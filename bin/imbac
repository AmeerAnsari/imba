#!/usr/bin/env node

var path = require('path');
var fs = require('fs');
var lib  = path.join(path.dirname(fs.realpathSync(__filename)), '../lib');
// var cli = require(lib + '/compiler/cli');
var args = process.argv;
// need to parse options instead
// var file = cli.sourcefileForPath(args[2]);
// var helpers = require(lib + '/compiler/helpers');
// var compiler = require(lib + '/compiler/compiler');

var imbac = require(lib + '/cli/imbac');

imbac.run(args.slice(2));


/*
var o = helpers.parseArgs(args,{
	alias: {
		o: 'output',
		s: 'stdio',
		b: 'bare',
		p: 'print'
	},
	group: ['source-map']
});

var dest = null;
var res = null;

console.log(o);

if(o.output){
	dest = path.resolve(process.cwd(),o.output);
	dest = path.normalize(dest);
	console.log('dest',dest);
}

if(dest) {
	// if passing in a directory, add js file to dest
	var stat = fs.statSync(dest);
	if(stat.isDirectory()){
		dest = path.resolve(dest,file.name().replace(/\.imba$/,'.js'));
	}
}

if(o.A) {
	file.analyze({entities: o.entities, scopes: true, loglevel: 0},function(meta){
		console.log('Analysis!');
		res = meta;
		process.stdout.write(JSON.stringify(res));
	});

} else if(o.T) {
	cli.printTokens(file.tokens());

} else {
	var out = file.compile(o);

	if(out.error){
		process.stderr.write(out.error.message);
	} else {

		if(o.sourceMap && out.sourcemap){
			var base64 = new Buffer(JSON.stringify(out.sourcemap)).toString("base64")
			out.js = out.js + "\n//# sourceMappingURL=data:application/json;base64," + base64;
		}

		if(o.print) {
			process.stdout.write(out.js);
		}

		if(dest){
			fs.writeFileSync(dest,out.js);
		} else {
			// process.stdout.write(out.js);
		}
	}
}

*/