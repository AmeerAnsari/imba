!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.PERF=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function(){


	var NODES, CLASSES;
	
	
	module.exports.NODES = NODES = "# TODO Create Expression - make all expressions inherit from these?\n\nextern parseInt\n\nvar helpers = require './helpers'\n\nexport var AST = {}\n\n# Helpers for operators\nexport var OP = do |op, left, right, opts|\n\tvar opstr = String(op)\n\n\tif opstr == '.'\n\t\t# Be careful\n\t\tif right isa String\n\t\t\tright = Identifier.new(right)\n\n\t\tAccess.new(op,left,right)\n\telif opstr == '='\n\t\tif left isa Tuple\n\t\t\t# p \"catching tuple-assign OP\"\n\t\t\treturn TupleAssign.new(op,left,right)\n\t\tAssign.new(op,left,right)\n\telif opstr in ['?=','||=','&&=']\n\t\tConditionalAssign.new(op,left,right)\n\telif opstr  == '=<'\n\t\tAsyncAssign.new('=',left,Await.new(right))\n\telif opstr in ['+=','-=','*=','/=','^=','%=']\n\t\tCompoundAssign.new(op,left,right)\n\telif opstr == 'instanceof'\n\t\tInstanceOf.new(op,left,right)\n\telif opstr == 'in'\n\t\tIn.new(op,left,right)\n\telif opstr == 'typeof'\n\t\tTypeOf.new(op,left,right)\n\telif opstr == 'delete'\n\t\tDelete.new(op,left,right)\n\telif opstr in ['--','++','!','√'] # hmm\n\t\tUnaryOp.new(op,left,right)\n\telif opstr in ['>','<','>=','<=','==','===','!=','!==']\n\t\tComparisonOp.new(op,left,right)\n\telif opstr in ['∩','∪']\n\t\tMathOp.new(op,left,right)\n\telif opstr in ['..','...']\n\t\tRange.new(op,left,right)\n\telse\n\t\tOp.new(op,left,right)\n\nLIT = do |val|\n\tLiteral.new(val)\n\nSYM = do |val|\n\tSymbol.new(val)\n\nIF = do |cond,body,alt|\n\tvar node = If.new(cond,body)\n\tnode.addElse(alt) if alt\n\tnode\n\nFN = do |pars,body|\n\tFunc.new(pars,body)\n\nCALL = do |callee,pars = []|\n\t# possibly return instead(!)\n\tCall.new(callee,pars)\n\nCALLSELF = do |name,pars = []|\n\tvar ref = Identifier.new(name)\n\tCall.new(OP('.',SELF,ref),pars)\n\nBLOCK = do\n\tBlock.wrap([]:slice.call(arguments))\n\nWHILE = do |test,code|\n\tWhile.new(test).addBody(code)\n\nSPLAT = do |value|\n\tif value isa Assign\n\t\t# p \"WARN\"\n\t\tvalue.left = Splat.new(value.left)\n\t\treturn value\n\telse\n\t\tSplat.new(value)\n\t\t# not sure about this\n\nOP.ASSIGNMENT = [ \"=\" , \"+=\" , \"-=\" , \"*=\" , \"/=\" , \"%=\", \"<<=\" , \">>=\" , \">>>=\", \"|=\" , \"^=\" , \"&=\" ]\nOP.LOGICAL = [ \"||\" , \"&&\" ]\nOP.UNARY = [ \"++\" , \"--\" ]\n\nLOC = do |loc|\n\tself\n\n# hmmm\ndef c__ obj\n\ttypeof obj == 'string' ? obj : obj.c\n\ndef num__ num\n\tNum.new(num)\n\ndef str__ str\n\t# should pack in token?!?\n\tStr.new(str)\n\ndef blk__ obj\n\tobj isa Array ? Block.wrap(obj) : obj\n\ndef sym__ obj\n\t# console.log \"sym {obj}\"\n\thelpers.symbolize(String(obj))\n\ndef cary__ ary\n\tary.map(|v| typeof v == 'string' ? v : v.c )\n\ndef AST.dump obj, key\n\tif obj isa Array\n\t\tobj.map do |v| v && v:dump ? v.dump(key) : v\n\telif obj and obj:dump\n\t\tobj.dump\n\n\ndef compact__ ary\n\tif ary isa ListNode\n\t\t# console.log \"IS LISTNODE\"\n\t\treturn ary.compact\n\n\tary.filter do |v| v != undefined && v != nil\n\ndef flatten__ ary, compact = no\n\tvar out = []\n\tary.forEach do |v| v isa Array ? out:push.apply(out,flatten__(v)) : out.push(v)\n\treturn out\n\t\ndef AST.parse str, opts = {}\n\tvar indent = str.match(/\\t+/)[0]\n\tImba.parse(str,opts)\n\ndef AST.inline str, opts = {}\n\tparse(str,opts).body\n\ndef AST.node typ, pars\n\tif typ == 'call'\n\t\tif pars[0].c == 'return'\n\t\t\tpars[0] = 'tata'\t\n\t\tCall.new(pars[0],pars[1],pars[2])\n\n\ndef AST.escapeComments str\n\treturn '' unless str\n\treturn str\n\t# var v = str.replace(/\\\\n/g,'\\n')\n\t# v.split(\"\\n\").join(\"\\n\")\n\t# v.split(\"\\n\").map(|v| v ? \"// {v}\" : v).join(\"\\n\")\n\nexport class Indentation\n\n\tprop open\n\tprop close\n\n\tdef initialize a,b\n\t\t@open = a or 1\n\t\t@close = b or 1\n\t\tself\n\n\t# should rather parse and extract the comments, no?\n\tdef wrap str, o\n\t\tvar pre = @open:pre\n\t\tvar post = @open:post\n\t\tvar esc = AST:escapeComments\n\n\t\t# the first newline should not be indented?\n\t\tstr = esc(post).replace(/^\\n/,'') + str\n\t\tstr = str.replace(/^/g,\"\\t\").replace(/\\n/g,\"\\n\\t\").replace(/\\n\\t$/g,\"\\n\")\n\n\t\tstr = esc(pre) + '\\n' + str\n\t\t# only add br if needed\n\t\tstr = str + '\\n' unless str[str:length - 1] == '\\n'\n\t\t# if o and o:braces\n\t\t# \tstr = '{' + str + '}'\n\n\t\treturn str\n\t\t\nINDENT = Indentation.new\n\nexport class Stack\n\n\tprop loglevel\n\tprop nodes\n\tprop scopes\n\n\tdef initialize\n\t\t@nodes = []\n\t\t@scoping = []\n\t\t@scopes = [] # for analysis - should rename\n\t\t@loglevel = 3\n\n\tdef addScope scope\n\t\t@scopes.push(scope)\n\t\tself\n\n\tdef traverse node\n\t\tself\n\n\tdef push node\n\t\t@nodes.push(node)\n\t\t# not sure if we have already defined a scope?\n\t\tself\n\n\tdef pop node\n\t\t@nodes.pop(node)\n\t\tself\n\n\tdef parent\n\t\t@nodes[@nodes:length - 2]\n\n\tdef current\n\t\t@nodes[@nodes:length - 1]\n\n\tdef up test\n\t\ttest ||= do |v| !(v isa VarOrAccess)\n\n\t\tif test:prototype isa Node\n\t\t\tvar typ = test\n\t\t\ttest = do |v| v isa typ\n\n\t\tvar i = @nodes:length - 1\n\t\twhile i >= 0\n\t\t\tvar node = @nodes[i]\n\t\t\treturn node if test(node)\n\t\t\ti -= 1\n\t\treturn nil\n\n\tdef relative node, offset = 0\n\t\tvar idx = @nodes.indexOf(node)\n\t\tidx >= 0 ? @nodes[idx + offset] : nil\n\n\tdef scope lvl = 0\n\t\tvar i = @nodes:length - 1 - lvl\n\t\twhile i >= 0\n\t\t\tvar node = @nodes[i]\n\t\t\treturn node.@scope if node.@scope\n\t\t\ti -= 1\n\t\treturn nil\n\n\tdef scopes\n\t\t# include deeper scopes as well?\n\t\tvar scopes = []\n\t\tvar i = @nodes:length - 1\n\t\twhile i >= 0\n\t\t\tvar node = @nodes[i]\n\t\t\tscopes.push(node.@scope) if node.@scope\n\t\t\ti -= 1\n\t\treturn scopes\n\n\tdef method\n\t\tup(MethodDeclaration)\n\n\tdef isExpression\n\t\tvar i = @nodes:length - 1\n\t\twhile i >= 0\n\t\t\tvar node = @nodes[i]\n\t\t\t# why are we not using isExpression here as well?\n\t\t\tif node isa Code or node isa Loop\n\t\t\t\treturn false\n\t\t\tif node.isExpression\n\t\t\t\treturn true\n\t\t\t# probably not the right test - need to be more explicit\n\t\t\ti -= 1\n\t\treturn false\n\n\tdef toString\n\t\t\"Stack({@nodes.join(\" -> \")})\"\n\n\tdef scoping\n\t\t@nodes.filter(|n| n.@scope ).map(|n| n.@scope )\n\n# Lots of globals -- really need to deal with one stack per file / context\nSTACK = Stack.new\n\nexport class Node\n\n\tprop o\n\tprop options\n\tprop traversed\n\tprop statement\n\n\tdef safechain\n\t\tno\n\n\tdef dom\n\t\tvar name = \"ast_\" + self:constructor:name.replace(/([a-z])([A-Z])/g,\"$1_$2\").toLowerCase\n\t\t# p \"try to get the dom-node for this ast-node\",name\n\t\tif Imba.TAGS[name]\n\t\t\tvar node = Imba.tag(name)\n\t\t\tnode.bind(self).build\n\t\t\treturn node\n\t\telse\n\t\t\treturn \"[{name}]\"\n\n\tdef p\n\t\t# hmm\n\t\t# allow controlling this from commandline\n\t\tif STACK.loglevel > 0\n\t\t\tconsole.log(*arguments)\n\t\tself\n\n\tdef initialize\n\t\tself\n\n\tdef set obj\n\t\t@options ||= {}\n\t\tfor own k,v of obj\n\t\t\t@options[k] = v\n\t\tself\n\n\t# get and set\n\tdef option key, val\n\t\tif val != undefined\n\t\t\t@options ||= {}\n\t\t\t@options[key] = val\n\t\t\treturn self\n\n\t\t@options && @options[key]\n\n\tdef configure obj\n\t\tset(obj)\n\n\tdef region\n\t\t[]\n\n\tdef loc\n\t\t[]\n\n\tdef toAST\n\t\tself\n\n\tdef compile\n\t\tself\n\n\tdef visit\n\t\tself\n\n\tdef stack\n\t\tSTACK\n\n\tdef traverse o = {}, up, key, index\n\t\treturn self if @traversed\n\t\t@traversed = yes\n\t\tSTACK.push self\n\t\tvisit(STACK)\n\t\tSTACK.pop self\n\t\treturn self\n\n\tdef inspect\n\t\t{type: self:constructor.toString}\n\n\tdef js\n\t\t\"NODE\"\n\n\tdef toString\n\t\t\"{self:constructor:name}\"\n\n\t# swallow might be better name\n\tdef consume node\n\t\tif node isa PushAssign\n\t\t\treturn PushAssign.new(node.op,node.left,self)\n\n\t\tif node isa Assign\n\t\t\t# p \"consume assignment\".cyan\n\t\t\t# node.right = self\n\t\t\treturn OP(node.op,node.left,self)\n\t\telif node isa Op\n\t\t\treturn OP(node.op,node.left,self)\n\t\telif node isa Return\n\t\t\t# p \"consume return\".cyan\n\t\t\treturn Return.new(self)\n\t\treturn self\n\n\tdef toExpression\n\t\t@expression = true\n\t\tself\n\n\tdef forceExpression\n\t\t@expression = true\n\t\tself\n\n\tdef isExpressable\n\t\ttrue\n\n\tdef isExpression\n\t\t@expression || false\n\n\tdef hasSideEffects\n\t\ttrue\n\n\tdef isUsed\n\t\ttrue\n\t\t\n\tdef shouldParenthesize\n\t\tfalse\n\n\tdef block\n\t\tthrow SyntaxError.new(\"dont call\")\n\t\tBlock.wrap([self])\n\n\tdef node\n\t\tself\n\n\tdef scope__\n\t\tSTACK.scope\n\n\tdef up\n\t\tSTACK.parent\n\n\tdef util\n\t\tUtil\n\n\tdef receiver\n\t\tself\n\n\tdef addExpression expr\n\t\t# might be better to nest this up after parsing is done?\n\t\t# p \"addExpression {self} <- {expr}\"\n\t\tvar node = ExpressionBlock.new([self])\n\t\treturn node.addExpression(expr)\n\n\n\tdef indented a,b\n\t\t# this is a _BIG_ hack\n\t\tif b isa Array\n\t\t\t# console.log \"indented array?\", b[0]\n\t\t\tadd(b[0])\n\t\t\tb = b[1]\n\n\t\t# if indent and indent.match(/\\:/)\n\t\t@indented = [a,b]\n\t\t@indentation ||= a and b ? Indentation.new(a,b) : INDENT\n\t\tself\n\n\tdef prebreak term = '\\n'\n\t\t# in options instead?\n\t\t# console.log \"prebreak!!!!\"\n\t\t# @prebreak = @prebreak or term\n\t\tself\n\n\tdef invert\n\t\treturn OP('!',self)\n\n\tdef cache o = {}\n\t\t@cache = o\n\t\to:var = scope__.temporary(self,o)\n\t\to:lookups = 0\n\t\t# o:lookups = 0\n\t\tself\n\n\tdef cachevar\n\t\t@cache && @cache:var\n\n\tdef decache\n\t\tif @cache\n\t\t\tcachevar.free\n\t\t\t@cache = nil # hmm, removing the cache WARN\n\t\tself\n\n\t# is this without side-effects? hmm - what does it even do?\n\tdef predeclare\n\t\tif @cache\n\t\t\tscope__.vars.swap(@cache:var,self)\n\t\tself\n\n\t# the \"name-suggestion\" for nodes if they need to be cached\n\tdef alias\n\t\tnil\n\n\tdef warn text, opts = {}\n\t\topts:message = text\n\t\topts:loc ||= loc\n\t\tscope__.root.warn opts\n\t\tself\n\n\tdef c o\n\t\tvar s = STACK\n\t\tvar ch = @cache\n\t\treturn c_cached(ch) if ch and ch:cached\n\n\t\ts.push(self)\n\t\tforceExpression if o && o:expression\n\n\t\tif o and o:indent\n\t\t\t@indentation ||= INDENT\n\n\t\tvar out = js(s,o)\n\n\t\tvar paren = shouldParenthesize\n\t\t\n\t\tif var indent = @indentation\n\t\t\tout = indent.wrap(out,o)\n\n\t\tout = \"({out})\" if paren\n\t\tout = '{' + out + '}' if o and o:braces\n\n\t\ts.pop(self)\n\n\t\tif ch = @cache\n\t\t\tout = \"{ch:var.c}={out}\" unless ch:manual\n\t\t\tvar par = s.current\n\t\t\tout = '(' + out + ')' if par isa Access || par isa Op # others? # \n\t\t\tch:cached = yes\n\n\t\t# most of these should never be needed?\n\t\t# where?!?\n\t\tif @temporary && @temporary:length\n\t\t\t@temporary.map do |temp| temp.decache\n\n\t\treturn out\n\n\tdef c_cached cache\n\t\tcache:lookups++\n\t\tcache:var.free if cache:uses == cache:lookups\n\t\treturn cache:var.c # recompile every time??\n\t\t\n\nexport class Expression < Node\n\nexport class ValueNode < Node\n\n\tprop value\n\n\tdef initialize value\n\t\t@value = load(value)\n\n\tdef load value\n\t\tvalue\n\n\tdef js\n\t\ttypeof @value == 'string' ? @value : @value.c\n\n\tdef visit\n\t\t# hmm - is this not optimized?\n\t\t@value.traverse if @value isa Node #  && @value:traverse\n\t\tself\n\n\tdef region\n\t\t@value.@region\n\nexport class Statement < ValueNode\n\n\tdef isExpressable\n\t\treturn no\n\t\t\n\tdef statement\n\t\treturn true\n\n\nexport class Meta < ValueNode\n\nexport class Comment < Meta\n\n\tdef c o\n\t\tvar v = @value.@value # hmm \n\t\tif o and o:expression or v.match(/\\n/) # multiline?\n\t\t\t\"/*{v}*/\"\n\t\telse\n\t\t\t\"// {v}\"\n\n\nexport class Terminator < Meta\n\n\tdef c\n\t\treturn @value.c\n\t\t# var v = value.replace(/\\\\n/g,'\\n')\n\t\tv # .split()\n\t\t# v.split(\"\\n\").map(|v| v ? \" // {v}\" : v).join(\"\\n\")\n\nexport class Newline < Terminator\n\n\tdef initialize v\n\t\t@value = v or '\\n'\n\n\tdef c\n\t\t@value.c\n\t\t\n\n# weird place?\nexport class Index < ValueNode\n\n\tdef js\n\t\t@value.c\n\nexport class ListNode < Node\n\n\tprop nodes\n\n\tdef initialize list = [], options = {}\n\t\t@nodes = load(list)\n\t\t@options = options\n\t\n\t# PERF acces @nodes directly?\n\tdef list\n\t\t@nodes\n\n\tdef compact\n\t\t@nodes = compact__(@nodes)\n\t\tself\n\n\tdef load list\n\t\tlist\n\n\tdef concat other\n\t\t# need to store indented content as well?\n\t\t@nodes = nodes.concat(other isa Array ? other : other.nodes)\n\t\tself\n\n\tdef swap item, other\n\t\tvar idx = indexOf(item)\n\t\tnodes[idx] = other if idx >= 0\n\t\tself\n\n\tdef push item\n\t\tnodes.push(item)\n\t\tself\n\n\tdef unshift item, br\n\t\tnodes.unshift(BR) if br\n\t\tnodes.unshift(item)\n\t\tself\n\n\t# test\n\tdef slice a, b\n\t\tself:constructor.new(@nodes.slice(a,b))\n\n\tdef add item\n\t\tpush(item)\n\t\tself\n\n\tdef break br, pre = no\n\t\t# console.log \"breaking block! ({br})\"\n\t\t# should just accept regular terminators no?\n\t\t# console.log \"BREAKING {br}\"\n\t\tbr = Terminator.new(br) if typeof br == 'string' # hmmm?\n\t\tpre ? unshift(br) : push(br)\n\t\tself\n\n\tdef some cb\n\t\tnodes.some(cb)\n\n\tdef every cb\n\t\tnodes.every(cb)\n\n\tdef filter cb\n\t\tif cb:prototype isa Node\n\t\t\tvar ary = []\n\t\t\tnodes.forEach do |n| ary.push(n) if n isa cb\n\t\t\treturn ary\n\n\t\tnodes.filter(cb)\n\n\tdef pluck cb\n\t\tvar item = filter(cb)[0]\n\t\tremove(item) if item\n\t\treturn item\n\n\tdef indexOf item\n\t\tnodes.indexOf(item)\n\n\tdef index i\n\t\tnodes[i]\t\n\n\tdef remove item\n\t\tvar idx = list.indexOf(item)\n\t\tlist.splice(idx, 1) if idx >= 0\n\t\tself\n\n\tdef first\n\t\tlist[0]\n\t\t\n\t# def last\n\t#\tlist[list:length - 1]\n\n\tdef last\n\t\tvar i = @nodes:length\n\t\twhile i\n\t\t\ti = i - 1\n\t\t\tvar v = @nodes[i]\n\t\t\treturn v unless v isa Meta\n\t\treturn nil\n\n\tdef map fn\n\t\tlist.map(fn)\n\n\tdef forEach fn\n\t\tlist.forEach(fn)\n\n\tdef remap fn\n\t\t@nodes = map(fn)\n\t\tself\n\n\tdef count\n\t\tlist:length\n\n\tdef replace original, replacement\n\t\tvar idx = nodes.indexOf(original)\n\t\tnodes[idx] = replacement if idx >= 0\n\t\tself\n\n\n\tdef visit\n\t\t@nodes.forEach do |node|\n\t\t\t# console.log \"traverse node {node}\"\n\t\t\tnode.traverse\n\t\tself\n\n\tdef isExpressable\n\t\treturn no unless nodes.every(|v| v.isExpressable )\n\t\treturn yes\n\n\tdef toArray\n\t\t@nodes\n\n\tdef delimiter\n\t\t@delimiter or \",\"\n\n\tdef js o, delim: delimiter, indent: @indentation, nodes: nodes\n\t\t# var delim = delimiter\n\t\tvar express = delim != ';'\n\t\tvar shouldDelim = no\n\t\tvar nodes = compact__(nodes)\n\t\tvar last = last\n\t\tvar realLast = nodes[nodes:length - 1]\n\t\t# need to find the last node that is not a comment or newline?\n\n\t\tvar parts = nodes.map do |arg|\n\t\t\tvar out = typeof arg == 'string' ? arg : arg.c(expression: express)\n\t\t\t# if var br = arg.@prebreak\n\t\t\t# \tindent = yes # force indentation if one item is indented for now\n\t\t\t# \tout = br.replace(/\\\\n/g,\"\\n\") + out #  '\\n' + arg.@prebreak + out \n\t\t\t# \tconsole.log \"prebreak!!\"\n\t\t\t#\tout = delim + out if shouldDelim\n\t\t\t# else\n\t\t\t#\tout = delim + \" \" + out if shouldDelim\n\n\t\t\tif arg isa Meta\n\t\t\t\ttrue\n\t\t\t\t# console.log \"argument is a comment!\"\n\t\t\t\t# shouldDelim = no\n\t\t\telse\n\t\t\t\t# comment as well?\n\t\t\t\t# shouldDelim = yes\n\t\t\t\tout = out + delim if !express or arg != last\n\t\t\tout\n\n\t\treturn parts.join(\"\")\n\t\t\n\nexport class ArgList < ListNode\n\n\tdef hasSplat\n\t\tlist.some do |v| v isa Splat\n\n\tdef delimiter\n\t\t\",\"\n\n\nexport class AssignList < ArgList\t\n\t# def c o\n\t# \t# p \"compile arglist {self}\"\n\t# \tsuper.c o\n\n\tdef concat other\n\t\tif @nodes:length == 0 and other isa AssignList\n\t\t\t# console.log \"return the other one(!)\",other.@indented[0]\n\t\t\treturn other\n\t\telse\n\t\t\tsuper\n\t\t# need to store indented content as well?\n\t\t# @nodes = nodes.concat(other isa Array ? other : other.nodes)\n\t\tself\n\n\nexport class Block < ListNode\t\n\t\n\tprop head\n\n\n\tdef self.wrap ary\n\t\tunless ary isa Array\n\t\t\tthrow SyntaxError.new(\"what\")\n\t\tary:length == 1 && ary[0] isa Block ? ary[0] : Block.new(ary)\n\n\n\tdef visit\n\t\t# @indentation ||= INDENT\n\n\t\tif @prebreak # hmm\n\t\t\t# are we sure?\n\t\t\t# console.log \"PREBREAK IN BLOCK SHOULD THROW\"\n\t\t\tfirst and first.prebreak(@prebreak)\n\t\tsuper\n\t\t\n\n\tdef push item\n\t\tnodes.push(item)\n\t\tself\n\n\n\tdef block\n\t\tself\n\n\n\tdef loc\n\t\tif var opt = option(:ends)\n\t\t\t# p \"location is\",opt\n\t\t\tvar a = opt[0].loc\n\t\t\tvar b = opt[1].loc\n\n\t\t\tp \"no loc for {opt[0]}\" unless a\n\t\t\tp \"no loc for {opt[1]}\" unless b\n\n\t\t\t[a[0],b[1]]\n\t\telse\n\t\t\t[0,0]\n\n\n\tdef initialize expr = []\n\t\tself.nodes = compact__(flatten__(expr)) or []\n\t\t\n\n\t# go through children and unwrap inner nodes\n\tdef unwrap\n\t\tvar ary = []\n\t\tfor node,i in nodes\n\t\t\tif node isa Block\n\t\t\t\t# p \"unwrapping inner block\"\n\t\t\t\tary:push.apply(ary,node.unwrap)\n\t\t\telse\n\t\t\t\tary.push(node)\n\t\treturn ary\n\n\n\t# This is just to work as an inplace replacement of nodes.coffee\n\t# After things are working okay we'll do bigger refactorings\n\tdef compile o = {}\n\t\tvar root = Root.new(self,o)\n\t\troot.compile(o)\n\n\n\t# Not sure if we should create a separate block?\n\tdef analyze o = {}\n\t\t# p \"analyzing block!!!\",o\n\t\tself\n\n\n\tdef js o, opts\n\t\tvar l = nodes:length\n\t\t# var filter = \n\t\tvar filter = (|n| n != null && n != undefined && n != EMPTY)\n\t\tvar ast = compact__(flatten__(nodes)).filter(|n| n != null && n != undefined && n != EMPTY)\n\t\tvar express = isExpression or o.isExpression or (option(:express) and isExpressable)\n\t\treturn null if ast:length == 0\n\n\t\t# return super(o, delim: ';', indent: no)\n\n\t\tif express\n\t\t\treturn super(o,delim: ',', nodes: ast)\n\n\t\t# should probably delegate to super for ; as well\n\t\t# else\n\t\t# \treturn super(o,delim: ';', nodes: ast)\n\t\t# return ast.c.flatten__.compact.join(\", \")\n\n\t\tvar compile = do |node,i|\n\t\t\t# if node isa Array\n\t\t\t# \tconsole.log \"was array initially\"\n\n\t\t\tvar out = typeof node == 'string' ? node : (node ? node.c : \"\")\n\t\t\treturn null if out == \"\"\n\n\t\t\t# FIXME should never happen\n\t\t\t# we need to handle it in a better way - results in ugly output\n\t\t\tif out isa Array\n\n\t\t\t\t# really??\n\t\t\t\t# console.log \"out is array\"\n\t\t\t\tout = compact__(flatten__(out)).filter(filter).join(\";\\n\")\n\t\t\t# console.log \"compiled {node} {out}\"\n\t\t\tvar hasSemiColon = out.match(/;(\\s*\\/\\/.*)?[\\n\\s\\t]*$/) # out[out:length - 1] == \";\"\n\n\t\t\tout += \";\" unless hasSemiColon or node isa Meta\n\t\t\t\n\t\t\t# if var br = node.@prebreak\n\t\t\t# \tconsole.log \"br prebreak\"\n\t\t\t# \tout = br.replace(/\\\\n/g,\"\\n\") + out\n\t\t\t# hmm\n\t\t\treturn out\n\n\t\tast = ast.map(compile)\n\n\t\t# now add the head items as well\n\t\tif @head\n\t\t\tvar prefix = []\n\t\t\tflatten__(@head).forEach do |item|\n\t\t\t\tvar out = compile(item)\n\t\t\t\tprefix.push(out + '\\n') if out\n\n\t\t\tast = prefix.concat(ast)\n\t\t\t# var ln = node.@newlines or 1\n\t\t\t# c += Array(ln + 1).join(\"\\n\") # \"\\n\"\n\n\t\tast = compact__(ast).filter(filter).join(\"\") # .replace(/[\\s\\n]+$/,'')  # hmm really?\n\n\t\t# @indentation ? @indentation.wrap(ast,opts) : ast\n\n\n\t# Should this create the function as well?\n\tdef defers original, replacement\n\t\tvar idx = nodes.indexOf(original)\n\t\tnodes[idx] = replacement if idx >= 0\n\t\t# now return the nodes after this\n\t\treplacement.@prebreak ||= original.@prebreak # hacky\n\t\tvar rest = nodes.splice(idx + 1)\n\t\treturn rest\n\n\n\tdef consume node\n\t\tif node isa TagTree # special case?!?\n\t\t\t# what if there is only one node?\n\t\t\t# let all the inner nodes consume this\n\t\t\tnodes = nodes.map(|child| child.consume(node))\n\t\t\t# then wrap ourselves in an array as well(!)\n\t\t\t# nodes = [Arr.new(nodes)] if nodes:length > 1\n\t\t\tnodes = [Arr.new(ArgList.new(nodes))] if nodes:length > 1\n\t\t\t\n\t\t\t# hmmm\n\t\t\treturn self\n\n\t\t# can also return super if it is expressable, but should we really?\n\t\tif var before = last\n\t\t\tvar after = before.consume(node)\n\t\t\tif after != before\n\t\t\t\t\n\t\t\t\t# p \"replace node in block\"\n\t\t\t\treplace(before,after)\n\t\t# really?\n\t\treturn self\n\n\n\tdef isExpressable\n\t\treturn no unless nodes.every(|v| v.isExpressable )\n\t\treturn yes\n\n\n\tdef isExpression\n\t\toption(:express) || super.isExpression\n\n\n# this is almost like the old VarDeclarations but without the values\nexport class VarBlock < ListNode\n\n\n\t# TODO All these inner items should rather be straight up literals\n\t# or basic localvars - without any care whatsoever about adding var to the\n\t# beginning etc. \n\tdef addExpression expr\n\t\t# p \"addExpression {self} <- {expr}\"\n\n\t\tif expr isa Assign\n\t\t\taddExpression(expr.left) # make sure this is a valid thing?\n\t\t\t# make this into a tuple instead\n\t\t\t# possibly fix this as well?!?\n\t\t\t# does not need to be a tuple?\n\t\t\treturn TupleAssign.new('=',Tuple.new(nodes),expr.right)\n\n\t\telif expr isa VarOrAccess\n\t\t\t# this is really a VarReference\n\t\t\tpush(VarReference.new(expr.value))\n\n\t\telif expr isa Splat && expr.node isa VarOrAccess\n\t\t\t# p \"is a splat - only allowed in tuple-assignment\"\n\t\t\texpr.value = VarReference.new(expr.node.value)\n\t\t\tpush(expr)\n\t\telse\n\t\t\tthrow \"VarBlock does not allow non-variable expressions\"\n\t\tself\n\n\n\tdef isExpressable\n\t\t# hmm, we would need to force-drop the variables, makes little sense\n\t\t# but, it could be, could just push the variables out?\n\t\tno\n\n\n\tdef js o\n\t\tvar code = compact__(flatten__(cary__(nodes)))\n\t\tcode = code.filter(|n| n != null && n != undefined && n != EMPTY)\n\t\treturn \"var {code.join(\",\")}\"\n\n\n\tdef consume node\n\t\t# It doesnt make much sense for a VarBlock to consume anything\n\t\t# it should probably return void for methods\n\t\treturn self\n\n\n# Could inherit from valueNode\nexport class Parens < ValueNode\n\n\t\t\n\tdef js o\n\t\tvar par = up\n\t\tvar v = @value\n\t\t# p \"Parens up {par} {o.isExpression}\"\n\n\t\tif par isa Block\n\t\t\t@noparen = yes unless o.isExpression\n\t\t\treturn v isa Array ? cary__(v) : v.c(expression: o.isExpression)\n\t\telse\n\t\t\treturn v isa Array ? cary__(v) : v.c(expression: yes)\n\n\n\tdef shouldParenthesize\n\t\t# no need to parenthesize if this is a line in a block\n\t\treturn no if @noparen #  or par isa ArgList\n\t\treturn yes\n\n\n\tdef prebreak br\n\t\tsuper(br)\n\t\t# hmm\n\t\t@value.prebreak(br) if @value\n\t\tself\n\n\n\tdef isExpressable\n\t\tvalue.isExpressable\n\n\n\tdef consume node\n\t\tvalue.consume(node)\n\n\n\n# Could inherit from valueNode\n# an explicit expression-block (with parens) is somewhat different\n# can be used to return after an expression\nexport class ExpressionBlock < ListNode\n\n\n\tdef visit\n\t\t# we need to see if this\n\t\tmap(|item| item.traverse)\n\t\tself\n\n\t\t\n\tdef c\n\t\tmap(|item| item.c).join(\",\")\n\n\n\tdef consume node\n\t\tvalue.consume(node)\n\n\n\tdef addExpression expr\n\t\t# Need to take care of the splat here to.. hazzle\n\t\tif expr.node isa Assign\n\t\t\t# p \"is assignment!\"\n\t\t\tpush(expr.left)\n\t\t\t# make this into a tuple instead\n\t\t\t# possibly fix this as well?!?\n\t\t\treturn TupleAssign.new('=',Tuple.new(nodes),expr.right)\n\t\telse\n\t\t\tpush(expr)\n\t\tself\n\n\n\n# STATEMENTS\n\nexport class Return < Statement\n\n\tprop value\n\n\tdef initialize v\n\t\t@value = v isa ArgList and v.count == 1 ? v.last : v\n\t\t# @prebreak = v and v.@prebreak # hmmm\n\t\t# console.log \"return?!? {v}\",@prebreak\n\t\t# if v isa ArgList and v.count == 1\n\t\treturn self\n\n\tdef visit\n\t\t@value.traverse if @value && @value:traverse\n\n\tdef js\n\t\tvar v = @value\n\n\t\tif v isa ArgList\n\t\t\treturn \"return [{v.c(expression: yes)}]\"\n\t\telif v\n\t\t\treturn \"return {v.c(expression: yes)}\"\n\t\telse\n\t\t\t\"return\"\n\n\tdef c\n\t\treturn super if !value or value.isExpressable\n\t\t# p \"return must cascade into value\".red\n\t\tvalue.consume(self).c\n\n\tdef consume node\n\t\treturn self\n\nexport class ImplicitReturn < Return\n\nexport class GreedyReturn < ImplicitReturn\n\n# cannot live inside an expression(!)\nexport class Throw < Statement\n\n\tdef js\n\t\t\"throw {value.c}\"\n\n\tdef consume node\n\t\t# ROADMAP should possibly consume to the value of throw and then throw?\n\t\treturn self\n\t\t\n\nexport class LoopFlowStatement < Statement\n\n\tprop literal\n\tprop expression\n\n\tdef initialize lit, expr\n\t\tself.literal = lit\n\t\tself.expression = expr # && ArgList.new(expr) # really?\n\n\tdef visit\n\t\texpression.traverse if expression\n\n\tdef consume node\n\t\t# p \"break/continue should consume?!\"\n\t\tself\n\n\tdef c\n\t\treturn super unless expression\n\t\t# get up to the outer loop\n\t\tvar _loop = STACK.up(Loop)\n\t\t# p \"found loop?\",_loop\n\n\t\t# need to fix the grammar for this. Right now it \n\t\t# is like a fake call, but should only care about the first argument\n\t\tvar expr = self.expression\n\n\t\tif _loop.catcher\n\t\t\texpr = expr.consume(_loop.catcher)\n\t\t\tvar copy = self:constructor.new(literal)\n\t\t\tBLOCK(expr,copy).c\n\t\telif expr\n\t\t\tvar copy = self:constructor.new(literal)\n\t\t\tBLOCK(expr,copy).c\n\t\telse\n\t\t\tsuper\n\t\t# return \"loopflow\"\n\t\t\n\nexport class BreakStatement < LoopFlowStatement\n\tdef js do \"break\"\n\nexport class ContinueStatement < LoopFlowStatement\n\tdef js do \"continue\"\n\nexport class DebuggerStatement < Statement\n\n\n\n\n\n# PARAMS\n\nexport class Param < Node\n\n\tprop name\n\tprop index\n\tprop defaults\n\tprop splat\n\tprop variable\n\n\t# what about object-params?\n\n\tdef initialize name, defaults, typ\n\t\t# could have introduced bugs by moving back to identifier here\n\t\t@name = name # .value # this is an identifier(!)\n\t\t@defaults = defaults\n\t\t@typ = typ\n\t\t@variable = null\n\n\tdef js\n\t\t# hmmz\n\t\treturn @variable.c if @variable\n\n\t\tif defaults\n\t\t\t\"if({name.c} == null) {name.c} = {defaults.c}\"\n\t\t# see if this is the initial declarator?\n\n\tdef visit\n\t\t# p \"VISIT PARAM {name}!\"\n\t\t# ary.[-1] # possible\n\t\t# ary.(-1) # possible\n\t\t# str(/ok/,-1)\n\t\t# scope.register(@name,self)\n\t\t# BUG The defaults should probably be looked up like vars\n\t\t@defaults.traverse if @defaults\n\t\tself.variable ||= scope__.register(name,self)\t\n\t\tself\n\n\tdef assignment\n\t\tOP('=',variable.accessor,defaults)\n\n\tdef isExpressable\n\t\t!defaults || defaults.isExpressable\n\t\t# p \"visiting param!!!\"\n\n\tdef dump\n\t\t{loc: loc}\n\n\tdef loc\n\t\t@name && @name.region\n\t\t\n\nexport class SplatParam < Param\n\n\tdef loc\n\t\t# hacky.. cannot know for sure that this is right?\n\t\tvar r = name.region\n\t\t[r[0] - 1,r[1]]\n\nexport class BlockParam < Param\n\n\tdef c\n\t\t\"blockparam\"\n\n\tdef loc\n\t\t# hacky.. cannot know for sure that this is right?\n\t\tvar r = name.region\n\t\t[r[0] - 1,r[1]]\n\n\nexport class OptionalParam < Param\n\nexport class NamedParam < Param\n\nexport class RequiredParam < Param\n\nexport class NamedParams < ListNode\n\n\tprop index\n\tprop variable\n\n\tdef load list\n\t\tvar load = (|k| NamedParam.new(k.key,k.value) )\n\t\tlist isa Obj ? list.value.map(load) : list\n\n\tdef visit\n\t\tvar s = scope__\n\t\t@variable ||= s.temporary(self, type: 'keypars')\n\t\t@variable.predeclared\n\n\t\t# this is a listnode, which will automatically traverse\n\t\t# and visit all children\n\t\tsuper\n\t\t# register the inner variables as well(!)\n\t\tself\n\n\tdef name\n\t\tvariable.c\n\n\tdef js\n\t\t\"namedpar\"\n\nexport class IndexedParam < Param\n\n\tprop parent\n\tprop subindex\n\n\tdef visit\n\t\t# p \"VISIT PARAM {name}!\"\n\t\t# ary.[-1] # possible\n\t\t# ary.(-1) # possible\n\t\t# str(/ok/,-1)\n\t\t# scope.register(@name,self)\n\t\t# BUG The defaults should probably be looked up like vars\n\t\tself.variable ||= scope__.register(name,self)\n\t\tself.variable.proxy(parent.variable,subindex)\n\t\tself\n\n\nexport class ArrayParams < ListNode\n\n\tprop index\n\tprop variable\n\n\tdef visit\n\t\tvar s = scope__\n\t\t@variable ||= s.temporary(self, type: 'keypars')\n\t\t@variable.predeclared\n\n\t\t# now when we loop through these inner params - we create the pars\n\t\t# with the correct name, but bind them to the parent\n\t\tsuper\n\n\tdef name\n\t\tvariable.c\n\n\tdef load list\n\t\treturn nil unless list isa Arr\n\t\t# p \"loading arrayparams\"\n\t\t# try the basic first\n\t\tunless list.splat\n\t\t\tlist.value.map do |v,i|\n\t\t\t\t# must make sure the params are supported here\n\t\t\t\t# should really not parse any array at all(!)\n\t\t\t\tvar name = v\n\t\t\t\tif v isa VarOrAccess\n\t\t\t\t\t# p \"varoraccess {v.value}\"\n\t\t\t\t\tname = v.value.value\n\t\t\t\t\t# this is accepted\n\t\t\t\tparse(name,v,i)\n\n\tdef parse name,child,i\n\t\tvar param = IndexedParam.new(name,nil)\n\n\t\tparam.parent = self\n\t\tparam.subindex = i\n\t\tparam\n\n\tdef head ast\n\t\t# \"arrayparams\"\n\t\tself\n\nexport class ParamList < ListNode\n\n\tprop splat\n\tprop block\n\n\tdef at index, force = no, name = nil\n\t\tif force\n\t\t\tadd(Param.new(count == index && name || \"_{count}\")) until count > index\n\t\t\t# need to visit at the same time, no?\n\t\tlist[index]\n\n\tdef visit\n\t\t@splat = filter(|par| par isa SplatParam)[0]\n\t\tvar blk = filter(BlockParam)\n\n\t\tif blk:length > 1\n\t\t\tblk[1].warn \"a method can only have one &block parameter\"\n\n\t\telif blk[0] && blk[0] != last\n\t\t\tblk[0].warn \"&block must be the last parameter of a method\"\n\t\t\t# warn \"&block must be the last parameter of a method\", blk[0]\n\n\t\t# add more warnings later(!)\n\t\t# should probably throw error as well to stop compilation\n\n\t\t# need to register the required-pars as variables\n\t\tsuper\n\n\tdef js o\n\t\treturn EMPTY if count == 0\n\t\treturn head(o) if o.parent isa Block\n\n\t\t# items = map(|arg| arg.name.c ).compact\n\t\t# return null unless items[0]\n\n\t\tif o.parent isa Code\n\t\t\t# remove the splat, for sure.. need to handle the other items as well\n\t\t\t# this is messy with references to argvars etc etc. Fix\n\t\t\tvar pars = nodes\n\t\t\t# pars = filter(|arg| arg != @splat && !(arg isa BlockParam)) if @splat\n\t\t\tpars = filter(|arg| arg isa RequiredParam or arg isa OptionalParam) if @splat\n\t\t\tcompact__(pars.map(|arg| c__(arg.name) )).join(\",\")\n\t\telse\n\t\t\tthrow \"not implemented paramlist js\"\n\t\t\t\"ta\" + compact__(map(|arg| arg.c )).join(\",\")\n\n\tdef head o\n\t\tvar reg = []\n\t\tvar opt = []\n\t\tvar blk = nil\n\t\tvar splat = nil\n\t\tvar named = nil\n\t\tvar arys = []\n\t\tvar signature = []\n\t\tvar idx = 0\n\n\t\tnodes.forEach do |par,i|\n\t\t\tpar.index = idx\n\t\t\tif par isa NamedParams\n\t\t\t\tsignature.push('named')\n\t\t\t\tnamed = par\n\t\t\telif par isa OptionalParam \n\t\t\t\tsignature.push('opt')\n\t\t\t\topt.push(par)\n\t\t\telif par isa BlockParam\n\t\t\t\tsignature.push('blk')\n\t\t\t\tblk = par\n\t\t\telif par isa SplatParam\n\t\t\t\tsignature.push('splat')\n\t\t\t\tsplat = par\n\t\t\t\tidx -= 1 # this should really be removed from the list, no?\n\t\t\telif par isa ArrayParams\n\t\t\t\tarys.push(par)\n\t\t\t\tsignature.push('ary')\n\t\t\telse\n\t\t\t\tsignature.push('reg')\n\t\t\t\treg.push(par)\n\t\t\tidx++\n\n\t\tif named\n\t\t\tvar namedvar = named.variable\n\n\t\t# var opt = nodes.filter(|n| n isa OptionalParam)\n\t\t# var blk = nodes.filter(|n| n isa BlockParam)[0]\n\t\t# var splat = nodes.filter(|n| n isa SplatParam)[0]\n\n\t\t# simple situation where we simply switch\n\t\t# can probably optimize by not looking at arguments at all\n\t\tvar ast = []\n\t\tvar isFunc = do |js| \"typeof {js} == 'function'\"\n\n\t\t# This is broken when dealing with iframes anc XSS scripting\n\t\t# but for now it is the best test for actual arguments\n\t\t# can also do constructor.name == 'Object'\n\t\tvar isObj = do |js| \"{js}.constructor === Object\"\n\t\tvar isntObj = do |js| \"{js}.constructor !== Object\"\n\t\t# should handle some common cases in a cleaner (less verbose) manner\n\t\t# does this work with default params after optional ones? Is that even worth anything?\n\t\t# this only works in one direction now, unlike TupleAssign\n\n\t\t# we dont really check the length etc now -- so it is buggy for lots of arguments\n\n\t\t# if we have optional params in the regular order etc we can go the easy route\n\t\t# slightly hacky now. Should refactor all of these to use the signature?\n\t\tif !named && !splat && !blk && opt:length > 0 && signature.join(\" \").match(/opt$/)\n\t\t\tfor par,i in opt\n\t\t\t\tast.push \"if({par.name.c} === undefined) {par.name.c} = {par.defaults.c}\"\n\n\t\t\n\t\telif named && !splat && !blk && opt:length == 0 # and no block?!\n\t\t\t# different shorthands\n\t\t\t# if named\n\t\t\tast.push \"if(!{namedvar.c}||{isntObj(namedvar.c)}) {namedvar.c} = \\{\\}\"\n\n\t\telif blk && opt:length == 1 && !splat && !named\n\t\t\tvar op = opt[0]\n\t\t\tvar opn = op.name.c\n\t\t\tvar bn = blk.name.c\n\t\t\tast.push \"if({bn}==undefined && {isFunc(opn)}) {bn} = {opn},{opn} = {op.defaults.c}\"\n\n\t\telif blk && named && opt:length == 0 && !splat\n\t\t\tvar bn = blk.name.c\n\t\t\tast.push \"if({bn}==undefined && {isFunc(namedvar.c)}) {bn} = {namedvar.c},{namedvar.c} = \\{\\}\"\n\t\t\tast.push \"else if(!{namedvar.c}||{isntObj(namedvar.c)}) {namedvar.c} = \\{\\}\"\n\n\t\telif opt:length > 0 || splat # && blk  # && !splat\n\n\t\t\tvar argvar = scope__.temporary(self, type: 'arguments').predeclared.c\n\t\t\tvar len = scope__.temporary(self, type: 'counter').predeclared.c\n\n\t\t\tvar last = \"{argvar}[{len}-1]\"\n\t\t\tvar pop = \"{argvar}[--{len}]\"\n\t\t\tast.push \"var {argvar} = arguments, {len} = {argvar}.length\"\n\n\t\t\tif blk\n\t\t\t\tvar bn = blk.name.c\n\t\t\t\tif splat\n\t\t\t\t\tast.push \"var {bn} = {isFunc(last)} ? {pop} : null\"\n\t\t\t\telif reg:length > 0\n\t\t\t\t\t# ast.push \"// several regs really?\"\n\t\t\t\t\tast.push \"var {bn} = {len} > {reg:length} && {isFunc(last)} ? {pop} : null\"\n\t\t\t\telse\n\t\t\t\t\tast.push \"var {bn} = {isFunc(last)} ? {pop} : null\"\n\n\t\t\t# if we have named params - look for them before splat\n\t\t\t# should probably loop through pars in the same order they were added\n\t\t\t# should it be prioritized above optional objects??\n\t\t\tif named\n\t\t\t\t# should not include it when there is a splat?\n\t\t\t\tast.push \"var {namedvar.c} = {last}&&{isObj(last)} ? {pop} : \\{\\}\"\n\n\t\t\tfor par,i in opt\n\t\t\t\tast.push \"if({len} < {par.index + 1}) {par.name.c} = {par.defaults.c}\"\n\n\t\t\t# add the splat\n\t\t\tif splat\n\t\t\t\tvar sn = splat.name.c\n\t\t\t\tvar si = splat.index\n\n\t\t\t\tif si == 0\n\t\t\t\t\tast.push \"var {sn} = new Array({len}>{si} ? {len} : 0)\"\n\t\t\t\t\tast.push \"while({len}>{si}) {sn}[{len}-1] = {pop}\"\n\t\t\t\telse\n\t\t\t\t\tast.push \"var {sn} = new Array({len}>{si} ? {len}-{si} : 0)\"\n\t\t\t\t\tast.push \"while({len}>{si}) {sn}[--{len} - {si}] = {argvar}[{len}]\"\n\n\t\t\t# if named\n\t\t\t# \tfor k,i in named.nodes\n\t\t\t# \t\t# OP('.',namedvar) <- this is the right way, with invalid names etc\n\t\t\t# \t\tvar op = OP('.',namedvar,k.key).c\n\t\t\t# \t\tast.push \"var {k.key.c} = {op} !== undefined ? {op} : {k.value.c}\"\n\n\t\t\t# if named\n\n\t\t\t# return ast.join(\";\\n\") + \";\"\n\t\t\t# return \"if({opt[0].name.c} instanceof Function) {blk.c} = {opt[0].c};\"\n\n\n\t\telif opt:length > 0\n\t\t\tfor par,i in opt\n\t\t\t\tast.push \"if({par.name.c} === undefined) {par.name.c} = {par.defaults.c}\"\n\n\t\t# now set stuff if named params(!)\n\n\t\tif named\n\t\t\tfor k,i in named.nodes\n\t\t\t\t# console.log \"named var {k.c}\"\n\t\t\t\tvar op = OP('.',namedvar,k.c).c\n\t\t\t\tast.push \"var {k.c} = {op} !== undefined ? {op} : {k.defaults.c}\"\n\n\t\tif arys:length\n\t\t\tfor v,i in arys\n\t\t\t\t# create tuples\n\t\t\t\tp \"adding arrayparams\"\n\t\t\t\tv.head(o,ast,self)\n\t\t\t\t# ast.push v.c\n\t\t\t\t\n\n\n\t\t# if opt:length == 0\n\t\treturn ast:length > 0 ? (ast.join(\";\\n\") + \";\") : EMPTY\n\n\n# Legacy. Should move away from this?\nexport class VariableDeclaration < ListNode\n\n\t# for later, moz-ast style\n\tprop kind\n\n\tdef visit\n\t\t# for now we just deal with this if it only has one declaration\n\t\t# if any inner assignment is an expression\n\n\t\t# the declarators might be predeclared, in which case we don't need\n\t\t# to act like a regular one\n\t\tmap do |item| item.traverse\n\n\t# we want to register these variables in\n\tdef add name, init\n\t\tvar vardec = VariableDeclarator.new(name,init)\n\t\tpush vardec\n\t\tvardec\n\t\t# TODO (target) << (node) rewrites to a caching push which returns node\n\n\t# def remove item\n\t# \tif item isa Variable\n\t# \t\tmap do |v,i|\n\t# \t\t\tif v.variable == item\n\t# \t\t\t\tp \"found variable to remove\"\n\t# \t\t\t\tsuper.remove(v)\n\t# \telse\n\t# \t\tsuper.remove(item)\n\t# \tself\n\t\t\n\t\n\tdef load list\n\t\t# temporary solution!!!\n\t\tlist.map do |par| VariableDeclarator.new(par.name,par.defaults,par.splat)\n\n\tdef isExpressable\n\t\tlist.every(|item| item.isExpressable)\n\n\tdef js\n\t\treturn EMPTY if count == 0\n\n\t\tif count == 1 && !isExpressable\n\t\t\tp \"SHOULD ALTER VARDEC!!!\".cyan\n\t\t\tfirst.variable.autodeclare\n\t\t\tvar node = first.assignment\n\t\t\treturn node.c\n\n\t\t# unless right.isExpressable\n\t\t# \tp \"Assign.consume!\".blue\n\t\t#\tast = right.consume(self)\n\t\t#\treturn ast.c\n\t\t# vars = map|arg| arg.c )\n\t\t# single declarations should be useable as/in expressions\n\t\t# when they are - we need to declare the variables at the top of scope\n\t\t# should do more generic check to find out if variable should be listed\n\t\t# var args = filter(|arg| !arg.variable.@proxy )\n\t\t\"var \" + compact__(cary__(nodes)).join(\", \") + \"\"\n\nexport class VariableDeclarator < Param\n\n\t# can possibly create the variable immediately but wait with scope-declaring\n\tdef visit\n\t\t# even if we should traverse the defaults as if this variable does not exist\n\t\t# we need to preregister it and then activate it later\n\t\tself.variable ||= scope__.register(name,null)\n\t\tdefaults.traverse if defaults\n\t\tself.variable.declarator = self\n\t\tself.variable.addReference(name)\n\t\tself\n\t\t\n\t# needs to be linked up to the actual scoped variables, no?\n\tdef js\n\t\treturn null if variable.@proxy\n\n\t\tvar defs = defaults\n\t\t# FIXME need to deal with var-defines within other statements etc\n\t\t# FIXME need better syntax for this\n\t\tif defs != null && defs != undefined\n\t\t\t# console.log \"defaults is {defaults}\"\n\t\t\tdefs = defs.c(expression: yes) if defs isa Node # hmmm\n\n\t\t\t\"{variable.c}={defs}\"\n\t\telse\n\t\t\t\"{variable.c}\"\n\n\tdef accessor\n\t\tself\n\n\n# TODO clean up and refactor all the different representations of vars\n# VarName, VarReference, LocalVarAccess?\nexport class VarName < ValueNode\n\n\tprop variable\n\tprop splat\n\n\tdef initialize a,b\n\t\tsuper\n\t\t@splat = b\n\n\tdef visit\n\t\t# p \"visiting varname(!)\", value.c\n\t\t# should we not lookup instead?\n\t\tself.variable ||= scope__.register(value.c,null)\n\t\tself.variable.declarator = self\n\t\tself.variable.addReference(value)\n\t\tself\n\n\tdef js\n\t\tvariable.c\n\n\tdef c\n\t\tvariable.c\t\t\n\t\t\n\nexport class VarList < Node\n\n\tprop type # let / var / const\n\tprop left\n\tprop right\n\n\t# format :type, :left, :right\n\n\t# should throw error if there are more values on right than left\n\n\tdef initialize t,l,r\n\t\t@type = type\n\t\t@left = l\n\t\t@right = r\n\n\tdef visit\n\n\t\t# we need to carefully traverse children in the right order\n\t\t# since we should be able to reference\n\t\tfor l,i in left\n\t\t\tl.traverse # this should really be a var-declaration\n\t\t\tr.traverse if r = right[i]\n\t\tself\n\n\tdef js\n\t\t# for the regular items \n\t\tvar pairs = []\n\t\tvar ll = left:length\n\t\tvar rl = right:length\n\t\tvar v = null\n\n\t\t# splatting here we come\n\t\tif ll > 1 && rl == 1\n\t\t\tp \"multiassign!\"\n\t\t\tvar r = right[0]\n\t\t\tr.cache\n\t\t\tfor l,i in left\n\t\t\t\tif l.splat\n\t\t\t\t\tthrow \"not supported?\"\n\t\t\t\t\tp \"splat\" # FIX reimplement slice?\n\t\t\t\t\tif i == ll - 1\n\t\t\t\t\t\tv = util.slice(r,i)\n\t\t\t\t\t\tp \"last\"\n\t\t\t\t\telse\n\t\t\t\t\t\tv = util.slice(r,i,-(ll - i) + 1)\n\t\t\t\telse\n\t\t\t\t\tv = OP('.',r,num__(i))\n\t\t\t\t\n\t\t\t\tpairs.push(OP('=',l,v))\n\n\t\telse\n\t\t\tfor l,i in left\n\t\t\t\tvar r = right[i]\n\t\t\t\tpairs.push(r ? OP('=',l.variable.accessor,r) : l)\n\n\t\treturn \"var {pairs.c}\"\n\n\n# CODE\n\nexport class Code < Node\n\n\tprop head\n\tprop body\n\tprop scope\n\tprop params\n\n\tdef scopetype\n\t\tScope\n\n\tdef visit\n\t\t@scope.visit if @scope\n\t\t# @scope.parent = STACK.scope(1) if @scope\n\t\tself\n\n# Rename to Program?\nexport class Root < Code\n\n\tdef initialize body, opts\n\t\t# p \"create root!\"\n\t\tself.body = blk__(body)\n\t\tself.scope = FileScope.new(self,null)\n\n\tdef visit\n\t\tscope.visit\n\t\tbody.traverse\n\n\tdef compile\n\t\ttraverse\n\t\treturn c\n\n\tdef js\n\t\t'(function(){\\n\\n' + scope.c(indent: yes) + '\\n\\n}())'\n\n\tdef analyze\n\t\t# STACK.loglevel = 0\n\t\ttraverse\n\t\treturn scope.dump\n\n\tdef inspect\n\t\ttrue\n\nexport class ClassDeclaration < Code\n\n\tprop name\n\tprop superclass\n\tprop initor\n\n\tdef initialize name, superclass, body\n\t\t# what about the namespace?\n\t\t@name = name\n\t\t@superclass = superclass\n\t\t@scope = ClassScope.new(self)\n\t\t@body = blk__(body)\n\n\tdef visit\n\t\t# replace with some advanced lookup?\n\t\tscope.visit\n\n\t\t# local is the default -- should it really be referenced?\n\t\t# if option(:local)\n\t\t#\tself.name = scope.parent.register(name,self)\n\n\t\tbody.traverse\n\n\tdef js\n\t\tscope.virtualize\n\t\tscope.context.value = name\n\n\t\t# should probably also warn about stuff etc\n\t\tif option(:extension)\n\t\t\treturn body.c\n\n\t\tvar o = @options or {}\n\t\tvar cname = name isa Access ? name.right : name\n\t\tvar namespaced = name != cname\n\n\t\tvar sup = superclass\n\t\tvar initor = body.pluck do |c| c isa MethodDeclaration && c.type == :constructor\n\t\t# compile the cname\n\t\tcname = cname.c unless typeof cname == 'string'\n\n\t\tvar cpath = typeof name  == 'string' ? name : name.c\n\n\t\tif !initor\n\t\t\tif sup\n\t\t\t\tinitor = \"function {cname}()\\{ {sup.c}.apply(this,arguments) \\}\"\n\t\t\telse\n\t\t\t\tinitor = \"function {cname}()\" + '{ }'\n\t\t\n\t\telse\n\t\t\tinitor.name = cname\n\t\t\tinitor = initor.c\n\t\t\n\t\t# if we are defining a class inside a namespace etc -- how should we set up the class?\n\t\tvar head = []\n\n\t\tif namespaced\n\t\t\tinitor = \"{cpath} = {initor}\" # OP('=',name,initor) # hmm\n\n\t\thead.push(\"/* @class {cname} */\\n{initor};\\n\\n\")\n\n\t\tif sup\n\t\t\t# console.log \"deal with superclass!\"\n\t\t\t# head.push(\"// extending the superclass\\nimba$class({name.c},{sup.c});\\n\\n\")\n\t\t\thead.push(Util.Subclass.new([name,sup]))\n\n\t\t# only if it is not namespaced\n\t\tif o:global and !namespaced # option(:global)\n\t\t\thead.push(\"global.{cname} = {cpath}; // global class \\n\")\n\n\t\tif o:export and !namespaced\n\t\t\thead.push(\"exports.{cname} = {cpath}; // export class \\n\")\n\n\t\t# FIXME\n\t\t# if namespaced and (o:local or o:export)\n\t\t# \tconsole.log \"namespaced classes are implicitly local/global depending on the namespace\"\n\n\n\t\tbody.unshift(part) for part in head.reverse\n\t\tbody.@indentation = nil\n\t\tvar out = body.c\n\n\t\treturn out\n\n\nexport class TagDeclaration < Code\n\n\tprop name\n\tprop superclass\n\tprop initor\n\n\tdef initialize name, superclass, body\n\t\t# what about the namespace?\n\t\t# @name = TagTypeRef.new(name)\n\t\t@name = name\n\t\t@superclass = superclass\n\t\t@scope = TagScope.new(self)\n\t\t@body = blk__(body || [])\n\n\tdef visit\n\t\t# replace with some advanced lookup?\n\t\tscope.visit\n\t\tbody.traverse\n\n\tdef id\n\t\tname.id\n\n\tdef js\n\n\t\tif option(:extension)\n\t\t\t# check if we have an initialize etc - not allowed?\n\t\t\tscope.context.value = name\n\t\t\treturn body.c\n\n\t\t# should disallow initialize for tags?\n\t\tvar sup =  superclass and \",\" + helpers.singlequote(superclass.func) or \"\"\n\n\t\tvar out = if name.id\n\t\t\t\"Imba.defineSingletonTag('{name.id}',function {name.func}(d)\\{this.setDom(d)\\}{sup})\"\n\t\telse\n\t\t\t\"Imba.defineTag('{name.func}',function {name.func}(d)\\{this.setDom(d)\\}{sup})\"\n\n\t\t# if the body is empty we can return this directly\n\t\t# console.log \"here\"\n\t\tif body.count == 0\n\n\t\t\treturn out\n\n\t\t# create closure etc\n\t\t# again, we should really use the included system\n\t\t# FIXME should consolidate the way we generate all code - this\n\t\t# is going down a route of more direct conversion, which is less\n\t\t# flexible.\n\n\t\t# WARN should fix\n\t\tbody.@indentation = nil\n\n\t\tout = \"var tag = {out};\"\n\t\tscope.context.value = Const.new('tag')\n\t\tout += \"\\n{body.c}\"\n\n\t\treturn '(function()' + helpers.bracketize(out,yes) + ')()'\n\nexport class Func < Code\n\n\tprop name\n\tprop params\n\tprop target\n\tprop options\n\tprop type\n\tprop context\n\n\tdef scopetype do FunctionScope\n\n\tdef initialize params, body, name, target, o\n\t\t# p \"INIT Function!!\",params,body,name\n\t\tvar typ = scopetype\n\t\t@scope ||= (o and o:scope) || typ.new(self)\n\t\t@scope.params = @params = ParamList.new(params)\n\t\t@body = blk__(body)\n\t\t@name = name || ''\n\t\t@target = target\n\t\t@options = o\n\t\t@type = :function\n\t\tself\n\n\tdef visit\n\t\tscope.visit\n\t\t@context = scope.parent\n\t\t@params.traverse\n\t\t@body.traverse # so soon?\n\t\t\n\n\tdef js o\n\t\tbody.consume(ImplicitReturn.new) unless option(:noreturn)\n\t\tvar code = scope.c(indent: yes, braces: yes)\n\t\t# args = params.map do |par| par.name\n\t\t# head = params.map do |par| par.c\n\t\t# code = [head,body.c(expression: no)].flatten__.compact.join(\"\\n\").wrap\n\t\t# FIXME creating the function-name this way is prone to create naming-collisions\n\t\t# will need to wrap the value in a FunctionName which takes care of looking up scope\n\t\t# and possibly dealing with it\n\t\tvar name = typeof @name == 'string' ? @name : @name.c\n\t\tvar name = name.replace(/\\./g,'_')\n\t\tvar out = \"function {name}({params.c})\" + code\n\t\tout = \"({out})()\" if option(:eval)\n\t\treturn out\n\n\tdef shouldParenthesize\n\t\tup isa Call && up.callee == self\n\t\t# if up as a call? Only if we are \n\nexport class Lambda < Func\n\tdef scopetype do LambdaScope\n# MethodDeclaration\n# Create a shared body?\n\nexport class MethodDeclaration < Func\n\n\tprop variable\n\n\tdef scopetype do MethodScope\n\n\tdef visit\n\t\t# prebreak # make sure this has a break?\n\n\t\tif String(name) == 'initialize'\n\t\t\tself.type = :constructor\n\n\t\tif body:expressions\n\t\t\tset(greedy: true)\n\t\t\t# p \"BODY EXPRESSIONS!! This is a fragment\"\n\t\t\tvar tree = TagTree.new\n\t\t\t@body = body.consume(tree)\n\t\t\t# body.nodes = [Arr.new(body.nodes)] # hmm\n\n\t\tscope.visit\n\t\t@context = scope.parent\n\t\t@params.traverse\n\n\t\tif target isa Self\n\t\t\t@target = @scope.parent.context\n\t\t\tset(static: yes)\n\n\t\tif context isa ClassScope\n\t\t\t# register as class-method?\n\t\t\tyes\n\t\telif !@target\n\t\t\tvariable = context.register(name, self, type: 'meth')\n\n\t\t# hmm?\n\t\t@target ||= @scope.parent.context\n\n\t\t@body.traverse # so soon?\n\n\t\t# p \"method target {@target} {@context}\"\n\t\tself\n\n\tdef supername\n\t\ttype == :constructor ? type : name\n\n\n\t# FIXME export global etc are NOT valid for methods inside any other scope than\n\t# the outermost scope (root)\n\n\tdef js\n\t\t# FIXME Do this in the grammar - remnants of old implementation\n\t\tunless type == :constructor or option(:noreturn)\n\t\t\tif option(:greedy)\n\t\t\t\t# haaack\n\t\t\t\tbody.consume(GreedyReturn.new)\n\t\t\telse\n\t\t\t\tbody.consume(ImplicitReturn.new) \n\t\tvar code = scope.c(indent: yes, braces: yes)\n\n\t\t# same for Func -- should generalize\n\t\tvar name = typeof @name == 'string' ? @name : @name.c\n\t\tname = name.replace(/\\./g,'_')\n\n\t\t# var name = self.name.c.replace(/\\./g,'_') # WHAT?\n\t\tvar foot = []\n\n\t\tvar left = \"\"\n\t\tvar func = \"({params.c})\" + code # .wrap\n\t\tvar target = self.target\n\t\tvar decl = !option(:global) and !option(:export)\n\n\t\tif target isa ScopeContext\n\t\t\t# the target is a scope context\n\t\t\ttarget = nil # hmm -- \n\n\t\tvar ctx = context\n\t\tvar out = \"\"\n\t\t# if ctx \n\n\n\n\t\tvar fname = sym__(self.name)\n\t\t# console.log \"symbolize {self.name} -- {fname}\"\n\t\tvar fdecl = fname # decl ? fname : ''\n\n\t\tif ctx isa ClassScope and !target\n\t\t\tif type == :constructor\n\t\t\t\tout = \"function {fname}{func}\"\n\t\t\telif option(:static)\n\t\t\t\tout = \"{ctx.context.c}.{fname} = function {func}\"\n\t\t\telse\n\t\t\t\tout = \"{ctx.context.c}.prototype.{fname} = function {func}\"\n\n\t\telif ctx isa FileScope and !target\n\t\t\t# register method as a root-function, but with auto-call? hmm\n\t\t\t# should probably set using variable directly instead, no?\n\t\t\tout = \"function {fdecl}{func}\"\n\n\t\telif target and option(:static)\n\t\t\tout = \"{target.c}.{fname} = function {func}\"\n\n\t\telif target\n\t\t\t# hmm\n\t\t\tout = \"{target.c}.prototype.{fname} = function {func}\"\n\t\telse\n\t\t\tout = \"function {fdecl}{func}\"\n\n\t\tif option(:global)\n\t\t\tout = \"{fname} = {out}\"\n\n\t\tif option(:export)\n\t\t\tout = \"{out}; exports.{fname} = {fname};\"\n\n\t\tout\n\n\nexport class TagFragmentDeclaration < MethodDeclaration\n\n\nvar propTemplate = '''\n${headers}\n${path}.__${getter} = ${options};\n${path}.${getter} = function(v){ return ${get}; }\n${path}.${setter} = function(v){ ${set}; return this; }\n${init}\n'''\n\nvar propWatchTemplate = '''\n${headers}\n${path}.__${getter} = ${options};\n${path}.${getter} = function(v){ return ${get}; }\n${path}.${setter} = function(v){\n\tvar a = this.${getter}();\n\tif(v != a) { v = ${set}; }\n\tif(v != a) { ${ondirty} }\n\treturn this;\n}\n${init}\n'''\n\nexport class PropertyDeclaration < Expression\n\n\tprop name\n\tprop options\n\n\tdef initialize name, options\n\t\t@name = name\n\t\t@options = options || Obj.new(AssignList.new)\n\n\tdef visit\n\t\t@options.traverse\n\t\tself\n\n\t# This will soon support bindings / listeners etc, much more\n\t# advanced generated code based on options passed in.\n\tdef c\n\t\tvar o = options\n\t\tvar ast = \"\"\n\t\tvar key = name.c\n\t\tvar gets = \"@{key}\"\n\t\tvar sets = \"@{key} = v\"\n\t\tvar scope = STACK.scope\n\n\t\tvar deflt = options.key(:default)\n\t\tvar init = deflt ? \"self:prototype.@{key} = {deflt.value.c}\" : \"\"\n\n\t\t# var pars =\n\t\t# \twatch: o.key(:watch)\n\t\t# \tdelegate: o.key(:delegate)\n\n\t\tvar pars = o.hash\n\n\t\tvar js =\n\t\t\tkey: key\n\t\t\tgetter: key\n\t\t\tsetter: sym__(\"set-{key}\")\n\t\t\tscope: \"{scope.context.c}\" \n\t\t\tpath: '${scope}.prototype'\n\t\t\tset: \"this._{key} = v\"\n\t\t\tget: \"this._{key}\"\n\t\t\tinit: \"\"\n\t\t\theaders: \"\"\n\t\t\tondirty: \"\"\n\n\t\tvar tpl = propTemplate\n\n\t\tif pars:watch\n\t\t\t# p \"watch is a property {pars:watch}\"\n\t\t\ttpl = propWatchTemplate unless pars:watch isa Bool and !pars:watch.truthy\n\t\t\tvar wfn = \"{key}DidSet\"\n\n\t\t\tif pars:watch isa Symbol\n\t\t\t\twfn = pars:watch\n\t\t\telif pars:watch isa Bool\n\t\t\t\to.key(:watch).value = Symbol.new(\"{key}DidSet\")\n\n\t\t\t# should check for the function first, no?\n\t\t\t# HACK\n\t\t\t# o.key(:watch).value = Symbol\n\t\t\tvar fn = OP('.',This.new,wfn)\n\t\t\tjs:ondirty = OP('&&',fn,CALL(fn,['v','a',\"this.__{key}\"])).c # CALLSELF(wfn,[]).c\n\t\t\t# js:ondirty = \"if(this.{wfn}) this.{wfn}(v,a,this.__{key});\"\n\n\t\tif o.key(:dom) or o.key(:attr)\n\t\t\tjs:set = \"this.setAttribute('{key}',v)\"\n\t\t\tjs:get = \"this.getAttribute('{key}')\"\n\n\t\telif o.key(:delegate)\n\t\t\t# if we have a delegate\n\t\t\tjs:set = \"this.__{key}.delegate.set(this,'{key}',v,this.__{key})\"\n\t\t\tjs:get = \"this.__{key}.delegate.get(this,'{key}',this.__{key})\"\n\n\t\tif deflt\n\t\t\tif o.key(:dom)\n\t\t\t\tjs:init = \"{js:scope}.dom().setAttribute('{key}',{deflt.value.c});\"\n\t\t\telse\n\t\t\t\tjs:init = \"{js:scope}.prototype._{key} = {deflt.value.c};\"\n\n\t\tif o.key(:chainable)\n\t\t\tjs:get = \"v !== undefined ? (this.{js:setter}(v),this) : {js:get}\"\n\n\t\tjs:options = o.c\n\n\t\tvar reg = /\\$\\{(\\w+)\\}/gm\n\t\t# var tpl = o.key(:watch) ? propWatchTemplate : propTemplate\n\t\tvar out = tpl.replace(reg) do |m,a| js[a]\n\t\t# run another time for nesting. hacky\n\t\tout = out.replace(reg) do |m,a| js[a]\n\t\tout = out.replace(/\\n\\s*$/,'')\n\t\t\n\t\t# if o.key(:v)\n\t\treturn out\n\n\n\n\n# Literals should probably not inherit from the same parent\n# as arrays, tuples, objects would be better off inheriting\n# from listnode.\n\nexport class Literal < ValueNode\n\t\n\tdef initialize v\n\t\t@value = v\n\t\t\n\t# hmm\n\tdef toString\n\t\t\"\" + value\n\n\tdef hasSideEffects\n\t\tfalse\n\t\t\n\nexport class Bool < Literal\n\n\tdef initialize v\n\t\t@value = v\n\t\t@raw = String(v) == \"true\" ? true : false\n\n\tdef cache\n\t\tself\n\n\tdef truthy\n\t\t# p \"bool is truthy? {value}\"\n\t\tString(value) == \"true\"\n\t\t# yes\n\n\tdef js\n\t\tString(@value)\n\n\tdef c\n\t\t# undefined should not be a bool\n\t\tString(@value)\n\t\t# @raw ? \"true\" : \"false\"\n\n\nexport class True < Bool\n\n\tdef raw\n\t\ttrue\n\n\tdef c\n\t\tconsole.log \"compile True\"\n\t\t\"true\"\n\t\t\nexport class False < Bool\n\n\tdef raw\n\t\tfalse\n\n\tdef c\n\t\t\"false\"\n\nexport class Num < Literal\n\t\n\t# value is token - should not be\n\tdef initialize v\n\t\t@value = v\n\n\tdef toString\n\t\tString(@value)\n\n\tdef shouldParenthesize\n\t\tup isa Access\n\n\n\tdef js\n\t\tvar num = String(@value)\n\t\t# console.log \"compiled num to {num}\"\n\t\treturn num\n\n\tdef c o\n\t\treturn super(o) if @cache\n\t\tvar js = String(@value)\n\t\tvar paren = STACK.current isa Access # hmmm\n\t\t# console.log \"should paren?? {shouldParenthesize}\"\n\t\tparen ? \"(\" + js + \")\" : js\n\t\t# @cache ? super(o) : String(@value)\n\n\t# def cache\n\t# \tp \"cache num\"\n\t# \tself\n\n\tdef raw\n\t\tJSON.parse(String(value))\n\n# should be quoted no?\n# what about strings in object-literals?\n# we want to be able to see if the values are allowed\nexport class Str < Literal\n\n\tdef initialize v\n\t\t@value = v\n\n\tdef raw\n\t\t# JSON.parse requires double-quoted strings,\n\t\t# while eval also allows single quotes. \n\t\t# NEXT eval is not accessible like this\n\t\t# WARNING TODO be careful! - should clean up\n\t\t@raw ||= global.eval(String(value)) # incredibly stupid solution\n\n\tdef isValidIdentifier\n\t\t# there are also some values we cannot use\n\t\traw.match(/^[a-zA-Z\\$\\_]+[\\d\\w\\$\\_]*$/) ? true : false\n\n\tdef js\n\t\tString(@value) # hmm\n\n\tdef c o\n\t\t@cache ? super(o) : String(@value)\n\n# Currently not used - it would be better to use this\n# for real interpolated strings though, than to break\n# them up into their parts before parsing\nexport class InterpolatedString < ListNode\n\n\tdef js\n\t\t\"interpolated string\"\n\n\nexport class Tuple < ListNode\n\n\tdef c\n\t\t# compiles as an array\n\t\tArr.new(nodes).c\n\n\tdef hasSplat\n\t\tfilter(|v| v isa Splat )[0]\n\n\tdef consume node\n\t\tif count == 1\n\t\t\treturn first.consume(node)\n\t\telse\n\t\t\tthrow \"multituple cannot consume\"\n\t\t\n\t\n# Because we've dropped the Str-wrapper it is kinda difficult\nexport class Symbol < Literal\n\n\tdef isValidIdentifier\n\t\traw.match(/^[a-zA-Z\\$\\_]+[\\d\\w\\$\\_]*$/) ? true : false\n\n\tdef raw\n\t\t@raw ||= sym__(value)\n\n\tdef js\n\t\t\"'{sym__(value)}'\"\n\nexport class RegExp < Literal\n\n\t# def toString\n\t# \t\"\" + value\n\n# Should inherit from ListNode - would simplify\nexport class Arr < Literal\n\n\tdef load value\n\t\tvalue isa Array ? ArgList.new(value) : value\n\n\tdef push item\n\t\tvalue.push(item)\n\t\tself\n\n\tdef count\n\t\tvalue:length\n\n\tdef nodes\n\t\tvalue\n\n\tdef splat\n\t\tvalue.some(|v| v isa Splat)\n\n\tdef visit\n\t\t@value.traverse if @value and @value:traverse\n\t\tself\n\n\tdef js\n\t\tvar splat = value.some(|v| v isa Splat)\n\n\t\tif splat\n\t\t\t\"SPLATTED ARRAY!\"\n\t\t\t# if we know for certain that the splats are arrays we can drop the slice?\n\t\t\tvar slices = []\n\t\t\tvar group = nil\n\t\t\tvalue.forEach do |v|\n\t\t\t\tif v isa Splat\n\t\t\t\t\tslices.push(v)\n\t\t\t\t\tgroup = nil\n\t\t\t\telse\n\t\t\t\t\tslices.push(group = Arr.new([])) unless group\n\t\t\t\t\tgroup.push(v)\n\n\t\t\t\"[].concat({cary__(slices).join(\", \")})\"\n\t\telse\n\t\t\t# very temporary. need a more generic way to prettify code\n\t\t\t# should depend on the length of the inner items etc\n\t\t\t# if @indented or option(:indent) or value.@indented\n\t\t\t#\t\"[\\n{value.c.join(\",\\n\").indent}\\n]\"\n\t\t\t# else\n\t\t\tvar v = value\n\t\t\tv = v isa Array ? cary__(v) : v.c # hmmm\n\t\t\t\"[{v}]\"\n\n\t# def indented\n\t# \tvar o = @options ||= {}\n\t# \to:indent = yes\n\t# \tself\n\n\tdef hasSideEffects\n\t\tvalue.some(|v| v.hasSideEffects )\n\n\tdef toString\n\t\t\"Arr\"\n\t\t\n\n\tdef self.wrap val\n\t\tArr.new(val)\n\n# should not be cklassified as a literal?\nexport class Obj < Literal\n\n\tdef load value\n\t\tvalue isa Array ? AssignList.new(value) : value\n\n\tdef visit\n\t\t@value.traverse if @value\n\t\t# for v in value\n\t\t# \tv.traverse\n\t\tself\n\n\tdef js\n\t\tvar dyn = value.filter(|v| v isa ObjAttr and v.key isa Op )\n\n\t\tif dyn:length > 0\n\t\t\tvar idx = value.indexOf(dyn[0])\n\t\t\t# p \"dynamic keys! {dyn}\"\n\t\t\t# create a temp variable\n\n\t\t\tvar tmp = scope__.temporary(self)\n\t\t\t# set the temporary object to the same\n\t\t\tvar first = value.slice(0,idx)\n\t\t\tvar obj = Obj.new(first)\n\t\t\tvar ast = [OP('=',tmp,obj)]\n\n\t\t\tvalue.slice(idx).forEach do |atr|\n\t\t\t\tast.push(OP('=',OP('.',tmp,atr.key),atr.value))\n\t\t\tast.push(tmp) # access the tmp at in the last part\n\t\t\treturn Parens.new(ast).c\n\n\n\t\t# var body = value.map do |v|\n\t\t# \tvar out = v.c\n\t\t# \tout = '\\n' + out if v.@pbr # hmmm \n\t\t# \tout\n\n\t\t# if @indented\n\t\t# \t# should be more generalized?\n\t\t# \tbody = '\\n' + body.join(',').indent + '\\n' # hmmm\n\t\t# else\n\t\t# \tbody.join(',')\n\t\t\n\t\t# for objects with expression-keys we need to think differently\n\t\t'{' + value.c + '}'\n\n\tdef add k, v\n\t\tvar kv = ObjAttr.new(k,v)\n\t\tvalue.push(kv)\n\t\treturn kv\n\n\tdef hash\n\t\tvar hash = {}\n\t\tfor k in value\n\t\t\thash[k.key.symbol] = k.value if k isa ObjAttr\n\t\treturn hash\n\t\t# return k if k.key.symbol == key\n\n\t# add method for finding properties etc?\n\tdef key key\n\t\tfor k in value\n\t\t\treturn k if k isa ObjAttr and k.key.symbol == key\n\t\tnil\n\n\tdef indented a,b\n\t\t@value.indented(a,b)\n\t\tself\n\n\tdef hasSideEffects\n\t\tvalue.some(|v| v.hasSideEffects )\n\n\t# for converting a real object into an ast-representation\n\tdef self.wrap obj\n\t\tvar attrs = []\n\t\tfor own k,v of obj\n\t\t\tif v isa Array\n\t\t\t\tv = Arr.wrap(v)\n\t\t\telif v:constructor == Object\n\t\t\t\tv = Obj.wrap(v)\n\t\t\tattrs.push(ObjAttr.new(k,v))\n\t\treturn Obj.new(attrs)\n\n\tdef toString\n\t\t\"Obj\"\n\t\t\nexport class ObjAttr < Node\n\n\tprop key\n\tprop value\n\tprop options\n\n\tdef initialize key, value\n\t\t@key = key\n\t\t@value = value\n\t\t@dynamic = key isa Op\n\n\tdef visit\n\t\t# should probably traverse key as well, unless it is a dead simple identifier\n\t\tkey.traverse\n\t\tvalue.traverse\n\n\tdef js\n\t\t\"{key.c}: {value.c}\"\n\n\tdef hasSideEffects\n\t\ttrue\n\t\t\n\n\nexport class ArgsReference < Node\n\n\t# should register in this scope --\n\tdef c\n\t\t\"arguments\"\n\n# should be a separate Context or something\nexport class Self < Literal\n\n\tprop scope\n\n\tdef initialize scope\n\t\t@scope = scope\n\n\tdef cache\n\t\tself\n\n\tdef reference\n\t\treturn self\n\n\tdef c\n\t\tvar s = scope__\n\t\t(s ? s.context.c : \"this\")\n\nexport class ImplicitSelf < Self\n\t\t\nexport class This < Self\n\n\tdef cache\n\t\tself\n\n\tdef reference\n\t\t# p \"referencing this\"\n\t\tself\n\n\tdef c\n\t\t\"this\"\n\n\n\n\n# OPERATORS\n\nexport class Op < Node\n\n\tprop op\n\tprop left\n\tprop right\n\n\tdef initialize o, l, r \n\t\t@invert = no\n\t\t@op = o and o.@value or o # hmmmm\n\t\t@left = l\n\t\t@right = r\n\t\treturn self\n\n\tdef visit\n\t\t@right.traverse if @right\n\t\t@left.traverse if @left\n\t\treturn self\n\n\tdef isExpressable\n\t\t# what if right is a string?!?\n\t\t!right || right.isExpressable\n\n\tdef js\n\t\tvar out = null\n\t\tvar op = @op\n\n\t\tvar l = @left\n\t\tvar r = @right\n\n\t\t# hmmmm?\n\t\tl = l.c if l isa Node # hmmm\n\t\tr = r.c if r isa Node\n\n\t\tif l && r\n\t\t\tout = \"{l} {op} {r}\"\n\t\telif l\n\t\t\tout = \"{op}{l}\"\n\t\t# out = out.parenthesize if up isa Op # really?\n\t\tout\n\n\tdef shouldParenthesize\n\t\toption(:parens)\n\n\tdef precedence\n\t\t10\n\n\tdef consume node\n\t\t# p \"Op.consume {node}\".cyan\n\t\treturn super if isExpressable\n\n\t\t# TODO can rather use global caching?\n\t\tvar tmpvar = scope__.declare(:tmp,null,system: yes)\n\t\tvar clone = OP(op,left,null)\n\t\tvar ast = right.consume(clone)\n\t\tast.consume(node) if node\n\t\treturn ast\n\nexport class ComparisonOp < Op\n\n\tdef invert\n\t\tvar op = @op\n\t\tvar pairs = [ \"==\",\"!=\" , \"===\",\"!==\" , \">\",\"<=\" , \"<\",\">=\" ]\n\t\tvar idx = pairs.indexOf(op)\n\t\tidx += (idx % 2 ? -1 : 1)\n\n\t\t# p \"inverted comparison(!) {idx} {op} -> {pairs[idx]}\"\n\t\tself.op = pairs[idx]\n\t\t@invert = !@invert\n\t\tself\n\n\tdef c\n\t\tif left isa ComparisonOp\n\t\t\tleft.right.cache\n\t\t\tOP('&&',left,OP(op,left.right,right)).c\n\t\telse\n\t\t\tsuper\n\n\tdef js\n\t\tvar op = @op\n\t\tvar l = @left\n\t\tvar r = @right\n\n\t\t# hmmmm?\n\t\tl = l.c if l isa Node # hmmm\n\t\tr = r.c if r isa Node\n\t\treturn \"{l} {op} {r}\"\n\n\t\t\nexport class MathOp < Op\n\t# BUG if we have a statement in left or right we need\n\t# to FORCE it into an expression, and register warning\n\t# should not at all consume anything like a regular Op\n\tdef c\n\t\tif op == '∪'\n\t\t\treturn util.union(left,right).c\n\t\telif op == '∩'\n\t\t\treturn util.intersect(left,right).c\n\n\nexport class UnaryOp < Op\n\n\tdef invert\n\t\tif op == '!'\n\t\t\treturn left\n\t\telse\n\t\t\tsuper # regular invert\n\n\tdef js\n\t\tvar l = @left\n\t\tvar r = @right\n\t\t# all of this could really be done i a much\n\t\t# cleaner way.\n\t\tl.set(parens: yes) if l\n\t\tr.set(parens: yes) if r\n\n\t\tif op == '!'\n\t\t\tl.set(parens: yes)\n\t\t\t\"{op}{l.c}\"\n\n\t\telif op == '√'\n\t\t\t\"Math.sqrt({l.c})\"\n\n\t\telif left\n\t\t\t\"{l.c}{op}\"\n\n\t\telse\n\t\t\t\"{op}{r.c}\"\n\n\tdef normalize\n\t\treturn self if op == '!' or op == '√'\n\t\tvar node = (left || right).node\n\t\t# for property-accessors we need to rewrite the ast\n\t\treturn self unless node isa PropertyAccess\n\n\t\t# ask to cache the path\n\t\tnode.left.cache if node isa Access && node.left\n\n\t\tvar num = Num.new(1)\n\t\tvar ast = OP('=',node,OP(op[0],node,num))\n\t\tast = OP(op[0] == '-' ? '+' : '-',ast,num) if left\n\n\t\treturn ast\n\n\tdef consume node\n\t\tvar norm = normalize\n\t\tnorm == self ? super : norm.consume(node)\n\n\tdef c\n\t\tvar norm = normalize\n\t\tnorm == self ? super : norm.c\n\nexport class InstanceOf < Op\n\n\tdef js o\n\t\t# fix checks for String and Number\n\t\t# p right.inspect\n\n\t\tif right isa Const\n\t\t\t# WARN otherwise - what do we do? does not work with dynamic\n\t\t\t# classes etc? Should probably send to utility function isa$\n\t\t\tvar name = c__(right.value)\n\t\t\tvar obj = left.node\n\t\t\t# TODO also check for primitive-constructor\n\t\t\tif name in ['String','Number','Boolean']\n\t\t\t\tunless obj isa LocalVarAccess\n\t\t\t\t\tobj.cache\n\t\t\t\t# need a double check for these (cache left) - possibly\n\t\t\t\treturn \"(typeof {obj.c}=='{name.toLowerCase}'||{obj.c} instanceof {name})\"\n\t\t\t\n\t\t\t\t# convert\n\t\tvar out = \"{left.c} {op} {right.c}\"\n\n\t\t# should this not happen in #c?\n\t\tout = helpers.parenthesize(out) if o.parent isa Op\n\t\tout\n\nexport class TypeOf < Op\n\n\tdef js\n\t\t\"typeof {left.c}\"\n\nexport class Delete < Op\n\n\tdef js\n\t\t# TODO this will execute calls several times if the path is not directly to an object\n\t\t# need to cache the receiver\n\t\tvar l = left\n\t\tvar tmp = scope__.temporary(self, type: 'val')\n\t\tvar o = OP('=',tmp,l)\n\t\t# FIXME\n\t\treturn \"({o.c},delete {l.c}, {tmp.c})\" # oh well\n\t\t# var ast = [OP('=',tmp,left),\"delete {left.c}\",tmp]\n\t\t# should parenthesize directly no?\n\t\t# ast.c\n\n\tdef shouldParenthesize\n\t\tyes\n\nexport class In < Op\n\n\tdef invert\n\t\t@invert = !@invert\n\t\tself\n\n\tdef js\n\t\tvar cond = @invert ? \"== -1\" : \">= 0\"\n\t\tvar idx = Util.indexOf(left,right)\n\t\t\"{idx.c} {cond}\"\n\t\n\n\n\n# ACCESS\n\nexport class Access < Op\n\n\tdef clone left, right\n\t\tvar ctor = self:constructor\n\t\tctor.new(op,left,right)\n\n\tdef js\n\t\tvar raw = null\n\t\tvar rgt = right\n\n\t\t# is this right? Should not the index compile the brackets\n\t\t# or value is a symbol -- should be the same, no?\n\t\tif rgt isa Index and (rgt.value isa Str or rgt.value isa Symbol)\n\t\t\trgt = rgt.value\n\n\t\t# TODO do the identifier-validation in a central place instead\n\t\tif rgt isa Str and rgt.isValidIdentifier\n\t\t\traw = rgt.raw\n\n\t\telif rgt isa Symbol and rgt.isValidIdentifier\n\t\t\traw = rgt.raw\n\n\t\telif rgt isa Identifier and rgt.isValidIdentifier\n\t\t\traw = rgt.c\n\n\t\t# really?\n\t\tvar ctx = (left || scope__.context)\n\n\t\tif ctx isa RootScopeContext\n\t\t\t# this is a hacky workaround\n\t\t\treturn (raw ? raw : \"global[{rgt.c}]\")\n\n\t\t# see if it needs quoting\n\t\tif raw\n\t\t\t# need to check to see if it is legal\n\t\t\treturn ctx ? \"{ctx.c}.{raw}\" : raw\n\t\telse\n\t\t\tvar r = rgt isa Node ? rgt.c(expression: yes) : rgt\n\t\t\treturn \"{ctx.c}[{r}]\"\n\n\tdef visit\n\t\tleft.traverse if left\n\t\tright.traverse if right\n\t\treturn\n\n\tdef isExpressable\n\t\tyes # ?\n\n\tdef isExpressable\n\t\ttrue\n\n\tdef alias\n\t\tright isa Identifier ? sym__(right) : super\n\n\tdef safechain\n\t\tright.safechain\n\n\n# Should change this to just refer directly to the variable? Or VarReference\nexport class LocalVarAccess < Access\n\n\tprop safechain\n\n\tdef js\n\t\tif right isa Variable and right.type == 'meth'\n\t\t\treturn \"{right.c}()\" unless up isa Call\n\n\t\tright.c\n\n\tdef variable\n\t\tright\n\n\tdef cache o = {}\n\t\tsuper if o:force # hmm\n\t\tself\n\n\tdef alias\n\t\tvariable.@alias or super # if resolved?\n\n\nexport class GlobalVarAccess < ValueNode\n\n\tdef js\n\t\tvalue.c\n\n\nexport class ObjectAccess < Access\n\n\nexport class PropertyAccess < Access\n\n\tdef js o\n\t\tif var rec = receiver\n\t\t\tvar ast = CALL(OP('.',left,right),[])\n\t\t\tast.receiver = rec\n\t\t\treturn ast.c\n\n\t\t# really need to fix this - for sure\n\t\tvar js = \"{super}\"\n\t\tjs += \"()\" unless (up isa Call or up isa Util.IsFunction)\n\t\treturn js\n\n\tdef receiver\n\t\tif left isa SuperAccess || left isa Super\n\t\t\tSELF\n\t\telse\n\t\t\tnull\n\n\nexport class IvarAccess < Access\n\n\tdef cache\n\t\t# WARN hmm, this is not right... when accessing on another object it will need to be cached\n\t\treturn self\n\n\nexport class ConstAccess < Access\n\n\nexport class IndexAccess < Access\n\n\tdef cache o = {}\n\t\treturn super if o:force\n\t\tright.cache\n\t\tself\n\n\nexport class SuperAccess < Access\n\n\tdef js o\n\t\tvar m = o.method\n\t\tvar up = o.parent\n\t\tvar deep = o.parent isa Access\n\n\t\tvar out = \"{left.c}.__super__\"\n\n\t\tunless up isa Access\n\t\t\tout += \".{m.supername.c}\"\n\t\t\tunless up isa Call # autocall?\n\t\t\t\tout += \".apply({m.scope.context.c},arguments)\"\n\n\t\treturn out\n\n\tdef receiver\n\t\tSELF\n\n\nexport class VarOrAccess < ValueNode\n\n\tdef visit\n\n\t\t@identifier = value # this is not a real identifier?\n\t\t# console.log \"VarOrAccess {@identifier}\"\n\n\t\tvar scope = scope__\n\t\tvar variable = scope.lookup(value)\n\n\t\tif variable && variable.declarator\n\n\t\t\tvariable.addReference(self) # hmm\n\n\t\t\tself.value = variable.accessor(self)\n\t\t\tself.value.safechain = safechain # hmm\n\n\t\telif value.symbol.indexOf('$') >= 0\n\t\t\tself.value = GlobalVarAccess.new(value)\n\t\telse\n\t\t\tself.value = PropertyAccess.new(\".\",scope.context,value)\n\n\t\t@value.traverse\n\n\tdef c\n\t\tvalue.c\n\n\tdef node\n\t\tvalue\n\n\tdef symbol\n\t\tvalue and value.symbol\n\n\tdef cache o = {}\n\t\tvalue.cache(o)\n\n\tdef decache\n\t\tvalue.decache\n\t\tself\n\n\tdef dom\n\t\tvalue.dom\n\n\tdef safechain\n\t\t@identifier.safechain # hmm\n\n\tdef dump\n\t\t{ loc: loc }\n\n\tdef loc\n\t\tvar loc = @identifier.region\n\t\treturn loc or [0,0]\n\n\tdef toString\n\t\t\"VarOrAccess({value})\"\n\n\nexport class VarReference < ValueNode\n\n\t# TODO VarBlock should convert these to plain / dumb nodes\n\n\tprop variable\n\n\tdef js o\n\t\t# experimental fix\n\t\t\n\t\tvar ref = @variable\n\t\tvar out = ref.c\n\n\t\tif ref && !ref.option(:declared)\n\t\t\tif o.up(VarBlock)\n\t\t\t\tref.set(declared: yes)\n\t\t\telif o.isExpression or option(:export) # why?\n\t\t\t\tref.autodeclare\n\t\t\telse\n\t\t\t\tout = \"var {out}\"\n\t\t\t\tref.set(declared: yes)\n\n\t\t# need to think the export through -- like registering somehow\n\t\t# should register in scope - export on analysis++\n\t\tif option(:export)\n\t\t\tout = \"module.exports.{ref.c} = {ref.c}\"\n\n\t\treturn out\n\n\tdef declare\n\t\tself\n\n\tdef consume node\n\t\t@variable && @variable.autodeclare\n\t\tself\n\n\tdef visit\n\t\tvar name = value.c\n\t\t# what about looking up? - on register we want to mark\n\t\tself.variable ||= scope__.register(name,null)\n\t\t# FIXME -- should not simply override the declarator here(!)\n\t\tself.variable.declarator = self # hmm, cannot be certain, but ok for now\n\t\tself.variable.addReference(value) # is this the first reference?\n\t\tself\n\n\tdef refnr\n\t\tvariable.references.indexOf(value)\n\n\t# convert this into a list of references\n\tdef addExpression expr\n\t\tVarBlock.new([self]).addExpression(expr)\n\n\n\n\n# ASSIGN\n\nexport class Assign < Op\n\n\tdef isExpressable\n\t\t!right || right.isExpressable\n\n\tdef isUsed\n\t\tif up isa Block && up.last != self # hmm\n\t\t\treturn no \n\t\treturn yes\n\n\tdef js o\n\n\t\tunless right.isExpressable\n\t\t\treturn right.consume(self).c\n\n\t\t# p \"assign left {left:contrstru}\"\n\t\tvar l = left.node\n\n\t\t# We are setting self(!)\n\t\t# TODO document functionality\n\t\tif l isa Self\n\t\t\tvar ctx = scope__.context\n\t\t\tl = ctx.reference\n\n\n\t\tif l isa PropertyAccess\n\t\t\tvar ast = CALL(OP('.',l.left,l.right.setter),[right])\n\t\t\tast.receiver = l.receiver\n\n\t\t\tif isUsed\n\t\t\t\t# dont cache it again if it is already cached(!)\n\t\t\t\tright.cache(type: 'val', uses: 1) unless right.cachevar # \n\t\t\t\t# this is only when used.. should be more clever about it\n\t\t\t\tast = Parens.new(blk__([ast,right]))\n\n\t\t\t# should check the up-value no?\n\t\t\treturn ast.c(expression: yes)\n\n\t\t# FIXME -- does not always need to be an expression?\n\t\tvar out = \"{l.c} {op} {right.c(expression: true)}\"\n\n\t\treturn out\n\n\tdef shouldParenthesize\n\t\tup isa Op && up.op != '='\n\n\n\tdef consume node\n\t\tif isExpressable\n\t\t\tforceExpression\n\t\t\treturn super\n\n\t\tvar ast = right.consume(self)\n\t\treturn ast.consume(node)\n\n\nexport class PushAssign < Assign\n\n\tdef js\n\t\t\"{left.c}.push({right.c})\"\n\n\tdef consume node\n\t\treturn self\n\n\nexport class ConditionalAssign < Assign\n\n\tdef consume node\n\t\tnormalize.consume(node)\n\n\tdef normalize\n\t\tvar l = left.node\n\t\tvar ls = l\n\n\t\tif l isa Access\n\t\t\t# p \"conditional-assign {l} {l.left} {l.right}\"\n\t\t\tif l.left # hmm\n\t\t\t\t# p \"cache l.left {l.left:constructor}̋\"\n\t\t\t\tl.left.cache \n\t\t\tls = l.clone(l.left,l.right) # this should still be cached?\n\t\t\tl.cache if l isa PropertyAccess # correct now, to a certain degree\n\t\t\tif l isa IndexAccess\n\t\t\t\t# p \"cache the right side of indexAccess!!! {l.right}\"\n\t\t\t\tl.right.cache \n\n\t\t\t# we should only cache the value itself if it is dynamic?\n\t\t\t# l.cache # cache the value as well -- we cannot use this in assigns them\n\n\t\t# some ops are less messy\n\t\t# need op to support consume then?\n\t\tvar expr = right.isExpressable\n\t\tvar ast = null\n\t\t# here we should use ast = if ...\n\t\tif expr && op == '||='\n\t\t\tast = OP('||',l, OP('=',ls,right))\n\t\telif expr && op == '&&='\n\t\t\tast = OP('&&',l, OP('=',ls,right))\n\t\telse\n\t\t\tast = IF(condition, OP('=',ls,right), l)\n\t\tast.toExpression if ast.isExpressable # hmm\n\t\tast\n\n\n\tdef c\n\t\t# WARN what if we return the same?\n\t\tnormalize.c\n\n\tdef condition\n\n\t\t# use switch instead to cache op access\n\t\tif op == '?='\n\t\t\tOP('==',left,NULL)\n\t\telif op == '||='\n\t\t\tOP('!',left)\n\t\telif op == '&&='\n\t\t\tleft\n\t\telif op == '!?='\n\t\t\tOP('!=',left,NULL)\n\t\telse\n\t\t\tleft\n\t\t\n\tdef js\n\t\t# p \"ConditionalAssign.js\".red\n\t\tvar ast = IF(condition, OP('=',left,right), left)\n\t\tast.toExpression if ast.isExpressable\n\t\treturn ast.c\n\nexport class CompoundAssign < Assign\n\n\t# FIXME can we merge consume and js?\n\tdef consume node\n\t\treturn super if isExpressable\n\n\t\tvar ast = normalize\n\t\treturn ast.consume(node) unless ast == self\n\n\t\tast = right.consume(self)\n\t\treturn ast.consume(node)\n\n\tdef normalize\n\t\tvar ln = left.node\n\t\t# we dont need to change this at all\n\t\tunless ln isa PropertyAccess\n\t\t\treturn self\n\n\t\tif ln isa Access\n\t\t\t# left might be zero?!?!\n\t\t\tln.left.cache if ln.left\n\t\t# TODO FIXME we want to cache the context of the assignment\n\t\t# p \"normalize compound assign {left}\"\n\t\tvar ast = OP('=',left,OP(op[0],left,right))\n\t\tast.toExpression if ast.isExpressable\n\n\t\treturn ast\n\t\t\n\tdef c\n\t\tvar ast = normalize\n\t\treturn super if ast == self\n\n\t\t# otherwise it is important that we actually replace this node in the outer block\n\t\t# whenever we normalize and override c it is important that we can pass on caching\n\t\t# etc -- otherwise there WILL be issues.\n\t\tvar up = STACK.current\n\t\tif up isa Block\n\t\t\t# p \"parent is block, should replace!\"\n\t\t\t# an alternative would be to just pass\n\t\t\tup.replace(self,ast)\n\t\tast.c\n\n\nexport class AsyncAssign < Assign\n\n\t# this will transform the tree by a decent amount.\n\t# Need to adjust Block to allow this\n\n\nexport class TupleAssign < Assign\n\n\tprop op\n\tprop left\n\tprop right\n\tprop type\n\n\tdef initialize a,b,c\n\t\t@op = a\n\t\t@left = b\n\t\t@right = c\n\t\t@temporary = []\n\n\tdef isExpressable\n\t\tright.isExpressable\n\n\tdef addExpression expr\n\t\tif right isa Tuple\n\t\t\tright.push(expr)\n\t\telse\n\t\t\t# p \"making child become a tuple?\"\n\t\t\tself.right = Tuple.new([right,expr])\n\t\t\n\t\treturn self\n\n\tdef visit\n\t\t# if the first left-value is a var-reference, then\n\t\t# all the variables should be declared as variables.\n\t\t# but if we have complex items in the other list - it does become much harder\n\n\t\t# if the first is a var-reference, they should all be(!) .. or splats?\n\t\t# this is really a hacky wao to do it though\n\t\tif left.first.node isa VarReference\n\t\t\tself.type = 'var'\n\t\t\t# NOTE can improve.. should rather make the whole left be a VarBlock or TupleVarBlock\n\t\t\t# p \"type is var -- skip the rest\"\n\n\t\tright.traverse\n\t\tleft.traverse\n\t\tself\n\n\tdef js\n\t\t# only for actual inner expressions, otherwise cache the whole array, no?\n\t\tunless right.isExpressable\n\t\t\t# p \"TupleAssign.consume! {right}\".blue\n\t\t\treturn right.consume(self).c\n\n\t\t### a,b,c = arguments ###\n\t\t# - direct. no matter if lvalues are variables or not. Make fake arguments up to the same count as tuple\n\n\t\t### a,*b,b = arguments ###\n\t\t# Need to convert arguments to an array. IF arguments is not referenced anywhere else in scope, \n\t\t# we can do the assignment directly while rolling through arguments\n\n\t\t### a,b = b,a ###\n\t\t# ideally we only need to cache the first value (or n - 1), assign directly when possible.\n\n\t\t### a,b,c = (method | expression) ###\n\t\t# convert res into array, assign from array. Can cache the variable when assigning first value\n\n\t\t# First we need to find out whether we are required to store the result in an array before assigning\n\t\t# If this needs to be an expression (returns?, we need to fall back to the CS-wa)\n\n\t\tvar ast = Block.new\n\t\tvar lft = self.left\n\t\tvar rgt = self.right\n\t\tvar typ = self.type\n\t\tvar via = nil\n\n\t\tvar li = 0\n\t\tvar ri = lft.count\n\t\tvar llen = ri\n\n\n\n\t\t# if we have a splat on the left it is much more likely that we need to store right\n\t\t# in a temporary array, but if the right side has a known length, it should still not be needed\n\t\tvar lsplat = lft.filter(|v| v isa Splat )[0]\n\n\t\t# if right is an array without any splats (or inner tuples?), normalize it to tuple\n\t\trgt = Tuple.new(rgt.nodes) if rgt isa Arr && !rgt.splat\n\t\tvar rlen = rgt isa Tuple ? rgt.count : nil\n\n\t\t# if any values are statements we need to handle this before continuing\n\n\t\t### a,b,c = 10,20,ary ###\n\t\t# ideally we only need to cache the first value (or n - 1), assign directly when possible.\n\t\t# only if the variables are not predefined or predeclared can be we certain that we can do it without caching\n\t\t# if rlen && typ == 'var' && !lsplat\n\t\t# \t# this can be dangerous in edgecases that are very hard to detect\n\t\t# \t# if it becomes an issue, fall back to simpler versions\n\t\t# \t# does not even matter if there is a splat?\n\n\t\t# special case for arguments(!)\n\t\tif !lsplat && rgt == ARGUMENTS\n\n\t\t\tvar pars = scope__.params\n\t\t\t# p \"special case with arguments {pars}\"\n\t\t\t# forcing the arguments to be named\n\t\t\t# p \"got here??? {pars}\"\n\t\t\tlft.map do |l,i| ast.push OP('=',l.node,pars.at(i,yes).visit.variable) # s.params.at(value - 1,yes)\n\n\t\t\n\t\telif rlen\n\t\t\t# we have several items in the right part. what about splats here?\n\n\t\t\t# pre-evaluate rvalues that might be reference from other assignments\n\t\t\t# we need to check if the rightside values has no side-effects. Cause if\n\t\t\t# they dont, we really do not need temporary variables.\n\n\t\t\t# some of these optimizations are quite petty - makes things more complicated\n\t\t\t# in the compiler only to get around adding a few temp-variables here and there\n\n\t\t\t# var firstUnsafe = 0\n\t\t\t# lft.map do |v,i|\n\t\t\t# \tif v isa VarReference\n\t\t\t# \t\tp \"left side {i} {v} {v.refnr}\"\n\n\t\t\t# rgt.map do |v,i|\n\t\t\t# \tif v.hasSideEffects\n\t\t\t# \t\t# return if i == 0 or !v.hasSideEffects\n\t\t\t# \t\t# return if v isa Num || v isa Str || i == 0\n\t\t\t# \t\t# we could explicitly create a temporary variable and adding nodes for accessing etc\n\t\t\t# \t\t# but the builtin caching should really take care of this for us\n\t\t\t# \t\t# we need to really force the caching though -- since we need a copy of it even if it is a local\n\t\t\t# \t\t# we need to predeclare the variables at the top of scope if this does not take care of it\n\t\t\t# \t\t\n\t\t\t# \t\t# these are the declarations -- we need to add them somewhere smart\n\t\t\t# \t\t@temporary.push(v) # need a generalized way to do this type of thing\n\t\t\t# \t\tast.push(v.cache(force: yes, type: 'swap', declared: typ == 'var'))\n\t\t\t# \t\t# they do need to be declared, no?\n\n\t\t\t# now we can free the cached variables\n\t\t\t# ast.map do |n| n.decache\n\n\t\t\tvar pre = []\n\t\t\tvar rest = []\n\n\t\t\tvar pairs = lft.map do |l,i|\n\t\t\t\tvar v = nil\n\t\t\t\t# determine if this needs to be precached?\n\t\t\t\t# if l isa VarReference\n\t\t\t\t# \t# this is the first time the variable is referenced\n\t\t\t\t# \t# should also count even if it is predeclared at the top\n\t\t\t\t# \tif l.refnr == 0\n\n\t\t\t\tif l == lsplat\n\t\t\t\t\tv = []\n\t\t\t\t\tvar to = (rlen - (ri - i))\n\t\t\t\t\t# p \"assing splat at index {i} to slice {li} - {to}\".cyan\n\t\t\t\t\tv.push(rgt.index(li++)) while li <= to\n\t\t\t\t\tv = Arr.new(v)\n\t\t\t\t\t# ast.push OP('=',l.node,Arr.new(v))\n\t\t\t\telse\n\t\t\t\t\tv = rgt.index(li++)\n\t\t\t\t[l.node,v]\n\n\t\t\t\t# if l isa VarReference && l.refnr \n\t\t\tvar clean = true\n\t\t\t\n\t\t\tpairs.map do |v,i|\n\t\t\t\tvar l = v[0]\n\t\t\t\tvar r = v[1]\n\n\t\t\t\tif clean\n\t\t\t\t\tif l isa VarReference && l.refnr == 0\n\t\t\t\t\t\t# still clean\n\t\t\t\t\t\tclean = yes\n\t\t\t\t\telse\n\t\t\t\t\t\tclean = no\n\t\t\t\t\t\t# p \"now cache\"\n\t\t\t\t\t\tpairs.slice(i).map do |part|\n\t\t\t\t\t\t\tif part[1].hasSideEffects\n\t\t\t\t\t\t\t\t@temporary.push(part[1]) # need a generalized way to do this type of thing\n\t\t\t\t\t\t\t\tast.push(part[1].cache(force: yes, type: 'swap', declared: typ == 'var'))\n\t\t\t\t\t\t# p \"from {i} - cache all remaining with side-effects\"\n\n\t\t\t\t# if the previous value in ast is a reference to our value - the caching was not needed\n\t\t\t\tif ast.last == r\n\t\t\t\t\tr.decache\n\t\t\t\t\t# p \"was cached - not needed\"\n\t\t\t\t\tast.replace(r,OP('=',l,r))\n\t\t\t\telse\n\t\t\t\t\tast.push OP('=',l,r)\n\n\t\t\t# WARN FIXME Is there not an issue with VarBlock vs not here?\n\t\telse \n\t\t\t# this is where we need to cache the right side before assigning\n\t\t\t# if the right side is a for loop, we COULD try to be extra clever, but\n\t\t\t# for now it is not worth the added compiler complexity\n\t\t\t\n\t\t\t# iter.cache(force: yes, type: 'iter')\n\t\t\tvar top = VarBlock.new\n\t\t\tvar iter = util.iterable(rgt, yes)\n\t\t\t# could set the vars inside -- most likely\n\t\t\tast.push(top)\n\t\t\ttop.push(iter)\n\n\t\t\tif lsplat\n\t\t\t\tvar len = util.len(iter, yes)\n\t\t\t\tvar idx = util.counter(0, yes)\n\t\t\t\t# cache the length of the array\n\t\t\t\ttop.push(len) # preassign the length\n\t\t\t\t# cache counter to loop through\n\t\t\t\ttop.push(idx)\n\n\t\t\t# only if the block is variable based, no?\n\t\t\t# ast.push(blk = VarBlock.new)\n\t\t\t# blk = nil\n\t\t\t\n\t\t\tvar blktype = typ == 'var' ? VarBlock : Block\n\t\t\tvar blk = blktype.new\n\t\t\t# blk = top if typ == 'var'\n\t\t\tast.push(blk)\n\n\t\t\t# if the lvals are not variables - we need to preassign\n\t\t\t# can also use slice here for simplicity, but try with while now\t\t\t\n\t\t\tlft.map do |l,i|\n\t\t\t\tif l == lsplat\n\t\t\t\t\tvar lvar = l.node\n\t\t\t\t\tvar rem = llen - i - 1 # remaining after splat\n\n\t\t\t\t\tif typ != 'var'\n\t\t\t\t\t\tvar arr = util.array(OP('-',len, num__(i + rem) ),yes)\n\t\t\t\t\t\ttop.push(arr)\n\t\t\t\t\t\tlvar = arr.cachevar\n\t\t\t\t\telse\n\t\t\t\t\t\tast.push(blk = blktype.new) unless blk\n\t\t\t\t\t\tvar arr = util.array( OP('-',len,num__(i + rem) ) )\n\t\t\t\t\t\tblk.push(OP('=',lvar,arr))\n\n\t\t\t\t\t# if !lvar:variable || !lvar.variable # lvar = \n\t\t\t\t\t# \ttop.push()\n\t\t\t\t\t#\tp \"has variable - no need to create a temp\"\n\t\t\t\t\t# blk.push(OP('=',lvar,Arr.new([]))) # dont precalculate size now\n\t\t\t\t\t# max = to = (rlen - (llen - i))\n\t\t\t\t\t\n\t\t\t\t\t \n\t\t\t\t\tvar test = rem ? OP('-',len,rem) : len\n\n\t\t\t\t\tvar set = OP('=',\n\t\t\t\t\t\tOP('.',lvar,OP('-',idx,num__(i))),\n\t\t\t\t\t\tOP('.',iter,OP('++',idx))\n\t\t\t\t\t)\n\n\t\t\t\t\tast.push(WHILE(OP('<',idx,test), set))\n\n\t\t\t\t\tif typ != 'var'\n\t\t\t\t\t\tast.push(blk = Block.new) \n\t\t\t\t\t\tblk.push(OP('=',l.node,lvar))\n\t\t\t\t\telse\n\t\t\t\t\t\tblk = nil\n\n\t\t\t\t\t# not if splat was last?\n\t\t\t\t\t# ast.push(blk = VarBlock.new)\n\n\t\t\t\telif lsplat\n\t\t\t\t\tast.push(blk = blktype.new) unless blk\n\t\t\t\t\t# we could cache the raw code of this node for better performance\n\t\t\t\t\tblk.push(OP('=',l,OP('.',iter,OP('++',idx))))\n\t\t\t\telse\n\t\t\t\t\tast.push(blk = blktype.new) unless blk\n\t\t\t\t\tblk.push(OP('=',l,OP('.',iter,num__(i) )))\n\n\n\t\tif ast.isExpressable # NO!\n\t\t\tvar out = ast.c(expression: yes)\n\t\t\tout = \"{typ} {out}\" if typ\n\t\t\treturn out\n\t\telse\n\t\t\treturn ast.c\n\n\n# IDENTIFIERS\n\n# really need to clean this up\nexport class Identifier < ValueNode\n\n\tprop safechain\n\n\tdef load v\n\t\tvar val = (v isa Identifier ? v.value : v)\n\t\tvar len = val:length\n\t\t# experimental way to include reserved-info\n\t\t# if v.match()\n\n\t\t# no?\n\t\tif val[len - 1] == '?'\n\t\t\tthrow \"Identifier#load\"\n\t\t\t# console.log \"nonono --\"\n\t\t\t# p \"safechain identifier?!\"\n\t\t\tsafechain = yes\n\t\t\tval = val.substr(0,len - 1)\n\n\t\treturn val\n\n\tdef isValidIdentifier\n\t\tyes\n\t\t\n\tdef isReserved\n\t\t# hmm\n\t\t@value:reserved\n\n\tdef symbol\n\t\t@symbol ||= sym__(value)\n\n\tdef setter\n\t\t@setter ||= Identifier.new(\"set-{value.c}\")\n\n\tdef toString\n\t\tString(@value)\n\n\tdef js\n\t\tsym__(@value)\n\n\tdef c\n\t\tsym__(@value)\n\n\tdef dump\n\t\t{ loc: region, value: value }\n\n\t\t\nexport class TagId < Identifier\n\n\tdef js\n\t\t\"id$('{value.c}')\"\n\t\t\n# This is not an identifier - it is really a string\n# Is this not a literal?\n\n# FIXME Rename to IvarLiteral? or simply Literal with type Ivar\nexport class Ivar < Identifier\n\n\tdef name\n\t\thelpers.camelCase(@value).replace(/^@/,'')\n\t\t# value.c.camelCase.replace(/^@/,'')\n\n\t# the @ should possibly be gone from the start?\n\tdef js\n\t\t'_' + name\n\n\tdef c\n\t\t'_' + helpers.camelCase(@value).replace(/^@/,'')\n\n# Ambiguous - We need to be consistent about Const vs ConstAccess\n# Becomes more important when we implement typeinference and code-analysis\nexport class Const < Identifier\n\n\nexport class TagTypeIdentifier < Identifier\n\n\tprop name\n\tprop ns\n\n\tdef load val\n\t\t@str = (\"\" + val)\n\t\tvar parts = @str.split(\":\")\n\t\t@raw = val\n\t\t@name = parts.pop\n\t\t@ns = parts.shift # if any?\n\t\treturn @str\n\n\tdef js\n\t\t# p \"tagtypeidentifier.js {self}\"\n\t\treturn \"IMBA_TAGS.{@str.replace(\":\",\"$\")}\"\n\n\tdef c\n\t\tjs\n\n\tdef func\n\t\tvar name = @name.replace(/-/g,'_').replace(/\\#/,'') # hmm\n\t\tname += \"${@ns.toLowerCase}\" if @ns\n\t\tname\n\n\tdef id\n\t\tvar m = @str.match(/\\#([\\w\\-\\d\\_]+)\\b/)\n\t\tm ? m[1] : nil\n\t\t\n\n\tdef flag\n\t\t\"_\" + name.replace(/--/g,'_').toLowerCase\n\n\tdef sel\n\t\t\".{flag}\" # + name.replace(/-/g,'_').toLowerCase\n\n\tdef string\n\t\tvalue\n\n\nexport class Argvar < ValueNode\n\n\tdef c\n\t\t# NEXT -- global.parseInt or Number.parseInt (better)\n\t\tvar v = parseInt(String(value))\n\t\t# FIXME Not needed anymore? I think the lexer handles this\n\t\treturn \"arguments\" if v == 0\n\n\t\tvar s = scope__\n\t\t# params need to go up to the closeste method-scope\n\t\tvar par = s.params.at(v - 1,yes)\n\t\t\"{c__(par.name)}\" # c\n\n\n# CALL\n\nexport class Call < Expression\n\n\tprop callee\n\tprop receiver\n\tprop args\n\tprop block\n\n\tdef initialize callee, args, opexists\n\t\t# some axioms that share the same syntax as calls will be redirected from here\n\t\t\n\t\tif callee isa VarOrAccess\n\t\t\tvar str = callee.value.symbol\n\t\t\t# p \"Call callee {callee} - {str}\"\n\t\t\tif str == 'extern'\n\t\t\t\t# p \"returning extern instead!\"\n\t\t\t\treturn ExternDeclaration.new(args)\n\t\t\tif str == 'tag'\n\t\t\t\t# console.log \"ERROR - access args by some method\"\n\t\t\t\treturn TagWrapper.new(args and args:index ? args.index(0) : args[0]) # hmmm\n\t\t\tif str == 'export'\n\t\t\t\treturn ExportStatement.new(args) # hmmm\n\n\t\t@callee = callee\n\t\t@args = args or ArgList.new([]) # hmmm\n\n\t\tif args isa Array\n\t\t\t@args = ArgList.new(args)\n\t\t\t# console.log \"ARGUMENTS IS ARRAY - error {args}\"\n\t\t# p \"call opexists {opexists}\"\n\t\tself\n\n\tdef visit\n\t\t# console.log \"visit args {args}\"\n\t\targs.traverse\n\t\tcallee.traverse\n\n\t\t@block && @block.traverse \n\n\tdef addBlock block\n\t\t# if args.names\n\t\t# p \"addBlock to call!\"\n\t\t# var idx = -1\n\t\tvar pos = @args.filter(|n,i| n == '&')[0]\n\t\t# idx = i if n == '&'\n\t\t# p \"FOUND LOGIC\"\n\t\t# p \"node in args {i} {n}\"\n\t\tpos ? args.replace(pos,block) : args.push(block)\n\t\t# args.push(block)\n\t\tself\n\n\tdef receiver\n\t\t@receiver ||= (callee isa Access && callee.left || NULL)\n\n\t# check if all arguments are expressions - otherwise we have an issue\n\n\tdef safechain\n\t\tcallee.safechain # really?\n\n\tdef c\n\t\tsuper\n\n\tdef js\n\t\tvar opt = expression: yes\n\t\tvar rec = null\n\t\tvar args = compact__(args)\n\t\tvar splat = args.some do |v| v isa Splat\n\t\tvar out = nil\n\t\tvar lft = nil\n\t\tvar rgt = nil\n\t\tvar wrap = nil\n\n\t\tvar callee = @callee = @callee.node # drop the var or access?\n\n\t\t# p \"{self} - {@callee}\"\n\n\t\tif callee isa Call && callee.safechain\n\t\t\t# p \"the outer call is safechained\"\n\t\t\tyes\n\t\t\t# we need to specify that the _result_ of\n\n\t\tif callee isa Access\n\t\t\tlft = callee.left\n\t\t\trgt = callee.right\n\n\t\tif callee isa Super or callee isa SuperAccess\n\t\t\t@receiver = scope__.context\n\t\t\t# return \"supercall\"\n\n\t\t# never call the property-access directly?\n\t\tif callee isa PropertyAccess # && rec = callee.receiver\n\t\t\t# p \"unwrapping property-access in call\"\n\t\t\t@receiver = callee.receiver\n\t\t\tcallee = @callee = OP('.',callee.left,callee.right)\n\t\t\t# console.log \"unwrapping the propertyAccess\"\n\t\t\t\n\n\t\tif lft && lft.safechain\n\t\t\t# p \"Call[left] is safechain {lft}\".blue\n\t\t\tlft.cache\n\t\t\t# we want to \n\t\t\t# wrap = [\"{}\"]\n\t\t\t# p \"Call should not cache whole result - only the result of the call\".red\n\n\n\t\tif callee.safechain\n\t\t\t# \n\t\t\t# if lft isa Call\n\t\t\t# if lft isa Call # could be a property access as well - it is the same?\n\t\t\t# if it is a local var access we simply check if it is a function, then call\n\t\t\t# but it should be safechained outside as well?\n\t\t\tlft.cache if lft\n\t\t\t# the outer safechain should not cache the whole call - only ask to cache\n\t\t\t# the result? -- chain onto\n\t\t\t# p \"Call safechain {callee} {lft}.{rgt}\"\n\t\t\tvar isfn = Util.IsFunction.new([callee])\n\t\t\twrap = [\"{isfn.c} && \",\"\"]\n\n\t\t# if callee.right\n\t\t# if calle is PropertyAccess we should convert it first\n\t\t# to keep the logic in call? \n\t\t# \n\n\t\t# if \n\n\t\t# should just force expression from the start, no?\n\t\tif splat\n\t\t\t# important to wrap the single value in a value, to keep implicit call\n\t\t\t# this is due to the way we check for an outer Call without checking if\n\t\t\t# we are the receiver (in PropertyAccess). Should rather wrap in CallArguments\n\t\t\tvar ary = (args.count == 1 ? ValueNode.new(args.first.value) : Arr.new(args.list))\n\t\t\treceiver.cache # need to cache the target\n\t\t\tout = \"{callee.c(expression: yes)}.apply({receiver.c},{ary.c(expression: yes)})\"\n\n\t\telif @receiver\n\t\t\t@receiver.cache\n\t\t\targs.unshift(receiver)\n\t\t\t# should rather rewrite to a new call?\n\t\t\tout = \"{callee.c(expression: yes)}.call({args.c(expression: yes)})\"\n\n\t\telse\n\t\t\tout = \"{callee.c(expression: yes)}({args.c(expression: yes)})\"\n\n\t\tif wrap\n\t\t\t# we set the cachevar inside\n\t\t\t# p \"special caching for call\"\n\t\t\tif @cache\n\t\t\t\t@cache:manual = yes \n\t\t\t\tout = \"({cachevar.c}={out})\"\n\n\t\t\tout = [wrap[0],out,wrap[1]].join(\"\")\n\n\t\treturn out\n\n\n\n\t\t\nexport class ImplicitCall < Call\n\n\tdef js\n\t\t\"{callee.c}()\"\n\n\n\nexport class New < Call\n\n\tdef js o\n\t\t# \n\t\tvar out = \"new {callee.c}\"\n\t\tout += '()' unless o.parent isa Call\n\t\tout\n\t\t# \"{callee.c}()\"\n\n\n\nexport class SuperCall < Call\n\n\tdef js o\n\t\tvar m = o.method\n\t\tself.receiver = SELF\n\t\tself.callee = \"{m.target.c}.super$.prototype.{m.name.c}\"\n\t\tsuper\n\n\n\nexport class ExternDeclaration < ListNode\n\n\tdef visit\n\t\t# p \"visiting externdeclaration\"\n\t\tnodes = map do |item| item.node # drop var or access really\n\t\t# only in global scope?\n\t\tvar root = scope__\n\t\tnodes.map do |item|\n\t\t\tvar variable = root.register item.symbol, item, type: 'global' # hmmmm\n\t\t\tvariable.addReference(item)\n\t\tself\n\n\tdef c\n\t\t\"// externs\"\n\t\t# register :global, self, type: 'global'\n\t\t\n\t\t\n\n# FLOW\n\nexport class ControlFlow < Node\n\n\n\nexport class ControlFlowStatement < ControlFlow\n\n\tdef isExpressable\n\t\tno\n\n\n\nexport class If < ControlFlow\n\n\n\tprop test\n\tprop body\n\tprop alt\n\n\n\tdef addElse add\n\t\t# p \"add else!\",add\n\t\tif alt && alt isa If\n\t\t\t# p 'add to the inner else(!)',add\n\t\t\talt.addElse(add)\n\t\telse\n\t\t\tself.alt = add\n\t\tself\n\n\n\tdef initialize cond, body, o = {}\n\t\t# p \"IF options\",o && o:type\n\t\t@test = (o:type == 'unless' ? OP('!',cond) : cond)\n\t\t@body = body\n\n\n\tdef visit\n\t\ttest.traverse if test\n\t\tbody.traverse if body\n\t\talt.traverse if alt\n\n\n\tdef js o\n\t\t# would possibly want to look up / out \n\t\tvar brace = braces: yes, indent: yes\n\n\t\tvar cond = test.c(expression: yes) # the condition is always an expression\n\t\t\n\n\t\tif o.isExpression\n\t\t\tvar code = body.c # (braces: yes)\n\t\t\t# is expression!\n\t\t\tif alt\n\t\t\t\t# be safe - wrap condition as well\n\t\t\t\treturn \"({cond}) ? ({code}) : ({alt.c})\"\n\t\t\telse\n\t\t\t\t# again - we need a better way to decide what needs parens\n\t\t\t\t# maybe better if we rewrite this to an OP('&&'), and put\n\t\t\t\t# the parens logic there\n\t\t\t\treturn \"({cond}) && ({code})\"\n\t\telse\n\t\t\tvar code = body.c(brace) # (braces: yes)\n\t\t\t# don't wrap if it is only a single expression?\n\t\t\tvar out = \"if({cond}) \" + code # ' {' + code + '}' # '{' + code + '}'\n\t\t\tout += \" else {alt.c(alt isa If ? {} : brace)}\" if alt\n\t\t\tout\n\n\n\tdef consume node\n\t\t# p 'assignify if?!'\n\t\t# if it is possible, convert into expression\n\t\tif node isa TagTree\n\t\t\t# p \"TAG TREEEEEE\"\n\t\t\t# hmmm\n\t\t\t@body = body.consume(node)\n\t\t\t@alt = alt.consume(node) if alt\n\t\t\treturn self\n\n\t\tif isExpressable\n\t\t\ttoExpression # mark as expression(!)\n\t\t\treturn super\n\t\telse\n\t\t\t@body = body.consume(node)\n\t\t\t@alt = alt.consume(node) if alt\n\t\tself\n\n\n\tdef isExpressable\n\t\tvar exp = body.isExpressable && (!alt || alt.isExpressable)\n\t\t# if exp\n\t\t# \tp \"if is expressable\".green\n\t\t# else\n\t\t# \tp \"if is not expressable\".red\n\t\treturn exp\n\n\n\nexport class Loop < Statement\n\n\n\tprop scope\n\tprop options\n\tprop body\n\tprop catcher\n\n\n\tdef initialize options = {}\n\t\tself.options = options \n\t\tself\n\n\n\tdef set obj\n\t\t# p \"configure for!\"\n\t\t@options ||= {}\n\t\tvar keys = Object.keys(obj)\n\t\tfor k in keys\n\t\t\t@options[k] = obj[k]\n\t\tself\n\n\n\tdef addBody body\n\t\tself.body = blk__(body)\n\t\tself\n\n\n\tdef c o\n\t\t# p \"Loop.c - {isExpressable} {stack} {stack.isExpression}\"\n\t\t# p \"stack is expression? {o} {isExpression}\"\n\n\t\tif stack.isExpression or isExpression\n\t\t\t# what the inner one should not be an expression though?\n\t\t\t# this will resut in an infinite loop, no?!?\n\t\t\tvar ast = CALL(FN([],[self]),[])\n\t\t\treturn ast.c o\n\t\t\n\t\telif stack.current isa Block\n\t\t\t# hmm - need to check more thoroughly\n\t\t\t# p \"parent is a block!\"\n\t\t\tsuper.c o\n\t\telse\n\t\t\t# p \"Should never get here?!?\"\n\t\t\tvar ast = CALL(FN([],[self]),[])\n\t\t\treturn ast.c o\n\t\t\t# need to wrap in function\n\n\n\nexport class While < Loop\n\n\n\tprop test\n\n\n\tdef initialize test, opts\n\t\t@test = test\n\t\t@scope = WhileScope.new(self)\n\t\tset(opts) if opts\n\t\t# p \"invert test for while? {@test}\"\n\t\tif option(:invert)\n\t\t\t# \"invert test for while {@test}\"\n\t\t\t@test = test.invert \n\t\t# invert the test\n\n\n\tdef visit\n\t\tscope.visit\n\t\ttest.traverse if test\n\t\tbody.traverse if body\n\n\n\t# TODO BUG -- when we declare a var like: while var y = ...\n\t# the variable will be declared in the WhileScope which never\n\t# force-declares the inner variables in the scope\n\n\tdef consume node\n\t\t# p \"While.consume {node}\".cyan\n\t\t# This is never expressable, but at some point\n\t\t# we might want to wrap it in a function (like CS)\n\t\treturn super if isExpressable\n\n\t\tif node isa TagTree\n\t\t\t# WARN this is a hack to allow references coming through the wrapping scope \n\t\t\t# will result in unneeded self-declarations and other oddities\n\t\t\tscope.context.reference\n\t\t\treturn CALL(FN([],[self]),[])\n\n\t\tvar reuse = no\n\t\t# WARN Optimization - might have untended side-effects\n\t\t# if we are assigning directly to a local variable, we simply\n\t\t# use said variable for the inner res\n\t\t# if reuse\n\t\t# \tresvar = scope.declare(node.left.node.variable,Arr.new([]),proxy: yes)\n\t\t# \tnode = null\n\t\t# \tp \"consume variable declarator!?\".cyan\n\t\t# else\n\t\t# declare the variable we will use to soak up results\n\t\t# p \"Creating value to store the result of loop\".cyan\n\t\t# TODO Use a special vartype for this?\n\t\tvar resvar = scope.declare(:res,Arr.new([]),system: yes)\n\t\t# WHAT -- fix this --\n\t\t@catcher = PushAssign.new(\"push\",resvar,null) # the value is not preset # what\n\t\tbody.consume(@catcher) # should still return the same body\n\n\t\t# scope vars must not be compiled before this -- this is important\n\t\tvar ast = BLOCK(self,resvar.accessor) # should be varaccess instead? # hmmm?\n\t\tast.consume(node)\n\t\t# NOTE Here we can find a way to know wheter or not we even need to \n\t\t# return the resvar. Often it will not be needed\n\t\t# FIXME what happens if there is no node?!?\n\n\n\tdef js\n\t\tvar out = \"while({test.c(expression: yes)})\" + body.c(braces: yes, indent: yes) # .wrap\n\n\t\tif scope.vars.count > 0\n\t\t\t# p \"while-block has declared variables(!)\"\n\t\t\treturn [scope.vars.c,out]\n\t\tout\n\n\n\n# This should define an open scope\n# should rather \nexport class For < Loop\n\n\n\tdef initialize o = {}\n\t\t@options = o\n\t\t@scope = ForScope.new(self)\n\n\n\tdef visit\n\t\tscope.visit\n\t\tdeclare\n\t\t# should be able to toggle whether to keep the results here already(!)\n\t\tbody.traverse\n\t\toptions[:source].traverse # what about awakening the vars here?\n\n\n\tdef declare\n\t\tvar scope = scope\n\t\tvar src  = options:source\n\t\tvar vars = options[:vars] = {}\n\t\tvar oi   = options:index\n\n\n\t\t# var i = vars:index = oi ? scope.declare(oi,0) : util.counter(0,yes).predeclare\n\n\t\tif src isa Range\n\t\t\t# p \"range for-loop\"\n\t\t\tvars:len = scope.declare('len',src.right) # util.len(o,yes).predeclare\n\t\t\tvars:index = scope.declare(options:name,src.left)\n\t\t\tvars:value = vars:index\n\t\telse\t\t\t\n\t\t\t# vars:value = scope.declare(options:name,null,let: yes)\n\t\t\t# we are using automatic caching far too much here\n\t\t\tvar i = vars:index = oi ? scope.declare(oi,0, let: yes) : util.counter(0,yes,scope).predeclare\n\t\t\tvars:source = util.iterable(src,yes).predeclare # hmm\n\t\t\tvars:len    = util.len(vars:source,yes).predeclare # hmm\n\t\t\tvars:value  = scope.declare(options:name,null,let: yes)\n\t\t\tvars:value.addReference(options:name) # adding reference!\n\t\t\ti.addReference(oi) if oi\n\n\t\treturn self\n\n\n\tdef consume node\n\t\t# p \"Loop consume? {node}\"\n\t\t# p \"For.consume {node}\".cyan\n\t\treturn super if isExpressable\n\n\t\t# other cases as well, no?\n\t\tif node isa TagTree\n\t\t\t# WARN this is a hack to allow references coming through the wrapping scope \n\t\t\t# will result in unneeded self-declarations and other oddities\n\t\t\t# scope.parent.context.reference\n\t\t\tscope.context.reference\n\t\t\treturn CALL(Lambda.new([],[self]),[])\n\t\t\t\n\n\t\tvar resvar = null\n\t\tvar reuseable = node isa Assign && node.left.node isa LocalVarAccess\n\n\t\t# WARN Optimization - might have untended side-effects\n\t\t# if we are assigning directly to a local variable, we simply\n\t\t# use said variable for the inner res\n\t\tif reuseable\n\t\t\t\n\t\t\tresvar = scope.declare(node.left.node.variable,Arr.new([]),proxy: yes)\n\t\t\tnode = null\n\t\t\t# p \"consume variable declarator!?\".cyan\n\t\telse\n\t\t\t# declare the variable we will use to soak up results\n\t\t\t# p \"Creating value to store the result of loop\".cyan\n\t\t\tresvar = scope.declare(:res,Arr.new([]),system: yes)\n\n\t\t# p \"GOT HERE TO PUSH ASSIGN\",PushAssign\n\t\t@catcher = PushAssign.new(\"push\",resvar,null) # the value is not preset\n\t\tbody.consume(@catcher) # should still return the same body\n\n\t\tvar ast = BLOCK(self,resvar.accessor) # should be varaccess instead?\n\t\tast.consume(node) if node\n\t\t# this is never an expression (for now -- but still)\n\t\treturn ast\n\n\n\tdef js\n\t\tvar vars = options:vars\n\t\tvar i = vars:index\n\t\tvar val = vars:value\n\t\tvar cond = OP('<',i,vars:len)\n\t\tvar src = options:source\n\n\t\t# p \"references for value\",val.references:length\n\n\t\tvar final = if options:step\n\t\t\tOP('=',i,OP('+',i,options:step))\n\t\telse\n\t\t\tOP('++',i)\n\n\t\t# if there are few references to the value - we can drop\n\t\t# the actual variable and instead make it proxy through the index\n\t\tif src isa Range\n\t\t\tcond.op = '<=' if src.inclusive\n\t\t\n\t\telif val.refcount < 3\n\t\t\t# p \"should proxy value-variable instead\"\n\t\t\tval.proxy(vars:source,i)\n\t\telse\n\t\t\tbody.unshift(OP('=',val,OP('.',vars:source,i)))\n\t\t\t# body.unshift(head)\n\t\t\t# TODO check lengths - intelligently decide whether to brace and indent\n\t\tvar head = \"for({scope.vars.c}; {cond.c}; {final.c}) \"\n\t\thead + body.c(braces: yes, indent: yes) # .wrap\n\n\n\tdef head\n\t\tvar vars = options:vars\n\t\tOP('=',vars:value,OP('.',vars:source,vars:index))\n\n\n\nexport class ForIn < For\n\n\n\t\t\nexport class ForOf < For\n\n\tdef declare\n\t\tvar vars = options:vars = {}\n\n\t\tvar o = vars:source = scope.declare('o',options:source,system: true)\n\t\tvar v = vars:value = scope.declare(options:index,null,let: yes) if options:index\n\n\t\tif options:own\n\t\t\tvar i = vars:index  = scope.declare('i',0,system: true)\n\t\t\tvar keys = vars:keys = scope.declare(:keys,Util.keys(o.accessor),system: yes)\n\t\t\tvar l = vars:len = scope.declare('l',Util.len(keys.accessor),system: yes)\n\t\t\tvar k = vars:key = scope.declare(options:name,null,system: yes)\n\t\telse\n\t\t\t# we set the var\n\t\t\tvar k = vars:key = scope.declare(options:name,nil, system: yes)\n\t\t\n\t\t# TODO use util - why add references already? Ah -- this is for the highlighting\n\t\tv.addReference(options:index) if v and options:index\n\t\tk.addReference(options:name) if k and options:name\n\n\t\tself\n\n\tdef js\n\t\tvar vars = options:vars\n\n\t\tvar o = vars:source\n\t\tvar k = vars:key\n\t\tvar v = vars:value\n\t\tvar i = vars:index\n\n\n\t\tif v \n\t\t\t# set value as proxy of object[key]\n\t\t\tv.refcount < 3 ? v.proxy(o,k) : body.unshift(OP('=',v,OP('.',o,k)))\n\n\t\tif options:own\n\n\t\t\tif k.refcount < 3 # should probably adjust these\n\t\t\t\tk.proxy(vars:keys,i)\n\t\t\telse\n\t\t\t\tbody.unshift(OP('=',k,OP('.',vars:keys,i)))\n\n\t\t\tvar head = \"for({scope.vars.c}; {OP('<',i,vars:len).c}; {OP('++',i).c})\"\n\t\t\treturn head + body.c(indent: yes, braces: yes) # .wrap\n\n\t\tvar code = body.c(braces: yes, indent: yes)\n\t\t# it is really important that this is a treated as a statement\n\t\t[scope.vars.c,\"for(var {k.c} in {o.c})\" + code]\n\n\tdef head\n\t\tvar v = options:vars\n\n\t\t[\n\t\t\tOP('=',v:key,OP('.',v:keys,v:index))\n\t\t\tOP('=',v:value,OP('.',v:source,v:key)) if v:value\n\t\t]\n\n\n\nexport class Begin < Block\n\n\n\tdef initialize body\n\t\t@nodes = blk__(body).nodes\n\n\n\tdef shouldParenthesize\n\t\tisExpression # hmmm\n\n\n\nexport class Switch < ControlFlowStatement\n\n\n\tprop source\n\tprop cases\n\tprop fallback\n\n\n\tdef initialize a,b,c\n\t\t@source = a\n\t\t@cases = b\n\t\t@fallback = c\n\n\n\tdef visit\n\t\tcases.map do |item| item.traverse\n\t\tfallback.visit if fallback\n\t\tsource.visit if source\n\n\n\tdef consume node\n\t\t@cases = @cases.map(|item| item.consume(node))\n\t\t@fallback = @fallback.consume(node) if @fallback\n\t\tself\n\n\n\tdef js\n\t\tvar body = []\n\n\t\tfor part in cases\n\t\t\tpart.autobreak\n\t\t\tbody.push(part)\n\n\t\tif fallback\n\t\t\tbody.push(\"default:\\n\" + fallback.c(indent: yes))\n\n\t\t\"switch({source.c}) \" + helpers.bracketize(cary__(body).join(\"\\n\"),yes)\n\n\n\nexport class SwitchCase < ControlFlowStatement\n\n\n\tprop test\n\tprop body\n\n\n\tdef initialize test, body\n\t\t@test = test\n\t\t@body = blk__(body)\n\n\tdef visit\n\t\tbody.traverse\n\n\n\tdef consume node\n\t\tbody.consume(node)\n\t\tself\n\n\n\tdef autobreak\n\t\tbody.push(BreakStatement.new) unless body.last isa BreakStatement\n\t\tself\n\n\n\tdef js\n\t\t@test = [@test] unless @test isa Array \n\t\tvar cases = @test.map do |item| \"case {item.c}:\"\n\t\tcases.join(\"\\n\") + body.c(indent: yes) # .indent\n\n\n\nexport class Try < ControlFlowStatement\n\n\n\tprop body\n\t# prop ncatch\n\t# prop nfinally\n\n\tdef initialize body, c, f\n\t\t@body = blk__(body)\n\t\t@catch = c\n\t\t@finally = f\n\n\n\tdef consume node\n\t\t@body = @body.consume(node)\n\t\t@catch = @catch.consume(node) if @catch\n\t\t@finally = @finally.consume(node) if @finally\n\t\tself\n\n\n\tdef visit\n\t\t@body.traverse\n\t\t@catch.traverse if @catch\n\t\t@finally.traverse if @finally\n\t\t# no blocks - add an empty catch\n\n\n\tdef js\n\t\tvar out = \"try \" + body.c(braces: yes, indent: yes) + \"\\n\"\n\t\tout += @catch.c if @catch\n\t\tout += @finally.c if @finally\n\n\t\tunless @catch or @finally\n\t\t\tout += \"catch(e)\\{\\}\"\n\t\tout\n\n\n\nexport class Catch < ControlFlowStatement\n\n\n\tdef initialize body, varname\n\t\t@body = blk__(body)\n\t\t@scope = CatchScope.new(self)\n\t\t@varname = varname\n\n\n\tdef consume node\n\t\t@body = @body.consume(node)\n\t\tself\n\n\n\tdef visit\n\t\t@scope.visit\n\t\t@variable = @scope.register(@varname,self,type: 'catchvar')\n\t\t@body.traverse\n\n\n\tdef js\n\t\t\"catch ({@variable.c}) \" + @body.c(braces: yes, indent: yes) + \"\\n\"\n\n\n# repeating myself.. don't deal with it until we move to compact tuple-args\n# for all astnodes\n\n\nexport class Finally < ControlFlowStatement\n\n\tdef initialize body\n\t\t@body = blk__(body)\n\n\n\tdef visit\n\t\t@body.traverse\n\n\n\tdef consume node\n\t\t# swallow silently\n\t\tself\n\n\n\tdef js\n\t\t\"finally \" + @body.c(braces: yes, indent: yes)\n\n\n# RANGE\n\nexport class Range < Op\n\n\tdef inclusive\n\t\top == '..'\n\t\t\n\tdef c\n\t\t\"range\"\n\n\nexport class Splat < ValueNode\n\n\tdef js\n\t\tvar par = stack.parent\n\t\tif par isa Arr\n\t\t\t\"[].slice.call({value.c})\"\n\t\telse\n\t\t\t\"SPLAT\"\n\n\tdef node\n\t\tvalue\n\n\n\n\n\n# TAGS\n\n\nTAG_TYPES = {}\nTAG_ATTRS = {}\n\n\nTAG_TYPES.HTML = \"a abbr address area article aside audio b base bdi bdo big blockquote body br \nbutton canvas caption cite code col colgroup data datalist dd del details dfn \ndiv dl dt em embed fieldset figcaption figure footer form h1 h2 h3 h4 h5 h6 \nhead header hr html i iframe img input ins kbd keygen label legend li link \nmain map mark menu menuitem meta meter nav noscript object ol optgroup option \noutput p param pre progress q rp rt ruby s samp script section select small \nsource span strong style sub summary sup table tbody td textarea tfoot th \nthead time title tr track u ul var video wbr\".split(\" \")\n\nTAG_TYPES.SVG = \"circle defs ellipse g line linearGradient mask path pattern polygon polyline \nradialGradient rect stop svg text tspan\".split(\" \")\n\nTAG_ATTRS.HTML = \"accept accessKey action allowFullScreen allowTransparency alt async \nautoComplete autoFocus autoPlay cellPadding cellSpacing charSet checked \nclassName cols colSpan content contentEditable contextMenu controls coords \ncrossOrigin data dateTime defer dir disabled download draggable encType form \nformNoValidate frameBorder height hidden href hrefLang htmlFor httpEquiv icon \nid label lang list loop max maxLength mediaGroup method min multiple muted \nname noValidate pattern placeholder poster preload radioGroup readOnly rel \nrequired role rows rowSpan sandbox scope scrollLeft scrolling scrollTop \nseamless selected shape size span spellCheck src srcDoc srcSet start step \nstyle tabIndex target title type useMap value width wmode\"\n\nTAG_ATTRS.SVG = \"cx cy d dx dy fill fillOpacity fontFamily fontSize fx fy gradientTransform \ngradientUnits markerEnd markerMid markerStart offset opacity \npatternContentUnits patternUnits points preserveAspectRatio r rx ry \nspreadMethod stopColor stopOpacity stroke strokeDasharray strokeLinecap \nstrokeOpacity strokeWidth textAnchor transform version viewBox x1 x2 x y1 y2 y\"\n\n\nexport class TagDesc < Node\n\n\tdef initialize\n\t\tp 'TagDesc!!!',$0\n\n\tdef classes\n\t\tp 'TagDescClasses',$0\n\t\tself\n\nexport class Tag < Expression\n\n\tprop parts\n\tprop object\n\tprop reactive\n\tprop parent\n\tprop tree\n\n\tdef initialize o = {}\n\t\t# p \"init tag\",$0\n\t\t@parts = []\n\t\to:classes ||= []\n\t\to:attributes ||= []\n\t\to:classes ||= []\n\t\t@options = o\n\n\tdef set obj\n\t\tfor own k,v of obj\n\n\t\t\tif k == 'attributes'\n\t\t\t\t# p \"attributs!\"\n\t\t\t\taddAttribute(atr) for atr in v\n\t\t\t\tcontinue\n\n\t\t\t@options[k] = v\n\t\tself\n\n\tdef addClass node\n\t\tunless node isa TagFlag\n\t\t\tnode = TagFlag.new(node)\n\t\t@options:classes.push(node)\n\t\t@parts.push(node)\n\n\t\t# p \"add class!!!\"\n\t\tself\n\n\tdef addIndex node\n\t\t@parts.push(node)\n\t\t# hmm\n\t\t@object = node\n\t\t# must be the first part?\n\t\tself\n\n\tdef addSymbol node\n\t\t# p \"addSymbol to the tag\",node\n\t\tif @parts:length == 0\n\t\t\t@parts.push(node)\n\t\t\t@options:ns = node\n\t\tself\n\t\t\n\n\tdef addAttribute atr\n\t\t# p \"add attribute!!!\", key, value\n\t\t@parts.push(atr) # what?\n\t\t@options:attributes.push(atr)\n\t\tself\n\n\tdef type\n\t\t@options:type || :div\n\n\tdef consume node\n\t\tif node isa TagTree\n\t\t\t# p \"tag consume tagtree? {node.reactive}\"\n\t\t\treactive = node.reactive or !!option(:ivar) # hmm\n\t\t\tparent = node.root # hmm\n\t\t\treturn self\n\t\telse\n\t\t\tsuper\n\n\tdef visit\n\t\tvar o = @options\n\t\tif o:body\n\t\t\t# force expression(!)\n\t\t\to:body.map(|v| v.traverse)\n\n\t\t# id should also be a regular part\n\t\t# hmm?\n\t\to:id.traverse if o:id\n\n\t\tfor part in @parts\n\t\t\tpart.traverse\n\n\t\t# for atr in @options:attributes\n\t\t# \tatr.traverse\n\n\t\tself\n\n\tdef reference\n\t\t# should resolve immediately to get the correct naming-structure that\n\t\t# reflects the nesting-level of the tag\n\t\t@reference ||= scope__.temporary(self,type: 'tag').resolve\n\n\t# should this not happen in js?\n\tdef js\n\t\t# p JSON.stringify(@options)\n\t\t# var attrs = TagAttributes.new(o:attributes)\n\t\t# p \"got here?\"\n\t\tvar o = @options\n\t\tvar a = {}\n\n\t\tvar setup = []\n\t\tvar calls = []\n\t\tvar statics = []\n\n\t\tvar scope = scope__\n\t\tvar commit = \"end\"\n\n\t\tvar isSelf = type isa Self\n\n\t\tfor atr in o:attributes\n\t\t\ta[atr.key] = atr.value # .populate(obj)\n\n\t\tvar quote = do |str| helpers.singlequote(str)\n\n\t\tvar id = o:id isa Node ? o:id.c : (o:id and quote(o:id.c))\n\n\n\n\t\t#  \"scope is\", !!scope\n\t\t# p \"type is {type}\"\n\t\tvar out = if isSelf\n\t\t\tcommit = \"synced\"\n\t\t\t# p \"got here\"\n\t\t\t# setting correct context directly\n\t\t\treactive = yes\n\t\t\t@reference = scope.context\n\t\t\t# hmm, not sure about this\n\t\t\tscope.context.c\n\n\t\telif o:id\n\t\t\t\"ti$('{type.func}',{id})\"\n\t\telse\n\t\t\t\"t$('{type.func}')\"\n\n\t\t# this is reactive if it has an ivar\n\t\tif o:ivar\n\t\t\treactive = yes\n\t\t\tstatics.push(\".setRef({quote(o:ivar.name)},{scope.context.c})\")\n\n\t\t# hmmm\n\t\tvar tree = TagTree.new(o:body, root: self, reactive: reactive).resolve\n\t\tself.tree = tree\n\n\n\t\tfor part in @parts\n\t\t\tif part isa TagAttr\n\t\t\t\tvar akey = String(part.key)\n\n\t\t\t\t# the attr should compile itself instead -- really\n\n\t\t\t\tif akey[0] == '.' # should check in a better way\n\t\t\t\t\tcalls.push \".flag({quote(akey.substr(1))},{part.value.c})\"\n\t\t\t\telse\n\t\t\t\t\tcalls.push \".{helpers.setterSym(akey)}({part.value.c})\"\n\n\t\t\telif part isa TagFlag\n\t\t\t\tcalls.push(part.c)\n\n\t\tif object\n\t\t\tcalls.push(\".setObject({object.c})\")\n\n\t\t# p \"tagtree is static? {tree.static}\"\n\n\t\t# we need to trigger our own reference before the body does\n\t\tif reactive\n\t\t\treference # hmm\n\n\t\tif var body = tree.c(expression: yes) # force it to be an expression, no?\n\t\t\tcalls.push (isSelf ? \".setChildren([{body}])\" : \".setContent([{body}])\")\n\t\t\t# out += \".body({body})\"\n\n\t\t# if o:attributes:length # or -- always?\n\t\t# adds lots of extra calls - but okay for now\n\t\tcalls.push \".{commit}()\"\n\n\t\tif statics:length\n\t\t\tout = out + statics.join(\"\")\n\n\t\t# hmm - hack much\n\t\tif (o:ivar or reactive) and !(type isa Self)\n\t\t\t# if this is an ivar, we should set the reference relative\n\t\t\t# to the outer reference, or possibly right on context?\n\t\t\tvar par = parent\n\t\t\tvar ctx =  !o:ivar and par and par.reference or scope.context\n\t\t\tvar key = o:ivar or par and par.tree.indexOf(self)\n\n\t\t\t# need the context -- might be better to rewrite it for real?\n\t\t\t# parse the whole thing into calls etc\n\t\t\tvar acc = OP('.',ctx,key).c\n\n\t\t\tout = \"({reference.c} = {acc} || ({acc} = {out}))\"\n\n\t\t# should we not add references to the outer ones first?\n\n\t\t# now work on the refereces?\n\n\t\t# free variable\n\t\t@reference.free if @reference isa Variable\n\t\t# if setup:length\n\t\t#\tout += \".setup({setup.join(\",\")})\"\n\n\t\treturn out + calls.join(\"\")\n\n# This is a helper-node\nexport class TagTree < ListNode\n\n\tdef load list\n\t\tif list isa ListNode\n\t\t\t@indentation ||= list.@indentation\n\t\t\tlist.nodes\n\t\telse\n\t\t\tcompact__(list isa Array ? list : [list])\n\n\tdef root\n\t\toption(:root)\n\n\tdef reactive\n\t\toption(:reactive)\t\t\n\n\tdef resolve\n\t\tremap do |c| c.consume(self)\n\t\tself\n\n\tdef static\n\t\t@static ?= every do |c| c isa Tag\n\n\tdef c\n\t\treturn super\n\t\t\n\t\t# p \"TagTree.c {nodes}\"\t\n\t\tvar l = nodes:length \n\t\tif l == 1\n\t\t\t# p \"TagTree.c {nodes}\"\n\t\t\tmap do |v| v.c(expression: yes)\n\t\t\t# nodes.c(expression: yes)\n\t\telif l > 1\n\t\t\tnodes.c(expression: yes)\n\n\nexport class TagWrapper < ValueNode\n\n\tdef visit\n\t\tif value isa Array\n\t\t\tvalue.map(|v| v.traverse)\n\t\telse\n\t\t\tvalue.traverse\n\t\tself\n\t\t\n\tdef c\n\t\t\"tag$wrap({value.c(expression: yes)})\"\n\n\nexport class TagAttributes < ListNode\n\n\tdef get name\n\t\tfor node in nodes\n\t\t\treturn node if node.key == name\n\t\t\n\t\t\nexport class TagAttr < Node\n\n\tprop key\n\tprop value\n\n\tdef visit\n\t\tvalue.traverse if value\n\t\tself\n\n\tdef initialize k, v\n\t\t# p \"init TagAttribute\", $0\n\t\t@key = k\n\t\t@value = v\n\n\tdef populate obj\n\t\tobj.add(key, value)\n\t\tself\n\n\tdef c\n\t\t\"attribute\"\n\n\nexport class TagFlag < Node\n\n\tprop value\n\tprop toggler\n\n\tdef initialize value\n\t\t@value = value\n\t\tself\n\n\tdef visit\n\t\tunless @value isa String\n\t\t\t@value.traverse\n\t\tself\n\n\tdef c\n\t\tif value isa Node\n\t\t\t\".flag({value.c})\"\n\t\telse\n\t\t\t\".flag({helpers.singlequote(value)})\"\n\t\t\n\t\t\n\n\n\n\n# SELECTORS\n\n\nexport class Selector < ListNode\n\n\tdef add part, typ\n\t\t# p \"select add!\",part,typ\n\t\tpush(part)\n\t\tself\n\n\tdef query\n\t\tvar str = \"\"\n\t\tvar ary = []\n\n\t\tfor item in nodes\n\t\t\tvar val = item.c\n\t\t\tif val isa String\n\t\t\t\tstr = \"{str}{val}\"\n\n\t\t\"'{str}'\"\n\n\n\tdef js o\n\t\tvar typ = option(:type)\n\t\tvar q = c__(query)\n\n\t\t# var scoped = typ == '%' or typ == '%%'\n\t\t# var all = typ == '$' or typ == '%'\n\n\t\tif typ == '%'\n\t\t\t\"q$({q},{o.scope.context.c(explicit: yes)})\" # explicit context\n\t\telif typ == '%%'\n\t\t\t\"q$$({q},{o.scope.context.c})\"\n\t\telse \n\t\t\t\"q{typ}({q})\"\n\n\t\t# return \"{typ} {scoped} - {all}\"\n\t\t\n\nexport class SelectorPart < ValueNode\n\n\tdef c\n\t\tc__(@value)\n\t\t# \"{value.c}\"\n\nexport class SelectorType < SelectorPart\n\n\tdef c\n\t\t# support\n\t\t# p \"selectortype {value}\"\n\t\t# var out = value.c\n\t\tvar name = value.name\n\t\t# hmm - what about svg? do need to think this through.\n\t\t# at least be very conservative about which tags we\n\t\t# can drop the tag for?\n\t\t# out in TAG_TYPES.HTML ? \n\t\tname in TAG_TYPES.HTML ? name : value.sel\n\n\nexport class SelectorUniversal < SelectorPart\n\nexport class SelectorNamespace < SelectorPart\n\nexport class SelectorClass < SelectorPart\n\n\tdef c\n\t\t\".{c__(@value)}\"\n\nexport class SelectorId < SelectorPart\n\n\tdef c\n\t\t\"#{c__(@value)}\"\n\nexport class SelectorCombinator < SelectorPart\n\n\tdef c\n\t\t\"{c__(@value)}\"\n\nexport class SelectorPseudoClass < SelectorPart\n\nexport class SelectorAttribute < SelectorPart\n\n\t# remember to visit nodes inside here?\n\tdef initialize left,op,right\n\t\t@left = left\n\t\t@op = op\n\t\t@right = @value = right\n\n\tdef c\n\t\t# TODO possibly support .toSel or sel$(v) for items inside query\n\t\t# could easily do it with a helper-function that is added to the top of the filescope\n\t\tif @right isa Str\n\t\t\t\"[{@left.c}{@op}{@right.c}]\"\n\t\telif @right\n\t\t\t# this is not at all good\n\t\t\t\"[{@left.c}{@op}\\\"'+{c__(@right)}+'\\\"]\"\n\t\telse\n\t\t\t\"[{@left.c}]\"\n\t\t\n\t\t\t# ...\n\t\t\n\n\n\n# DEFER\n\nexport class Await < ValueNode\n\n\tprop func\n\n\tdef js\n\t\t# introduce a util here, no?\n\t\tCALL(OP('.',Util.Promisify.new([value]),'then').prebreak,[func]).c\n\t\t# value.c\n\t\n\tdef visit o\n\t\t# things are now traversed in a somewhat chaotic order. Need to tighten\n\t\t# Create await function - push this value up to block, take the outer\n\t\tvalue.traverse\n\n\t\tvar block = o.up(Block) # or up to the closest FUNCTION?\n\t\tvar outer = o.relative(block,1)\n\t\tvar par = o.relative(self,-1)\n\n\t\t# p \"Block {block} {outer} {par}\"\n\n\t\tfunc = AsyncFunc.new([],[])\n\t\t# now we move this node up to the block\n\t\tfunc.body.nodes = block.defers(outer,self)\n\n\t\t# if the outer is a var-assignment, we can simply set the params\n\t\tif par isa Assign\n\t\t\tpar.left.traverse\n\t\t\tvar lft = par.left.node\n\t\t\t# p \"Async assignment {par} {lft}\"\n\t\t\t# Can be a tuple as well, no?\n\t\t\tif lft isa VarReference\n\t\t\t\t# the param is already registered?\n\t\t\t\t# should not force the name already??\n\t\t\t\t# beware of bugs\n\t\t\t\tfunc.params.at(0,yes,lft.variable.name)\n\t\t\telif lft isa Tuple\n\t\t\t\t# if this an unfancy tuple, with only vars\n\t\t\t\t# we can just use arguments\n\n\t\t\t\tif par.type == 'var' && !lft.hasSplat\n\t\t\t\t\t# p \"SIMPLIFY! {lft.nodes[0]}\"\n\t\t\t\t\tlft.map do |el,i|\n\t\t\t\t\t\tfunc.params.at(i,yes,el.value)\n\t\t\t\telse\n\t\t\t\t\t# otherwise, do the whole tuple\n\t\t\t\t\t# make sure it is a var assignment?\n\t\t\t\t\tpar.right = ARGUMENTS\n\t\t\t\t\tfunc.body.unshift(par)\n\t\t\telse\n\t\t\t\t# regular setters\n\t\t\t\tpar.right = func.params.at(0,yes)\n\t\t\t\tfunc.body.unshift(par)\n\t\t\t\t\n\t\t\t\n\n\t\t# If it is an advance tuple or something, it should be possible to\n\t\t# feed in the paramlist, and let the tuple handle it as if it was any\n\t\t# other value\n\n\t\t# CASE If this is a tuple / multiset with more than one async value\n\t\t# we need to think differently.\n\n\t\t# now we need to visit the function as well\n\t\tfunc.traverse\n\t\t# pull the outer in\n\t\tself\n\nexport class AsyncFunc < Func\n\n\tdef initialize params, body, name, target, options\n\t\tsuper\n\n\tdef scopetype do LambdaScope\n\n\t# need to override, since we wont do implicit returns\n\t# def js\n\t# \tvar code = scope.c\n\t# \treturn \"function ({params.c})\" + code.wrap\n\n\n\n# IMPORTS\n\nexport class ImportStatement < Statement\n\n\n\tprop ns\n\tprop imports\n\tprop source\n\n\n\tdef initialize imports, source, ns\n\t\t@imports = imports\n\t\t@source = source\n\t\t@ns = ns\n\t\tself\n\n\n\tdef visit\n\t\tif @ns\n\t\t\t@nsvar ||= scope__.register(@ns,self)\n\t\tself\n\n\n\tdef js\n\t\tvar req = CALL(Identifier.new(\"require\"),[source])\n\n\t\tif @ns\n\t\t\t# must register ns as a real variable\n\t\t\treturn \"var {@nsvar.c} = {req.c}\"\n\t\telif @imports\n\n\t\t\t# create a require for the source, with a temporary name?\n\t\t\tvar out = [req.cache.c]\n\n\t\t\tfor imp in @imports\n\t\t\t\t# we also need to register these imports as variables, no?\n\t\t\t\tvar o = OP('=',imp,OP('.',req,imp))\n\t\t\t\tout.push(\"var {o.c}\")\n\n\t\t\treturn out\n\t\telse\n\t\t\treturn req.c\n\n\n\n\tdef consume node\n\t\treturn self\n\n\n# EXPORT \n\nexport class ExportStatement < ValueNode\n\n\tdef js\n\t\tyes\n\t\tvar nodes = @value.map do |arg|\n\t\t\t\"module.exports.{arg.c} = {arg.c};\\n\"\n\t\tnodes.join(\"\")\n\n\n# UTILS\n\nexport class Util < Node\n\n\tprop args\n\n\tdef initialize args\n\t\t@args = args\n\t\t\n\t# this is how we deal with it now\n\tdef self.extend a,b\n\t\tUtil.Extend.new([a,b])\n\n\tdef self.repeat str, times\n\t\tvar res = ''\n\t\twhile times > 0\n\t\t\tif times % 2 == 1\n\t\t\t\tres += str\n\t\t\tstr += str\n\t\t\ttimes >>= 1\n\t\treturn res\n\t\t\n\t\t\n\n\tdef self.keys obj\n\t\tvar l = Const.new(\"Object\")\n\t\tvar r = Identifier.new(\"keys\")\n\t\tCALL(OP('.',l,r),[obj])\n\n\tdef self.len obj, cache\n\t\t# p \"LEN HELPER\".green\n\t\tvar r = Identifier.new(\"length\")\n\t\tvar node = OP('.', obj, r)\n\t\tnode.cache(force: yes, type: 'len') if cache\n\t\treturn node\n\n\tdef self.indexOf lft, rgt\n\t\tvar node = Util.IndexOf.new([lft,rgt])\n\t\t# node.cache(force: yes, type: 'iter') if cache\n\t\treturn node\n\n\tdef self.slice obj, a, b\n\t\tvar slice = Identifier.new(\"slice\")\n\t\tconsole.log \"slice {a} {b}\"\n\t\treturn CALL(OP('.',obj,slice),compact__([a,b]))\n\t\n\tdef self.iterable obj, cache\n\t\tvar node = Util.Iterable.new([obj])\n\t\tnode.cache(force: yes, type: 'iter') if cache\n\t\treturn node\n\n\n\n\tdef self.union a,b\n\t\tUtil.Union.new([a,b])\n\t\t# CALL(UNION,[a,b])\n\n\tdef self.intersect a,b\n\t\tUtil.Intersect.new([a,b])\n\t\t# CALL(INTERSECT,[a,b])\n\n\tdef self.counter start, cache\n\t\t# should it not rather be a variable?!?\n\t\tvar node = Num.new(start) # make sure it really is a number\n\t\tnode.cache(force: yes, type: 'counter') if cache\n\t\treturn node\n\n\tdef self.array size, cache\n\t\tvar node = Util.Array.new([size])\n\t\tnode.cache(force: yes, type: 'list') if cache\n\t\treturn node\n\n\tdef self.defineTag type, ctor, supr\n\t\tCALL(TAGDEF,[type,ctor,supr])\n\n\t# hmm\n\tdef self.defineClass name, supr, initor\n\t\tCALL(CLASSDEF,[name or initor,sup])\n\n\n\tdef self.toAST obj\n\t\t# deep converter that takes arrays etc and converts into ast\n\t\tself\n\n\tdef js\n\t\t\"helper\"\n\nexport class Util.Union < Util\n\n\tdef helper\n\t\t'''\n\t\tfunction union$(a,b){\n\t\t\tif(a && a.__union) return a.__union(b);\n\n\t\t\tvar u = a.slice(0);\n\t\t\tfor(var i=0,l=b.length;i<l;i++) if(u.indexOf(b[i]) == -1) u.push(b[i]);\n\t\t\treturn u;\n\t\t};\n\n\t\t'''\n\t\t\n\n\tdef js\n\t\tscope__.root.helper(self,helper)\n\t\t# When this is triggered, we need to add it to the top of file?\n\t\t\"union$({args.map(|v| v.c ).join(',')})\"\n\nexport class Util.Intersect < Util\n\n\tdef helper\n\t\t'''\n\t\tfunction intersect$(a,b){\n\t\t\tif(a && a.__intersect) return a.__intersect(b);\n\t\t\tvar res = [];\n\t\t\tfor(var i=0, l=a.length; i<l; i++) {\n\t\t\t\tvar v = a[i];\n\t\t\t\tif(b.indexOf(v) != -1) res.push(v);\n\t\t\t}\n\t\t\treturn res;\n\t\t};\n\n\t\t'''\n\n\tdef js\n\t\t# When this is triggered, we need to add it to the top of file?\n\t\tscope__.root.helper(self,helper)\n\t\t\"intersect$({args.map(|v| v.c ).join(',')})\"\n\nexport class Util.Extend < Util\n\n\tdef js\n\t\t# When this is triggered, we need to add it to the top of file?\n\t\t\"extend$({compact__(cary__(args)).join(',')})\"\n\nexport class Util.IndexOf < Util\n\n\tdef helper\n\t\t'''\n\t\tfunction idx$(a,b){\n\t\t\treturn (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);\n\t\t};\n\n\t\t'''\n\t\t\n\n\tdef js\n\t\tscope__.root.helper(self,helper)\n\t\t# When this is triggered, we need to add it to the top of file?\n\t\t\"idx$({args.map(|v| v.c ).join(',')})\"\n\nexport class Util.Subclass < Util\n\n\tdef helper\n\t\t# should also check if it is a real promise\n\t\t'''\n\t\t// helper for subclassing\n\t\tfunction subclass$(obj,sup) {\n\t\t\tfor (var k in sup) {\n\t\t\t\tif (sup.hasOwnProperty(k)) obj[k] = sup[k];\n\t\t\t};\n\t\t\t// obj.__super__ = sup;\n\t\t\tobj.prototype = Object.create(sup.prototype);\n\t\t\tobj.__super__ = obj.prototype.__super__ = sup.prototype;\n\t\t\tobj.prototype.initialize = obj.prototype.constructor = obj;\n\t\t};\n\n\t\t'''\n\n\tdef js\n\t\t# When this is triggered, we need to add it to the top of file?\n\t\tscope__.root.helper(self,helper)\n\t\t\"subclass$({args.map(|v| v.c).join(',')});\\n\"\n\nexport class Util.Promisify < Util\n\n\tdef helper\n\t\t# should also check if it is a real promise\n\t\t\"function promise$(a)\\{ return a instanceof Array ? Promise.all(a) : (a && a.then ? a : Promise.resolve(a)); \\}\"\n\t\t\n\tdef js\n\t\t# When this is triggered, we need to add it to the top of file?\n\t\tscope__.root.helper(self,helper)\n\t\t\"promise$({args.map(|v| v.c).join(',')})\"\n\nexport class Util.Class < Util\n\n\tdef js\n\t\t# When this is triggered, we need to add it to the top of file?\n\t\t\"class$({args.map(|v| v.c).join(',')})\"\n\nexport class Util.Iterable < Util\n\n\tdef helper\n\t\t# now we want to allow nil values as well - just return as empty collection\n\t\t# should be the same for for own of I guess\n\t\t\"function iter$(a)\\{ return a ? (a.toArray ? a.toArray() : a) : []; \\};\"\n\t\t\n\tdef js\n\t\treturn args[0].c if args[0] isa Arr # or if we know for sure that it is an array\n\t\t# only wrap if it is not clear that this is an array?\n\t\tscope__.root.helper(self,helper)\n\t\treturn \"iter$({args[0].c})\"\n\nexport class Util.IsFunction < Util\n\n\tdef js\n\t\t# p \"IS FUNCTION {args[0]}\"\n\t\t# just plain check for now\n\t\t\"{args[0].c}\"\n\t\t# \"isfn$({args[0].c})\"\n\t\t# \"typeof {args[0].c} == 'function'\"\n\t\t\n\nexport class Util.Array < Util\n\n\tdef js\n\t\t# When this is triggered, we need to add it to the top of file?\n\t\t\"new Array({args.map(|v| v.c)})\"\n\n\n\n\n\n\n# SCOPES\n\n# handles local variables, self etc. Should create references to outer scopes\n# when needed etc.\n\n# should move the whole context-thingie right into scope\nexport class Scope\n\n\tprop level\n\tprop context\n\tprop node\n\tprop parent\n\tprop varmap\n\tprop varpool\n\tprop params\n\tprop head\n\tprop vars\n\tprop counter\n\n\tdef initialize node, parent\n\t\t@head = []\n\t\t@node = node\n\t\t@parent = parent\n\t\t@vars = VariableDeclaration.new([])\n\t\t@virtual = no\n\t\t@counter = 0\n\t\t@varmap = {}\n\t\t@varpool = []\n\n\tdef context\n\t\t@context ||= ScopeContext.new(self)\n\n\tdef traverse\n\t\tself\n\n\tdef visit\n\t\t# p \"visited scope!\"\n\t\t@parent = STACK.scope(1) # the parent scope\n\t\t@level = STACK.scopes:length - 1 # hmm\n\n\t\t# p \"parent is\",@parent\n\n\t\tSTACK.addScope(self)\n\t\troot.scopes.push(self)\n\t\tself\n\n\t# called for scopes that are not real scopes in js\n\t# must ensure that the local variables inside of the scopes do not\n\t# collide with variables in outer scopes -- rename if needed\n\tdef virtualize\n\t\tself\n\t\t\n\n\tdef root\n\t\tvar scope = self\n\t\twhile scope\n\t\t\treturn scope if scope isa FileScope\n\t\t\tscope = scope.parent\n\t\treturn nil\n\n\tdef register name, decl = nil, o = {}\n\n\t\t# FIXME re-registering a variable should really return the existing one\n\t\t# Again, here we should not really have to deal with system-generated vars\n\t\t# But again, it is important\n\n\t\t# p \"registering {name}\"\n\t\tname = helpers.symbolize(name)\n\n\t\t# also look at outer scopes if this is not closed?\n\t\tvar existing = @varmap.hasOwnProperty(name) && @varmap[name]\n\t\treturn existing if existing\n\n\t\tvar item = Variable.new(self,name,decl,o)\n\t\t# need to check for duplicates, and handle this gracefully -\n\t\t# going to refactor later\n\t\t@varmap[name] = item\n\t\treturn item\n\t# declares a variable (has no real declaration beforehand)\n\n\t# change these values, no?\n\tdef temporary refnode, o = {}, name = nil\n\n\t\t# p \"registering temporary {refnode} {name}\"\n\t\t# reuse variables\n\t\tif o:type\n\t\t\tfor v in @varpool\n\t\t\t\tif v.type == o:type && v.declarator == nil\n\t\t\t\t\treturn v.reuse(refnode)\n\n\t\t# should only 'register' as ahidden variable, no?\n\t\t# if there are real nodes inside that tries to refer to vars\n\t\t# defined in outer scopes, we need to make sure they are not named after this\n\t\tvar item = SystemVariable.new(self,name,refnode,o)\n\t\t@varpool.push(item) # WHAT? It should not be in the pool unless explicitly put there?\n\t\t@vars.push(item) # WARN variables should not go directly into a declaration-list\n\t\treturn item\n\t\t# return register(name || \"__\",nil,system: yes, temporary: yes)\n\n\tdef declare name, init = null, options = {}\n\t\t# if name isa Variable\n\t\t# p \"SCOPE declare var\".green\n\t\tname = helpers.symbolize(name)\n\t\t@vars.add(name,init) # .last\n\t\tvar decl = @vars.last\n\t\t# item = Variable.new(self,name,decl)\n\t\tvar item = Variable.new(self,name,decl,options)\n\t\tdecl.variable = item\n\t\titem.resolve\n\t\t# should be possible to force-declare for this scope, no?\n\t\t# if this is a system-variable \n\n\tdef lookup name\n\t\tvar ret = null\n\t\tname = helpers.symbolize(name)\n\t\tif @varmap.hasOwnProperty(name)\n\t\t\tret = @varmap[name] \n\t\telse\n\t\t\t# look up any parent scope ?? seems okay\n\t\t\t# !isClosed && \n\t\t\tret = parent && parent.lookup(name)\n\t\tret ||= (g.lookup(name) if var g = root)\n\t\t# g = root\n\t\tret\n\n\tdef free variable\n\t\t# p \"free variable\"\n\t\tvariable.free # :owner = nil\n\t\t# @varpool.push(variable)\n\t\tself\n\t\n\tdef isClosed\n\t\tno\n\n\tdef finalize\n\t\tself\n\n\tdef klass\n\t\tvar scope = self\n\t\twhile scope\n\t\t\tscope = scope.parent\n\t\t\treturn scope if scope isa ClassScope\n\t\treturn nil\n\n\tdef head\n\t\t[@vars,@params]\n\n\tdef c o = {}\n\t\to:expression = no\n\t\t# need to fix this\n\t\tnode.body.head = head\n\t\tvar body = node.body.c(o)\n\n\t\t# var head = [@vars,@params].block.c(expression: no)\n\t\t# p \"head from scope is ({head})\"\n\t\t# var out = [head or nil,body].flatten__.compact.join(\"\\n\")\n\t\t# out\n\t\t# out = '{' + out + \n\n\tdef dump\n\t\tvar vars = Object.keys(@varmap).map do |k| \n\t\t\tvar v = @varmap[k]\n\t\t\tv.references:length ? dump(v) : nil\n\n\t\treturn \\\n\t\t\ttype: self:constructor:name\n\t\t\tlevel: (level or 0)\n\t\t\tvars: compact__(vars)\n\t\t\tloc: node.body.region\n\n\tdef toString\n\t\t\"{self:constructor:name}\"\n\t\t\n# FileScope is wrong? Rather TopScope or ProgramScope\nexport class FileScope < Scope\n\n\tprop warnings\n\tprop scopes\n\n\tdef initialize\n\t\tsuper\n\t\t# really? makes little sense\n\t\tregister :global, self, type: 'global'\n\t\tregister :exports, self, type: 'global'\n\t\tregister :console, self, type: 'global'\n\t\tregister :process, self, type: 'global'\n\t\tregister :setTimeout, self, type: 'global'\n\t\tregister :setInterval, self, type: 'global'\n\t\tregister :clearTimeout, self, type: 'global'\n\t\tregister :clearInterval, self, type: 'global'\n\t\tregister :__dirname, self, type: 'global'\n\t\t# preregister global special variables here\n\t\t@warnings = []\n\t\t@scopes = []\n\t\t@helpers = []\n\n\tdef context\n\t\t@context ||= RootScopeContext.new(self)\n\n\tdef lookup name\n\t\t# p \"lookup filescope\"\n\t\tname = helpers.symbolize(name)\n\t\t@varmap[name] if @varmap.hasOwnProperty(name)\n\n\tdef visit\n\t\tSTACK.addScope(self)\n\t\tself\n\n\tdef helper typ, value\n\t\t# log \"add helper\",typ,value\n\t\t@helpers.push(value) if @helpers.indexOf(value) == -1\n\t\treturn self\n\n\tdef head\n\t\t[@helpers,@params,@vars]\n\n\tdef warn data\n\t\t# hacky\n\t\tdata:node = nil\n\t\t# p \"warning\",JSON.stringify(data)\n\t\t@warnings.push(data)\n\t\tself\n\n\tdef dump\n\t\tvar scopes = @scopes.map(|s| s.dump)\n\t\tscopes.unshift(super.dump)\n\n\t\tvar obj = \n\t\t\twarnings: dump(@warnings)\n\t\t\tscopes: scopes\n\n\t\treturn obj\n\t\t\n\n\nexport class ClassScope < Scope\n\n\t# called for scopes that are not real scopes in js\n\t# must ensure that the local variables inside of the scopes do not\n\t# collide with variables in outer scopes -- rename if needed\n\tdef virtualize\n\t\t# console.log \"virtualizing ClassScope\"\n\t\tvar up = parent\n\t\tfor own k,v of @varmap\n\t\t\ttrue\n\t\t\tv.resolve(up,yes) # force new resolve\n\t\tself\n\nexport class TagScope < ClassScope\n\nexport class ClosureScope < Scope\n\nexport class FunctionScope < Scope\n\nexport class MethodScope < Scope\n\n\tdef isClosed\n\t\tyes\n\nexport class LambdaScope < Scope\n\n\tdef context\n\n\t\t# when accessing the outer context we need to make sure that it is cached\n\t\t# so this is wrong - but temp okay\n\t\t@context ||= parent.context.reference(self)\n\nexport class FlowScope < Scope\n\n\t# these have no params themselves, refer to outer scopes -- hjmm\n\tdef params\n\t\t@parent.params if @parent\n\n\tdef context\n\t\t# if we are wrapping in an expression - we do need to add a reference\n\t\t# @referenced = yes\n\t\tparent.context\n\t# \t# usually - if the parent scope is a closed scope we dont really need\n\t# \t# to force a reference\n\t# \t# @context ||= parent.context.reference(self)\n\nexport class CatchScope < FlowScope\n\nexport class WhileScope < FlowScope\n\nexport class ForScope < FlowScope\n\n# lives in scope\nexport class Variable < Node\n\n\tprop scope\n\tprop name\n\tprop alias\n\tprop type\n\tprop options\n\tprop declarator\n\tprop autodeclare\n\tprop references\n\tprop export\n\n\tdef initialize scope, name, decl, options\n\t\t@scope = scope\n\t\t@name = name\n\t\t@alias = nil\n\t\t@declarator = decl\n\t\t@autodeclare = no\n\t\t@declared = yes\n\t\t@resolved = no\n\t\t@options = options || {}\n\t\t@type = @options:type || 'var'\n\t\t@export = no # hmmmm\n\t\t# @declarators = [] # not used now\n\t\t@references = [] # should probably be somewhere else, no?\n\n\n\tdef resolve scope = scope, force = no\n\t\treturn self if @resolved and !force\n\n\t\t@resolved = yes\n\t\t# p \"need to resolve!\".cyan\n\t\tif var item = scope.lookup(name)\n\t\t\t# p \"variable already exists {name}\".red\n\t\t\t# possibly redefine this inside, use it only in this scope\n\t\t\tif item.scope != scope && options[:let]\n\t\t\t\t# p \"override variable inside this scope\".red\n\t\t\t\tscope.varmap[name] = self\n\n\t\t\t# different rules for different variables?\n\t\t\tif @options:proxy\n\t\t\t\t# p \"is proxy -- no need to change name!!! {name}\".cyan\n\t\t\t\tyes\n\t\t\telse\n\t\t\t\tvar i = 0\n\t\t\t\tvar orig = @name\n\t\t\t\twhile scope.lookup(@name)\n\t\t\t\t\t@name = \"{orig}{i += 1}\"\n\n\t\tscope.varmap[name] = self\n\t\treturn self\n\t\t# p \"resolve variable\".cyan\n\n\tdef reference\n\t\tself\n\n\tdef free ref\n\t\t# p \"free variable!\"\n\t\t@declarator = nil\n\t\tself\n\n\tdef reuse ref\n\t\t@declarator = ref\n\t\tself\n\n\tdef proxy par, index\n\t\t@proxy = [par,index]\n\t\tself\n\n\tdef refcount\n\t\t@references:length\n\n\tdef c\n\t\treturn @c if @c\n\n\t\tif @proxy\n\t\t\t# p \"var is proxied!\",@proxy\n\t\t\t@c = \"{@proxy[0].c}[{@proxy[1].c}]\"\n\t\telse\n\t\t\tvar v = (alias or name)\n\t\t\t@c = typeof v == 'string' ? v : v.c\n\t\t\t# allow certain reserved words\n\t\t\t# should warn on others though (!!!)\n\t\t\t@c = \"{c}$\" if RESERVED_REGEX.test(@c) # @c.match(/^(default)$/)\n\t\treturn @c\n\n\t# variables should probably inherit from node(!)\n\tdef consume node\n\t\t# p \"variable assignify!!!\"\n\t\treturn self\n\n\t# this should only generate the accessors - not dael with references\n\tdef accessor ref\n\t\tvar node = LocalVarAccess.new(\".\",null,self) # this is just wrong .. should not be a regular accessor\n\t\t# @references.push([ref,el]) if ref # weird temp format\n\t\treturn node\n\n\tdef addReference ref\n\t\t@references.push(ref)\n\t\tself\n\n\tdef autodeclare\n\t\treturn self if option(:declared)\n\t\t# p \"variable should autodeclare(!)\"\n\t\t@autodeclare = yes\n\n\t\t# WARN\n\t\t# if scope isa WhileScope\n\t\t# \tp \"should do different autodeclare!!\"\n\t\t# \t# or we should simply add them\n\n\t\tscope.vars.push(self) # only if it does not exist here!!!\n\t\tset(declared: yes)\n\t\tself\n\n\tdef toString\n\t\tString(name)\n\n\tdef dump typ\n\t\t{\n\t\t\ttype: type\n\t\t\tname: name\n\t\t\trefs: dump(@references, typ)\n\t\t}\n\t\t\nexport class SystemVariable < Variable\n\n\t# weird name for this\n\tdef predeclared\n\t\t# p \"remove var from scope(!)\"\n\t\tscope.vars.remove(self)\n\t\tself\n\t\n\tdef resolve\n\t\treturn self if @resolved || @name\n\t\t# p \"RESOLVE SYSTEM VARIABLE\".red\n\t\t@resolved = yes\n\t\t# unless @name\n\t\t# adds a very random initial name\n\t\t# the auto-magical goes last, or at least, possibly reuse other names\n\t\t# \"${Math.floor(Math.random * 1000)}\"\n\n\t\tvar typ = @options:type\n\t\tvar names = [].concat(@options:names)\n\t\tvar alt = null\n\t\tvar node = null\n\n\t\tvar scope = self.scope\n\n\t\tif typ == 'tag'\n\t\t\tvar i = 0\n\t\t\twhile !@name\n\t\t\t\tvar alt = \"t{i++}\"\n\t\t\t\t@name = alt unless scope.lookup(alt)\n\n\t\telif typ == 'iter'\n\t\t\tnames = ['ary__','ary_','coll','array','items','ary']\n\n\t\telif typ == 'val'\n\t\t\tnames = ['v_']\n\n\t\telif typ == 'arguments'\n\t\t\tnames = ['$_','$0']\n\n\t\telif typ == 'keypars'\n\t\t\tnames = ['opts','options','pars']\n\n\t\telif typ == 'counter'\n\t\t\tnames = ['i__','i_','k','j','i']\n\n\t\telif typ == 'len'\n\t\t\tnames = ['len__','len_','len']\n\n\t\telif typ == 'list'\n\t\t\tnames = ['tmplist_','tmplist','tmp']\n\t\t# or if type placeholder / cacher (add 0)\n\n\t\twhile !@name && alt = names.pop\n\t\t\t@name = alt unless scope.lookup(alt)\n\n\t\tunless @name\n\t\t\tif node = declarator.node\n\t\t\t\tnames.push(alias + \"_\") if var alias = node.alias\n\n\t\twhile !@name && alt = names.pop\n\t\t\t@name = alt unless scope.lookup(alt)\n\n\t\t# p \"suggested names {names.join(\" , \")} {node}\".cyan\n\t\t#  Math.floor(Math.random * 1000)\n\t\t@name ||= \"${scope.counter += 1}\"\n\t\t# p \"name for variable is {@name}\"\n\t\tscope.varmap[@name] = self\n\t\tself\n\n\tdef name\n\t\tresolve\n\t\t@name\n\n\nexport class ScopeContext < Node\n\n\tprop scope\n\tprop value\n\n\tdef initialize scope, value\n\t\t@scope = scope\n\t\t@value = value\n\t\t@reference = nil\n\t\tself\n\n\t# instead of all these references we should probably\n\t# just register when it is accessed / looked up from\n\t# a deeper function-scope, and when it is, we should\n\t# register the variable in scope, and then start to\n\t# use that for further references. Might clean things\n\t# up for the cases where we have yet to decide the\n\t# name of the variable etc?\n\n\tdef reference\n\t\t# p \"p reference {STACK.scoping}\"\n\t\t# should be a special context-variable!!!\n\t\t@reference ||= scope.declare(\"self\",This.new)\n\n\tdef c\n\t\tvar val = @value || @reference\n\t\t(val ? val.c : \"this\")\n\nexport class RootScopeContext < ScopeContext\n\n\tdef reference scope\n\t\tself\n\n\tdef c o\n\t\treturn \"\" if o and o:explicit\n\t\tvar val = @value || @reference\n\t\treturn val ? val.c : \"this\"\n\t\t# should be the other way around, no?\n\t\t# o and o:explicit ? super : \"\"\n\t\t\nexport class Super < Node\n\n\tdef c\n\t\t# need to find the stuff here\n\t\t# this is really not that good8\n\t\tvar m = STACK.method\n\t\tvar out = null\n\t\tvar up = STACK.current\n\t\tvar deep = up isa Access\n\n\t\t# TODO optimization for later - problematic if there is a different reference in the end\n\t\tif false && m && m.type == :constructor\n\t\t\tout = \"{m.target.c}.superclass\"\n\t\t\tout += \".apply({m.scope.context.c},arguments)\" unless deep\n\t\telse\n\t\t\tout = \"{m.target.c}.__super__\"\n\t\t\tunless up isa Access\n\t\t\t\tout += \".{c__(m.supername)}\" \n\t\t\t\tunless up isa Call # autocall?\n\t\t\t\t\tout += \".apply({m.scope.context.c},arguments)\" \n\t\tout\n\n# constants\n\nexport var BR = Newline.new('\\n')\nexport var BR2 = Newline.new('\\n\\n')\nexport var SELF = Self.new\nexport var SUPER = Super.new\nexport var TRUE = True.new('true')\nexport var FALSE = False.new('false')\nexport var ARGUMENTS = ArgsReference.new('arguments')\nexport var EMPTY = ''\nexport var NULL = 'null'\n\nexport var RESERVED = ['default','native','enum','with']\nexport var RESERVED_REGEX = /^(default|native|enum|with)$/\n\nexport var UNION = Const.new('union$')\nexport var INTERSECT = Const.new('intersect$')\nexport var CLASSDEF = Const.new('imba$class')\nexport var TAGDEF = Const.new('Imba.Tag.define')\nexport var NEWTAG = Identifier.new(\"tag$\")\n\n\n\n\n\n\n\n\n\n\n";
	module.exports.CLASSES = CLASSES = "# really?\n\n\nclass A\n\n\tdef a\n\t\t[1,2,3,4,5,6,7,8,9]\n\n\tdef b\n\t\ta b c d e f g\n\n\tdef c\n\t\t{a: 1, b: 2, c: 3, d: 4, e: 5}\n\n\tdef d\n\t\t1 + 2 + 3 + 4 + 5 + 6 + 7 + 8\n\n\tdef e\n\t\t1\n\n\tdef f\n\t\t1\n\n\tdef g\n\t\t1\n\n\n";


}())
},{}],2:[function(require,module,exports){
(function(){


	var lex, rewrite, tokenize, parse, compile;
	// externs;
	// var compiler = require '/repos/imba/lib/compiler'
	var compiler = imbalang;
	var snippets = require('./snippets');
	
	// var html = fs.readFileSync(__dirname + '/robot.html', 'utf8')
	// console.log(html)
	
	function bench(name,blk){
		console.time(name);
		console.profile();
		blk();
		console.timeEnd(name);
		return console.profileEnd();
	};
	
	module.exports.lex = lex = function (num,snippet){
		num = num || 1;
		snippet = snippet || snippets.NODES;
		snippet = new Array(num + 1).join(snippet + "\n");
		bench("lex",function (){
			return compiler.tokenize(snippet,{rewrite: false});
		});
		return;
	};
	
	module.exports.rewrite = rewrite = function (num,snippet){
		num = num || 1;
		
		snippet = snippet || snippets.NODES;
		snippet = new Array(num + 1).join(snippet + "\n");
		var tokens = compiler.tokenize(snippet,{rewrite: false});
		bench("rewrite",function (){
			return compiler.rewrite(tokens);
		});
		return;
	};
	
	module.exports.tokenize = tokenize = function (num,snippet){
		num = num || 1;
		snippet = snippet || snippets.NODES;
		snippet = new Array(num + 1).join(snippet + "\n");
		bench("tokenize",function (){
			return compiler.tokenize(snippet);
		});
		return;
	};
	
	module.exports.parse = parse = function (num,snippet){
		num = num || 1;
		snippet = snippet || snippets.NODES;
		snippet = new Array(num + 1).join(snippet + "\n");
		bench("parse",function (){
			return compiler.parse(snippet);
		});
		return;
	};
	
	
	module.exports.compile = compile = function (num,snippet){
		num = num || 1;
		snippet = snippet || snippets.NODES;
		snippet = new Array(num + 1).join(snippet + "\n");
		bench("compile",function (){
			return compiler.compile(snippet);
		});
		return;
	};


}())
},{"./snippets":1}]},{},[2])(2)
});