
`LONG_SAMPLE = "# TODO Create AST.Expression - make all expressions inherit from these?\n\nextern parseInt\n\n\nvar helpers = require './helpers'\n\nAST = {}\n\n# Helpers for operators\nOP = do |op, left, right, opts|\n\tif op == '.'\n\t\t# Be careful\n\t\tif right isa String\n\t\t\tright = AST.Identifier.new(right)\n\n\t\tAST.Access.new(op,left,right)\n\telif op == '='\n\t\tif left isa AST.Tuple\n\t\t\t# p \"catching tuple-assign OP\"\n\t\t\treturn AST.TupleAssign.new(op,left,right)\n\t\tAST.Assign.new(op,left,right)\n\telif op in ['?=','||=','&&=']\n\t\tAST.ConditionalAssign.new(op,left,right)\n\telif op in ['=<']\n\t\tAST.AsyncAssign.new('=',left,AST.Await.new(right))\n\t\t# AST.AsyncAssign.new(op,left,right)\n\telif op in ['+=','-=','*=','/=','^=','%=']\n\t\tAST.CompoundAssign.new(op,left,right)\n\t\t# elif op == '<<'\n\t\t#\tAST.PushAssign.new(op,left,right)\n\n\telif op == 'instanceof'\n\t\tAST.InstanceOf.new(op,left,right)\n\telif op == 'in'\n\t\tAST.In.new(op,left,right)\n\telif op == 'typeof'\n\t\tAST.TypeOf.new(op,left,right)\n\telif op == 'delete'\n\t\tAST.Delete.new(op,left,right)\n\telif op in ['--','++','!','√'] # hmm\n\t\tAST.UnaryOp.new(op,left,right)\n\telif op in ['>','<','>=','<=','==','===','!=','!==']\n\t\tAST.ComparisonOp.new(op,left,right)\n\telif op in ['∩','∪']\n\t\tAST.MathOp.new(op,left,right)\n\telif op in ['..','...']\n\t\tAST.Range.new(op,left,right)\n\telse\n\t\tAST.Op.new(op,left,right)\n\nLIT = do |val|\n\tAST.Literal.new(val)\n\nSYM = do |val|\n\tAST.Symbol.new(val)\n\nIF = do |cond,body,alt|\n\tvar node = AST.If.new(cond,body)\n\tnode.addElse(alt) if alt\n\tnode\n\nFN = do |pars,body|\n\tAST.Func.new(pars,body)\n\nCALL = do |callee,pars = []|\n\t# possibly return instead(!)\n\tAST.Call.new(callee,pars)\n\nCALLSELF = do |name,pars = []|\n\tvar ref = AST.Identifier.new(name)\n\tAST.Call.new(OP('.',AST.SELF,ref),pars)\n\nBLOCK = do\n\tAST.Block.wrap([]:slice.call(arguments))\n\nWHILE = do |test,code|\n\tAST.While.new(test).addBody(code)\n\nSPLAT = do |value|\n\tif value isa AST.Assign\n\t\t# p \"WARN\"\n\t\tvalue.left = AST.Splat.new(value.left)\n\t\treturn value\n\telse\n\t\tAST.Splat.new(value)\n\t\t# not sure about this\n\nOP.ASSIGNMENT = [ \"=\" , \"+=\" , \"-=\" , \"*=\" , \"/=\" , \"%=\", \"<<=\" , \">>=\" , \">>>=\", \"|=\" , \"^=\" , \"&=\" ]\nOP.LOGICAL = [ \"||\" , \"&&\" ]\nOP.UNARY = [ \"++\" , \"--\" ]\n\nAST.LOC = do |loc|\n\tself\n\ndef AST.parse str, opts = {}\n\tvar indent = str.match(/\\t+/)[0]\n\tAST.Imba.parse(str,opts)\n\ndef AST.inline str, opts = {}\n\tAST.parse(str,opts).body\n\ndef AST.node typ, pars\n\tif typ == 'call'\n\t\tif pars[0].c == 'return'\n\t\t\tpars[0] = 'tata'\t\n\t\tAST.Call.new(pars[0],pars[1],pars[2])\n\n\ndef AST.escapeComments str\n\treturn '' unless str\n\treturn str\n\t# var v = str.replace(/\\\\n/g,'\\n')\n\t# v.split(\"\\n\").join(\"\\n\")\n\t# v.split(\"\\n\").map(|v| v ? \"// {v}\" : v).join(\"\\n\")\n\nclass AST.Indentation\n\n\tprop open\n\tprop close\n\n\tdef initialize a,b\n\t\t@open = a or 1\n\t\t@close = b or 1\n\t\tself\n\n\t# should rather parse and extract the comments, no?\n\tdef wrap str, o\n\t\tvar pre = @open:pre\n\t\tvar post = @open:post\n\t\tvar esc = AST:escapeComments\n\n\t\t# the first newline should not be indented?\n\t\tstr = esc(post).replace(/^\\n/,'') + str\n\t\tstr = str.replace(/^/g,\"\\t\").replace(/\\n/g,\"\\n\\t\").replace(/\\n\\t$/g,\"\\n\")\n\n\t\tstr = esc(pre) + '\\n' + str\n\t\t# only add br if needed\n\t\tstr = str + '\\n' unless str[str:length - 1] == '\\n'\n\t\t# if o and o:braces\n\t\t# \tstr = '{' + str + '}'\n\n\t\treturn str\n\t\t\nAST.INDENT = AST.Indentation.new\n\nclass AST.Stack\n\n\tprop loglevel\n\tprop nodes\n\tprop scopes\n\n\tdef initialize\n\t\t@nodes = []\n\t\t@scoping = []\n\t\t@scopes = [] # for analysis - should rename\n\t\t@loglevel = 3\n\n\tdef addScope scope\n\t\t@scopes.push(scope)\n\t\tself\n\n\tdef traverse node\n\t\tself\n\n\tdef push node\n\t\t@nodes.push(node)\n\t\t# not sure if we have already defined a scope?\n\t\tself\n\n\tdef pop node\n\t\t@nodes.pop(node)\n\t\tself\n\n\tdef parent\n\t\t@nodes[@nodes:length - 2]\n\n\tdef current\n\t\t@nodes[@nodes:length - 1]\n\n\tdef up test\n\t\ttest ||= do |v| !(v isa AST.VarOrAccess)\n\n\t\tif test:prototype isa AST.Node\n\t\t\tvar typ = test\n\t\t\ttest = do |v| v isa typ\n\n\t\tvar i = @nodes:length - 1\n\t\twhile i >= 0\n\t\t\tvar node = @nodes[i]\n\t\t\treturn node if test(node)\n\t\t\ti -= 1\n\t\treturn nil\n\n\tdef relative node, offset = 0\n\t\tvar idx = @nodes.indexOf(node)\n\t\tidx >= 0 ? @nodes[idx + offset] : nil\n\n\tdef scope lvl = 0\n\t\tvar i = @nodes:length - 1 - lvl\n\t\twhile i >= 0\n\t\t\tvar node = @nodes[i]\n\t\t\treturn node.@scope if node.@scope\n\t\t\ti -= 1\n\t\treturn nil\n\n\tdef scopes\n\t\t# include deeper scopes as well?\n\t\tvar scopes = []\n\t\tvar i = @nodes:length - 1\n\t\twhile i >= 0\n\t\t\tvar node = @nodes[i]\n\t\t\tscopes.push(node.@scope) if node.@scope\n\t\t\ti -= 1\n\t\treturn scopes\n\n\tdef method\n\t\tup(AST.MethodDeclaration)\n\n\tdef isExpression\n\t\tvar i = @nodes:length - 1\n\t\twhile i >= 0\n\t\t\tvar node = @nodes[i]\n\t\t\t# why are we not using isExpression here as well?\n\t\t\tif node isa AST.Code or node isa AST.Loop\n\t\t\t\treturn false\n\t\t\tif node.isExpression\n\t\t\t\treturn true\n\t\t\t# probably not the right test - need to be more explicit\n\t\t\ti -= 1\n\t\treturn false\n\n\tdef toString\n\t\t\"Stack({@nodes.join(\" -> \")})\"\n\n\tdef scoping\n\t\t@nodes.filter(|n| n.@scope ).map(|n| n.@scope )\n\n# Lots of globals -- really need to deal with one stack per file / context\nSTACK = AST.Stack.new\n\nclass AST.Node\n\n\tprop o\n\tprop options\n\tprop traversed\n\tprop statement\n\n\tdef safechain\n\t\tno\n\n\tdef dom\n\t\tvar name = \"ast_\" + self:constructor:name.replace(/([a-z])([A-Z])/g,\"$1_$2\").toLowerCase\n\t\t# p \"try to get the dom-node for this ast-node\",name\n\t\tif Imba.TAGS[name]\n\t\t\tvar node = Imba.tag(name)\n\t\t\tnode.bind(self).build\n\t\t\treturn node\n\t\telse\n\t\t\treturn \"[{name}]\"\n\n\tdef p\n\t\t# hmm\n\t\t# allow controlling this from commandline\n\t\tif STACK.loglevel > 0\n\t\t\tconsole.log(*arguments)\n\t\tself\n\n\tdef initialize\n\t\tself\n\n\tdef set obj\n\t\t@options ||= {}\n\t\tfor own k,v of obj\n\t\t\t@options[k] = v\n\t\tself\n\n\t# get and set\n\tdef option key, val\n\t\tif val != undefined\n\t\t\t@options ||= {}\n\t\t\t@options[key] = val\n\t\t\treturn self\n\n\t\t@options && @options[key]\n\n\tdef configure obj\n\t\tset(obj)\n\n\tdef region\n\t\t[]\n\n\tdef loc\n\t\t[]\n\n\tdef toAST\n\t\tself\n\n\tdef compile\n\t\tself\n\n\tdef visit\n\t\tself\n\n\tdef stack\n\t\tSTACK\n\n\tdef traverse o = {}, up, key, index\n\t\treturn self if @traversed\n\t\t@traversed = yes\n\t\tSTACK.push self\n\t\tvisit(STACK)\n\t\tSTACK.pop self\n\t\treturn self\n\n\tdef inspect\n\t\t{type: self:constructor.toString}\n\n\tdef js\n\t\t\"NODE\"\n\n\tdef toString\n\t\t\"{self:constructor:name}\"\n\n\t# swallow might be better name\n\tdef consume node\n\t\tif node isa AST.PushAssign\n\t\t\treturn AST.PushAssign.new(node.op,node.left,self)\n\n\t\tif node isa AST.Assign\n\t\t\t# p \"consume assignment\".cyan\n\t\t\t# node.right = self\n\t\t\treturn OP(node.op,node.left,self)\n\t\telif node isa AST.Op\n\t\t\treturn OP(node.op,node.left,self)\n\t\telif node isa AST.Return\n\t\t\t# p \"consume return\".cyan\n\t\t\treturn AST.Return.new(self)\n\t\treturn self\n\n\tdef toExpression\n\t\t@expression = true\n\t\tself\n\n\tdef forceExpression\n\t\t@expression = true\n\t\tself\n\n\tdef isExpressable\n\t\ttrue\n\n\tdef isExpression\n\t\t@expression || false\n\n\tdef hasSideEffects\n\t\ttrue\n\n\tdef isUsed\n\t\ttrue\n\t\t\n\tdef shouldParenthesize\n\t\tfalse\n\n\tdef block\n\t\tAST.Block.wrap([self])\n\n\tdef node\n\t\tself\n\n\tdef scope__\n\t\tSTACK.scope\n\n\tdef up\n\t\tSTACK.parent\n\n\tdef util\n\t\tAST.Util\n\n\tdef receiver\n\t\tself\n\n\tdef addExpression expr\n\t\t# might be better to nest this up after parsing is done?\n\t\t# p \"addExpression {self} <- {expr}\"\n\t\tvar node = AST.ExpressionBlock.new([self])\n\t\treturn node.addExpression(expr)\n\n\tdef addComment comment\n\t\t# console.log \"adding comment\"\n\t\t@comment = comment\n\t\tself\n\n\tdef indented a,b\n\t\t# this is a _BIG_ hack\n\t\tif b isa Array\n\t\t\t# console.log \"indented array?\", b[0]\n\t\t\tadd(b[0])\n\t\t\tb = b[1]\n\n\t\t# if indent and indent.match(/\\:/)\n\t\t@indented = [a,b]\n\t\t@indentation ||= a and b ? AST.Indentation.new(a,b) : AST.INDENT\n\t\tself\n\n\tdef prebreak term = '\\n'\n\t\t# in options instead?\n\t\t# console.log \"prebreak!!!!\"\n\t\t# @prebreak = @prebreak or term\n\t\tself\n\n\tdef invert\n\t\treturn OP('!',self)\n\n\tdef cache o = {}\n\t\t@cache = o\n\t\to:var = scope__.temporary(self,o)\n\t\to:lookups = 0\n\t\t# o:lookups = 0\n\t\tself\n\n\tdef cachevar\n\t\t@cache && @cache:var\n\n\tdef decache\n\t\tif @cache\n\t\t\tcachevar.free\n\t\t\t@cache = nil # hmm, removing the cache WARN\n\t\tself\n\n\t# is this without side-effects? hmm - what does it even do?\n\tdef predeclare\n\t\tif @cache\n\t\t\tscope__.vars.swap(@cache:var,self)\n\t\tself\n\n\t# the \"name-suggestion\" for nodes if they need to be cached\n\tdef alias\n\t\tnil\n\n\tdef warn text, opts = {}\n\t\t# opts:node = self\n\t\t# p \"AST.warn {text} {opts}\"\n\t\topts:message = text\n\t\topts:loc ||= loc\n\t\tscope__.root.warn opts\n\t\tself\n\n\tdef c o\n\t\tif @cache && @cache:cached\n\t\t\t@cache:lookups++\n\t\t\tif @cache:uses == @cache:lookups\n\t\t\t\t@cache:var.free\n\t\t\t\t#  \"free variable(!) {@cache:var.c}\"\n\t\t\t# p \"getting cache {self}\"\n\t\t\t# free it after the cached usage?\n\t\t\t# possibly premark how many times it need to be used before it is freed?\n\t\t\treturn @cache:var.c\n\n\t\tSTACK.push(self)\n\t\tforceExpression if o && o:expression\n\n\t\tif o and o:indent\n\t\t\t# console.log \"set indentation\"\n\t\t\t@indentation ||= AST.INDENT\n\t\t\t# self.indented()\n\n\t\tvar out = js(STACK,o)\n\n\t\tvar paren = shouldParenthesize\n\t\t\n\t\tif var indent = @indentation\n\t\t\tout = indent.wrap(out,o)\n\n\t\tif paren\n\t\t\t# this is not a good way to do it\n\t\t\tif out isa Array\n\t\t\t\tout = \"({out})\"\n\t\t\telse\n\t\t\t\tout = out.parenthesize\n\n\t\tif o and o:braces\n\t\t\tout = '{' + out + '}'\n\n\n\t\t# what about if we should indent?!?\n\n\t\tSTACK.pop(self)\n\n\t\tif @cache\n\n\t\t\t# FIXME possibly double parenthesizing?\n\t\t\tout = \"{@cache:var.c}={out}\" unless @cache:manual\n\t\t\tvar par = STACK.current\n\t\t\tout = out.parenthesize if par isa AST.Access || par isa AST.Op # others?\n\t\t\t@cache:cached = yes\n\n\t\tif @temporary && @temporary:length\n\t\t\t@temporary.map do |temp| \n\t\t\t\t# p \"decache temp!!! {temp}\"\n\t\t\t\ttemp.decache\n\n\t\t# if @newlines && @newlines.value:length > 2\n\t\t# \tout = \"{out}\\n\"\n\n\t\treturn out\n\nclass AST.Expression < AST.Node\n\nclass AST.ValueNode < AST.Node\n\tprop value\n\n\tdef initialize value\n\t\t@value = load(value)\n\n\tdef load value\n\t\tvalue\n\n\tdef js\n\t\tvalue.c\n\n\tdef visit\n\t\t@value.traverse if @value && @value:traverse\n\t\tself\n\n\tdef region\n\t\t@value:_region\n\nclass AST.Statement < AST.ValueNode\n\n\tdef isExpressable\n\t\treturn no\n\t\t\n\tdef statement\n\t\treturn true\n\n\nclass AST.Meta < AST.ValueNode\n\nclass AST.Comment < AST.Meta\n\n\tdef c o\n\t\tif o and o:expression or @value.match(/\\n/) # multiline?\n\t\t\t\"/*{value.c}*/\"\n\t\telse\n\t\t\t\"// {value.c}\"\n\n\nclass AST.Terminator < AST.Meta\n\n\tdef c\n\t\treturn @value\n\t\t# var v = value.replace(/\\\\n/g,'\\n')\n\t\tv # .split()\n\t\t# v.split(\"\\n\").map(|v| v ? \" // {v}\" : v).join(\"\\n\")\n\nclass AST.Newline < AST.Terminator\n\n\tdef initialize v\n\t\t@value = v or '\\n'\n\n\tdef c\n\t\t@value\n\t\t\n\n# weird place?\nclass AST.Index < AST.ValueNode\n\n\tdef js\n\t\t@value.c\n\nclass AST.NewLines < AST.ValueNode\n\n\tdef js\n\t\t@value\n\n\tdef isExpressable\n\t\tyes\n\nclass AST.ListNode < AST.Node\n\n\tprop nodes\n\n\tdef initialize list = [], options = {}\n\t\t@nodes = load(list)\n\t\t@options = options\n\t\n\t# PERF acces @nodes directly?\n\tdef list\n\t\t@nodes\n\n\tdef compact\n\t\t@nodes = @nodes.compact\n\t\tself\n\n\tdef load list\n\t\tlist\n\n\tdef concat other\n\t\t# need to store indented content as well?\n\t\t@nodes = nodes.concat(other isa Array ? other : other.nodes)\n\t\tself\n\n\tdef swap item, other\n\t\tvar idx = indexOf(item)\n\t\tnodes[idx] = other if idx >= 0\n\t\tself\n\n\tdef push item\n\t\tnodes.push(item)\n\t\tself\n\n\tdef unshift item, br\n\t\tnodes.unshift(AST.BR) if br\n\t\tnodes.unshift(item)\n\t\tself\n\n\t# test\n\tdef slice a, b\n\t\tself:constructor.new(@nodes.slice(a,b))\n\n\tdef add item\n\t\tpush(item)\n\t\tself\n\n\tdef break br, pre = no\n\t\t# console.log \"breaking block! ({br})\"\n\t\t# should just accept regular terminators no?\n\t\t# console.log \"BREAKING {br}\"\n\t\tbr = AST.Terminator.new(br) if typeof br == 'string' # hmmm?\n\t\tpre ? unshift(br) : push(br)\n\t\tself\n\n\tdef some cb\n\t\tnodes.some(cb)\n\n\tdef every cb\n\t\tnodes.every(cb)\n\n\tdef filter cb\n\t\tif cb:prototype isa AST.Node\n\t\t\tvar ary = []\n\t\t\tnodes.forEach do |n| ary.push(n) if n isa cb\n\t\t\treturn ary\n\n\t\tnodes.filter(cb)\n\n\tdef pluck cb\n\t\tvar item = filter(cb)[0]\n\t\tremove(item) if item\n\t\treturn item\n\n\tdef indexOf item\n\t\tnodes.indexOf(item)\n\n\tdef index i\n\t\tnodes[i]\t\n\n\tdef remove item\n\t\tvar idx = list.indexOf(item)\n\t\tlist.splice(idx, 1) if idx >= 0\n\t\tself\n\n\tdef first\n\t\tlist[0]\n\t\t\n\t# def last\n\t#\tlist[list:length - 1]\n\n\tdef last\n\t\tvar i = @nodes:length\n\t\twhile i\n\t\t\ti = i - 1\n\t\t\tvar v = @nodes[i]\n\t\t\treturn v unless v isa AST.Meta\n\t\treturn nil\n\n\tdef map fn\n\t\tlist.map(fn)\n\n\tdef forEach fn\n\t\tlist.forEach(fn)\n\n\tdef remap fn\n\t\t@nodes = map(fn)\n\t\tself\n\n\tdef count\n\t\tlist:length\n\n\tdef replace original, replacement\n\t\tvar idx = nodes.indexOf(original)\n\t\tnodes[idx] = replacement if idx >= 0\n\t\tself\n\n\n\tdef visit\n\t\t@nodes.forEach do |node|\n\t\t\t# console.log \"traverse node {node}\"\n\t\t\tnode.traverse\n\t\tself\n\n\tdef isExpressable\n\t\treturn no unless nodes.every(|v| v.isExpressable )\n\t\treturn yes\n\n\tdef toArray\n\t\t@nodes\n\n\tdef delimiter\n\t\t@delimiter or \",\"\n\n\tdef js o, delim: delimiter, indent: @indentation, nodes: nodes\n\t\t# var delim = delimiter\n\t\tvar express = delim != ';'\n\t\tvar shouldDelim = no\n\t\tvar nodes = nodes.compact\n\t\tvar last = last\n\t\tvar realLast = nodes[nodes:length - 1]\n\t\t# need to find the last node that is not a comment or newline?\n\n\t\tvar parts = nodes.map do |arg| \n\t\t\tvar out = arg.c(expression: express)\n\t\t\t# if var br = arg.@prebreak\n\t\t\t# \tindent = yes # force indentation if one item is indented for now\n\t\t\t# \tout = br.replace(/\\\\n/g,\"\\n\") + out #  '\\n' + arg.@prebreak + out \n\t\t\t# \tconsole.log \"prebreak!!\"\n\t\t\t#\tout = delim + out if shouldDelim\n\t\t\t# else\n\t\t\t#\tout = delim + \" \" + out if shouldDelim\n\n\t\t\tif arg isa AST.Meta\n\t\t\t\ttrue\n\t\t\t\t# console.log \"argument is a comment!\"\n\t\t\t\t# shouldDelim = no\n\t\t\telse\n\t\t\t\t# comment as well?\n\t\t\t\t# shouldDelim = yes\n\t\t\t\tout = out + delim if !express or arg != last\n\t\t\tout\n\n\t\treturn parts.join(\"\")\n\n\t\t# if indent\n\t\t# \t# console.log \"{self} indented?\"\n\t\t# \t# hmm\n\t\t# \t# var out = (@prebreak or '\\n') +\n\t\t# \treturn indent:wrap and indent.wrap(parts.join(\"\"))\n\t\t# \n\t\t# \t# var out = parts.join(\"\").indent # + '\\n' # hmmm\n\t\t# \t# out = '\\n' + out unless nodes[0] isa AST.Terminator # hmmm\n\t\t# \t# out += '\\n' unless realLast isa AST.Terminator # hmmm\n\t\t# \t# out\n\t\t# else\n\t\t# \tparts.join(\"\")\n\t\t\n\nclass AST.ArgList < AST.ListNode\n\n\tdef hasSplat\n\t\tlist.some do |v| v isa AST.Splat\n\n\tdef delimiter\n\t\t\",\"\n\n\t# def visit\n\t# \t# console.log \"ArgList.visit {@indented}\"\n\t# \t# if @prebreak # hmm\n\t# \t# \tconsole.log \"adding prebreak inside {@prebreak} arglist\"\n\t# \t# \tfirst and first.prebreak(@prebreak) \n\t# \tsuper\n\n\t# def js\n\t# \treturn super\n\t# \t\n\t# \t# ).join(\",\")\n\n\t# def c\n\t# \tjs --- not good(!)\n\nclass AST.AssignList < AST.ArgList\t\n\t# def c o\n\t# \t# p \"compile arglist {self}\"\n\t# \tsuper.c o\n\n\tdef concat other\n\t\tif @nodes:length == 0 and other isa AST.AssignList\n\t\t\t# console.log \"return the other one(!)\",other.@indented[0]\n\t\t\treturn other\n\t\telse\n\t\t\tsuper\n\t\t# need to store indented content as well?\n\t\t# @nodes = nodes.concat(other isa Array ? other : other.nodes)\n\t\tself\n\n\n\n\nclass AST.Block < AST.ListNode\t\n\t\n\tprop head\n\n\tdef self.wrap ary\n\t\t# p \"called Block wrap!!\", $0\n\t\tary:length == 1 && ary[0] isa AST.Block ? ary[0] : AST.Block.new(ary)\n\t\t# return nodes[0] if nodes.length is 1 and nodes[0] instanceof Block\n\t\t# new Block nodes\n\n\t# def prebreak br\n\t# \tconsole.log \"Block prebreak {br}\"\n\t# \tsuper\n\n\tdef visit\n\t\t# @indentation ||= AST.INDENT\n\n\t\tif @prebreak # hmm\n\t\t\t# are we sure?\n\t\t\tconsole.log \"PREBREAK IN AST.BLOCK SHOULD THROW\"\n\t\t\tfirst and first.prebreak(@prebreak)\n\t\tsuper\n\t\t\n\tdef push item, sep\n\t\t# if sep\n\t\t# \t# probably better to set property on the item - no?\n\t\t# \t# only newlines - no ?\n\t\t# \t\n\t\t# \t# @newlines = sep.replace(//)\n\t\t# \t# var ln = sep.replace(/[^\\n]/g,''):length\n\t\t# \tvar ln = sep.split(\"\\\\n\"):length\n\t\t# \t# p \"block separator!\",ln,sep\n\t\t# \tlast && last.@newlines = ln - 1\n\t\t# \t# nodes.push(AST.NewLines.new(sep))\n\n\t\tnodes.push(item)\n\t\tself\n\n\tdef block\n\t\tself\n\n\tdef loc\n\t\tif var opt = option(:ends)\n\t\t\t# p \"location is\",opt\n\t\t\tvar a = opt[0].loc\n\t\t\tvar b = opt[1].loc\n\n\t\t\tp \"no loc for {opt[0]}\" unless a\n\t\t\tp \"no loc for {opt[1]}\" unless b\n\n\t\t\t[a[0],b[1]]\n\t\telse\n\t\t\t[0,0]\n\n\tdef initialize expr = []\n\t\tself.nodes = expr.flatten.compact or []\n\t\t# @indentation ||= AST.INDENT\n\n\t# go through children and unwrap inner nodes\n\tdef unwrap\n\t\tvar ary = []\n\t\tfor node,i in nodes\n\t\t\tif node isa AST.Block\n\t\t\t\t# p \"unwrapping inner block\"\n\t\t\t\tary:push.apply(ary,node.unwrap)\n\t\t\telse\n\t\t\t\tary.push(node)\n\t\treturn ary\n\n\t# This is just to work as an inplace replacement of nodes.coffee\n\t# After things are working okay we'll do bigger refactorings\n\tdef compile o = {}\n\t\tvar root = AST.Root.new(self,o)\n\t\troot.compile(o)\n\n\t# Not sure if we should create a separate block?\n\tdef analyze o = {}\n\t\t# p \"analyzing block!!!\",o\n\t\tself\n\n\tdef js o, opts\n\t\tvar l = nodes:length\n\t\t# var filter = \n\t\tvar filter = (|n| n != null && n != undefined && n != AST.EMPTY)\n\t\tvar ast = nodes.flatten.compact.filter(|n| n != null && n != undefined && n != AST.EMPTY)\n\t\tvar express = isExpression or o.isExpression or (option(:express) and isExpressable)\n\t\treturn null if ast:length == 0\n\n\t\t# return super(o, delim: ';', indent: no)\n\n\t\tif express\n\t\t\treturn super(o,delim: ',', nodes: ast)\n\t\t# else\n\t\t# \treturn super(o,delim: ';', nodes: ast)\n\t\t# return ast.c.flatten.compact.join(\", \")\n\n\t\tvar compile = do |node,i|\n\t\t\tvar out = node ? node.c : \"\"\n\t\t\treturn null if out == \"\"\n\n\t\t\t# hmm -- are we sure?\n\t\t\tif out isa Array\n\t\t\t\t# really??\n\t\t\t\tout = out.flatten.compact.filter(filter).join(\";\\n\")\n\n\t\t\tvar hasSemiColon = out.match(/;(\\s*\\/\\/.*)?[\\n\\s\\t]*$/) # out[out:length - 1] == \";\"\n\n\t\t\tout += \";\" unless hasSemiColon or node isa AST.Meta\n\t\t\t\n\t\t\t# if var br = node.@prebreak\n\t\t\t# \tconsole.log \"br prebreak\"\n\t\t\t# \tout = br.replace(/\\\\n/g,\"\\n\") + out\n\t\t\t# hmm\n\t\t\treturn out\n\n\t\tast = ast.map(compile)\n\n\t\t# now add the head items as well\n\t\tif @head\n\t\t\tvar prefix = []\n\t\t\t@head.forEach do |item|\n\t\t\t\tvar out = compile(item)\n\t\t\t\tprefix.push(out + '\\n') if out\n\n\t\t\tast = prefix.concat(ast)\n\t\t\t# var ln = node.@newlines or 1\n\t\t\t# c += Array(ln + 1).join(\"\\n\") # \"\\n\"\n\n\t\tast = ast.compact.filter(filter).join(\"\") # .replace(/[\\s\\n]+$/,'')  # hmm really?\n\n\t\t# @indentation ? @indentation.wrap(ast,opts) : ast\n\n\t# Should this create the function as well?\n\tdef defers original, replacement\n\t\tvar idx = nodes.indexOf(original)\n\t\tnodes[idx] = replacement if idx >= 0\n\t\t# now return the nodes after this\n\t\treplacement.@prebreak ||= original.@prebreak # hacky\n\t\tvar rest = nodes.splice(idx + 1)\n\t\treturn rest\n\n\tdef consume node\n\t\tif node isa AST.TagTree # special case?!?\n\t\t\t# what if there is only one node?\n\t\t\t# let all the inner nodes consume this\n\t\t\tnodes = nodes.map(|child| child.consume(node))\n\t\t\t# then wrap ourselves in an array as well(!)\n\t\t\tnodes = [AST.Arr.new(nodes)] if nodes:length > 1\n\t\t\t\n\t\t\t# hmmm\n\t\t\treturn self\n\n\t\t# can also return super if it is expressable, but should we really?\n\t\tif var before = last\n\t\t\tvar after = before.consume(node)\n\t\t\tif after != before\n\t\t\t\t\n\t\t\t\t# p \"replace node in block\"\n\t\t\t\treplace(before,after)\n\t\t# really?\n\t\treturn self\n\t\t\n\tdef isExpressable\n\t\treturn no unless nodes.every(|v| v.isExpressable )\n\t\treturn yes\n\n\tdef isExpression\n\t\toption(:express) || super.isExpression\n\n# this is almost like the old VarDeclarations but without the values\nclass AST.VarBlock < AST.ListNode\n\n\t# TODO All these inner items should rather be straight up literals\n\t# or basic localvars - without any care whatsoever about adding var to the\n\t# beginning etc. \n\n\tdef addExpression expr\n\t\t# p \"addExpression {self} <- {expr}\"\n\n\t\tif expr isa AST.Assign\n\t\t\taddExpression(expr.left) # make sure this is a valid thing?\n\t\t\t# make this into a tuple instead\n\t\t\t# possibly fix this as well?!?\n\t\t\t# does not need to be a tuple?\n\t\t\treturn AST.TupleAssign.new('=',AST.Tuple.new(nodes),expr.right)\n\n\t\telif expr isa AST.VarOrAccess\n\t\t\t# this is really a VarReference\n\t\t\tpush(AST.VarReference.new(expr.value))\n\n\t\telif expr isa AST.Splat && expr.node isa AST.VarOrAccess\n\t\t\t# p \"is a splat - only allowed in tuple-assignment\"\n\t\t\texpr.value = AST.VarReference.new(expr.node.value)\n\t\t\tpush(expr)\n\t\telse\n\t\t\tthrow \"VarBlock does not allow non-variable expressions\"\n\t\tself\n\n\tdef isExpressable\n\t\t# hmm, we would need to force-drop the variables, makes little sense\n\t\t# but, it could be, could just push the variables out?\n\t\tno\n\n\tdef js o\n\t\tvar code = nodes.map do |node| node.c\n\t\tcode = code.flatten.compact.filter(|n| n != null && n != undefined && n != AST.EMPTY)\n\t\treturn \"var {code.join(\",\")}\"\n\n\tdef consume node\n\t\t# It doesnt make much sense for a VarBlock to consume anything\n\t\t# it should probably return void for methods\n\t\t# throw \"VarBlock.consume\"\n\t\treturn self\n\n# Could inherit from valueNode\nclass AST.Parens < AST.ValueNode\n\n\t\t\n\tdef js o\n\t\tvar par = up\n\t\t# p \"Parens up {par} {o.isExpression}\"\n\n\t\tif par isa AST.Block\n\t\t\t@noparen = yes unless o.isExpression\n\t\t\treturn value.c(expression: o.isExpression)\n\t\telse\n\t\t\tvalue.c(expression: yes)\n\t\t# if value isa AST.Block\n\t\t# \t# no need to pare\n\t\t# \tp \"compile the parens {value} {value.count}\"\n\t\t# p \"compile the parens {value}\"\n\t\t# should not force expression\n\t\t# p o.isExpression\n\t\t# value.c(expression: yes)\n\t\t# \"({value.c(expression: o.isExpression)})\"\n\n\tdef shouldParenthesize\n\t\t# var par = up\n\t\t# no need to parenthesize if this is a line in a block\n\t\treturn no if @noparen #  or par isa AST.ArgList\n\t\treturn yes\n\n\tdef prebreak br\n\t\tsuper(br)\n\t\t# hmm\n\t\t@value.prebreak(br) if @value\n\t\tself\n\n\tdef isExpressable\n\t\tvalue.isExpressable\n\n\tdef consume node\n\t\tvalue.consume(node)\n\n# Could inherit from valueNode\n# an explicit expression-block (with parens) is somewhat different\n# can be used to return after an expression\nclass AST.ExpressionBlock < AST.ListNode\n\n\tdef visit\n\t\t# we need to see if this\n\t\tmap(|item| item.traverse)\n\t\tself\n\t\t\n\tdef c\n\t\tmap(|item| item.c).join(\",\")\n\n\t# def isExpressable\n\t#\tvalue.isExpressable\n\n\tdef consume node\n\t\tvalue.consume(node)\n\n\tdef addExpression expr\n\t\t# p \"add expression {self} <- {expr}\"\n\n\t\t# Need to take care of the splat here to.. hazzle\n\t\tif expr.node isa AST.Assign\n\t\t\t# p \"is assignment!\"\n\t\t\tpush(expr.left)\n\t\t\t# make this into a tuple instead\n\t\t\t# possibly fix this as well?!?\n\t\t\treturn AST.TupleAssign.new('=',AST.Tuple.new(nodes),expr.right)\n\t\telse\n\t\t\tpush(expr)\n\t\tself\n\n# create a raw-block for compiled stuff?\n\t\t\n\t\t\n\n"`
