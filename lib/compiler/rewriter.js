// Generated by CoffeeScript 1.8.0
(function() {
  var BALANCED_PAIRS, COMPOUND_ASSIGN, CONDITIONAL_ASSIGN, EXPRESSION_CLOSE, EXPRESSION_END, EXPRESSION_START, IDENTIFIERS, IMPLICIT_BLOCK, IMPLICIT_CALL, IMPLICIT_COMMA, IMPLICIT_END, IMPLICIT_FUNC, IMPLICIT_UNSPACED_CALL, INVERSES, LINEBREAKS, LOGIC, NO_IMPLICIT_BLOCK_CALL, SINGLE_CLOSERS, SINGLE_LINERS, UNARY, left, rite, _i, _len, _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  exports.Rewriter = (function() {
    function Rewriter() {}

    Rewriter.prototype.rewrite = function(tokens) {
      this.tokens = tokens;
      this.removeLeadingNewlines();
      this.removeMidExpressionNewlines();
      this.tagDefArguments();
      this.closeOpenCalls();
      this.closeOpenIndexes();
      this.closeOpenTags();
      this.closeOpenRawIndexes();
      this.closeOpenTagAttrLists();
      this.addImplicitIndentation();
      this.tagPostfixConditionals();
      this.addImplicitBraces();
      this.addImplicitParentheses();
      return this.tokens;
    };

    Rewriter.prototype.scanTokens = function(block) {
      var i, token, tokens;
      tokens = this.tokens;
      i = 0;
      while (token = tokens[i]) {
        i += block.call(this, token, i, tokens);
      }
      return true;
    };

    Rewriter.prototype.detectEnd = function(i, condition, action) {
      var levels, starts, token, tokens, _ref, _ref1;
      tokens = this.tokens;
      levels = 0;
      starts = [];
      while (token = tokens[i]) {
        if (levels === 0 && condition.call(this, token, i, starts)) {
          return action.call(this, token, i);
        }
        if (!token || levels < 0) {
          return action.call(this, token, i - 1);
        }
        if (_ref = token[0], __indexOf.call(EXPRESSION_START, _ref) >= 0) {
          if (levels === 0) {
            starts.push(i);
          }
          levels += 1;
        } else if (_ref1 = token[0], __indexOf.call(EXPRESSION_END, _ref1) >= 0) {
          levels -= 1;
        }
        i += 1;
      }
      return i - 1;
    };

    Rewriter.prototype.removeLeadingNewlines = function() {
      var i, tag, _i, _len, _ref;
      _ref = this.tokens;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        tag = _ref[i][0];
        if (tag !== 'TERMINATOR') {
          break;
        }
      }
      if (i) {
        return this.tokens.splice(0, i);
      }
    };

    Rewriter.prototype.removeMidExpressionNewlines = function() {
      return this.scanTokens(function(token, i, tokens) {
        var _ref;
        if (!(token[0] === 'TERMINATOR' && (_ref = this.tag(i + 1), __indexOf.call(EXPRESSION_CLOSE, _ref) >= 0))) {
          return 1;
        }
        tokens.splice(i, 1);
        return 0;
      });
    };

    Rewriter.prototype.tagDefArguments = function() {
      return true;
    };

    Rewriter.prototype.closeOpenCalls = function() {
      var action, condition;
      condition = function(token, i) {
        var _ref;
        return ((_ref = token[0]) === ')' || _ref === 'CALL_END') || token[0] === 'OUTDENT' && this.tag(i - 1) === ')';
      };
      action = function(token, i) {
        return this.tokens[token[0] === 'OUTDENT' ? i - 1 : i][0] = 'CALL_END';
      };
      return this.scanTokens(function(token, i) {
        if (token[0] === 'CALL_START') {
          this.detectEnd(i + 1, condition, action);
        }
        return 1;
      });
    };

    Rewriter.prototype.closeOpenIndexes = function() {
      var action, condition;
      condition = function(token, i) {
        var _ref;
        return (_ref = token[0]) === ']' || _ref === 'INDEX_END';
      };
      action = function(token, i) {
        return token[0] = 'INDEX_END';
      };
      return this.scanTokens(function(token, i) {
        if (token[0] === 'INDEX_START') {
          this.detectEnd(i + 1, condition, action);
        }
        return 1;
      });
    };

    Rewriter.prototype.closeOpenRawIndexes = function() {
      var action, condition;
      condition = function(token, i) {
        var _ref;
        return (_ref = token[0]) === '}' || _ref === 'RAW_INDEX_END';
      };
      action = function(token, i) {
        return token[0] = 'RAW_INDEX_END';
      };
      return this.scanTokens(function(token, i) {
        if (token[0] === 'RAW_INDEX_START') {
          this.detectEnd(i + 1, condition, action);
        }
        return 1;
      });
    };

    Rewriter.prototype.closeOpenTagAttrLists = function() {
      var action, condition;
      condition = function(token, i) {
        var _ref;
        return (_ref = token[0]) === ')' || _ref === 'TAG_ATTRS_END';
      };
      action = function(token, i) {
        return token[0] = 'TAG_ATTRS_END';
      };
      return this.scanTokens(function(token, i) {
        if (token[0] === 'TAG_ATTRS_START') {
          this.detectEnd(i + 1, condition, action);
        }
        return 1;
      });
    };

    Rewriter.prototype.closeOpenTags = function() {
      var action, condition;
      condition = function(token, i) {
        var _ref;
        return (_ref = token[0]) === '>' || _ref === 'TAG_END';
      };
      action = function(token, i) {
        return token[0] = 'TAG_END';
      };
      return this.scanTokens(function(token, i) {
        if (token[0] === 'TAG_START') {
          this.detectEnd(i + 1, condition, action);
        }
        return 1;
      });
    };

    Rewriter.prototype.addImplicitCommas = function() {};

    Rewriter.prototype.addImplicitBlockCalls = function() {
      return this.scanTokens(function(token, i, tokens) {
        var prev, _ref;
        prev = tokens[i - 1] || [];
        if (token[0] === 'DO' && ((_ref = prev[0]) === 'RAW_INDEX_END' || _ref === 'INDEX_END' || _ref === 'IDENTIFIER' || _ref === 'NEW')) {
          tokens.splice(i, 0, ['CALL_END', ')']);
          tokens.splice(i, 0, ['CALL_START', '(']);
          return 2;
        }
        return 1;
      });
    };

    Rewriter.prototype.addImplicitBraces = function() {
      var action, close, open, reopen, scope, stack, start, startIdx, startIndent;
      stack = [];
      start = null;
      startIndent = 0;
      startIdx = null;
      action = function(token, i) {
        var tok;
        tok = ['}', '}', token[2]];
        tok.generated = true;
        return this.tokens.splice(i, 0, tok);
      };
      open = (function(_this) {
        return function(token, i) {
          var tok, value;
          value = new String('{');
          value.generated = true;
          tok = ['{', value, token[2]];
          tok.generated = true;
          return _this.tokens.splice(i, 0, tok);
        };
      })(this);
      close = (function(_this) {
        return function(token, i) {
          var ctx, tok;
          tok = ['}', '}', token[2]];
          tok.generated = true;
          _this.tokens.splice(i, 0, tok);
          return ctx = scope();
        };
      })(this);
      reopen = (function(_this) {
        return function(token, i) {
          return true;
        };
      })(this);
      scope = function() {
        return stack[stack.length - 1] || [];
      };
      return this.scanTokens(function(token, i, tokens) {
        var ago, ctx, idx, prev, s, t0, tag, tok, value, _ref, _ref1;
        tag = token[0];
        ctx = stack[stack.length - 1] || [];
        if (token[1] === '?') {
          stack.push(['TERNARY', i]);
          return 1;
        }
        if (__indexOf.call(EXPRESSION_START, tag) >= 0) {
          if (tag === 'INDENT' && this.tag(i - 1) === '{') {
            stack.push(["{", i]);
          } else {
            stack.push([tag, i]);
          }
          return 1;
        }
        if (__indexOf.call(EXPRESSION_END, tag) >= 0) {
          if (ctx[0] === 'TERNARY') {
            stack.pop();
          }
          start = stack.pop();
          start[2] = i;
          if (start[0] === '{' && start.generated) {
            close(token, i);
            return 1;
          }
          return 1;
        }
        if (ctx[0] === 'TERNARY' && (tag === 'TERMINATOR' || tag === 'OUTDENT')) {
          stack.pop();
          return 1;
        }
        if (tag === ',') {
          if (scope()[0] === '{' && scope().generated) {
            action.call(this, token, i);
            stack.pop();
            return 2;
          } else {
            return 1;
          }
          true;
        }
        if (tag === ':' && ((_ref = ctx[0]) !== '{' && _ref !== 'TERNARY')) {
          if (start && start[2] === i - 1) {
            idx = start[1] - 1;
          } else {
            idx = i - 2;
          }
          while (this.tag(idx - 1) === 'HERECOMMENT') {
            idx -= 2;
          }
          t0 = this.tokens[idx - 1];
          if (t0 && t0[0] === '}' && t0.generated) {
            this.tokens.splice(idx - 1, 1);
            s = ['{'];
            s.generated = true;
            stack.push(s);
            return 0;
          } else if (t0 && t0[0] === ',' && this.tag(idx - 2) === '}') {
            this.tokens.splice(idx - 2, 1);
            s = ['{'];
            s.generated = true;
            stack.push(s);
            return 0;
          } else {
            s = ['{'];
            s.generated = true;
            stack.push(s);
            open(token, idx + 1);
            return 2;
          }
        }
        if (tag === 'DO') {
          prev = tokens[i - 1][0];
          if (prev === 'NUMBER' || prev === 'STRING' || prev === 'REGEX' || prev === 'SYMBOL' || prev === ']' || prev === '}' || prev === ')') {
            tok = [',', ','];
            tok.generated = true;
            this.tokens.splice(i, 0, tok);
            if (ctx.generated) {
              close(token, i);
              stack.pop();
              return 2;
            }
          }
        }
        if ((tag === 'TERMINATOR' || tag === 'OUTDENT' || tag === 'DEF_BODY') && ctx.generated) {
          close(token, i);
          stack.pop();
          return 2;
        }
        return 1;
        ago = this.tag(i - 2);
        if (typeof startIdx === 'number') {
          ago = this.tag(startIdx);
        }
        if (tag === ':' && scope()[0] !== '{') {
          idx = (start && start[1] || i) - 2;
          prev = this.tag(idx);
          console.log('prev is', prev);
          if (prev === '[' || prev === '(' || prev === ',') {
            console.log('should add', idx);
            stack.push(['{', idx + 1]);
            value = new String('{');
            value.generated = true;
            tok = ['{', value, token[2]];
            tok.generated = true;
            tokens.splice(idx + 1, 0, tok);
            return 2;
          }
        }
        if (!(tag === ':' && (ago === ':' || ((_ref1 = stack[stack.length - 1]) != null ? _ref1[0] : void 0) !== '{'))) {
          return 1;
        }
        stack.push(['{']);
        idx = ago === '@' ? i - 2 : i - 1;
        while (this.tag(idx - 2) === 'HERECOMMENT') {
          idx -= 2;
        }
        if (typeof startIdx === 'number') {
          idx = startIdx;
        }
        prev = tokens[idx - 2];
        if (false && this.tag(idx - 2) === '}' && prev.generated) {
          console.log('should merge!!!');
          tokens.splice(idx - 2, 1);
          this.detectEnd(i + 1, condition, action);
          return 2;
        } else {
          value = new String('{');
          value.generated = true;
          tok = ['{', value, token[2]];
          tok.generated = true;
          tokens.splice(idx, 0, tok);
          this.detectEnd(i + 2, condition, action);
          return 2;
        }
      });
    };

    Rewriter.prototype.addImplicitParentheses = function() {
      var action, noCall, noCallTag;
      noCall = false;
      noCallTag = ['CLASS', 'IF', 'UNLESS', 'TAG', 'WHILE', 'FOR', 'UNTIL', 'CATCH', 'FINALLY', 'MODULE'];
      action = function(token, i) {
        return this.tokens.splice(i, 0, ['CALL_END', ')', token[2]]);
      };
      return this.scanTokens(function(token, i, tokens) {
        var callIndent, callObject, current, next, prev, seenControl, seenSingle, tag, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
        tag = token[0];
        if (__indexOf.call(noCallTag, tag) >= 0) {
          noCall = true;
        }
        _ref = tokens.slice(i - 1, +(i + 1) + 1 || 9e9), prev = _ref[0], current = _ref[1], next = _ref[2];
        callObject = !noCall && tag === 'INDENT' && next && ((next.generated && next[0] === '{') || (next[0] === 'TAG_START')) && prev && (_ref1 = prev[0], __indexOf.call(IMPLICIT_FUNC, _ref1) >= 0);
        callObject = !noCall && tag === 'INDENT' && next && ((next.generated && next[0] === '{') || (_ref2 = next[0], __indexOf.call(IMPLICIT_CALL, _ref2) >= 0)) && prev && (_ref3 = prev[0], __indexOf.call(IMPLICIT_FUNC, _ref3) >= 0);
        callIndent = !noCall && tag === 'INDENT' && next && (_ref4 = next[0], __indexOf.call(IMPLICIT_CALL, _ref4) >= 0) && prev && (_ref5 = prev[0], __indexOf.call(IMPLICIT_FUNC, _ref5) >= 0);
        seenSingle = false;
        seenControl = false;
        if (tag === 'TERMINATOR' || tag === 'OUTDENT' || tag === 'INDENT') {
          noCall = false;
        }
        if (prev && !prev.spaced && tag === '?') {
          token.call = true;
        }
        if (token.fromThen) {
          return 1;
        }
        if (!(callObject || callIndent || (prev != null ? prev.spaced : void 0) && (prev.call || (_ref6 = prev[0], __indexOf.call(IMPLICIT_FUNC, _ref6) >= 0)) && (__indexOf.call(IMPLICIT_CALL, tag) >= 0 || !(token.spaced || token.newLine) && __indexOf.call(IMPLICIT_UNSPACED_CALL, tag) >= 0))) {
          return 1;
        }
        tokens.splice(i, 0, ['CALL_START', '(', token[2]]);
        this.detectEnd(i + 1, function(token, i) {
          var post, _ref7, _ref8;
          tag = token[0];
          if (!seenSingle && token.fromThen) {
            return true;
          }
          if (tag === 'IF' || tag === 'UNLESS' || tag === 'ELSE' || tag === 'CATCH' || tag === '->' || tag === '=>') {
            seenSingle = true;
          }
          if (tag === 'IF' || tag === 'UNLESS' || tag === 'ELSE' || tag === 'SWITCH' || tag === 'TRY') {
            seenControl = true;
          }
          prev = this.tag(i - 1);
          if ((tag === '.' || tag === '?.' || tag === '::') && this.tag(i - 1) === 'OUTDENT') {
            return true;
          }
          return !token.generated && this.tag(i - 1) !== ',' && (__indexOf.call(IMPLICIT_END, tag) >= 0 || (tag === 'INDENT' && !seenControl) || (tag === 'DOS' && (prev !== '='))) && (tag !== 'INDENT' || (this.tag(i - 2) !== 'CLASS' && (_ref7 = this.tag(i - 1), __indexOf.call(IMPLICIT_BLOCK, _ref7) < 0) && !((post = this.tokens[i + 1]) && ((post.generated && post[0] === '{') || (_ref8 = post[0], __indexOf.call(IMPLICIT_CALL, _ref8) >= 0)))));
        }, action);
        if (prev[0] === '?') {
          prev[0] = 'FUNC_EXIST';
        }
        return 2;
      });
    };

    Rewriter.prototype.addImplicitIndentation = function() {
      return this.scanTokens(function(token, i, tokens) {
        var action, condition, indent, outdent, starter, tag, _ref, _ref1, _ref2;
        tag = token[0];
        if (tag === 'TERMINATOR' && this.tag(i + 1) === 'THEN') {
          tokens.splice(i, 1);
          return 0;
        }
        if (tag === 'ELSE' && this.tag(i - 1) !== 'OUTDENT') {
          tokens.splice.apply(tokens, [i, 0].concat(__slice.call(this.indentation(token))));
          return 2;
        }
        if (tag === 'CATCH' && ((_ref = this.tag(i + 2)) === 'OUTDENT' || _ref === 'TERMINATOR' || _ref === 'FINALLY')) {
          tokens.splice.apply(tokens, [i + 2, 0].concat(__slice.call(this.indentation(token))));
          return 4;
        }
        if (__indexOf.call(SINGLE_LINERS, tag) >= 0 && ((_ref1 = this.tag(i + 1)) !== 'INDENT' && _ref1 !== 'BLOCK_PARAM_START') && !(tag === 'ELSE' && this.tag(i + 1) === 'IF') && !(tag === 'ELIF')) {
          starter = tag;
          _ref2 = this.indentation(token), indent = _ref2[0], outdent = _ref2[1];
          if (starter === 'THEN') {
            indent.fromThen = true;
          }
          indent.generated = outdent.generated = true;
          tokens.splice(i + 1, 0, indent);
          condition = function(token, i) {
            var _ref3;
            return token[1] !== ';' && (_ref3 = token[0], __indexOf.call(SINGLE_CLOSERS, _ref3) >= 0) && !(token[0] === 'ELSE' && (starter !== 'IF' && starter !== 'THEN'));
          };
          action = function(token, i) {
            return this.tokens.splice((this.tag(i - 1) === ',' ? i - 1 : i), 0, outdent);
          };
          this.detectEnd(i + 2, condition, action);
          if (tag === 'THEN') {
            tokens.splice(i, 1);
          }
          return 1;
        }
        return 1;
      });
    };

    Rewriter.prototype.tagPostfixConditionals = function() {
      var condition;
      condition = function(token, i) {
        var _ref;
        return (_ref = token[0]) === 'TERMINATOR' || _ref === 'INDENT';
      };
      return this.scanTokens(function(token, i) {
        var original;
        if (token[0] !== 'IF') {
          return 1;
        }
        original = token;
        this.detectEnd(i + 1, condition, function(token, i) {
          if (token[0] !== 'INDENT') {
            return original[0] = 'POST_' + original[0];
          }
        });
        return 1;
      });
    };

    Rewriter.prototype.indentation = function(token) {
      return [['INDENT', 2, token[2]], ['OUTDENT', 2, token[2]]];
    };

    Rewriter.prototype.tag = function(i) {
      var _ref;
      return (_ref = this.tokens[i]) != null ? _ref[0] : void 0;
    };

    return Rewriter;

  })();

  BALANCED_PAIRS = [['(', ')'], ['[', ']'], ['{', '}'], ['INDENT', 'OUTDENT'], ['CALL_START', 'CALL_END'], ['PARAM_START', 'PARAM_END'], ['INDEX_START', 'INDEX_END'], ['RAW_INDEX_START', 'RAW_INDEX_END'], ['TAG_START', 'TAG_END'], ['TAG_PARAM_START', 'TAG_PARAM_END'], ['TAG_ATTRS_START', 'TAG_ATTRS_END'], ['BLOCK_PARAM_START', 'BLOCK_PARAM_END']];

  exports.INVERSES = INVERSES = {};

  EXPRESSION_START = [];

  EXPRESSION_END = [];

  for (_i = 0, _len = BALANCED_PAIRS.length; _i < _len; _i++) {
    _ref = BALANCED_PAIRS[_i], left = _ref[0], rite = _ref[1];
    EXPRESSION_START.push(INVERSES[rite] = left);
    EXPRESSION_END.push(INVERSES[left] = rite);
  }

  IDENTIFIERS = ['IDENTIFIER', 'GVAR', 'IVAR', 'CVAR', 'CONST', 'ARGVAR'];

  EXPRESSION_CLOSE = ['CATCH', 'WHEN', 'ELSE', 'FINALLY'].concat(EXPRESSION_END);

  IMPLICIT_FUNC = ['IDENTIFIER', 'SUPER', ')', ']', 'INDEX_END', '@', 'THIS', 'SELF', 'EVENT', 'TRIGGER', 'RAW_INDEX_END', 'TAG_END', 'IVAR', 'GVAR', 'CONST', 'ARGVAR', 'NEW', 'BREAK', 'CONTINUE', 'RETURN'];

  IMPLICIT_CALL = ['SELECTOR', 'IDENTIFIER', 'NUMBER', 'STRING', 'SYMBOL', 'JS', 'REGEX', 'NEW', 'PARAM_START', 'CLASS', 'IF', 'UNLESS', 'TRY', 'SWITCH', 'THIS', 'BOOL', 'UNARY', 'SUPER', 'IVAR', 'GVAR', 'CONST', 'ARGVAR', 'SELF', 'NEW', '@', '[', '(', '{', '--', '++', 'SELECTOR', 'TAG_START', 'TAGID', '#', 'SELECTOR_START', 'IDREF', 'SPLAT', 'DO', 'BLOCK_ARG'];

  IMPLICIT_UNSPACED_CALL = ['+', '-'];

  IMPLICIT_BLOCK = ['{', '[', ',', 'BLOCK_PARAM_END', 'DO'];

  CONDITIONAL_ASSIGN = ['||=', '&&=', '?=', '&=', '|='];

  COMPOUND_ASSIGN = ['-=', '+=', '/=', '*=', '%=', '||=', '&&=', '?=', '<<=', '>>=', '>>>=', '&=', '^=', '|='];

  UNARY = ['!', '~', 'NEW', 'TYPEOF', 'DELETE'];

  LOGIC = ['&&', '||', '&', '|', '^'];

  NO_IMPLICIT_BLOCK_CALL = ['CALL_END', '=', 'DEF_BODY', '(', 'CALL_START', ',', ':', 'RETURN'].concat(COMPOUND_ASSIGN);

  IMPLICIT_COMMA = ['DO'];

  IMPLICIT_END = ['POST_IF', 'POST_UNLESS', 'FOR', 'WHILE', 'UNTIL', 'WHEN', 'BY', 'LOOP', 'TERMINATOR', 'DEF_BODY', 'DEF_FRAGMENT'];

  SINGLE_LINERS = ['ELSE', 'TRY', 'FINALLY', 'THEN', 'BLOCK_PARAM_END', 'DO', 'BEGIN', 'CATCH_VAR'];

  SINGLE_CLOSERS = ['TERMINATOR', 'CATCH', 'FINALLY', 'ELSE', 'OUTDENT', 'LEADING_WHEN'];

  LINEBREAKS = ['TERMINATOR', 'INDENT', 'OUTDENT'];

}).call(this);
