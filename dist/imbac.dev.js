var Imbac =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		var parser, lex, Rewriter;
		
		// var imba = require '../imba'
		var T = __webpack_require__(1);
		var ERR = __webpack_require__(2);
		var util = __webpack_require__(3);
		var lexer = __webpack_require__(4);
		var rewriter = __webpack_require__(5);
		module.exports.parser = parser = __webpack_require__(6).parser;
		var ast = __webpack_require__(9);
		
		var ImbaParseError = __webpack_require__(2).ImbaParseError;
		
		// Instantiate a Lexer for our use here.
		module.exports.lex = lex = new (lexer.Lexer)();
		module.exports.Rewriter = Rewriter = rewriter.Rewriter;
		
		parser.lexer = lex.jisonBridge();
		parser.yy = ast; // everything is exported right here now
		
		
		function tokenize(code,o){
			if(o === undefined) o = {};
			try {
				o._source = code;
				lex.reset();
				return lex.tokenize(code,o);
			} catch (err) {
				throw err;
			};
		}; exports.tokenize = tokenize;
		
		function rewrite(tokens,o){
			if(o === undefined) o = {};
			var rewriter = new Rewriter();
			try {
				return rewriter.rewrite(tokens,o);
			} catch (err) {
				throw err;
			};
		}; exports.rewrite = rewrite;
		
		
		function parse(code,o){
			if(o === undefined) o = {};
			var tokens = code instanceof Array ? (code) : (tokenize(code,o));
			try {
				// console.log("Tokens",tokens)
				if (tokens != code) o._source || (o._source = code);
				o._tokens = tokens;
				return parser.parse(tokens);
			} catch (err) {
				if (o.filename) { err._filename = o.filename };
				throw err;
			};
		}; exports.parse = parse;
		
		
		function compile(code,o){
			if(o === undefined) o = {};
			try {
				var tokens = tokenize(code,o);
				var ast = parse(tokens,o);
				return ast.compile(o);
			} catch (err) {
				if (o.filename) { err._filename = o.filename };
				tokens || (tokens = o._tokens);
				
				if (tokens && (err instanceof ImbaParseError)) {
					try {
						var tok = err.start();
					} catch (e) {
						throw err;
					};
					
					var locmap = util.locationToLineColMap(code);
					var lines = code.split(/\n/g);
					
					var lc = locmap[tok._loc] || [0,0];
					var ln = lc[0];
					var col = lc[1];
					var line = lines[ln];
					
					var message = err.message + ("\n\n" + ln) + ("\n" + (ln + 1) + " " + line) + ("\n" + (ln + 2));
					var reducer = function(s,c,i) {
						return s += i == col ? ("^") : ((c == "\t" ? (c) : (" ")));
					};
					message += line.split('').reduce(reducer,"");
					
					err.message = message;
				};
				throw err;
			};
		}; exports.compile = compile;
		
		function analyze(code,o){
			if(o === undefined) o = {};
			var meta;
			try {
				var ast = parse(code,o);
				meta = ast.analyze(o);
			} catch (e) {
				// console.log "something wrong {e:message}"
				if (!((e instanceof ImbaParseError))) {
					if (e.lexer) {
						e = new ImbaParseError(e,{tokens: e.lexer.tokens,pos: e.lexer.pos});
					} else {
						throw e;
					};
				};
				meta = {warnings: [e]};
			};
			return meta;
		}; exports.analyze = analyze;; return analyze;

	})()

/***/ },
/* 1 */
/***/ function(module, exports) {

	(function(){
		var TOK, LBRACKET, RBRACKET, LPAREN, RPAREN, INDENT, OUTDENT;
		
		
		module.exports.TOK = TOK = {};
		var TTERMINATOR = TOK.TERMINATOR = 1;
		var TIDENTIFIER = TOK.IDENTIFIER = TOK.IVAR = 2;
		var CONST = TOK.CONST = 3;
		var VAR = TOK.VAR = 4;
		var IF = TOK.IF = 5;
		var ELSE = TOK.ELSE = 6;
		var DEF = TOK.DEF = 7;
		
		function Token(type,value,loc,len){
			this._type = type;
			this._value = value;
			this._loc = loc != null ? (loc) : (-1);
			this._len = len || 0;
			this._meta = null;
			this.generated = false;
			this.newLine = false;
			this.spaced = false;
			return this;
		};
		
		exports.Token = Token; // export class 
		Token.prototype.type = function (){
			return this._type;
		};
		
		Token.prototype.value = function (){
			return this._value;
		};
		
		Token.prototype.traverse = function (){
			return;
		};
		
		Token.prototype.c = function (){
			return "" + this._value;
		};
		
		Token.prototype.toString = function (){
			return this._value;
		};
		
		Token.prototype.charAt = function (i){
			return this._value.charAt(i);
		};
		
		Token.prototype.slice = function (i){
			return this._value.slice(i);
		};
		
		Token.prototype.region = function (){
			return [this._loc,this._loc + (this._len || this._value.length)];
		};
		
		Token.prototype.sourceMapMarker = function (){
			return this._loc == -1 ? (':') : (("%$" + (this._loc) + "$%"));
			// @col == -1 ? '' : "%%{@line}${@col}%%"
		};
		
		
		function lex(){
			var token = this.tokens[this.pos++];
			var ttag;
			
			if (token) {
				ttag = token._type;
				this.yytext = token;
			} else {
				ttag = '';
			};
			
			return ttag;
		}; exports.lex = lex;
		
		
		// export def token typ, val, line, col, len do Token.new(typ,val,line, col or 0, len or 0) # [null,typ,val,loc]
		function token(typ,val){
			return new Token(typ,val,-1,0);
		}; exports.token = token;
		
		function typ(tok){
			return tok._type;
		}; exports.typ = typ;
		function val(tok){
			return tok._value;
		}; exports.val = val; // tok[offset + 1]
		function line(tok){
			return tok._line;
		}; exports.line = line; // tok[offset + 2]
		function loc(tok){
			return tok._loc;
		}; exports.loc = loc; // tok[offset + 2]
		
		function setTyp(tok,v){
			return tok._type = v;
		}; exports.setTyp = setTyp;
		function setVal(tok,v){
			return tok._value = v;
		}; exports.setVal = setVal;
		function setLine(tok,v){
			return tok._line = v;
		}; exports.setLine = setLine;
		function setLoc(tok,v){
			return tok._loc = v;
		}; exports.setLoc = setLoc;
		
		
		module.exports.LBRACKET = LBRACKET = new Token('{','{',0,0,0);
		module.exports.RBRACKET = RBRACKET = new Token('}','}',0,0,0);
		
		module.exports.LPAREN = LPAREN = new Token('(','(',0,0,0);
		module.exports.RPAREN = RPAREN = new Token(')',')',0,0,0);
		
		LBRACKET.generated = true;
		RBRACKET.generated = true;
		LPAREN.generated = true;
		RPAREN.generated = true;
		
		module.exports.INDENT = INDENT = new Token('INDENT','2',0,0,0);
		return module.exports.OUTDENT = OUTDENT = new Token('OUTDENT','2',0,0,0);
	
	})()

/***/ },
/* 2 */
/***/ function(module, exports) {

	(function(){
		// helper for subclassing
		function subclass$(obj,sup) {
			for (var k in sup) {
				if (sup.hasOwnProperty(k)) obj[k] = sup[k];
			};
			// obj.__super__ = sup;
			obj.prototype = Object.create(sup.prototype);
			obj.__super__ = obj.prototype.__super__ = sup.prototype;
			obj.prototype.initialize = obj.prototype.constructor = obj;
		};
		
		// create separate error-types with all the logic
		
		function ImbaParseError(e,o){
			this.error = e;
			this.message = e.message;
			this.filename = e.filename;
			this.line = e.line;
			this._options = o || {};
			this;
		};
		
		subclass$(ImbaParseError,Error);
		exports.ImbaParseError = ImbaParseError; // export class 
		ImbaParseError.wrap = function (err){
			// what about the stacktrace?
			return new ImbaParseError(err);
		};
		
		ImbaParseError.prototype.set = function (opts){
			this._options || (this._options = {});
			for (var i = 0, keys = Object.keys(opts), l = keys.length; i < l; i++){
				this._options[keys[i]] = opts[keys[i]];
			};
			return this;
		};
		
		ImbaParseError.prototype.start = function (){
			var o = this._options;
			var idx = o.pos - 1;
			var tok = o.tokens && o.tokens[idx];
			while (tok && tok._loc == -1){
				tok = o.tokens[--idx];
			};
			return tok;
		};
		
		ImbaParseError.prototype.desc = function (){
			var o = this._options;
			var msg = this.message;
			if (o.token && o.token._loc == -1) {
				return 'Syntax Error';
			} else {
				return msg;
			};
		};
		
		ImbaParseError.prototype.loc = function (){
			var start_;
			return (start_ = this.start()) && start_.region  &&  start_.region();
		};
		
		ImbaParseError.prototype.toJSON = function (){
			var o = this._options;
			var tok = this.start();
			// var tok = o:tokens and o:tokens[o:pos - 1]
			// var loc = tok and [tok.@loc,tok.@loc + (tok.@len or tok.@value:length)] or [0,0]
			// , col: tok.@col, line: tok.@line
			// get the token itself?
			return {warn: true,message: this.desc(),loc: this.loc()};
		};
		return ImbaParseError;
	
	})()

/***/ },
/* 3 */
/***/ function(module, exports) {

	(function(){
		
		function brace(str){
			var lines = str.match(/\n/);
			// what about indentation?
			
			if (lines) {
				return '{' + str + '\n}';
			} else {
				return '{\n' + str + '\n}';
			};
		}; exports.brace = brace;
		
		function normalizeIndentation(str){
			var m;
			var reg = /\n+([^\n\S]*)/g;
			var ind = null;
			
			var length_;while (m = reg.exec(str)){
				var attempt = m[1];
				if (ind == null || 0 < (length_ = attempt.length) && length_ < ind.length) {
					ind = attempt;
				};
			};
			
			if (ind) { str = str.replace(RegExp(("\\n" + ind),"g"),'\n') };
			return str;
		}; exports.normalizeIndentation = normalizeIndentation;
		
		
		function flatten(arr){
			var out = [];
			arr.forEach(function(v) { return v instanceof Array ? (out.push.apply(out,flatten(v))) : (out.push(v)); });
			return out;
		}; exports.flatten = flatten;
		
		
		function pascalCase(str){
			return str.replace(/(^|[\-\_\s])(\w)/g,function(m,v,l) { return l.toUpperCase(); });
		}; exports.pascalCase = pascalCase;
		
		function camelCase(str){
			str = String(str);
			// should add shortcut out
			return str.replace(/([\-\_\s])(\w)/g,function(m,v,l) { return l.toUpperCase(); });
		}; exports.camelCase = camelCase;
		
		function snakeCase(str){
			var str = str.replace(/([\-\s])(\w)/g,'_');
			return str.replace(/()([A-Z])/g,"_$1",function(m,v,l) { return l.toUpperCase(); });
		}; exports.snakeCase = snakeCase;
		
		function setterSym(sym){
			return camelCase(("set-" + sym));
		}; exports.setterSym = setterSym;
		
		function quote(str){
			return '"' + str + '"';
		}; exports.quote = quote;
		
		function singlequote(str){
			return "'" + str + "'";
		}; exports.singlequote = singlequote;
		
		function symbolize(str){
			str = String(str);
			var end = str.charAt(str.length - 1);
			
			if (end == '=') {
				str = 'set' + str[0].toUpperCase() + str.slice(1,-1);
			};
			
			if (str.indexOf("-") >= 0) {
				str = str.replace(/([\-\s])(\w)/g,function(m,v,l) { return l.toUpperCase(); });
			};
			
			return str;
		}; exports.symbolize = symbolize;
		
		
		function indent(str){
			return String(str).replace(/^/g,"\t").replace(/\n/g,"\n\t").replace(/\n\t$/g,"\n");
		}; exports.indent = indent;
		
		function bracketize(str,ind){
			if(ind === undefined) ind = true;
			if (ind) { str = "\n" + indent(str) + "\n" };
			return '{' + str + '}';
		}; exports.bracketize = bracketize;
		
		function parenthesize(str){
			return '(' + String(str) + ')';
		}; exports.parenthesize = parenthesize;
		
		function locationToLineColMap(code){
			var lines = code.split(/\n/g);
			var map = [];
			
			var chr;
			var loc = 0;
			var col = 0;
			var line = 0;
			
			while (chr = code[loc]){
				map[loc] = [line,col];
				
				if (chr == '\n') {
					line++;
					col = 0;
				} else {
					col++;
				};
				
				loc++;
			};
			
			return map;
		}; exports.locationToLineColMap = locationToLineColMap;
		
		function markLineColForTokens(tokens,code){
			return this;
		}; exports.markLineColForTokens = markLineColForTokens;; return markLineColForTokens;

	})()

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function idx$(a,b){
			return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
		};
		
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		// helper for subclassing
		function subclass$(obj,sup) {
			for (var k in sup) {
				if (sup.hasOwnProperty(k)) obj[k] = sup[k];
			};
			// obj.__super__ = sup;
			obj.prototype = Object.create(sup.prototype);
			obj.__super__ = obj.prototype.__super__ = sup.prototype;
			obj.prototype.initialize = obj.prototype.constructor = obj;
		};
		
		var ALL_KEYWORDS;
		
		var T = __webpack_require__(1);
		var Token = T.Token;
		
		var rw = __webpack_require__(5);
		var Rewriter = rw.Rewriter;
		var INVERSES = rw.INVERSES;
		
		var K = 0;
		
		var ERR = __webpack_require__(2);
		
		// Constants
		// ---------
		
		// Keywords that Imba shares in common with JavaScript.
		var JS_KEYWORDS = [
			'true','false','null','this',
			'delete','typeof','in','instanceof',
			'throw','break','continue','debugger',
			'if','else','switch','for','while','do','try','catch','finally',
			'class','extends','super','return'
		];
		
		// new can be used as a keyword in imba, since object initing is done through
		// MyObject.new. new is a very useful varname.
		
		// We want to treat return like any regular call for now
		// Must be careful to throw the exceptions in AST, since the parser
		// wont
		
		// Imba-only keywords. var should move to JS_Keywords
		// some words (like tokid) should be context-specific
		var IMBA_KEYWORDS = [
			'undefined','then','unless','until','loop','of','by',
			'when','def','tag','do','elif','begin','var','let','self','await','import'
		];
		
		var IMBA_CONTEXTUAL_KEYWORDS = ['extend','static','local','export','global','prop'];
		
		var IMBA_ALIAS_MAP = {
			'and': '&&',
			'or': '||',
			'is': '==',
			'isnt': '!=',
			'not': '!',
			'yes': 'true',
			'no': 'false',
			'isa': 'instanceof',
			'case': 'switch',
			'nil': 'null'
		};
		
		var IMBA_ALIASES = Object.keys(IMBA_ALIAS_MAP);
		IMBA_KEYWORDS = IMBA_KEYWORDS.concat(IMBA_ALIASES);
		
		// FixedArray for performance
		// var ALL_KEYWORDS = JS_KEYWORDS.concat(IMBA_KEYWORDS)
		module.exports.ALL_KEYWORDS = ALL_KEYWORDS = [
			'true','false','null','this',
			'delete','typeof','in','instanceof',
			'throw','break','continue','debugger',
			'if','else','switch','for','while','do','try','catch','finally',
			'class','extends','super','return',
			'undefined','then','unless','until','loop','of','by',
			'when','def','tag','do','elif','begin','var','let','self','await','import',
			'and','or','is','isnt','not','yes','no','isa','case','nil'
		];
		
		// The list of keywords that are reserved by JavaScript, but not used, or are
		// used by Imba internally. We throw an error when these are encountered,
		// to avoid having a JavaScript error at runtime.  # 'var', 'let', - not inside here
		var RESERVED = ['case','default','function','void','with','const','enum','native'];
		var STRICT_RESERVED = ['case','function','void','const'];
		
		// The superset of both JavaScript keywords and reserved words, none of which may
		// be used as identifiers or properties.
		var JS_FORBIDDEN = JS_KEYWORDS.concat(RESERVED);
		
		var METHOD_IDENTIFIER = /^((([\x23]?[\$A-Za-z_\x7f-\uffff][$\-\w\x7f-\uffff]*)([\=]?))|(<=>|\|(?![\|=])))/;
		// removed ~=|~| |&(?![&=])
		
		// Token matching regexes.
		// added hyphens to identifiers now - to test
		var IDENTIFIER = /^((\$|@@|@|\#)[\wA-Za-z_\-\x7f-\uffff][$\w\x7f-\uffff]*(\-[$\w\x7f-\uffff]+)*|[$A-Za-z_][$\w\x7f-\uffff]*(\-[$\w\x7f-\uffff]+)*)([^\n\S]*:(?![\*\=:$\w\x7f-\uffff]))?/;
		
		var OBJECT_KEY = /^((\$|@@|@|)[$A-Za-z_\x7f-\uffff\-][$\w\x7f-\uffff\-]*)([^\n\S\s]*:(?![\*\=:$\w\x7f-\uffff]))/;
		
		var TAG = /^(\<|%)(?=[A-Za-z\#\.\{\@\>])/;
		
		var TAG_TYPE = /^(\w[\w\d]*:)?(\w[\w\d]*)(-[\w\d]+)*/;
		var TAG_ID = /^#((\w[\w\d]*)(-[\w\d]+)*)/;
		
		var TAG_ATTR = /^([\.\:]?[\w\_]+([\-\:][\w]+)*)(\s)*\=/;
		
		var SELECTOR = /^([%\$]{1,2})([\(\w\#\.\[])/;
		var SELECTOR_PART = /^(\#|\.|:|::)?([\w]+(\-[\w]+)*)/;
		var SELECTOR_COMBINATOR = /^ (\+|\>|\~)*\s*(?=[\w\.\#\:\{\*\[])/;
		
		var SELECTOR_PSEUDO_CLASS = /^(::?)([\w]+(\-[\w]+)*)/;
		var SELECTOR_ATTR_OP = /^(\$=|\~=|\^=|\*=|\|=|=|\!=)/;
		var SELECTOR_ATTR = /^\[([\w\_\-]+)(\$=|\~=|\^=|\*=|\|=|=|\!=)/;
		
		var SYMBOL = /^\:((([\*\@$\w\x7f-\uffff]+)+([\-\\/\\\:][\w\x7f-\uffff]+)*)|==|\<=\>|\[\]|\[\]\=|\*|[\\/,\\])/;
		
		
		var NUMBER = /^0x[\da-f]+|^0b[01]+|^\d*\.?\d+(?:e[+-]?\d+)?/i;
		
		var HEREDOC = /^("""|''')([\s\S]*?)(?:\n[^\n\S]*)?\1/;
		
		var OPERATOR = /^(?:[-=]=>|===|->|!==|[-+*\/%<>&|^!?=]=|=<|>>>=?|([-+:])\1|([&|<>])\2=?|\?\.|\?\:|\.{2,3}|\*(?=[a-zA-Z\_]))/;
		
		// FIXME splat should only be allowed when the previous thing is spaced or inside call?
		
		var WHITESPACE = /^[^\n\S]+/;
		
		var COMMENT = /^###([^#][\s\S]*?)(?:###[^\n\S]*|(?:###)?$)/;
		// COMMENT    = /^###([^#][\s\S]*?)(?:###[^\n\S]*|(?:###)?$)|^(?:\s*(#\s.*|#\s*$))+/
		var INLINE_COMMENT = /^(\s*)(#[ \t\!](.*)|#[ \t]?(?=\n|$))+/;
		
		var CODE = /^[-=]=>/;
		
		var MULTI_DENT = /^(?:\n[^\n\S]*)+/;
		
		var SIMPLESTR = /^'[^\\']*(?:\\.[^\\']*)*'/;
		
		var JSTOKEN = /^`[^\\`]*(?:\\.[^\\`]*)*`/;
		
		// Regex-matching-regexes.
		var REGEX = /^(\/(?![\s=])[^[\/\n\\]*(?:(?:\\[\s\S]|\[[^\]\n\\]*(?:\\[\s\S][^\]\n\\]*)*])[^[\/\n\\]*)*\/)([imgy]{0,4})(?!\w)/;
		
		var HEREGEX = /^\/{3}([\s\S]+?)\/{3}([imgy]{0,4})(?!\w)/;
		
		var HEREGEX_OMIT = /\s+(?:#.*)?/g;
		
		// Token cleaning regexes.
		var MULTILINER = /\n/g;
		
		var HEREDOC_INDENT = /\n+([^\n\S]*)/g;
		
		var HEREDOC_ILLEGAL = /\*\//;
		
		// expensive?
		var LINE_CONTINUER = /^\s*(?:,|\??\.(?![.\d])|::)/;
		
		var TRAILING_SPACES = /\s+$/;
		
		var CONST_IDENTIFIER = /^[A-Z]/;
		
		var ARGVAR = /^\$\d$/;
		
		// Compound assignment tokens.
		var COMPOUND_ASSIGN = ['-=','+=','/=','*=','%=','||=','&&=','?=','<<=','>>=','>>>=','&=','^=','|=','=<'];
		
		// Unary tokens.
		var UNARY = ['!','~','NEW','TYPEOF','DELETE'];
		
		// Logical tokens.
		var LOGIC = ['&&','||','&','|','^'];
		
		// Bit-shifting tokens.
		var SHIFT = ['<<','>>','>>>'];
		
		// Comparison tokens.
		var COMPARE = ['===','!==','==','!=','<','>','<=','>=','===','!=='];
		
		// Overideable methods
		var OP_METHODS = ['<=>','<<','..'];
		
		// Mathematical tokens.
		var MATH = ['*','/','%','∪','∩','√'];
		
		// Relational tokens that are negatable with `not` prefix.
		var RELATION = ['IN','OF','INSTANCEOF','ISA'];
		
		// Boolean tokens.
		var BOOL = ['TRUE','FALSE','NULL','UNDEFINED'];
		
		// Our list is shorter, due to sans-parentheses method calls.
		var NOT_REGEX = ['NUMBER','REGEX','BOOL','TRUE','FALSE','++','--',']'];
		
		// If the previous token is not spaced, there are more preceding tokens that
		// force a division parse:
		var NOT_SPACED_REGEX = ['NUMBER','REGEX','BOOL','TRUE','FALSE','++','--',']',')','}','THIS','SELF','IDENTIFIER','STRING'];
		
		// Tokens which could legitimately be invoked or indexed. An opening
		// parentheses or bracket following these tokens will be recorded as the start
		// of a function invocation or indexing operation.
		// really?!
		
		var UNFINISHED = ['\\','.','?.','?:','UNARY','MATH','+','-','SHIFT','RELATION','COMPARE','LOGIC','COMPOUND_ASSIGN','THROW','EXTENDS'];
		
		// } should not be callable anymore!!! '}', '::',
		var CALLABLE = ['IDENTIFIER','STRING','REGEX',')',']','THIS','SUPER','TAG_END','IVAR','GVAR','SELF','CONST','NEW','ARGVAR','SYMBOL','RETURN'];
		// var INDEXABLE = CALLABLE.concat 'NUMBER', 'BOOL', 'TAG_SELECTOR', 'IDREF', 'ARGUMENTS','}' # are booleans indexable? really?
		// optimize for FixedArray
		var INDEXABLE = [
			'IDENTIFIER','STRING','REGEX',')',']','THIS','SUPER','TAG_END','IVAR','GVAR','SELF','CONST','NEW','ARGVAR','SYMBOL','RETURN',
			'NUMBER','BOOL','TAG_SELECTOR','IDREF','ARGUMENTS','}','TAG_TYPE'
		];
		
		var GLOBAL_IDENTIFIERS = ['global','exports','require'];
		
		// Tokens that, when immediately preceding a `WHEN`, indicate that the `WHEN`
		// occurs at the start of a line. We disambiguate these from trailing whens to
		// avoid an ambiguity in the grammar.
		var LINE_BREAK = ['INDENT','OUTDENT','TERMINATOR'];
		
		
		function LexerError(message,file,line){
			this.message = message;
			this.file = file;
			this.line = line;
			return this;
		};
		subclass$(LexerError,SyntaxError);
		exports.LexerError = LexerError; // export class 
		
		
		
		function last(array,back){
			if(back === undefined) back = 0;
			return array[array.length - back - 1];
		};
		
		function count(str,substr){
			return str.split(substr).length - 1;
		};
		
		function repeatString(str,times){
			var res = '';
			while (times > 0){
				if (times % 2 == 1) {
					res += str;
				};
				str += str;
				times >>= 1;
			};
			return res;
		};
		
		var tT = T.typ;
		var tV = T.val;
		var tTs = T.setTyp;
		var tVs = T.setVal;
		
		// The Lexer class reads a stream of Imba and divvies it up into tokidged
		// tokens. Some potential ambiguity in the grammar has been avoided by
		// pushing some extra smarts into the Lexer.
		
		// Based on the original lexer.coffee from CoffeeScript
		function Lexer(){
			this.reset();
			this;
		};
		
		exports.Lexer = Lexer; // export class 
		Lexer.prototype.reset = function (){
			this._code = null;
			this._chunk = null; // The remainder of the source code.
			this._opts = null;
			
			this._indent = 0; // The current indentation level.
			this._indebt = 0; // The over-indentation at the current level.
			this._outdebt = 0; // The under-outdentation at the current level.
			
			this._indents = []; // The stack of all current indentation levels.
			this._ends = []; // The stack for pairing up tokens.
			this._contexts = []; // suplements @ends
			this._scopes = [];
			this._nextScope = null; // the scope to add on the next indent
			// should rather make it like a statemachine that moves from CLASS_DEF to CLASS_BODY etc
			// Things should compile differently when you are in a CLASS_BODY than when in a DEF_BODY++
			
			this._indentStyle = null;
			
			this._tokens = []; // Stream of parsed tokens in the form `['TYPE', value, line]`.
			this._seenFor = false;
			this._loc = 0;
			this._locOffset = 0;
			
			this._end = null;
			this._char = null;
			this._bridge = null;
			this._last = null;
			this._lastTyp = '';
			this._lastVal = null;
			return this;
		};
		
		Lexer.prototype.jisonBridge = function (jison){
			return this._bridge = {
				lex: T.lex,
				setInput: function(tokens) {
					this.tokens = tokens;
					return this.pos = 0;
				},
				
				upcomingInput: function() { return ""; }
			};
		};
		
		
		Lexer.prototype.tokenize = function (code,o){
			
			if(o === undefined) o = {};
			if (code.length == 0) {
				return [];
			};
			
			if (!o.inline) {
				if (WHITESPACE.test(code)) {
					code = ("\n" + code);
					if (code.match(/^\s*$/g)) { return [] };
				};
				
				code = code.replace(/\r/g,'').replace(/[\t ]+$/g,'');
			};
			
			this._last = null;
			this._lastTyp = null;
			this._lastVal = null;
			
			this._code = code;
			this._opts = o;
			this._locOffset = o.loc || 0;
			
			o.indent || (o.indent = {style: null,size: null});
			// add a reference to the options object
			o._tokens = this._tokens;
			// what about col here?
			
			// @indent  = 0 # The current indentation level.
			// @indebt  = 0 # The over-indentation at the current level.
			// @outdebt = 0 # The under-outdentation at the current level.
			// @indents = [] # The stack of all current indentation levels.
			// @ends    = [] # The stack for pairing up tokens.
			// @tokens  = [] # Stream of parsed tokens in the form `['TYPE', value, line]`.
			// @char = nil
			
			if (o.profile) { console.time("tokenize:lexer") };
			this.parse(code);
			if (!o.inline) this.closeIndentation();
			if (!o.silent && this._ends.length) {
				this.error(("missing " + (this._ends.pop())));
			};
			
			if (o.profile) { console.timeEnd("tokenize:lexer") };
			if (o.rewrite == false || o.norewrite) { return this._tokens };
			return new Rewriter().rewrite(this._tokens,o);
		};
		
		Lexer.prototype.parse = function (code){
			var i = 0;
			var pi = 0;
			
			while (this._chunk = code.slice(i)){
				this._loc = this._locOffset + i;
				pi = (this._end == 'TAG' && this.tagDefContextToken()) || (this._inTag && this.tagContextToken()) || this.basicContext();
				i += pi;
			};
			
			return;
		};
		
		Lexer.prototype.basicContext = function (){
			return this.selectorToken() || this.symbolToken() || this.methodNameToken() || this.identifierToken() || this.whitespaceToken() || this.lineToken() || this.commentToken() || this.heredocToken() || this.tagToken() || this.stringToken() || this.numberToken() || this.regexToken() || this.jsToken() || this.literalToken() || 0;
		};
		
		Lexer.prototype.moveCaret = function (i){
			return this._loc += i;
		};
		
		Lexer.prototype.context = function (){
			return this._ends[this._ends.length - 1];
		};
		
		Lexer.prototype.inContext = function (key){
			var o = this._contexts[this._contexts.length - 1];
			return o && o[key];
		};
		
		Lexer.prototype.pushEnd = function (val){
			// console.log "pushing end",val
			this._ends.push(val);
			this._contexts.push(null);
			this._end = val;
			this.refreshScope();
			return this;
		};
		
		Lexer.prototype.popEnd = function (val){
			this._ends.pop();
			this._contexts.pop();
			this._end = this._ends[this._ends.length - 1];
			this.refreshScope();
			return this;
		};
		
		Lexer.prototype.refreshScope = function (){
			var ctx0 = this._ends[this._ends.length - 1];
			var ctx1 = this._ends[this._ends.length - 2];
			return this._inTag = ctx0 == 'TAG_END' || (ctx1 == 'TAG_END' && ctx0 == 'OUTDENT');
		};
		
		
		
		Lexer.prototype.queueScope = function (val){
			// console.log("pushing scope {val} - {@indents} {@indents:length}")
			// @scopes.push(val) # no no
			this._scopes[this._indents.length] = val;
			return this;
		};
		
		Lexer.prototype.popScope = function (val){
			this._scopes.pop();
			return this;
		};
		
		Lexer.prototype.getScope = function (){
			return this._scopes[this._indents.length - 1];
		};
		
		Lexer.prototype.scope = function (sym,opts){
			var len = this._ends.push(this._end = sym);
			this._contexts.push(opts || null);
			return sym;
		};
		
		
		Lexer.prototype.closeSelector = function (){
			if (this._end == '%') {
				this.token('SELECTOR_END','%',0);
				return this.pair('%');
			};
		};
		
		
		Lexer.prototype.openDef = function (){
			return this.pushEnd('DEF');
		};
		
		
		Lexer.prototype.closeDef = function (){
			if (this.context() == 'DEF') {
				var prev = last(this._tokens);
				// console.log "close def {prev}"
				// console.log('closeDef with last>',prev)
				if (tT(prev) == 'DEF_FRAGMENT') {
					true;
				} else if (tT(prev) == 'TERMINATOR') {
					// console.log "here?!??"
					var n = this._tokens.pop();
					// console.log n
					this.token('DEF_BODY','DEF_BODY',0);
					// token('TERMINATOR', '',0) unless n.@value.indexOf('//') >= 0
					this._tokens.push(n);
				} else {
					this.token('DEF_BODY','DEF_BODY',0);
				};
				
				this.pair('DEF');
			};
			return;
		};
		
		Lexer.prototype.tagContextToken = function (){
			var match;
			if (this._chunk[0] == '#') {
				// console.log('found id # in tagContextToken')
				this.token('#','#',1);
				return 1;
			};
			
			if (match = TAG_ATTR.exec(this._chunk)) {
				// console.log 'TAG_SDDSATTR IN tokid',match
				// var prev = last @tokens
				// if the prev is a terminator, we dont really need to care?
				if (this._lastTyp != 'TAG_NAME') {
					if (this._lastTyp == 'TERMINATOR') {
						// console.log('prev was terminator -- drop it?')
						true;
					} else {
						this.token(",",",");
					};
				};
				
				var l = match[0].length;
				
				this.token('TAG_ATTR',match[1],l - 1); // add to loc?
				this._loc += l - 1;
				this.token('=','=',1);
				return l;
			};
			return 0;
		};
		
		Lexer.prototype.tagDefContextToken = function (){
			// console.log "tagContextToken"
			var match;
			if (match = TAG_TYPE.exec(this._chunk)) {
				this.token('TAG_TYPE',match[0],match[0].length);
				return match[0].length;
			};
			
			if (match = TAG_ID.exec(this._chunk)) {
				var input = match[0];
				this.token('TAG_ID',input,input.length);
				return input.length;
			};
			
			return 0;
		};
		
		
		Lexer.prototype.tagToken = function (){
			var match, ary;
			if (!(match = TAG.exec(this._chunk))) { return 0 };
			var ary = iter$(match);var input = ary[0],type = ary[1],identifier = ary[2];
			
			if (type == '<') {
				this.token('TAG_START','<',1);
				this.pushEnd(INVERSES.TAG_START);
				
				if (match = TAG_TYPE.exec(this._chunk.substr(1,40))) {
					// special case should probably be handled in AST
					if (match[0] != 'self') {
						this.token('TAG_TYPE',match[0],match[0].length,1);
						return input.length + match[0].length;
					};
				};
				
				if (identifier) {
					if (identifier.substr(0,1) == '{') {
						return type.length;
					} else {
						this.token('TAG_NAME',input.substr(1),0);
					};
				};
			};
			
			return input.length;
		};
		
		
		Lexer.prototype.selectorToken = function (){
			var ary;
			var match;
			
			// special handling if we are in this context
			if (this._end == '%') {
				var chr = this._chunk.charAt(0);
				var open = this.inContext('open');
				
				// should add for +, ~ etc
				// should maybe rather look for the correct type of character?
				
				if (open && (chr == ' ' || chr == '\n' || chr == ',' || chr == '+' || chr == '~' || chr == ')' || chr == ']')) {
					// console.log "close this selector directly"
					this.token('SELECTOR_END','%',0);
					this.pair('%');
					return 0;
				};
				
				if (match = SELECTOR_COMBINATOR.exec(this._chunk)) {
					// spaces between? -- include the whole
					this.token('SELECTOR_COMBINATOR',match[1] || " ",match[0].length);
					return match[0].length;
				} else if (match = SELECTOR_PART.exec(this._chunk)) {
					var type = match[1];
					var id = match[2];
					
					switch (type) {
						case '.':
							tokid = 'SELECTOR_CLASS';break;
						
						case '#':
							tokid = 'SELECTOR_ID';break;
						
						case ':':
							tokid = 'SELECTOR_PSEUDO_CLASS';break;
						
						case '::':
							tokid = 'SELECTOR_PSEUDO_CLASS';break;
						
						default:
						
							var tokid = 'SELECTOR_TAG';
					
					};
					
					this.token(tokid,match[2],match[0].length);
					return match[0].length;
				} else if (chr == '[') {
					this.token('[','[',1);
					this.pushEnd(']');
					if (match = SELECTOR_ATTR.exec(this._chunk)) {
						// fuck this length shit
						var idoffset = match[0].indexOf(match[1]);
						var opoffset = match[0].indexOf(match[2]);
						this.token('IDENTIFIER',match[1],match[1].length,idoffset);
						this.token('SELECTOR_ATTR_OP',match[2],match[2].length,opoffset);
						return match[0].length;
					};
					return 1;
				} else if (chr == '|') {
					var tok = this._tokens[this._tokens.length - 1];
					tTs(tok,'SELECTOR_NS');
					// tok[0] = 'SELECTOR_NS' # FIX
					return 1;
				} else if (chr == ',') {
					this.token('SELECTOR_GROUP',',',1);
					return 1;
				} else if (chr == '*') {
					this.token('UNIVERSAL_SELECTOR','*',1);
					return 1;
				} else if (chr == ')') {
					this.pair('%');
					this.token('SELECTOR_END',')',1);
					return 1;
				} else if (idx$(chr,[')','}',']','']) >= 0) {
					this.pair('%');
					return 0;
				};
			};
			
			if (!(match = SELECTOR.exec(this._chunk))) { return 0 };
			var ary = iter$(match);var input = ary[0],id = ary[1],kind = ary[2];
			
			// this is a closed selector
			if (kind == '(') {
				// token '(','('
				this.token('SELECTOR_START',id,id.length + 1);
				// self.pushEnd(')') # are we so sure about this?
				this.pushEnd('%');
				
				// @ends.push ')'
				// @ends.push '%'
				return id.length + 1;
			} else if (id == '%') {
				// we are already scoped in on a selector
				if (this.context() == '%') { return 1 };
				this.token('SELECTOR_START',id,id.length);
				// this is a separate - scope. Full selector should rather be $, and keep the single selector as %
				
				this.scope('%',{open: true});
				// @ends.push '%'
				// make sure a terminator breaks out
				return id.length;
			} else {
				return 0;
			};
		};
		
		// is this really needed? Should be possible to
		// parse the identifiers and = etc i jison?
		// what is special about methodNameToken? really?
		Lexer.prototype.methodNameToken = function (){
			// we can optimize this by after a def simply
			// fetching all the way after the def until a space or (
			// and then add this to the def-token itself (as with fragment)
			if (this._chunk.charAt(0) == ' ') { return 0 };
			
			var match;
			
			if (this._end == ')') {
				var outerctx = this._ends[this._ends.length - 2];
				// weird assumption, no?
				// console.log 'context is inside!!!'
				if (outerctx == '%' && (match = TAG_ATTR.exec(this._chunk))) {
					this.token('TAG_ATTR_SET',match[1]);
					return match[0].length;
				};
			};
			
			if (!(match = METHOD_IDENTIFIER.exec(this._chunk))) {
				return 0;
			};
			// var prev = last @tokens
			var length = match[0].length;
			
			var id = match[0];
			var ltyp = this._lastTyp;
			var typ = 'IDENTIFIER';
			var pre = id.charAt(0);
			var space = false;
			
			var m4 = match[4]; // might be out of bounds? should rather check charAt
			// drop match 4??
			
			// should this not quit here in practically all cases?
			if (!((ltyp == '.' || ltyp == 'DEF') || (m4 == '!' || m4 == '?') || match[5])) {
				return 0;
			};
			
			// again, why?
			if (id == 'self' || id == 'this' || id == 'super') { // in ['SELF','THIS']
				return 0;
			};
			
			if (id == 'new') {
				typ = 'NEW';
			};
			
			if (id == '...' && [',','(','CALL_START','BLOCK_PARAM_START','PARAM_START'].indexOf(ltyp) >= 0) {
				return 0;
			};
			
			if (id == '|') {
				// hacky way to implement this
				// with new lexer we'll use { ... } instead, and assume object-context,
				// then go back and correct when we see the context is invalid
				if (ltyp == '(' || ltyp == 'CALL_START') {
					this.token('DO','DO',0);
					this.pushEnd('|');
					// @ends.push '|'
					this.token('BLOCK_PARAM_START',id,1);
					return length;
				} else if (ltyp == 'DO' || ltyp == '{') {
					// @ends.push '|'
					this.pushEnd('|');
					this.token('BLOCK_PARAM_START',id,1);
					return length;
				} else if (this._ends[this._ends.length - 1] == '|') {
					this.token('BLOCK_PARAM_END','|',1);
					this.pair('|');
					return length;
				} else {
					return 0;
				};
			};
			
			// whaat?
			// console.log("method identifier",id)
			if ((['&','^','<<','<<<','>>'].indexOf(id) >= 0 || (id == '|' && this.context() != '|'))) {
				return 0;
			};
			
			if (OP_METHODS.indexOf(id) >= 0) {
				space = true;
			};
			
			// not even anything we should use?!?
			if (pre == '@') {
				typ = 'IVAR';
			} else if (pre == '$') {
				true;
				// typ = 'GVAR'
			} else if (pre == '#') {
				typ = 'TAGID';
			} else if (CONST_IDENTIFIER.test(pre) || id == 'require' || id == 'global' || id == 'exports') {
				// really? seems very strange
				// console.log('global!!',typ,id)
				typ = 'CONST';
			};
			
			// what is this really for?
			if (match[5] && ['IDENTIFIER','CONST','GVAR','CVAR','IVAR','SELF','THIS',']','}',')','NUMBER','STRING','IDREF'].indexOf(ltyp) >= 0) {
				this.token('.','.',0);
			};
			
			this.token(typ,id,length);
			
			if (space) {
				this._last.spaced = true;
			};
			
			return length;
		};
		
		
		Lexer.prototype.inTag = function (){
			var len = this._ends.length;
			if (len > 0) {
				var ctx0 = this._ends[len - 1];
				var ctx1 = len > 1 ? (this._ends[len - 2]) : (ctx0);
				return ctx0 == 'TAG_END' || (ctx1 == 'TAG_END' && ctx0 == 'OUTDENT');
			};
			return false;
		};
		
		Lexer.prototype.isKeyword = function (id){
			if ((id == 'attr' || id == 'prop')) {
				var scop = this.getScope();
				var incls = scop == 'CLASS' || scop == 'TAG';
				// var scopes = @indents.map(|ind,i| @scopes[i] or 'NONE')
				// console.log "id is prop: {scopes.join(" -> ")} | {@indents.join(" -> ")}"
				if (incls) { return true };
			};
			
			return ALL_KEYWORDS.indexOf(id) >= 0;
		};
		
		// Matches identifying literals: variables, keywords, method names, etc.
		// Check to ensure that JavaScript reserved words aren't being used as
		// identifiers. Because Imba reserves a handful of keywords that are
		// allowed in JavaScript, we're careful not to tokid them as keywords when
		// referenced as property names here, so you can still do `jQuery.is()` even
		// though `is` means `===` otherwise.
		Lexer.prototype.identifierToken = function (){
			var ary;
			var match;
			
			var ctx0 = this._ends[this._ends.length - 1];
			var ctx1 = this._ends[this._ends.length - 2];
			var innerctx = ctx0;
			var typ;
			var reserved = false;
			
			var addLoc = false;
			var inTag = ctx0 == 'TAG_END' || (ctx1 == 'TAG_END' && ctx0 == 'OUTDENT');
			
			// console.log ctx1,ctx0
			
			if (inTag && (match = TAG_ATTR.exec(this._chunk))) {
				// console.log 'TAG_ATTR IN tokid',match
				// var prev = last @tokens
				// if the prev is a terminator, we dont really need to care?
				if (this._lastTyp != 'TAG_NAME') {
					if (this._lastTyp == 'TERMINATOR') {
						// console.log('prev was terminator -- drop it?')
						true;
					} else {
						this.token(",",",");
					};
				};
				
				var l = match[0].length;
				
				this.token('TAG_ATTR',match[1],l - 1); // add to loc?
				this._loc += l - 1;
				this.token('=','=',1);
				return l;
			};
			
			// see if this is a plain object-key
			// way too much logic going on here?
			// the ast should normalize whether keys
			// are accessable as keys or strings etc
			if (match = OBJECT_KEY.exec(this._chunk)) {
				var id = match[1];
				typ = 'IDENTIFIER';
				
				// FIXME loc of key includes colon
				// moveCaret(id:length)
				// console.log "ok"
				if (true) {
					// console.log "got here? {match}"
					this.token(typ,id,id.length);
					this.moveCaret(id.length);
					this.token(':',':',match[3].length);
					this.moveCaret(-id.length);
					// moveCaret(match[3]:length)
					return match[0].length;
				};
				
				// moveCaret(match[2]:length)
				// return 0
				// console.log match[3]:length
				this.token(typ,id,match[0].length);
				this.token(':',':',1);
				return match[0].length;
			};
			
			if (!(match = IDENTIFIER.exec(this._chunk))) {
				return 0;
			};
			
			var ary = iter$(match);var input = ary[0],id = ary[1],typ = ary[2],m3 = ary[3],m4 = ary[4],colon = ary[5];
			var idlen = id.length;
			
			// What is the logic here?
			if (id == 'own' && this.lastTokenType() == 'FOR') {
				this.token('OWN',id,id.length);
				return id.length;
			};
			
			var prev = last(this._tokens);
			var lastTyp = this._lastTyp;
			
			// should we force this to be an identifier even if it is a reserved word?
			// this should only happen for when part of object etc
			// will prev ever be @???
			var forcedIdentifier;
			
			// again
			forcedIdentifier = colon || lastTyp == '.' || lastTyp == '?.'; // in ['.', '?.'
			
			
			// temp hack! need to solve for other keywords etc as well
			// problem appears with ternary conditions.
			
			// well -- it should still be an indentifier if in object?
			// forcedIdentifier = no if id in ['undefined','break']
			
			if (colon && lastTyp == '?') { forcedIdentifier = false }; // for ternary
			
			// if we are not at the top level? -- hacky
			if (id == 'tag' && this._chunk.indexOf("tag(") == 0) { // @chunk.match(/^tokid\(/)
				forcedIdentifier = true;
			};
			
			var isKeyword = false;
			
			// console.log "match",match
			// console.log "typ is {typ}"
			// little reason to check for this right here? but I guess it is only a simple check
			if (typ == '$' && ARGVAR.test(id)) { // id.match(/^\$\d$/)
				// console.log "TYP $"
				if (id == '$0') {
					typ = 'ARGUMENTS';
				} else {
					typ = 'ARGVAR';
					id = id.substr(1);
				};
			} else if (typ == '@') {
				typ = 'IVAR';
				
				// id:reserved = yes if colon
			} else if (typ == '#') {
				// we are trying to move to generic tokens,
				// so we are starting to splitting up the symbols and the items
				// we'll see if that works
				typ = 'IDENTIFIER';
				this.token('#','#');
				id = id.substr(1);
			} else if (typ == '@@') {
				typ = 'CVAR';
			} else if (typ == '$' && !(colon)) {
				typ = 'IDENTIFIER';
				// typ = 'GVAR'
			} else if (CONST_IDENTIFIER.test(id) || id == 'require' || id == 'global' || id == 'exports') {
				// thous should really be handled by the ast instead
				typ = 'CONST';
			} else if (id == 'elif') {
				this.token('ELSE','elif',id.length);
				this.token('IF','if');
				return id.length;
			} else {
				typ = 'IDENTIFIER';
			};
			
			
			
			// this catches all 
			if (!(forcedIdentifier) && (isKeyword = this.isKeyword(id))) {
				// (id in JS_KEYWORDS or id in IMBA_KEYWORDS)
				typ = id.toUpperCase();
				addLoc = true;
				
				// clumsy - but testing performance
				if (typ == 'YES') {
					typ = 'TRUE';
				} else if (typ == 'NO') {
					typ = 'FALSE';
				} else if (typ == 'NIL') {
					typ = 'NULL';
				} else if (typ == 'VAR') {
					if (this._lastVal == 'export') {
						tTs(prev,'EXPORT');
					};
				} else if (typ == 'IF' || typ == 'ELSE' || typ == 'TRUE' || typ == 'FALSE' || typ == 'NULL') {
					true;
				} else if (typ == 'TAG') {
					this.pushEnd('TAG');
					// @ends.push('TAG')
				} else if (typ == 'DEF') {
					// should probably shift context and optimize this
					this.openDef();
				} else if (typ == 'DO') {
					if (this.context() == 'DEF') this.closeDef();
				} else if (typ == 'WHEN' && LINE_BREAK.indexOf(this.lastTokenType()) >= 0) {
					typ = 'LEADING_WHEN';
				} else if (typ == 'FOR') {
					this._seenFor = true;
				} else if (typ == 'UNLESS') {
					typ = 'IF'; // WARN
				} else if (UNARY.indexOf(typ) >= 0) {
					typ = 'UNARY';
				} else if (RELATION.indexOf(typ) >= 0) {
					if (typ != 'INSTANCEOF' && typ != 'ISA' && this._seenFor) {
						typ = 'FOR' + typ; // ?
						this._seenFor = false;
					} else {
						typ = 'RELATION';
						if (String(this.value()) == '!') {
							this._tokens.pop(); // is fucked up??!
							// WARN we need to keep the loc, no?
							id = '!' + id;
						};
					};
				};
			};
			
			if (id == 'super') {
				typ = 'SUPER';
			};
			
			// do we really want to check this here
			if (!(forcedIdentifier)) {
				// should already have dealt with this
				
				if (isKeyword && IMBA_ALIASES.indexOf(id) >= 0) { id = IMBA_ALIAS_MAP[id] };
				// these really should not go here?!?
				switch (id) {
					case '!':
						typ = 'UNARY';break;
					
					case '==':
					case '!=':
					case '===':
					case '!==':
						typ = 'COMPARE';break;
					
					case '&&':
					case '||':
						typ = 'LOGIC';break;
					
					case 'break':
					case 'continue':
					case 'debugger':
					case 'arguments':
						typ = id.toUpperCase();break;
				
				};
			};
			
			// prev = last @tokens
			var len = input.length;
			
			// should be strict about the order, check this manually instead
			if (typ == 'CLASS' || typ == 'DEF' || typ == 'TAG') {
				this.queueScope(typ);
				
				var i = this._tokens.length;
				
				while (i){
					prev = this._tokens[--i];
					var ctrl = "" + tV(prev);
					// console.log("ctrl is {ctrl}")
					// need to coerce to string because of stupid CS ===
					// console.log("prev is",prev[0],prev[1])
					if (idx$(ctrl,IMBA_CONTEXTUAL_KEYWORDS) >= 0) {
						tTs(prev,ctrl.toUpperCase());
						// prev[0] = ctrl.toUpperCase # FIX
					} else {
						break;
					};
				};
			} else if (typ == 'IF') {
				this.queueScope(typ);
			} else if (typ == 'IMPORT') {
				// could manually parse the whole ting here?
				this.pushEnd('IMPORT');
				// @ends.push 'IMPORT'
			} else if (id == 'from' && ctx0 == 'IMPORT') {
				typ = 'FROM';
				this.pair('IMPORT');
			} else if (id == 'as' && ctx0 == 'IMPORT') {
				typ = 'AS';
				this.pair('IMPORT');
			};
			
			if (typ == 'IDENTIFIER') {
				// see if previous was catch -- belongs in rewriter?
				if (lastTyp == 'CATCH') {
					typ = 'CATCH_VAR';
				};
			};
			
			if (colon) {
				this.token(typ,id,idlen);
				this.moveCaret(idlen);
				// console.log "add colon?"
				this.token(':',':',colon.length);
				this.moveCaret(-idlen);
			} else {
				this.token(typ,id,idlen);
			};
			
			return len;
		};
		
		// Matches numbers, including decimals, hex, and exponential notation.
		// Be careful not to interfere with ranges-in-progress.
		Lexer.prototype.numberToken = function (){
			var binaryLiteral;
			var match,number,lexedLength;
			
			if (!(match = NUMBER.exec(this._chunk))) { return 0 };
			
			number = match[0];
			lexedLength = number.length;
			
			if (binaryLiteral = /0b([01]+)/.exec(number)) {
				
				number = "" + parseInt(binaryLiteral[1],2);
			};
			
			var prev = last(this._tokens);
			
			if (match[0][0] == '.' && prev && !prev.spaced && ['IDENTIFIER',')','}',']','NUMBER'].indexOf(tT(prev)) >= 0) {
				// console.log "got here"
				this.token(".",".");
				number = number.substr(1);
			};
			
			
			this.token('NUMBER',number,lexedLength);
			return lexedLength;
		};
		
		Lexer.prototype.symbolToken = function (){
			var match,symbol,prev;
			
			if (!(match = SYMBOL.exec(this._chunk))) { return 0 };
			symbol = match[0].substr(1);
			prev = last(this._tokens);
			
			// is this a property-access?
			// should invert this -- only allow when prev IS .. 
			
			// : should be a token itself, with a specification of spacing (LR,R,L,NONE)
			
			// FIX
			if (prev && !prev.spaced && idx$(tT(prev),['(','{','[','.','CALL_START','INDEX_START',',','=','INDENT','TERMINATOR']) == -1) {
				this.token('.:',':',1);
				var sym = symbol.split(/[\:\\\/]/)[0]; // really?
				// token 'SYMBOL', "'#{symbol}'"
				this.token('IDENTIFIER',sym,sym.length,1);
				return (sym.length + 1);
			} else {
				// token 'SYMBOL', "'#{symbol}'"
				this.token('SYMBOL',symbol,match[0].length);
				return match[0].length;
			};
		};
		
		Lexer.prototype.escapeStr = function (str,heredoc,q){
			str = str.replace(MULTILINER,(heredoc ? ('\\n') : ('')));
			if (q) {
				var r = RegExp(("\\\\[" + q + "]"),"g");
				str = str.replace(r,q);
				str = str.replace(RegExp(("" + q),"g"),'\\$&');
			};
			return str;
			
			// str = str.replace(MULTILINER, '\\n')
			// str = str.replace(/\t/g, '\\t')
		};
		// Matches strings, including multi-line strings. Ensures that quotation marks
		// are balanced within the string's contents, and within nested interpolations.
		Lexer.prototype.stringToken = function (){
			var match,string;
			
			switch (this._chunk.charAt(0)) {
				case "'":
					if (!(match = SIMPLESTR.exec(this._chunk))) { return 0 };
					string = match[0];
					this.token('STRING',this.escapeStr(string),string.length);
					// token 'STRING', (string = match[0]).replace(MULTILINER, '\\\n'), string:length
					break;
				
				case '"':
					if (!(string = this.balancedString(this._chunk,'"'))) { return 0 };
					// what about tripe quoted strings?
					
					if (string.indexOf('{') >= 0) {
						var len = string.length;
						// if this has no interpolation?
						// we are now messing with locations - beware
						this.token('STRING_START',string.charAt(0),1);
						this.interpolateString(string.slice(1,-1));
						this.token('STRING_END',string.charAt(len - 1),1,string.length - 1);
					} else {
						len = string.length;
						// string = string.replace(MULTILINER, '\\\n')
						this.token('STRING',this.escapeStr(string),len);
					};
					break;
				
				default:
				
					return 0;
			
			};
			
			this.moveHead(string);
			return string.length;
		};
		
		// Matches heredocs, adjusting indentation to the correct level, as heredocs
		// preserve whitespace, but ignore indentation to the left.
		Lexer.prototype.heredocToken = function (){
			var match,heredoc,quote,doc;
			
			if (!(match = HEREDOC.exec(this._chunk))) { return 0 };
			
			heredoc = match[0];
			quote = heredoc.charAt(0);
			doc = this.sanitizeHeredoc(match[2],{quote: quote,indent: null});
			// console.log "found heredoc {match[0]:length} {doc:length}"
			
			if (quote == '"' && doc.indexOf('{') >= 0) {
				var open = match[1];
				// console.log doc.substr(0,3),match[1]
				this.token('STRING_START',open,open.length);
				this.interpolateString(doc,{heredoc: true,offset: open.length,quote: quote});
				this.token('STRING_END',open,open.length,heredoc.length - open.length);
			} else {
				this.token('STRING',this.makeString(doc,quote,true),0);
			};
			
			this.moveHead(heredoc);
			return heredoc.length;
		};
		
		// Matches and consumes comments.
		Lexer.prototype.commentToken = function (){
			var match,length,comment,indent,prev;
			
			var typ = 'HERECOMMENT';
			
			if (match = INLINE_COMMENT.exec(this._chunk)) { // .match(INLINE_COMMENT)
				// console.log "match inline comment"
				length = match[0].length;
				indent = match[1];
				comment = match[2];
				
				prev = last(this._tokens);
				var pt = prev && tT(prev);
				var note = '//' + comment.substr(1);
				
				if (this._last && this._last.spaced) {
					note = ' ' + note;
					// console.log "the previous node was SPACED"
				};
				// console.log "comment {note} - indent({indent}) - {length} {comment:length}"
				
				if ((pt && pt != 'INDENT' && pt != 'TERMINATOR') || !(pt)) {
					// console.log "skip comment"
					// token 'INLINECOMMENT', comment.substr(2)
					// console.log "adding as terminator"
					this.token('TERMINATOR',note,length); // + '\n'
				} else {
					// console.log "add comment ({note})"
					if (pt == 'TERMINATOR') {
						tVs(prev,tV(prev) + note);
						// prev[1] += note
					} else if (pt == 'INDENT') {
						// console.log "adding comment to INDENT: {note}" # why not add directly here?
						this.addLinebreaks(1,note);
					} else {
						// console.log "comment here"
						// should we ever get here?
						this.token(typ,comment.substr(2),length); // are we sure?
					};
				};
				
				return length; // disable now while compiling
			};
			
			// should use exec?
			if (!(match = COMMENT.exec(this._chunk))) { return 0 };
			
			comment = match[0];
			var here = match[1];
			
			if (here) {
				this.token('HERECOMMENT',this.sanitizeHeredoc(here,{herecomment: true,indent: Array(this._indent + 1).join(' ')}),comment.length);
				this.token('TERMINATOR','\n');
			} else {
				this.token('HERECOMMENT',comment,comment.length);
				this.token('TERMINATOR','\n'); // auto? really?
			};
			
			this.moveHead(comment);
			return comment.length;
		};
		
		// Matches JavaScript interpolated directly into the source via backticks.
		Lexer.prototype.jsToken = function (){
			var match,script;
			
			if (!(this._chunk.charAt(0) == '`' && (match = JSTOKEN.exec(this._chunk)))) { return 0 };
			this.token('JS',(script = match[0]).slice(1,-1));
			return script.length;
		};
		
		// Matches regular expression literals. Lexing regular expressions is difficult
		// to distinguish from division, so we borrow some basic heuristics from
		// JavaScript and Ruby.
		Lexer.prototype.regexToken = function (){
			var ary;
			var match,length,prev;
			
			if (this._chunk.charAt(0) != '/') { return 0 };
			if (match = HEREGEX.exec(this._chunk)) {
				length = this.heregexToken(match);
				this.moveHead(match[0]);
				return length;
			};
			
			prev = last(this._tokens);
			// FIX
			if (prev && (idx$(tT(prev),(prev.spaced ? (
				NOT_REGEX
			) : (
				NOT_SPACED_REGEX
			))) >= 0)) { return 0 };
			if (!(match = REGEX.exec(this._chunk))) { return 0 };
			var ary = iter$(match);var m = ary[0],regex = ary[1],flags = ary[2];
			
			// FIXME
			// if regex[..1] is '/*'
			//	error 'regular expressions cannot begin with `*`'
			
			if (regex == '//') {
				regex = '/(?:)/';
			};
			
			this.token('REGEX',("" + regex + flags),m.length);
			return m.length;
		};
		
		// Matches multiline extended regular expressions.
		// The escaping should rather happen in AST - possibly as an additional flag?
		Lexer.prototype.heregexToken = function (match){
			var ary;
			var ary = iter$(match);var heregex = ary[0],body = ary[1],flags = ary[2];
			
			if (0 > body.indexOf('#{')) {
				
				var re = body.replace(HEREGEX_OMIT,'').replace(/\//g,'\\/');
				
				if (re.match(/^\*/)) {
					this.error('regular expressions cannot begin with `*`');
				};
				
				this.token('REGEX',("/" + (re || '(?:)') + "/" + flags),heregex.length);
				return heregex.length;
			};
			
			// use more basic regex type
			
			this.token('CONST','RegExp');
			this._tokens.push(T.token('CALL_START','(',0));
			var tokens = [];
			
			for (var i = 0, items = iter$(this.interpolateString(body,{regex: true})), len = items.length, pair; i < len; i++) {
				
				pair = items[i];
				var tok = tT(pair); // FIX
				var value = tV(pair); // FIX
				
				if (tok == 'TOKENS') {
					// FIXME what is this?
					tokens.push.apply(tokens,value);
				} else {
					if (!(value)) {
						console.log("what??");
					};
					
					if (!(value = value.replace(HEREGEX_OMIT,''))) { continue; };
					
					value = value.replace(/\\/g,'\\\\');
					tokens.push(T.token('STRING',this.makeString(value,'"',true),0)); // FIX
				};
				
				tokens.push(T.token('+','+',0)); // FIX
			};
			
			tokens.pop();
			
			// FIX
			if (!(tokens[0] && tT(tokens[0]) == 'STRING')) {
				// FIX
				this._tokens.push(T.token('STRING','""'),T.token('+','+'));
			};
			
			this._tokens.push.apply(this._tokens,tokens); // what is this?
			// FIX
			
			if (flags) {
				this._tokens.push(T.token(',',',',0));
				this._tokens.push(T.token('STRING','"' + flags + '"',0));
			};
			
			this.token(')',')',0);
			
			return heregex.length;
		};
		
		// Matches newlines, indents, and outdents, and determines which is which.
		// If we can detect that the current line is continued onto the the next line,
		// then the newline is suppressed:
		//
		//     elements
		//       .each( ... )
		//       .map( ... )
		//
		// Keeps track of the level of indentation, because a single outdent token
		// can close multiple indents, so we need to know how far in we happen to be.
		Lexer.prototype.lineToken = function (){
			var match;
			
			if (!(match = MULTI_DENT.exec(this._chunk))) { return 0 };
			
			var indent = match[0];
			var brCount = this.moveHead(indent);
			
			this._seenFor = false;
			// reset column as well?
			
			var prev = last(this._tokens,1);
			var whitespace = indent.substr(indent.lastIndexOf('\n') + 1);
			var size = whitespace.length;
			var noNewlines = this.unfinished();
			
			if ((/^\n#\s/).test(this._chunk)) {
				this.addLinebreaks(1);
				return 0;
			};
			
			if (size > 0) {
				if (!this._indentStyle) {
					this._opts.indent = this._indentStyle = whitespace;
				};
				
				var indentSize = 0;
				var offset = 0;
				
				while (true){
					var idx = whitespace.indexOf(this._indentStyle,offset);
					if (idx == offset) {
						indentSize++;
						offset += this._indentStyle.length;
					} else if (offset == whitespace.length) {
						break;
					} else {
						// workaround to report correct location
						this._loc += indent.length - whitespace.length;
						this.token('INDENT',whitespace,whitespace.length);
						return this.error('inconsistent indentation');
					};
				};
				
				size = indentSize;
			};
			
			
			if (size - this._indebt == this._indent) {
				if (noNewlines) {
					this.suppressNewlines();
				} else {
					this.newlineToken(brCount);
				};
				return indent.length;
			};
			
			if (size > this._indent) {
				if (noNewlines) {
					this._indebt = size - this._indent;
					this.suppressNewlines();
					return indent.length;
				};
				
				if (this.inTag()) {
					// console.log "indent inside tokid?!?"
					// @indebt = size - @indent
					// suppressNewlines()
					return indent.length;
				};
				
				
				var diff = size - this._indent + this._outdebt;
				this.closeDef();
				
				var immediate = last(this._tokens);
				
				if (immediate && tT(immediate) == 'TERMINATOR') {
					tTs(immediate,'INDENT');
					immediate._meta || (immediate._meta = {pre: tV(immediate),post: ''});
					
					// should rather add to meta somehow?!?
					// tVs(immediate,tV(immediate) + '%|%') # crazy
				} else {
					this.token('INDENT',"" + diff,0);
				};
				
				// console.log "indenting", prev, last(@tokens,1)
				// if prev and prev[0] == 'TERMINATOR'
				//   console.log "terminator before indent??"
				
				// check for comments as well ?
				
				this._indents.push(diff);
				this.pushEnd('OUTDENT');
				// @ends.push 'OUTDENT'
				this._outdebt = this._indebt = 0;
				this.addLinebreaks(brCount);
			} else {
				this._indebt = 0;
				this.outdentToken(this._indent - size,noNewlines,brCount);
				this.addLinebreaks(brCount - 1);
				// console.log "outdent",noNewlines,tokid()
			};
			
			this._indent = size;
			return indent.length;
		};
		
		// Record an outdent token or multiple tokens, if we happen to be moving back
		// inwards past several recorded indents.
		Lexer.prototype.outdentToken = function (moveOut,noNewlines,newlineCount){
			// here we should also take care to pop / reset the scope-body
			// or context-type for indentation 
			var dent = 0;
			while (moveOut > 0){
				var len = this._indents.length - 1;
				if (this._indents[len] == undefined) {
					moveOut = 0;
				} else if (this._indents[len] == this._outdebt) {
					moveOut -= this._outdebt;
					this._outdebt = 0;
				} else if (this._indents[len] < this._outdebt) {
					this._outdebt -= this._indents[len];
					moveOut -= this._indents[len];
				} else {
					dent = this._indents.pop() - this._outdebt;
					moveOut -= dent;
					this._outdebt = 0;
					
					if (!(noNewlines)) { this.addLinebreaks(1) };
					
					this.pair('OUTDENT');
					this.token('OUTDENT',"" + dent,0);
				};
			};
			
			if (dent) { this._outdebt -= moveOut };
			
			while (this.lastTokenValue() == ';'){
				this._tokens.pop();
			};
			
			if (!(this.lastTokenType() == 'TERMINATOR' || noNewlines)) { this.token('TERMINATOR','\n',0) };
			
			// capping scopes so they dont hang around 
			this._scopes.length = this._indents.length;
			
			var ctx = this.context();
			if (ctx == '%' || ctx == 'TAG') { this.pair(ctx) }; // really?
			this.closeDef();
			return this;
		};
		
		// Matches and consumes non-meaningful whitespace. tokid the previous token
		// as being "spaced", because there are some cases where it makes a difference.
		Lexer.prototype.whitespaceToken = function (){
			var match,nline,prev;
			if (!((match = WHITESPACE.exec(this._chunk)) || (nline = this._chunk.charAt(0) == '\n'))) { return 0 };
			prev = last(this._tokens);
			
			// FIX - why oh why?
			if (prev) {
				if (match) {
					prev.spaced = true;
					return match[0].length;
				} else {
					prev.newLine = true;
					return 0;
				};
			};
		};
		
		Lexer.prototype.addNewline = function (){
			return this.token('TERMINATOR','\n');
		};
		
		Lexer.prototype.moveHead = function (str){
			var br = count(str,'\n');
			return br;
		};
		
		
		Lexer.prototype.addLinebreaks = function (count,raw){
			var br;
			
			if (!(raw) && count == 0) { return this }; // no terminators?
			
			var prev = this._last;
			
			if (!(raw)) {
				if (count == 1) {
					br = '\n';
				} else if (count == 2) {
					br = '\n\n';
				} else if (count == 3) {
					br = '\n\n\n';
				} else {
					br = repeatString('\n',count);
				};
			};
			// FIX
			if (prev) {
				var t = prev._type; // @lastTyp
				var v = tV(prev);
				
				// we really want to add this
				if (t == 'INDENT') {
					// TODO we want to add to the indent
					// console.log "add the comment to the indent -- pre? {raw} {br}"
					
					var meta = prev._meta || (prev._meta = {pre: '',post: ''});
					meta.post += (raw || br);
					// tVs(v + (raw or br))
					return this;
				} else if (t == 'TERMINATOR') {
					// console.log "already exists terminator {br} {raw}"
					tVs(prev,v + (raw || br));
					return this;
				};
			};
			
			this.token('TERMINATOR',br,0);
			return;
		};
		
		// Generate a newline token. Consecutive newlines get merged together.
		Lexer.prototype.newlineToken = function (lines){
			// console.log "newlineToken"
			while (this.lastTokenValue() == ';'){
				console.log("pop token",this._tokens[this._tokens.length - 1]);
				this._tokens.pop();
			};
			
			this.addLinebreaks(lines);
			
			var ctx = this.context();
			// WARN now import cannot go over multiple lines
			if (ctx == 'TAG' || ctx == 'IMPORT') { this.pair(ctx) };
			this.closeDef(); // close def -- really?
			return this;
		};
		
		// Use a `\` at a line-ending to suppress the newline.
		// The slash is removed here once its job is done.
		Lexer.prototype.suppressNewlines = function (){
			if (this.value() == '\\') { this._tokens.pop() };
			return this;
		};
		
		// We treat all other single characters as a token. E.g.: `( ) , . !`
		// Multi-character operators are also literal tokens, so that Jison can assign
		// the proper order of operations. There are some symbols that we tokid specially
		// here. `;` and newlines are both treated as a `TERMINATOR`, we distinguish
		// parentheses that indicate a method call from regular parentheses, and so on.
		Lexer.prototype.literalToken = function (){
			var match,value;
			if (match = OPERATOR.exec(this._chunk)) {
				value = match[0];
				if (CODE.test(value)) this.tagParameters();
			} else {
				value = this._chunk.charAt(0);
			};
			
			var end1 = this._ends[this._ends.length - 1];
			var end2 = this._ends[this._ends.length - 2];
			
			var inTag = end1 == 'TAG_END' || end1 == 'OUTDENT' && end2 == 'TAG_END';
			
			var tokid = value;
			var prev = last(this._tokens);
			var pt = prev && tT(prev);
			var pv = prev && tV(prev);
			var length = value.length;
			
			// is this needed?
			if (value == '=' && prev) {
				
				if (pv == '||' || pv == '&&') { // in ['||', '&&']
					tTs(prev,'COMPOUND_ASSIGN');
					tVs(prev,pv + '=');
					// prev[0] = 'COMPOUND_ASSIGN'
					// prev[1] += '='
					return value.length;
				};
			};
			
			if (value == ';') {
				this._seenFor = false;
				tokid = 'TERMINATOR';
			} else if (value == '(' && inTag && pt != '=' && prev.spaced) { // FIXed
				// console.log 'spaced before ( in tokid'
				// FIXME - should rather add a special token like TAG_PARAMS_START
				this.token(',',',');
			} else if (value == '->' && inTag) {
				tokid = 'TAG_END';
				this.pair('TAG_END');
			} else if (value == '/>' && inTag) {
				tokid = 'TAG_END';
				this.pair('TAG_END');
			} else if (value == '>' && inTag) {
				tokid = 'TAG_END';
				this.pair('TAG_END');
			} else if (value == '>' && this.context() == 'DEF') {
				// console.log('picked up >!!')
				tokid = 'DEF_FRAGMENT';
				
				// elif value is 'TERMINATOR' and end1 is '%' 
				// 	closeSelector()
			} else if (value == 'TERMINATOR' && end1 == 'DEF') {
				this.closeDef();
			} else if (value == '&' && this.context() == 'DEF') {
				// console.log("okay!")
				tokid = 'BLOCK_ARG';
				// change the next identifier instead?
			} else if (value == '*' && this._chunk.charAt(1).match(/[A-Za-z\_\@\[]/) && (prev.spaced || [',','(','[','{','|','\n','\t'].indexOf(pv) >= 0)) {
				tokid = "SPLAT";
			} else if (value == '√') {
				tokid = 'SQRT';
			} else if (value == 'ƒ') {
				tokid = 'FUNC';
			} else if (idx$(value,MATH) >= 0) {
				tokid = 'MATH';
			} else if (idx$(value,COMPARE) >= 0) {
				tokid = 'COMPARE';
			} else if (idx$(value,COMPOUND_ASSIGN) >= 0) {
				tokid = 'COMPOUND_ASSIGN';
			} else if (idx$(value,UNARY) >= 0) {
				tokid = 'UNARY';
			} else if (idx$(value,SHIFT) >= 0) {
				tokid = 'SHIFT';
			} else if (idx$(value,LOGIC) >= 0) {
				tokid = 'LOGIC'; // or value is '?' and prev?:spaced 
			} else if (prev && !prev.spaced) {
				// need a better way to do these
				if (value == '(' && end1 == '%') {
					tokid = 'TAG_ATTRS_START';
				} else if (value == '(' && idx$(pt,CALLABLE) >= 0) {
					// not using this ???
					// prev[0] = 'FUNC_EXIST' if prev[0] is '?'
					tokid = 'CALL_START';
				} else if (value == '[' && idx$(pt,INDEXABLE) >= 0) {
					tokid = 'INDEX_START';
					if (pt == '?') { tTs(prev,'INDEX_SOAK') };
					// prev[0] = 'INDEX_SOAK' if prev[0] == '?'
				};
			};
			
			switch (value) {
				case '(':
				case '{':
				case '[':
					this.pushEnd(INVERSES[value]);break;
				
				case ')':
				case '}':
				case ']':
					this.pair(value);break;
			
			};
			
			// hacky rule to try to allow for tuple-assignments in blocks
			// if value is ',' and prev[0] is 'IDENTIFIER' and @tokens[@tokens:length - 2][0] in ['TERMINATOR','INDENT']
			//   # token "TUPLE", "tuple" # should rather insert it somewhere else, no?
			//   console.log("found comma")
			
			this.token(tokid,value,value.length);
			return value.length;
		};
		
		// Token Manipulators
		// ------------------
		
		// Sanitize a heredoc or herecomment by
		// erasing all external indentation on the left-hand side.
		Lexer.prototype.sanitizeHeredoc = function (doc,options){
			var match;
			var indent = options.indent;
			var herecomment = options.herecomment;
			
			if (herecomment) {
				if (HEREDOC_ILLEGAL.test(doc)) {
					this.error("block comment cannot contain '*/' starting");
				};
				if (doc.indexOf('\n') <= 0) { return doc };
			} else {
				var length_;while (match = HEREDOC_INDENT.exec(doc)){
					var attempt = match[1];
					if (indent == null || 0 < (length_ = attempt.length) && length_ < indent.length) {
						indent = attempt;
					};
				};
			};
			
			if (indent) { doc = doc.replace(RegExp(("\\n" + indent),"g"),'\n') };
			if (!(herecomment)) { doc = doc.replace(/^\n/,'') };
			return doc;
		};
		
		// A source of ambiguity in our grammar used to be parameter lists in function
		// definitions versus argument lists in function calls. Walk backwards, tokidging
		// parameters specially in order to make things easier for the parser.
		Lexer.prototype.tagParameters = function (){
			var tok;
			if (this.lastTokenType() != ')') { return this };
			var stack = [];
			var tokens = this._tokens;
			var i = tokens.length;
			
			tTs(tokens[--i],'PARAM_END');
			
			while (tok = tokens[--i]){
				var t = tT(tok);
				switch (t) {
					case ')':
						stack.push(tok);
						break;
					
					case '(':
					case 'CALL_START':
						if (stack.length) {
							stack.pop();
						} else if (t == '(') {
							tTs(tok,'PARAM_START');
							return this;
						} else {
							return this;
						};
						break;
				
				};
			};
			
			return this;
		};
		
		// Close up all remaining open blocks at the end of the file.
		Lexer.prototype.closeIndentation = function (){
			// ctx = context
			// pair(ctx) if ctx in ['%','DEF']
			this.closeDef();
			this.closeSelector();
			return this.outdentToken(this._indent,false,0);
		};
		
		// Matches a balanced group such as a single or double-quoted string. Pass in
		// a series of delimiters, all of which must be nested correctly within the
		// contents of the string. This method allows us to have strings within
		// interpolations within strings, ad infinitum.
		Lexer.prototype.balancedString = function (str,end){
			var match,letter,prev;
			
			// console.log 'balancing string!', str, end
			var stack = [end];
			var i = 0;
			
			// could it not happen here?
			while (i < (str.length - 1)){
				i++;
				letter = str.charAt(i);
				switch (letter) {
					case '\\':
						i++;
						continue;
						break;
					
					case end:
						stack.pop();
						if (!stack.length) {
							var v = str.slice(0,i + 1);
							return v;
						};
						end = stack[stack.length - 1];
						continue;
						break;
				
				};
				
				if (end == '}' && (letter == '"' || letter == "'")) {
					stack.push(end = letter);
				} else if (end == '}' && letter == '/' && (match = (HEREGEX.exec(str.slice(i)) || REGEX.exec(str.slice(i))))) {
					i += match[0].length - 1;
				} else if (end == '}' && letter == '{') {
					stack.push(end = '}');
				} else if (end == '"' && letter == '{') {
					stack.push(end = '}');
				};
				prev = letter;
			};
			
			if (!this._opts.silent) { return this.error(("missing " + (stack.pop()) + ", starting")) };
		};
		
		// Expand variables and expressions inside double-quoted strings using
		// Ruby-like notation for substitution of arbitrary expressions.
		//
		//     "Hello #{name.capitalize()}."
		//
		// If it encounters an interpolation, this method will recursively create a
		// new Lexer, tokenize the interpolated contents, and merge them into the
		// token stream.
		Lexer.prototype.interpolateString = function (str,options){
			// console.log "interpolate string"
			if(options === undefined) options = {};
			var heredoc = options.heredoc;
			var quote = options.quote;
			var regex = options.regex;
			var prefix = options.prefix;
			
			var startLoc = this._loc;
			var tokens = [];
			var pi = 0;
			var i = -1;
			var locOffset = options.offset || 1;
			var strlen = str.length;
			var letter;
			var expr;
			
			var isInterpolated = false;
			// out of bounds
			while (letter = str.charAt(i += 1)){
				if (letter == '\\') {
					i += 1;
					continue;
				};
				
				if (!(str.charAt(i) == '{' && (expr = this.balancedString(str.slice(i),'}')))) {
					continue;
				};
				
				isInterpolated = true;
				
				// these have no real sense of location or anything?
				if (pi < i) {
					// this is the prefix-string - before any item
					var tok = new Token('NEOSTRING',this.escapeStr(str.slice(pi,i),heredoc,quote),this._loc + pi + locOffset,i - pi);
					// tok.@loc = @loc + pi
					// tok.@len = i - pi + 2
					tokens.push(tok);
				};
				
				tokens.push(new Token('{{','{',this._loc + i + locOffset,1));
				
				var inner = expr.slice(1,-1);
				// console.log 'inner is',inner
				// remove leading spaces 
				// need to keep track of how much whitespace we dropped from the start
				inner = inner.replace(/^[^\n\S]+/,'');
				
				if (inner.length) {
					// we need to remember the loc we start at
					// console.log('interpolate from loc',@loc,i)
					// really? why not just add to the stack??
					// what about the added 
					// should share with the selector no?
					// console.log "tokenize inner parts of string",inner
					var spaces = 0;
					var offset = this._loc + i + (expr.length - inner.length) - 1;
					// why create a whole new lexer? Should rather reuse one
					// much better to simply move into interpolation mode where
					// we continue parsing until we meet unpaired }
					var nested = new Lexer().tokenize(inner,{inline: true,rewrite: false,loc: offset + locOffset});
					// console.log nested.pop
					
					if (nested[0] && tT(nested[0]) == 'TERMINATOR') {
						nested.shift();
					};
					
					if (nested.length) {
						tokens.push.apply(tokens,nested); // T.token('TOKENS',nested,0)
					};
				};
				
				// should rather add the amount by which our lexer has moved?
				i += expr.length - 1;
				tokens.push(new Token('}}','}',this._loc + i + locOffset,1));
				pi = i + 1;
			};
			
			// adding the last part of the string here
			if (i >= pi && pi < str.length) {
				// set the length as well - or?
				// the string after?
				// console.log 'push neostring'
				tokens.push(new Token('NEOSTRING',this.escapeStr(str.slice(pi),heredoc,quote),this._loc + pi + locOffset,str.length - pi));
			};
			
			// console.log tokens:length
			if (regex) { return tokens };
			
			if (!tokens.length) { return this.token('NEOSTRING','""') };
			
			for (var j = 0, len = tokens.length; j < len; j++) {
				this._tokens.push(tokens[j]);
			};
			
			return tokens;
		};
		
		// Matches a balanced group such as a single or double-quoted string. Pass in
		// a series of delimiters, all of which must be nested correctly within the
		// contents of the string. This method allows us to have strings within
		// interpolations within strings, ad infinitum.
		Lexer.prototype.balancedSelector = function (str,end){
			var prev;
			var letter;
			var stack = [end];
			// FIXME
			for (var len = str.length, i = 1; i < len; i++) {
				switch (letter = str.charAt(i)) {
					case '\\':
						i++;
						continue;
						break;
					
					case end:
						stack.pop();
						if (!stack.length) {
							return str.slice(0,i + 1);
						};
						
						end = stack[stack.length - 1];
						continue;
						break;
				
				};
				if (end == '}' && letter == [')']) {
					stack.push(end = letter);
				} else if (end == '}' && letter == '{') {
					stack.push(end = '}');
				} else if (end == ')' && letter == '{') {
					stack.push(end = '}');
				};
				prev = letter; // what, why?
			};
			
			return this.error(("missing " + (stack.pop()) + ", starting"));
		};
		
		// Pairs up a closing token, ensuring that all listed pairs of tokens are
		// correctly balanced throughout the course of the token stream.
		Lexer.prototype.pair = function (tok){
			var wanted = last(this._ends);
			if (tok != wanted) {
				if ('OUTDENT' != wanted) { this.error(("unmatched " + tok)) };
				var size = last(this._indents);
				this._indent -= size;
				this.outdentToken(size,true,0);
				return this.pair(tok);
			};
			return this.popEnd();
		};
		
		
		// Helpers
		// -------
		
		// Add a token to the results, taking note of the line number.
		Lexer.prototype.token = function (id,value,len,offset){
			this._lastTyp = id;
			this._lastVal = value;
			var tok = this._last = new Token(id,value,this._loc + (offset || 0),len || 0);
			this._tokens.push(tok);
			return;
		};
		
		Lexer.prototype.lastTokenType = function (){
			var token = this._tokens[this._tokens.length - 1];
			return token ? (tT(token)) : ('NONE');
		};
		
		Lexer.prototype.lastTokenValue = function (){
			var token = this._tokens[this._tokens.length - 1];
			return token ? (token._value) : ('');
		};
		
		// Peek at a tokid in the current token stream.
		Lexer.prototype.tokid = function (index,val){
			var tok;
			if (tok = last(this._tokens,index)) {
				if (val) { tTs(tok,val) };
				return tT(tok);
				// tok.@type = tokid if tokid # why?
				// tok.@type
			} else {
				return null;
			};
		};
		
		// Peek at a value in the current token stream.
		Lexer.prototype.value = function (index,val){
			var tok;
			if (tok = last(this._tokens,index)) {
				if (val) { tVs(tok,val) };
				return tV(tok);
				// tok.@value = val if val # why?
				// tok.@value
			} else {
				return null;
			};
		};
		
		
		// Are we in the midst of an unfinished expression?
		Lexer.prototype.unfinished = function (){
			if (LINE_CONTINUER.test(this._chunk)) { return true };
			return UNFINISHED.indexOf(this._lastTyp) >= 0;
		};
		
		// var tokens = ['\\','.', '?.', 'UNARY', 'MATH', '+', '-', 'SHIFT', 'RELATION', 'COMPARE', 'LOGIC', 'COMPOUND_ASSIGN', 'THROW', 'EXTENDS']
		
		// Converts newlines for string literals.
		Lexer.prototype.escapeLines = function (str,heredoc){
			return str.replace(MULTILINER,(heredoc ? ('\\n') : ('')));
		};
		
		// Constructs a string token by escaping quotes and newlines.
		Lexer.prototype.makeString = function (body,quote,heredoc){
			if (!(body)) { return quote + quote };
			body = body.replace(/\\([\s\S])/g,function(match,contents) {
				return (contents == '\n' || contents == quote) ? (contents) : (match);
			});
			// Does not work now
			body = body.replace(RegExp(("" + quote),"g"),'\\$&');
			return quote + this.escapeLines(body,heredoc) + quote;
		};
		
		// Throws a syntax error on the current `@line`.
		Lexer.prototype.error = function (message,len){
			if ((typeof this._line=='number'||this._line instanceof Number)) { message = ("" + message + " on line " + (this._line)) };
			
			if (len) {
				message += (" [" + (this._loc) + ":" + (this._loc + len) + "]");
			};
			
			var err = new SyntaxError(message);
			err.line = this._line;
			// err:columnNumber
			err = new ERR.ImbaParseError(err,{tokens: this._tokens,pos: this._tokens.length});
			err.region = [this._loc,this._loc + (len || 0)];
			throw err;
		};
		return Lexer;
	
	})()

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function idx$(a,b){
			return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
		};
		
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		var INVERSES, LINEBREAKS;
		
		// The Imba language has a good deal of optional syntax, implicit syntax,
		// and shorthand syntax. This can greatly complicate a grammar and bloat
		// the resulting parse table. Instead of making the parser handle it all, we take
		// a series of passes over the token stream, using this **Rewriter** to convert
		// shorthand into the unambiguous long form, add implicit indentation and
		// parentheses, and generally clean things up.
		
		var T = __webpack_require__(1);
		var Token = T.Token;
		
		// Based on the original rewriter.coffee from CoffeeScript
		function Rewriter(){ };
		
		exports.Rewriter = Rewriter; // export class 
		Rewriter.prototype.tokens = function (){
			return this._tokens;
		};
		
		// Helpful snippet for debugging:
		//     console.log (t[0] + '/' + t[1] for t in @tokens).join ' '
		// Rewrite the token stream in multiple passes, one logical filter at
		// a time. This could certainly be changed into a single pass through the
		// stream, with a big ol' efficient switch, but it's much nicer to work with
		// like this. The order of these passes matters -- indentation must be
		// corrected before implicit parentheses can be wrapped around blocks of code.
		Rewriter.prototype.rewrite = function (tokens,opts){
			var token;
			if(opts === undefined) opts = {};
			this._tokens = tokens;
			this._options = opts;
			
			// console.log "tokens in: " + tokens:length
			if (opts.profile) { console.time("tokenize:rewrite") };
			
			var i = 0;
			// flag empty methods
			while (token = tokens[i]){
				var next = tokens[i + 1];
				if (token._type == 'DEF_BODY' && next && next._type == 'TERMINATOR') {
					token._type = 'DEF_EMPTY';
				};
				i++;
			};
			
			this.step("ensureFirstLine");
			this.step("removeLeadingNewlines");
			this.step("removeMidExpressionNewlines");
			this.step("tagDefArguments");
			this.step("closeOpenCalls");
			this.step("closeOpenIndexes");
			this.step("closeOpenTags");
			this.step("closeOpenTagAttrLists");
			this.step("addImplicitIndentation");
			this.step("tagPostfixConditionals");
			this.step("addImplicitBraces");
			this.step("addImplicitParentheses");
			
			if (opts.profile) { console.timeEnd("tokenize:rewrite") };
			// console.log "tokens out: " + @tokens:length
			return this._tokens;
		};
		
		Rewriter.prototype.step = function (fn){
			if (this._options.profile) {
				console.log(("---- starting " + fn + " ---- "));
				console.time(fn);
			};
			
			this[fn]();
			
			if (this._options.profile) {
				console.timeEnd(fn);
				console.log("\n\n");
			};
			return;
		};
		
		// Rewrite the token stream, looking one token ahead and behind.
		// Allow the return value of the block to tell us how many tokens to move
		// forwards (or backwards) in the stream, to make sure we don't miss anything
		// as tokens are inserted and removed, and the stream changes length under
		// our feet.
		Rewriter.prototype.scanTokens = function (block){
			var token;
			var tokens = this._tokens;
			
			var i = 0;
			while (token = tokens[i]){
				i += block.call(this,token,i,tokens);
			};
			
			return true;
		};
		
		Rewriter.prototype.detectEnd = function (i,condition,action){
			var tokens = this._tokens;
			var levels = 0;
			var starts = [];
			var token;
			var t,v;
			
			while (token = tokens[i]){
				if (levels == 0 && condition.call(this,token,i,starts)) {
					return action.call(this,token,i);
				};
				if (!(token) || levels < 0) {
					return action.call(this,token,i - 1);
				};
				
				t = T.typ(token);
				
				if (EXPRESSION_START.indexOf(t) >= 0) {
					if (levels == 0) { starts.push(i) };
					levels += 1;
				} else if (EXPRESSION_END.indexOf(t) >= 0) {
					levels -= 1;
				};
				i += 1;
			};
			return i - 1;
		};
		
		Rewriter.prototype.ensureFirstLine = function (){
			var tok = this._tokens[0];
			
			if (T.typ(tok) == 'TERMINATOR') {
				// console.log "adding bodystart"
				this._tokens = [T.token('BODYSTART','BODYSTART')].concat(this._tokens);
				// T.setTyp(tok,'HEADER')
			};
			return;
		};
		
		// Leading newlines would introduce an ambiguity in the grammar, so we
		// dispatch them here.
		Rewriter.prototype.removeLeadingNewlines = function (){
			var at = 0;
			
			for (var i = 0, ary = iter$(this._tokens), len = ary.length; i < len; i++) {
				if (T.typ(ary[i]) != 'TERMINATOR') {
					at = i;break;
				};
			};
			
			if (at) { this._tokens.splice(0,at) };
			
			return;
		};
		
		// Some blocks occur in the middle of expressions -- when we're expecting
		// this, remove their trailing newlines.
		Rewriter.prototype.removeMidExpressionNewlines = function (){
			var self = this;
			return self.scanTokens(function(token,i,tokens) { // do |token,i,tokens|
				var next = self.tokenType(i + 1);
				
				if (!(T.typ(token) == 'TERMINATOR' && EXPRESSION_CLOSE.indexOf(next) >= 0)) { return 1 };
				if (next == 'OUTDENT') { return 1 };
				tokens.splice(i,1);
				return 0;
			});
		};
		
		
		Rewriter.prototype.tagDefArguments = function (){
			return true;
		};
		
		// The lexer has tagged the opening parenthesis of a method call. Match it with
		// its paired close. We have the mis-nested outdent case included here for
		// calls that close on the same line, just before their outdent.
		Rewriter.prototype.closeOpenCalls = function (){
			var self = this;
			var condition = function(token,i) {
				var t = T.typ(token);
				return (t == ')' || t == 'CALL_END') || t == 'OUTDENT' && self.tokenType(i - 1) == ')';
			};
			
			var action = function(token,i) {
				var t = T.typ(token);
				var tok = self._tokens[t == 'OUTDENT' ? (i - 1) : (i)];
				return T.setTyp(tok,'CALL_END');
			};
			
			return self.scanTokens(function(token,i) {
				if (T.typ(token) == 'CALL_START') { self.detectEnd(i + 1,condition,action) };
				return 1;
			});
		};
		
		// The lexer has tagged the opening parenthesis of an indexing operation call.
		// Match it with its paired close.
		Rewriter.prototype.closeOpenIndexes = function (){
			var self = this;
			var condition = function(token,i) { return idx$(T.typ(token),[']','INDEX_END']) >= 0; };
			var action = function(token,i) { return T.setTyp(token,'INDEX_END'); };
			
			return self.scanTokens(function(token,i) {
				if (T.typ(token) == 'INDEX_START') { self.detectEnd(i + 1,condition,action) };
				return 1;
			});
		};
		
		
		Rewriter.prototype.closeOpenTagAttrLists = function (){
			var self = this;
			var condition = function(token,i) { return idx$(T.typ(token),[')','TAG_ATTRS_END']) >= 0; };
			var action = function(token,i) { return T.setTyp(token,'TAG_ATTRS_END'); }; // 'TAG_ATTRS_END'
			
			return self.scanTokens(function(token,i) {
				if (T.typ(token) == 'TAG_ATTRS_START') { self.detectEnd(i + 1,condition,action) };
				return 1;
			});
		};
		
		// The lexer has tagged the opening parenthesis of an indexing operation call.
		// Match it with its paired close. Should be done in lexer directly
		Rewriter.prototype.closeOpenTags = function (){
			var self = this;
			var condition = function(token,i) { return idx$(T.typ(token),['>','TAG_END']) >= 0; };
			var action = function(token,i) { return T.setTyp(token,'TAG_END'); }; // token[0] = 'TAG_END'
			
			return self.scanTokens(function(token,i) {
				if (T.typ(token) == 'TAG_START') { self.detectEnd(i + 1,condition,action) };
				return 1;
			});
		};
		
		Rewriter.prototype.addImplicitCommas = function (){
			return;
		};
		
		Rewriter.prototype.addImplicitBlockCalls = function (){
			var token;
			var i = 1;
			var tokens = this._tokens;
			
			while (token = tokens[i]){
				var t = token._type;
				var v = token._value;
				// hmm
				if (t == 'DO' && (v == 'INDEX_END' || v == 'IDENTIFIER' || v == 'NEW')) {
					tokens.splice(i + 1,0,T.token('CALL_END',')'));
					tokens.splice(i + 1,0,T.token('CALL_START','('));
					i++;
				};
				i++;
			};
			
			return;
		};
		
		// Object literals may be written with implicit braces, for simple cases.
		// Insert the missing braces here, so that the parser doesn't have to.
		Rewriter.prototype.addImplicitBraces = function (){
			var self = this;
			var stack = [];
			var start = null;
			var startIndent = 0;
			var startIdx = null;
			
			var noBraceTag = ['CLASS','IF','UNLESS','TAG','WHILE','FOR','UNTIL','CATCH','FINALLY','MODULE','LEADING_WHEN'];
			var noBraceContext = ['IF','TERNARY','FOR'];
			
			var noBrace = false;
			
			var scope = function() {
				return stack[stack.length - 1] || [];
			};
			
			var action = function(token,i) {
				return self._tokens.splice(i,0,T.RBRACKET);
			};
			
			var open = function(token,i) {
				return self._tokens.splice(i,0,T.LBRACKET);
			};
			
			var close = function(token,i) {
				return self._tokens.splice(i,0,T.RBRACKET);
			};
			
			var stackToken = function(a,b) {
				return [a,b];
			};
			
			return self.scanTokens(function(token,i,tokens) {
				var type = T.typ(token);
				var v = T.val(token);
				var ctx = stack[stack.length - 1] || [];
				var idx;
				
				if (noBraceContext.indexOf(type) >= 0) {
					// console.log "found noBraceTag {type}"
					stack.push(stackToken(type,i));
					return 1;
				};
				
				if (v == '?') {
					// console.log('TERNARY OPERATOR!')
					stack.push(stackToken('TERNARY',i));
					return 1;
				};
				
				// no need to test for this here as well as in
				if (EXPRESSION_START.indexOf(type) >= 0) {
					if (type == 'INDENT' && noBraceContext.indexOf(ctx[0]) >= 0) {
						stack.pop();
					};
					
					// console.log('expression start',type,ctx[0])
					if (type == 'INDENT' && self.tokenType(i - 1) == '{') {
						// stack ?!? no token
						stack.push(stackToken('{',i)); // should not autogenerate another?
					} else {
						stack.push(stackToken(type,i));
					};
					return 1;
				};
				
				if (EXPRESSION_END.indexOf(type) >= 0) {
					// console.log "EXPRESSION_END at {type} - stack is {ctx[0]}"
					if (ctx[0] == 'TERNARY') { // FIX?
						stack.pop();
					};
					
					start = stack.pop();
					if (!(start)) {
						console.log("NO STACK!!");
					};
					start[2] = i;
					
					// seems like the stack should use tokens, no?)
					if (start[0] == '{' && start.generated) { //  # type != '}' # and start:generated
						close(token,i);
						return 1;
					};
					
					return 1;
				};
				
				// is this correct? same for if/class etc?
				if (ctx[0] == 'TERNARY' && (type == 'TERMINATOR' || type == 'OUTDENT')) {
					stack.pop();
					return 1;
				};
				
				if (noBraceContext.indexOf(ctx[0]) >= 0 && type == 'INDENT') {
					console.log("popping noBraceContext");
					stack.pop();
					return 1;
				};
				
				
				if (type == ',') {
					// automatically add an ending here if inside:generated scope?
					// it is important that this is:generated(!)
					if (ctx[0] == '{' && ctx.generated) {
						tokens.splice(i,0,T.RBRACKET);
						stack.pop();
						return 2;
					} else {
						return 1;
					};
					true;
				};
				
				// found a type
				if (type == ':' && ctx[0] != '{' && ctx[0] != 'TERNARY' && (noBraceContext.indexOf(ctx[0]) == -1)) {
					// could just check if the end was right before this?
					
					if (start && start[2] == i - 1) {
						// console.log('this expression was just ending before colon!')
						idx = start[1] - 1; // these are the stackTokens
					} else {
						// console.log "rewrite here? #{i}"
						idx = i - 2; // if start then start[1] - 1 else i - 2
						// idx = idx - 1 if tokenType(idx) is 'TERMINATOR'
					};
					
					while (self.tokenType(idx - 1) == 'HERECOMMENT'){
						idx -= 2;
					};
					
					var t0 = tokens[idx - 1];
					
					if (t0 && T.typ(t0) == '}' && t0.generated) {
						tokens.splice(idx - 1,1);
						var s = stackToken('{');
						s.generated = true;
						stack.push(s);
						return 0;
					} else if (t0 && T.typ(t0) == ',' && self.tokenType(idx - 2) == '}') {
						tokens.splice(idx - 2,1);
						s = stackToken('{');
						s.generated = true;
						stack.push(s);
						return 0;
					} else {
						s = stackToken('{');
						s.generated = true;
						stack.push(s);
						open(token,idx + 1);
						return 2;
					};
				};
				
				// we probably need to run through autocall first?!
				
				if (type == 'DO') { // and ctx:generated
					var prev = T.typ(tokens[i - 1]); // [0]
					if (['NUMBER','STRING','REGEX','SYMBOL',']','}',')','STRING_END'].indexOf(prev) >= 0) {
						
						var tok = T.token(',',',');
						tok.generated = true;
						tokens.splice(i,0,tok);
						
						if (ctx.generated) {
							close(token,i);
							stack.pop();
							return 2;
						};
					};
				};
				
				if ((type == 'TERMINATOR' || type == 'OUTDENT' || type == 'DEF_BODY') && ctx.generated) {
					close(token,i);
					stack.pop();
					return 2;
				};
				
				return 1;
			});
		};
		
		// Methods may be optionally called without parentheses, for simple cases.
		// Insert the implicit parentheses here, so that the parser doesn't have to
		// deal with them.
		// Practically everything will now be callable this way (every identifier)
		Rewriter.prototype.addImplicitParentheses = function (){
			
			var self = this, token;
			var noCallTag = ['CLASS','IF','UNLESS','TAG','WHILE','FOR','UNTIL','CATCH','FINALLY','MODULE','LEADING_WHEN'];
			
			var action = function(token,i) {
				return self._tokens.splice(i,0,T.token('CALL_END',')'));
			};
			
			// console.log "adding implicit parenthesis" # ,self:scanTokens
			var tokens = self._tokens;
			
			var noCall = false;
			var seenFor = false;
			var endCallAtTerminator = false;
			
			var i = 0;
			while (token = tokens[i]){
				
				// to handle cases like:
				// if a(do yes).test
				// 	yes
				// we need to keep a stack for balanced pairs
				// until then you must explicitly end the call like
				// if a(do yes).test()
				// 	yes
				
				var type = token._type;
				
				var prev = tokens[i - 1];
				var current = tokens[i];
				var next = tokens[i + 1];
				
				var pt = prev && prev._type;
				var nt = next && next._type;
				
				// if pt == 'WHEN'
				// Never make these tags implicitly call
				// should we not just remove these from IMPLICIT_FUNC?
				if ((pt == ')' || pt == ']') && type == 'INDENT') {
					noCall = true;
				};
				
				if (noCallTag.indexOf(pt) >= 0) {
					// console.log("seen nocall tag {pt} ({pt} {type} {nt})")
					endCallAtTerminator = true;
					noCall = true;
					if (pt == 'FOR') { seenFor = true };
				};
				
				
				var callObject = false;
				var callIndent = false;
				
				// [prev, current, next] = tokens[i - 1 .. i + 1]
				
				// check for comments
				// console.log "detect end??"
				if (!(noCall) && type == 'INDENT' && next) {
					var prevImpFunc = pt && IMPLICIT_FUNC.indexOf(pt) >= 0;
					var nextImpCall = nt && IMPLICIT_CALL.indexOf(nt) >= 0;
					callObject = ((next.generated && nt == '{') || nextImpCall) && prevImpFunc;
					callIndent = nextImpCall && prevImpFunc;
				};
				
				var seenSingle = false;
				var seenControl = false;
				// Hmm ?
				
				// this is not correct if this is inside a block,no?
				if ((type == 'TERMINATOR' || type == 'OUTDENT' || type == 'INDENT')) {
					endCallAtTerminator = false;
					noCall = false;
				};
				
				if (type == '?' && prev && !prev.spaced) { token.call = true };
				
				// where does fromThem come from?
				if (token.fromThen) {
					i += 1;continue;
				};
				// here we deal with :spaced and :newLine
				if (!(callObject || callIndent || (prev && prev.spaced) && (prev.call || IMPLICIT_FUNC.indexOf(pt) >= 0) && (IMPLICIT_CALL.indexOf(type) >= 0 || !(token.spaced || token.newLine) && IMPLICIT_UNSPACED_CALL.indexOf(type) >= 0))) {
					i += 1;continue;
				};
				
				
				tokens.splice(i,0,T.token('CALL_START','('));
				// console.log "added ( {prev}"
				var cond = function(token,i) {
					var type = T.typ(token);
					if (!(seenSingle) && token.fromThen) { return true };
					var ifelse = type == 'IF' || type == 'UNLESS' || type == 'ELSE';
					if (ifelse || type == 'CATCH') { seenSingle = true };
					if (ifelse || type == 'SWITCH' || type == 'TRY') { seenControl = true };
					var prev = self.tokenType(i - 1);
					
					if ((type == '.' || type == '?.' || type == '::') && prev == 'OUTDENT') { return true };
					if (endCallAtTerminator && (type == 'INDENT' || type == 'TERMINATOR')) { return true };
					if ((type == 'WHEN' || type == 'BY') && !(seenFor)) {
						// console.log "dont close implicit call outside for"
						return false;
					};
					
					var post = tokens[i + 1];
					var postTyp = post && T.typ(post);
					// WTF
					return !token.generated && prev != ',' && (IMPLICIT_END.indexOf(type) >= 0 || (type == 'INDENT' && !(seenControl)) || (type == 'DOS' && prev != '=')) && (type != 'INDENT' || (self.tokenType(i - 2) != 'CLASS' && IMPLICIT_BLOCK.indexOf(prev) == -1 && !(post && ((post.generated && postTyp == '{') || IMPLICIT_CALL.indexOf(postTyp) >= 0))));
				};
				
				// The action for detecting when the call should end
				// console.log "detect end??"
				self.detectEnd(i + 1,cond,action);
				if (T.typ(prev) == '?') { T.setTyp(prev,'FUNC_EXIST') };
				i += 2;
				// need to reset after a match
				endCallAtTerminator = false;
				noCall = false;
				seenFor = false;
			};
			
			
			return;
		};
		
		// Because our grammar is LALR(1), it can't handle some single-line
		// expressions that lack ending delimiters. The **Rewriter** adds the implicit
		// blocks, so it doesn't need to. ')' can close a single-line block,
		// but we need to make sure it's balanced.
		Rewriter.prototype.addImplicitIndentation = function (){
			
			
			var self = this, token;
			var i = 0;
			var tokens = self._tokens;
			while (token = tokens[i]){
				var type = T.typ(token);
				var next = self.tokenType(i + 1);
				
				// why are we removing terminators after then? should be able to handle
				if (type == 'TERMINATOR' && next == 'THEN') {
					tokens.splice(i,1);
					continue;
				};
				
				if (type == 'CATCH' && idx$(self.tokenType(i + 2),['OUTDENT','TERMINATOR','FINALLY']) >= 0) {
					tokens.splice.apply(tokens,[].concat([i + 2,0], [].slice.call(self.indentation(token))));
					i += 4;continue;
				};
				
				if (SINGLE_LINERS.indexOf(type) >= 0 && (next != 'INDENT' && next != 'BLOCK_PARAM_START') && !(type == 'ELSE' && next == 'IF') && type != 'ELIF') {
					
					var starter = type;
					
					var indent = T.token('INDENT','2');
					var outdent = T.OUTDENT;
					// var indent, outdent = indentation(token)
					if (starter == 'THEN') { indent.fromThen = true }; // setting special values for these -- cannot really reuse?
					indent.generated = true;
					// outdent:generated = true
					tokens.splice(i + 1,0,indent);
					
					var condition = function(token,i) {
						var t = T.typ(token);
						return T.val(token) != ';' && SINGLE_CLOSERS.indexOf(t) >= 0 && !(t == 'ELSE' && starter != 'IF' && starter != 'THEN');
					};
					
					var action = function(token,i) {
						var idx = self.tokenType(i - 1) == ',' ? (i - 1) : (i);
						return tokens.splice(idx,0,outdent);
					};
					
					self.detectEnd(i + 2,condition,action);
					if (type == 'THEN') { tokens.splice(i,1) };
				};
				
				i++;
			};
			
			return;
		};
		
		// Tag postfix conditionals as such, so that we can parse them with a
		// different precedence.
		Rewriter.prototype.tagPostfixConditionals = function (){
			var self = this;
			var condition = function(token,i) { return idx$(T.typ(token),['TERMINATOR','INDENT']) >= 0; };
			
			return self.scanTokens(function(token,i) {
				var typ = T.typ(token);
				if (!(typ == 'IF' || typ == 'FOR')) { return 1 };
				var original = token;
				self.detectEnd(i + 1,condition,function(token,i) {
					if (T.typ(token) != 'INDENT') { return T.setTyp(original,'POST_' + T.typ(original)) };
				});
				return 1;
			});
		};
		
		// Generate the indentation tokens, based on another token on the same line.
		Rewriter.prototype.indentation = function (token){
			return [T.token('INDENT','2'),T.token('OUTDENT','2')];
		};
		
		// Look up a type by token index.
		Rewriter.prototype.type = function (i){
			// if i < 0 then return null
			var tok = this._tokens[i];
			return tok && T.typ(tok);
			// if tok then tok[0] else null
		};
		
		Rewriter.prototype.tokenType = function (i){
			var tok = this._tokens[i];
			return tok && T.typ(tok);
			// return tok and tok[0]
		};
		
		// Constants
		// ---------
		
		// List of the token pairs that must be balanced.
		var BALANCED_PAIRS = [
			['(',')'],
			['[',']'],
			['{','}'],
			['{{','}}'],
			['INDENT','OUTDENT'],
			['CALL_START','CALL_END'],
			['PARAM_START','PARAM_END'],
			['INDEX_START','INDEX_END'],
			['TAG_START','TAG_END'],
			['TAG_PARAM_START','TAG_PARAM_END'],
			['TAG_ATTRS_START','TAG_ATTRS_END'],
			['BLOCK_PARAM_START','BLOCK_PARAM_END']
		];
		
		// The inverse mappings of `BALANCED_PAIRS` we're trying to fix up, so we can
		// look things up from either end.
		module.exports.INVERSES = INVERSES = {};
		
		// The tokens that signal the start/end of a balanced pair.
		// var EXPRESSION_START = []
		// var EXPRESSION_END   = []
		
		for (var i = 0, ary = iter$(BALANCED_PAIRS), len = ary.length, pair; i < len; i++) {
			pair = ary[i];
			var left = pair[0];
			var rite = pair[1];
			INVERSES[rite] = left;
			INVERSES[left] = rite;
		};
		
		var EXPRESSION_START = ['(','[','{','INDENT','CALL_START','PARAM_START','INDEX_START','TAG_PARAM_START','BLOCK_PARAM_START','STRING_START','{{','TAG_START'];
		var EXPRESSION_END = [')',']','}','OUTDENT','CALL_END','PARAM_END','INDEX_END','TAG_PARAM_END','BLOCK_PARAM_END','STRING_END','}}','TAG_END'];
		
		var IDENTIFIERS = ['IDENTIFIER','GVAR','IVAR','CVAR','CONST','ARGVAR'];
		
		// Tokens that indicate the close of a clause of an expression.
		var EXPRESSION_CLOSE = ['CATCH','WHEN','ELSE','FINALLY'].concat(EXPRESSION_END);
		
		// Tokens that, if followed by an `IMPLICIT_CALL`, indicate a function invocation.
		var IMPLICIT_FUNC = ['IDENTIFIER','SUPER','@','THIS','SELF','EVENT','TRIGGER','TAG_END','IVAR',
		'GVAR','CONST','ARGVAR','NEW','BREAK','CONTINUE','RETURN'];
		
		// If preceded by an `IMPLICIT_FUNC`, indicates a function invocation.
		var IMPLICIT_CALL = [
			'SELECTOR','IDENTIFIER','NUMBER','STRING','SYMBOL','JS','REGEX','NEW','PARAM_START','CLASS',
			'IF','UNLESS','TRY','SWITCH','THIS','BOOL','TRUE','FALSE','NULL','UNDEFINED','UNARY','SUPER','IVAR','GVAR','CONST','ARGVAR','SELF',
			'@','[','(','{','--','++','SELECTOR','TAG_START','TAGID','#','SELECTOR_START','IDREF','SPLAT','DO','BLOCK_ARG',
			'FOR','STRING_START','CONTINUE','BREAK'
		]; // '->', '=>', why does it not work with symbol?
		
		var IMPLICIT_INDENT_CALL = [
			'FOR'
		];
		// is not do an implicit call??
		
		var IMPLICIT_UNSPACED_CALL = ['+','-'];
		
		// Tokens indicating that the implicit call must enclose a block of expressions.
		var IMPLICIT_BLOCK = ['{','[',',','BLOCK_PARAM_END','DO']; // '->', '=>', 
		
		var CONDITIONAL_ASSIGN = ['||=','&&=','?=','&=','|='];
		var COMPOUND_ASSIGN = ['-=','+=','/=','*=','%=','||=','&&=','?=','<<=','>>=','>>>=','&=','^=','|='];
		var UNARY = ['!','~','NEW','TYPEOF','DELETE'];
		var LOGIC = ['&&','||','&','|','^'];
		
		// optimize for fixed arrays
		var NO_IMPLICIT_BLOCK_CALL = [
			'CALL_END','=','DEF_BODY','(','CALL_START',',',':','RETURN',
			'-=','+=','/=','*=','%=','||=','&&=','?=','<<=','>>=','>>>=','&=','^=','|='
		]; // .concat(COMPOUND_ASSIGN)
		
		
		// console.log NO_IMPLICIT_BLOCK_CALL:length
		// NO_IMPLICIT_BLOCK_CALL
		// IMPLICIT_COMMA = ['->', '=>', '{', '[', 'NUMBER', 'STRING', 'SYMBOL', 'IDENTIFIER','DO']
		
		var IMPLICIT_COMMA = ['DO'];
		
		// Tokens that always mark the end of an implicit call for single-liners.
		var IMPLICIT_END = ['POST_IF','POST_UNLESS','POST_FOR','WHILE','UNTIL','WHEN','BY','LOOP','TERMINATOR','DEF_BODY','DEF_FRAGMENT'];
		
		// Single-line flavors of block expressions that have unclosed endings.
		// The grammar can't disambiguate them, so we insert the implicit indentation.
		var SINGLE_LINERS = ['ELSE','TRY','FINALLY','THEN','BLOCK_PARAM_END','DO','BEGIN','CATCH_VAR']; // '->', '=>', really?
		var SINGLE_CLOSERS = ['TERMINATOR','CATCH','FINALLY','ELSE','OUTDENT','LEADING_WHEN'];
		
		// Tokens that end a line.
		return LINEBREAKS = ['TERMINATOR','INDENT','OUTDENT'];
	
	})()

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module, process) {/* parser generated by jison-fork */
	var parser = (function(){
	var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,4],$V1=[1,6],$V2=[1,32],$V3=[1,33],$V4=[1,34],$V5=[1,35],$V6=[1,75],$V7=[1,115],$V8=[1,128],$V9=[1,121],$Va=[1,122],$Vb=[1,123],$Vc=[1,120],$Vd=[1,124],$Ve=[1,131],$Vf=[1,114],$Vg=[1,132],$Vh=[1,80],$Vi=[1,81],$Vj=[1,82],$Vk=[1,83],$Vl=[1,84],$Vm=[1,85],$Vn=[1,86],$Vo=[1,73],$Vp=[1,118],$Vq=[1,95],$Vr=[1,91],$Vs=[1,88],$Vt=[1,71],$Vu=[1,65],$Vv=[1,66],$Vw=[1,111],$Vx=[1,90],$Vy=[1,87],$Vz=[1,28],$VA=[1,29],$VB=[1,96],$VC=[1,94],$VD=[1,112],$VE=[1,113],$VF=[1,126],$VG=[1,67],$VH=[1,68],$VI=[1,119],$VJ=[1,11],$VK=[1,127],$VL=[1,78],$VM=[1,37],$VN=[1,43],$VO=[1,110],$VP=[1,69],$VQ=[1,89],$VR=[1,125],$VS=[1,59],$VT=[1,74],$VU=[1,105],$VV=[1,106],$VW=[1,107],$VX=[1,129],$VY=[1,130],$VZ=[1,63],$V_=[1,104],$V$=[1,51],$V01=[1,52],$V11=[1,53],$V21=[1,54],$V31=[1,55],$V41=[1,56],$V51=[1,134],$V61=[1,6,11,137],$V71=[1,136],$V81=[1,6,11,14,137],$V91=[1,144],$Va1=[1,145],$Vb1=[1,147],$Vc1=[1,148],$Vd1=[1,141],$Ve1=[1,140],$Vf1=[1,142],$Vg1=[1,143],$Vh1=[1,146],$Vi1=[1,151],$Vj1=[1,6,10,11,14,22,71,90,97,106,112,126,135,137,147,171,200,201,212,213,214,219,220,229,238,239,242,243,246,247,248],$Vk1=[2,263],$Vl1=[1,158],$Vm1=[1,164],$Vn1=[1,162],$Vo1=[1,160],$Vp1=[1,161],$Vq1=[1,165],$Vr1=[1,163],$Vs1=[1,6,10,11,14,22,90,97,137],$Vt1=[1,6,11,14,137,212,214,219,220,238],$Vu1=[1,6,10,11,14,21,22,71,88,89,90,97,106,111,112,126,135,137,144,147,171,180,181,183,196,200,201,212,213,214,219,220,229,238,239,242,243,246,247,248],$Vv1=[2,231],$Vw1=[1,178],$Vx1=[1,176],$Vy1=[1,6,10,11,14,21,22,71,88,89,90,97,106,111,112,117,126,135,137,144,147,171,180,181,183,196,200,201,212,213,214,219,220,229,238,239,242,243,246,247,248],$Vz1=[2,227],$VA1=[6,14,53,54,88,91,106,111,113,116],$VB1=[1,212],$VC1=[1,217],$VD1=[1,6,10,11,14,21,22,71,88,89,90,97,106,111,112,117,126,135,137,144,147,171,180,181,183,196,200,201,212,213,214,219,220,229,238,239,242,243,244,245,246,247,248,249],$VE1=[1,227],$VF1=[1,224],$VG1=[1,229],$VH1=[6,10,14,90],$VI1=[2,244],$VJ1=[1,257],$VK1=[1,247],$VL1=[1,276],$VM1=[1,277],$VN1=[51,89],$VO1=[85,86,87,88,91,92,93,94,95,96,100,102],$VP1=[1,289],$VQ1=[1,6,10,11,14,21,22,53,54,71,88,89,90,91,97,106,111,112,113,116,117,126,135,137,144,147,171,180,181,183,196,200,201,212,213,214,219,220,229,238,239,242,243,244,245,246,247,248,249],$VR1=[1,295],$VS1=[51,89,96,225],$VT1=[1,6,10,11,14,21,22,67,69,70,71,88,89,90,97,106,111,112,126,135,137,144,147,171,180,181,183,196,200,201,212,213,214,219,220,229,238,239,242,243,246,247,248],$VU1=[1,6,10,11,14,21,22,71,88,89,90,97,106,111,112,126,135,137,144,147,171,180,181,183,196,200,201,207,208,212,213,214,219,220,229,232,234,237,238,239,242,243,246,247,248],$VV1=[51,53,54,58],$VW1=[1,326],$VX1=[1,327],$VY1=[1,6,10,11,14,22,71,90,97,106,112,135,137,147,200,201,212,213,214,219,220,229,238],$VZ1=[1,340],$V_1=[1,344],$V$1=[1,6,11,14,22,71,90,97,106,112,126,135,137,147,171,200,201,212,213,214,219,220,229,238,239,242,243,246,247,248],$V02=[6,14,106],$V12=[1,354],$V22=[1,6,10,11,14,21,22,71,89,90,97,106,112,126,135,137,147,171,200,201,212,213,214,219,220,229,238,239,242,243,246,247,248],$V32=[14,28],$V42=[1,6,11,14,28,137,212,214,219,220,238],$V52=[2,284],$V62=[1,6,10,11,14,21,22,71,88,89,90,97,106,111,112,117,126,135,137,144,147,171,180,181,183,196,200,201,212,213,214,219,220,227,228,229,238,239,242,243,244,245,246,247,248,249],$V72=[2,184],$V82=[1,369],$V92=[6,10,11,14,22,97],$Va2=[14,147],$Vb2=[2,186],$Vc2=[1,379],$Vd2=[1,380],$Ve2=[1,381],$Vf2=[1,385],$Vg2=[6,10,11,14,90],$Vh2=[6,10,11,14,90,135],$Vi2=[1,6,10,11,14,22,71,90,97,106,112,135,137,147,200,201,220,229,238],$Vj2=[1,6,10,11,14,22,71,90,97,106,112,135,137,147,200,201,213,220,229,238],$Vk2=[227,228],$Vl2=[14,227,228],$Vm2=[1,6,11,14,22,71,90,97,106,112,135,137,147,171,200,201,212,213,214,219,220,229,238,239,242,243,246,247,248],$Vn2=[88,91],$Vo2=[1,406],$Vp2=[1,407],$Vq2=[21,88,91,164,165],$Vr2=[1,6,10,11,14,22,71,90,97,106,112,126,135,137,147,171,200,201,212,213,214,219,220,229,238,239,242,243,247,248],$Vs2=[1,6,10,11,14,22,71,90,97,106,112,135,137,147,200,201,213,229],$Vt2=[19,20,23,24,26,32,51,53,54,56,58,60,62,64,66,73,74,75,76,77,78,79,80,83,89,91,96,103,112,122,123,124,130,136,143,144,151,152,154,156,157,158,175,184,185,188,193,194,197,198,204,210,212,214,216,219,220,230,236,240,241,242,243,244,245],$Vu2=[1,6,10,11,14,22,71,90,97,106,112,126,135,137,147,171,200,201,212,213,214,219,220,229,232,237,238,239,242,243,246,247,248],$Vv2=[11,232,234],$Vw2=[1,453],$Vx2=[2,185],$Vy2=[6,10,11],$Vz2=[1,461],$VA2=[14,22,147],$VB2=[1,469],$VC2=[1,6,10,11,14,22,71,90,97,106,112,135,137,147,200,201,212,214,219,220,229,238],$VD2=[51,58,89],$VE2=[14,22],$VF2=[1,492],$VG2=[10,14],$VH2=[1,542],$VI2=[6,10];
	var parser = {trace: function trace() { },
	yy: {},
	symbols_: {"error":2,"Root":3,"Body":4,"Block":5,"TERMINATOR":6,"BODYSTART":7,"Line":8,"Terminator":9,"INDENT":10,"OUTDENT":11,"Splat":12,"Expression":13,",":14,"Comment":15,"Statement":16,"Return":17,"Throw":18,"STATEMENT":19,"BREAK":20,"CALL_START":21,"CALL_END":22,"CONTINUE":23,"DEBUGGER":24,"ImportStatement":25,"IMPORT":26,"ImportArgList":27,"FROM":28,"ImportFrom":29,"AS":30,"ImportArg":31,"STRING":32,"VarIdentifier":33,"Await":34,"Value":35,"Code":36,"Operation":37,"Assign":38,"If":39,"Ternary":40,"Try":41,"While":42,"For":43,"Switch":44,"Class":45,"Module":46,"TagDeclaration":47,"Tag":48,"Property":49,"Identifier":50,"IDENTIFIER":51,"Ivar":52,"IVAR":53,"CVAR":54,"Gvar":55,"GVAR":56,"Const":57,"CONST":58,"Argvar":59,"ARGVAR":60,"Symbol":61,"SYMBOL":62,"AlphaNumeric":63,"NUMBER":64,"InterpolatedString":65,"STRING_START":66,"NEOSTRING":67,"Interpolation":68,"STRING_END":69,"{{":70,"}}":71,"Literal":72,"JS":73,"REGEX":74,"BOOL":75,"TRUE":76,"FALSE":77,"NULL":78,"UNDEFINED":79,"RETURN":80,"Arguments":81,"TagSelector":82,"SELECTOR_START":83,"TagSelectorType":84,"SELECTOR_NS":85,"SELECTOR_ID":86,"SELECTOR_CLASS":87,".":88,"{":89,"}":90,"#":91,"SELECTOR_COMBINATOR":92,"SELECTOR_PSEUDO_CLASS":93,"SELECTOR_GROUP":94,"UNIVERSAL_SELECTOR":95,"[":96,"]":97,"SELECTOR_ATTR_OP":98,"TagSelectorAttrValue":99,"SELECTOR_TAG":100,"Selector":101,"SELECTOR_END":102,"TAG_START":103,"TagOptions":104,"TagAttributes":105,"TAG_END":106,"TagBody":107,"TagTypeName":108,"Self":109,"TAG_TYPE":110,"INDEX_START":111,"INDEX_END":112,"@":113,"TagAttr":114,"OptComma":115,"TAG_ATTR":116,"=":117,"TagAttrValue":118,"ArgList":119,"TagTypeDef":120,"TagDeclarationBlock":121,"EXTEND":122,"LOCAL":123,"TAG":124,"TagType":125,"COMPARE":126,"TagDeclKeywords":127,"TAG_ID":128,"TagId":129,"IDREF":130,"Assignable":131,"Outdent":132,"AssignObj":133,"ObjAssignable":134,":":135,"(":136,")":137,"HERECOMMENT":138,"COMMENT":139,"Method":140,"Do":141,"Begin":142,"BEGIN":143,"DO":144,"BLOCK_PARAM_START":145,"ParamList":146,"BLOCK_PARAM_END":147,"PropType":148,"PropertyIdentifier":149,"Object":150,"PROP":151,"ATTR":152,"TupleAssign":153,"VAR":154,"MethodDeclaration":155,"GLOBAL":156,"EXPORT":157,"DEF":158,"MethodScope":159,"MethodScopeType":160,"MethodIdentifier":161,"MethodBody":162,"MethodReceiver":163,"DEF_BODY":164,"DEF_EMPTY":165,"This":166,"Param":167,"Array":168,"ParamVar":169,"SPLAT":170,"LOGIC":171,"BLOCK_ARG":172,"VarReference":173,"VarAssignable":174,"LET":175,"SimpleAssignable":176,"NEW":177,"Super":178,"SoakableOp":179,"?:":180,".:":181,"IndexValue":182,"?.":183,"SUPER":184,"AWAIT":185,"Parenthetical":186,"Range":187,"ARGUMENTS":188,"Invocation":189,"Slice":190,"AssignList":191,"ClassStart":192,"CLASS":193,"MODULE":194,"OptFuncExist":195,"FUNC_EXIST":196,"THIS":197,"SELF":198,"RangeDots":199,"..":200,"...":201,"Arg":202,"SimpleArgs":203,"TRY":204,"Catch":205,"Finally":206,"FINALLY":207,"CATCH":208,"CATCH_VAR":209,"THROW":210,"WhileSource":211,"WHILE":212,"WHEN":213,"UNTIL":214,"Loop":215,"LOOP":216,"ForBody":217,"ForKeyword":218,"FOR":219,"POST_FOR":220,"ForBlock":221,"ForStart":222,"ForSource":223,"ForVariables":224,"OWN":225,"ForValue":226,"FORIN":227,"FOROF":228,"BY":229,"SWITCH":230,"Whens":231,"ELSE":232,"When":233,"LEADING_WHEN":234,"IfBlock":235,"IF":236,"ELIF":237,"POST_IF":238,"?":239,"UNARY":240,"SQRT":241,"-":242,"+":243,"--":244,"++":245,"MATH":246,"SHIFT":247,"RELATION":248,"COMPOUND_ASSIGN":249,"$accept":0,"$end":1},
	terminals_: {2:"error",6:"TERMINATOR",7:"BODYSTART",10:"INDENT",11:"OUTDENT",14:",",19:"STATEMENT",20:"BREAK",21:"CALL_START",22:"CALL_END",23:"CONTINUE",24:"DEBUGGER",26:"IMPORT",28:"FROM",30:"AS",32:"STRING",51:"IDENTIFIER",53:"IVAR",54:"CVAR",56:"GVAR",58:"CONST",60:"ARGVAR",62:"SYMBOL",64:"NUMBER",66:"STRING_START",67:"NEOSTRING",69:"STRING_END",70:"{{",71:"}}",73:"JS",74:"REGEX",75:"BOOL",76:"TRUE",77:"FALSE",78:"NULL",79:"UNDEFINED",80:"RETURN",83:"SELECTOR_START",85:"SELECTOR_NS",86:"SELECTOR_ID",87:"SELECTOR_CLASS",88:".",89:"{",90:"}",91:"#",92:"SELECTOR_COMBINATOR",93:"SELECTOR_PSEUDO_CLASS",94:"SELECTOR_GROUP",95:"UNIVERSAL_SELECTOR",96:"[",97:"]",98:"SELECTOR_ATTR_OP",100:"SELECTOR_TAG",102:"SELECTOR_END",103:"TAG_START",106:"TAG_END",110:"TAG_TYPE",111:"INDEX_START",112:"INDEX_END",113:"@",116:"TAG_ATTR",117:"=",122:"EXTEND",123:"LOCAL",124:"TAG",126:"COMPARE",128:"TAG_ID",130:"IDREF",135:":",136:"(",137:")",138:"HERECOMMENT",139:"COMMENT",143:"BEGIN",144:"DO",145:"BLOCK_PARAM_START",147:"BLOCK_PARAM_END",151:"PROP",152:"ATTR",154:"VAR",156:"GLOBAL",157:"EXPORT",158:"DEF",164:"DEF_BODY",165:"DEF_EMPTY",170:"SPLAT",171:"LOGIC",172:"BLOCK_ARG",175:"LET",177:"NEW",180:"?:",181:".:",183:"?.",184:"SUPER",185:"AWAIT",188:"ARGUMENTS",193:"CLASS",194:"MODULE",196:"FUNC_EXIST",197:"THIS",198:"SELF",200:"..",201:"...",204:"TRY",207:"FINALLY",208:"CATCH",209:"CATCH_VAR",210:"THROW",212:"WHILE",213:"WHEN",214:"UNTIL",216:"LOOP",219:"FOR",220:"POST_FOR",225:"OWN",227:"FORIN",228:"FOROF",229:"BY",230:"SWITCH",232:"ELSE",234:"LEADING_WHEN",236:"IF",237:"ELIF",238:"POST_IF",239:"?",240:"UNARY",241:"SQRT",242:"-",243:"+",244:"--",245:"++",246:"MATH",247:"SHIFT",248:"RELATION",249:"COMPOUND_ASSIGN"},
	productions_: [0,[3,0],[3,1],[3,2],[4,1],[4,1],[4,3],[4,2],[9,1],[5,2],[5,3],[5,4],[8,1],[8,1],[8,3],[8,3],[8,1],[8,1],[16,1],[16,1],[16,1],[16,1],[16,4],[16,1],[16,4],[16,1],[16,1],[25,4],[25,4],[25,2],[29,1],[27,1],[27,3],[31,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[50,1],[52,1],[52,1],[55,1],[57,1],[59,1],[61,1],[63,1],[63,1],[63,1],[63,1],[65,1],[65,2],[65,2],[65,2],[68,2],[68,3],[72,1],[72,1],[72,1],[72,1],[72,1],[72,1],[72,1],[72,1],[17,2],[17,2],[17,1],[82,1],[82,2],[82,2],[82,2],[82,2],[82,5],[82,5],[82,2],[82,2],[82,2],[82,2],[82,4],[82,6],[84,1],[101,2],[99,1],[99,1],[99,3],[48,4],[48,5],[48,5],[108,1],[108,1],[108,1],[108,0],[104,1],[104,3],[104,4],[104,3],[104,5],[104,5],[104,3],[104,2],[104,5],[105,0],[105,1],[105,3],[105,4],[114,1],[114,3],[118,1],[107,3],[107,3],[120,1],[120,3],[47,1],[47,2],[47,2],[121,2],[121,3],[121,4],[121,5],[127,0],[127,1],[125,1],[125,1],[129,1],[129,2],[38,3],[38,5],[133,1],[133,3],[133,5],[133,1],[134,1],[134,1],[134,1],[134,1],[134,1],[134,3],[15,1],[15,1],[36,1],[36,1],[36,1],[142,2],[141,2],[141,5],[141,6],[49,3],[49,5],[49,2],[148,1],[148,1],[149,1],[149,3],[153,4],[140,1],[140,2],[140,2],[155,8],[155,5],[155,6],[155,3],[160,1],[160,1],[161,1],[161,1],[161,3],[162,2],[162,2],[162,1],[159,1],[159,1],[159,1],[159,1],[115,0],[115,1],[146,0],[146,1],[146,3],[167,1],[167,1],[167,1],[167,2],[167,2],[167,2],[167,3],[169,1],[12,2],[173,3],[173,2],[173,2],[173,3],[173,2],[33,1],[33,1],[174,1],[174,1],[174,1],[176,1],[176,1],[176,1],[176,1],[176,1],[176,1],[176,1],[176,3],[176,3],[176,3],[176,3],[176,3],[176,3],[176,3],[176,3],[176,4],[179,1],[179,1],[178,1],[131,1],[131,1],[131,1],[34,2],[35,1],[35,1],[35,1],[35,1],[35,1],[35,1],[35,1],[35,1],[35,1],[35,1],[182,1],[182,1],[150,4],[191,0],[191,1],[191,3],[191,4],[191,6],[45,1],[45,2],[45,2],[45,2],[45,2],[45,3],[192,2],[192,3],[192,4],[192,5],[46,2],[46,3],[189,3],[189,2],[195,0],[195,1],[81,2],[81,4],[166,1],[109,1],[168,2],[168,4],[199,1],[199,1],[187,5],[190,3],[190,2],[190,2],[119,1],[119,3],[119,4],[119,4],[119,6],[132,2],[132,1],[202,1],[202,1],[202,1],[202,1],[203,1],[203,3],[41,2],[41,3],[41,3],[41,4],[206,2],[205,3],[18,2],[186,3],[186,5],[211,2],[211,4],[211,2],[211,4],[42,2],[42,2],[42,2],[42,1],[215,2],[215,2],[43,2],[43,2],[43,2],[218,1],[218,1],[221,2],[217,2],[217,2],[222,2],[222,3],[226,1],[226,1],[226,1],[224,1],[224,3],[223,2],[223,2],[223,4],[223,4],[223,4],[223,6],[223,6],[44,5],[44,7],[44,4],[44,6],[231,1],[231,2],[233,3],[233,4],[235,3],[235,5],[235,4],[235,3],[39,1],[39,3],[39,3],[40,5],[37,2],[37,2],[37,2],[37,2],[37,2],[37,2],[37,2],[37,2],[37,3],[37,3],[37,3],[37,3],[37,3],[37,3],[37,3],[37,3],[37,5]],
	performAction: function performAction(self, yytext, yy, yystate /* action[1] */, $$ /* vstack */) {
	/* self == yyval */
	
	var $0 = $$.length - 1;
	switch (yystate) {
	case 1:
	return self.$ = new yy.Root([]);
	break;
	case 2:
	return self.$ = new yy.Root($$[$0]);
	break;
	case 3:
	return self.$ = $$[$0-1];
	break;
	case 4:
	self.$ = new yy.Block([]);
	break;
	case 5:
	self.$ = new yy.Block([$$[$0]]);
	break;
	case 6:
	self.$ = $$[$0-2].break($$[$0-1]).add($$[$0]);
	break;
	case 7:
	self.$ = $$[$0-1].break($$[$0]);
	break;
	case 8:
	self.$ = new yy.Terminator($$[$0]);
	break;
	case 9:
	self.$ = new yy.Block([]).indented($$[$0-1],$$[$0]);
	break;
	case 10: case 119:
	self.$ = $$[$0-1].indented($$[$0-2],$$[$0]);
	break;
	case 11:
	self.$ = $$[$0-1].prebreak($$[$0-2]).indented($$[$0-3],$$[$0]);
	break;
	case 12: case 13: case 16: case 17: case 18: case 19: case 26: case 30: case 33: case 34: case 35: case 36: case 37: case 38: case 39: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 48: case 49: case 59: case 60: case 67: case 93: case 94: case 99: case 118: case 123: case 130: case 141: case 142: case 143: case 144: case 145: case 146: case 150: case 151: case 152: case 160: case 161: case 162: case 165: case 174: case 175: case 177: case 180: case 181: case 182: case 183: case 184: case 185: case 196: case 203: case 204: case 205: case 206: case 207: case 208: case 210: case 211: case 212: case 213: case 227: case 228: case 229: case 231: case 232: case 233: case 234: case 235: case 237: case 238: case 239: case 240: case 249: case 283: case 284: case 285: case 286: case 287: case 288: case 306: case 312: case 313: case 319: case 335: case 343:
	self.$ = $$[$0];
	break;
	case 14: case 15:
	self.$ = $$[$0-2].addExpression($$[$0]);
	break;
	case 20: case 68:
	self.$ = new yy.Literal($$[$0]);
	break;
	case 21:
	self.$ = new yy.BreakStatement($$[$0]);
	break;
	case 22:
	self.$ = new yy.BreakStatement($$[$0-3],$$[$0-1]);
	break;
	case 23:
	self.$ = new yy.ContinueStatement($$[$0]);
	break;
	case 24:
	self.$ = new yy.ContinueStatement($$[$0-3],$$[$0-1]);
	break;
	case 25:
	self.$ = new yy.DebuggerStatement($$[$0]);
	break;
	case 27:
	self.$ = new yy.ImportStatement($$[$0-2],$$[$0]);
	break;
	case 28:
	self.$ = new yy.ImportStatement(null,$$[$0-2],$$[$0]);
	break;
	case 29:
	self.$ = new yy.ImportStatement(null,$$[$0]);
	break;
	case 31: case 113: case 187: case 322:
	self.$ = [$$[$0]];
	break;
	case 32: case 114: case 188:
	self.$ = $$[$0-2].concat($$[$0]);
	break;
	case 50:
	self.$ = new yy.Identifier($$[$0]);
	break;
	case 51: case 52:
	self.$ = new yy.Ivar($$[$0]);
	break;
	case 53:
	self.$ = new yy.Gvar($$[$0]);
	break;
	case 54:
	self.$ = new yy.Const($$[$0]);
	break;
	case 55:
	self.$ = new yy.Argvar($$[$0]);
	break;
	case 56:
	self.$ = new yy.Symbol($$[$0]);
	break;
	case 57:
	self.$ = new yy.Num($$[$0]);
	break;
	case 58:
	self.$ = new yy.Str($$[$0]);
	break;
	case 61:
	self.$ = new yy.InterpolatedString([],{open: $$[$0]});
	break;
	case 62:
	self.$ = $$[$0-1].add($$[$0]);
	break;
	case 63:
	self.$ = $$[$0] ? ($$[$0-1].add($$[$0])) : ($$[$0-1]);
	break;
	case 64:
	self.$ = $$[$0-1].option('close',$$[$0]);
	break;
	case 65:
	self.$ = null;
	break;
	case 66: case 92: case 95: case 120: case 147: case 163: case 176: case 282:
	self.$ = $$[$0-1];
	break;
	case 69:
	self.$ = new yy.RegExp($$[$0]);
	break;
	case 70:
	self.$ = new yy.Bool($$[$0]);
	break;
	case 71:
	self.$ = yy.TRUE;
	break;
	case 72:
	self.$ = yy.FALSE;
	break;
	case 73:
	self.$ = yy.NIL;
	break;
	case 74:
	self.$ = yy.UNDEFINED;
	break;
	case 75: case 76:
	self.$ = new yy.Return($$[$0]);
	break;
	case 77:
	self.$ = new yy.Return();
	break;
	case 78:
	self.$ = new yy.Selector([],{type: $$[$0]});
	break;
	case 79:
	self.$ = $$[$0-1].add(new yy.SelectorType($$[$0]),'tag');
	break;
	case 80:
	self.$ = $$[$0-1].add(new yy.SelectorNamespace($$[$0]),'ns');
	break;
	case 81:
	self.$ = $$[$0-1].add(new yy.SelectorId($$[$0]),'id');
	break;
	case 82:
	self.$ = $$[$0-1].add(new yy.SelectorClass($$[$0]),'class');
	break;
	case 83:
	self.$ = $$[$0-4].add(new yy.SelectorClass($$[$0-1]),'class');
	break;
	case 84:
	self.$ = $$[$0-4].add(new yy.SelectorId($$[$0-1]),'id');
	break;
	case 85:
	self.$ = $$[$0-1].add(new yy.SelectorCombinator($$[$0]),'sep');
	break;
	case 86:
	self.$ = $$[$0-1].add(new yy.SelectorPseudoClass($$[$0]),'pseudoclass');
	break;
	case 87:
	self.$ = $$[$0-1].group();
	break;
	case 88:
	self.$ = $$[$0-1].add(new yy.SelectorUniversal($$[$0]),'universal');
	break;
	case 89:
	self.$ = $$[$0-3].add(new yy.SelectorAttribute($$[$0-1]),'attr');
	break;
	case 90:
	self.$ = $$[$0-5].add(new yy.SelectorAttribute($$[$0-3],$$[$0-2],$$[$0-1]),'attr');
	break;
	case 91: case 100: case 101: case 132: case 133:
	self.$ = new yy.TagTypeIdentifier($$[$0]);
	break;
	case 96:
	self.$ = $$[$0-2].set({attributes: $$[$0-1],open: $$[$0-3],close: $$[$0]});
	break;
	case 97:
	self.$ = $$[$0-3].set({attributes: $$[$0-2],body: $$[$0],open: $$[$0-4],close: $$[$0-1]});
	break;
	case 98:
	self.$ = new yy.TagWrapper($$[$0-2],$$[$0-4],$$[$0]);
	break;
	case 102:
	self.$ = new yy.TagTypeIdentifier('div');
	break;
	case 103:
	self.$ = new yy.Tag({type: $$[$0]});
	break;
	case 104:
	self.$ = $$[$0-2].addSymbol($$[$0]);
	break;
	case 105:
	self.$ = $$[$0-3].addIndex($$[$0-1]);
	break;
	case 106:
	self.$ = $$[$0-2].addClass($$[$0]);
	break;
	case 107:
	self.$ = $$[$0-4].addClass($$[$0-1]);
	break;
	case 108:
	self.$ = $$[$0-4].set({key: $$[$0-1]});
	break;
	case 109:
	self.$ = $$[$0-2].set({id: $$[$0]});
	break;
	case 110:
	self.$ = $$[$0-1].set({ivar: $$[$0]});
	break;
	case 111:
	self.$ = $$[$0-4].set({id: $$[$0-1]});
	break;
	case 112: case 179: case 186:
	self.$ = [];
	break;
	case 115:
	self.$ = $$[$0-3].concat($$[$0]);
	break;
	case 116:
	self.$ = new yy.TagAttr($$[$0],$$[$0]);
	break;
	case 117:
	self.$ = new yy.TagAttr($$[$0-2],$$[$0],$$[$0-1]);
	break;
	case 121:
	self.$ = new yy.TagDesc($$[$0]);
	break;
	case 122:
	self.$ = $$[$0-2].classes($$[$0]);
	break;
	case 124:
	self.$ = $$[$0].set({extension: true});
	break;
	case 125:
	self.$ = $$[$0].set({local: true});
	break;
	case 126:
	self.$ = new yy.TagDeclaration($$[$0]).set({keyword: $$[$0-1]});
	break;
	case 127:
	self.$ = new yy.TagDeclaration($$[$0-1],null,$$[$0]).set({keyword: $$[$0-2]});
	break;
	case 128:
	self.$ = new yy.TagDeclaration($$[$0-2],$$[$0]).set({keyword: $$[$0-3]});
	break;
	case 129:
	self.$ = new yy.TagDeclaration($$[$0-3],$$[$0-1],$$[$0]).set({keyword: $$[$0-4]});
	break;
	case 131:
	self.$ = ['yy.extend'];
	break;
	case 134: case 135:
	self.$ = new yy.TagId($$[$0]);
	break;
	case 136:
	self.$ = new yy.Assign($$[$0-1],$$[$0-2],$$[$0]);
	break;
	case 137:
	self.$ = new yy.Assign($$[$0-3],$$[$0-4],$$[$0-1].indented($$[$0-2],$$[$0]));
	break;
	case 138:
	self.$ = new yy.ObjAttr($$[$0]);
	break;
	case 139:
	self.$ = new yy.ObjAttr($$[$0-2],$$[$0],'object');
	break;
	case 140:
	self.$ = new yy.ObjAttr($$[$0-4],$$[$0-1].indented($$[$0-2],$$[$0]),'object');
	break;
	case 148:
	self.$ = new yy.Comment($$[$0],true);
	break;
	case 149:
	self.$ = new yy.Comment($$[$0],false);
	break;
	case 153:
	self.$ = new yy.Begin($$[$0]);
	break;
	case 154:
	self.$ = new yy.Lambda([],$$[$0],null,null,{bound: true});
	break;
	case 155:
	self.$ = new yy.Lambda($$[$0-2],$$[$0],null,null,{bound: true});
	break;
	case 156:
	self.$ = new yy.Lambda($$[$0-3],$$[$0-1],null,null,{bound: true});
	break;
	case 157:
	self.$ = new yy.PropertyDeclaration($$[$0-1],$$[$0],$$[$0-2]);
	break;
	case 158:
	self.$ = new yy.PropertyDeclaration($$[$0-3],$$[$0-1],$$[$0-4]);
	break;
	case 159:
	self.$ = new yy.PropertyDeclaration($$[$0],null,$$[$0-1]);
	break;
	case 164:
	self.$ = $$[$0-3];
	break;
	case 166: case 252:
	self.$ = $$[$0].set({global: $$[$0-1]});
	break;
	case 167: case 202: case 253:
	self.$ = $$[$0].set({export: $$[$0-1]});
	break;
	case 168:
	self.$ = new yy.MethodDeclaration($$[$0-2],$$[$0],$$[$0-4],$$[$0-6],$$[$0-5]).set({def: $$[$0-7]});
	break;
	case 169:
	self.$ = new yy.MethodDeclaration([],$$[$0],$$[$0-1],$$[$0-3],$$[$0-2]).set({def: $$[$0-4]});
	break;
	case 170:
	self.$ = new yy.MethodDeclaration($$[$0-2],$$[$0],$$[$0-4],null).set({def: $$[$0-5]});
	break;
	case 171:
	self.$ = new yy.MethodDeclaration([],$$[$0],$$[$0-1],null).set({def: $$[$0-2]});
	break;
	case 172:
	self.$ = {static: true};
	break;
	case 173:
	self.$ = {};
	break;
	case 178:
	self.$ = $$[$0].body();
	break;
	case 189:
	self.$ = new yy.NamedParams($$[$0]);
	break;
	case 190:
	self.$ = new yy.ArrayParams($$[$0]);
	break;
	case 191:
	self.$ = new yy.RequiredParam($$[$0]);
	break;
	case 192:
	self.$ = new yy.SplatParam($$[$0],null,$$[$0-1]);
	break;
	case 193: case 194:
	self.$ = new yy.BlockParam($$[$0],null,$$[$0-1]);
	break;
	case 195:
	self.$ = new yy.OptionalParam($$[$0-2],$$[$0],$$[$0-1]);
	break;
	case 197:
	self.$ = yy.SPLAT($$[$0]);
	break;
	case 198: case 201:
	self.$ = yy.SPLAT(new yy.VarReference($$[$0],$$[$0-2]),$$[$0-1]);
	break;
	case 199: case 200:
	self.$ = new yy.VarReference($$[$0],$$[$0-1]);
	break;
	case 209:
	self.$ = new yy.IvarAccess('.',null,$$[$0]);
	break;
	case 214:
	self.$ = new yy.VarOrAccess($$[$0]);
	break;
	case 215:
	self.$ = new yy.New($$[$0-2]);
	break;
	case 216:
	self.$ = new yy.SuperAccess('.',$$[$0-2],$$[$0]);
	break;
	case 217:
	self.$ = new yy.PropertyAccess($$[$0-1],$$[$0-2],$$[$0]);
	break;
	case 218: case 219: case 220: case 222:
	self.$ = new yy.Access($$[$0-1],$$[$0-2],$$[$0]);
	break;
	case 221:
	self.$ = new yy.Access('.',$$[$0-2],new yy.Identifier($$[$0].value()));
	break;
	case 223:
	self.$ = new yy.IndexAccess('.',$$[$0-3],$$[$0-1]);
	break;
	case 226:
	self.$ = yy.SUPER;
	break;
	case 230:
	self.$ = new yy.Await($$[$0]).set({keyword: $$[$0-1]});
	break;
	case 236:
	self.$ = yy.ARGUMENTS;
	break;
	case 241:
	self.$ = new yy.Index($$[$0]);
	break;
	case 242:
	self.$ = new yy.Slice($$[$0]);
	break;
	case 243:
	self.$ = new yy.Obj($$[$0-2],$$[$0-3].generated);
	break;
	case 244:
	self.$ = new yy.AssignList([]);
	break;
	case 245:
	self.$ = new yy.AssignList([$$[$0]]);
	break;
	case 246: case 278:
	self.$ = $$[$0-2].add($$[$0]);
	break;
	case 247: case 279:
	self.$ = $$[$0-3].add($$[$0-1]).add($$[$0]);
	break;
	case 248:
	self.$ = $$[$0-5].concat($$[$0-2].indented($$[$0-3],$$[$0]));
	break;
	case 250:
	self.$ = $$[$0].set({extension: $$[$0-1]});
	break;
	case 251:
	self.$ = $$[$0].set({local: $$[$0-1]});
	break;
	case 254:
	self.$ = $$[$0].set({export: $$[$0-2],local: $$[$0-1]});
	break;
	case 255:
	self.$ = new yy.ClassDeclaration($$[$0],null,[]).set({keyword: $$[$0-1]});
	break;
	case 256:
	self.$ = new yy.ClassDeclaration($$[$0-1],null,$$[$0]).set({keyword: $$[$0-2]});
	break;
	case 257:
	self.$ = new yy.ClassDeclaration($$[$0-2],$$[$0],[]).set({keyword: $$[$0-3]});
	break;
	case 258:
	self.$ = new yy.ClassDeclaration($$[$0-3],$$[$0-1],$$[$0]).set({keyword: $$[$0-4]});
	break;
	case 259:
	self.$ = new yy.Module($$[$0]);
	break;
	case 260:
	self.$ = new yy.Module($$[$0-1],null,$$[$0]);
	break;
	case 261:
	self.$ = new yy.Call($$[$0-2],$$[$0],$$[$0-1]);
	break;
	case 262:
	self.$ = $$[$0-1].addBlock($$[$0]);
	break;
	case 263:
	self.$ = false;
	break;
	case 264:
	self.$ = true;
	break;
	case 265:
	self.$ = new yy.ArgList([]);
	break;
	case 266:
	self.$ = $$[$0-2];
	break;
	case 267:
	self.$ = new yy.This($$[$0]);
	break;
	case 268:
	self.$ = new yy.Self($$[$0]);
	break;
	case 269:
	self.$ = new yy.Arr(new yy.ArgList([]));
	break;
	case 270:
	self.$ = new yy.Arr($$[$0-2]);
	break;
	case 271:
	self.$ = '..';
	break;
	case 272:
	self.$ = '...';
	break;
	case 273:
	self.$ = yy.OP($$[$0-2],$$[$0-3],$$[$0-1]);
	break;
	case 274:
	self.$ = new yy.Range($$[$0-2],$$[$0],$$[$0-1]);
	break;
	case 275:
	self.$ = new yy.Range($$[$0-1],null,$$[$0]);
	break;
	case 276:
	self.$ = new yy.Range(null,$$[$0],$$[$0-1]);
	break;
	case 277:
	self.$ = new yy.ArgList([$$[$0]]);
	break;
	case 280:
	self.$ = $$[$0-2].indented($$[$0-3],$$[$0]);
	break;
	case 281:
	self.$ = $$[$0-5].concat($$[$0-2]);
	break;
	case 289:
	self.$ = [].concat($$[$0-2],$$[$0]);
	break;
	case 290:
	self.$ = new yy.Try($$[$0]);
	break;
	case 291:
	self.$ = new yy.Try($$[$0-1],$$[$0]);
	break;
	case 292:
	self.$ = new yy.Try($$[$0-1],null,$$[$0]);
	break;
	case 293:
	self.$ = new yy.Try($$[$0-2],$$[$0-1],$$[$0]);
	break;
	case 294:
	self.$ = new yy.Finally($$[$0]);
	break;
	case 295:
	self.$ = new yy.Catch($$[$0],$$[$0-1]);
	break;
	case 296:
	self.$ = new yy.Throw($$[$0]);
	break;
	case 297:
	self.$ = new yy.Parens($$[$0-1],$$[$0-2],$$[$0]);
	break;
	case 298:
	self.$ = new yy.Parens($$[$0-2],$$[$0-4],$$[$0]);
	break;
	case 299:
	self.$ = new yy.While($$[$0]);
	break;
	case 300:
	self.$ = new yy.While($$[$0-2],{guard: $$[$0]});
	break;
	case 301:
	self.$ = new yy.While($$[$0],{invert: true});
	break;
	case 302:
	self.$ = new yy.While($$[$0-2],{invert: true,guard: $$[$0]});
	break;
	case 303: case 311: case 314:
	self.$ = $$[$0-1].addBody($$[$0]);
	break;
	case 304: case 305:
	self.$ = $$[$0].addBody(yy.Block.wrap([$$[$0-1]]));
	break;
	case 307:
	self.$ = new yy.While(new yy.Literal('true')).addBody($$[$0]);
	break;
	case 308:
	self.$ = new yy.While(new yy.Literal('true')).addBody(yy.Block.wrap([$$[$0]]));
	break;
	case 309: case 310:
	self.$ = $$[$0].addBody([$$[$0-1]]);
	break;
	case 315:
	self.$ = {source: new yy.ValueNode($$[$0])};
	break;
	case 316:
	self.$ = $$[$0].configure({own: $$[$0-1].own,name: $$[$0-1][0],index: $$[$0-1][1],keyword: $$[$0-1].keyword});
	break;
	case 317:
	self.$ = ($$[$0].keyword = $$[$0-1]) && $$[$0];
	break;
	case 318:
	self.$ = ($$[$0].own = true) && ($$[$0].keyword = $$[$0-2]) && $$[$0];
	break;
	case 320: case 321:
	self.$ = new yy.ValueNode($$[$0]);
	break;
	case 323:
	self.$ = [$$[$0-2],$$[$0]];
	break;
	case 324:
	self.$ = new yy.ForIn({source: $$[$0]});
	break;
	case 325:
	self.$ = new yy.ForOf({source: $$[$0],object: true});
	break;
	case 326:
	self.$ = new yy.ForIn({source: $$[$0-2],guard: $$[$0]});
	break;
	case 327:
	self.$ = new yy.ForOf({source: $$[$0-2],guard: $$[$0],object: true});
	break;
	case 328:
	self.$ = new yy.ForIn({source: $$[$0-2],step: $$[$0]});
	break;
	case 329:
	self.$ = new yy.ForIn({source: $$[$0-4],guard: $$[$0-2],step: $$[$0]});
	break;
	case 330:
	self.$ = new yy.ForIn({source: $$[$0-4],step: $$[$0-2],guard: $$[$0]});
	break;
	case 331:
	self.$ = new yy.Switch($$[$0-3],$$[$0-1]);
	break;
	case 332:
	self.$ = new yy.Switch($$[$0-5],$$[$0-3],$$[$0-1]);
	break;
	case 333:
	self.$ = new yy.Switch(null,$$[$0-1]);
	break;
	case 334:
	self.$ = new yy.Switch(null,$$[$0-3],$$[$0-1]);
	break;
	case 336:
	self.$ = $$[$0-1].concat($$[$0]);
	break;
	case 337:
	self.$ = [new yy.SwitchCase($$[$0-1],$$[$0])];
	break;
	case 338:
	self.$ = [new yy.SwitchCase($$[$0-2],$$[$0-1])];
	break;
	case 339:
	self.$ = new yy.If($$[$0-1],$$[$0],{type: $$[$0-2]});
	break;
	case 340:
	self.$ = $$[$0-4].addElse(new yy.If($$[$0-1],$$[$0],{type: $$[$0-2]}));
	break;
	case 341:
	self.$ = $$[$0-3].addElse(new yy.If($$[$0-1],$$[$0],{type: $$[$0-2]}));
	break;
	case 342:
	self.$ = $$[$0-2].addElse($$[$0]);
	break;
	case 344:
	self.$ = new yy.If($$[$0],new yy.Block([$$[$0-2]]),{type: $$[$0-1],statement: true});
	break;
	case 345:
	self.$ = new yy.If($$[$0],new yy.Block([$$[$0-2]]),{type: $$[$0-1]});
	break;
	case 346:
	self.$ = yy.If.ternary($$[$0-4],$$[$0-2],$$[$0]);
	break;
	case 347: case 348:
	self.$ = yy.OP($$[$0-1],$$[$0]);
	break;
	case 349:
	self.$ = new yy.Op('-',$$[$0]);
	break;
	case 350:
	self.$ = new yy.Op('+',$$[$0]);
	break;
	case 351:
	self.$ = new yy.UnaryOp('--',null,$$[$0]);
	break;
	case 352:
	self.$ = new yy.UnaryOp('++',null,$$[$0]);
	break;
	case 353:
	self.$ = new yy.UnaryOp('--',$$[$0-1],null,true);
	break;
	case 354:
	self.$ = new yy.UnaryOp('++',$$[$0-1],null,true);
	break;
	case 355: case 356:
	self.$ = new yy.Op($$[$0-1],$$[$0-2],$$[$0]);
	break;
	case 357: case 358: case 359: case 360:
	self.$ = yy.OP($$[$0-1],$$[$0-2],$$[$0]);
	break;
	case 361:
	self.$ = (function () {
					if ($$[$0-1].charAt(0) == '!') {
						return yy.OP($$[$0-1].slice(1),$$[$0-2],$$[$0]).invert();
					} else {
						return yy.OP($$[$0-1],$$[$0-2],$$[$0]);
					};
				}());
	break;
	case 362:
	self.$ = yy.OP_COMPOUND($$[$0-1]._value,$$[$0-1],$$[$0-2],$$[$0]);
	break;
	case 363:
	self.$ = yy.OP_COMPOUND($$[$0-3]._value,$$[$0-4],$$[$0-1].indented($$[$0-2],$$[$0]));
	break;
	}
	},
	table: [{1:[2,1],3:1,4:2,5:3,7:$V0,8:5,10:$V1,12:7,13:8,15:9,16:10,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{1:[3]},{1:[2,2],6:$V51,9:133},{6:[1,135]},o($V61,[2,4]),o($V61,[2,5],{14:$V71}),{4:138,6:[1,139],7:$V0,8:5,11:[1,137],12:7,13:8,15:9,16:10,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($V81,[2,12]),o($V81,[2,13],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($V81,[2,16]),o($V81,[2,17],{218:108,222:109,211:152,217:153,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vi1}),{13:154,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vj1,[2,34]),o($Vj1,[2,35],{195:156,141:157,179:159,21:$Vk1,88:$Vl1,89:$Vm1,111:$Vn1,144:$VC,180:$Vo1,181:$Vp1,183:$Vq1,196:$Vr1}),o($Vj1,[2,36]),o($Vj1,[2,37]),o($Vj1,[2,38]),o($Vj1,[2,39]),o($Vj1,[2,40]),o($Vj1,[2,41]),o($Vj1,[2,42]),o($Vj1,[2,43]),o($Vj1,[2,44]),o($Vj1,[2,45]),o($Vj1,[2,46]),o($Vj1,[2,47]),o($Vj1,[2,48]),o($Vj1,[2,49]),o($Vs1,[2,148]),o($Vs1,[2,149]),o($Vt1,[2,18]),o($Vt1,[2,19]),o($Vt1,[2,20]),o($Vt1,[2,21],{21:[1,166]}),o($Vt1,[2,23],{21:[1,167]}),o($Vt1,[2,25]),o($Vt1,[2,26]),{13:168,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vu1,$Vv1,{117:[1,169]}),o($Vu1,[2,232]),o($Vu1,[2,233]),o($Vu1,[2,234]),o($Vu1,[2,235]),o($Vu1,[2,236]),o($Vu1,[2,237]),o($Vu1,[2,238]),o($Vu1,[2,239]),o($Vu1,[2,240]),o($Vj1,[2,150]),o($Vj1,[2,151]),o($Vj1,[2,152]),{13:170,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:171,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:172,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:173,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{32:$V7,35:175,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,82:92,83:$Vp,89:$Vw1,91:$Vr,96:$Vs,101:46,109:101,129:45,130:$Vx,131:177,136:$Vy,150:77,154:$VF,157:$Vx1,166:44,168:76,173:102,175:$VK,176:174,178:39,184:$VL,186:41,187:42,188:$VN,189:47,197:$VQ,198:$VR},{32:$V7,35:175,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,82:92,83:$Vp,89:$Vw1,91:$Vr,96:$Vs,101:46,109:101,129:45,130:$Vx,131:177,136:$Vy,150:77,154:$VF,157:$Vx1,166:44,168:76,173:102,175:$VK,176:179,178:39,184:$VL,186:41,187:42,188:$VN,189:47,197:$VQ,198:$VR},o($Vy1,$Vz1,{244:[1,180],245:[1,181],249:[1,182]}),o($Vj1,[2,343],{232:[1,183],237:[1,184]}),{5:185,10:$V1},{5:186,10:$V1},o($Vj1,[2,306]),{5:187,10:$V1},{10:[1,189],13:188,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vj1,[2,249]),{121:191,124:$Vw,192:190,193:$VO},{121:193,124:$Vw,192:192,193:$VO},{155:195,158:$VI,192:194,193:$VO},{123:[1,197],154:$VF,155:198,157:$Vx1,158:$VI,173:199,175:$VK,192:196,193:$VO},{32:$V7,35:175,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,82:92,83:$Vp,89:$Vw1,91:$Vr,96:$Vs,101:46,109:101,129:45,130:$Vx,131:177,136:$Vy,150:77,154:$VF,157:$Vx1,166:44,168:76,173:102,175:$VK,176:200,178:39,184:$VL,186:41,187:42,188:$VN,189:47,197:$VQ,198:$VR},o($Vj1,[2,123]),o($VA1,[2,102],{104:201,108:203,109:204,51:[1,205],89:[1,202],110:[1,206],198:$VR}),{50:208,51:$V8,89:[1,209],149:207},o($Vt1,[2,77],{34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,17:30,18:31,25:36,131:38,178:39,72:40,186:41,187:42,166:44,129:45,101:46,189:47,140:48,141:49,142:50,176:57,235:58,211:60,215:61,217:62,192:64,121:70,148:72,168:76,150:77,63:79,82:92,155:93,57:97,52:98,55:99,59:100,109:101,173:102,50:103,218:108,222:109,61:116,65:117,16:155,13:210,81:211,19:$V2,20:$V3,21:$VB1,23:$V4,24:$V5,26:$V6,32:$V7,51:$V8,53:$V9,54:$Va,56:$Vb,58:$Vc,60:$Vd,62:$Ve,64:$Vf,66:$Vg,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,83:$Vp,89:$Vq,91:$Vr,96:$Vs,103:$Vt,122:$Vu,123:$Vv,124:$Vw,130:$Vx,136:$Vy,143:$VB,144:$VC,151:$VD,152:$VE,154:$VF,156:$VG,157:$VH,158:$VI,175:$VK,184:$VL,185:$VM,188:$VN,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,216:$VW,230:$VZ,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41}),{13:213,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{27:214,29:215,31:216,32:$VC1,33:218,50:220,51:$V8,57:219,58:$Vc},o($Vy1,[2,228]),o($Vy1,[2,229]),o($VD1,[2,226]),o($Vu1,[2,67]),o($Vu1,[2,68]),o($Vu1,[2,69]),o($Vu1,[2,70]),o($Vu1,[2,71]),o($Vu1,[2,72]),o($Vu1,[2,73]),o($Vu1,[2,74]),{4:221,7:$V0,8:5,10:[1,222],12:7,13:8,15:9,16:10,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{10:$VE1,12:228,13:223,15:230,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,97:$VF1,101:46,103:$Vt,109:101,119:225,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,171:$VG1,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,202:226,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o([1,6,10,11,14,21,22,71,88,89,90,91,97,106,111,112,126,135,137,144,147,171,180,181,183,196,200,201,212,213,214,219,220,229,238,239,242,243,246,247,248],[2,267]),o($Vu1,[2,134]),{50:231,51:$V8},{84:233,85:[1,234],86:[1,235],87:[1,236],88:[1,237],91:[1,238],92:[1,239],93:[1,240],94:[1,241],95:[1,242],96:[1,243],100:[1,244],102:[1,232]},o($Vj1,[2,165]),{5:245,10:$V1,145:[1,246]},o($VH1,$VI1,{61:116,65:117,191:248,133:249,134:250,15:251,50:252,57:253,63:254,52:255,55:256,32:$V7,51:$V8,53:$V9,54:$Va,56:$Vb,58:$Vc,62:$Ve,64:$Vf,66:$Vg,136:$VJ1,138:$Vz,139:$VA,145:$VK1}),{5:258,10:$V1},o($VD1,[2,208]),o($VD1,[2,209]),o($VD1,[2,210]),o($VD1,[2,211]),o($VD1,[2,212]),o($VD1,[2,213]),o($VD1,[2,214]),{13:259,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:260,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:261,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{5:262,10:$V1,13:263,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{50:268,51:$V8,89:$Vw1,96:$Vs,150:270,168:269,187:264,224:265,225:[1,266],226:267},{223:271,227:[1,272],228:[1,273]},{32:$V7,35:175,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,82:92,83:$Vp,89:$Vw1,91:$Vr,96:$Vs,101:46,109:101,129:45,130:$Vx,131:177,136:$Vy,150:77,154:$VF,157:$Vx1,166:44,168:76,173:102,175:$VK,176:274,178:39,184:$VL,186:41,187:42,188:$VN,189:47,197:$VQ,198:$VR},{110:$VL1,125:275,128:$VM1},o($VN1,[2,160]),o($VN1,[2,161]),o($Vu1,[2,57]),o($Vu1,[2,58]),o($Vu1,[2,59]),o($Vu1,[2,60],{68:279,67:[1,278],69:[1,280],70:[1,281]}),o($VO1,[2,78]),{50:287,51:$V8,55:286,56:$Vb,57:288,58:$Vc,89:$VP1,109:285,159:282,161:283,166:284,197:$VQ,198:$VR},o([1,6,10,11,14,21,22,28,71,88,89,90,91,97,106,111,112,117,126,135,137,144,147,164,165,171,180,181,183,196,200,201,212,213,214,219,220,229,238,239,242,243,244,245,246,247,248,249],[2,54]),o($VQ1,[2,51]),o($VQ1,[2,52]),o([1,6,10,11,14,21,22,71,88,89,90,91,97,106,111,112,117,126,135,137,144,147,171,180,181,183,196,200,201,212,213,214,219,220,229,238,239,242,243,244,245,246,247,248,249],[2,53]),o($VD1,[2,55]),o($VQ1,[2,268]),{50:293,51:$V8,57:292,58:$Vc,96:$VR1,168:294,170:[1,290],174:291},{50:293,51:$V8,57:292,58:$Vc,96:$VR1,168:294,170:[1,297],174:296},o([1,6,10,11,14,21,22,28,71,88,89,90,91,97,98,106,111,112,117,126,135,137,144,147,164,165,171,180,181,183,196,200,201,212,213,214,219,220,227,228,229,238,239,242,243,244,245,246,247,248,249],[2,50]),o($VS1,[2,312]),o($VS1,[2,313]),o($VD1,[2,56]),o($VT1,[2,61]),o($V61,[2,7],{12:7,13:8,15:9,16:10,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,17:30,18:31,25:36,131:38,178:39,72:40,186:41,187:42,166:44,129:45,101:46,189:47,140:48,141:49,142:50,176:57,235:58,211:60,215:61,217:62,192:64,121:70,148:72,168:76,150:77,63:79,82:92,155:93,57:97,52:98,55:99,59:100,109:101,173:102,50:103,218:108,222:109,61:116,65:117,8:298,19:$V2,20:$V3,23:$V4,24:$V5,26:$V6,32:$V7,51:$V8,53:$V9,54:$Va,56:$Vb,58:$Vc,60:$Vd,62:$Ve,64:$Vf,66:$Vg,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,83:$Vp,89:$Vq,91:$Vr,96:$Vs,103:$Vt,122:$Vu,123:$Vv,124:$Vw,130:$Vx,136:$Vy,138:$Vz,139:$VA,143:$VB,144:$VC,151:$VD,152:$VE,154:$VF,156:$VG,157:$VH,158:$VI,170:$VJ,175:$VK,184:$VL,185:$VM,188:$VN,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,212:$VU,214:$VV,216:$VW,219:$VX,220:$VY,230:$VZ,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41}),o([1,6,11,19,20,23,24,26,32,51,53,54,56,58,60,62,64,66,73,74,75,76,77,78,79,80,83,89,91,96,103,122,123,124,130,136,137,138,139,143,144,151,152,154,156,157,158,170,171,175,184,185,188,193,194,197,198,204,210,212,214,216,219,220,230,236,240,241,242,243,244,245],[2,8]),{1:[2,3]},{12:300,13:299,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($VU1,[2,9]),{6:$V51,9:133,11:[1,301]},{4:302,7:$V0,8:5,12:7,13:8,15:9,16:10,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:303,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:304,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:305,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:306,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:307,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:308,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:309,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:310,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:311,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vj1,[2,305]),o($Vj1,[2,310]),{13:312,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vj1,[2,304]),o($Vj1,[2,309]),o([1,6,10,11,14,22,97,137],[2,197],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),{211:152,212:$VU,214:$VV,217:153,218:108,219:$VX,220:$VY,222:109,238:$Vi1},{21:$VB1,81:313},o($Vu1,[2,262]),o($VV1,[2,224],{178:315,61:316,62:$Ve,177:[1,314],184:$VL}),{50:317,51:$V8,52:318,53:$V9,54:$Va,57:319,58:$Vc},{50:320,51:$V8},{50:321,51:$V8},{13:323,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,182:322,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,190:324,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,199:325,200:$VW1,201:$VX1,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{21:[2,264]},{145:$VK1},o($VV1,[2,225]),{13:328,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:329,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($VY1,[2,230],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),{10:[1,331],13:330,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vj1,[2,347],{218:108,222:109,211:149,217:150}),o($Vj1,[2,348],{218:108,222:109,211:149,217:150}),o($Vj1,[2,349],{218:108,222:109,211:149,217:150}),o($Vj1,[2,350],{218:108,222:109,211:149,217:150}),o($Vj1,[2,351],{21:$Vz1,88:$Vz1,89:$Vz1,111:$Vz1,144:$Vz1,180:$Vz1,181:$Vz1,183:$Vz1,196:$Vz1}),{21:$Vk1,88:$Vl1,89:$Vm1,111:$Vn1,141:157,144:$VC,179:159,180:$Vo1,181:$Vp1,183:$Vq1,195:156,196:$Vr1},{154:$VF,157:$Vx1,173:199,175:$VK},o([21,88,89,111,144,180,181,183,196],$Vv1),o($VH1,$VI1,{61:116,65:117,191:248,133:249,134:250,15:251,50:252,57:253,63:254,52:255,55:256,32:$V7,51:$V8,53:$V9,54:$Va,56:$Vb,58:$Vc,62:$Ve,64:$Vf,66:$Vg,136:$VJ1,138:$Vz,139:$VA}),o($Vj1,[2,352],{21:$Vz1,88:$Vz1,89:$Vz1,111:$Vz1,144:$Vz1,180:$Vz1,181:$Vz1,183:$Vz1,196:$Vz1}),o($Vj1,[2,353]),o($Vj1,[2,354]),{10:[1,333],13:332,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{5:335,10:$V1,236:[1,334]},{13:336,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vj1,[2,290],{205:337,206:338,207:$VZ1,208:[1,339]}),o($Vj1,[2,303]),o($Vj1,[2,311]),{10:[1,341],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},{231:342,233:343,234:$V_1},o($Vj1,[2,250]),o($Vj1,[2,124]),o($Vj1,[2,251]),o($Vj1,[2,125]),o($Vj1,[2,252]),o($Vj1,[2,166]),o($Vj1,[2,253]),{192:345,193:$VO},o($Vj1,[2,167]),o($VD1,[2,202]),o($V$1,[2,259],{5:346,10:$V1,21:$Vz1,88:$Vz1,89:$Vz1,111:$Vz1,144:$Vz1,180:$Vz1,181:$Vz1,183:$Vz1,196:$Vz1}),o($V02,[2,112],{105:347,52:352,114:353,53:$V9,54:$Va,88:[1,348],91:[1,351],111:[1,349],113:[1,350],116:$V12}),{13:355,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($VA1,[2,103]),o($VA1,[2,99]),o($VA1,[2,100]),o($VA1,[2,101]),o($Vj1,[2,159],{150:356,21:[1,357],89:$Vw1}),o($V22,[2,162]),{13:358,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vt1,[2,75],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($Vt1,[2,76]),{10:$VE1,12:228,13:361,15:230,16:155,17:30,18:31,19:$V2,20:$V3,22:[1,359],23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,119:360,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,171:$VG1,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,202:226,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vt1,[2,296],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),{14:[1,363],28:[1,362]},o($Vt1,[2,29],{30:[1,364]}),o($V32,[2,31]),o([1,6,11,14,30,137,212,214,219,220,238],[2,30]),o($V42,[2,33]),o($V42,[2,203]),o($V42,[2,204]),{6:$V51,9:133,137:[1,365]},{4:366,7:$V0,8:5,12:7,13:8,15:9,16:10,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o([6,10,14,97],$V52,{218:108,222:109,211:149,217:150,199:367,126:$V91,171:$Va1,200:$VW1,201:$VX1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($V62,[2,269]),o([6,10,97],$V72,{115:368,14:$V82}),o($V92,[2,277]),{10:$VE1,12:228,13:361,15:230,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,119:370,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,171:$VG1,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,202:226,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($V92,[2,285]),o($V92,[2,286]),o($V92,[2,287]),o($Vu1,[2,135]),o($Vu1,[2,92]),o($VO1,[2,79]),o($VO1,[2,80]),o($VO1,[2,81]),o($VO1,[2,82]),{89:[1,371]},{89:[1,372]},o($VO1,[2,85]),o($VO1,[2,86]),o($VO1,[2,87]),o($VO1,[2,88]),{50:373,51:$V8},o($VO1,[2,91]),o($Vu1,[2,154]),o($Va2,$Vb2,{146:374,167:375,150:376,168:377,169:378,50:382,51:$V8,89:$Vw1,96:$VR1,170:$Vc2,171:$Vd2,172:$Ve2}),o($Va2,$Vb2,{167:375,150:376,168:377,169:378,50:382,146:383,51:$V8,89:$Vw1,96:$VR1,170:$Vc2,171:$Vd2,172:$Ve2}),o([6,10,90],$V72,{115:384,14:$Vf2}),o($Vg2,[2,245]),o($Vg2,[2,138],{135:[1,386]}),o($Vg2,[2,141]),o($Vh2,[2,142]),o($Vh2,[2,143]),o($Vh2,[2,144]),o($Vh2,[2,145]),o($Vh2,[2,146]),{13:387,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vj1,[2,153]),{5:388,10:$V1,126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($Vi2,[2,299],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,213:[1,389],214:$VV,219:$VX,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($Vi2,[2,301],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,213:[1,390],214:$VV,219:$VX,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($Vj1,[2,307]),o($Vj2,[2,308],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($Vj1,[2,315]),o($Vk2,[2,317]),{50:268,51:$V8,89:$Vw1,96:$VR1,150:270,168:269,224:391,226:267},o($Vk2,[2,322],{14:[1,392]}),o($Vl2,[2,319]),o($Vl2,[2,320]),o($Vl2,[2,321]),o($Vj1,[2,316]),{13:393,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:394,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vm2,[2,255],{5:395,10:$V1,21:$Vz1,88:$Vz1,89:$Vz1,111:$Vz1,144:$Vz1,180:$Vz1,181:$Vz1,183:$Vz1,196:$Vz1,126:[1,396]}),o($Vm2,[2,126],{5:397,10:$V1,126:[1,398]}),o($Vj1,[2,132]),o($Vj1,[2,133]),o($VT1,[2,62]),o($VT1,[2,63]),o($VT1,[2,64]),{13:400,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,71:[1,399],72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{88:[1,402],91:[1,403],160:401},o($Vn2,[2,180],{162:405,21:[1,404],164:$Vo2,165:$Vp2}),o($Vn2,[2,181]),o($Vn2,[2,182]),o($Vn2,[2,183]),o($Vq2,[2,174]),o($Vq2,[2,175]),{13:408,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{50:293,51:$V8,57:292,58:$Vc,96:$VR1,168:294,174:409},o($VD1,[2,199]),o($VD1,[2,205]),o($VD1,[2,206]),o($VD1,[2,207]),{10:$VE1,12:228,13:361,15:230,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,97:$VF1,101:46,103:$Vt,109:101,119:225,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,171:$VG1,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,202:226,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($VD1,[2,200]),{50:293,51:$V8,57:292,58:$Vc,96:$VR1,168:294,174:410},o($V61,[2,6],{14:$V71}),o($V81,[2,14],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($V81,[2,15]),o($VU1,[2,10]),{6:$V51,9:133,11:[1,411]},o($Vr2,[2,355],{218:108,222:109,211:149,217:150,246:$Vf1}),o($Vr2,[2,356],{218:108,222:109,211:149,217:150,246:$Vf1}),o($Vj1,[2,357],{218:108,222:109,211:149,217:150}),o([1,6,10,11,14,22,71,90,97,106,112,126,135,137,147,171,200,201,212,213,214,219,220,229,238,239,247,248],[2,358],{218:108,222:109,211:149,217:150,242:$Vd1,243:$Ve1,246:$Vf1}),o([1,6,10,11,14,22,71,90,97,106,112,126,135,137,147,171,200,201,212,213,214,219,220,229,238,239],[2,359],{218:108,222:109,211:149,217:150,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o([1,6,10,11,14,22,71,90,97,106,112,135,137,147,171,200,201,212,213,214,219,220,229,238,239],[2,360],{218:108,222:109,211:149,217:150,126:$V91,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o([1,6,10,11,14,22,71,90,97,106,112,126,135,137,147,171,200,201,212,213,214,219,220,229,238,239,248],[2,361],{218:108,222:109,211:149,217:150,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1}),o($Vs2,[2,345],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),{126:$V91,135:[1,412],171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($Vs2,[2,344],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($Vu1,[2,261]),o($VD1,[2,215]),o($VD1,[2,216]),o($VD1,[2,221]),o($VD1,[2,217]),o($VD1,[2,220]),o($VD1,[2,222]),o($VD1,[2,218]),o($VD1,[2,219]),{112:[1,413]},{112:[2,241],126:$V91,171:$Va1,199:414,200:$VW1,201:$VX1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},{112:[2,242]},{13:415,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vt2,[2,271]),o($Vt2,[2,272]),{22:[1,416],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},{22:[1,417],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($VY1,[2,136],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),{13:418,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($VY1,[2,362],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),{13:419,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:420,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vu2,[2,342]),{5:421,10:$V1,126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($Vj1,[2,291],{206:422,207:$VZ1}),o($Vj1,[2,292]),{209:[1,423]},{5:424,10:$V1},{231:425,233:343,234:$V_1},{11:[1,426],232:[1,427],233:428,234:$V_1},o($Vv2,[2,335]),{13:430,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,203:429,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vj1,[2,254]),o($Vj1,[2,260]),{6:$V72,14:[1,432],106:[1,431],115:433},{51:[1,435],62:[1,434],89:[1,436]},{13:437,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{89:[1,438]},{51:[1,439],89:[1,440]},o($VA1,[2,110]),o($V02,[2,113]),o($V02,[2,116],{117:[1,441]}),{90:[1,442],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($Vj1,[2,157]),{89:$Vw1,150:443},{90:[1,444],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($Vu1,[2,265]),o([6,10,22],$V72,{115:445,14:$V82}),o($V92,$V52,{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),{29:446,32:$VC1},{31:447,33:218,50:220,51:$V8,57:219,58:$Vc},{31:448,33:218,50:220,51:$V8,57:219,58:$Vc},o($Vu1,[2,297]),{6:$V51,9:133,11:[1,449]},{13:450,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{6:$V51,9:452,10:$Vw2,97:[1,451]},o([6,10,11,22,97],$Vx2,{34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,17:30,18:31,25:36,131:38,178:39,72:40,186:41,187:42,166:44,129:45,101:46,189:47,140:48,141:49,142:50,176:57,235:58,211:60,215:61,217:62,192:64,121:70,148:72,168:76,150:77,63:79,82:92,155:93,57:97,52:98,55:99,59:100,109:101,173:102,50:103,218:108,222:109,61:116,65:117,16:155,12:228,15:230,13:361,202:454,19:$V2,20:$V3,23:$V4,24:$V5,26:$V6,32:$V7,51:$V8,53:$V9,54:$Va,56:$Vb,58:$Vc,60:$Vd,62:$Ve,64:$Vf,66:$Vg,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,83:$Vp,89:$Vq,91:$Vr,96:$Vs,103:$Vt,122:$Vu,123:$Vv,124:$Vw,130:$Vx,136:$Vy,138:$Vz,139:$VA,143:$VB,144:$VC,151:$VD,152:$VE,154:$VF,156:$VG,157:$VH,158:$VI,170:$VJ,171:$VG1,175:$VK,184:$VL,185:$VM,188:$VN,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,212:$VU,214:$VV,216:$VW,219:$VX,220:$VY,230:$VZ,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41}),o($Vy2,$V72,{115:455,14:$V82}),{13:456,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:457,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{97:[1,458],98:[1,459]},{14:$Vz2,147:[1,460]},o($VA2,[2,187]),o($VA2,[2,189]),o($VA2,[2,190]),o($VA2,[2,191],{117:[1,462]}),{50:382,51:$V8,169:463},{50:382,51:$V8,169:464},{50:382,51:$V8,169:465},o([14,22,117,147],[2,196]),{14:$Vz2,147:[1,466]},{6:$V51,9:468,10:$VB2,90:[1,467]},o([6,10,11,90],$Vx2,{61:116,65:117,134:250,15:251,50:252,57:253,63:254,52:255,55:256,133:470,32:$V7,51:$V8,53:$V9,54:$Va,56:$Vb,58:$Vc,62:$Ve,64:$Vf,66:$Vg,136:$VJ1,138:$Vz,139:$VA}),{10:[1,472],13:471,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{126:$V91,137:[1,473],171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($Vu2,[2,339]),{13:474,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:475,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vk2,[2,318]),{50:268,51:$V8,89:$Vw1,96:$VR1,150:270,168:269,226:476},o([1,6,10,11,14,22,71,90,97,106,112,135,137,147,200,201,212,214,219,220,238],[2,324],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,213:[1,477],229:[1,478],239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($VC2,[2,325],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,213:[1,479],239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($Vj1,[2,256]),{13:480,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vj1,[2,127]),{110:$VL1,125:481,128:$VM1},o($VT1,[2,65]),{71:[1,482],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},{50:287,51:$V8,57:288,58:$Vc,89:$VP1,161:483},o($VD2,[2,172]),o($VD2,[2,173]),o($VE2,$Vb2,{167:375,150:376,168:377,169:378,50:382,146:484,51:$V8,89:$Vw1,96:$VR1,170:$Vc2,171:$Vd2,172:$Ve2}),o($Vj1,[2,171]),{5:485,10:$V1,89:$Vm1,141:486,144:$VC},o($Vj1,[2,179]),{90:[1,487],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($VD1,[2,198]),o($VD1,[2,201]),o($VU1,[2,11]),{13:488,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($VD1,[2,223]),{13:489,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,112:[2,275],121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{112:[2,276],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($Vt1,[2,22]),o($Vt1,[2,24]),{6:$V51,9:491,11:$VF2,126:$V91,132:490,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},{6:$V51,9:491,11:$VF2,126:$V91,132:493,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},{5:494,10:$V1,126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($Vu2,[2,341]),o($Vj1,[2,293]),{5:495,10:$V1},o($Vj1,[2,294]),{11:[1,496],232:[1,497],233:428,234:$V_1},o($Vj1,[2,333]),{5:498,10:$V1},o($Vv2,[2,336]),{5:499,10:$V1,14:[1,500]},o($VG2,[2,288],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($V$1,[2,96],{107:501,10:[1,502],21:[1,503]}),{6:$Vx2,114:504,116:$V12},{6:[1,505]},o($VA1,[2,104]),o($VA1,[2,106]),{13:506,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{112:[1,507],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},{13:508,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($VA1,[2,109]),{13:509,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:511,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,118:510,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{106:[1,512]},{22:[1,513]},o($V22,[2,163]),{6:$V51,9:452,10:$Vw2,22:[1,514]},o($Vt1,[2,27]),o($V32,[2,32]),o($Vt1,[2,28]),{137:[1,515]},{97:[1,516],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($V62,[2,270]),{12:228,13:361,15:230,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,171:$VG1,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,202:517,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{10:$VE1,12:228,13:361,15:230,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,119:518,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,171:$VG1,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,202:226,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($V92,[2,278]),{6:$V51,9:520,10:$Vw2,11:$VF2,132:519},{90:[1,521],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},{90:[1,522],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($VO1,[2,89]),{32:$V7,51:[1,524],61:116,62:$Ve,63:525,64:$Vf,65:117,66:$Vg,89:[1,526],99:523},{5:527,10:$V1},{50:382,51:$V8,89:$Vw1,96:$VR1,150:376,167:528,168:377,169:378,170:$Vc2,171:$Vd2,172:$Ve2},{13:529,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($VA2,[2,192]),o($VA2,[2,193]),o($VA2,[2,194]),{5:530,10:$V1},o([1,6,10,11,14,21,22,71,88,89,90,97,106,111,112,117,126,135,137,144,147,171,180,181,183,196,200,201,212,213,214,219,220,227,228,229,238,239,242,243,246,247,248],[2,243]),{15:251,32:$V7,50:252,51:$V8,52:255,53:$V9,54:$Va,55:256,56:$Vb,57:253,58:$Vc,61:116,62:$Ve,63:254,64:$Vf,65:117,66:$Vg,133:531,134:250,136:$VJ1,138:$Vz,139:$VA},o([6,10,11,14],$VI1,{61:116,65:117,133:249,134:250,15:251,50:252,57:253,63:254,52:255,55:256,191:532,32:$V7,51:$V8,53:$V9,54:$Va,56:$Vb,58:$Vc,62:$Ve,64:$Vf,66:$Vg,136:$VJ1,138:$Vz,139:$VA}),o($Vg2,[2,246]),o($Vg2,[2,139],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),{13:533,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vh2,[2,147]),o($Vj2,[2,300],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($Vj2,[2,302],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($Vk2,[2,323]),{13:534,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:535,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:536,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o([1,6,11,14,22,71,90,97,106,112,135,137,147,200,201,213,220,229,238],[2,257],{218:108,222:109,211:149,217:150,5:537,10:$V1,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($V$1,[2,128],{5:538,10:$V1}),o($VT1,[2,66]),{21:[1,539],162:540,164:$Vo2,165:$Vp2},{14:$Vz2,22:[1,541]},o($Vj1,[2,177]),o($Vj1,[2,178]),o($Vq2,[2,176]),o([1,6,10,11,14,22,71,90,97,106,112,135,137,147,200,201,212,213,214,219,220,229,238,239],[2,346],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),{112:[2,274],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($Vj1,[2,137]),{11:$VH2},o($Vj1,[2,283]),o($Vj1,[2,363]),o($Vu2,[2,340]),o([1,6,10,11,14,22,71,90,97,106,112,126,135,137,147,171,200,201,207,212,213,214,219,220,229,238,239,242,243,246,247,248],[2,295]),o($Vj1,[2,331]),{5:543,10:$V1},{11:[1,544]},o($Vv2,[2,337],{6:[1,545]}),{13:546,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vj1,[2,97]),{10:$VE1,12:228,13:361,15:230,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,119:547,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,171:$VG1,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,202:226,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{10:$VE1,12:228,13:361,15:230,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,119:548,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,171:$VG1,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,202:226,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($V02,[2,114]),{114:549,116:$V12},{90:[1,550],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($VA1,[2,105]),{90:[1,551],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},{90:[1,552],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($V02,[2,117]),o($V02,[2,118],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($Vj1,[2,98]),o($Vj1,[2,158]),o($Vu1,[2,266]),o($Vu1,[2,298]),o($Vu1,[2,273]),o($V92,[2,279]),o($Vy2,$V72,{115:553,14:$V82}),o($V92,[2,280]),{11:$VH2,12:228,13:361,15:230,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,171:$VG1,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,202:517,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($VO1,[2,83]),o($VO1,[2,84]),{97:[1,554]},{97:[2,93]},{97:[2,94]},{13:555,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vu1,[2,155]),o($VA2,[2,188]),o($VA2,[2,195],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),{90:[1,556]},o($Vg2,[2,247]),o($Vy2,$V72,{115:557,14:$Vf2}),{6:$V51,9:491,11:$VF2,126:$V91,132:558,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o([1,6,10,11,14,22,71,90,97,106,112,135,137,147,200,201,212,213,214,219,220,238],[2,326],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,229:[1,559],239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($VC2,[2,328],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,213:[1,560],239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($VY1,[2,327],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($Vj1,[2,258]),o($Vj1,[2,129]),o($VE2,$Vb2,{167:375,150:376,168:377,169:378,50:382,146:561,51:$V8,89:$Vw1,96:$VR1,170:$Vc2,171:$Vd2,172:$Ve2}),o($Vj1,[2,169]),{162:562,164:$Vo2,165:$Vp2},o($Vj1,[2,282]),{6:$V51,9:491,11:$VF2,132:563},o($Vj1,[2,334]),o($Vv2,[2,338]),o($VG2,[2,289],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($VI2,$V72,{115:565,11:[1,564],14:$V82}),o($VI2,$V72,{115:565,14:$V82,22:[1,566]}),o($V02,[2,115]),o($VA1,[2,107]),o($VA1,[2,108]),o($VA1,[2,111]),{6:$V51,9:520,10:$Vw2,11:$VF2,132:567},o($VO1,[2,90]),{90:[1,568],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($Vu1,[2,156]),{6:$V51,9:570,10:$VB2,11:$VF2,132:569},o($Vg2,[2,140]),{13:571,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:572,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{14:$Vz2,22:[1,573]},o($Vj1,[2,170]),o($Vj1,[2,332]),o($Vj1,[2,119]),{6:$V51,9:452,10:$Vw2},o($Vj1,[2,120]),o($V92,[2,281]),{97:[2,95]},o($Vg2,[2,248]),{11:$VH2,15:251,32:$V7,50:252,51:$V8,52:255,53:$V9,54:$Va,55:256,56:$Vb,57:253,58:$Vc,61:116,62:$Ve,63:254,64:$Vf,65:117,66:$Vg,133:531,134:250,136:$VJ1,138:$Vz,139:$VA},o($VY1,[2,329],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($VY1,[2,330],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),{162:574,164:$Vo2,165:$Vp2},o($Vj1,[2,168])],
	defaultActions: {135:[2,3],163:[2,264],324:[2,242],524:[2,93],525:[2,94],568:[2,95]},
	parseError: function parseError(str, hash) {
	    if (hash.recoverable) {
	        this.trace(str);
	    } else {
	        throw new Error(str);
	    }
	},
	parse: function parse(input) {
	
	    // For Imba we are going to drop most of the features that are not used
	    // Locations are provided by the tokens from the lexer directly - so drop yylloc
	    // We dont really need the shared state (it seems)
	
	    var self = this,
	        stack = [0],
	        tstack = [], // token stack
	        vstack = [null], // semantic value stack
	        table = this.table,
	        yytext = '',
	        yylineno = 0,
	        yyleng = 0,
	        recovering = 0,
	        TERROR = 2,
	        EOF = 1;
	
	    // var args = lstack.slice.call(arguments, 1);
	    //this.reductionCount = this.shiftCount = 0;
	
	    var lexer = Object.create(this.lexer);
	    var yy = this.yy;
	
	    lexer.setInput(input,yy);
	
	    if (typeof yy.parseError === 'function') {
	        this.parseError = yy.parseError;
	    } else {
	        this.parseError = Object.getPrototypeOf(this).parseError; // what?
	    }
	
	    function popStack (n) {
	        stack.length = stack.length - 2 * n;
	        vstack.length = vstack.length - n;
	    }
	
	    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
	
	    function handleError(){
	        var error_rule_depth;
	        var errStr = '';
	
	        // Return the rule stack depth where the nearest error rule can be found.
	        // Return FALSE when no error recovery rule was found.
	        // we have no rules now
	        function locateNearestErrorRecoveryRule(state) {
	            var stack_probe = stack.length - 1;
	            var depth = 0;
	
	            // try to recover from error
	            for(;;) {
	                // check for error recovery rule in this state
	                if ((TERROR.toString()) in table[state]) {
	                    return depth;
	                }
	                if (state === 0 || stack_probe < 2) {
	                    return false; // No suitable error recovery rule available.
	                }
	                stack_probe -= 2; // popStack(1): [symbol, action]
	                state = stack[stack_probe];
	                ++depth;
	            }
	        }
	
	        if (!recovering) {
	            // first see if there's any chance at hitting an error recovery rule:
	            error_rule_depth = locateNearestErrorRecoveryRule(state);
	
	            // Report error
	            expected = [];
	
	            var tsym = lexer.yytext;
	            var tok = self.terminals_[symbol] || symbol;
	            var tloc = tsym ? tsym._loc : -1;
	            var tpos = tloc != -1 ? "[" + tsym._loc + ":" + tsym._len + "]" : '[0:0]';
	
	            if (lexer.showPosition) {
	                errStr = 'Parse error at '+(tpos)+":\n"+lexer.showPosition()+"\nExpecting "+expected.join(', ') + ", got '" + (self.terminals_[symbol] || symbol)+ "'";
	            } else {
	                errStr = 'Parse error at '+(tpos)+": Unexpected " + (symbol == EOF ? "end of input" : ("'"+(tok)+"'"));
	            }
	
	            self.parseError(errStr, {
	                lexer: lexer,
	                text: lexer.match,
	                token: tok,
	                line: lexer.yylineno,
	                expected: expected,
	                recoverable: (error_rule_depth !== false)
	            });
	        } else if (preErrorSymbol !== EOF) {
	            error_rule_depth = locateNearestErrorRecoveryRule(state);
	        }
	
	        // just recovered from another error
	        if (recovering == 3) {
	            if (symbol === EOF || preErrorSymbol === EOF) {
	                throw new Error(errStr || 'Parsing halted while starting to recover from another error.');
	            }
	
	            // discard current lookahead and grab another
	            yytext = lexer.yytext;
	        }
	
	        // try to recover from error
	        if (error_rule_depth === false) {
	            throw new Error(errStr || 'Parsing halted. No suitable error recovery rule available.');
	        }
	        popStack(error_rule_depth);
	        preErrorSymbol = (symbol == TERROR ? null : symbol); // save the lookahead token
	        symbol = TERROR;         // insert generic error symbol as new lookahead
	        state = stack[stack.length-1];
	        action = table[state] && table[state][TERROR];
	        recovering = 3; // allow 3 real symbols to be shifted before reporting a new error
	    }
	
	
	    var __sym = this.symbols_;
	    var __prod = this.productions_;
	
	    while (true) {
	        // retreive state number from top of stack
	        state = stack[stack.length - 1];
	
	        if (symbol === null || typeof symbol == 'undefined') {
	            symbol = __sym[lexer.lex()] || EOF;
	        }
	        action = table[state] && table[state][symbol];
	
	_handle_error:
	        if (typeof action === 'undefined' || !action.length || !action[0]) {
	            handleError();
	        }
	
	        switch (action[0]) {
	            case 1: // shift
	                stack.push(symbol);
	                stack.push(action[1]); // push state
	                vstack.push(lexer.yytext);
	                
	                symbol = null;
	                if (!preErrorSymbol) { // normal execution/no error
	                    yytext = lexer.yytext;
	                    if (recovering > 0) {
	                        recovering--;
	                    }
	                } else {
	                    // error just occurred, resume old lookahead f/ before error
	                    symbol = preErrorSymbol;
	                    preErrorSymbol = null;
	                }
	                break;
	
	            case 2:
	                len = __prod[action[1]][1];
	                // perform semantic action
	                yyval.$ = vstack[vstack.length-len];
	                r = this.performAction(yyval, yytext, yy, action[1], vstack);
	                if (typeof r !== 'undefined') {
	                    return r;
	                }
	
	                while(len > 0) {
	                    stack.pop();
	                    stack.pop();
	                    vstack.pop();
	                    len--;
	                }
	
	                stack.push(__prod[action[1]][0]);
	                newState = table[stack[stack.length-2]][stack[stack.length-1]];
	                stack.push(newState);
	                vstack.push(yyval.$);
	                break;
	
	            case 3:
	                return true;
	        }
	    }
	
	    return true;
	}};
	
	function Parser () {
	  this.yy = {};
	}
	Parser.prototype = parser;parser.Parser = Parser;
	return new Parser;
	})();
	
	
	if (true) {
	exports.parser = parser;
	exports.Parser = parser.Parser;
	exports.parse = function () { return parser.parse.apply(parser, arguments); };
	// exports.main = function commonjsMain(args) {
	//     if (!args[1]) {
	//         console.log('Usage: '+args[0]+' FILE');
	//         process.exit(1);
	//     }
	//     var source = require('fs').readFileSync(require('path').normalize(args[1]), "utf8");
	//     return exports.parser.parse(source);
	// };
	if (typeof module !== 'undefined' && __webpack_require__.c[0] === module) {
	  exports.main(process.argv.slice(1));
	}
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)(module), __webpack_require__(8)))

/***/ },
/* 7 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 8 */
/***/ function(module, exports) {

	// shim for using process in browser
	
	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function idx$(a,b){
			return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
		};
		
		// helper for subclassing
		function subclass$(obj,sup) {
			for (var k in sup) {
				if (sup.hasOwnProperty(k)) obj[k] = sup[k];
			};
			// obj.__super__ = sup;
			obj.prototype = Object.create(sup.prototype);
			obj.__super__ = obj.prototype.__super__ = sup.prototype;
			obj.prototype.initialize = obj.prototype.constructor = obj;
		};
		
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		var AST, OP, OP_COMPOUND, NODES, SPLAT, STACK, K_IVAR, K_SYM, K_STR, K_PROP, BR, BR2, SELF, SUPER, TRUE, FALSE, UNDEFINED, NIL, ARGUMENTS, EMPTY, NULL, RESERVED, RESERVED_REGEX, UNION, INTERSECT, CLASSDEF, TAGDEF, NEWTAG;
		// TODO Create Expression - make all expressions inherit from these?
		
		// externs;
		
		var helpers = __webpack_require__(3);
		var ERR = __webpack_require__(2);
		var v8 = null; // require 'v8-natives'
		
		var T = __webpack_require__(1);
		var Token = T.Token;
		
		var SourceMap = __webpack_require__(10).SourceMap;
		
		module.exports.AST = AST = {};
		
		// Helpers for operators
		module.exports.OP = OP = function(op,l,r) {
			var o = String(op);
			// console.log "operator",o
			switch (o) {
				case '.':
					if ((typeof r=='string'||r instanceof String)) { r = new Identifier(r) };
					// r = r.value if r isa VarOrAccess
					return new Access(op,l,r);
					break;
				
				case '=':
					if (l instanceof Tuple) { return new TupleAssign(op,l,r) };
					return new Assign(op,l,r);
					break;
				
				case '?=':
				case '||=':
				case '&&=':
					return new ConditionalAssign(op,l,r);
					break;
				
				case '+=':
				case '-=':
				case '*=':
				case '/=':
				case '^=':
				case '%=':
					return new CompoundAssign(op,l,r);
					break;
				
				case '?.':
					if (r instanceof VarOrAccess) {
						// console.log "is var or access"
						r = r.value();
					};
					// depends on the right side - this is wrong
					return new PropertyAccess(op,l,r);
					break;
				
				case 'instanceof':
					return new InstanceOf(op,l,r);
					break;
				
				case 'in':
					return new In(op,l,r);
					break;
				
				case 'typeof':
					return new TypeOf(op,l,r);
					break;
				
				case 'delete':
					return new Delete(op,l,r);
					break;
				
				case '--':
				case '++':
				case '!':
				case '√':
					return new UnaryOp(op,l,r);
					break;
				
				case '>':
				case '<':
				case '>=':
				case '<=':
				case '==':
				case '===':
				case '!=':
				case '!==':
					return new ComparisonOp(op,l,r);
					break;
				
				case '∩':
				case '∪':
					return new MathOp(op,l,r);
					break;
				
				case '..':
				case '...':
					return new Range(op,l,r);
					break;
				
				default:
				
					return new Op(op,l,r);
			
			};
		};
		
		module.exports.OP_COMPOUND = OP_COMPOUND = function(sym,op,l,r) {
			// console.log "?. soak operator",sym
			if (sym == '?.') {
				console.log("?. soak operator");
				return null;
			};
			if (sym == '?=' || sym == '||=' || sym == '&&=') {
				return new ConditionalAssign(op,l,r);
			} else {
				return new CompoundAssign(op,l,r);
			};
		};
		
		var OPTS = {};
		var ROOT = null;
		
		module.exports.NODES = NODES = [];
		
		var LIT = function(val) {
			return new Literal(val);
		};
		
		var SYM = function(val) {
			return new Symbol(val);
		};
		
		var IF = function(cond,body,alt) {
			var node = new If(cond,body);
			if (alt) { node.addElse(alt) };
			return node;
		};
		
		var FN = function(pars,body) {
			return new Func(pars,body);
		};
		
		var CALL = function(callee,pars) {
			// possibly return instead(!)
			if(pars === undefined) pars = [];
			return new Call(callee,pars);
		};
		
		var CALLSELF = function(name,pars) {
			if(pars === undefined) pars = [];
			var ref = new Identifier(name);
			return new Call(OP('.',SELF,ref),pars);
		};
		
		var BLOCK = function() {
			return Block.wrap([].slice.call(arguments));
		};
		
		var WHILE = function(test,code) {
			return new While(test).addBody(code);
		};
		
		module.exports.SPLAT = SPLAT = function(value) {
			if (value instanceof Assign) {
				// p "WARN"
				value.setLeft(new Splat(value.left()));
				return value;
			} else {
				return new Splat(value);
				// not sure about this
			};
		};
		
		// OP.ASSIGNMENT = [ "=" , "+=" , "-=" , "*=" , "/=" , "%=", "<<=" , ">>=" , ">>>=", "|=" , "^=" , "&=" ]
		// OP.LOGICAL = [ "||" , "&&" ]
		// OP.UNARY = [ "++" , "--" ]
		
		var SEMICOLON_TEST = /;(\s*\/\/.*)?[\n\s\t]*$/;
		var RESERVED_TEST = /^(default|char)$/;
		
		// captures error from parser
		function parseError(str,o){
			// console.log 'parseError',o:token
			
			// find nearest token
			var err;
			
			if (o.lexer) {
				var token = o.lexer.yytext;
				// console.log o:lexer:pos,token.@loc
				err = new ERR.ImbaParseError({message: str},{
					pos: o.lexer.pos,
					tokens: o.lexer.tokens,
					token: o.lexer.yytext,
					meta: o
				});
				
				throw err;
				
				// should find the closest token with actual position
				// str = "[{token.@loc}:{token.@len || String(token):length}] {str}"
			};
			var e = new Error(str);
			e.lexer = o.lexer;
			e.options = o;
			throw e;
		}; exports.parseError = parseError;
		
		function c__(obj){
			return typeof obj == 'string' ? (obj) : (obj.c());
		};
		
		function mark__(tok){
			if (tok && (OPTS.sourceMapInline || OPTS.sourceMap) && tok.sourceMapMarker) {
				return tok.sourceMapMarker();
			} else {
				return '';
			};
		};
		
		function num__(num){
			return new Num(num);
		};
		
		function str__(str){
			// should pack in token?!?
			return new Str(str);
		};
		
		function blk__(obj){
			return obj instanceof Array ? (Block.wrap(obj)) : (obj);
		};
		
		function sym__(obj){
			// console.log "sym {obj}"
			return helpers.symbolize(String(obj));
		};
		
		function cary__(ary){
			return ary.map(function(v) { return typeof v == 'string' ? (v) : (v.c()); });
		};
		
		function dump__(obj,key){
			if (obj instanceof Array) {
				return obj.map(function(v) { return v && v.dump ? (v.dump(key)) : (v); });
			} else if (obj && obj.dump) {
				return obj.dump();
			};
		};
		
		function compact__(ary){
			if (ary instanceof ListNode) {
				return ary.compact();
			};
			
			return ary.filter(function(v) { return v != undefined && v != null; });
		};
		
		function reduce__(res,ary){
			for (var i = 0, items = iter$(ary), len = items.length, v; i < len; i++) {
				v = items[i];
				v instanceof Array ? (reduce__(res,v)) : (res.push(v));
			};
			return;
		};
		
		function flatten__(ary,compact){
			if(compact === undefined) compact = false;
			var out = [];
			for (var i = 0, items = iter$(ary), len = items.length, v; i < len; i++) {
				v = items[i];
				v instanceof Array ? (reduce__(out,v)) : (out.push(v));
			};
			return out;
		};
		
		AST.parse = function (str,opts){
			if(opts === undefined) opts = {};
			var indent = str.match(/\t+/)[0];
			// really? Require the compiler, not this
			return Imbac.parse(str,opts);
		};
		
		AST.inline = function (str,opts){
			if(opts === undefined) opts = {};
			return this.parse(str,opts).body();
		};
		
		AST.node = function (typ,pars){
			if (typ == 'call') {
				if (pars[0].c() == 'return') {
					pars[0] = 'tata';
				};
				return new Call(pars[0],pars[1],pars[2]);
			};
		};
		
		
		AST.escapeComments = function (str){
			if (!(str)) { return '' };
			return str;
		};
		
		function Indentation(a,b){
			this._open = a;
			this._close = b;
			this;
		};
		
		exports.Indentation = Indentation; // export class 
		Indentation.prototype.open = function(v){ return this._open; }
		Indentation.prototype.setOpen = function(v){ this._open = v; return this; };
		Indentation.prototype.close = function(v){ return this._close; }
		Indentation.prototype.setClose = function(v){ this._close = v; return this; };
		
		Indentation.prototype.isGenerated = function (){
			return this._open && this._open.generated;
		};
		
		Indentation.prototype.aloc = function (){
			return this._open && this._open._loc || 0;
		};
		
		Indentation.prototype.bloc = function (){
			return this._close && this._close._loc || 0;
		};
		
		// should rather parse and extract the comments, no?
		Indentation.prototype.wrap = function (str){
			// var pre, post
			
			// console.log "INDENT {@open and JSON.stringify(@open.@meta)}"
			// console.log "OUTDENT {@close}"
			// var ov = @open and @open.@value
			// if ov and ov:length > 1
			// 	console.log "value for indent",ov
			// 	if ov.indexOf('%|%')
			// 		pre = ov.substr
			var om = this._open && this._open._meta;
			var pre = om && om.pre || '';
			var post = om && om.post || '';
			var esc = AST.escapeComments;
			var out = this._close;
			
			// the first newline should not be indented?
			str = post.replace(/^\n/,'') + str;
			str = str.replace(/^/g,"\t").replace(/\n/g,"\n\t").replace(/\n\t$/g,"\n");
			
			str = pre + '\n' + str;
			if (out instanceof Terminator) { str += out.c() };
			if (str[str.length - 1] != '\n') { str = str + '\n' };
			return str;
		};
		
		var INDENT = new Indentation({},{});
		
		function Stash(){
			this._entities = [];
		};
		
		Stash.prototype.add = function (item){
			this._entities.unshift(item);
			return this;
		};
		
		Stash.prototype.pluck = function (item){
			var match = null;
			for (var i = 0, ary = iter$(this._entities), len = ary.length, entity; i < len; i++) {
				entity = ary[i];
				if (entity == item || (entity instanceof item)) {
					match = entity;
					this._entities.splice(i,1);
					return match;
				};
			};
			return null;
		};
		
		
		function Stack(){
			this.reset();
		};
		
		exports.Stack = Stack; // export class 
		Stack.prototype.loglevel = function(v){ return this._loglevel; }
		Stack.prototype.setLoglevel = function(v){ this._loglevel = v; return this; };
		Stack.prototype.nodes = function(v){ return this._nodes; }
		Stack.prototype.setNodes = function(v){ this._nodes = v; return this; };
		Stack.prototype.scopes = function(v){ return this._scopes; }
		Stack.prototype.setScopes = function(v){ this._scopes = v; return this; };
		
		Stack.prototype.reset = function (){
			this._nodes = [];
			this._scoping = [];
			this._scopes = []; // for analysis - should rename
			this._stash = new Stash(this);
			this._loglevel = 3;
			this._counter = 0;
			this._counters = {};
			return this;
		};
		
		Stack.prototype.incr = function (name){
			var $1;
			this._counters[($1 = name)] || (this._counters[$1] = 0);
			return this._counters[name] += 1;
		};
		
		Stack.prototype.stash = function (){
			return this._stash;
		};
		
		Stack.prototype.option = function (key){
			return this._options && this._options[key];
		};
		
		Stack.prototype.addScope = function (scope){
			this._scopes.push(scope);
			return this;
		};
		
		Stack.prototype.traverse = function (node){
			return this;
		};
		
		Stack.prototype.push = function (node){
			this._nodes.push(node);
			// not sure if we have already defined a scope?
			return this;
		};
		
		Stack.prototype.pop = function (node){
			this._nodes.pop(); // (node)
			return this;
		};
		
		Stack.prototype.parent = function (){
			return this._nodes[this._nodes.length - 2];
		};
		
		Stack.prototype.current = function (){
			return this._nodes[this._nodes.length - 1];
		};
		
		Stack.prototype.up = function (test){
			test || (test = function(v) { return !(v instanceof VarOrAccess); });
			
			if (test.prototype instanceof Node) {
				var typ = test;
				test = function(v) { return v instanceof typ; };
			};
			
			var i = this._nodes.length - 2; // key
			while (i >= 0){
				var node = this._nodes[i];
				if (test(node)) { return node };
				i -= 1;
			};
			return null;
		};
		
		Stack.prototype.relative = function (node,offset){
			if(offset === undefined) offset = 0;
			var idx = this._nodes.indexOf(node);
			return idx >= 0 ? (this._nodes[idx + offset]) : (null);
		};
		
		Stack.prototype.scope = function (lvl){
			if(lvl === undefined) lvl = 0;
			var i = this._nodes.length - 1 - lvl;
			while (i >= 0){
				var node = this._nodes[i];
				if (node._scope) { return node._scope };
				i -= 1;
			};
			return null;
		};
		
		Stack.prototype.scopes = function (){
			// include deeper scopes as well?
			var scopes = [];
			var i = this._nodes.length - 1;
			while (i >= 0){
				var node = this._nodes[i];
				if (node._scope) { scopes.push(node._scope) };
				i -= 1;
			};
			return scopes;
		};
		
		Stack.prototype.method = function (){
			return this.up(MethodDeclaration);
		};
		
		Stack.prototype.block = function (){
			return this.up(Block);
		};
		
		Stack.prototype.isExpression = function (){
			var i = this._nodes.length - 1;
			while (i >= 0){
				var node = this._nodes[i];
				// why are we not using isExpression here as well?
				if ((node instanceof Code) || (node instanceof Loop)) {
					return false;
				};
				if (node.isExpression()) {
					return true;
				};
				// probably not the right test - need to be more explicit
				i -= 1;
			};
			return false;
		};
		
		Stack.prototype.toString = function (){
			return ("Stack(" + this._nodes.join(" -> ") + ")");
		};
		
		Stack.prototype.scoping = function (){
			return this._nodes.filter(function(n) { return n._scope; }).map(function(n) { return n._scope; });
		};
		
		// Lots of globals -- really need to deal with one stack per file / context
		module.exports.STACK = STACK = new Stack();
		
		GLOBSTACK = STACK;
		
		// use a bitmask for these
		
		function Node(){
			this.setup();
			this;
		};
		
		exports.Node = Node; // export class 
		Node.prototype.o = function(v){ return this._o; }
		Node.prototype.setO = function(v){ this._o = v; return this; };
		Node.prototype.options = function(v){ return this._options; }
		Node.prototype.setOptions = function(v){ this._options = v; return this; };
		Node.prototype.traversed = function(v){ return this._traversed; }
		Node.prototype.setTraversed = function(v){ this._traversed = v; return this; };
		
		Node.prototype.safechain = function (){
			return false;
		};
		
		// def dom
		// 	var name = "ast_" + self:constructor:name.replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase
		// 	# p "try to get the dom-node for this ast-node",name
		// 	if Imba.TAGS[name]
		// 		var node = Imba.tag(name)
		// 		node.bind(self).build
		// 		return node
		// 	else
		// 		return "[{name}]"
		
		Node.prototype.p = function (){
			
			// allow controlling this from commandline
			if (STACK.loglevel() > 0) {
				console.log.apply(console,arguments);
			};
			return this;
		};
		
		Node.prototype.typeName = function (){
			return this.constructor.name;
		};
		
		Node.prototype.namepath = function (){
			return this.typeName();
		};
		
		Node.prototype.setup = function (){
			this._expression = false;
			this._traversed = false;
			this._parens = false;
			this._cache = null;
			this._value = null;
			return this;
		};
		
		Node.prototype.set = function (obj){
			// console.log "setting options {JSON.stringify(obj)}"
			this._options || (this._options = {});
			for (var i = 0, keys = Object.keys(obj), l = keys.length; i < l; i++){
				this._options[keys[i]] = obj[keys[i]];
			};
			return this;
		};
		
		// get and set
		Node.prototype.option = function (key,val){
			if (val != undefined) {
				// console.log "setting option {key} {val}"
				this._options || (this._options = {});
				this._options[key] = val;
				return this;
			};
			
			return this._options && this._options[key];
		};
		
		Node.prototype.configure = function (obj){
			return this.set(obj);
		};
		
		Node.prototype.region = function (){
			return [0,0];
		};
		
		Node.prototype.loc = function (){
			return [0,0];
		};
		
		Node.prototype.token = function (){
			return null;
		};
		
		Node.prototype.compile = function (){
			return this;
		};
		
		Node.prototype.visit = function (){
			return this;
		};
		
		Node.prototype.stack = function (){
			return STACK;
		};
		
		Node.prototype.isString = function (){
			return false;
		};
		
		Node.prototype.isPrimitive = function (deep){
			return false;
		};
		
		Node.prototype.isReserved = function (){
			return false;
		};
		
		// should rather do traversals
		// o = {}, up, key, index
		Node.prototype.traverse = function (){
			if (this._traversed) {
				return this;
			};
			// NODES.push(self)
			this._traversed = true;
			STACK.push(this);
			this.visit(STACK);
			STACK.pop(this);
			return this;
		};
		
		Node.prototype.inspect = function (){
			return {type: this.constructor.toString()};
		};
		
		Node.prototype.js = function (o){
			return "NODE";
		};
		
		Node.prototype.toString = function (){
			return ("" + (this.constructor.name));
		};
		
		// swallow might be better name
		Node.prototype.consume = function (node){
			if (node instanceof PushAssign) {
				return new PushAssign(node.op(),node.left(),this);
			};
			
			if (node instanceof Assign) {
				// p "consume assignment".cyan
				// node.right = self
				return OP(node.op(),node.left(),this);
			} else if (node instanceof Op) {
				return OP(node.op(),node.left(),this);
			} else if (node instanceof Return) {
				// p "consume return".cyan
				return new Return(this);
			};
			return this;
		};
		
		Node.prototype.toExpression = function (){
			this._expression = true;
			return this;
		};
		
		Node.prototype.forceExpression = function (){
			this._expression = true;
			return this;
		};
		
		Node.prototype.isExpressable = function (){
			return true;
		};
		
		Node.prototype.isExpression = function (){
			return this._expression || false;
		};
		
		Node.prototype.hasSideEffects = function (){
			return true;
		};
		
		Node.prototype.isUsed = function (){
			return true;
		};
		
		Node.prototype.shouldParenthesize = function (){
			return false;
		};
		
		Node.prototype.block = function (){
			return Block.wrap([this]);
		};
		
		Node.prototype.node = function (){
			return this;
		};
		
		Node.prototype.scope__ = function (){
			return STACK.scope();
		};
		
		Node.prototype.up = function (){
			return STACK.parent();
		};
		
		Node.prototype.util = function (){
			return Util;
		};
		
		Node.prototype.receiver = function (){
			return this;
		};
		
		Node.prototype.addExpression = function (expr){
			// might be better to nest this up after parsing is done?
			// p "addExpression {self} <- {expr}"
			var node = new ExpressionBlock([this]);
			return node.addExpression(expr);
		};
		
		
		Node.prototype.indented = function (a,b){
			
			if (a instanceof Indentation) {
				this._indentation = a;
				return this;
			};
			
			// this is a _BIG_ hack
			if (b instanceof Array) {
				this.add(b[0]);
				b = b[1];
			};
			
			// if indent and indent.match(/\:/)
			this._indentation || (this._indentation = a && b ? (new Indentation(a,b)) : (INDENT));
			return this;
		};
		
		Node.prototype.prebreak = function (term){
			// in options instead?
			// console.log "prebreak!!!!"
			// @prebreak = @prebreak or term
			if(term === undefined) term = '\n';
			return this;
		};
		
		Node.prototype.invert = function (){
			return OP('!',this);
		};
		
		Node.prototype.cache = function (o){
			if(o === undefined) o = {};
			this._cache = o;
			o.var = this.scope__().temporary(this,o);
			o.lookups = 0;
			return this;
		};
		
		Node.prototype.cachevar = function (){
			return this._cache && this._cache.var;
		};
		
		Node.prototype.decache = function (){
			if (this._cache) {
				this.cachevar().free();
				this._cache = null;
			};
			return this;
		};
		
		// is this without side-effects? hmm - what does it even do?
		Node.prototype.predeclare = function (){
			if (this._cache) {
				this.scope__().vars().swap(this._cache.var,this);
			};
			return this;
		};
		
		// the "name-suggestion" for nodes if they need to be cached
		Node.prototype.alias = function (){
			return null;
		};
		
		Node.prototype.warn = function (text,opts){
			if(opts === undefined) opts = {};
			opts.message = text;
			opts.loc || (opts.loc = this.loc());
			this.scope__().root().warn(opts);
			return this;
		};
		
		Node.prototype.c = function (o){
			var indent;
			var s = STACK;
			var ch = this._cache;
			if (ch && ch.cached) { return this.c_cached(ch) };
			
			s.push(this);
			if (o && o.expression) this.forceExpression();
			
			v8 && console.log(v8.hasFastObjectElements(this));
			
			if (o && o.indent) {
				this._indentation || (this._indentation = INDENT);
			};
			
			var out = this.js(s,o);
			
			// really? why not call this somewhere else?
			var paren = this.shouldParenthesize();
			
			if (indent = this._indentation) {
				out = indent.wrap(out,o);
			};
			
			// should move this somewhere else really
			if (paren) { out = ("(" + out + ")") };
			if (o && o.braces) {
				if (indent) {
					out = '{' + out + '}';
				} else {
					out = '{ ' + out + ' }';
				};
			};
			
			s.pop(this);
			
			if (ch = this._cache) {
				if (!ch.manual) { out = ("" + (ch.var.c()) + " = " + out) };
				var par = s.current();
				if ((par instanceof Access) || (par instanceof Op)) { out = '(' + out + ')' }; // others? # 
				ch.cached = true;
			};
			return out;
		};
		
		Node.prototype.c_cached = function (cache){
			cache.lookups++;
			if (cache.uses == cache.lookups) { cache.var.free() };
			return cache.var.c(); // recompile every time??
		};
		
		function ValueNode(value){
			this.setup();
			this._value = this.load(value);
		};
		
		subclass$(ValueNode,Node);
		exports.ValueNode = ValueNode; // export class 
		ValueNode.prototype.value = function(v){ return this._value; }
		ValueNode.prototype.setValue = function(v){ this._value = v; return this; };
		
		ValueNode.prototype.load = function (value){
			return value;
		};
		
		ValueNode.prototype.js = function (o){
			return typeof this._value == 'string' ? (this._value) : (this._value.c());
		};
		
		ValueNode.prototype.visit = function (){
			
			if (this._value instanceof Node) { this._value.traverse() }; //  && @value:traverse
			return this;
		};
		
		ValueNode.prototype.region = function (){
			return [this._value._loc,this._value._loc + this._value._len];
		};
		
		
		function Statement(){ return ValueNode.apply(this,arguments) };
		
		subclass$(Statement,ValueNode);
		exports.Statement = Statement; // export class 
		Statement.prototype.isExpressable = function (){
			return false;
		};
		
		
		function Meta(){ return ValueNode.apply(this,arguments) };
		
		subclass$(Meta,ValueNode);
		exports.Meta = Meta; // export class 
		Meta.prototype.isPrimitive = function (deep){
			return true;
		};
		
		function Comment(){ return Meta.apply(this,arguments) };
		
		subclass$(Comment,Meta);
		exports.Comment = Comment; // export class 
		Comment.prototype.visit = function (){
			// stack.stash.add(self)
			
			var block, next;
			if (block = this.up()) {
				var idx = block.indexOf(this) + 1;
				if (block.index(idx) instanceof Terminator) { idx += 1 };
				if (next = block.index(idx)) {
					next._desc = this;
				};
				
				// console.log "Next item after comment is {block.index(idx)}"
			};
			
			return this;
		};
		
		Comment.prototype.toDoc = function (){
			return helpers.normalizeIndentation("" + this._value._value);
		};
		
		Comment.prototype.toJSON = function (){
			return helpers.normalizeIndentation("" + this._value._value);
		};
		
		Comment.prototype.c = function (o){
			var v = this._value._value;
			// p @value.type
			if (o && o.expression || v.match(/\n/) || this._value.type() == 'HERECOMMENT') { // multiline?
				return ("/*" + v + "*/");
			} else {
				return ("// " + v);
			};
		};
		
		function Terminator(v){
			this._value = v;
			this;
		};
		
		subclass$(Terminator,Meta);
		exports.Terminator = Terminator; // export class 
		Terminator.prototype.traverse = function (){
			return this;
		};
		
		Terminator.prototype.c = function (){
			// TODO this can contain several newlines
			// for sourcemaps it would be nice to parse this
			// and fix it up mark__(@value) + 
			return this._value.c();
			// var v = value.replace(/\\n/g,'\n')
			// v # .split()
			// v.split("\n").map(|v| v ? " // {v}" : v).join("\n")
		};
		
		function Newline(v){
			this._traversed = false;
			this._value = v || '\n';
		};
		
		subclass$(Newline,Terminator);
		exports.Newline = Newline; // export class 
		Newline.prototype.c = function (){
			return c__(this._value);
		};
		
		
		// weird place?
		function Index(){ return ValueNode.apply(this,arguments) };
		
		subclass$(Index,ValueNode);
		exports.Index = Index; // export class 
		Index.prototype.js = function (o){
			return this._value.c();
		};
		
		function ListNode(list){
			this.setup();
			this._nodes = this.load(list || []);
			this._indentation = null;
		};
		
		// PERF acces @nodes directly?
		subclass$(ListNode,Node);
		exports.ListNode = ListNode; // export class 
		ListNode.prototype.nodes = function(v){ return this._nodes; }
		ListNode.prototype.setNodes = function(v){ this._nodes = v; return this; };
		
		ListNode.prototype.list = function (){
			return this._nodes;
		};
		
		ListNode.prototype.compact = function (){
			this._nodes = compact__(this._nodes);
			return this;
		};
		
		ListNode.prototype.load = function (list){
			return list;
		};
		
		ListNode.prototype.concat = function (other){
			// need to store indented content as well?
			this._nodes = this.nodes().concat(other instanceof Array ? (other) : (other.nodes()));
			return this;
		};
		
		ListNode.prototype.swap = function (item,other){
			var idx = this.indexOf(item);
			if (idx >= 0) { this.nodes()[idx] = other };
			return this;
		};
		
		ListNode.prototype.push = function (item){
			this._nodes.push(item);
			return this;
		};
		
		ListNode.prototype.pop = function (){
			var end = this._nodes.pop();
			return end;
		};
		
		ListNode.prototype.add = function (item){
			this._nodes.push(item);
			return this;
		};
		
		ListNode.prototype.unshift = function (item,br){
			if (br) { this._nodes.unshift(BR) };
			this._nodes.unshift(item);
			return this;
		};
		
		// test
		ListNode.prototype.slice = function (a,b){
			return new this.constructor(this._nodes.slice(a,b));
		};
		
		
		
		ListNode.prototype.break = function (br,pre){
			if(pre === undefined) pre = false;
			if (typeof br == 'string') { br = new Terminator(br) };
			pre ? (this.unshift(br)) : (this.push(br));
			return this;
		};
		
		ListNode.prototype.some = function (cb){
			for (var i = 0, ary = iter$(this._nodes), len = ary.length; i < len; i++) {
				if (cb(ary[i])) { return true };
			};
			return false;
		};
		
		ListNode.prototype.every = function (cb){
			for (var i = 0, ary = iter$(this._nodes), len = ary.length; i < len; i++) {
				if (!cb(ary[i])) { return false };
			};
			return true;
		};
		
		ListNode.prototype.filter = function (cb){
			return this._nodes.filter(cb);
		};
		
		ListNode.prototype.pluck = function (cb){
			var item = this.filter(cb)[0];
			if (item) { this.remove(item) };
			return item;
		};
		
		ListNode.prototype.indexOf = function (item){
			return this._nodes.indexOf(item);
		};
		
		ListNode.prototype.index = function (i){
			return this._nodes[i];
		};
		
		ListNode.prototype.remove = function (item){
			var idx = this._nodes.indexOf(item);
			if (idx >= 0) { this._nodes.splice(idx,1) };
			return this;
		};
		
		ListNode.prototype.removeAt = function (idx){
			var item = this._nodes[idx];
			if (idx >= 0) { this._nodes.splice(idx,1) };
			return item;
		};
		
		
		ListNode.prototype.replace = function (original,replacement){
			var idx = this._nodes.indexOf(original);
			if (idx >= 0) {
				if (replacement instanceof Array) {
					// p "replaceing with array of items"
					this._nodes.splice.apply(this._nodes,[].concat([idx,1], [].slice.call(replacement)));
				} else {
					this._nodes[idx] = replacement;
				};
			};
			return this;
		};
		
		ListNode.prototype.first = function (){
			return this._nodes[0];
		};
		
		ListNode.prototype.last = function (){
			var i = this._nodes.length;
			while (i){
				i = i - 1;
				var v = this._nodes[i];
				if (!((v instanceof Meta))) { return v };
			};
			return null;
		};
		
		ListNode.prototype.map = function (fn){
			return this._nodes.map(fn);
		};
		
		ListNode.prototype.forEach = function (fn){
			return this._nodes.forEach(fn);
		};
		
		ListNode.prototype.remap = function (fn){
			this._nodes = this.map(fn);
			return this;
		};
		
		ListNode.prototype.count = function (){
			return this._nodes.length;
		};
		
		ListNode.prototype.realCount = function (){
			var k = 0;
			for (var i = 0, ary = iter$(this._nodes), len = ary.length, node; i < len; i++) {
				node = ary[i];
				if (node && !(node instanceof Meta)) { k++ };
			};
			return k;
		};
		
		ListNode.prototype.visit = function (){
			for (var i = 0, ary = iter$(this._nodes), len = ary.length, node; i < len; i++) {
				node = ary[i];
				node && node.traverse();
			};
			return this;
		};
		
		ListNode.prototype.isExpressable = function (){
			for (var i = 0, ary = iter$(this.nodes()), len = ary.length, node; i < len; i++) {
				node = ary[i];
				if (node && !node.isExpressable()) { return false };
			};
			// return no unless nodes.every(|v| v.isExpressable )
			return true;
		};
		
		ListNode.prototype.toArray = function (){
			return this._nodes;
		};
		
		ListNode.prototype.delimiter = function (){
			return this._delimiter || ",";
		};
		
		ListNode.prototype.js = function (o,pars){
			if(!pars||pars.constructor !== Object) pars = {};
			var nodes = pars.nodes !== undefined ? pars.nodes : this._nodes;
			var delim = ',';
			var express = delim != ';';
			var last = this.last();
			
			var i = 0;
			var l = nodes.length;
			var str = "";
			
			for (var j = 0, ary = iter$(nodes), len = ary.length, arg; j < len; j++) {
				arg = ary[j];
				var part = typeof arg == 'string' ? (arg) : ((arg ? (arg.c({expression: express})) : ('')));
				str += part;
				if (part && (!(express) || arg != last) && !(arg instanceof Meta)) { str += delim };
			};
			
			return str;
		};
		
		ListNode.prototype.indented = function (a,b){
			if (a instanceof Indentation) {
				this._indentation = a;
				return this;
			};
			
			this._indentation || (this._indentation = a && b ? (new Indentation(a,b)) : (INDENT));
			return this;
		};
		
		
		function ArgList(){ return ListNode.apply(this,arguments) };
		
		subclass$(ArgList,ListNode);
		exports.ArgList = ArgList; // export class 
		
		
		//	def indented a,b
		//		if a isa Indentation
		//			@indentation = a
		//			return self
		//
		//		@indentation ||= a and b ? Indentation.new(a,b) : INDENT
		//		self
		
		// def hasSplat
		// 	@nodes.some do |v| v isa Splat
		// def delimiter
		// 	","
		
		
		function AssignList(){ return ArgList.apply(this,arguments) };
		
		subclass$(AssignList,ArgList);
		exports.AssignList = AssignList; // export class 
		AssignList.prototype.concat = function (other){
			if (this._nodes.length == 0 && (other instanceof AssignList)) {
				return other;
			} else {
				AssignList.__super__.concat.call(this,other);
			};
			// need to store indented content as well?
			// @nodes = nodes.concat(other isa Array ? other : other.nodes)
			return this;
		};
		
		
		function Block(list){
			this.setup();
			// @nodes = compact__(flatten__(list)) or []
			this._nodes = list || [];
			this._head = null;
			this._indentation = null;
		};
		
		subclass$(Block,ListNode);
		exports.Block = Block; // export class 
		Block.prototype.head = function(v){ return this._head; }
		Block.prototype.setHead = function(v){ this._head = v; return this; };
		
		Block.wrap = function (ary){
			if (!((ary instanceof Array))) {
				throw new SyntaxError("what");
			};
			return ary.length == 1 && (ary[0] instanceof Block) ? (ary[0]) : (new Block(ary));
		};
		
		Block.prototype.visit = function (){
			if (this._scope) { this._scope.visit() };
			
			for (var i = 0, ary = iter$(this._nodes), len = ary.length, node; i < len; i++) {
				node = ary[i];
				node && node.traverse();
			};
			return this;
		};
		
		Block.prototype.block = function (){
			return this;
		};
		
		// def indented a,b
		// 	@indentation ||= a and b ? Indentation.new(a,b) : INDENT
		// 	self
		
		Block.prototype.loc = function (){
			// rather indents, no?
			var opt, ind;
			if (opt = this.option('ends')) {
				// p "location is",opt
				var a = opt[0].loc();
				var b = opt[1].loc();
				
				if (!(a)) { this.p(("no loc for " + (opt[0]))) };
				if (!(b)) { this.p(("no loc for " + (opt[1]))) };
				
				return [a[0],b[1]];
			} else if (ind = this._indentation) {
				return [ind.aloc(),ind.bloc()];
			} else {
				return [0,0];
			};
		};
		
		// go through children and unwrap inner nodes
		Block.prototype.unwrap = function (){
			var ary = [];
			for (var i = 0, items = iter$(this.nodes()), len = items.length, node; i < len; i++) {
				node = items[i];
				if (node instanceof Block) {
					// p "unwrapping inner block"
					ary.push.apply(ary,node.unwrap());
				} else {
					ary.push(node);
				};
			};
			return ary;
		};
		
		Block.prototype.push = function (item){
			this._nodes.push(item);
			return this;
		};
		
		Block.prototype.add = function (item){
			this._nodes.push(item);
			return this;
		};
		
		// This is just to work as an inplace replacement of nodes.coffee
		// After things are working okay we'll do bigger refactorings
		Block.prototype.compile = function (o){
			if(o === undefined) o = {};
			var root = new Root(this,o);
			return root.compile(o);
		};
		
		
		// Not sure if we should create a separate block?
		Block.prototype.analyze = function (o){
			// p "analyzing block!!!",o
			if(o === undefined) o = {};
			return this;
		};
		
		Block.prototype.cpart = function (node){
			var out = typeof node == 'string' ? (node) : ((node ? (node.c()) : ("")));
			if (out == null || out == undefined || out == "") { return "" };
			
			if (out instanceof Array) {
				var str = "";
				var l = out.length;
				var i = 0;
				while (i < l){
					str += this.cpart(out[i++]);
				};
				return str;
			};
			
			var hasSemiColon = SEMICOLON_TEST.test(out);
			if (!(hasSemiColon || (node instanceof Meta))) { out += ";" };
			return out;
		};
		
		Block.prototype.js = function (o,opts){
			var ast = this._nodes;
			var l = ast.length;
			// really?
			var express = this.isExpression() || o.isExpression() || (this.option('express') && this.isExpressable());
			if (ast.length == 0) { return '' };
			
			if (express) {
				return Block.__super__.js.call(this,o,{nodes: ast});
			};
			
			var str = "";
			for (var i = 0, ary = iter$(ast), len = ary.length; i < len; i++) {
				str += this.cpart(ary[i]);
			};
			
			// now add the head items as well
			if (this._head && this._head.length > 0) {
				var prefix = "";
				for (var i = 0, ary = iter$(this._head), len = ary.length; i < len; i++) {
					var hv = this.cpart(ary[i]);
					if (hv) { prefix += hv + '\n' };
				};
				str = prefix + str;
			};
			return str;
		};
		
		
		// Should this create the function as well?
		Block.prototype.defers = function (original,replacement){
			var idx = this._nodes.indexOf(original);
			if (idx >= 0) { this._nodes[idx] = replacement };
			var rest = this._nodes.splice(idx + 1);
			return rest;
		};
		
		Block.prototype.expressions = function (){
			var expressions = [];
			for (var i = 0, ary = iter$(this.nodes()), len = ary.length, node; i < len; i++) {
				node = ary[i];
				if (!((node instanceof Terminator))) { expressions.push(node) };
			};
			return expressions;
		};
		
		
		Block.prototype.consume = function (node){
			var before;
			if (node instanceof TagTree) { // special case?!?
				this._nodes = this._nodes.map(function(child) {
					return child.consume(node);
				});
				
				var real = this.expressions();
				// FIXME should not include terminators and comments when counting
				// should only wrap the content in array (returning all parts)
				// for if/else blocks -- not loops
				
				// we need to compare the real length
				if (!node._loop && real.length > 1) {
					// p "lengths",@nodes:length,expressions:length
					var nr = node.blocks().push(this);
					var arr = new Arr(new ArgList(this._nodes));
					arr.indented(this._indentation);
					this._indentation = null;
					
					if (node.reactive()) {
						this._nodes = [Util.callImba("static",[arr,new Num(nr)])];
					} else {
						this._nodes = [arr];
					};
				};
				
				
				
				return this;
			};
			
			// can also return super if it is expressable, but should we really?
			if (before = this.last()) {
				var after = before.consume(node);
				if (after != before) {
					// p "replace node in block {before} -> {after}"
					if (after instanceof Block) {
						// p "replaced with block -- should basically add it instead?"
						after = after.nodes();
					};
					
					this.replace(before,after);
				};
			};
			// really?
			return this;
		};
		
		
		Block.prototype.isExpressable = function (){
			if (!this._nodes.every(function(v) { return v.isExpressable(); })) { return false };
			return true;
		};
		
		Block.prototype.isExpression = function (){
			
			return this.option('express') || this._expression;
		};
		
		
		// this is almost like the old VarDeclarations but without the values
		function VarBlock(){ return ListNode.apply(this,arguments) };
		
		subclass$(VarBlock,ListNode);
		exports.VarBlock = VarBlock; // export class 
		VarBlock.prototype.load = function (list){
			var first = list[0];
			
			if (first instanceof Assign) {
				this._type = first.left()._type;
			} else if (first instanceof VarReference) {
				this._type = first._type;
			};
			// p "here {list[0]} - {@type}"
			// @type = list[0] and list[0].type
			return list;
		};
		
		// TODO All these inner items should rather be straight up literals
		// or basic localvars - without any care whatsoever about adding var to the
		// beginning etc. 
		VarBlock.prototype.addExpression = function (expr){
			// p "VarBlock.addExpression {self} <- {expr}"
			
			if (expr instanceof Assign) {
				// make sure the left-side is a var-reference
				// this should be a different type of assign, no?
				if (expr.left() instanceof VarOrAccess) {
					expr.setLeft(new VarReference(expr.left().value(),this._type));
				};
				
				this.push(expr);
			} else if (expr instanceof Assign) {
				this.addExpression(expr.left()); // make sure this is a valid thing?
				// make this into a tuple instead
				// does not need to be a tuple?
				return new TupleAssign('=',new Tuple(this.nodes()),expr.right());
			} else if (expr instanceof VarOrAccess) {
				// this is really a VarReference
				this.push(new VarReference(expr.value(),this._type));
			} else if ((expr instanceof Splat) && (expr.node() instanceof VarOrAccess)) {
				// p "is a splat - only allowed in tuple-assignment"
				// what?
				expr.setValue(new VarReference(expr.node().value(),this._type));
				this.push(expr);
			} else {
				this.p(("VarBlock.addExpression " + this + " <- " + expr));
				throw "VarBlock does not allow non-variable expressions";
			};
			return this;
		};
		
		
		VarBlock.prototype.isExpressable = function (){
			// we would need to force-drop the variables, makes little sense
			// but, it could be, could just push the variables out?
			return false;
		};
		
		VarBlock.prototype.js = function (o){
			// p "VarBlock"
			// for n in @nodes
			// 	p "VarBlock child {n}"
			var code = compact__(flatten__(cary__(this.nodes())));
			code = code.filter(function(n) { return n != null && n != undefined && n != EMPTY; });
			var out = code.join(",");
			// we just need to trust that the variables have been autodeclared beforehand
			// if we are inside an expression
			if (!o.isExpression()) { out = "var " + out };
			return out;
		};
		
		
		VarBlock.prototype.consume = function (node){
			// It doesnt make much sense for a VarBlock to consume anything
			// it should probably return void for methods
			return this;
		};
		
		
		// Could inherit from valueNode
		function Parens(value,open,close){
			this.setup();
			this._open = open;
			this._close = close;
			this._value = this.load(value);
		};
		
		subclass$(Parens,ValueNode);
		exports.Parens = Parens; // export class 
		Parens.prototype.load = function (value){
			this._noparen = false;
			return (value instanceof Block) && value.count() == 1 ? (value.first()) : (value);
		};
		
		Parens.prototype.isString = function (){
			// checking if this is an interpolated string
			return this._open && String(this._open) == '("' || this.value().isString();
		};
		
		Parens.prototype.js = function (o){
			
			var par = this.up();
			var v = this._value;
			var str = null;
			
			if (v instanceof Func) { this._noparen = true };
			// p "compile parens {v} {v isa Block and v.count}"
			// p "Parens up {par} {o.isExpression}"
			if (par instanceof Block) {
				// is it worth it?
				if (!o.isExpression()) { this._noparen = true };
				str = v instanceof Array ? (cary__(v)) : (v.c({expression: o.isExpression()}));
			} else {
				str = v instanceof Array ? (cary__(v)) : (v.c({expression: true}));
			};
			
			// check if we really need parens here?
			return str;
		};
		
		Parens.prototype.set = function (obj){
			console.log(("Parens set " + JSON.stringify(obj)));
			return Parens.__super__.set.call(this,obj);
		};
		
		
		Parens.prototype.shouldParenthesize = function (){
			// no need to parenthesize if this is a line in a block
			if (this._noparen) { return false }; //  or par isa ArgList
			return true;
		};
		
		
		Parens.prototype.prebreak = function (br){
			Parens.__super__.prebreak.call(this,br);
			console.log("PREBREAK");
			if (this._value) { this._value.prebreak(br) };
			return this;
		};
		
		
		Parens.prototype.isExpressable = function (){
			return this._value.isExpressable();
		};
		
		Parens.prototype.consume = function (node){
			return this._value.consume(node);
		};
		
		
		// Could inherit from valueNode
		// an explicit expression-block (with parens) is somewhat different
		// can be used to return after an expression
		function ExpressionBlock(){ return ListNode.apply(this,arguments) };
		
		subclass$(ExpressionBlock,ListNode);
		exports.ExpressionBlock = ExpressionBlock; // export class 
		ExpressionBlock.prototype.c = function (){
			return this.map(function(item) { return item.c(); }).join(",");
		};
		
		ExpressionBlock.prototype.consume = function (node){
			return this.value().consume(node);
		};
		
		ExpressionBlock.prototype.addExpression = function (expr){
			// Need to take care of the splat here to.. hazzle
			if (expr.node() instanceof Assign) {
				// p "is assignment!"
				this.push(expr.left());
				// make this into a tuple instead
				// possibly fix this as well?!?
				return new TupleAssign('=',new Tuple(this.nodes()),expr.right());
			} else {
				this.push(expr);
			};
			return this;
		};
		
		
		
		// STATEMENTS
		
		function Return(v){
			this._traversed = false;
			this._value = (v instanceof ArgList) && v.count() == 1 ? (v.last()) : (v);
			// @prebreak = v and v.@prebreak
			// console.log "return?!? {v}",@prebreak
			// if v isa ArgList and v.count == 1
			return this;
		};
		
		subclass$(Return,Statement);
		exports.Return = Return; // export class 
		Return.prototype.value = function(v){ return this._value; }
		Return.prototype.setValue = function(v){ this._value = v; return this; };
		
		Return.prototype.visit = function (){
			if (this._value && this._value.traverse) { return this._value.traverse() };
		};
		
		Return.prototype.js = function (o){
			var v = this._value;
			
			if (v instanceof ArgList) {
				return ("return [" + v.c({expression: true}) + "]");
			} else if (v) {
				return ("return " + v.c({expression: true}));
			} else {
				return "return";
			};
		};
		
		Return.prototype.c = function (){
			if (!(this.value()) || this.value().isExpressable()) { return Return.__super__.c.apply(this,arguments) };
			// p "return must cascade into value".red
			return this.value().consume(this).c();
		};
		
		Return.prototype.consume = function (node){
			return this;
		};
		
		function ImplicitReturn(){ return Return.apply(this,arguments) };
		
		subclass$(ImplicitReturn,Return);
		exports.ImplicitReturn = ImplicitReturn; // export class 
		
		
		function GreedyReturn(){ return ImplicitReturn.apply(this,arguments) };
		
		subclass$(GreedyReturn,ImplicitReturn);
		exports.GreedyReturn = GreedyReturn; // export class 
		
		
		// cannot live inside an expression(!)
		function Throw(){ return Statement.apply(this,arguments) };
		
		subclass$(Throw,Statement);
		exports.Throw = Throw; // export class 
		Throw.prototype.js = function (o){
			return ("throw " + (this.value().c()));
		};
		
		Throw.prototype.consume = function (node){
			// ROADMAP should possibly consume to the value of throw and then throw?
			return this;
		};
		
		
		function LoopFlowStatement(lit,expr){
			this.setLiteral(lit);
			this.setExpression(expr); // && ArgList.new(expr) # really?
		};
		
		subclass$(LoopFlowStatement,Statement);
		exports.LoopFlowStatement = LoopFlowStatement; // export class 
		LoopFlowStatement.prototype.literal = function(v){ return this._literal; }
		LoopFlowStatement.prototype.setLiteral = function(v){ this._literal = v; return this; };
		LoopFlowStatement.prototype.expression = function(v){ return this._expression; }
		LoopFlowStatement.prototype.setExpression = function(v){ this._expression = v; return this; };
		
		LoopFlowStatement.prototype.visit = function (){
			if (this.expression()) { return this.expression().traverse() };
		};
		
		LoopFlowStatement.prototype.consume = function (node){
			// p "break/continue should consume?!"
			return this;
		};
		
		LoopFlowStatement.prototype.c = function (){
			if (!(this.expression())) { return LoopFlowStatement.__super__.c.apply(this,arguments) };
			// get up to the outer loop
			var _loop = STACK.up(Loop);
			// p "found loop?",_loop
			
			// need to fix the grammar for this. Right now it 
			// is like a fake call, but should only care about the first argument
			var expr = this.expression();
			
			if (_loop.catcher()) {
				expr = expr.consume(_loop.catcher());
				var copy = new this.constructor(this.literal());
				return new Block([expr,copy]).c();
			} else if (expr) {
				copy = new this.constructor(this.literal());
				return new Block([expr,copy]).c();
			} else {
				return LoopFlowStatement.__super__.c.apply(this,arguments);
			};
			// return "loopflow"
		};
		
		
		function BreakStatement(){ return LoopFlowStatement.apply(this,arguments) };
		
		subclass$(BreakStatement,LoopFlowStatement);
		exports.BreakStatement = BreakStatement; // export class 
		BreakStatement.prototype.js = function (o){
			return "break";
		};
		
		function ContinueStatement(){ return LoopFlowStatement.apply(this,arguments) };
		
		subclass$(ContinueStatement,LoopFlowStatement);
		exports.ContinueStatement = ContinueStatement; // export class 
		ContinueStatement.prototype.js = function (o){
			return "continue";
		};
		
		function DebuggerStatement(){ return Statement.apply(this,arguments) };
		
		subclass$(DebuggerStatement,Statement);
		exports.DebuggerStatement = DebuggerStatement; // export class 
		
		
		
		// PARAMS
		
		function Param(name,defaults,typ){
			// could have introduced bugs by moving back to identifier here
			this._traversed = false;
			this._name = name; // .value # this is an identifier(!)
			this._defaults = defaults;
			this._typ = typ;
			this._variable = null;
		};
		
		subclass$(Param,Node);
		exports.Param = Param; // export class 
		Param.prototype.name = function(v){ return this._name; }
		Param.prototype.setName = function(v){ this._name = v; return this; };
		Param.prototype.index = function(v){ return this._index; }
		Param.prototype.setIndex = function(v){ this._index = v; return this; };
		Param.prototype.defaults = function(v){ return this._defaults; }
		Param.prototype.setDefaults = function(v){ this._defaults = v; return this; };
		Param.prototype.splat = function(v){ return this._splat; }
		Param.prototype.setSplat = function(v){ this._splat = v; return this; };
		Param.prototype.variable = function(v){ return this._variable; }
		Param.prototype.setVariable = function(v){ this._variable = v; return this; };
		
		// what about object-params?
		
		Param.prototype.varname = function (){
			return this._variable ? (this._variable.c()) : (this.name());
		};
		
		Param.prototype.js = function (o){
			if (this._variable) { return this._variable.c() };
			
			if (this.defaults()) {
				// should not include any source-mapping here?
				return ("if(" + (this.name().c()) + " == null) " + (this.name().c()) + " = " + (this.defaults().c()));
			};
			// see if this is the initial declarator?
		};
		
		Param.prototype.visit = function (){
			var variable_, v_;
			if (this._defaults) { this._defaults.traverse() };
			(variable_ = this.variable()) || ((this.setVariable(v_ = this.scope__().register(this.name(),this)),v_));
			
			if (this._name instanceof Identifier) {
				// change type here?
				if (this._name._value) { this._name._value._type = "PARAMVAR" };
				this._name.references(this._variable);
				// console.log "got here!! {@name:constructor}"
				// @name.@token.@variable = @variable if @name.@token
			};
			
			return this;
		};
		
		Param.prototype.assignment = function (){
			return OP('=',this.variable().accessor(),this.defaults());
		};
		
		Param.prototype.isExpressable = function (){
			return !(this.defaults()) || this.defaults().isExpressable();
			// p "visiting param!!!"
		};
		
		Param.prototype.dump = function (){
			return {loc: this.loc()};
		};
		
		Param.prototype.loc = function (){
			return this._name && this._name.region();
		};
		
		Param.prototype.toJSON = function (){
			return {
				type: this.typeName(),
				name: this.name(),
				defaults: this.defaults()
			};
		};
		
		
		function SplatParam(){ return Param.apply(this,arguments) };
		
		subclass$(SplatParam,Param);
		exports.SplatParam = SplatParam; // export class 
		SplatParam.prototype.loc = function (){
			// hacky.. cannot know for sure that this is right?
			var r = this.name().region();
			return [r[0] - 1,r[1]];
		};
		
		function BlockParam(){ return Param.apply(this,arguments) };
		
		subclass$(BlockParam,Param);
		exports.BlockParam = BlockParam; // export class 
		BlockParam.prototype.c = function (){
			return "blockparam";
		};
		
		BlockParam.prototype.loc = function (){
			// hacky.. cannot know for sure that this is right?
			var r = this.name().region();
			return [r[0] - 1,r[1]];
		};
		
		
		function OptionalParam(){ return Param.apply(this,arguments) };
		
		subclass$(OptionalParam,Param);
		exports.OptionalParam = OptionalParam; // export class 
		
		
		function NamedParam(){ return Param.apply(this,arguments) };
		
		subclass$(NamedParam,Param);
		exports.NamedParam = NamedParam; // export class 
		
		
		function RequiredParam(){ return Param.apply(this,arguments) };
		
		subclass$(RequiredParam,Param);
		exports.RequiredParam = RequiredParam; // export class 
		
		
		function NamedParams(){ return ListNode.apply(this,arguments) };
		
		subclass$(NamedParams,ListNode);
		exports.NamedParams = NamedParams; // export class 
		NamedParams.prototype.index = function(v){ return this._index; }
		NamedParams.prototype.setIndex = function(v){ this._index = v; return this; };
		NamedParams.prototype.variable = function(v){ return this._variable; }
		NamedParams.prototype.setVariable = function(v){ this._variable = v; return this; };
		
		NamedParams.prototype.load = function (list){
			var load = function(k) { return new NamedParam(k.key(),k.value()); };
			return list instanceof Obj ? (list.value().map(load)) : (list);
		};
		
		NamedParams.prototype.visit = function (){
			var s = this.scope__();
			this._variable || (this._variable = s.temporary(this,{pool: 'keypars'}));
			this._variable.predeclared();
			
			// this is a listnode, which will automatically traverse
			// and visit all children
			NamedParams.__super__.visit.apply(this,arguments);
			// register the inner variables as well(!)
			return this;
		};
		
		
		NamedParams.prototype.varname = function (){
			return this.variable().c();
		};
		
		NamedParams.prototype.name = function (){
			return this.varname();
		};
		
		NamedParams.prototype.js = function (o){
			return "namedpar";
		};
		
		NamedParams.prototype.toJSON = function (){
			return {
				type: this.typeName(),
				nodes: this.filter(function(v) { return v instanceof NamedParam; })
			};
		};
		
		
		function IndexedParam(){ return Param.apply(this,arguments) };
		
		subclass$(IndexedParam,Param);
		exports.IndexedParam = IndexedParam; // export class 
		IndexedParam.prototype.parent = function(v){ return this._parent; }
		IndexedParam.prototype.setParent = function(v){ this._parent = v; return this; };
		IndexedParam.prototype.subindex = function(v){ return this._subindex; }
		IndexedParam.prototype.setSubindex = function(v){ this._subindex = v; return this; };
		
		IndexedParam.prototype.visit = function (){
			// p "VISIT PARAM {name}!"
			// ary.[-1] # possible
			// ary.(-1) # possible
			// str(/ok/,-1)
			// scope.register(@name,self)
			// BUG The defaults should probably be looked up like vars
			var variable_, v_;
			(variable_ = this.variable()) || ((this.setVariable(v_ = this.scope__().register(this.name(),this)),v_));
			this.variable().proxy(this.parent().variable(),this.subindex());
			return this;
		};
		
		
		function ArrayParams(){ return ListNode.apply(this,arguments) };
		
		subclass$(ArrayParams,ListNode);
		exports.ArrayParams = ArrayParams; // export class 
		ArrayParams.prototype.index = function(v){ return this._index; }
		ArrayParams.prototype.setIndex = function(v){ this._index = v; return this; };
		ArrayParams.prototype.variable = function(v){ return this._variable; }
		ArrayParams.prototype.setVariable = function(v){ this._variable = v; return this; };
		
		ArrayParams.prototype.visit = function (){
			var s = this.scope__();
			this._variable || (this._variable = s.temporary(this,{pool: 'keypars'}));
			this._variable.predeclared();
			
			// now when we loop through these inner params - we create the pars
			// with the correct name, but bind them to the parent
			return ArrayParams.__super__.visit.apply(this,arguments);
		};
		
		ArrayParams.prototype.name = function (){
			return this.variable().c();
		};
		
		ArrayParams.prototype.load = function (list){
			var self = this;
			if (!((list instanceof Arr))) { return null };
			// p "loading arrayparams"
			// try the basic first
			if (!list.splat()) {
				return list.value().map(function(v,i) {
					// must make sure the params are supported here
					// should really not parse any array at all(!)
					var name = v;
					if (v instanceof VarOrAccess) {
						// p "varoraccess {v.value}"
						// FIX?
						name = v.value().value();
						// this is accepted
					};
					return self.parse(name,v,i);
				});
			};
		};
		
		ArrayParams.prototype.parse = function (name,child,i){
			var param = new IndexedParam(name,null);
			
			param.setParent(this);
			param.setSubindex(i);
			return param;
		};
		
		ArrayParams.prototype.head = function (ast){
			// "arrayparams"
			return this;
		};
		
		function ParamList(){ return ListNode.apply(this,arguments) };
		
		subclass$(ParamList,ListNode);
		exports.ParamList = ParamList; // export class 
		ParamList.prototype.splat = function(v){ return this._splat; }
		ParamList.prototype.setSplat = function(v){ this._splat = v; return this; };
		ParamList.prototype.block = function(v){ return this._block; }
		ParamList.prototype.setBlock = function(v){ this._block = v; return this; };
		
		ParamList.prototype.at = function (index,force,name){
			if(force === undefined) force = false;
			if(name === undefined) name = null;
			if (force) {
				while (this.count() <= index){
					this.add(new Param(this.count() == index && name || ("_" + this.count())));
				};
				// need to visit at the same time, no?
			};
			return this.list()[index];
		};
		
		ParamList.prototype.metadata = function (){
			return this.filter(function(par) { return !(par instanceof Meta); });
		};
		
		ParamList.prototype.toJSON = function (){
			return this.metadata();
		};
		
		ParamList.prototype.visit = function (){
			this._splat = this.filter(function(par) { return par instanceof SplatParam; })[0];
			var blk = this.filter(function(par) { return par instanceof BlockParam; });
			
			if (blk.length > 1) {
				blk[1].warn("a method can only have one &block parameter");
			} else if (blk[0] && blk[0] != this.last()) {
				blk[0].warn("&block must be the last parameter of a method");
				// warn "&block must be the last parameter of a method", blk[0]
			};
			
			// add more warnings later(!)
			// should probably throw error as well to stop compilation
			
			// need to register the required-pars as variables
			return ParamList.__super__.visit.apply(this,arguments);
		};
		
		ParamList.prototype.js = function (o){
			if (this.count() == 0) { return EMPTY };
			if (o.parent() instanceof Block) { return this.head(o) };
			
			// items = map(|arg| arg.name.c ).compact
			// return null unless items[0]
			
			if (o.parent() instanceof Code) {
				// remove the splat, for sure.. need to handle the other items as well
				// this is messy with references to argvars etc etc. Fix
				var pars = this.nodes();
				// pars = filter(|arg| arg != @splat && !(arg isa BlockParam)) if @splat
				if (this._splat) { pars = this.filter(function(arg) { return (arg instanceof RequiredParam) || (arg instanceof OptionalParam); }) };
				return compact__(pars.map(function(arg) { return c__(arg.varname()); })).join(",");
			} else {
				throw "not implemented paramlist js";
				return "ta" + compact__(this.map(function(arg) { return arg.c(); })).join(",");
			};
		};
		
		ParamList.prototype.head = function (o){
			var reg = [];
			var opt = [];
			var blk = null;
			var splat = null;
			var named = null;
			var arys = [];
			var signature = [];
			var idx = 0;
			
			this.nodes().forEach(function(par,i) {
				par.setIndex(idx);
				if (par instanceof NamedParams) {
					signature.push('named');
					named = par;
				} else if (par instanceof OptionalParam) {
					signature.push('opt');
					opt.push(par);
				} else if (par instanceof BlockParam) {
					signature.push('blk');
					blk = par;
				} else if (par instanceof SplatParam) {
					signature.push('splat');
					splat = par;
					idx -= 1; // this should really be removed from the list, no?
				} else if (par instanceof ArrayParams) {
					arys.push(par);
					signature.push('ary');
				} else {
					signature.push('reg');
					reg.push(par);
				};
				return idx++;
			});
			
			if (named) {
				var namedvar = named.variable();
			};
			
			// var opt = nodes.filter(|n| n isa OptionalParam)
			// var blk = nodes.filter(|n| n isa BlockParam)[0]
			// var splat = nodes.filter(|n| n isa SplatParam)[0]
			
			// simple situation where we simply switch
			// can probably optimize by not looking at arguments at all
			var ast = [];
			var isFunc = function(js) { return ("typeof " + js + " == 'function'"); };
			
			// This is broken when dealing with iframes anc XSS scripting
			// but for now it is the best test for actual arguments
			// can also do constructor.name == 'Object'
			var isObj = function(js) { return ("" + js + ".constructor === Object"); };
			var isntObj = function(js) { return ("" + js + ".constructor !== Object"); };
			// should handle some common cases in a cleaner (less verbose) manner
			// does this work with default params after optional ones? Is that even worth anything?
			// this only works in one direction now, unlike TupleAssign
			
			// we dont really check the length etc now -- so it is buggy for lots of arguments
			
			// if we have optional params in the regular order etc we can go the easy route
			// slightly hacky now. Should refactor all of these to use the signature?
			if (!(named) && !(splat) && !(blk) && opt.length > 0 && signature.join(" ").match(/opt$/)) {
				for (var i = 0, len_ = opt.length, par; i < len_; i++) {
					par = opt[i];
					ast.push(("if(" + (par.name().c()) + " === undefined) " + (par.name().c()) + " = " + (par.defaults().c())));
				};
			} else if (named && !(splat) && !(blk) && opt.length == 0) { // and no block?!
				// different shorthands
				// if named
				ast.push(("if(!" + (namedvar.c()) + "||" + isntObj(namedvar.c()) + ") " + (namedvar.c()) + " = \{\}"));
			} else if (blk && opt.length == 1 && !(splat) && !(named)) {
				var op = opt[0];
				var opn = op.name().c();
				var bn = blk.name().c();
				ast.push(("if(" + bn + "==undefined && " + isFunc(opn) + ") " + bn + " = " + opn + "," + opn + " = " + (op.defaults().c())));
				ast.push(("if(" + opn + "==undefined) " + opn + " = " + (op.defaults().c())));
			} else if (blk && named && opt.length == 0 && !(splat)) {
				bn = blk.name().c();
				ast.push(("if(" + bn + "==undefined && " + isFunc(namedvar.c()) + ") " + bn + " = " + (namedvar.c()) + "," + (namedvar.c()) + " = \{\}"));
				ast.push(("else if(!" + (namedvar.c()) + "||" + isntObj(namedvar.c()) + ") " + (namedvar.c()) + " = \{\}"));
			} else if (opt.length > 0 || splat) { // && blk  # && !splat
				
				var argvar = this.scope__().temporary(this,{pool: 'arguments'}).predeclared().c();
				var len = this.scope__().temporary(this,{pool: 'counter'}).predeclared().c();
				
				var last = ("" + argvar + "[" + len + "-1]");
				var pop = ("" + argvar + "[--" + len + "]");
				ast.push(("var " + argvar + " = arguments, " + len + " = " + argvar + ".length"));
				
				if (blk) {
					bn = blk.name().c();
					if (splat) {
						ast.push(("var " + bn + " = " + isFunc(last) + " ? " + pop + " : null"));
					} else if (reg.length > 0) {
						// ast.push "// several regs really?"
						ast.push(("var " + bn + " = " + len + " > " + (reg.length) + " && " + isFunc(last) + " ? " + pop + " : null"));
					} else {
						ast.push(("var " + bn + " = " + isFunc(last) + " ? " + pop + " : null"));
					};
				};
				
				// if we have named params - look for them before splat
				// should probably loop through pars in the same order they were added
				// should it be prioritized above optional objects??
				if (named) {
					// should not include it when there is a splat?
					ast.push(("var " + (namedvar.c()) + " = " + last + "&&" + isObj(last) + " ? " + pop + " : \{\}"));
				};
				
				for (var i1 = 0, len_ = opt.length, par1; i1 < len_; i1++) {
					par1 = opt[i1];
					ast.push(("if(" + len + " < " + (par1.index() + 1) + ") " + (par1.name().c()) + " = " + (par1.defaults().c())));
				};
				
				// add the splat
				if (splat) {
					var sn = splat.name().c();
					var si = splat.index();
					
					if (si == 0) {
						ast.push(("var " + sn + " = new Array(" + len + ">" + si + " ? " + len + " : 0)"));
						ast.push(("while(" + len + ">" + si + ") " + sn + "[" + len + "-1] = " + pop));
					} else {
						ast.push(("var " + sn + " = new Array(" + len + ">" + si + " ? " + len + "-" + si + " : 0)"));
						ast.push(("while(" + len + ">" + si + ") " + sn + "[--" + len + " - " + si + "] = " + argvar + "[" + len + "]"));
					};
				};
				
				// if named
				// 	for k,i in named.nodes
				// 		# OP('.',namedvar) <- this is the right way, with invalid names etc
				// 		var op = OP('.',namedvar,k.key).c
				// 		ast.push "var {k.key.c} = {op} !== undefined ? {op} : {k.value.c}"
				
				// if named
				
				// return ast.join(";\n") + ";"
				// return "if({opt[0].name.c} instanceof Function) {blk.c} = {opt[0].c};"
			} else if (opt.length > 0) {
				for (var i2 = 0, len_ = opt.length, par2; i2 < len_; i2++) {
					par2 = opt[i2];
					ast.push(("if(" + (par2.name().c()) + " === undefined) " + (par2.name().c()) + " = " + (par2.defaults().c())));
				};
			};
			
			// now set stuff if named params(!)
			
			if (named) {
				for (var i3 = 0, ary = iter$(named.nodes()), len_ = ary.length, k; i3 < len_; i3++) {
					// console.log "named var {k.c}"
					k = ary[i3];
					op = OP('.',namedvar,k.c()).c();
					ast.push(("var " + (k.c()) + " = " + op + " !== undefined ? " + op + " : " + (k.defaults().c())));
				};
			};
			
			if (arys.length) {
				for (var i4 = 0, len_ = arys.length; i4 < len_; i4++) {
					// create tuples
					// p "adding arrayparams"
					arys[i4].head(o,ast,this);
					// ast.push v.c
				};
			};
			
			
			
			// if opt:length == 0
			return ast.length > 0 ? ((ast.join(";\n") + ";")) : (EMPTY);
		};
		
		
		// Legacy. Should move away from this?
		function VariableDeclaration(){ return ListNode.apply(this,arguments) };
		
		subclass$(VariableDeclaration,ListNode);
		exports.VariableDeclaration = VariableDeclaration; // export class 
		VariableDeclaration.prototype.kind = function(v){ return this._kind; }
		VariableDeclaration.prototype.setKind = function(v){ this._kind = v; return this; };
		
		// we want to register these variables in
		VariableDeclaration.prototype.add = function (name,init,pos){
			if(pos === undefined) pos = -1;
			var vardec = new VariableDeclarator(name,init);
			if (name instanceof Variable) { (vardec.setVariable(name),name) };
			pos == 0 ? (this.unshift(vardec)) : (this.push(vardec));
			return vardec;
			
			// TODO (target) << (node) rewrites to a caching push which returns node
		};
		
		// def remove item
		// 	if item isa Variable
		// 		map do |v,i|
		// 			if v.variable == item
		// 				p "found variable to remove"
		// 				super.remove(v)
		// 	else
		// 		super.remove(item)
		// 	self
		
		VariableDeclaration.prototype.load = function (list){
			// temporary solution!!!
			return list.map(function(par) { return new VariableDeclarator(par.name(),par.defaults(),par.splat()); });
		};
		
		VariableDeclaration.prototype.isExpressable = function (){
			return this.nodes().every(function(item) { return item.isExpressable(); });
		};
		
		VariableDeclaration.prototype.js = function (o){
			if (this.count() == 0) { return EMPTY };
			
			if (this.count() == 1 && !(this.isExpressable())) {
				// p "SHOULD ALTER VARDEC!!!".cyan
				this.first().variable().autodeclare();
				var node = this.first().assignment();
				return node.c();
			};
			
			// FIX PERFORMANCE
			var out = compact__(cary__(this.nodes())).join(", ");
			return out ? (("var " + out)) : ("");
			// "var " + compact__(cary__(nodes)).join(", ") + ""
		};
		
		function VariableDeclarator(){ return Param.apply(this,arguments) };
		
		subclass$(VariableDeclarator,Param);
		exports.VariableDeclarator = VariableDeclarator; // export class 
		VariableDeclarator.prototype.visit = function (){
			// even if we should traverse the defaults as if this variable does not exist
			// we need to preregister it and then activate it later
			var variable_, v_;
			(variable_ = this.variable()) || ((this.setVariable(v_ = this.scope__().register(this.name(),null)),v_));
			if (this.defaults()) { this.defaults().traverse() };
			// WARN what if it is already declared?
			this.variable().setDeclarator(this);
			this.variable().addReference(this.name());
			return this;
		};
		
		// needs to be linked up to the actual scoped variables, no?
		VariableDeclarator.prototype.js = function (o){
			if (this.variable()._proxy) { return null };
			
			var defs = this.defaults();
			// FIXME need to deal with var-defines within other statements etc
			// FIXME need better syntax for this
			if (defs != null && defs != undefined) {
				// console.log "defaults is {defaults}"
				if (defs instanceof Node) { defs = defs.c({expression: true}) };
				
				return ("" + (this.variable().c()) + " = " + defs);
			} else {
				return ("" + (this.variable().c()));
			};
		};
		
		VariableDeclarator.prototype.accessor = function (){
			return this;
		};
		
		
		// TODO clean up and refactor all the different representations of vars
		// VarName, VarReference, LocalVarAccess?
		function VarName(a,b){
			VarName.__super__.constructor.apply(this,arguments);
			this._splat = b;
		};
		
		subclass$(VarName,ValueNode);
		exports.VarName = VarName; // export class 
		VarName.prototype.variable = function(v){ return this._variable; }
		VarName.prototype.setVariable = function(v){ this._variable = v; return this; };
		VarName.prototype.splat = function(v){ return this._splat; }
		VarName.prototype.setSplat = function(v){ this._splat = v; return this; };
		
		VarName.prototype.visit = function (){
			// p "visiting varname(!)", value.c
			// should we not lookup instead?
			// FIXME p "register value {value.c}"
			var variable_, v_;
			(variable_ = this.variable()) || ((this.setVariable(v_ = this.scope__().register(this.value().c(),null)),v_));
			this.variable().setDeclarator(this);
			this.variable().addReference(this.value());
			return this;
		};
		
		VarName.prototype.js = function (o){
			return this.variable().c();
		};
		
		VarName.prototype.c = function (){
			return this.variable().c();
		};
		
		
		function VarList(t,l,r){
			this._traversed = false;
			this._type = this.type();
			this._left = l;
			this._right = r;
		};
		
		subclass$(VarList,Node);
		exports.VarList = VarList; // export class 
		VarList.prototype.type = function(v){ return this._type; }
		VarList.prototype.setType = function(v){ this._type = v; return this; }; // let / var / const
		VarList.prototype.left = function(v){ return this._left; }
		VarList.prototype.setLeft = function(v){ this._left = v; return this; };
		VarList.prototype.right = function(v){ return this._right; }
		VarList.prototype.setRight = function(v){ this._right = v; return this; };
		
		// format :type, :left, :right
		
		// should throw error if there are more values on right than left
		
		VarList.prototype.visit = function (){
			
			// we need to carefully traverse children in the right order
			// since we should be able to reference
			var r;
			for (var i = 0, ary = iter$(this.left()), len = ary.length; i < len; i++) {
				ary[i].traverse(); // this should really be a var-declaration
				if (r = this.right()[i]) { r.traverse() };
			};
			return this;
		};
		
		VarList.prototype.js = function (o){
			// for the regular items 
			var pairs = [];
			var ll = this.left().length;
			var rl = this.right().length;
			var v = null;
			
			// splatting here we come
			if (ll > 1 && rl == 1) {
				this.p("multiassign!");
				var r = this.right()[0];
				r.cache();
				for (var i = 0, ary = iter$(this.left()), len = ary.length, l; i < len; i++) {
					l = ary[i];
					if (l.splat()) {
						throw "not supported?";
						this.p("splat"); // FIX reimplement slice?
						if (i == ll - 1) {
							v = this.util().slice(r,i);
							this.p("last");
						} else {
							v = this.util().slice(r,i,-(ll - i) + 1);
						};
					} else {
						v = OP('.',r,num__(i));
					};
					
					pairs.push(OP('=',l,v));
				};
			} else {
				for (var i1 = 0, ary = iter$(this.left()), len = ary.length, l1; i1 < len; i1++) {
					l1 = ary[i1];
					r = this.right()[i1];
					pairs.push(r ? (OP('=',l1.variable().accessor(),r)) : (l1));
				};
			};
			
			return ("var " + (pairs.c()));
		};
		
		
		// CODE
		
		function Code(){ return Node.apply(this,arguments) };
		
		subclass$(Code,Node);
		exports.Code = Code; // export class 
		Code.prototype.head = function(v){ return this._head; }
		Code.prototype.setHead = function(v){ this._head = v; return this; };
		Code.prototype.body = function(v){ return this._body; }
		Code.prototype.setBody = function(v){ this._body = v; return this; };
		Code.prototype.scope = function(v){ return this._scope; }
		Code.prototype.setScope = function(v){ this._scope = v; return this; };
		Code.prototype.params = function(v){ return this._params; }
		Code.prototype.setParams = function(v){ this._params = v; return this; };
		
		Code.prototype.scopetype = function (){
			return Scope;
		};
		
		Code.prototype.visit = function (){
			if (this._scope) { this._scope.visit() };
			// @scope.parent = STACK.scope(1) if @scope
			return this;
		};
		
		
		// Rename to Program?
		function Root(body,opts){
			// p "create root!"
			this._traversed = false;
			this._body = blk__(body);
			this._scope = new RootScope(this,null);
			this._options = {};
		};
		
		subclass$(Root,Code);
		exports.Root = Root; // export class 
		Root.prototype.visit = function (){
			ROOT = STACK.ROOT = this._scope;
			this.scope().visit();
			return this.body().traverse();
		};
		
		Root.prototype.compile = function (o){
			STACK.reset(); // -- nested compilation does not work now
			OPTS = STACK._options = this._options = o || {};
			
			this.traverse();
			
			var out = this.c();
			var result = {
				js: out,
				ast: this,
				warnings: this.scope().warnings(),
				options: o,
				toString: function() { return this.js; }
			};
			if (o.sourceMapInline || o.sourceMap) {
				result.sourcemap = new SourceMap(result).generate();
			};
			
			return result;
		};
		
		Root.prototype.js = function (o){
			var out;
			if (this._options.bare) {
				out = this.scope().c();
			} else {
				this.body().consume(new ImplicitReturn());
				out = this.scope().c({indent: true});
				out = out.replace(/^\n?/,'\n');
				out = out.replace(/\n?$/,'\n\n');
				out = '(function(){' + out + '})()';
			};
			
			// find and replace shebangs
			var shebangs = [];
			out = out.replace(/^[ \t]*\/\/(\!.+)$/mg,function(m,shebang) {
				// p "found shebang {shebang}"
				shebang = shebang.replace(/\bimba\b/g,'node');
				shebangs.push(("#" + shebang + "\n"));
				return "";
			});
			
			out = shebangs.join('') + out;
			
			return out;
		};
		
		
		Root.prototype.analyze = function (pars){
			if(!pars||pars.constructor !== Object) pars = {};
			var loglevel = pars.loglevel !== undefined ? pars.loglevel : 0;
			var entities = pars.entities !== undefined ? pars.entities : false;
			var scopes = pars.scopes !== undefined ? pars.scopes : true;
			STACK.setLoglevel(loglevel);
			STACK._analyzing = true;
			ROOT = STACK.ROOT = this._scope;
			
			OPTS = {
				analysis: {
					entities: entities,
					scopes: scopes
				}
			};
			
			this.traverse();
			STACK._analyzing = false;
			
			return this.scope().dump();
		};
		
		Root.prototype.inspect = function (){
			return true;
		};
		
		function ClassDeclaration(name,superclass,body){
			// what about the namespace?
			this._traversed = false;
			this._name = name;
			this._superclass = superclass;
			this._scope = new ClassScope(this);
			this._body = blk__(body);
			this;
		};
		
		subclass$(ClassDeclaration,Code);
		exports.ClassDeclaration = ClassDeclaration; // export class 
		ClassDeclaration.prototype.name = function(v){ return this._name; }
		ClassDeclaration.prototype.setName = function(v){ this._name = v; return this; };
		ClassDeclaration.prototype.superclass = function(v){ return this._superclass; }
		ClassDeclaration.prototype.setSuperclass = function(v){ this._superclass = v; return this; };
		ClassDeclaration.prototype.initor = function(v){ return this._initor; }
		ClassDeclaration.prototype.setInitor = function(v){ this._initor = v; return this; };
		
		ClassDeclaration.prototype.consume = function (node){
			if (node instanceof Return) {
				this.option('return',true);
				return this;
			};
			return ClassDeclaration.__super__.consume.apply(this,arguments);
		};
		
		ClassDeclaration.prototype.namepath = function (){
			return this._namepath || (this._namepath = ("" + (this.name().c())));
		};
		
		ClassDeclaration.prototype.metadata = function (){
			var superclass_;
			return {
				type: 'class',
				namepath: this.namepath(),
				inherits: (superclass_ = this.superclass()) && superclass_.namepath  &&  superclass_.namepath(),
				path: this.name().c().toString(),
				desc: this._desc,
				loc: this.loc()
			};
		};
		
		ClassDeclaration.prototype.toJSON = function (){
			return this.metadata();
		};
		
		ClassDeclaration.prototype.visit = function (){
			// replace with some advanced lookup?
			ROOT.entities().add(this.namepath(),this);
			this.scope().visit();
			this.body().traverse();
			return this;
		};
		
		ClassDeclaration.prototype.js = function (o){
			this.scope().virtualize(); // is this always needed?
			this.scope().context().setValue(this.name());
			
			// should probably also warn about stuff etc
			if (this.option('extension')) {
				return this.body().c();
			};
			
			var head = [];
			var o = this._options || {};
			var cname = this.name() instanceof Access ? (this.name().right()) : (this.name());
			var namespaced = this.name() != cname;
			var initor = null;
			var sup = this.superclass();
			
			var bodyindex = -1;
			var spaces = this.body().filter(function(item) { return item instanceof Terminator; });
			var mark = mark__(this.option('keyword'));
			
			this.body().map(function(c,i) {
				if ((c instanceof MethodDeclaration) && c.type() == 'constructor') {
					return bodyindex = i;
				};
			});
			
			if (bodyindex >= 0) {
				initor = this.body().removeAt(bodyindex);
			};
			
			// var initor = body.pluck do |c| c isa MethodDeclaration && c.type == :constructor
			// compile the cname
			if (typeof cname != 'string') { cname = cname.c() };
			
			var cpath = typeof this.name() == 'string' ? (this.name()) : (this.name().c());
			
			if (!(initor)) {
				if (sup) {
					initor = ("" + mark + "function " + cname + "()\{ return " + (sup.c()) + ".apply(this,arguments) \};\n\n");
				} else {
					initor = ("" + mark + "function " + cname + "()") + '{ };\n\n';
				};
			} else {
				initor.setName(cname);
				initor = initor.c() + ';';
			};
			
			// if we are defining a class inside a namespace etc -- how should we set up the class?
			
			if (namespaced) {
				// should use Nodes to build this instead
				initor = ("" + cpath + " = " + initor); // OP('=',name,initor)
			};
			
			head.push(initor); // // @class {cname}\n
			
			if (bodyindex >= 0) {
				// add the space after initor?
				if (this.body().index(bodyindex) instanceof Terminator) {
					head.push(this.body().removeAt(bodyindex));
				};
			} else {
				// head.push(Terminator.new('\n\n'))
				true;
			};
			
			
			
			if (sup) {
				// console.log "deal with superclass!"
				// head.push("// extending the superclass\nimba$class({name.c},{sup.c});\n\n")
				head.push(new Util.Subclass([this.name(),sup]));
			};
			
			// only if it is not namespaced
			if (o.global && !(namespaced)) { // option(:global)
				head.push(("global." + cname + " = " + cpath + "; // global class \n"))
			};
			
			if (o.export && !(namespaced)) {
				head.push(("exports." + cname + " = " + cpath + "; // export class \n"))
			};
			
			// FIXME
			// if namespaced and (o:local or o:export)
			// 	console.log "namespaced classes are implicitly local/global depending on the namespace"
			
			if (this.option('return')) {
				this.body().push(("return " + cpath + ";"));
			};
			
			for (var i = 0, ary = iter$(head.reverse()), len = ary.length; i < len; i++) {
				this.body().unshift(ary[i]);
			};
			this.body()._indentation = null;
			var end = this.body().index(this.body().count() - 1);
			if ((end instanceof Terminator) && end.c().length == 1) { this.body().pop() };
			
			var out = this.body().c();
			
			return out;
		};
		
		
		function TagDeclaration(name,superclass,body){
			// what about the namespace?
			// @name = TagTypeRef.new(name)
			this._traversed = false;
			this._name = name;
			this._superclass = superclass;
			this._scope = new TagScope(this);
			this._body = blk__(body || []);
		};
		
		subclass$(TagDeclaration,Code);
		exports.TagDeclaration = TagDeclaration; // export class 
		TagDeclaration.prototype.name = function(v){ return this._name; }
		TagDeclaration.prototype.setName = function(v){ this._name = v; return this; };
		TagDeclaration.prototype.superclass = function(v){ return this._superclass; }
		TagDeclaration.prototype.setSuperclass = function(v){ this._superclass = v; return this; };
		TagDeclaration.prototype.initor = function(v){ return this._initor; }
		TagDeclaration.prototype.setInitor = function(v){ this._initor = v; return this; };
		
		TagDeclaration.prototype.namepath = function (){
			return ("<" + this.name() + ">");
		};
		
		TagDeclaration.prototype.toJSON = function (){
			return {
				type: 'tag',
				namepath: this.namepath(),
				inherits: this.superclass() ? (("<" + (this.superclass().name()) + ">")) : (null),
				loc: this.loc(),
				desc: this._desc
			};
		};
		
		TagDeclaration.prototype.visit = function (){
			ROOT.entities().register(this); // what if this is not local?
			
			for (var i = 0, ary = iter$(STACK.scopes()), len = ary.length, scope; i < len; i++) {
				scope = ary[i];
				if (i > 0 && (scope instanceof TagScope)) {
					// register inside here?
					scope.node().option('hasLocalTags',true);
					this.option('parent',scope.node());
					break;
					// console.log "tag is local!!!"
				};
			};
			// replace with some advanced lookup?
			this.scope().visit();
			return this.body().traverse();
		};
		
		TagDeclaration.prototype.id = function (){
			return this.name().id();
		};
		
		TagDeclaration.prototype.tagspace = function (){
			var ctx = this.scope().closure().tagContextPath();
			return this.name().ns() ? (("" + ctx + "." + (this.name().ns().toUpperCase()))) : (ctx);
		};
		
		TagDeclaration.prototype.js = function (o){
			this.scope().context().setValue(this._ctx = this.scope().declare('tag',null,{system: true}));
			
			var ns = this.name().ns();
			var mark = mark__(this.option('keyword'));
			
			var params = [helpers.singlequote(this.name().name())];
			var cbody = this.body().c();
			// var outbody = body.count ? ", function({@ctx.c})\{{cbody}\}" : ''
			
			if (this.superclass()) {
				// WARN what if the superclass has a namespace?
				params.push(helpers.singlequote(this.superclass().name()));
			};
			
			if (this.body().count()) {
				if (this.option('hasLocalTags')) {
					params.push(("function(" + (this._ctx.c()) + "," + (this.scope().closure().tagContextPath()) + ")\{" + cbody + "\}"));
				} else {
					params.push(("function(" + (this._ctx.c()) + ")\{" + cbody + "\}"));
				};
			};
			
			var meth = this.option('extension') ? ('extendTag') : ('defineTag');
			// return "{mark}{tagspace}.extendTag('{name.name}'{outbody})"
			
			// var sup = superclass and "," + helpers.singlequote(superclass.func) or ""
			
			// var out = if name.id
			//	"{mark}{tagspace}.defineSingleton('{name.name}'{sup}{outbody})"
			// else
			
			return ("" + mark + this.tagspace() + "." + meth + "(" + params.join(', ') + ")");
			
			// return out
		};
		
		function Func(params,body,name,target,o){
			// p "INIT Function!!",params,body,name
			var typ = this.scopetype();
			this._traversed = false;
			this._body = blk__(body);
			this._scope || (this._scope = (o && o.scope) || new typ(this));
			this._scope.setParams(this._params = new ParamList(params));
			this._name = name || '';
			this._target = target;
			this._options = o;
			this._type = 'function';
			this._variable = null;
			this;
		};
		
		subclass$(Func,Code);
		exports.Func = Func; // export class 
		Func.prototype.name = function(v){ return this._name; }
		Func.prototype.setName = function(v){ this._name = v; return this; };
		Func.prototype.params = function(v){ return this._params; }
		Func.prototype.setParams = function(v){ this._params = v; return this; };
		Func.prototype.target = function(v){ return this._target; }
		Func.prototype.setTarget = function(v){ this._target = v; return this; };
		Func.prototype.options = function(v){ return this._options; }
		Func.prototype.setOptions = function(v){ this._options = v; return this; };
		Func.prototype.type = function(v){ return this._type; }
		Func.prototype.setType = function(v){ this._type = v; return this; };
		Func.prototype.context = function(v){ return this._context; }
		Func.prototype.setContext = function(v){ this._context = v; return this; };
		
		Func.prototype.scopetype = function (){
			return FunctionScope;
		};
		
		Func.prototype.visit = function (){
			this.scope().visit();
			this._context = this.scope().parent();
			this._params.traverse();
			return this._body.traverse(); // so soon?
		};
		
		
		Func.prototype.js = function (o){
			if (!this.option('noreturn')) { this.body().consume(new ImplicitReturn()) };
			var ind = this.body()._indentation;
			// var s = ind and ind.@open
			// p "indent function? {body.@indentation} {s} {s:generated} {body.count}"
			if (ind && ind.isGenerated()) { this.body()._indentation = null };
			var code = this.scope().c({indent: (!(ind) || !ind.isGenerated()),braces: true});
			
			// args = params.map do |par| par.name
			// head = params.map do |par| par.c
			// code = [head,body.c(expression: no)].flatten__.compact.join("\n").wrap
			// FIXME creating the function-name this way is prone to create naming-collisions
			// will need to wrap the value in a FunctionName which takes care of looking up scope
			// and possibly dealing with it
			var name = typeof this._name == 'string' ? (this._name) : (this._name.c());
			name = name ? (' ' + name.replace(/\./g,'_')) : ('');
			var out = ("function" + name + "(" + (this.params().c()) + ") ") + code;
			if (this.option('eval')) { out = ("(" + out + ")()") };
			return out;
		};
		
		Func.prototype.shouldParenthesize = function (par){
			if(par === undefined) par = this.up();
			return (par instanceof Call) && par.callee() == this;
			// if up as a call? Only if we are 
		};
		
		function Lambda(){ return Func.apply(this,arguments) };
		
		subclass$(Lambda,Func);
		exports.Lambda = Lambda; // export class 
		Lambda.prototype.scopetype = function (){
			return LambdaScope;
		};
		
		function TagFragmentFunc(){ return Func.apply(this,arguments) };
		
		subclass$(TagFragmentFunc,Func);
		exports.TagFragmentFunc = TagFragmentFunc; // export class 
		
		
		// MethodDeclaration
		// Create a shared body?
		
		function MethodDeclaration(){ return Func.apply(this,arguments) };
		
		subclass$(MethodDeclaration,Func);
		exports.MethodDeclaration = MethodDeclaration; // export class 
		MethodDeclaration.prototype.variable = function(v){ return this._variable; }
		MethodDeclaration.prototype.setVariable = function(v){ this._variable = v; return this; };
		
		MethodDeclaration.prototype.scopetype = function (){
			return MethodScope;
		};
		
		MethodDeclaration.prototype.consume = function (node){
			if (node instanceof Return) {
				this.option('return',true);
				return this;
			};
			return MethodDeclaration.__super__.consume.apply(this,arguments);
		};
		
		MethodDeclaration.prototype.metadata = function (){
			return {
				type: "method",
				name: "" + this.name(),
				namepath: this.namepath(),
				params: this._params.metadata(),
				desc: this._desc,
				scopenr: this.scope()._nr,
				loc: this.loc()
			};
		};
		
		MethodDeclaration.prototype.loc = function (){
			var d;
			if (d = this.option('def')) {
				return [d._loc,this.body().loc()[1]];
			} else {
				return [0,0];
			};
		};
		
		
		MethodDeclaration.prototype.toJSON = function (){
			return this.metadata();
		};
		
		MethodDeclaration.prototype.namepath = function (){
			if (this._namepath) { return this._namepath };
			
			var name = String(this.name());
			var sep = (this.option('static') ? ('.') : ('#'));
			if (this.target()) {
				return this._namepath = this._target.namepath() + sep + name;
			} else {
				return this._namepath = '&' + name;
			};
		};
		
		MethodDeclaration.prototype.visit = function (){
			// @desc = stack.stash.pluck(Comment)
			// @desc = stack.stash.pluck(Comment)
			// prebreak # make sure this has a break?
			this.scope().visit();
			
			if (String(this.name()) == 'initialize') {
				this.setType('constructor');
			};
			
			if (this.option('greedy')) {
				this.warn("deprecated");
				// set(greedy: true)
				// p "BODY EXPRESSIONS!! This is a fragment"
				var tree = new TagTree();
				this._body = this.body().consume(tree);
				// body.nodes = [Arr.new(body.nodes)]
			};
			
			this._context = this.scope().parent().closure();
			this._params.traverse();
			
			if (this.target() instanceof Self) {
				this._target = this._context.context();
				this.set({static: true});
			};
			
			if (this.context() instanceof ClassScope) {
				this.context().annotate(this);
				this._target || (this._target = this.context().context());
				// register as class-method?
				// should register for this
				// console.log "context is classscope {@name}"
			};
			
			if (!this._target) {
				// should not be registered on the outermost closure?
				this._variable = this.context().register(this.name(),this,{type: 'meth'});
			};
			
			ROOT.entities().add(this.namepath(),this);
			this._body.traverse(); // so soon?
			return this;
		};
		
		MethodDeclaration.prototype.supername = function (){
			return this.type() == 'constructor' ? (this.type()) : (this.name());
		};
		
		
		// FIXME export global etc are NOT valid for methods inside any other scope than
		// the outermost scope (root)
		
		MethodDeclaration.prototype.js = function (o){
			// FIXME Do this in the grammar - remnants of old implementation
			if (!(this.type() == 'constructor' || this.option('noreturn'))) {
				if (this.option('greedy')) {
					// haaack
					this.body().consume(new GreedyReturn());
				} else {
					this.body().consume(new ImplicitReturn());
				};
			};
			
			var code = this.scope().c({indent: true,braces: true});
			
			// same for Func -- should generalize
			var name = typeof this._name == 'string' ? (this._name) : (this._name.c());
			name = name.replace(/\./g,'_');
			
			// var name = self.name.c.replace(/\./g,'_') # WHAT?
			var foot = [];
			
			var left = "";
			var func = ("(" + (this.params().c()) + ")") + code; // .wrap
			var target = this.target();
			var decl = !this.option('global') && !this.option('export');
			
			if (target instanceof ScopeContext) {
				// the target is a scope context
				target = null;
			};
			
			var ctx = this.context();
			var out = "";
			var mark = mark__(this.option('def'));
			// if ctx 
			
			var fname = sym__(this.name());
			// console.log "symbolize {self.name} -- {fname}"
			var fdecl = fname; // decl ? fname : ''
			
			if ((ctx instanceof ClassScope) && !(target)) {
				if (this.type() == 'constructor') {
					out = ("" + mark + "function " + fname + func);
				} else if (this.option('static')) {
					out = ("" + mark + (ctx.context().c()) + "." + fname + " = function " + func);
				} else {
					out = ("" + mark + (ctx.context().c()) + ".prototype." + fname + " = function " + func);
				};
			} else if ((ctx instanceof RootScope) && !(target)) {
				// register method as a root-function, but with auto-call? hmm
				// should probably set using variable directly instead, no?
				out = ("" + mark + "function " + fdecl + func);
			} else if (target && this.option('static')) {
				out = ("" + mark + (target.c()) + "." + fname + " = function " + func);
			} else if (target) {
				out = ("" + mark + (target.c()) + ".prototype." + fname + " = function " + func);
			} else {
				out = ("" + mark + "function " + fdecl + func);
			};
			
			if (this.option('global')) {
				out = ("" + fname + " = " + out);
			};
			
			if (this.option('export')) {
				out = ("" + out + "; exports." + fname + " = " + fname + ";");
				if (this.option('return')) { out = ("" + out + "; return " + fname + ";") };
			} else if (this.option('return')) {
				out = ("return " + out);
			};
			
			return out;
		};
		
		
		function TagFragmentDeclaration(){ return MethodDeclaration.apply(this,arguments) };
		
		subclass$(TagFragmentDeclaration,MethodDeclaration);
		exports.TagFragmentDeclaration = TagFragmentDeclaration; // export class 
		
		
		
		function PropertyDeclaration(name,options,token){
			this._token = token;
			this._traversed = false;
			this._name = name;
			this._options = options || new Obj(new AssignList());
		};
		
		subclass$(PropertyDeclaration,Node);
		exports.PropertyDeclaration = PropertyDeclaration; // export class 
		var propTemplate = '${headers}\n${path}.${getter} = function(v){ return ${get}; }\n${path}.${setter} = function(v){ ${set}; return this; }\n${init}';
		
		var propWatchTemplate = '${headers}\n${path}.${getter} = function(v){ return ${get}; }\n${path}.${setter} = function(v){\n	var a = this.${getter}();\n	if(v != a) { ${set}; }\n	if(v != a) { ${ondirty} }\n	return this;\n}\n${init}';
		
		PropertyDeclaration.prototype.name = function(v){ return this._name; }
		PropertyDeclaration.prototype.setName = function(v){ this._name = v; return this; };
		PropertyDeclaration.prototype.options = function(v){ return this._options; }
		PropertyDeclaration.prototype.setOptions = function(v){ this._options = v; return this; };
		
		PropertyDeclaration.prototype.visit = function (){
			this._options.traverse();
			return this;
		};
		
		// This will soon support bindings / listeners etc, much more
		// advanced generated code based on options passed in.
		PropertyDeclaration.prototype.c = function (){
			var o = this.options();
			var ast = "";
			var key = this.name().js();
			var scope = STACK.scope();
			
			var addDesc = o.keys().length;
			
			var pars = o.hash();
			
			var isAttr = (this._token && String(this._token) == 'attr') || o.key('attr');
			
			var js = {
				key: key,
				getter: key,
				setter: sym__(("set-" + key)),
				scope: ("" + (scope.context().c())),
				path: '${scope}.prototype',
				set: ("this._" + key + " = v"),
				get: ("this._" + key),
				init: "",
				headers: "",
				ondirty: ""
			};
			
			
			if (pars.inline) {
				if ((pars.inline instanceof Bool) && !pars.inline.truthy()) {
					o.remove('inline');
					// p "dont make attr inline(!)"
					return ("Imba." + (this._token) + "(" + (js.scope) + ",'" + (this.name().value()) + "'," + (o.c()) + ")").replace(',{})',')');
				};
				
				// p "pars inline?!? {pars:inline}", typeof pars:inline
			};
			
			var tpl = propTemplate;
			
			o.add('name',new Symbol(key));
			
			if (pars.watch) {
				// p "watch is a property {pars:watch}"
				if (!((pars.watch instanceof Bool) && !pars.watch.truthy())) { tpl = propWatchTemplate };
				var wfn = ("" + key + "DidSet");
				
				if (pars.watch instanceof Symbol) {
					wfn = pars.watch;
				} else if (pars.watch instanceof Bool) {
					o.key('watch').setValue(new Symbol(("" + key + "DidSet")));
				};
				
				var fn = OP('.',new This(),wfn);
				js.ondirty = OP('&&',fn,CALL(fn,['v','a',("this.__" + key)])).c();
			};
			
			if (pars.observe) {
				if (pars.observe instanceof Bool) {
					o.key('observe').setValue(new Symbol(("" + key + "DidEmit")));
				};
				
				tpl = propWatchTemplate;
				js.ondirty = ("Imba.observeProperty(this,'" + key + "'," + (o.key('observe').value().c()) + ",v,a);") + (js.ondirty || '');
				// OP('&&',fn,CALL(fn,['v','a',"this.__{key}"])).c
			};
			
			if ((this._token && String(this._token) == 'attr') || o.key('dom') || o.key('attr')) {
				var attrKey = o.key('dom') instanceof Str ? (o.key('dom')) : (this.name().value());
				// need to make sure o has a key for attr then - so that the delegate can know?
				js.set = ("this.setAttribute('" + attrKey + "',v)");
				js.get = ("this.getAttribute('" + attrKey + "')");
			} else if (o.key('delegate')) {
				// if we have a delegate
				js.set = ("v = this.__" + key + ".delegate.set(this,'" + key + "',v,this.__" + key + ")");
				js.get = ("this.__" + key + ".delegate.get(this,'" + key + "',this.__" + key + ")");
			};
			
			
			
			if (pars.default) {
				if (o.key('dom')) {
					// FIXME go through class-method setAttribute instead
					js.init = ("" + (js.scope) + ".dom().setAttribute('" + key + "'," + (pars.default.c()) + ");");
				} else {
					// if this is not a primitive - it MUST be included in the
					// getter / setter instead
					js.init = ("" + (js.scope) + ".prototype._" + key + " = " + (pars.default.c()) + ";");
				};
			};
			
			if (o.key('chainable')) {
				js.get = ("v !== undefined ? (this." + (js.setter) + "(v),this) : " + (js.get));
			};
			
			
			js.options = o.c();
			
			if (addDesc) {
				js.headers = ("" + (js.path) + ".__" + (js.getter) + " = " + (js.options) + ";");
			};
			
			var reg = /\$\{(\w+)\}/gm;
			// var tpl = o.key(:watch) ? propWatchTemplate : propTemplate
			var out = tpl.replace(reg,function(m,a) { return js[a]; });
			// run another time for nesting. hacky
			out = out.replace(reg,function(m,a) { return js[a]; });
			// out = out.replace(/\n\s*$/,'')
			out = out.replace(/^\s+|\s+$/g,'');
			
			// if o.key(:v)
			return out;
		};
		
		
		
		// Literals should probably not inherit from the same parent
		// as arrays, tuples, objects would be better off inheriting
		// from listnode.
		
		function Literal(v){
			this._traversed = false;
			this._expression = true;
			this._cache = null;
			this._raw = null;
			this._value = v;
		};
		
		subclass$(Literal,ValueNode);
		exports.Literal = Literal; // export class 
		Literal.prototype.toString = function (){
			return "" + this.value();
		};
		
		Literal.prototype.hasSideEffects = function (){
			return false;
		};
		
		
		function Bool(v){
			this._value = v;
			this._raw = String(v) == "true" ? (true) : (false);
		};
		
		subclass$(Bool,Literal);
		exports.Bool = Bool; // export class 
		Bool.prototype.cache = function (){
			return this;
		};
		
		Bool.prototype.isPrimitive = function (){
			return true;
		};
		
		Bool.prototype.truthy = function (){
			// p "bool is truthy? {value}"
			return String(this.value()) == "true";
			// yes
		};
		
		Bool.prototype.js = function (o){
			return String(this._value);
		};
		
		Bool.prototype.c = function (){
			STACK._counter += 1;
			// undefined should not be a bool
			return String(this._value);
			// @raw ? "true" : "false"
		};
		
		Bool.prototype.toJSON = function (){
			return {type: 'Bool',value: this._value};
		};
		
		function Undefined(){ return Literal.apply(this,arguments) };
		
		subclass$(Undefined,Literal);
		exports.Undefined = Undefined; // export class 
		Undefined.prototype.isPrimitive = function (){
			return true;
		};
		
		Undefined.prototype.c = function (){
			return mark__(this._value) + "undefined";
		};
		
		function Nil(){ return Literal.apply(this,arguments) };
		
		subclass$(Nil,Literal);
		exports.Nil = Nil; // export class 
		Nil.prototype.isPrimitive = function (){
			return true;
		};
		
		Nil.prototype.c = function (){
			return mark__(this._value) + "null";
		};
		
		function True(){ return Bool.apply(this,arguments) };
		
		subclass$(True,Bool);
		exports.True = True; // export class 
		True.prototype.raw = function (){
			return true;
		};
		
		True.prototype.c = function (){
			return mark__(this._value) + "true";
		};
		
		function False(){ return Bool.apply(this,arguments) };
		
		subclass$(False,Bool);
		exports.False = False; // export class 
		False.prototype.raw = function (){
			return false;
		};
		
		False.prototype.c = function (){
			return mark__(this._value) + "false";
		};
		
		function Num(v){
			this._traversed = false;
			this._value = v;
		};
		
		subclass$(Num,Literal);
		exports.Num = Num; // export class 
		Num.prototype.toString = function (){
			return String(this._value);
		};
		
		Num.prototype.isPrimitive = function (deep){
			return true;
		};
		
		Num.prototype.shouldParenthesize = function (par){
			if(par === undefined) par = this.up();
			return (par instanceof Access) && par.left() == this;
		};
		
		Num.prototype.js = function (o){
			var num = String(this._value);
			// console.log "compiled num to {num}"
			return num;
		};
		
		Num.prototype.c = function (o){
			if (this._cache) { return Num.__super__.c.call(this,o) };
			var js = String(this._value);
			var par = STACK.current();
			var paren = (par instanceof Access) && par.left() == this;
			// only if this is the right part of teh acces
			// console.log "should paren?? {shouldParenthesize}"
			return paren ? (("(" + mark__(this._value)) + js + ")") : ((mark__(this._value) + js));
			// @cache ? super(o) : String(@value)
		};
		
		Num.prototype.cache = function (o){
			// p "cache num",o
			if (!(o && (o.cache || o.pool))) { return this };
			return Num.__super__.cache.call(this,o);
		};
		
		Num.prototype.raw = function (){
			// really?
			return JSON.parse(String(this.value()));
		};
		
		Num.prototype.toJSON = function (){
			return {type: this.typeName(),value: this.raw()};
		};
		
		// should be quoted no?
		// what about strings in object-literals?
		// we want to be able to see if the values are allowed
		function Str(v){
			this._traversed = false;
			this._expression = true;
			this._cache = null;
			this._value = v;
			// should grab the actual value immediately?
		};
		
		subclass$(Str,Literal);
		exports.Str = Str; // export class 
		Str.prototype.isString = function (){
			return true;
		};
		
		Str.prototype.isPrimitive = function (deep){
			return true;
		};
		
		Str.prototype.raw = function (){
			// JSON.parse requires double-quoted strings,
			// while eval also allows single quotes. 
			// NEXT eval is not accessible like this
			// WARNING TODO be careful! - should clean up
			
			return this._raw || (this._raw = String(this.value()).slice(1,-1)); // incredibly stupid solution
		};
		
		Str.prototype.isValidIdentifier = function (){
			// there are also some values we cannot use
			return this.raw().match(/^[a-zA-Z\$\_]+[\d\w\$\_]*$/) ? (true) : (false);
		};
		
		Str.prototype.js = function (o){
			return String(this._value);
		};
		
		Str.prototype.c = function (o){
			return this._cache ? (Str.__super__.c.call(this,o)) : (String(this._value));
		};
		
		
		function Interpolation(){ return ValueNode.apply(this,arguments) };
		
		subclass$(Interpolation,ValueNode);
		exports.Interpolation = Interpolation; // export class 
		
		
		// Currently not used - it would be better to use this
		// for real interpolated strings though, than to break
		// them up into their parts before parsing
		function InterpolatedString(nodes,o){
			if(o === undefined) o = {};
			this._nodes = nodes;
			this._options = o;
			this;
		};
		
		subclass$(InterpolatedString,Node);
		exports.InterpolatedString = InterpolatedString; // export class 
		InterpolatedString.prototype.add = function (part){
			if (part) { this._nodes.push(part) };
			return this;
		};
		
		InterpolatedString.prototype.visit = function (){
			for (var i = 0, ary = iter$(this._nodes), len = ary.length; i < len; i++) {
				ary[i].traverse();
			};
			return this;
		};
		
		InterpolatedString.prototype.escapeString = function (str){
			// var idx = 0
			// var len = str:length
			// var chr
			// while chr = str[idx++]
			return str = str.replace(/\n/g,'\\\n');
		};
		
		InterpolatedString.prototype.js = function (o){
			// creating the string
			var self = this;
			var parts = [];
			var str = '(';
			
			self._nodes.map(function(part,i) {
				if ((part instanceof Token) && part._type == 'NEOSTRING') {
					// esca
					return parts.push('"' + self.escapeString(part._value) + '"');
				} else if (part) {
					if (i == 0) {
						// force first part to be string
						parts.push('""');
					};
					part._parens = true;
					return parts.push(part.c({expression: true}));
				};
			});
			
			str += parts.join(" + ");
			str += ')';
			return str;
		};
		
		
		function Tuple(){ return ListNode.apply(this,arguments) };
		
		subclass$(Tuple,ListNode);
		exports.Tuple = Tuple; // export class 
		Tuple.prototype.c = function (){
			// compiles as an array
			return new Arr(this.nodes()).c();
		};
		
		Tuple.prototype.hasSplat = function (){
			return this.filter(function(v) { return v instanceof Splat; })[0];
		};
		
		Tuple.prototype.consume = function (node){
			if (this.count() == 1) {
				return this.first().consume(node);
			} else {
				throw "multituple cannot consume";
			};
		};
		
		
		// Because we've dropped the Str-wrapper it is kinda difficult
		function Symbol(){ return Literal.apply(this,arguments) };
		
		subclass$(Symbol,Literal);
		exports.Symbol = Symbol; // export class 
		Symbol.prototype.isValidIdentifier = function (){
			return this.raw().match(/^[a-zA-Z\$\_]+[\d\w\$\_]*$/) ? (true) : (false);
		};
		
		Symbol.prototype.isPrimitive = function (deep){
			return true;
		};
		
		Symbol.prototype.raw = function (){
			return this._raw || (this._raw = sym__(this.value()));
		};
		
		Symbol.prototype.js = function (o){
			return ("'" + sym__(this.value()) + "'");
		};
		
		function RegExp(){ return Literal.apply(this,arguments) };
		
		subclass$(RegExp,Literal);
		exports.RegExp = RegExp; // export class 
		RegExp.prototype.isPrimitive = function (){
			return true;
		};
		
		// def toString
		// 	"" + value
		;
		
		// Should inherit from ListNode - would simplify
		function Arr(){ return Literal.apply(this,arguments) };
		
		subclass$(Arr,Literal);
		exports.Arr = Arr; // export class 
		Arr.prototype.load = function (value){
			return value instanceof Array ? (new ArgList(value)) : (value);
		};
		
		Arr.prototype.push = function (item){
			this.value().push(item);
			return this;
		};
		
		Arr.prototype.count = function (){
			return this.value().length;
		};
		
		Arr.prototype.nodes = function (){
			var val = this.value();
			return val instanceof Array ? (val) : (val.nodes());
		};
		
		Arr.prototype.splat = function (){
			return this.value().some(function(v) { return v instanceof Splat; });
		};
		
		Arr.prototype.visit = function (){
			if (this._value && this._value.traverse) { this._value.traverse() };
			return this;
		};
		
		Arr.prototype.isPrimitive = function (deep){
			return !this.value().some(function(v) { return !v.isPrimitive(true); });
		};
		
		Arr.prototype.js = function (o){
			
			var val = this._value;
			if (!(val)) { return "[]" };
			
			var splat = this.splat();
			var nodes = val instanceof Array ? (val) : (val.nodes());
			// p "value of array isa {@value}"
			
			// for v in @value
			// 	break splat = yes if v isa Splat
			// var splat = value.some(|v| v isa Splat)
			
			if (splat) {
				// "SPLATTED ARRAY!"
				// if we know for certain that the splats are arrays we can drop the slice?
				// p "array is splat?!?"
				var slices = [];
				var group = null;
				
				for (var i = 0, ary = iter$(nodes), len = ary.length, v; i < len; i++) {
					v = ary[i];
					if (v instanceof Splat) {
						slices.push(v);
						group = null;
					} else {
						if (!(group)) { slices.push(group = new Arr([])) };
						group.push(v);
					};
				};
				
				return ("[].concat(" + cary__(slices).join(", ") + ")");
			} else {
				// very temporary. need a more generic way to prettify code
				// should depend on the length of the inner items etc
				// if @indented or option(:indent) or value.@indented
				//	"[\n{value.c.join(",\n").indent}\n]"
				var out = val instanceof Array ? (cary__(val)) : (val.c());
				return ("[" + out + "]");
			};
		};
		
		Arr.prototype.hasSideEffects = function (){
			return this.value().some(function(v) { return v.hasSideEffects(); });
		};
		
		Arr.prototype.toString = function (){
			return "Arr";
		};
		
		Arr.prototype.indented = function (a,b){
			this._value.indented(a,b);
			return this;
		};
		
		Arr.wrap = function (val){
			return new Arr(val);
		};
		
		// should not be cklassified as a literal?
		function Obj(){ return Literal.apply(this,arguments) };
		
		subclass$(Obj,Literal);
		exports.Obj = Obj; // export class 
		Obj.prototype.load = function (value){
			return value instanceof Array ? (new AssignList(value)) : (value);
		};
		
		Obj.prototype.visit = function (){
			if (this._value) { this._value.traverse() };
			// for v in value
			// 	v.traverse
			return this;
		};
		
		Obj.prototype.js = function (o){
			var dyn = this.value().filter(function(v) { return (v instanceof ObjAttr) && ((v.key() instanceof Op) || (v.key() instanceof InterpolatedString)); });
			
			if (dyn.length > 0) {
				var idx = this.value().indexOf(dyn[0]);
				// p "dynamic keys! {dyn}"
				// create a temp variable
				
				var tmp = this.scope__().temporary(this);
				// set the temporary object to the same
				var first = this.value().slice(0,idx);
				var obj = new Obj(first);
				var ast = [OP('=',tmp,obj)];
				
				this.value().slice(idx).forEach(function(atr) {
					return ast.push(OP('=',OP('.',tmp,atr.key()),atr.value()));
				});
				ast.push(tmp); // access the tmp at in the last part
				return new Parens(ast).c();
			};
			
			// for objects with expression-keys we need to think differently
			return '{' + this.value().c() + '}';
		};
		
		Obj.prototype.add = function (k,v){
			if ((typeof k=='string'||k instanceof String)) { k = new Identifier(k) };
			var kv = new ObjAttr(k,v);
			this.value().push(kv);
			return kv;
		};
		
		Obj.prototype.remove = function (key){
			for (var i = 0, ary = iter$(this.value()), len = ary.length, k; i < len; i++) {
				k = ary[i];
				if (k.key().symbol() == key) { this.value().remove(k) };
			};
			return this;
		};
		
		Obj.prototype.keys = function (){
			return Object.keys(this.hash());
		};
		
		Obj.prototype.hash = function (){
			var hash = {};
			for (var i = 0, ary = iter$(this.value()), len = ary.length, k; i < len; i++) {
				k = ary[i];
				if (k instanceof ObjAttr) { hash[k.key().symbol()] = k.value() };
			};
			return hash;
			// return k if k.key.symbol == key
		};
		
		// add method for finding properties etc?
		Obj.prototype.key = function (key){
			for (var i = 0, ary = iter$(this.value()), len = ary.length, k; i < len; i++) {
				k = ary[i];
				if ((k instanceof ObjAttr) && k.key().symbol() == key) { return k };
			};
			return null;
		};
		
		Obj.prototype.indented = function (a,b){
			this._value.indented(a,b);
			return this;
		};
		
		Obj.prototype.hasSideEffects = function (){
			return this.value().some(function(v) { return v.hasSideEffects(); });
		};
		
		// for converting a real object into an ast-representation
		Obj.wrap = function (obj){
			var attrs = [];
			for (var v, i = 0, keys = Object.keys(obj), l = keys.length; i < l; i++){
				v = obj[keys[i]];if (v instanceof Array) {
					v = Arr.wrap(v);
				} else if (v.constructor == Object) {
					v = Obj.wrap(v);
				};
				attrs.push(new ObjAttr(keys[i],v));
			};
			return new Obj(attrs);
		};
		
		Obj.prototype.toString = function (){
			return "Obj";
		};
		
		function ObjAttr(key,value){
			this._traversed = false;
			this._key = key;
			this._value = value;
			this._dynamic = (key instanceof Op);
			this;
		};
		
		subclass$(ObjAttr,Node);
		exports.ObjAttr = ObjAttr; // export class 
		ObjAttr.prototype.key = function(v){ return this._key; }
		ObjAttr.prototype.setKey = function(v){ this._key = v; return this; };
		ObjAttr.prototype.value = function(v){ return this._value; }
		ObjAttr.prototype.setValue = function(v){ this._value = v; return this; };
		ObjAttr.prototype.options = function(v){ return this._options; }
		ObjAttr.prototype.setOptions = function(v){ this._options = v; return this; };
		
		ObjAttr.prototype.visit = function (){
			// should probably traverse key as well, unless it is a dead simple identifier
			this.key().traverse();
			return this.value().traverse();
		};
		
		ObjAttr.prototype.js = function (o){
			var k = this.key().isReserved() ? (("'" + (this.key().c()) + "'")) : (this.key().c());
			return ("" + k + ": " + (this.value().c()));
		};
		
		ObjAttr.prototype.hasSideEffects = function (){
			return true;
		};
		
		
		
		function ArgsReference(){ return Node.apply(this,arguments) };
		
		subclass$(ArgsReference,Node);
		exports.ArgsReference = ArgsReference; // export class 
		ArgsReference.prototype.c = function (){
			return "arguments";
		};
		
		// should be a separate Context or something
		function Self(scope){
			this._scope = scope;
		};
		
		subclass$(Self,Literal);
		exports.Self = Self; // export class 
		Self.prototype.scope = function(v){ return this._scope; }
		Self.prototype.setScope = function(v){ this._scope = v; return this; };
		
		Self.prototype.cache = function (){
			return this;
		};
		
		Self.prototype.reference = function (){
			return this;
		};
		
		Self.prototype.c = function (){
			var s = this.scope__();
			return s ? (s.context().c()) : ("this");
		};
		
		function ImplicitSelf(){ return Self.apply(this,arguments) };
		
		subclass$(ImplicitSelf,Self);
		exports.ImplicitSelf = ImplicitSelf; // export class 
		
		
		function This(){ return Self.apply(this,arguments) };
		
		subclass$(This,Self);
		exports.This = This; // export class 
		This.prototype.cache = function (){
			return this;
		};
		
		This.prototype.reference = function (){
			// p "referencing this"
			return this;
		};
		
		This.prototype.c = function (){
			return "this";
		};
		
		
		
		
		// OPERATORS
		
		function Op(o,l,r){
			// set expression yes, no?
			this._expression = false;
			this._traversed = false;
			this._parens = false;
			this._cache = null;
			this._invert = false;
			this._opToken = o;
			this._op = o && o._value || o;
			this._left = l;
			this._right = r;
			return this;
		};
		
		subclass$(Op,Node);
		exports.Op = Op; // export class 
		Op.prototype.op = function(v){ return this._op; }
		Op.prototype.setOp = function(v){ this._op = v; return this; };
		Op.prototype.left = function(v){ return this._left; }
		Op.prototype.setLeft = function(v){ this._left = v; return this; };
		Op.prototype.right = function(v){ return this._right; }
		Op.prototype.setRight = function(v){ this._right = v; return this; };
		
		Op.prototype.visit = function (){
			if (this._right) { this._right.traverse() };
			if (this._left) { this._left.traverse() };
			return this;
		};
		
		Op.prototype.isExpressable = function (){
			// what if right is a string?!?
			return !(this.right()) || this.right().isExpressable();
		};
		
		Op.prototype.js = function (o){
			var out = null;
			var op = this._op;
			
			var l = this._left;
			var r = this._right;
			
			if (l instanceof Node) { l = l.c() };
			if (r instanceof Node) { r = r.c() };
			
			if (l && r) {
				out = ("" + l + " " + mark__(this._opToken) + op + " " + r);
			} else if (l) {
				out = ("" + mark__(this._opToken) + op + l);
			};
			// out = out.parenthesize if up isa Op # really?
			return out;
		};
		
		Op.prototype.shouldParenthesize = function (){
			return this._parens;
			// option(:parens)
		};
		
		Op.prototype.precedence = function (){
			return 10;
		};
		
		Op.prototype.consume = function (node){
			// p 'assignify if?!'
			// if it is possible, convert into expression
			if (node instanceof TagTree) {
				if (this._left) { this._left.consume(node) };
				if (this._right) { this._right.consume(node) };
				// @body = @body.consume(node)
				// @alt = @alt.consume(node) if @alt
				return this;
			};
			// p "Op.consume {node}".cyan
			if (this.isExpressable()) { return Op.__super__.consume.apply(this,arguments) };
			
			// TODO can rather use global caching?
			var tmpvar = this.scope__().declare('tmp',null,{system: true});
			var clone = OP(this.op(),this.left(),null);
			var ast = this.right().consume(clone);
			if (node) { ast.consume(node) };
			return ast;
		};
		
		function ComparisonOp(){ return Op.apply(this,arguments) };
		
		subclass$(ComparisonOp,Op);
		exports.ComparisonOp = ComparisonOp; // export class 
		ComparisonOp.prototype.invert = function (){
			// are there other comparison ops?
			// what about a chain?
			var op = this._op;
			var pairs = ["==","!=","===","!==",">","<=","<",">="];
			var idx = pairs.indexOf(op);
			idx += (idx % 2 ? (-1) : (1));
			
			// p "invert {@op}"
			// p "inverted comparison(!) {idx} {op} -> {pairs[idx]}"
			this.setOp(pairs[idx]);
			this._invert = !this._invert;
			return this;
		};
		
		ComparisonOp.prototype.c = function (){
			if (this.left() instanceof ComparisonOp) {
				this.left().right().cache();
				return OP('&&',this.left(),OP(this.op(),this.left().right(),this.right())).c();
			} else {
				return ComparisonOp.__super__.c.apply(this,arguments);
			};
		};
		
		ComparisonOp.prototype.js = function (o){
			var op = this._op;
			var l = this._left;
			var r = this._right;
			
			if (l instanceof Node) { l = l.c() };
			if (r instanceof Node) { r = r.c() };
			return ("" + l + " " + mark__(this._opToken) + op + " " + r);
		};
		
		
		function MathOp(){ return Op.apply(this,arguments) };
		
		subclass$(MathOp,Op);
		exports.MathOp = MathOp; // export class 
		MathOp.prototype.c = function (){
			if (this.op() == '∪') {
				return this.util().union(this.left(),this.right()).c();
			} else if (this.op() == '∩') {
				return this.util().intersect(this.left(),this.right()).c();
			};
		};
		
		
		function UnaryOp(){ return Op.apply(this,arguments) };
		
		subclass$(UnaryOp,Op);
		exports.UnaryOp = UnaryOp; // export class 
		UnaryOp.prototype.invert = function (){
			if (this.op() == '!') {
				return this.left();
			} else {
				return UnaryOp.__super__.invert.apply(this,arguments); // regular invert
			};
		};
		
		UnaryOp.prototype.js = function (o){
			var l = this._left;
			var r = this._right;
			// all of this could really be done i a much
			// cleaner way.
			// l.set(parens: yes) if l # are we really sure about this?
			// r.set(parens: yes) if r
			
			if (this.op() == '!') {
				// l.@parens = yes
				var str = l.c();
				var paren = l.shouldParenthesize(this);
				// p "check for parens in !: {str} {l} {l.@parens} {l.shouldParenthesize(self)}"
				// FIXME this is a very hacky workaround. Need to handle all this
				// in the child instead, problems arise due to automatic caching
				if (!(str.match(/^\!?([\w\.]+)$/) || (l instanceof Parens) || paren || (l instanceof Access) || (l instanceof Call))) { str = '(' + str + ')' };
				// l.set(parens: yes) # sure?
				return ("" + this.op() + str);
			} else if (this.op() == '√') {
				return ("Math.sqrt(" + (l.c()) + ")");
			} else if (this.left()) {
				return ("" + (l.c()) + this.op());
			} else {
				return ("" + this.op() + (r.c()));
			};
		};
		
		UnaryOp.prototype.normalize = function (){
			if (this.op() == '!' || this.op() == '√') { return this };
			var node = (this.left() || this.right()).node();
			// for property-accessors we need to rewrite the ast
			if (!((node instanceof PropertyAccess))) { return this };
			
			// ask to cache the path
			if ((node instanceof Access) && node.left()) { node.left().cache() };
			
			var num = new Num(1);
			var ast = OP('=',node,OP(this.op()[0],node,num));
			if (this.left()) { ast = OP(this.op()[0] == '-' ? ('+') : ('-'),ast,num) };
			
			return ast;
		};
		
		UnaryOp.prototype.consume = function (node){
			var norm = this.normalize();
			return norm == this ? (UnaryOp.__super__.consume.apply(this,arguments)) : (norm.consume(node));
		};
		
		UnaryOp.prototype.c = function (){
			var norm = this.normalize();
			return norm == this ? (UnaryOp.__super__.c.apply(this,arguments)) : (norm.c());
		};
		
		function InstanceOf(){ return Op.apply(this,arguments) };
		
		subclass$(InstanceOf,Op);
		exports.InstanceOf = InstanceOf; // export class 
		InstanceOf.prototype.js = function (o){
			// fix checks for String and Number
			// p right.inspect
			
			if (this.right() instanceof Const) {
				// WARN otherwise - what do we do? does not work with dynamic
				// classes etc? Should probably send to utility function isa$
				var name = c__(this.right().value());
				var obj = this.left().node();
				// TODO also check for primitive-constructor
				if (idx$(name,['String','Number','Boolean']) >= 0) {
					if (!((obj instanceof LocalVarAccess))) {
						obj.cache();
					};
					// need a double check for these (cache left) - possibly
					return ("(typeof " + (obj.c()) + "=='" + (name.toLowerCase()) + "'||" + (obj.c()) + " instanceof " + name + ")");
					
					// convert
				};
			};
			var out = ("" + (this.left().c()) + " " + this.op() + " " + (this.right().c()));
			
			// should this not happen in #c?
			if (o.parent() instanceof Op) { out = helpers.parenthesize(out) };
			return out;
		};
		
		function TypeOf(){ return Op.apply(this,arguments) };
		
		subclass$(TypeOf,Op);
		exports.TypeOf = TypeOf; // export class 
		TypeOf.prototype.js = function (o){
			return ("typeof " + (this.left().c()));
		};
		
		function Delete(){ return Op.apply(this,arguments) };
		
		subclass$(Delete,Op);
		exports.Delete = Delete; // export class 
		Delete.prototype.js = function (o){
			// TODO this will execute calls several times if the path is not directly to an object
			// need to cache the receiver
			var l = this.left();
			var tmp = this.scope__().temporary(this,{pool: 'val'});
			var o = OP('=',tmp,l);
			// FIXME
			return ("(" + (o.c()) + ",delete " + (l.c()) + ", " + (tmp.c()) + ")"); // oh well
			// var ast = [OP('=',tmp,left),"delete {left.c}",tmp]
			// should parenthesize directly no?
			// ast.c
		};
		
		Delete.prototype.shouldParenthesize = function (){
			return true;
		};
		
		function In(){ return Op.apply(this,arguments) };
		
		subclass$(In,Op);
		exports.In = In; // export class 
		In.prototype.invert = function (){
			this._invert = !this._invert;
			return this;
		};
		
		In.prototype.js = function (o){
			var cond = this._invert ? ("== -1") : (">= 0");
			var idx = Util.indexOf(this.left(),this.right());
			return ("" + (idx.c()) + " " + cond);
		};
		
		
		
		
		
		
		
		// ACCESS
		
		module.exports.K_IVAR = K_IVAR = 1;
		module.exports.K_SYM = K_SYM = 2;
		module.exports.K_STR = K_STR = 3;
		module.exports.K_PROP = K_PROP = 4;
		
		function Access(o,l,r){
			// set expression yes, no?
			this._expression = false;
			this._traversed = false;
			this._parens = false;
			this._cache = null;
			this._invert = false;
			this._op = o && o._value || o;
			this._left = l;
			this._right = r;
			return this;
		};
		
		subclass$(Access,Op);
		exports.Access = Access; // export class 
		Access.prototype.clone = function (left,right){
			var ctor = this.constructor;
			return new ctor(this.op(),left,right);
		};
		
		Access.prototype.js = function (o){
			var r;
			var raw = null;
			var rgt = this.right();
			var ctx = (this.left() || this.scope__().context());
			var pre = "";
			var mark = '';
			
			// if safechain
			//	p "Access is safechained {rgt.c}"
			
			
			if (rgt instanceof Num) {
				return ctx.c() + "[" + rgt.c() + "]";
			};
			
			// is this right? Should not the index compile the brackets
			// or value is a symbol -- should be the same, no?
			if ((rgt instanceof Index) && ((rgt.value() instanceof Str) || (rgt.value() instanceof Symbol))) {
				rgt = rgt.value();
			};
			
			// TODO do the identifier-validation in a central place instead
			if ((rgt instanceof Str) && rgt.isValidIdentifier()) {
				raw = rgt.raw();
			} else if ((rgt instanceof Symbol) && rgt.isValidIdentifier()) {
				raw = rgt.raw();
			} else if ((rgt instanceof Identifier) && rgt.isValidIdentifier()) {
				mark = mark__(rgt._value);
				raw = rgt.c();
			};
			
			if (this.safechain() && ctx) {
				ctx.cache({force: true});
				pre = ctx.c() + " && ";
			};
			
			// really?
			// var ctx = (left || scope__.context)
			var out = raw ? (
				// see if it needs quoting
				// need to check to see if it is legal
				ctx ? (("" + (ctx.c()) + "." + mark + raw)) : (raw)
			) : (
				r = rgt instanceof Node ? (rgt.c({expression: true})) : (rgt),
				("" + (ctx.c()) + "[" + r + "]")
			);
			
			// if safechain and ctx
			// 	out = "{ctx.c} && {out}"
			
			return pre + out;
		};
		
		Access.prototype.visit = function (){
			if (this.left()) { this.left().traverse() };
			if (this.right()) { this.right().traverse() };
			return;
		};
		
		Access.prototype.isExpressable = function (){
			return true;
		};
		
		Access.prototype.alias = function (){
			return this.right() instanceof Identifier ? (this.right().alias()) : (Access.__super__.alias.call(this));
		};
		
		Access.prototype.safechain = function (){
			// right.safechain
			return String(this._op) == '?.' || String(this._op) == '?:';
		};
		
		Access.prototype.cache = function (o){
			return ((this.right() instanceof Ivar) && !(this.left())) ? (this) : (Access.__super__.cache.call(this,o));
		};
		
		
		
		// Should change this to just refer directly to the variable? Or VarReference
		function LocalVarAccess(){ return Access.apply(this,arguments) };
		
		subclass$(LocalVarAccess,Access);
		exports.LocalVarAccess = LocalVarAccess; // export class 
		LocalVarAccess.prototype.safechain = function(v){ return this._safechain; }
		LocalVarAccess.prototype.setSafechain = function(v){ this._safechain = v; return this; };
		
		LocalVarAccess.prototype.js = function (o){
			if ((this.right() instanceof Variable) && this.right().type() == 'meth') {
				if (!((this.up() instanceof Call))) { return ("" + (this.right().c()) + "()") };
			};
			
			return this.right().c();
		};
		
		LocalVarAccess.prototype.variable = function (){
			return this.right();
		};
		
		LocalVarAccess.prototype.cache = function (o){
			if(o === undefined) o = {};
			if (o.force) { LocalVarAccess.__super__.cache.call(this,o) };
			return this;
		};
		
		LocalVarAccess.prototype.alias = function (){
			return this.variable()._alias || LocalVarAccess.__super__.alias.call(this);
		};
		
		
		function GlobalVarAccess(){ return ValueNode.apply(this,arguments) };
		
		subclass$(GlobalVarAccess,ValueNode);
		exports.GlobalVarAccess = GlobalVarAccess; // export class 
		GlobalVarAccess.prototype.js = function (o){
			return this.value().c();
		};
		
		
		function ObjectAccess(){ return Access.apply(this,arguments) };
		
		subclass$(ObjectAccess,Access);
		exports.ObjectAccess = ObjectAccess; // export class 
		
		
		
		function PropertyAccess(o,l,r){
			this._traversed = false;
			this._invert = false;
			this._parens = false;
			this._expression = false; // yes?
			this._cache = null;
			this._op = o;
			this._left = l;
			this._right = r;
			return this;
		};
		
		subclass$(PropertyAccess,Access);
		exports.PropertyAccess = PropertyAccess; // export class 
		PropertyAccess.prototype.visit = function (){
			if (this._right) { this._right.traverse() };
			if (this._left) { this._left.traverse() };
			return this;
		};
		
		// right in c we should possibly override
		// to create a call and regular access instead
		
		PropertyAccess.prototype.js = function (o){
			
			var rec;
			if (rec = this.receiver()) {
				// p "converting to call"
				var ast = CALL(OP('.',this.left(),this.right()),[]); // convert to ArgList or null
				ast.setReceiver(rec);
				return ast.c();
			};
			
			var up = this.up();
			
			if (!((up instanceof Call))) {
				// p "convert to call instead"
				ast = CALL(new Access(this.op(),this.left(),this.right()),[]);
				return ast.c();
			};
			
			// really need to fix this - for sure
			// should be possible for the function to remove this this instead?
			var js = ("" + PropertyAccess.__super__.js.call(this,o));
			
			if (!((up instanceof Call) || (up instanceof Util.IsFunction))) {
				// p "Called"
				js += "()";
			};
			
			return js;
		};
		
		
		PropertyAccess.prototype.receiver = function (){
			if ((this.left() instanceof SuperAccess) || (this.left() instanceof Super)) {
				return SELF;
			} else {
				return null;
			};
		};
		
		
		function IvarAccess(){ return Access.apply(this,arguments) };
		
		subclass$(IvarAccess,Access);
		exports.IvarAccess = IvarAccess; // export class 
		IvarAccess.prototype.cache = function (){
			// WARN hmm, this is not right... when accessing on another object it will need to be cached
			return this;
		};
		
		
		function ConstAccess(){ return Access.apply(this,arguments) };
		
		subclass$(ConstAccess,Access);
		exports.ConstAccess = ConstAccess; // export class 
		
		
		
		function IndexAccess(){ return Access.apply(this,arguments) };
		
		subclass$(IndexAccess,Access);
		exports.IndexAccess = IndexAccess; // export class 
		IndexAccess.prototype.cache = function (o){
			if(o === undefined) o = {};
			if (o.force) { return IndexAccess.__super__.cache.apply(this,arguments) };
			this.right().cache();
			return this;
		};
		
		
		function SuperAccess(){ return Access.apply(this,arguments) };
		
		subclass$(SuperAccess,Access);
		exports.SuperAccess = SuperAccess; // export class 
		SuperAccess.prototype.js = function (o){
			var m = o.method();
			var up = o.parent();
			var deep = (o.parent() instanceof Access);
			
			var out = ("" + (this.left().c()) + ".__super__");
			
			if (!((up instanceof Access))) {
				out += ("." + (m.supername().c()));
				if (!((up instanceof Call))) { // autocall?
					out += (".apply(" + (m.scope().context().c()) + ",arguments)");
				};
			};
			
			return out;
		};
		
		SuperAccess.prototype.receiver = function (){
			return SELF;
		};
		
		
		function VarOrAccess(value){
			// should rather call up to valuenode?
			this._traversed = false;
			this._parens = false;
			this._value = value;
			this._identifier = value;
			this._token = value._value;
			this._variable = null;
			this;
		};
		
		// Shortcircuit traverse so that it is not added to the stack?!
		subclass$(VarOrAccess,ValueNode);
		exports.VarOrAccess = VarOrAccess; // export class 
		VarOrAccess.prototype.visit = function (){
			// @identifier = value # this is not a real identifier?
			// console.log "VarOrAccess {@identifier}"
			// p "visit {self}"
			
			
			var scope = this.scope__();
			
			var variable = scope.lookup(this.value());
			
			// does not really need to have a declarator already? -- tricky
			if (variable && variable.declarator()) {
				// var decl = variable.declarator
				
				// if the variable is not initialized just yet and we are
				// in the same scope - we should not treat this as a var-lookup
				// ie.  var x = x would resolve to var x = this.x() if x
				// was not previously defined
				
				// should do this even if we are not in the same scope?
				// we only need to be in the same closure(!)
				
				if (variable._initialized || (scope.closure() != variable.scope().closure())) {
					this._variable = variable;
					variable.addReference(this);
					this._value = variable; // variable.accessor(self)
					this._token._variable = variable;
					return this;
				};
				
				// p "var is not yet initialized!"
				// p "declarator for var {decl.@declared}"
				// FIX
				// @value.safechain = safechain
			};
			
			// TODO deprecate and remove
			if (this.value().symbol().indexOf('$') >= 0) {
				// big hack - should disable
				// major hack here, no?
				// console.log "GlobalVarAccess"
				this._value = new GlobalVarAccess(this.value());
				return this;
			};
			
			// really? what about just mimicking the two diffrent instead?
			// Should we not return a call directly instead?
			this._value = new PropertyAccess(".",scope.context(),this.value());
			// mark the scope / context -- so we can show correct implicit
			this._token._meta = {type: 'ACCESS'};
			// @value.traverse # nah
			return this;
		};
		
		VarOrAccess.prototype.c = function (){
			return mark__(this._token) + (this._variable ? (VarOrAccess.__super__.c.call(this)) : (this.value().c()));
		};
		
		VarOrAccess.prototype.js = function (o){
			
			var v;
			if (v = this._variable) {
				var out = v.c();
				if (v._type == 'meth' && !(o.up() instanceof Call)) { out += "()" };
				return out;
			};
			return "NONO";
		};
		
		VarOrAccess.prototype.node = function (){
			return this._variable ? (this) : (this.value());
		};
		
		VarOrAccess.prototype.symbol = function (){
			return this._identifier.symbol();
			// value and value.symbol
		};
		
		VarOrAccess.prototype.cache = function (o){
			if(o === undefined) o = {};
			return this._variable ? ((o.force && VarOrAccess.__super__.cache.call(this,o))) : (this.value().cache(o));
			// should we really cache this?
			// value.cache(o)
		};
		
		VarOrAccess.prototype.decache = function (){
			this._variable ? (VarOrAccess.__super__.decache.call(this)) : (this.value().decache());
			return this;
		};
		
		VarOrAccess.prototype.dom = function (){
			return this.value().dom();
		};
		
		VarOrAccess.prototype.safechain = function (){
			return this._identifier.safechain();
		};
		
		VarOrAccess.prototype.dump = function (){
			return {loc: this.loc()};
		};
		
		VarOrAccess.prototype.loc = function (){
			var loc = this._identifier.region();
			return loc || [0,0];
		};
		
		VarOrAccess.prototype.region = function (){
			return this._identifier.region();
		};
		
		VarOrAccess.prototype.toString = function (){
			return ("VarOrAccess(" + this.value() + ")");
		};
		
		VarOrAccess.prototype.toJSON = function (){
			return {type: this.typeName(),value: this._identifier.toString()};
		};
		
		//	def js
		//		if right isa Variable and right.type == 'meth'
		//			return "{right.c}()" unless up isa Call
		//
		//		right.c
		//
		//	def variable
		//		right
		//
		//	def cache o = {}
		//		super if o:force
		//		self
		//
		//	def alias
		//		variable.@alias or super # if resolved?
		//
		
		function VarReference(value,type){
			if (value instanceof VarOrAccess) {
				value = value.value();
			};
			// for now - this can happen
			VarReference.__super__.constructor.call(this,value);
			this._export = false;
			this._type = type && String(type);
			this._variable = null;
			this._declared = true; // just testing now
		};
		
		
		subclass$(VarReference,ValueNode);
		exports.VarReference = VarReference; // export class 
		VarReference.prototype.variable = function(v){ return this._variable; }
		VarReference.prototype.setVariable = function(v){ this._variable = v; return this; };
		VarReference.prototype.declared = function(v){ return this._declared; }
		VarReference.prototype.setDeclared = function(v){ this._declared = v; return this; };
		VarReference.prototype.type = function(v){ return this._type; }
		VarReference.prototype.setType = function(v){ this._type = v; return this; };
		
		VarReference.prototype.loc = function (){
			// p "loc for VarReference {@value:constructor} {@value.@value:constructor} {@value.region}"
			return this._value.region();
		};
		
		VarReference.prototype.set = function (o){
			// hack - workaround for hidden classes perf
			if (o.export) { this._export = true };
			return this;
		};
		
		VarReference.prototype.js = function (o){
			// experimental fix
			
			// what about resolving?
			var ref = this._variable;
			var out = ("" + mark__(this._value) + (ref.c()));
			
			// p "VarReference {out} - {o.up} {o.up == self}\n{o}"
			
			if (ref && !ref._declared) { // .option(:declared)
				if (o.up(VarBlock)) { // up varblock??
					ref._declared = true;
					
					// ref.set(declared: yes)
				} else if (o.isExpression() || this._export) { // why?
					// p "autodeclare"
					ref.autodeclare();
				} else {
					out = ("var " + out);
					ref._declared = true;
					// ref.set(declared: yes)
				};
			};
			
			// need to think the export through -- like registering somehow
			// should register in scope - export on analysis++
			if (this._export) {
				out = ("module.exports." + (ref.c()) + " = " + (ref.c()));
			};
			
			return out;
		};
		
		VarReference.prototype.declare = function (){
			return this;
		};
		
		VarReference.prototype.consume = function (node){
			// really? the consumed node dissappear?
			this._variable && this._variable.autodeclare();
			return this;
		};
		
		VarReference.prototype.visit = function (){
			
			// console.log "value type for VarReference {@value} {@value.@loc} {@value:constructor}"
			
			// should be possible to have a VarReference without a name as well? for a system-variable
			// name should not set this way.
			// p "varname {value} {value:constructor}"
			var name = this.value().c();
			// p "visit vardecl {name} {value}"
			
			// what about looking up? - on register we want to mark
			var v = this._variable || (this._variable = this.scope__().register(name,this,{type: this._type}));
			// FIXME -- should not simply override the declarator here(!)
			
			if (!v.declarator()) {
				v.setDeclarator(this);
			};
			
			if (this._value) { v.addReference(this._value) }; // is this the first reference?
			
			// only needed when analyzing?
			this._value._value._variable = v;
			return this;
		};
		
		VarReference.prototype.refnr = function (){
			return this.variable().references().indexOf(this.value());
		};
		
		// convert this into a list of references
		VarReference.prototype.addExpression = function (expr){
			
			return new VarBlock([this]).addExpression(expr);
		};
		
		
		// ASSIGN
		
		function Assign(o,l,r){
			
			// workaround until we complete transition from lua-style assignments
			// to always use explicit tuples - then we can move assignments out etc
			// this will not be needed after we remove support for var a,b,c = 1,2,3
			if ((l instanceof VarReference) && (l.value() instanceof Arr)) {
				// converting all nodes to var-references ?
				// do we need to keep it in a varblock at all?
				var vars = l.value().nodes().map(function(v) {
					// what about inner tuples etc?
					// keep the splats -- clumsy but true
					var v_;
					if (v instanceof Splat) {
						// p "value is a splat!!"
						if (!((v.value() instanceof VarReference))) { (v.setValue(v_ = new VarReference(v.value(),l.type())),v_) };
					} else if (v instanceof VarReference) {
						true;
					} else {
						// what about retaining location?
						// v = v.value if v isa VarOrAccess
						v = new VarReference(v,l.type());
					};
					
					return v;
					
					// v isa VarReference ? v : VarReference.new(v)
				});
				return new TupleAssign(o,new Tuple(vars),r);
			};
			
			if (l instanceof Arr) {
				return new TupleAssign(o,new Tuple(l.nodes()),r);
				// p "left is array in assign - in init"
			};
			
			
			// set expression yes, no?
			this._expression = false;
			this._traversed = false;
			this._parens = false;
			this._cache = null;
			this._invert = false;
			this._opToken = o;
			this._op = o && o._value || o;
			this._left = l;
			this._right = r;
			return this;
		};
		
		subclass$(Assign,Op);
		exports.Assign = Assign; // export class 
		Assign.prototype.isExpressable = function (){
			return !(this.right()) || this.right().isExpressable();
		};
		
		Assign.prototype.isUsed = function (){
			// really?
			// if up is a block in general this should not be used -- since it should already have received implicit self?
			if (this.up() instanceof Block) { // && up.last != self
				return false;
			};
			return true;
		};
		
		// FIXME optimize
		Assign.prototype.visit = function (){
			var l = this._left;
			var r = this._right;
			
			// WARNING - slightly undefined
			// MARK THE STACK
			if (l) { l.traverse() };
			
			var lvar = (l instanceof VarReference) && l.variable();
			
			// how does this work with constants that are really var references?
			// should work when things are not described as well - but this is for testing
			// but if it refers to something else 
			if (!(lvar) && this._desc) {
				// entities should be able to extract the needed info instead
				ROOT.entities().add(l.namepath(),{namepath: l.namepath(),type: r.typeName(),desc: this._desc});
			};
			
			// this should probably be done in a different manner
			if (lvar && lvar.declarator() == l) {
				lvar._initialized = false;
				if (r) { r.traverse() };
				lvar._initialized = true;
			} else {
				if (r) { r.traverse() };
			};
			
			if ((l instanceof VarReference) || l._variable) {
				l._variable.assigned(r,this);
			};
			
			return this;
		};
		
		Assign.prototype.c = function (o){
			if (!this.right().isExpressable()) {
				// p "Assign#c right is not expressable "
				return this.right().consume(this).c(o);
			};
			// testing this
			return Assign.__super__.c.call(this,o);
		};
		
		Assign.prototype.js = function (o){
			if (!this.right().isExpressable()) {
				this.p("Assign#js right is not expressable ");
				// here this should be go out of the stack(!)
				// it should already be consumed?
				return this.right().consume(this).c();
			};
			
			// p "assign left {left:contrstru}"
			var l = this.left().node();
			var r = this.right();
			
			// We are setting self(!)
			// TODO document functionality
			if (l instanceof Self) {
				var ctx = this.scope__().context();
				l = ctx.reference();
			};
			
			
			if (l instanceof PropertyAccess) {
				var ast = CALL(OP('.',l.left(),l.right().setter()),[this.right()]);
				ast.setReceiver(l.receiver());
				
				if (this.isUsed()) {
					// p "Assign is used {stack}"
					// dont cache it again if it is already cached(!)
					if (!this.right().cachevar()) { this.right().cache({pool: 'val',uses: 1}) }; // 
					// this is only when used.. should be more clever about it
					ast = new Parens(blk__([ast,this.right()]));
				};
				
				// should check the up-value no?
				return ast.c({expression: true});
			};
			
			// if l isa VarReference
			// 	p "assign var-ref"
			// 	l.@variable.assigned(r)
			
			// FIXME -- does not always need to be an expression?
			// p "typeof op {@opToken and @opToken:constructor}"
			var out = ("" + (l.c()) + " " + mark__(this._opToken) + this.op() + " " + this.right().c({expression: true}));
			
			return out;
		};
		
		// FIXME op is a token? _FIX_
		// this (and similar cases) is broken when called from
		// another position in the stack, since 'up' is dynamic
		// should maybe freeze up?
		Assign.prototype.shouldParenthesize = function (par){
			if(par === undefined) par = this.up();
			return this._parens || (par instanceof Op) && par.op() != '=';
		};
		
		Assign.prototype.consume = function (node){
			if (this.isExpressable()) {
				this.forceExpression();
				return Assign.__super__.consume.call(this,node);
			};
			
			var ast = this.right().consume(this);
			return ast.consume(node);
		};
		
		// more workaround during transition away from a,b,c = 1,2,3 style assign
		Assign.prototype.addExpression = function (expr){
			var typ = ExpressionBlock;
			if (this._left && (this._left instanceof VarReference)) {
				typ = VarBlock;
			};
			// might be better to nest this up after parsing is done?
			// p "Assign.addExpression {self} <- {expr}"
			var node = new typ([this]);
			return node.addExpression(expr);
		};
		
		
		function PushAssign(){ return Assign.apply(this,arguments) };
		
		subclass$(PushAssign,Assign);
		exports.PushAssign = PushAssign; // export class 
		PushAssign.prototype.js = function (o){
			return ("" + (this.left().c()) + ".push(" + (this.right().c()) + ")");
		};
		
		PushAssign.prototype.consume = function (node){
			return this;
		};
		
		
		function ConditionalAssign(){ return Assign.apply(this,arguments) };
		
		subclass$(ConditionalAssign,Assign);
		exports.ConditionalAssign = ConditionalAssign; // export class 
		ConditionalAssign.prototype.consume = function (node){
			return this.normalize().consume(node);
		};
		
		ConditionalAssign.prototype.normalize = function (){
			var l = this.left().node();
			var ls = l;
			
			if (l instanceof Access) {
				// p "conditional-assign {l} {l.left} {l.right}"
				if (l.left()) {
					// p "cache l.left {l.left:constructor}̋"
					l.left().cache();
				};
				ls = l.clone(l.left(),l.right()); // this should still be cached?
				if (l instanceof PropertyAccess) { l.cache() }; // correct now, to a certain degree
				if (l instanceof IndexAccess) {
					// p "cache the right side of indexAccess!!! {l.right}"
					l.right().cache();
				};
				
				// we should only cache the value itself if it is dynamic?
				// l.cache # cache the value as well -- we cannot use this in assigns them
			};
			
			// some ops are less messy
			// need op to support consume then?
			var expr = this.right().isExpressable();
			var ast = null;
			// here we should use ast = if ...
			if (expr && this.op() == '||=') {
				ast = OP('||',l,OP('=',ls,this.right()));
			} else if (expr && this.op() == '&&=') {
				ast = OP('&&',l,OP('=',ls,this.right()));
			} else {
				ast = IF(this.condition(),OP('=',ls,this.right()),l); // do we need a scope for these?
				ast.setScope(null);
				// drop the scope
				// touch scope -- should probably visit the whole thing?
				// ast.scope.visit
			};
			if (ast.isExpressable()) { ast.toExpression() };
			return ast;
		};
		
		
		ConditionalAssign.prototype.c = function (){
			// WARN what if we return the same?
			return this.normalize().c();
		};
		
		ConditionalAssign.prototype.condition = function (){
			
			// use switch instead to cache op access
			if (this.op() == '?=') {
				return OP('==',this.left(),NULL);
			} else if (this.op() == '||=') {
				return OP('!',this.left());
			} else if (this.op() == '&&=') {
				return this.left();
			} else if (this.op() == '!?=') {
				return OP('!=',this.left(),NULL);
			} else {
				return this.left();
			};
		};
		
		ConditionalAssign.prototype.js = function (o){
			// p "ConditionalAssign.js".red
			var ast = IF(this.condition(),OP('=',this.left(),this.right()),this.left());
			ast.setScope(null); // not sure about this
			if (ast.isExpressable()) { ast.toExpression() }; // forced expression already
			return ast.c();
		};
		
		function CompoundAssign(){ return Assign.apply(this,arguments) };
		
		subclass$(CompoundAssign,Assign);
		exports.CompoundAssign = CompoundAssign; // export class 
		CompoundAssign.prototype.consume = function (node){
			if (this.isExpressable()) { return CompoundAssign.__super__.consume.apply(this,arguments) };
			
			var ast = this.normalize();
			if (ast != this) { return ast.consume(node) };
			
			ast = this.right().consume(this);
			return ast.consume(node);
		};
		
		CompoundAssign.prototype.normalize = function (){
			var ln = this.left().node();
			// we dont need to change this at all
			if (!((ln instanceof PropertyAccess))) {
				return this;
			};
			
			if (ln instanceof Access) {
				// left might be zero?!?!
				if (ln.left()) { ln.left().cache() };
			};
			// TODO FIXME we want to cache the context of the assignment
			// p "normalize compound assign {left}"
			var ast = OP('=',this.left(),OP(this.op()[0],this.left(),this.right()));
			if (ast.isExpressable()) { ast.toExpression() };
			
			return ast;
		};
		
		CompoundAssign.prototype.c = function (){
			var ast = this.normalize();
			if (ast == this) { return CompoundAssign.__super__.c.apply(this,arguments) };
			
			// otherwise it is important that we actually replace this node in the outer block
			// whenever we normalize and override c it is important that we can pass on caching
			// etc -- otherwise there WILL be issues.
			var up = STACK.current();
			if (up instanceof Block) {
				// p "parent is block, should replace!"
				// an alternative would be to just pass
				up.replace(this,ast);
			};
			return ast.c();
		};
		
		
		function AsyncAssign(){ return Assign.apply(this,arguments) };
		
		subclass$(AsyncAssign,Assign);
		exports.AsyncAssign = AsyncAssign; // export class 
		
		
		
		function TupleAssign(a,b,c){
			this._traversed = false;
			this._op = a;
			this._left = b;
			this._right = c;
			this._temporary = [];
		};
		
		subclass$(TupleAssign,Assign);
		exports.TupleAssign = TupleAssign; // export class 
		TupleAssign.prototype.op = function(v){ return this._op; }
		TupleAssign.prototype.setOp = function(v){ this._op = v; return this; };
		TupleAssign.prototype.left = function(v){ return this._left; }
		TupleAssign.prototype.setLeft = function(v){ this._left = v; return this; };
		TupleAssign.prototype.right = function(v){ return this._right; }
		TupleAssign.prototype.setRight = function(v){ this._right = v; return this; };
		TupleAssign.prototype.type = function(v){ return this._type; }
		TupleAssign.prototype.setType = function(v){ this._type = v; return this; };
		
		TupleAssign.prototype.isExpressable = function (){
			return this.right().isExpressable();
		};
		
		TupleAssign.prototype.addExpression = function (expr){
			if (this.right() instanceof Tuple) {
				this.right().push(expr);
			} else {
				// p "making child become a tuple?"
				this.setRight(new Tuple([this.right(),expr]));
			};
			
			return this;
		};
		
		TupleAssign.prototype.visit = function (){
			// if the first left-value is a var-reference, then
			// all the variables should be declared as variables.
			// but if we have complex items in the other list - it does become much harder
			
			// if the first is a var-reference, they should all be(!) .. or splats?
			// this is really a hacky wao to do it though
			if (this.left().first().node() instanceof VarReference) {
				this.setType('var');
				// should possibly allow real vars as well, no?
				this._vars = this.left().nodes().filter(function(n) { return n instanceof VarReference; });
				// collect the vars for tuple for easy access
				
				// NOTE can improve.. should rather make the whole left be a VarBlock or TupleVarBlock
				// p "type is var -- skip the rest"
			};
			
			this.right().traverse();
			this.left().traverse();
			return this;
		};
		
		TupleAssign.prototype.js = function (o){
			// only for actual inner expressions, otherwise cache the whole array, no?
			var self = this;
			if (!self.right().isExpressable()) {
				// p "TupleAssign.consume! {right}".blue
				
				return self.right().consume(self).c();
			};
			
			// p "TUPLE {type}"
			
			/* a,b,c = arguments */
			
			// - direct. no matter if lvalues are variables or not. Make fake arguments up to the same count as tuple
			
			/* a,*b,b = arguments */
			
			// Need to convert arguments to an array. IF arguments is not referenced anywhere else in scope, 
			// we can do the assignment directly while rolling through arguments
			
			/* a,b = b,a */
			
			// ideally we only need to cache the first value (or n - 1), assign directly when possible.
			
			/* a,b,c = (method | expression) */
			
			// convert res into array, assign from array. Can cache the variable when assigning first value
			
			// First we need to find out whether we are required to store the result in an array before assigning
			// If this needs to be an expression (returns?, we need to fall back to the CS-wa)
			
			var ast = new Block([]);
			var lft = self.left();
			var rgt = self.right();
			var typ = self.type();
			var via = null;
			
			var li = 0;
			var ri = lft.count();
			var llen = ri;
			
			
			// if @vars
			// 	p "tuple has {@vars:length} vars"
			
			// if we have a splat on the left it is much more likely that we need to store right
			// in a temporary array, but if the right side has a known length, it should still not be needed
			var lsplat = lft.filter(function(v) { return v instanceof Splat; })[0];
			
			// if right is an array without any splats (or inner tuples?), normalize it to tuple
			if ((rgt instanceof Arr) && !rgt.splat()) { rgt = new Tuple(rgt.nodes()) };
			var rlen = rgt instanceof Tuple ? (rgt.count()) : (null);
			
			// if any values are statements we need to handle this before continuing
			
			/* a,b,c = 10,20,ary */
			
			// ideally we only need to cache the first value (or n - 1), assign directly when possible.
			// only if the variables are not predefined or predeclared can be we certain that we can do it without caching
			// if rlen && typ == 'var' && !lsplat
			// 	# this can be dangerous in edgecases that are very hard to detect
			// 	# if it becomes an issue, fall back to simpler versions
			// 	# does not even matter if there is a splat?
			
			// special case for arguments(!)
			if (!(lsplat) && rgt == ARGUMENTS) {
				
				var pars = self.scope__().params();
				// p "special case with arguments {pars}"
				// forcing the arguments to be named
				// p "got here??? {pars}"
				lft.map(function(l,i) { return ast.push(OP('=',l.node(),pars.at(i,true).visit().variable())); }); // s.params.at(value - 1,yes)
			} else if (rlen) {
				// we have several items in the right part. what about splats here?
				
				// pre-evaluate rvalues that might be reference from other assignments
				// we need to check if the rightside values has no side-effects. Cause if
				// they dont, we really do not need temporary variables.
				
				// some of these optimizations are quite petty - makes things more complicated
				// in the compiler only to get around adding a few temp-variables here and there
				
				// var firstUnsafe = 0
				// lft.map do |v,i|
				// 	if v isa VarReference
				// 		p "left side {i} {v} {v.refnr}"
				
				// rgt.map do |v,i|
				// 	if v.hasSideEffects
				// 		# return if i == 0 or !v.hasSideEffects
				// 		# return if v isa Num || v isa Str || i == 0
				// 		# we could explicitly create a temporary variable and adding nodes for accessing etc
				// 		# but the builtin caching should really take care of this for us
				// 		# we need to really force the caching though -- since we need a copy of it even if it is a local
				// 		# we need to predeclare the variables at the top of scope if this does not take care of it
				// 		
				// 		# these are the declarations -- we need to add them somewhere smart
				// 		@temporary.push(v) # need a generalized way to do this type of thing
				// 		ast.push(v.cache(force: yes, type: 'swap', declared: typ == 'var'))
				// 		# they do need to be declared, no?
				
				// now we can free the cached variables
				// ast.map do |n| n.decache
				
				var pre = [];
				var rest = [];
				
				var pairs = lft.map(function(l,i) {
					var v = null;
					// determine if this needs to be precached?
					// if l isa VarReference
					// 	# this is the first time the variable is referenced
					// 	# should also count even if it is predeclared at the top
					// 	if l.refnr == 0
					
					if (l == lsplat) {
						v = new ArgList([]);
						var to = (rlen - (ri - i));
						// p "assing splat at index {i} to slice {li} - {to}".cyan
						while (li <= to){
							v.push(rgt.index(li++));
						};
						v = new Arr(v);
						// ast.push OP('=',l.node,Arr.new(v))
					} else {
						v = rgt.index(li++);
					};
					return [l.node(),v];
					
					// if l isa VarReference && l.refnr 
				});
				var clean = true;
				
				pairs.map(function(v,i) {
					var l = v[0];
					var r = v[1];
					
					if (clean) {
						if ((l instanceof VarReference) && l.refnr() == 0) {
							// still clean
							clean = true;
						} else {
							clean = false;
							// p "now cache"
							pairs.slice(i).map(function(part) {
								if (part[1].hasSideEffects()) {
									self._temporary.push(part[1]); // need a generalized way to do this type of thing
									return ast.push(part[1].cache({force: true,pool: 'swap',declared: typ == 'var'}));
								};
							});
							// p "from {i} - cache all remaining with side-effects"
						};
					};
					
					// if the previous value in ast is a reference to our value - the caching was not needed
					if (ast.last() == r) {
						r.decache();
						// p "was cached - not needed"
						// simple assign
						return ast.replace(r,OP('=',l,r));
					} else {
						return ast.push(OP('=',l,r));
					};
				});
				
				// WARN FIXME Is there not an issue with VarBlock vs not here?
			} else {
				// this is where we need to cache the right side before assigning
				// if the right side is a for loop, we COULD try to be extra clever, but
				// for now it is not worth the added compiler complexity
				
				// iter.cache(force: yes, type: 'iter')
				var top = new VarBlock();
				var iter = self.util().iterable(rgt,true);
				// could set the vars inside -- most likely
				ast.push(top);
				top.push(iter);
				
				if (lsplat) {
					var len = self.util().len(iter,true);
					var idx = self.util().counter(0,true);
					// cache the length of the array
					top.push(len); // preassign the length
					// cache counter to loop through
					top.push(idx);
				};
				
				// only if the block is variable based, no?
				// ast.push(blk = VarBlock.new)
				// blk = null
				
				var blktype = typ == 'var' ? (VarBlock) : (Block);
				var blk = new blktype([]);
				// blk = top if typ == 'var'
				ast.push(blk);
				
				// if the lvals are not variables - we need to preassign
				// can also use slice here for simplicity, but try with while now			
				lft.map(function(l,i) {
					if (l == lsplat) {
						var lvar = l.node();
						var rem = llen - i - 1; // remaining after splat
						
						if (typ != 'var') {
							var arr = self.util().array(OP('-',len,num__(i + rem)),true);
							top.push(arr);
							lvar = arr.cachevar();
						} else {
							if (!(blk)) { ast.push(blk = new blktype()) };
							arr = self.util().array(OP('-',len,num__(i + rem)));
							blk.push(OP('=',lvar,arr));
						};
						
						// if !lvar:variable || !lvar.variable # lvar = 
						// 	top.push()
						//	p "has variable - no need to create a temp"
						// blk.push(OP('=',lvar,Arr.new([]))) # dont precalculate size now
						// max = to = (rlen - (llen - i))
						
						
						var test = rem ? (OP('-',len,rem)) : (len);
						
						var set = OP('=',OP('.',lvar,OP('-',idx,num__(i))),
						OP('.',iter,OP('++',idx)));
						
						ast.push(WHILE(OP('<',idx,test),set));
						
						if (typ != 'var') {
							ast.push(blk = new Block());
							return blk.push(OP('=',l.node(),lvar));
						} else {
							return blk = null;
						};
						
						// not if splat was last?
						// ast.push(blk = VarBlock.new)
					} else if (lsplat) {
						if (!(blk)) { ast.push(blk = new blktype()) };
						// we could cache the raw code of this node for better performance
						return blk.push(OP('=',l,OP('.',iter,OP('++',idx))));
					} else {
						if (!(blk)) { ast.push(blk = new blktype()) };
						return blk.push(OP('=',l,OP('.',iter,num__(i))));
					};
				});
			};
			
			// if we are in an expression we really need to 
			if (o.isExpression() && self._vars) {
				// p "tuple is expression" # variables MUST be autodeclared outside of the expression
				for (var i = 0, ary = iter$(self._vars), len_ = ary.length; i < len_; i++) {
					ary[i].variable().autodeclare();
				};
			} else if (self._vars) {
				for (var i = 0, ary = iter$(self._vars), len_ = ary.length; i < len_; i++) {
					// p "predeclare variable before compilation"
					ary[i].variable().predeclared();
				};
			};
			
			// is there any reason to make it into an expression?
			if (ast.isExpressable()) { // NO!
				// p "express"
				// if this is an expression
				var out = ast.c({expression: true});
				if (typ && !o.isExpression()) { out = ("" + typ + " " + out) }; // not in expression
				return out;
			} else {
				out = ast.c();
				// if this is a varblock 
				return out;
			};
		};
		
		
		TupleAssign.prototype.c = function (o){
			var out = TupleAssign.__super__.c.call(this,o);
			// this is only used in tuple -- better to let the tuple hav a separate #c
			if (this._temporary && this._temporary.length) {
				this._temporary.map(function(temp) { return temp.decache(); });
			};
			return out;
		};
		
		
		
		// IDENTIFIERS
		
		// really need to clean this up
		// Drop the token?
		function Identifier(value){
			this._value = this.load(value);
			this._symbol = null;
			this._setter = null;
			
			if (("" + value).indexOf("?") >= 0) {
				this._safechain = true;
			};
			// @safechain = ("" + value).indexOf("?") >= 0
			this;
		};
		
		subclass$(Identifier,Node);
		exports.Identifier = Identifier; // export class 
		Identifier.prototype.safechain = function(v){ return this._safechain; }
		Identifier.prototype.setSafechain = function(v){ this._safechain = v; return this; };
		Identifier.prototype.value = function(v){ return this._value; }
		Identifier.prototype.setValue = function(v){ this._value = v; return this; };
		
		Identifier.prototype.references = function (variable){
			if (this._value) { this._value._variable = variable };
			return this;
		};
		
		Identifier.prototype.sourceMapMarker = function (){
			return this._value.sourceMapMarker();
		};
		
		Identifier.prototype.load = function (v){
			return (v instanceof Identifier ? (v.value()) : (v));
		};
		
		Identifier.prototype.traverse = function (){
			// NODES.push(self)
			return this;
		};
		
		Identifier.prototype.visit = function (){
			
			if (this._value instanceof Node) {
				// console.log "IDENTIFIER VALUE IS NODE"
				this._value.traverse();
			};
			return this;
		};
		
		Identifier.prototype.region = function (){
			return [this._value._loc,this._value._loc + this._value._len];
		};
		
		Identifier.prototype.isValidIdentifier = function (){
			return true;
		};
		
		Identifier.prototype.isReserved = function (){
			return this._value.reserved || RESERVED_TEST.test(String(this._value));
		};
		
		Identifier.prototype.symbol = function (){
			// console.log "Identifier#symbol {value}"
			return this._symbol || (this._symbol = sym__(this.value()));
		};
		
		Identifier.prototype.setter = function (){
			// console.log "Identifier#setter"
			var tok;
			return this._setter || (this._setter = (true) && (
				tok = new Token('IDENTIFIER',sym__('set-' + this._value),this._value._loc || -1),
				new Identifier(tok)
				// Identifier.new("set-{symbol}")
			));
		};
		
		Identifier.prototype.toString = function (){
			return String(this._value);
		};
		
		Identifier.prototype.toJSON = function (){
			return this.toString();
		};
		
		Identifier.prototype.alias = function (){
			return sym__(this._value);
		};
		
		Identifier.prototype.js = function (o){
			return this.symbol();
		};
		
		Identifier.prototype.c = function (){
			return '' + this.symbol(); // mark__(@value) + 
		};
		
		Identifier.prototype.dump = function (){
			return {loc: this.region()};
		};
		
		Identifier.prototype.namepath = function (){
			return this.toString();
		};
		
		function TagId(v){
			this._value = v instanceof Identifier ? (v.value()) : (v);
			this;
		};
		
		subclass$(TagId,Identifier);
		exports.TagId = TagId; // export class 
		TagId.prototype.c = function (){
			return ("id$('" + (this.value().c()) + "')");
		};
		
		// This is not an identifier - it is really a string
		// Is this not a literal?
		
		// FIXME Rename to IvarLiteral? or simply Literal with type Ivar
		function Ivar(v){
			this._value = v instanceof Identifier ? (v.value()) : (v);
			this;
		};
		
		subclass$(Ivar,Identifier);
		exports.Ivar = Ivar; // export class 
		Ivar.prototype.name = function (){
			return helpers.camelCase(this._value).replace(/^@/,'');
			// value.c.camelCase.replace(/^@/,'')
		};
		
		Ivar.prototype.alias = function (){
			return '_' + this.name();
		};
		
		// the @ should possibly be gone from the start?
		Ivar.prototype.js = function (o){
			return '_' + this.name();
		};
		
		Ivar.prototype.c = function (){
			return '_' + helpers.camelCase(this._value).slice(1); // .replace(/^@/,'') # mark__(@value) + 
		};
		
		
		
		// Ambiguous - We need to be consistent about Const vs ConstAccess
		// Becomes more important when we implement typeinference and code-analysis
		function Const(){ return Identifier.apply(this,arguments) };
		
		subclass$(Const,Identifier);
		exports.Const = Const; // export class 
		Const.prototype.symbol = function (){
			// console.log "Identifier#symbol {value}"
			return this._symbol || (this._symbol = sym__(this.value()));
		};
		
		Const.prototype.js = function (o){
			return this.symbol();
		};
		
		Const.prototype.c = function (){
			return mark__(this._value) + this.symbol();
		};
		
		function TagTypeIdentifier(value){
			this._value = this.load(value);
			this;
		};
		
		subclass$(TagTypeIdentifier,Identifier);
		exports.TagTypeIdentifier = TagTypeIdentifier; // export class 
		TagTypeIdentifier.prototype.name = function(v){ return this._name; }
		TagTypeIdentifier.prototype.setName = function(v){ this._name = v; return this; };
		TagTypeIdentifier.prototype.ns = function(v){ return this._ns; }
		TagTypeIdentifier.prototype.setNs = function(v){ this._ns = v; return this; };
		
		TagTypeIdentifier.prototype.load = function (val){
			this._str = ("" + val);
			var parts = this._str.split(":");
			this._raw = val;
			this._name = parts.pop();
			this._ns = parts.shift(); // if any?
			return this._str;
		};
		
		TagTypeIdentifier.prototype.js = function (o){
			return ("Imba.TAGS." + this._str.replace(":","$"));
		};
		
		TagTypeIdentifier.prototype.c = function (){
			return this.js();
		};
		
		TagTypeIdentifier.prototype.func = function (){
			var name = this._name.replace(/-/g,'_').replace(/\#/,'');
			if (this._ns) { name += ("$" + (this._ns.toLowerCase())) };
			return name;
		};
		
		TagTypeIdentifier.prototype.spawner = function (){
			if (this._ns) {
				return ("" + (this._ns.toUpperCase()) + ".$" + this._name.replace(/-/g,'_'));
			} else {
				return ("$" + this._name.replace(/-/g,'_'));
			};
		};
		
		TagTypeIdentifier.prototype.id = function (){
			var m = this._str.match(/\#([\w\-\d\_]+)\b/);
			return m ? (m[1]) : (null);
		};
		
		
		TagTypeIdentifier.prototype.flag = function (){
			return "_" + this.name().replace(/--/g,'_').toLowerCase();
		};
		
		TagTypeIdentifier.prototype.sel = function (){
			return ("." + this.flag()); // + name.replace(/-/g,'_').toLowerCase
		};
		
		TagTypeIdentifier.prototype.string = function (){
			return this.value();
		};
		
		
		function Argvar(){ return ValueNode.apply(this,arguments) };
		
		subclass$(Argvar,ValueNode);
		exports.Argvar = Argvar; // export class 
		Argvar.prototype.c = function (){
			// NEXT -- global.parseInt or Number.parseInt (better)
			var v = parseInt(String(this.value()));
			// FIXME Not needed anymore? I think the lexer handles this
			if (v == 0) { return "arguments" };
			
			var s = this.scope__();
			// params need to go up to the closeste method-scope
			var par = s.params().at(v - 1,true);
			return ("" + c__(par.name())); // c
		};
		
		
		// CALL
		
		function Call(callee,args,opexists){
			this._traversed = false;
			this._expression = false;
			this._parens = false;
			this._cache = null;
			this._receiver = null;
			this._opexists = opexists;
			// some axioms that share the same syntax as calls will be redirected from here
			
			if (callee instanceof VarOrAccess) {
				var str = callee.value().symbol();
				// p "Call callee {callee} - {str}"
				if (str == 'extern') {
					// p "returning extern instead!"
					callee.value().value()._type = 'EXTERN';
					return new ExternDeclaration(args);
				};
				if (str == 'tag') {
					// console.log "ERROR - access args by some method"
					return new TagWrapper(args && args.index ? (args.index(0)) : (args[0]));
				};
				if (str == 'export') {
					return new ExportStatement(args);
				};
			};
			
			this._callee = callee;
			this._args = args || new ArgList([]);
			
			if (args instanceof Array) {
				this._args = new ArgList(args);
				// console.log "ARGUMENTS IS ARRAY - error {args}"
			};
			// p "call opexists {opexists}"
			this;
		};
		
		subclass$(Call,Node);
		exports.Call = Call; // export class 
		Call.prototype.callee = function(v){ return this._callee; }
		Call.prototype.setCallee = function(v){ this._callee = v; return this; };
		Call.prototype.receiver = function(v){ return this._receiver; }
		Call.prototype.setReceiver = function(v){ this._receiver = v; return this; };
		Call.prototype.args = function(v){ return this._args; }
		Call.prototype.setArgs = function(v){ this._args = v; return this; };
		Call.prototype.block = function(v){ return this._block; }
		Call.prototype.setBlock = function(v){ this._block = v; return this; };
		
		Call.prototype.visit = function (){
			// console.log "visit args {args}"
			this.args().traverse();
			this.callee().traverse();
			
			// if the callee is a PropertyAccess - better to immediately change it
			
			return this._block && this._block.traverse();
		};
		
		Call.prototype.addBlock = function (block){
			var pos = this._args.filter(function(n,i) { return n == '&'; })[0]; // WOULD BE TOKEN - CAREFUL
			pos ? (this.args().replace(pos,block)) : (this.args().push(block));
			return this;
		};
		
		Call.prototype.receiver = function (){
			return this._receiver || (this._receiver = ((this.callee() instanceof Access) && this.callee().left() || NULL));
		};
		
		// check if all arguments are expressions - otherwise we have an issue
		
		Call.prototype.safechain = function (){
			return this.callee().safechain(); // really?
		};
		
		Call.prototype.js = function (o){
			var opt = {expression: true};
			var rec = null;
			// var args = compact__(args) # really?
			var args = this.args();
			
			// drop this?
			
			var splat = args.some(function(v) { return v instanceof Splat; });
			
			var out = null;
			var lft = null;
			var rgt = null;
			var wrap = null;
			
			var callee = this._callee = this._callee.node(); // drop the var or access?
			
			// if callee isa Call && callee.safechain
			//	yes
			
			if (callee instanceof Access) {
				lft = callee.left();
				rgt = callee.right();
			};
			
			if ((callee instanceof Super) || (callee instanceof SuperAccess)) {
				this._receiver = this.scope__().context();
				// return "supercall"
			};
			
			// never call the property-access directly?
			if (callee instanceof PropertyAccess) { // && rec = callee.receiver
				// p "unwrapping property-access in call"
				this._receiver = callee.receiver();
				callee = this._callee = new Access(callee.op(),callee.left(),callee.right());
				// p "got here? {callee}"
				// console.log "unwrapping the propertyAccess"
			};
			
			if (callee.safechain()) {
				// p "callee is safechained?!?"
				// if lft isa Call
				// if lft isa Call # could be a property access as well - it is the same?
				// if it is a local var access we simply check if it is a function, then call
				// but it should be safechained outside as well?
				// lft.cache if lft
				// the outer safechain should not cache the whole call - only ask to cache
				// the result? -- chain onto
				// p "Call safechain {callee} {lft}.{rgt}"
				var isfn = new Util.IsFunction([callee]);
				wrap = [("" + (isfn.c()) + "  &&  "),""];
				callee = OP('.',callee.left(),callee.right());
				// callee should already be cached now - 
			};
			
			// should just force expression from the start, no?
			if (splat) {
				// important to wrap the single value in a value, to keep implicit call
				// this is due to the way we check for an outer Call without checking if
				// we are the receiver (in PropertyAccess). Should rather wrap in CallArguments
				var rec1 = this.receiver();
				var ary = (args.count() == 1 ? (new ValueNode(args.first().value())) : (new Arr(args.list())));
				
				rec1.cache(); // need to cache the context as it will be referenced in apply
				out = ("" + callee.c({expression: true}) + ".apply(" + (rec1.c()) + "," + ary.c({expression: true}) + ")");
			} else if (this._receiver) {
				// quick workaround
				if (!((this._receiver instanceof ScopeContext))) { this._receiver.cache() };
				args.unshift(this.receiver());
				// should rather rewrite to a new call?
				out = ("" + callee.c({expression: true}) + ".call(" + args.c({expression: true}) + ")");
			} else {
				out = ("" + callee.c({expression: true}) + "(" + args.c({expression: true}) + ")");
			};
			
			if (wrap) {
				// we set the cachevar inside
				// p "special caching for call"
				if (this._cache) {
					this._cache.manual = true;
					out = ("(" + (this.cachevar().c()) + "=" + out + ")");
				};
				
				out = [wrap[0],out,wrap[1]].join("");
			};
			
			return out;
		};
		
		
		
		
		function ImplicitCall(){ return Call.apply(this,arguments) };
		
		subclass$(ImplicitCall,Call);
		exports.ImplicitCall = ImplicitCall; // export class 
		ImplicitCall.prototype.js = function (o){
			return ("" + (this.callee().c()) + "()");
		};
		
		function New(){ return Call.apply(this,arguments) };
		
		subclass$(New,Call);
		exports.New = New; // export class 
		New.prototype.js = function (o){
			var target = this.callee();
			
			while (target instanceof Access){
				var left = target.left();
				
				if ((left instanceof PropertyAccess) || (left instanceof VarOrAccess)) {
					this.callee()._parens = true;
					break;
				};
				
				target = left;
			};
			
			var out = ("new " + (this.callee().c()));
			if (!((o.parent() instanceof Call))) { out += '()' };
			return out;
		};
		
		function SuperCall(){ return Call.apply(this,arguments) };
		
		subclass$(SuperCall,Call);
		exports.SuperCall = SuperCall; // export class 
		SuperCall.prototype.js = function (o){
			var m = o.method();
			this.setReceiver(SELF);
			this.setCallee(("" + (m.target().c()) + ".super$.prototype." + (m.name().c())));
			return SuperCall.__super__.js.apply(this,arguments);
		};
		
		
		
		function ExternDeclaration(){ return ListNode.apply(this,arguments) };
		
		subclass$(ExternDeclaration,ListNode);
		exports.ExternDeclaration = ExternDeclaration; // export class 
		ExternDeclaration.prototype.visit = function (){
			
			// p "visiting externdeclaration"
			this.setNodes(this.map(function(item) { return item.node(); })); // drop var or access really
			// only in global scope?
			var root = this.scope__();
			for (var i = 0, ary = iter$(this.nodes()), len = ary.length, item; i < len; i++) {
				item = ary[i];
				var variable = root.register(item.symbol(),item,{type: 'global'});
				variable.addReference(item);
			};
			return this;
		};
		
		ExternDeclaration.prototype.c = function (){
			return "// externs";
		};
		
		
		// FLOW
		
		function ControlFlow(){ return Node.apply(this,arguments) };
		
		subclass$(ControlFlow,Node);
		exports.ControlFlow = ControlFlow; // export class 
		
		
		
		
		function ControlFlowStatement(){ return ControlFlow.apply(this,arguments) };
		
		subclass$(ControlFlowStatement,ControlFlow);
		exports.ControlFlowStatement = ControlFlowStatement; // export class 
		ControlFlowStatement.prototype.isExpressable = function (){
			return false;
		};
		
		
		
		function If(cond,body,o){
			if(o === undefined) o = {};
			this.setup();
			this._test = cond; // (o:type == 'unless' ? UnaryOp.new('!',cond,null) : cond)
			this._body = body;
			this._alt = null;
			this._type = o.type;
			if (this._type == 'unless') this.invert();
			this._scope = new IfScope(this);
			this;
		};
		
		subclass$(If,ControlFlow);
		exports.If = If; // export class 
		If.prototype.test = function(v){ return this._test; }
		If.prototype.setTest = function(v){ this._test = v; return this; };
		If.prototype.body = function(v){ return this._body; }
		If.prototype.setBody = function(v){ this._body = v; return this; };
		If.prototype.alt = function(v){ return this._alt; }
		If.prototype.setAlt = function(v){ this._alt = v; return this; };
		If.prototype.scope = function(v){ return this._scope; }
		If.prototype.setScope = function(v){ this._scope = v; return this; };
		
		If.ternary = function (cond,body,alt){
			// prefer to compile it this way as well
			var obj = new If(cond,new Block([body]),{type: '?'});
			obj.addElse(new Block([alt]));
			return obj;
		};
		
		If.prototype.addElse = function (add){
			// p "add else!",add
			if (this.alt() && (this.alt() instanceof If)) {
				// p 'add to the inner else(!)',add
				this.alt().addElse(add);
			} else {
				this.setAlt(add);
			};
			return this;
		};
		
		
		If.prototype.invert = function (){
			if (this._test instanceof ComparisonOp) {
				return this._test = this._test.invert();
			} else {
				return this._test = new UnaryOp('!',this._test,null);
			};
		};
		
		If.prototype.visit = function (){
			var alt = this.alt();
			
			if (this._scope) { this._scope.visit() };
			if (this.test()) { this.test().traverse() };
			if (this.body()) { this.body().traverse() };
			
			// should skip the scope in alt.
			if (alt) {
				// p "scoping {STACK.scopes:length}"
				STACK.pop(this);
				alt._scope || (alt._scope = new BlockScope(alt));
				alt.traverse();
				STACK.push(this);
			};
			
			// force it as expression?
			if (this._type == '?' && this.isExpressable()) this.toExpression();
			return this;
		};
		
		
		If.prototype.js = function (o){
			var body = this.body();
			// would possibly want to look up / out 
			var brace = {braces: true,indent: true};
			
			var cond = this.test().c({expression: true}); // the condition is always an expression
			
			if (o.isExpression()) {
				var code = body.c(); // (braces: yes)
				code = '(' + code + ')'; // if code.indexOf(',') >= 0
				// is expression!
				if (this.alt()) {
					// console.log "type of ternary {test}"
					// be safe - wrap condition as well
					// ask for parens
					return ("" + cond + " ? " + code + " : (" + (this.alt().c()) + ")");
				} else {
					// again - we need a better way to decide what needs parens
					// maybe better if we rewrite this to an OP('&&'), and put
					// the parens logic there
					// cond should possibly have parens - but where do we decide?
					if (this._tagtree) {
						return ("(" + cond + ") ? " + code + " : void(0)");
					} else {
						return ("(" + cond + ") && " + code);
					};
				};
			} else {
				// if there is only a single item - and it is an expression?
				code = null;
				// if body.count == 1 # dont indent by ourselves?
				
				if ((body instanceof Block) && body.count() == 1 && !(body.first() instanceof LoopFlowStatement)) {
					// p "body to body first {body.first}"
					body = body.first();
				};
				
				// if body.count == 1
				//	p "one item only!"
				//	body = body.first
				
				code = body.c({braces: true}); // (braces: yes)
				
				// don't wrap if it is only a single expression?
				var out = ("" + mark__(this._type) + "if (" + cond + ") ") + code; // ' {' + code + '}' # '{' + code + '}'
				if (this.alt()) { out += (" else " + this.alt().c(this.alt() instanceof If ? ({}) : (brace))) };
				return out;
			};
		};
		
		If.prototype.sourceMapMarker = function (){
			return this;
		};
		
		If.prototype.consume = function (node){
			// p 'assignify if?!'
			// if it is possible, convert into expression
			if (node instanceof TagTree) {
				this._body = this._body.consume(node);
				if (this._alt) { this._alt = this._alt.consume(node) };
				this._tagtree = node;
				return this;
			};
			
			// special case for If created from conditional assign as well?
			// @type == '?' and 
			// ideally we dont really want to make any expression like this by default
			var isRet = (node instanceof Return);
			
			// might have been forced to expression already
			// if it was originally a ternary - why not
			if (this._expression || ((!(isRet) || this._type == '?') && this.isExpressable())) {
				this.toExpression(); // mark as expression(!) - is this needed?
				return If.__super__.consume.call(this,node);
			} else {
				this._body = this._body.consume(node);
				if (this._alt) { this._alt = this._alt.consume(node) };
			};
			return this;
		};
		
		
		If.prototype.isExpressable = function (){
			// process:stdout.write 'x'
			var exp = this.body().isExpressable() && (!(this.alt()) || this.alt().isExpressable());
			return exp;
		};
		
		
		
		function Loop(options){
			if(options === undefined) options = {};
			this._traversed = false;
			this._options = options;
			this._body = null;
			this;
		};
		
		
		subclass$(Loop,Statement);
		exports.Loop = Loop; // export class 
		Loop.prototype.scope = function(v){ return this._scope; }
		Loop.prototype.setScope = function(v){ this._scope = v; return this; };
		Loop.prototype.options = function(v){ return this._options; }
		Loop.prototype.setOptions = function(v){ this._options = v; return this; };
		Loop.prototype.body = function(v){ return this._body; }
		Loop.prototype.setBody = function(v){ this._body = v; return this; };
		Loop.prototype.catcher = function(v){ return this._catcher; }
		Loop.prototype.setCatcher = function(v){ this._catcher = v; return this; };
		
		
		Loop.prototype.set = function (obj){
			// p "configure for!"
			this._options || (this._options = {});
			var keys = Object.keys(obj);
			for (var i = 0, ary = iter$(keys), len = ary.length, k; i < len; i++) {
				k = ary[i];
				this._options[k] = obj[k];
			};
			return this;
		};
		
		
		Loop.prototype.addBody = function (body){
			this.setBody(blk__(body));
			return this;
		};
		
		
		Loop.prototype.c = function (o){
			
			var s = this.stack();
			var curr = s.current();
			// p "Loop.c - {isExpressable} {stack} {stack.isExpression}"
			// p "stack is expression? {o} {isExpression}"
			
			
			
			if (this.stack().isExpression() || this.isExpression()) {
				// p "the stack is an expression for loop now(!)"
				// what the inner one should not be an expression though?
				// this will resut in an infinite loop, no?!?
				var ast = CALL(FN([],[this]),[]);
				return ast.c(o);
			} else if ((this.stack().current() instanceof Block) || ((s.up() instanceof Block) && s.current()._consumer == this)) {
				
				// p "what is the current stack of loop? {stack.current}"
				return Loop.__super__.c.call(this,o);
			} else {
				// p "Should never get here?!?"
				ast = CALL(FN([],[this]),[]);
				return ast.c(o);
				// need to wrap in function
			};
		};
		
		
		
		function While(test,opts){
			this._traversed = false;
			this._test = test;
			this._options = opts || {};
			this._scope = new WhileScope(this);
			// set(opts) if opts
			// p "invert test for while? {@test}"
			if (this.option('invert')) {
				// "invert test for while {@test}"
				this._test = test.invert();
			};
			// invert the test
		};
		
		
		subclass$(While,Loop);
		exports.While = While; // export class 
		While.prototype.test = function(v){ return this._test; }
		While.prototype.setTest = function(v){ this._test = v; return this; };
		
		
		While.prototype.visit = function (){
			this.scope().visit();
			if (this.test()) { this.test().traverse() };
			if (this.body()) { return this.body().traverse() };
		};
		
		
		// TODO BUG -- when we declare a var like: while var y = ...
		// the variable will be declared in the WhileScope which never
		// force-declares the inner variables in the scope
		
		While.prototype.consume = function (node){
			// p "While.consume {node}".cyan
			// This is never expressable, but at some point
			// we might want to wrap it in a function (like CS)
			if (this.isExpressable()) { return While.__super__.consume.apply(this,arguments) };
			
			if (node instanceof TagTree) {
				// WARN this is a hack to allow references coming through the wrapping scope 
				// will result in unneeded self-declarations and other oddities
				this.scope().context().reference();
				return CALL(FN([],[this]),[]);
			};
			
			var reuse = false;
			// WARN Optimization - might have untended side-effects
			// if we are assigning directly to a local variable, we simply
			// use said variable for the inner res
			// if reuse
			// 	resvar = scope.declare(node.left.node.variable,Arr.new([]),proxy: yes)
			// 	node = null
			// 	p "consume variable declarator!?".cyan
			// else
			// declare the variable we will use to soak up results
			// p "Creating value to store the result of loop".cyan
			// TODO Use a special vartype for this?
			var resvar = this.scope().declare('res',new Arr([]),{system: true});
			// WHAT -- fix this --
			this._catcher = new PushAssign("push",resvar,null); // the value is not preset # what
			this.body().consume(this._catcher); // should still return the same body
			
			// scope vars must not be compiled before this -- this is important
			var ast = new Block([this,resvar.accessor()]); // should be varaccess instead?
			return ast.consume(node);
			// NOTE Here we can find a way to know wheter or not we even need to 
			// return the resvar. Often it will not be needed
			// FIXME what happens if there is no node?!?
		};
		
		
		While.prototype.js = function (o){
			var out = ("while (" + this.test().c({expression: true}) + ")") + this.body().c({braces: true,indent: true}); // .wrap
			
			if (this.scope().vars().count() > 0) {
				// p "while-block has declared variables(!)"
				return [this.scope().vars().c(),out];
			};
			return out;
		};
		
		
		
		// This should define an open scope
		// should rather 
		function For(o){
			if(o === undefined) o = {};
			this._traversed = false;
			this._options = o;
			this._scope = new ForScope(this);
			this._catcher = null;
		};
		
		subclass$(For,Loop);
		exports.For = For; // export class 
		For.prototype.visit = function (){
			this.scope().visit();
			this.options().source.traverse(); // what about awakening the vars here?
			this.declare();
			// should be able to toggle whether to keep the results here already(!)
			
			// add guard to body
			if (this.options().guard) {
				var op = IF(this.options().guard.invert(),Block.wrap([new ContinueStatement("continue")]));
				this.body().unshift(op,BR);
			};
			
			return this.body().traverse();
		};
		
		For.prototype.isBare = function (src){
			return src && src._variable && src._variable._isArray;
		};
		
		For.prototype.declare = function (){
			var o = this.options();
			var scope = this.scope();
			var src = o.source;
			var vars = o.vars = {};
			var oi = o.index;
			
			var bare = this.isBare(src);
			// p "source is a {src} - {bare}"
			// var i = vars:index = oi ? scope.declare(oi,0) : util.counter(0,yes).predeclare
			
			// what about a range where we also include an index?
			if (src instanceof Range) {
				// p "range for-loop"
				
				// really? declare? 
				// are we sure? _really_?
				vars.len = scope.declare('len',src.right()); // util.len(o,yes).predeclare
				// make the scope be the declarator
				// TODO would like to be able to have counter in range as well
				vars.index = scope.register(o.name,scope,{type: 'let',declared: true});
				// p "registered {vars:index:constructor}"
				// p "index-var is declareod?!?! {vars:index.@declared}"
				scope.vars().push(vars.index.assignment(src.left()));
				// scope.declare(options:name,src.left)
				vars.value = vars.index;
			} else {
				// vars:value = scope.declare(options:name,null,let: yes)
				// we are using automatic caching far too much here
				
				// we should simply change how declare works
				var i = vars.index = oi ? (scope.declare(oi,0,{type: 'let'})) : (this.util().counter(0,true,scope).predeclare());
				
				vars.source = bare ? (src) : (this.util().iterable(src,true).predeclare());
				vars.len = this.util().len(vars.source,true).predeclare();
				
				vars.value = scope.declare(o.name,null,{type: 'let'});
				vars.value.addReference(o.name); // adding reference!
				if (oi) { i.addReference(oi) };
			};
			
			return this;
		};
		
		
		For.prototype.consume = function (node){
			
			var receiver;
			if (this.isExpressable()) {
				return For.__super__.consume.apply(this,arguments);
			};
			
			// other cases as well, no?
			if (node instanceof TagTree) {
				this.scope().context().reference();
				var ref = node.root().reference();
				node._loop = this;
				
				// Should not be consumed the same way
				this.body().consume(node);
				node._loop = null;
				var fn = new Lambda([new Param(ref)],[this]);
				fn.scope().wrap(this.scope());
				// TODO Scope of generated lambda should be added into stack for
				// variable naming / resolution
				return CALL(fn,[ref]);
			};
			
			
			if (this._resvar) {
				// p "already have a resvar -- change consume? {node}"
				var ast = new Block([this,BR,this._resvar.accessor()]);
				ast.consume(node);
				return ast;
			};
			
			// if node isa return -- do something else
			
			var resvar = null;
			var reuseable = false; // node isa Assign && node.left.node isa LocalVarAccess
			var assignee = null;
			// might only work for locals?
			if (node instanceof Assign) {
				// p "node isa assign {node} {node.left}"
				if (receiver = node.left()) {
					if (assignee = receiver._variable) {
						// we can only pull the var reference into the scope
						// if we know that the variable is declared in this scope
						reuseable = (receiver instanceof VarReference);
					};
				};
			};
			
			// p "reusable?!?! {node} {node}"
			
			// WARN Optimization - might have untended side-effects
			// if we are assigning directly to a local variable, we simply
			// use said variable for the inner res
			if (reuseable && assignee) {
				// instead of declaring it in the scope - why not declare it outside?
				// it might already exist in the outer scope no?
				// p "reuseable {assignee} {scope} {scope.parent.lookup(assignee)}"
				// assignee.resolve
				// should probably instead alter the assign-node to set value to a blank array
				// resvar = scope.parent.declare(assignee,Arr.new([]),proxy: yes,pos: 0)
				
				// this variable should really not be redeclared inside here at all
				assignee.resolve();
				// resvar = @resvar = scope.declare(assignee,Arr.new([]),proxy: yes)
				
				// dont declare it - simply push an assign into the vardecl of scope
				this.scope().vars().unshift(OP('=',assignee,new Arr([])));
				resvar = this._resvar = assignee;
				
				node._consumer = this;
				node = null;
				
				// p "consume variable declarator!?".cyan
			} else {
				// declare the variable we will use to soak up results
				// p "Creating value to store the result of loop".cyan
				// what about a pool here?
				resvar = this._resvar = this.scope().declare('res',new Arr([]),{system: true});
			};
			
			this._catcher = new PushAssign("push",resvar,null); // the value is not preset
			this.body().consume(this._catcher); // should still return the same body
			
			
			
			if (node) {
				// p "returning new ast where Loop is first"
				ast = new Block([this,BR,resvar.accessor().consume(node)]);
				return ast;
			};
			// var ast = Block.new([self,BR,resvar.accessor])
			// ast.consume(node) if node
			// return ast
			// p "Loop did consume successfully"
			return this;
			
			// this is never an expression (for now -- but still)
			// return ast
		};
		
		
		For.prototype.js = function (o){
			var v_;
			var vars = this.options().vars;
			var i = vars.index;
			var val = vars.value;
			var cond = OP('<',i,vars.len);
			var src = this.options().source;
			
			// p "references for value",val.references:length
			
			var final = this.options().step ? (
				OP('=',i,OP('+',i,this.options().step))
			) : (
				OP('++',i)
			);
			
			// if there are few references to the value - we can drop
			// the actual variable and instead make it proxy through the index
			if (src instanceof Range) {
				if (src.inclusive()) { (cond.setOp(v_ = '<='),v_) };
			} else if (val.refcount() < 3 && val.assignments().length == 0) {
				// p "proxy the value {val.assignments:length}"
				// p "should proxy value-variable instead"
				val.proxy(vars.source,i);
			} else {
				this.body().unshift(OP('=',val,OP('.',vars.source,i)),BR);
				// body.unshift(head)
				// TODO check lengths - intelligently decide whether to brace and indent
			};
			var head = ("" + mark__(this.options().keyword) + "for (" + (this.scope().vars().c()) + "; " + (cond.c()) + "; " + (final.c()) + ") ");
			return head + this.body().c({braces: true,indent: true}); // .wrap
		};
		
		
		For.prototype.head = function (){
			var vars = this.options().vars;
			return OP('=',vars.value,OP('.',vars.source,vars.index));
		};
		
		
		
		function ForIn(){ return For.apply(this,arguments) };
		
		subclass$(ForIn,For);
		exports.ForIn = ForIn; // export class 
		
		
		
		
		function ForOf(){ return For.apply(this,arguments) };
		
		subclass$(ForOf,For);
		exports.ForOf = ForOf; // export class 
		ForOf.prototype.declare = function (){
			var o = this.options();
			var vars = o.vars = {};
			
			// see if 
			
			// p "ForOf source isa {o:source}"
			
			// if o:source is a variable -- refer directly # variable? is this the issue?
			// p scope.@varmap['o'], scope.parent.@varmap['o']
			
			var src = vars.source = o.source._variable || this.scope().declare('o',o.source,{system: true,type: 'let'});
			if (o.index) { var v = vars.value = this.scope().declare(o.index,null,{let: true}) };
			
			// p "ForOf o:index {o:index} o:name {o:name}"
			// if o:index
			
			// possibly proxy the index-variable?
			
			if (o.own) {
				// var i = vars:index = scope.declare('i',0,system: true, type: 'let') # mark as a counter?
				var i = vars.index = this.util().counter(0,true,this.scope()).predeclare();
				// systemvariable -- should not really be added to the map
				var keys = vars.keys = this.scope().declare('keys',Util.keys(src.accessor()),{system: true,type: 'let'}); // the outer one should resolve first
				var l = vars.len = this.scope().declare('l',Util.len(keys.accessor()),{system: true,type: 'let'});
				var k = vars.key = this.scope().register(o.name,o.name,{type: 'let'}); // scope.declare(o:name,null,system: yes)
			} else {
				// we set the var -- why even declare it
				// no need to declare -- it will declare itself in the loop - no?
				k = vars.key = this.scope().register(o.name,o.name,{type: 'let'});
			};
			
			// TODO use util - why add references already? Ah -- this is for the highlighting
			if (v && o.index) { v.addReference(o.index) };
			if (k && o.name) { k.addReference(o.name) };
			
			return this;
		};
		
		ForOf.prototype.js = function (o){
			var vars = this.options().vars;
			
			var o = vars.source;
			var k = vars.key;
			var v = vars.value;
			var i = vars.index;
			
			
			if (v) {
				// set value as proxy of object[key]
				// possibly make it a ref? what is happening?
				v.refcount() < 3 ? (v.proxy(o,k)) : (this.body().unshift(OP('=',v,OP('.',o,k))));
			};
			
			if (this.options().own) {
				
				if (k.refcount() < 3) { // should probably adjust these
					k.proxy(vars.keys,i);
				} else {
					this.body().unshift(OP('=',k,OP('.',vars.keys,i)));
				};
				
				var head = ("" + mark__(this.options().keyword) + "for (" + (this.scope().vars().c()) + "; " + (OP('<',i,vars.len).c()) + "; " + (OP('++',i).c()) + ")");
				return head + this.body().c({indent: true,braces: true}); // .wrap
			};
			
			var code = this.body().c({braces: true,indent: true});
			// it is really important that this is a treated as a statement
			return this.scope().vars().c() + (";\n" + mark__(this.options().keyword) + "for (var " + (k.c()) + " in " + (o.c()) + ")") + code;
		};
		
		ForOf.prototype.head = function (){
			var v = this.options().vars;
			
			return [
				OP('=',v.key,OP('.',v.keys,v.index)),
				(v.value) && (OP('=',v.value,OP('.',v.source,v.key)))
			];
		};
		
		// NO NEED?
		function Begin(body){
			this._nodes = blk__(body).nodes();
		};
		
		
		subclass$(Begin,Block);
		exports.Begin = Begin; // export class 
		Begin.prototype.shouldParenthesize = function (){
			return this.isExpression();
		};
		
		
		
		function Switch(a,b,c){
			this._traversed = false;
			this._source = a;
			this._cases = b;
			this._fallback = c;
		};
		
		
		subclass$(Switch,ControlFlowStatement);
		exports.Switch = Switch; // export class 
		Switch.prototype.source = function(v){ return this._source; }
		Switch.prototype.setSource = function(v){ this._source = v; return this; };
		Switch.prototype.cases = function(v){ return this._cases; }
		Switch.prototype.setCases = function(v){ this._cases = v; return this; };
		Switch.prototype.fallback = function(v){ return this._fallback; }
		Switch.prototype.setFallback = function(v){ this._fallback = v; return this; };
		
		
		Switch.prototype.visit = function (){
			for (var i = 0, ary = iter$(this.cases()), len = ary.length; i < len; i++) {
				ary[i].traverse();
			};
			if (this.fallback()) { this.fallback().visit() };
			if (this.source()) { this.source().visit() };
			return;
		};
		
		
		Switch.prototype.consume = function (node){
			// TODO work inside tags (like loops)
			this._cases = this._cases.map(function(item) { return item.consume(node); });
			if (this._fallback) { this._fallback = this._fallback.consume(node) };
			return this;
		};
		
		Switch.prototype.c = function (o){
			if (this.stack().isExpression() || this.isExpression()) {
				var ast = CALL(FN([],[this]),[]);
				return ast.c(o);
			};
			
			return Switch.__super__.c.call(this,o);
		};
		
		
		Switch.prototype.js = function (o){
			var body = [];
			
			for (var i = 0, ary = iter$(this.cases()), len = ary.length, part; i < len; i++) {
				part = ary[i];
				part.autobreak();
				body.push(part);
			};
			
			if (this.fallback()) {
				body.push("default:\n" + this.fallback().c({indent: true}));
			};
			
			return ("switch (" + (this.source().c()) + ") ") + helpers.bracketize(cary__(body).join("\n"),true);
		};
		
		
		
		function SwitchCase(test,body){
			this._traversed = false;
			this._test = test;
			this._body = blk__(body);
		};
		
		subclass$(SwitchCase,ControlFlowStatement);
		exports.SwitchCase = SwitchCase; // export class 
		SwitchCase.prototype.test = function(v){ return this._test; }
		SwitchCase.prototype.setTest = function(v){ this._test = v; return this; };
		SwitchCase.prototype.body = function(v){ return this._body; }
		SwitchCase.prototype.setBody = function(v){ this._body = v; return this; };
		
		
		SwitchCase.prototype.visit = function (){
			return this.body().traverse();
		};
		
		
		SwitchCase.prototype.consume = function (node){
			this.body().consume(node);
			return this;
		};
		
		
		SwitchCase.prototype.autobreak = function (){
			if (!((this.body().last() instanceof BreakStatement))) { this.body().push(new BreakStatement()) };
			return this;
		};
		
		
		SwitchCase.prototype.js = function (o){
			if (!((this._test instanceof Array))) { this._test = [this._test] };
			var cases = this._test.map(function(item) { return ("case " + (item.c()) + ":"); });
			return cases.join("\n") + this.body().c({indent: true}); // .indent
		};
		
		
		
		function Try(body,c,f){
			this._traversed = false;
			this._body = blk__(body);
			this._catch = c;
			this._finally = f;
		};
		
		
		subclass$(Try,ControlFlowStatement);
		exports.Try = Try; // export class 
		Try.prototype.body = function(v){ return this._body; }
		Try.prototype.setBody = function(v){ this._body = v; return this; };
		// prop ncatch
		// prop nfinally
		
		Try.prototype.consume = function (node){
			this._body = this._body.consume(node);
			if (this._catch) { this._catch = this._catch.consume(node) };
			if (this._finally) { this._finally = this._finally.consume(node) };
			return this;
		};
		
		
		Try.prototype.visit = function (){
			this._body.traverse();
			if (this._catch) { this._catch.traverse() };
			if (this._finally) { return this._finally.traverse() };
			// no blocks - add an empty catch
		};
		
		
		Try.prototype.js = function (o){
			var out = "try " + this.body().c({braces: true,indent: true});
			if (this._catch) { out += " " + this._catch.c() };
			if (this._finally) { out += " " + this._finally.c() };
			
			if (!(this._catch || this._finally)) {
				out += (" catch (e) \{ \}");
			};
			out += ";";
			return out;
		};
		
		
		
		function Catch(body,varname){
			this._traversed = false;
			this._body = blk__(body || []);
			this._scope = new CatchScope(this);
			this._varname = varname;
			this;
		};
		
		subclass$(Catch,ControlFlowStatement);
		exports.Catch = Catch; // export class 
		Catch.prototype.body = function(v){ return this._body; }
		Catch.prototype.setBody = function(v){ this._body = v; return this; };
		
		Catch.prototype.consume = function (node){
			this._body = this._body.consume(node);
			return this;
		};
		
		
		Catch.prototype.visit = function (){
			this._scope.visit();
			this._variable = this._scope.register(this._varname,this,{pool: 'catchvar'});
			return this._body.traverse();
		};
		
		
		Catch.prototype.js = function (o){
			// only indent if indented by default?
			return ("catch (" + (this._variable.c()) + ") ") + this._body.c({braces: true,indent: true});
		};
		
		
		// repeating myself.. don't deal with it until we move to compact tuple-args
		// for all astnodes
		
		
		function Finally(body){
			this._traversed = false;
			this._body = blk__(body || []);
		};
		
		
		subclass$(Finally,ControlFlowStatement);
		exports.Finally = Finally; // export class 
		Finally.prototype.visit = function (){
			return this._body.traverse();
		};
		
		
		Finally.prototype.consume = function (node){
			// swallow silently
			return this;
		};
		
		
		Finally.prototype.js = function (o){
			return "finally " + this._body.c({braces: true,indent: true});
		};
		
		
		// RANGE
		
		function Range(){ return Op.apply(this,arguments) };
		
		subclass$(Range,Op);
		exports.Range = Range; // export class 
		Range.prototype.inclusive = function (){
			return this.op() == '..';
		};
		
		Range.prototype.c = function (){
			return "range";
		};
		
		
		function Splat(){ return ValueNode.apply(this,arguments) };
		
		subclass$(Splat,ValueNode);
		exports.Splat = Splat; // export class 
		Splat.prototype.js = function (o){
			var par = this.stack().parent();
			if ((par instanceof ArgList) || (par instanceof Arr)) {
				return ("[].slice.call(" + (this.value().c()) + ")");
			} else {
				this.p(("what is the parent? " + par));
				return "SPLAT";
			};
		};
		
		Splat.prototype.node = function (){
			return this.value();
		};
		
		
		
		
		
		// TAGS
		
		
		TAG_TYPES = {};
		TAG_ATTRS = {};
		
		
		TAG_TYPES.HTML = "a abbr address area article aside audio b base bdi bdo big blockquote body br button canvas caption cite code col colgroup data datalist dd del details dfn div dl dt em embed fieldset figcaption figure footer form h1 h2 h3 h4 h5 h6 head header hr html i iframe img input ins kbd keygen label legend li link main map mark menu menuitem meta meter nav noscript object ol optgroup option output p param pre progress q rp rt ruby s samp script section select small source span strong style sub summary sup table tbody td textarea tfoot th thead time title tr track u ul var video wbr".split(" ");
		
		TAG_TYPES.SVG = "circle defs ellipse g line linearGradient mask path pattern polygon polyline radialGradient rect stop svg text tspan".split(" ");
		
		TAG_ATTRS.HTML = "accept accessKey action allowFullScreen allowTransparency alt async autoComplete autoFocus autoPlay cellPadding cellSpacing charSet checked className cols colSpan content contentEditable contextMenu controls coords crossOrigin data dateTime defer dir disabled download draggable encType form formNoValidate frameBorder height hidden href hrefLang htmlFor httpEquiv icon id label lang list loop max maxLength mediaGroup method min multiple muted name noValidate pattern placeholder poster preload radioGroup readOnly rel required role rows rowSpan sandbox scope scrollLeft scrolling scrollTop seamless selected shape size span spellCheck src srcDoc srcSet start step style tabIndex target title type useMap value width wmode";
		
		TAG_ATTRS.SVG = "cx cy d dx dy fill fillOpacity fontFamily fontSize fx fy gradientTransform gradientUnits markerEnd markerMid markerStart offset opacity patternContentUnits patternUnits points preserveAspectRatio r rx ry spreadMethod stopColor stopOpacity stroke strokeDasharray strokeLinecap strokeOpacity strokeWidth textAnchor transform version viewBox x1 x2 x y1 y2 y";
		
		
		function TagDesc(){
			this.p('TagDesc!!!',arguments);
			this;
		};
		
		subclass$(TagDesc,Node);
		exports.TagDesc = TagDesc; // export class 
		TagDesc.prototype.classes = function (){
			this.p('TagDescClasses',arguments);
			return this;
		};
		
		function Tag(o){
			if(o === undefined) o = {};
			this._traversed = false;
			this._parts = [];
			o.classes || (o.classes = []);
			o.attributes || (o.attributes = []);
			o.classes || (o.classes = []);
			this._options = o;
			this._reference = null;
			this._object = null;
			this._tree = null;
			this;
		};
		
		subclass$(Tag,Node);
		exports.Tag = Tag; // export class 
		Tag.prototype.parts = function(v){ return this._parts; }
		Tag.prototype.setParts = function(v){ this._parts = v; return this; };
		Tag.prototype.object = function(v){ return this._object; }
		Tag.prototype.setObject = function(v){ this._object = v; return this; };
		Tag.prototype.reactive = function(v){ return this._reactive; }
		Tag.prototype.setReactive = function(v){ this._reactive = v; return this; };
		Tag.prototype.parent = function(v){ return this._parent; }
		Tag.prototype.setParent = function(v){ this._parent = v; return this; };
		Tag.prototype.tree = function(v){ return this._tree; }
		Tag.prototype.setTree = function(v){ this._tree = v; return this; };
		
		Tag.prototype.set = function (obj){
			for (var v, i = 0, keys = Object.keys(obj), l = keys.length; i < l; i++){
				k = keys[i];v = obj[k];if (k == 'attributes') {
					// p "attributs!"
					for (var j = 0, ary = iter$(v), len = ary.length; j < len; j++) {
						this.addAttribute(ary[j]);
					};
					continue;
				};
				
				this._options[k] = v;
			};
			return this;
		};
		
		Tag.prototype.addClass = function (node){
			if (!((node instanceof TagFlag))) {
				node = new TagFlag(node);
			};
			this._options.classes.push(node);
			this._parts.push(node);
			
			// p "add class!!!"
			return this;
		};
		
		Tag.prototype.addIndex = function (node){
			this._parts.push(node);
			this._object = node;
			return this;
		};
		
		Tag.prototype.addSymbol = function (node){
			// p "addSymbol to the tag",node
			if (this._parts.length == 0) {
				this._parts.push(node);
				this._options.ns = node;
			};
			return this;
		};
		
		
		Tag.prototype.addAttribute = function (atr){
			// p "add attribute!!!", key, value
			this._parts.push(atr); // what?
			this._options.attributes.push(atr);
			return this;
		};
		
		Tag.prototype.enclosing = function (){
			return this._options.close && this._options.close.value();
		};
		
		Tag.prototype.type = function (){
			return this._options.type || 'div';
		};
		
		Tag.prototype.consume = function (node){
			var o = this._options;
			
			
			if (node instanceof TagTree) {
				// p "tag consume tagtree? {node.reactive}"
				this.setParent(node.root());
				// o:treeRef = node.nextCacheKey
				
				if (node._loop) {
					// alwatys make items in loop reactive
					this.setReactive(node.reactive() || this.option('key'));
					this.option('loop',node._loop);
					
					if (this.option('ivar')) {
						this.warn(("Tag inside loop can not have a static reference " + this.option('ivar')),{type: 'error',token: this.option('ivar').value()});
					};
				} else {
					this.setReactive(node.reactive() || !(!this.option('ivar')));
				};
				
				return this;
			};
			
			return Tag.__super__.consume.apply(this,arguments);
		};
		
		
		Tag.prototype.visit = function (){
			
			var o = this._options;
			
			if (o.ivar || o.key) {
				this.setReactive(true);
			};
			
			var typ = this.enclosing();
			
			// look for outer tag here?
			
			if (typ == '->' || typ == '=>') {
				// console.log "tag is template?!? {typ}"
				this._tree = new TagTree(this,o.body,{root: this,reactive: this.reactive()});
				o.body = new TagFragmentFunc([],Block.wrap([this._tree]));
				// console.log "made o body a function?"
			};
			
			if (o.key) { o.key.traverse() };
			
			if (o.body) {
				o.body.traverse();
			};
			
			// id should also be a regular part
			
			if (o.id) { o.id.traverse() };
			
			
			for (var i = 0, ary = iter$(this._parts), len = ary.length; i < len; i++) {
				ary[i].traverse();
			};
			
			// for atr in @options:attributes
			// 	atr.traverse
			
			return this;
		};
		
		Tag.prototype.reference = function (){
			return this._reference || (this._reference = this.scope__().closure().temporary(this,{pool: 'tag'}).resolve());
		};
		
		// should this not happen in js?
		// should this not happen in js?
		Tag.prototype.js = function (o){
			// p JSON.stringify(@options)
			// var attrs = TagAttributes.new(o:attributes)
			// p "got here?"
			var body;
			var o = this._options;
			var a = {};
			var enc = this.enclosing();
			
			var setup = [];
			var calls = [];
			var statics = [];
			
			var scope = this.scope__();
			var commit = "end";
			var content = o.body;
			
			var isSelf = (this.type() instanceof Self);
			var bodySetter = isSelf ? ("setChildren") : ("setContent");
			
			// should not cache statics if the node itself is not cached
			// that would only mangle the order in which we set the properties
			var cacheStatics = true;
			
			for (var i = 0, ary = iter$(o.attributes), len = ary.length, atr; i < len; i++) {
				atr = ary[i];
				a[atr.key()] = atr.value(); // .populate(obj)
			};
			
			var quote = function(str) { return helpers.singlequote(str); };
			var id = o.id instanceof Node ? (o.id.c()) : ((o.id && quote(o.id.c())));
			var tree = this._tree || null;
			var parent = this.parent();
			// var parTree = parent and parent.tree
			
			
			//  "scope is", !!scope
			// p "type is {type}"
			var out = isSelf ? (
				commit = "synced",
				// p "got here"
				// setting correct context directly
				this.setReactive(true),
				this._reference = scope.context(),
				scope.context().c()
			) : (
				("" + mark__(o.open) + (scope.tagContextPath()) + "." + (this.type().spawner()) + "()")
			);
			
			if (o.id) {
				statics.push((".setId(" + quote(o.id) + ")"));
			};
			// this is reactive if it has an ivar
			if (o.ivar) {
				this.setReactive(true);
				statics.push((".setRef(" + quote(o.ivar.name()) + "," + (scope.context().c()) + ")"));
			};
			
			if (o.body instanceof Func) {
				// console.log "o:body isa function!"
				bodySetter = "setTemplate";
			} else if (o.body) {
				if ((o.body instanceof ArgList) && o.body.count() == 1 && o.body.first().isString()) {
					bodySetter = "setText";
				} else {
					// would probably be better to convert to a tagtree during the initial visit
					tree = new TagTree(this,o.body,{root: this,reactive: this.reactive()});
					content = tree;
					this.setTree(tree);
				};
			};
			
			if (tree) {
				// this is the point where we traverse the inner nodes with our tree
				// should rather happen in visit - long before.
				tree.resolve();
			};
			
			for (var i = 0, ary = iter$(this._parts), len = ary.length, part; i < len; i++) {
				part = ary[i];
				var pjs;
				var pcache = false;
				
				if (part instanceof TagAttr) {
					var akey = String(part.key());
					var aval = part.value();
					// p "part value {aval} {aval.isPrimitive(yes)}"
					
					// the attr should compile itself instead -- really
					pcache = aval.isPrimitive();
					
					if (akey[0] == '.') { // should check in a better way
						pcache = false;
						pjs = (".flag(" + quote(akey.substr(1)) + "," + (aval.c()) + ")");
					} else if (akey[0] == ':') {
						// need to analyze whether this is static or not
						pjs = (".setHandler(" + quote(akey.substr(1)) + "," + (aval.c()) + "," + (scope.context().c()) + ")");
					} else if (akey.substr(0,5) == 'data-') {
						pjs = (".dataset('" + akey.slice(5) + "'," + (aval.c()) + ")");
					} else {
						pjs = ("." + mark__(part.key()) + helpers.setterSym(akey) + "(" + (aval.c()) + ")");
					};
				} else if (part instanceof TagFlag) {
					pjs = part.c();
					pcache = true;
				};
				
				if (pjs) {
					cacheStatics && pcache ? (statics.push(pjs)) : (calls.push(pjs));
				};
			};
			
			
			
			if (this.object()) {
				calls.push((".setObject(" + (this.object().c()) + ")"));
			};
			
			// p "tagtree is static? {tree.static}"
			
			// we need to trigger our own reference before the body does
			// but we do not need a reference if we have no body (no nodes will refer it)
			if (this.reactive() && tree) { // and tree.hasTags
				this.reference();
			};
			
			if (this.reactive() && parent && parent.tree()) {
				o.treeRef = parent.tree().nextCacheKey(this);
			};
			
			if (body = content && content.c({expression: true})) { // force it to be an expression, no?
				var typ = 0;
				
				if (tree) {
					if (tree.static()) {
						typ = 2;
					} else if (this.reactive() || tree.reactive()) {
						if (!tree.single() || (tree.single() instanceof If)) {
							typ = 1;
						} else {
							typ = 3;
						};
					};
				};
				
				
				if (bodySetter == 'setChildren' || bodySetter == 'setContent') {
					calls.push(("." + bodySetter + "(" + body + "," + typ + ")"));
				} else {
					calls.push(("." + bodySetter + "(" + body + ")"));
				};
				
				// out += ".body({body})"
			};
			
			// if o:attributes:length # or -- always?
			// adds lots of extra calls - but okay for now
			calls.push(("." + commit + "()"));
			
			if (statics.length) {
				out = out + statics.join("");
			};
			
			
			if ((o.ivar || o.key || this.reactive()) && !(this.type() instanceof Self)) {
				// if this is an ivar, we should set the reference relative
				// to the outer reference, or possibly right on context?
				var ctx,key;
				var partree = parent && parent.tree();
				// ctx = !o:ivar and par and par.reference or scope.context
				// key = o:ivar or tree and tree.nextCacheKey
				
				if (o.key) {
					// closest tag
					// TODO if the dynamic key starts with a static string we should
					// just prepend _ to the string instead of wrapping in OP
					ctx = parent && parent.reference();
					key = OP('+',new Str("'_'"),o.key);
				} else if (o.ivar) {
					ctx = scope.context();
					key = o.ivar;
				} else {
					ctx = parent && parent.reference();
					// ctx = partree.cacher
					key = o.treeRef || partree && partree.nextCacheKey();
					// key = tree and tree.nextCacheKey
					if (o.loop) {
						var idx = o.loop.option('vars').index;
						key = OP('+',"'" + key + "'",idx);
					};
				};
				
				
				
				// need the context -- might be better to rewrite it for real?
				// parse the whole thing into calls etc
				var acc = OP('.',ctx,key).c();
				
				if (this._reference) {
					out = ("(" + (this.reference().c()) + " = " + acc + "=" + acc + " || " + out + ")");
				} else {
					out = ("(" + acc + " = " + acc + " || " + out + ")");
				};
			};
			
			return out + calls.join("");
		};
		
		// This is a helper-node
		// Should probably use the same type of listnode everywhere - and simply flag the type as TagTree instead
		function TagTree(owner,list,options){
			if(options === undefined) options = {};
			this._owner = owner;
			this._nodes = this.load(list);
			this._options = options;
			this._conditions = [];
			this._blocks = [this];
			this._counter = 0;
			this;
		};
		
		subclass$(TagTree,ListNode);
		exports.TagTree = TagTree; // export class 
		TagTree.prototype.counter = function(v){ return this._counter; }
		TagTree.prototype.setCounter = function(v){ this._counter = v; return this; };
		TagTree.prototype.conditions = function(v){ return this._conditions; }
		TagTree.prototype.setConditions = function(v){ this._conditions = v; return this; };
		TagTree.prototype.blocks = function(v){ return this._blocks; }
		TagTree.prototype.setBlocks = function(v){ this._blocks = v; return this; };
		TagTree.prototype.cacher = function(v){ return this._cacher; }
		TagTree.prototype.setCacher = function(v){ this._cacher = v; return this; };
		
		TagTree.prototype.parent = function (){
			return this._parent || (this._parent = this._owner.parent());
		};
		
		TagTree.prototype.nextCacheKey = function (){
			var root = this._owner;
			
			// if we want to cache everything on root
			var num = ++this._counter;
			var base = "A".charCodeAt(0);
			var str = "";
			
			while (true){
				num -= 1;
				str = String.fromCharCode(base + (num % 26)) + str;
				num = Math.floor(num / 26);
				if (num <= 0) { break; };
			};
			
			str = (this._owner.type() instanceof Self ? ("$") : ("$$")) + str.toLowerCase();
			return str;
			return num;
		};
		
		TagTree.prototype.load = function (list){
			if (list instanceof ListNode) {
				// p "is a list node!! {list.count}"
				// we still want the indentation if we are not in a template
				// or, rather - we want the block to get the indentation - not the tree
				this._indentation || (this._indentation = list._indentation); // if list.count > 1
				return list.nodes();
			} else {
				return compact__(list instanceof Array ? (list) : ([list]));
			};
		};
		
		TagTree.prototype.root = function (){
			return this.option('root');
		};
		
		TagTree.prototype.reactive = function (){
			return this.option('reactive');
		};
		
		TagTree.prototype.resolve = function (){
			var self = this;
			this.remap(function(c) { return c.consume(self); });
			return self;
		};
		
		TagTree.prototype.static = function (){
			// every real node
			return this._static == null ? (this._static = this.every(function(c) { return (c instanceof Tag) || (c instanceof Str) || (c instanceof Meta); })) : (this._static);
		};
		
		TagTree.prototype.single = function (){
			return this._single == null ? (this._single = (this.realCount() == 1 ? (this.last()) : (false))) : (this._single);
		};
		
		TagTree.prototype.hasTags = function (){
			return this.some(function(c) { return c instanceof Tag; });
		};
		
		TagTree.prototype.c = function (o){
			// FIXME TEST what about comments???
			var single = this.single();
			
			// no indentation if this should return
			if (single && (STACK.current() instanceof Return)) {
				this._indentation = null;
			};
			
			var out = TagTree.__super__.c.call(this,o);
			
			if (!(single) || (single instanceof If)) {
				return ("[" + out + "]");
			} else {
				return out;
			};
		};
		
		function TagWrapper(){ return ValueNode.apply(this,arguments) };
		
		subclass$(TagWrapper,ValueNode);
		exports.TagWrapper = TagWrapper; // export class 
		TagWrapper.prototype.visit = function (){
			if (this.value() instanceof Array) {
				this.value().map(function(v) { return v.traverse(); });
			} else {
				this.value().traverse();
			};
			return this;
		};
		
		TagWrapper.prototype.c = function (){
			return ("tag$wrap(" + this.value().c({expression: true}) + ")");
		};
		
		
		function TagAttributes(){ return ListNode.apply(this,arguments) };
		
		subclass$(TagAttributes,ListNode);
		exports.TagAttributes = TagAttributes; // export class 
		TagAttributes.prototype.get = function (name){
			for (var i = 0, ary = iter$(this.nodes()), len = ary.length, node, res = []; i < len; i++) {
				node = ary[i];
				if (node.key() == name) { return node };
			};
			return res;
		};
		
		
		function TagAttr(k,v){
			// p "init TagAttribute", $0
			this._traversed = false;
			this._key = k;
			this._value = v;
		};
		
		subclass$(TagAttr,Node);
		exports.TagAttr = TagAttr; // export class 
		TagAttr.prototype.key = function(v){ return this._key; }
		TagAttr.prototype.setKey = function(v){ this._key = v; return this; };
		TagAttr.prototype.value = function(v){ return this._value; }
		TagAttr.prototype.setValue = function(v){ this._value = v; return this; };
		
		TagAttr.prototype.visit = function (){
			if (this.value()) { this.value().traverse() };
			return this;
		};
		
		TagAttr.prototype.populate = function (obj){
			obj.add(this.key(),this.value());
			return this;
		};
		
		TagAttr.prototype.c = function (){
			return "attribute";
		};
		
		
		function TagFlag(value){
			this._traversed = false;
			this._value = value;
			this;
		};
		
		subclass$(TagFlag,Node);
		exports.TagFlag = TagFlag; // export class 
		TagFlag.prototype.value = function(v){ return this._value; }
		TagFlag.prototype.setValue = function(v){ this._value = v; return this; };
		TagFlag.prototype.toggler = function(v){ return this._toggler; }
		TagFlag.prototype.setToggler = function(v){ this._toggler = v; return this; };
		
		TagFlag.prototype.visit = function (){
			if (!((typeof this._value=='string'||this._value instanceof String))) {
				this._value.traverse();
			};
			return this;
		};
		
		TagFlag.prototype.c = function (){
			if (this.value() instanceof Node) {
				return (".flag(" + (this.value().c()) + ")");
			} else {
				return (".flag(" + helpers.singlequote(this.value()) + ")");
			};
		};
		
		
		
		
		
		
		// SELECTORS
		
		
		function Selector(list,options){
			this._nodes = list || [];
			this._options = options;
		};
		
		subclass$(Selector,ListNode);
		exports.Selector = Selector; // export class 
		Selector.prototype.add = function (part,typ){
			// p "select add!",part,typ
			// mark if special?
			this.push(part);
			return this;
		};
		
		Selector.prototype.group = function (){
			// console.log "grouped!"
			// for now we simply add a comma
			// how would this work for dst?
			this._nodes.push(new SelectorGroup(","));
			return this;
		};
		
		Selector.prototype.query = function (){
			var str = "";
			var ary = [];
			
			for (var i = 0, items = iter$(this.nodes()), len = items.length; i < len; i++) {
				var val = items[i].c();
				if ((typeof val=='string'||val instanceof String)) {
					str = ("" + str + val);
				};
			};
			
			return ("'" + str + "'");
		};
		
		
		Selector.prototype.js = function (o){
			var typ = this.option('type');
			var q = c__(this.query());
			
			if (typ == '%') {
				return ("q$(" + q + "," + o.scope().context().c({explicit: true}) + ")"); // explicit context
			} else if (typ == '%%') {
				return ("q$$(" + q + "," + o.scope().context().c({explicit: true}) + ")");
			} else {
				return ("q" + typ + "(" + q + ")");
			};
			
			// return "{typ} {scoped} - {all}"
		};
		
		
		function SelectorPart(){ return ValueNode.apply(this,arguments) };
		
		subclass$(SelectorPart,ValueNode);
		exports.SelectorPart = SelectorPart; // export class 
		SelectorPart.prototype.c = function (){
			return c__(this._value);
			// "{value.c}"
		};
		
		function SelectorGroup(){ return SelectorPart.apply(this,arguments) };
		
		subclass$(SelectorGroup,SelectorPart);
		exports.SelectorGroup = SelectorGroup; // export class 
		SelectorGroup.prototype.c = function (){
			return ",";
		};
		
		function SelectorType(){ return SelectorPart.apply(this,arguments) };
		
		subclass$(SelectorType,SelectorPart);
		exports.SelectorType = SelectorType; // export class 
		SelectorType.prototype.c = function (){
			// support
			// p "selectortype {value}"
			// var out = value.c
			var name = this.value().name();
			
			// at least be very conservative about which tags we
			// can drop the tag for?
			// out in TAG_TYPES.HTML ? 
			return idx$(name,TAG_TYPES.HTML) >= 0 ? (name) : (this.value().sel());
		};
		
		
		function SelectorUniversal(){ return SelectorPart.apply(this,arguments) };
		
		subclass$(SelectorUniversal,SelectorPart);
		exports.SelectorUniversal = SelectorUniversal; // export class 
		
		
		function SelectorNamespace(){ return SelectorPart.apply(this,arguments) };
		
		subclass$(SelectorNamespace,SelectorPart);
		exports.SelectorNamespace = SelectorNamespace; // export class 
		
		
		function SelectorClass(){ return SelectorPart.apply(this,arguments) };
		
		subclass$(SelectorClass,SelectorPart);
		exports.SelectorClass = SelectorClass; // export class 
		SelectorClass.prototype.c = function (){
			if (this._value instanceof Node) {
				return (".'+" + (this._value.c()) + "+'");
			} else {
				return ("." + c__(this._value));
			};
		};
		
		function SelectorId(){ return SelectorPart.apply(this,arguments) };
		
		subclass$(SelectorId,SelectorPart);
		exports.SelectorId = SelectorId; // export class 
		SelectorId.prototype.c = function (){
			if (this._value instanceof Node) {
				return ("#'+" + (this._value.c()) + "+'");
			} else {
				return ("#" + c__(this._value));
			};
		};
		
		function SelectorCombinator(){ return SelectorPart.apply(this,arguments) };
		
		subclass$(SelectorCombinator,SelectorPart);
		exports.SelectorCombinator = SelectorCombinator; // export class 
		SelectorCombinator.prototype.c = function (){
			return ("" + c__(this._value));
		};
		
		function SelectorPseudoClass(){ return SelectorPart.apply(this,arguments) };
		
		subclass$(SelectorPseudoClass,SelectorPart);
		exports.SelectorPseudoClass = SelectorPseudoClass; // export class 
		
		
		function SelectorAttribute(left,op,right){
			this._left = left;
			this._op = op;
			this._right = this._value = right;
		};
		
		subclass$(SelectorAttribute,SelectorPart);
		exports.SelectorAttribute = SelectorAttribute; // export class 
		SelectorAttribute.prototype.c = function (){
			// TODO possibly support .toSel or sel$(v) for items inside query
			// could easily do it with a helper-function that is added to the top of the filescope
			if (this._right instanceof Str) {
				return ("[" + (this._left.c()) + (this._op) + (this._right.c()) + "]");
			} else if (this._right) {
				// this is not at all good
				return ("[" + (this._left.c()) + (this._op) + "\"'+" + c__(this._right) + "+'\"]");
			} else {
				return ("[" + (this._left.c()) + "]");
				
				// ...
			};
		};
		
		
		
		
		// DEFER
		
		function Await(){ return ValueNode.apply(this,arguments) };
		
		subclass$(Await,ValueNode);
		exports.Await = Await; // export class 
		Await.prototype.func = function(v){ return this._func; }
		Await.prototype.setFunc = function(v){ this._func = v; return this; };
		
		Await.prototype.js = function (o){
			// introduce a util here, no?
			return CALL(OP('.',new Util.Promisify([this.value()]),'then'),[this.func()]).c();
			// value.c
		};
		
		Await.prototype.visit = function (o){
			// things are now traversed in a somewhat chaotic order. Need to tighten
			// Create await function - push this value up to block, take the outer
			var self = this;
			self.value().traverse();
			
			var block = o.up(Block); // or up to the closest FUNCTION?
			var outer = o.relative(block,1);
			var par = o.relative(self,-1);
			
			// p "Block {block} {outer} {par}"
			
			self.setFunc(new AsyncFunc([],[]));
			// now we move this node up to the block
			self.func().body().setNodes(block.defers(outer,self));
			
			// if the outer is a var-assignment, we can simply set the params
			if (par instanceof Assign) {
				par.left().traverse();
				var lft = par.left().node();
				// p "Async assignment {par} {lft}"
				// Can be a tuple as well, no?
				if (lft instanceof VarReference) {
					// the param is already registered?
					// should not force the name already??
					// beware of bugs
					self.func().params().at(0,true,lft.variable().name());
				} else if (lft instanceof Tuple) {
					// if this an unfancy tuple, with only vars
					// we can just use arguments
					
					if (par.type() == 'var' && !lft.hasSplat()) {
						// p "SIMPLIFY! {lft.nodes[0]}"
						lft.map(function(el,i) {
							return self.func().params().at(i,true,el.value());
						});
					} else {
						// otherwise, do the whole tuple
						// make sure it is a var assignment?
						par.setRight(ARGUMENTS);
						self.func().body().unshift(par);
					};
				} else {
					// regular setters
					par.setRight(self.func().params().at(0,true));
					self.func().body().unshift(par);
				};
			};
			
			
			
			// If it is an advance tuple or something, it should be possible to
			// feed in the paramlist, and let the tuple handle it as if it was any
			// other value
			
			// CASE If this is a tuple / multiset with more than one async value
			// we need to think differently.
			
			// now we need to visit the function as well
			self.func().traverse();
			// pull the outer in
			return self;
		};
		
		function AsyncFunc(params,body,name,target,options){
			AsyncFunc.__super__.constructor.call(this,params,body,name,target,options);
		};
		
		subclass$(AsyncFunc,Func);
		exports.AsyncFunc = AsyncFunc; // export class 
		AsyncFunc.prototype.scopetype = function (){
			return LambdaScope;
		};
		
		// need to override, since we wont do implicit returns
		// def js
		// 	var code = scope.c
		// 	return "function ({params.c})" + code.wrap
		;
		
		
		
		// IMPORTS
		
		function ImportStatement(imports,source,ns){
			this._traversed = false;
			this._imports = imports;
			this._source = source;
			this._ns = ns;
			this;
		};
		
		subclass$(ImportStatement,Statement);
		exports.ImportStatement = ImportStatement; // export class 
		ImportStatement.prototype.ns = function(v){ return this._ns; }
		ImportStatement.prototype.setNs = function(v){ this._ns = v; return this; };
		ImportStatement.prototype.imports = function(v){ return this._imports; }
		ImportStatement.prototype.setImports = function(v){ this._imports = v; return this; };
		ImportStatement.prototype.source = function(v){ return this._source; }
		ImportStatement.prototype.setSource = function(v){ this._source = v; return this; };
		
		
		ImportStatement.prototype.visit = function (){
			if (this._ns) {
				this._nsvar || (this._nsvar = this.scope__().register(this._ns,this));
			} else {
				var src = this.source().c();
				var m = src.match(/(\w+)(\.js|imba)?[\"\']$/);
				this._alias = m ? (m[1] + '$') : ('mod$');
			};
			
			// should also register the imported items, no?
			if (this._imports) {
				var dec = this._declarations = new VariableDeclaration([]);
				
				if (this._imports.length == 1) {
					this._alias = this._imports[0];
					dec.add(this._alias,OP('.',CALL(new Identifier("require"),[this.source()]),this._alias));
					dec.traverse();
					return this;
					
					// dec.add(@alias,CALL(Identifier.new("require"),[source]))
				};
				
				// p "ImportStatement has imports {@imports:length}"
				// @declarations = VariableDeclaration.new([])
				this._moduledecl = dec.add(this._alias,CALL(new Identifier("require"),[this.source()]));
				this._moduledecl.traverse();
				
				
				if (this._imports.length > 1) {
					for (var i = 0, ary = iter$(this._imports), len = ary.length, imp; i < len; i++) {
						imp = ary[i];
						this._declarations.add(imp,OP('.',this._moduledecl.variable(),imp));
					};
				};
				
				dec.traverse();
			};
			return this;
		};
		
		
		ImportStatement.prototype.js = function (o){
			
			var fname;
			if (this._declarations) {
				return this._declarations.c();
			};
			
			var req = CALL(new Identifier("require"),[this.source()]);
			
			if (this._ns) {
				// must register ns as a real variable
				return ("var " + (this._nsvar.c()) + " = " + (req.c()));
			};
			
			if (this._imports) {
				
				var src = this.source().c();
				var alias = [];
				var vars = new VarBlock([]);
				
				if (fname = src.match(/(\w+)(\.js|imba)?[\"\']$/)) {
					alias.push(fname[1]);
				};
				
				// var alias = src.match(/(\w+)(\.js|imba)?[\"\']$/)
				// p "source type {source}"
				// create a require for the source, with a temporary name?
				var out = [req.cache({names: alias}).c()];
				
				for (var i = 0, ary = iter$(this._imports), len = ary.length, imp; i < len; i++) {
					// we also need to register these imports as variables, no?
					imp = ary[i];
					var o = OP('=',imp,OP('.',req,imp));
					out.push(("var " + (o.c())));
				};
				
				return out;
			} else {
				return req.c();
			};
		};
		
		ImportStatement.prototype.consume = function (node){
			return this;
		};
		
		
		// EXPORT 
		
		function ExportStatement(){ return ValueNode.apply(this,arguments) };
		
		subclass$(ExportStatement,ValueNode);
		exports.ExportStatement = ExportStatement; // export class 
		ExportStatement.prototype.js = function (o){
			var nodes = this._value.map(function(arg) { return ("module.exports." + (arg.c()) + " = " + (arg.c())); });
			
			if (nodes.length > 1 && (this.up() instanceof Return)) {
				return '[' + nodes.join(',') + ']';
			} else {
				return nodes.join(';\n') + ';';
			};
		};
		
		
		// UTILS
		
		function Util(args){
			this._args = args;
		};
		
		// this is how we deal with it now
		subclass$(Util,Node);
		exports.Util = Util; // export class 
		Util.prototype.args = function(v){ return this._args; }
		Util.prototype.setArgs = function(v){ this._args = v; return this; };
		
		Util.extend = function (a,b){
			return new Util.Extend([a,b]);
		};
		
		Util.callImba = function (meth,args){
			return CALL(OP('.',new Const("Imba"),new Identifier(meth)),args);
		};
		
		Util.repeat = function (str,times){
			var res = '';
			while (times > 0){
				if (times % 2 == 1) {
					res += str;
				};
				str += str;
				times >>= 1;
			};
			return res;
		};
		
		
		
		Util.keys = function (obj){
			var l = new Const("Object");
			var r = new Identifier("keys");
			return CALL(OP('.',l,r),[obj]);
		};
		
		Util.len = function (obj,cache){
			// p "LEN HELPER".green
			var r = new Identifier("length");
			var node = OP('.',obj,r);
			if (cache) { node.cache({force: true,pool: 'len'}) };
			return node;
		};
		
		Util.indexOf = function (lft,rgt){
			var node = new Util.IndexOf([lft,rgt]);
			// node.cache(force: yes, type: 'iter') if cache
			return node;
		};
		
		Util.slice = function (obj,a,b){
			var slice = new Identifier("slice");
			console.log(("slice " + a + " " + b));
			return CALL(OP('.',obj,slice),compact__([a,b]));
		};
		
		Util.iterable = function (obj,cache){
			var node = new Util.Iterable([obj]);
			if (cache) { node.cache({force: true,pool: 'iter'}) };
			return node;
		};
		
		
		
		Util.union = function (a,b){
			return new Util.Union([a,b]);
			// CALL(UNION,[a,b])
		};
		
		Util.intersect = function (a,b){
			return new Util.Intersect([a,b]);
			// CALL(INTERSECT,[a,b])
		};
		
		Util.counter = function (start,cache){
			// should it not rather be a variable?!?
			var node = new Num(start); // make sure it really is a number
			if (cache) { node.cache({force: true,pool: 'counter'}) };
			return node;
		};
		
		Util.array = function (size,cache){
			var node = new Util.Array([size]);
			if (cache) { node.cache({force: true,pool: 'list'}) };
			return node;
		};
		
		Util.defineTag = function (type,ctor,supr){
			return CALL(TAGDEF,[type,ctor,supr]);
		};
		
		
		Util.defineClass = function (name,supr,initor){
			return CALL(CLASSDEF,[name || initor,this.sup()]);
		};
		
		Util.prototype.isStandalone = function (){
			return OPTS.standalone !== false;
		};
		
		Util.prototype.js = function (o){
			return "helper";
		};
		
		// TODO Deprecate and remove
		Util.Union = function Union(){ return Util.apply(this,arguments) };
		
		subclass$(Util.Union,Util);
		Util.Union.prototype.helper = function (){
			return 'function union$(a,b){\n	if(a && a.__union) return a.__union(b);\n\n	var u = a.slice(0);\n	for(var i=0,l=b.length;i<l;i++) if(u.indexOf(b[i]) == -1) u.push(b[i]);\n	return u;\n};\n';
		};
		
		Util.Union.prototype.js = function (o){
			this.scope__().root().helper(this,this.helper());
			// When this is triggered, we need to add it to the top of file?
			return ("union$(" + this.args().map(function(v) { return v.c(); }).join(',') + ")");
		};
		
		// TODO Deprecate and remove
		Util.Intersect = function Intersect(){ return Util.apply(this,arguments) };
		
		subclass$(Util.Intersect,Util);
		Util.Intersect.prototype.helper = function (){
			return 'function intersect$(a,b){\n	if(a && a.__intersect) return a.__intersect(b);\n	var res = [];\n	for(var i=0, l=a.length; i<l; i++) {\n		var v = a[i];\n		if(b.indexOf(v) != -1) res.push(v);\n	}\n	return res;\n};\n';
		};
		
		Util.Intersect.prototype.js = function (o){
			// When this is triggered, we need to add it to the top of file?
			this.scope__().root().helper(this,this.helper());
			return ("intersect$(" + this.args().map(function(v) { return v.c(); }).join(',') + ")");
		};
		
		Util.Extend = function Extend(){ return Util.apply(this,arguments) };
		
		subclass$(Util.Extend,Util);
		Util.Extend.prototype.js = function (o){
			// When this is triggered, we need to add it to the top of file?
			return ("extend$(" + compact__(cary__(this.args())).join(',') + ")");
		};
		
		Util.IndexOf = function IndexOf(){ return Util.apply(this,arguments) };
		
		subclass$(Util.IndexOf,Util);
		Util.IndexOf.prototype.helper = function (){
			return 'function idx$(a,b){\n	return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);\n};\n';
		};
		
		Util.IndexOf.prototype.js = function (o){
			if (this.isStandalone()) {
				this.scope__().root().helper(this,this.helper());
				// When this is triggered, we need to add it to the top of file?
				return ("idx$(" + this.args().map(function(v) { return v.c(); }).join(',') + ")");
			} else {
				return ("Imba.indexOf(" + this.args().map(function(v) { return v.c(); }).join(',') + ")");
			};
		};
		
		
		Util.Subclass = function Subclass(){ return Util.apply(this,arguments) };
		
		subclass$(Util.Subclass,Util);
		Util.Subclass.prototype.helper = function (){
			// should also check if it is a real promise
			return '// helper for subclassing\nfunction subclass$(obj,sup) {\n	for (var k in sup) {\n		if (sup.hasOwnProperty(k)) obj[k] = sup[k];\n	};\n	// obj.__super__ = sup;\n	obj.prototype = Object.create(sup.prototype);\n	obj.__super__ = obj.prototype.__super__ = sup.prototype;\n	obj.prototype.initialize = obj.prototype.constructor = obj;\n};\n';
		};
		
		Util.Subclass.prototype.js = function (o){
			if (this.isStandalone()) {
				// When this is triggered, we need to add it to the top of file?
				this.scope__().root().helper(this,this.helper());
				return ("subclass$(" + this.args().map(function(v) { return v.c(); }).join(',') + ");\n");
			} else {
				return ("Imba.subclass(" + this.args().map(function(v) { return v.c(); }).join(',') + ");\n");
			};
		};
		
		Util.Promisify = function Promisify(){ return Util.apply(this,arguments) };
		
		subclass$(Util.Promisify,Util);
		Util.Promisify.prototype.helper = function (){
			// should also check if it is a real promise
			return ("function promise$(a)\{ return a instanceof Array ? Promise.all(a) : (a && a.then ? a : Promise.resolve(a)); \}");
		};
		
		Util.Promisify.prototype.js = function (o){
			if (this.isStandalone()) {
				// When this is triggered, we need to add it to the top of file?
				this.scope__().root().helper(this,this.helper());
				return ("promise$(" + this.args().map(function(v) { return v.c(); }).join(',') + ")");
			} else {
				return ("Imba.await(" + this.args().map(function(v) { return v.c(); }).join(',') + ")");
			};
		};
		
		// TODO deprecated: can remove
		Util.Class = function Class(){ return Util.apply(this,arguments) };
		
		subclass$(Util.Class,Util);
		Util.Class.prototype.js = function (o){
			// When this is triggered, we need to add it to the top of file?
			return ("class$(" + this.args().map(function(v) { return v.c(); }).join(',') + ")");
		};
		
		Util.Iterable = function Iterable(){ return Util.apply(this,arguments) };
		
		subclass$(Util.Iterable,Util);
		Util.Iterable.prototype.helper = function (){
			// now we want to allow null values as well - just return as empty collection
			// should be the same for for own of I guess
			return ("function iter$(a)\{ return a ? (a.toArray ? a.toArray() : a) : []; \};");
		};
		
		Util.Iterable.prototype.js = function (o){
			if (this.args()[0] instanceof Arr) { return this.args()[0].c() }; // or if we know for sure that it is an array
			
			if (this.isStandalone()) {
				this.scope__().root().helper(this,this.helper());
				return ("iter$(" + (this.args()[0].c()) + ")");
			} else {
				return ("Imba.iterable(" + (this.args()[0].c()) + ")");
			};
		};
		
		Util.IsFunction = function IsFunction(){ return Util.apply(this,arguments) };
		
		subclass$(Util.IsFunction,Util);
		Util.IsFunction.prototype.js = function (o){
			return ("" + (this.args()[0].c()));
		};
		
		Util.Array = function Array(){ return Util.apply(this,arguments) };
		
		subclass$(Util.Array,Util);
		Util.Array.prototype.js = function (o){
			// When this is triggered, we need to add it to the top of file?
			return ("new Array(" + this.args().map(function(v) { return v.c(); }) + ")");
		};
		
		
		
		
		function Entities(root){
			this._root = root;
			this._map = {};
			return this;
		};
		
		Entities.prototype.add = function (path,object){
			this._map[path] = object;
			return this;
		};
		
		Entities.prototype.register = function (entity){
			var $1;
			var path = entity.namepath();
			this._map[($1 = path)] || (this._map[$1] = entity);
			return this;
		};
		
		Entities.prototype.plain = function (){
			return JSON.parse(JSON.stringify(this._map));
		};
		
		Entities.prototype.toJSON = function (){
			return this._map;
		};
		
		// SCOPES
		
		// handles local variables, self etc. Should create references to outer scopes
		// when needed etc.
		
		// add class for annotations / registering methods, etc?
		// class Interface
		
		// should move the whole context-thingie right into scope
		function Scope(node,parent){
			this._nr = STACK.incr('scopes');
			this._head = [];
			this._node = node;
			this._parent = parent;
			this._vars = new VariableDeclaration([]);
			this._meta = {};
			this._annotations = [];
			this._closure = this;
			this._virtual = false;
			this._counter = 0;
			this._varmap = {};
			this._varpool = [];
		};
		
		exports.Scope = Scope; // export class 
		Scope.prototype.level = function(v){ return this._level; }
		Scope.prototype.setLevel = function(v){ this._level = v; return this; };
		Scope.prototype.context = function(v){ return this._context; }
		Scope.prototype.setContext = function(v){ this._context = v; return this; };
		Scope.prototype.node = function(v){ return this._node; }
		Scope.prototype.setNode = function(v){ this._node = v; return this; };
		Scope.prototype.parent = function(v){ return this._parent; }
		Scope.prototype.setParent = function(v){ this._parent = v; return this; };
		Scope.prototype.varmap = function(v){ return this._varmap; }
		Scope.prototype.setVarmap = function(v){ this._varmap = v; return this; };
		Scope.prototype.varpool = function(v){ return this._varpool; }
		Scope.prototype.setVarpool = function(v){ this._varpool = v; return this; };
		Scope.prototype.params = function(v){ return this._params; }
		Scope.prototype.setParams = function(v){ this._params = v; return this; };
		Scope.prototype.head = function(v){ return this._head; }
		Scope.prototype.setHead = function(v){ this._head = v; return this; };
		Scope.prototype.vars = function(v){ return this._vars; }
		Scope.prototype.setVars = function(v){ this._vars = v; return this; };
		Scope.prototype.counter = function(v){ return this._counter; }
		Scope.prototype.setCounter = function(v){ this._counter = v; return this; };
		
		Scope.prototype.p = function (){
			if (STACK.loglevel() > 0) {
				console.log.apply(console,arguments);
			};
			return this;
		};
		
		Scope.prototype.stack = function (){
			return STACK;
		};
		
		Scope.prototype.meta = function (key,value){
			if (value != undefined) {
				this._meta[key] = value;
				return this;
			};
			return this._meta[key];
		};
		
		Scope.prototype.namepath = function (){
			return '?';
		};
		
		Scope.prototype.tagContextPath = function (){
			// bypassing for now
			return this._tagContextPath || (this._tagContextPath = "tag$"); // parent.tagContextPath
		};
		
		Scope.prototype.context = function (){
			return this._context || (this._context = new ScopeContext(this));
		};
		
		Scope.prototype.traverse = function (){
			return this;
		};
		
		Scope.prototype.visit = function (){
			if (this._parent) { return this };
			// p "visited scope!"
			this._parent = STACK.scope(1); // the parent scope
			this._level = STACK.scopes().length - 1;
			
			// p "parent is",@parent
			STACK.addScope(this);
			this.root().scopes().push(this);
			return this;
		};
		
		Scope.prototype.wrap = function (scope){
			this._parent = scope._parent;
			scope._parent = this;
			return this;
		};
		
		// called for scopes that are not real scopes in js
		// must ensure that the local variables inside of the scopes do not
		// collide with variables in outer scopes -- rename if needed
		Scope.prototype.virtualize = function (){
			return this;
		};
		
		Scope.prototype.root = function (){
			var scope = this;
			while (scope){
				if (scope instanceof RootScope) { return scope };
				scope = scope.parent();
			};
			return null;
		};
		
		Scope.prototype.register = function (name,decl,o){
			// FIXME re-registering a variable should really return the existing one
			// Again, here we should not really have to deal with system-generated vars
			// But again, it is important
			
			// p "registering {name}"
			if(decl === undefined) decl = null;
			if(o === undefined) o = {};
			name = helpers.symbolize(name);
			
			// also look at outer scopes if this is not closed?
			var existing = this._varmap.hasOwnProperty(name) && this._varmap[name];
			if (existing) { return existing };
			
			var item = new Variable(this,name,decl,o);
			// need to check for duplicates, and handle this gracefully -
			// going to refactor later
			if (!o.system) { this._varmap[name] = item }; // dont even add to the varmap if it is a sysvar
			return item;
		};
		
		Scope.prototype.annotate = function (obj){
			this._annotations.push(obj);
			return this;
		};
		
		// just like register, but we automatically 
		Scope.prototype.declare = function (name,init,o){
			var declarator_;
			if(init === undefined) init = null;
			if(o === undefined) o = {};
			var variable = this.register(name,null,o);
			// TODO create the variabledeclaration here instead?
			// if this is a sysvar we need it to be renameable
			var dec = this._vars.add(variable,init);
			(declarator_ = variable.declarator()) || ((variable.setDeclarator(dec),dec));
			return variable;
			
			// p "declare variable {name} {o}"
			// if name isa Variable
			// p "SCOPE declare var".green
			name = helpers.symbolize(name);
			// we will see here
			this._vars.add(name,init); // .last -- 
			var decl = this._vars.last(); // bug(!)
			var item;
			// item = Variable.new(self,name,decl)
			
			// if o:system
			// 	item = SystemVariable.new(self,name,decl,o)
			// 	decl.variable = item
			// else
			item = new Variable(this,name,decl,o);
			decl.setVariable(item);
			item.resolve(); // why on earth should it resolve immediately?
			
			// decl.variable = item
			// item.resolve # why on earth should it resolve immediately?
			return item;
			
			// should be possible to force-declare for this scope, no?
			// if this is a system-variable 
		};
		
		// declares a variable (has no real declaration beforehand)
		
		
		// what are the differences here? omj
		// we only need a temporary thing with defaults -- that is all
		// change these values, no?
		Scope.prototype.temporary = function (refnode,o,name){
			
			// p "registering temporary {refnode} {name}"
			// reuse variables -- hmm
			if(o === undefined) o = {};
			if(name === undefined) name = null;
			if (o.pool) {
				for (var i = 0, ary = iter$(this._varpool), len = ary.length, v; i < len; i++) {
					v = ary[i];
					if (v.pool() == o.pool && v.declarator() == null) {
						return v.reuse(refnode);
					};
				};
			};
			
			// should only 'register' as ahidden variable, no?
			// if there are real nodes inside that tries to refer to vars
			// defined in outer scopes, we need to make sure they are not named after this
			var item = new SystemVariable(this,name,refnode,o);
			this._varpool.push(item); // WHAT? It should not be in the pool unless explicitly put there?
			this._vars.push(item); // WARN variables should not go directly into a declaration-list
			return item;
			// return register(name || "__",null,system: yes, temporary: yes)
		};
		
		
		
		Scope.prototype.lookup = function (name){
			var ret = null;
			name = helpers.symbolize(name);
			if (this._varmap.hasOwnProperty(name)) {
				ret = this._varmap[name];
			} else {
				// look up any parent scope ?? seems okay
				// !isClosed && 
				ret = this.parent() && this.parent().lookup(name);
				// or -- not all scopes have a parent?
			};
			
			// should this not happen by itself?
			// if !ret and 
			//	ret = 
			// ret ||= (g.lookup(name) if var g = root)
			// g = root
			return ret;
		};
		
		Scope.prototype.autodeclare = function (variable){
			return this.vars().push(variable); // only if it does not exist here!!!
		};
		
		Scope.prototype.free = function (variable){
			// p "free variable"
			variable.free(); // :owner = null
			// @varpool.push(variable)
			return this;
		};
		
		Scope.prototype.isClosed = function (){
			return false;
		};
		
		Scope.prototype.closure = function (){
			return this._closure;
		};
		
		Scope.prototype.finalize = function (){
			return this;
		};
		
		Scope.prototype.klass = function (){
			var scope = this;
			while (scope){
				scope = scope.parent();
				if (scope instanceof ClassScope) { return scope };
			};
			return null;
		};
		
		Scope.prototype.head = function (){
			return [this._vars,this._params];
		};
		
		Scope.prototype.c = function (o){
			var body;
			if(o === undefined) o = {};
			o.expression = false;
			// need to fix this
			this.node().body().setHead(this.head());
			return body = this.node().body().c(o);
			
			// var head = [@vars,@params].block.c(expression: no)
			// p "head from scope is ({head})"
			// var out = [head or null,body].flatten__.compact.join("\n")
			// out
			// out = '{' + out + 
		};
		
		Scope.prototype.region = function (){
			return this.node().body().region();
		};
		
		Scope.prototype.loc = function (){
			return this.node().loc();
		};
		
		Scope.prototype.dump = function (){
			var self = this;
			var vars = Object.keys(this._varmap).map(function(k) {
				var v = self._varmap[k];
				return v.references().length ? (dump__(v)) : (null);
			});
			
			var desc = {
				nr: self._nr,
				type: self.constructor.name,
				level: (self.level() || 0),
				vars: compact__(vars),
				loc: self.loc()
			};
			
			return desc;
		};
		
		Scope.prototype.toJSON = function (){
			return this.dump();
		};
		
		Scope.prototype.toString = function (){
			return ("" + (this.constructor.name));
		};
		
		
		// RootScope is wrong? Rather TopScope or ProgramScope
		function RootScope(){
			RootScope.__super__.constructor.apply(this,arguments);
			
			this.register('global',this,{type: 'global'});
			this.register('module',this,{type: 'global'});
			this.register('window',this,{type: 'global'});
			this.register('document',this,{type: 'global'});
			this.register('exports',this,{type: 'global'});
			this.register('console',this,{type: 'global'});
			this.register('process',this,{type: 'global'});
			this.register('parseInt',this,{type: 'global'});
			this.register('parseFloat',this,{type: 'global'});
			this.register('setTimeout',this,{type: 'global'});
			this.register('setInterval',this,{type: 'global'});
			this.register('clearTimeout',this,{type: 'global'});
			this.register('clearInterval',this,{type: 'global'});
			this.register('__dirname',this,{type: 'global'});
			
			// preregister global special variables here
			this._warnings = [];
			this._scopes = [];
			this._helpers = [];
			this._entities = new Entities(this);
			this._head = [this._vars];
		};
		
		subclass$(RootScope,Scope);
		exports.RootScope = RootScope; // export class 
		RootScope.prototype.warnings = function(v){ return this._warnings; }
		RootScope.prototype.setWarnings = function(v){ this._warnings = v; return this; };
		RootScope.prototype.scopes = function(v){ return this._scopes; }
		RootScope.prototype.setScopes = function(v){ this._scopes = v; return this; };
		RootScope.prototype.entities = function(v){ return this._entities; }
		RootScope.prototype.setEntities = function(v){ this._entities = v; return this; };
		
		RootScope.prototype.context = function (){
			return this._context || (this._context = new RootScopeContext(this));
		};
		
		RootScope.prototype.tagContextPath = function (){
			return this._tagContextPath || (this._tagContextPath = "tag$");
		};
		
		RootScope.prototype.lookup = function (name){
			// p "lookup filescope"
			name = helpers.symbolize(name);
			if (this._varmap.hasOwnProperty(name)) { return this._varmap[name] };
		};
		
		RootScope.prototype.visit = function (){
			STACK.addScope(this);
			return this;
		};
		
		RootScope.prototype.helper = function (typ,value){
			// log "add helper",typ,value
			if (this._helpers.indexOf(value) == -1) {
				this._helpers.push(value);
				this._head.unshift(value);
			};
			
			return this;
		};
		
		RootScope.prototype.head = function (){
			return this._head;
		};
		
		RootScope.prototype.warn = function (data){
			// hacky
			data.node = null;
			// p "warning",JSON.stringify(data)
			this._warnings.push(data);
			return this;
		};
		
		RootScope.prototype.dump = function (){
			var obj = {warnings: dump__(this._warnings)};
			
			if (OPTS.analysis.scopes) {
				var scopes = this._scopes.map(function(s) { return s.dump(); });
				scopes.unshift(RootScope.__super__.dump.call(this));
				obj.scopes = scopes;
			};
			
			if (OPTS.analysis.entities) {
				obj.entities = this._entities;
			};
			
			return obj;
		};
		
		
		function ClassScope(){ return Scope.apply(this,arguments) };
		
		subclass$(ClassScope,Scope);
		exports.ClassScope = ClassScope; // export class 
		ClassScope.prototype.namepath = function (){
			return this._node.namepath();
		};
		
		
		// called for scopes that are not real scopes in js
		// must ensure that the local variables inside of the scopes do not
		// collide with variables in outer scopes -- rename if needed
		ClassScope.prototype.virtualize = function (){
			// console.log "virtualizing ClassScope"
			var up = this.parent();
			for (var o = this._varmap, i = 0, keys = Object.keys(o), l = keys.length; i < l; i++){
				true;
				o[keys[i]].resolve(up,true); // force new resolve
			};
			return this;
		};
		
		ClassScope.prototype.isClosed = function (){
			return true;
		};
		
		function TagScope(){ return ClassScope.apply(this,arguments) };
		
		subclass$(TagScope,ClassScope);
		exports.TagScope = TagScope; // export class 
		
		
		function ClosureScope(){ return Scope.apply(this,arguments) };
		
		subclass$(ClosureScope,Scope);
		exports.ClosureScope = ClosureScope; // export class 
		
		
		function FunctionScope(){ return Scope.apply(this,arguments) };
		
		subclass$(FunctionScope,Scope);
		exports.FunctionScope = FunctionScope; // export class 
		
		
		function MethodScope(){ return Scope.apply(this,arguments) };
		
		subclass$(MethodScope,Scope);
		exports.MethodScope = MethodScope; // export class 
		MethodScope.prototype.isClosed = function (){
			return true;
		};
		
		function LambdaScope(){ return Scope.apply(this,arguments) };
		
		subclass$(LambdaScope,Scope);
		exports.LambdaScope = LambdaScope; // export class 
		LambdaScope.prototype.context = function (){
			
			// when accessing the outer context we need to make sure that it is cached
			// so this is wrong - but temp okay
			return this._context || (this._context = this.parent().context().reference(this));
		};
		
		function FlowScope(){ return Scope.apply(this,arguments) };
		
		subclass$(FlowScope,Scope);
		exports.FlowScope = FlowScope; // export class 
		FlowScope.prototype.params = function (){
			if (this._parent) { return this._parent.params() };
		};
		
		FlowScope.prototype.register = function (name,decl,o){
			var found;
			if(decl === undefined) decl = null;
			if(o === undefined) o = {};
			if (o.type != 'let' && (this.closure() != this)) {
				if (found = this.lookup(name)) {
					// p "already found variable {found.type}"
					if (found.type() == 'let') {
						this.p(("" + name + " already exists as a block-variable " + decl));
						// TODO should throw error instead
						if (decl) { decl.warn("Variable already exists in block") };
						// root.warn message: "Holy shit"
					};
					// if found.
				};
				// p "FlowScope register var -- do it right in the outer scope"
				return this.closure().register(name,decl,o);
			} else {
				// p "Register local variable for FlowScope {name}"
				// o:closure = parent
				// p "FlowScope register", arguments
				return FlowScope.__super__.register.call(this,name,decl,o);
			};
		};
		
		// FIXME should override temporary as well
		
		FlowScope.prototype.autodeclare = function (variable){
			return this.parent().autodeclare(variable);
		};
		
		FlowScope.prototype.closure = function (){
			// rather all the way?
			return this._parent.closure(); // this is important?
		};
		
		FlowScope.prototype.context = function (){
			// if we are wrapping in an expression - we do need to add a reference
			// @referenced = yes
			return this.parent().context();
			// usually - if the parent scope is a closed scope we dont really need
			// to force a reference
			// @context ||= parent.context.reference(self)
		};
		
		function CatchScope(){ return FlowScope.apply(this,arguments) };
		
		subclass$(CatchScope,FlowScope);
		exports.CatchScope = CatchScope; // export class 
		
		
		function WhileScope(){ return FlowScope.apply(this,arguments) };
		
		subclass$(WhileScope,FlowScope);
		exports.WhileScope = WhileScope; // export class 
		WhileScope.prototype.autodeclare = function (variable){
			return this.vars().push(variable);
		};
		
		function ForScope(){ return FlowScope.apply(this,arguments) };
		
		subclass$(ForScope,FlowScope);
		exports.ForScope = ForScope; // export class 
		ForScope.prototype.autodeclare = function (variable){
			return this.vars().push(variable);
			// parent.autodeclare(variable)
		};
		
		// def closure
		// 	self
		;
		
		function IfScope(){ return FlowScope.apply(this,arguments) };
		
		subclass$(IfScope,FlowScope);
		exports.IfScope = IfScope; // export class 
		IfScope.prototype.temporary = function (refnode,o,name){
			if(o === undefined) o = {};
			if(name === undefined) name = null;
			return this.parent().temporary(refnode,o,name);
		};
		
		function BlockScope(){ return FlowScope.apply(this,arguments) };
		
		subclass$(BlockScope,FlowScope);
		exports.BlockScope = BlockScope; // export class 
		BlockScope.prototype.temporary = function (refnode,o,name){
			if(o === undefined) o = {};
			if(name === undefined) name = null;
			return this.parent().temporary(refnode,o,name);
		};
		
		BlockScope.prototype.region = function (){
			return this.node().region();
		};
		
		// lives in scope -- really a node???
		function Variable(scope,name,decl,o){
			this._ref = STACK._counter++;
			this._c = null;
			this._scope = scope;
			this._name = name;
			this._alias = null;
			this._initialized = true;
			this._declarator = decl;
			this._autodeclare = false;
			this._declared = o && o.declared || false;
			this._resolved = false;
			this._options = o || {};
			this._type = o && o.type || 'var'; // what about let here=
			this._export = false;
			this._references = []; // only needed when profiling
			this._assignments = [];
			this;
		};
		
		subclass$(Variable,Node);
		exports.Variable = Variable; // export class 
		Variable.prototype.scope = function(v){ return this._scope; }
		Variable.prototype.setScope = function(v){ this._scope = v; return this; };
		Variable.prototype.name = function(v){ return this._name; }
		Variable.prototype.setName = function(v){ this._name = v; return this; };
		Variable.prototype.alias = function(v){ return this._alias; }
		Variable.prototype.setAlias = function(v){ this._alias = v; return this; };
		Variable.prototype.type = function(v){ return this._type; }
		Variable.prototype.setType = function(v){ this._type = v; return this; };
		Variable.prototype.options = function(v){ return this._options; }
		Variable.prototype.setOptions = function(v){ this._options = v; return this; };
		Variable.prototype.initialized = function(v){ return this._initialized; }
		Variable.prototype.setInitialized = function(v){ this._initialized = v; return this; };
		Variable.prototype.declared = function(v){ return this._declared; }
		Variable.prototype.setDeclared = function(v){ this._declared = v; return this; };
		Variable.prototype.declarator = function(v){ return this._declarator; }
		Variable.prototype.setDeclarator = function(v){ this._declarator = v; return this; };
		Variable.prototype.autodeclare = function(v){ return this._autodeclare; }
		Variable.prototype.setAutodeclare = function(v){ this._autodeclare = v; return this; };
		Variable.prototype.references = function(v){ return this._references; }
		Variable.prototype.setReferences = function(v){ this._references = v; return this; };
		Variable.prototype.export = function(v){ return this._export; }
		Variable.prototype.setExport = function(v){ this._export = v; return this; };
		
		Variable.prototype.pool = function (){
			return null;
		};
		
		Variable.prototype.closure = function (){
			return this._scope.closure();
		};
		
		Variable.prototype.assignments = function (){
			return this._assignments;
		};
		
		// Here we can collect lots of type-info about variables
		// and show warnings / give advice if variables are ambiguous etc
		Variable.prototype.assigned = function (val,source){
			this._assignments.push(val);
			// p "Variable was assigned {val}"
			if (val instanceof Arr) {
				// just for testing really
				this._isArray = true;
			} else {
				this._isArray = false;
			};
			return this;
		};
		
		Variable.prototype.resolve = function (scope,force){
			if(scope === undefined) scope = this.scope();
			if(force === undefined) force = false;
			if (this._resolved && !(force)) { return this };
			
			this._resolved = true;
			var closure = this._scope.closure();
			var item = scope.lookup(this._name);
			
			// if this is a let-definition inside a virtual scope we do need
			// 
			if (this._scope != closure && this._type == 'let') { // or if it is a system-variable
				// p "scope is not the closure -- need to resolve {@name}"
				item = closure.lookup(this._name);
				
				// we now need to ensure that this variable is unique inside
				// the whole closure.
				scope = closure;
			};
			
			// p "scope is not the closure -- need to resolve {@name} {@type}"
			
			if (item == this) {
				scope.varmap()[this._name] = this;
				return this;
			} else if (item) {
				// p "variable already exists {@name}"
				
				// possibly redefine this inside, use it only in this scope
				// if the item is defined in an outer scope - we reserve the
				if (item.scope() != scope && (this.options().let || this._type == 'let')) {
					// p "override variable inside this scope {@name}"
					scope.varmap()[this._name] = this;
				};
				
				// different rules for different variables?
				if (this._options.proxy) {
					// p "is proxy -- no need to change name!!! {name}".cyan
					true;
				} else {
					var i = 0;
					var orig = this._name;
					// it is the closure that we should use
					while (scope.lookup(this._name)){
						this._name = ("" + orig + (i += 1));
					};
				};
			};
			
			// inefficient double setting
			scope.varmap()[this._name] = this;
			closure.varmap()[this._name] = this;
			return this;
			// p "resolve variable".cyan
		};
		
		Variable.prototype.reference = function (){
			return this;
		};
		
		Variable.prototype.node = function (){
			return this;
		};
		
		Variable.prototype.traverse = function (){
			// NODES.push(self)
			return this;
		};
		
		Variable.prototype.free = function (ref){
			// p "free variable!"
			this._declarator = null;
			return this;
		};
		
		Variable.prototype.reuse = function (ref){
			this._declarator = ref;
			return this;
		};
		
		Variable.prototype.proxy = function (par,index){
			this._proxy = [par,index];
			return this;
		};
		
		Variable.prototype.refcount = function (){
			return this._references.length;
		};
		
		Variable.prototype.c = function (){
			if (this._c) { return this._c };
			// options - proxy??
			if (this._proxy) {
				// p "var is proxied!",@proxy
				this._c = this._proxy[0].c() + '[' + this._proxy[1].c() + ']';
			} else {
				if (!this._resolved) this.resolve();
				var v = (this.alias() || this.name());
				this._c = typeof v == 'string' ? (v) : (v.c());
				// allow certain reserved words
				// should warn on others though (!!!)
				// if @c == 'new'
				// 	@c = '_new'
				// 	# should happen at earlier stage to
				// 	# get around naming conventions
				if (RESERVED_REGEX.test(this._c)) { this._c = ("" + this.c() + "$") }; // @c.match(/^(default)$/)
			};
			return this._c;
		};
		
		// variables should probably inherit from node(!)
		Variable.prototype.consume = function (node){
			// p "variable assignify!!!"
			return this;
		};
		
		// this should only generate the accessors - not dael with references
		Variable.prototype.accessor = function (ref){
			var node = new LocalVarAccess(".",null,this); // this is just wrong .. should not be a regular accessor
			// @references.push([ref,el]) if ref # weird temp format
			return node;
		};
		
		Variable.prototype.assignment = function (val){
			return new Assign('=',this,val);
		};
		
		Variable.prototype.addReference = function (ref){
			if (ref instanceof Identifier) {
				ref.references(this);
			};
			
			if (ref.region && ref.region()) {
				this._references.push(ref);
			};
			
			// p "reference is {ref:region and ref.region}"
			return this;
		};
		
		Variable.prototype.autodeclare = function (){
			if (this._declared) { return this };
			// p "variable should autodeclare(!) {name}"
			this._autodeclare = true;
			this.scope().autodeclare(this);
			this._declared = true;
			return this;
		};
		
		Variable.prototype.predeclared = function (){
			this._declared = true;
			return this;
		};
		
		
		Variable.prototype.toString = function (){
			return String(this.name());
		};
		
		Variable.prototype.dump = function (typ){
			var name = this.name();
			if (name[0].match(/[A-Z]/)) { return null };
			// console.log "dump variable of type {type} - {name}"
			return {
				type: this.type(),
				name: name,
				refs: dump__(this._references,typ)
			};
		};
		
		
		function SystemVariable(){ return Variable.apply(this,arguments) };
		
		subclass$(SystemVariable,Variable);
		exports.SystemVariable = SystemVariable; // export class 
		SystemVariable.prototype.pool = function (){
			return this._options.pool;
		};
		
		// weird name for this
		SystemVariable.prototype.predeclared = function (){
			// p "remove var from scope(!)"
			this.scope().vars().remove(this);
			return this;
		};
		
		SystemVariable.prototype.resolve = function (){
			var alias, v_;
			if (this._resolved || this._name) { return this };
			// p "RESOLVE SYSTEM VARIABLE".red
			this._resolved = true;
			// unless @name
			// adds a very random initial name
			// the auto-magical goes last, or at least, possibly reuse other names
			// "${Math.floor(Math.random * 1000)}"
			
			var typ = this._options.pool;
			var names = [].concat(this._options.names);
			var alt = null;
			var node = null;
			
			var scope = this.scope();
			
			if (typ == 'tag') {
				var i = 0;
				while (!this._name){
					alt = ("t" + (i++));
					if (!scope.lookup(alt)) { this._name = alt };
				};
			} else if (typ == 'iter') {
				names = ['ary__','ary_','coll','array','items','ary'];
			} else if (typ == 'val') {
				names = ['v_'];
			} else if (typ == 'arguments') {
				names = ['$_','$0'];
			} else if (typ == 'keypars') {
				names = ['opts','options','pars'];
			} else if (typ == 'counter') {
				names = ['i__','i_','k','j','i'];
			} else if (typ == 'len') {
				names = ['len__','len_','len'];
			} else if (typ == 'list') {
				names = ['tmplist_','tmplist','tmp'];
			};
			// or if type placeholder / cacher (add 0)
			
			while (!this._name && (alt = names.pop())){
				if (!scope.lookup(alt)) { this._name = alt };
			};
			
			if (!this._name && this._declarator) {
				if (node = this.declarator().node()) {
					if (alias = node.alias()) { names.push(alias + "_") };
				};
			};
			
			while (!this._name && (alt = names.pop())){
				if (!scope.lookup(alt)) { this._name = alt };
			};
			
			// p "suggested names {names.join(" , ")} {node}".cyan
			//  Math.floor(Math.random * 1000)
			this._name || (this._name = ("$" + (scope.setCounter(v_ = scope.counter() + 1),v_)));
			// p "name for variable is {@name}"
			scope.varmap()[this._name] = this;
			return this;
		};
		
		SystemVariable.prototype.name = function (){
			this.resolve();
			return this._name;
		};
		
		
		function ScopeContext(scope,value){
			this._scope = scope;
			this._value = value;
			this._reference = null;
			this;
		};
		
		subclass$(ScopeContext,Node);
		exports.ScopeContext = ScopeContext; // export class 
		ScopeContext.prototype.scope = function(v){ return this._scope; }
		ScopeContext.prototype.setScope = function(v){ this._scope = v; return this; };
		ScopeContext.prototype.value = function(v){ return this._value; }
		ScopeContext.prototype.setValue = function(v){ this._value = v; return this; };
		
		ScopeContext.prototype.namepath = function (){
			return this._scope.namepath();
		};
		
		// instead of all these references we should probably
		// just register when it is accessed / looked up from
		// a deeper function-scope, and when it is, we should
		// register the variable in scope, and then start to
		// use that for further references. Might clean things
		// up for the cases where we have yet to decide the
		// name of the variable etc?
		
		ScopeContext.prototype.reference = function (){
			// p "p reference {STACK.scoping}"
			// should be a special context-variable!!!
			return this._reference || (this._reference = this.scope().declare("self",new This()));
		};
		
		ScopeContext.prototype.c = function (){
			var val = this._value || this._reference;
			return val ? (val.c()) : ("this");
		};
		
		ScopeContext.prototype.cache = function (){
			return this;
		};
		
		function RootScopeContext(){ return ScopeContext.apply(this,arguments) };
		
		subclass$(RootScopeContext,ScopeContext);
		exports.RootScopeContext = RootScopeContext; // export class 
		RootScopeContext.prototype.c = function (o){
			// return "" if o and o:explicit
			var val = this._value || this._reference;
			return (val && val != this) ? (val.c()) : ("this");
			// should be the other way around, no?
			// o and o:explicit ? super : ""
		};
		
		function Super(){ return Node.apply(this,arguments) };
		
		subclass$(Super,Node);
		exports.Super = Super; // export class 
		Super.prototype.c = function (){
			// need to find the stuff here
			// this is really not that good8
			var m = STACK.method();
			var out = null;
			var up = STACK.current();
			var deep = (up instanceof Access);
			
			// TODO optimization for later - problematic if there is a different reference in the end
			if (false) {
				out = ("" + (m.target().c()) + ".superclass");
				if (!(deep)) { out += (".apply(" + (m.scope().context().c()) + ",arguments)") };
			} else {
				out = ("" + (m.target().c()) + ".__super__");
				if (!((up instanceof Access))) {
					out += ("." + c__(m.supername()));
					if (!((up instanceof Call))) { // autocall?
						out += (".apply(" + (m.scope().context().c()) + ",arguments)");
					};
				};
			};
			return out;
		};
		
		// constants
		
		module.exports.BR = BR = new Newline('\n');
		module.exports.BR2 = BR2 = new Newline('\n\n');
		module.exports.SELF = SELF = new Self();
		module.exports.SUPER = SUPER = new Super();
		
		module.exports.TRUE = TRUE = new True('true');
		module.exports.FALSE = FALSE = new False('false');
		module.exports.UNDEFINED = UNDEFINED = new Undefined();
		module.exports.NIL = NIL = new Nil();
		
		module.exports.ARGUMENTS = ARGUMENTS = new ArgsReference('arguments');
		module.exports.EMPTY = EMPTY = '';
		module.exports.NULL = NULL = 'null';
		
		module.exports.RESERVED = RESERVED = ['default','native','enum','with'];
		module.exports.RESERVED_REGEX = RESERVED_REGEX = /^(default|native|enum|with|new|char)$/;
		
		module.exports.UNION = UNION = new Const('union$');
		module.exports.INTERSECT = INTERSECT = new Const('intersect$');
		module.exports.CLASSDEF = CLASSDEF = new Const('imba$class');
		module.exports.TAGDEF = TAGDEF = new Const('Imba.TAGS.define');
		return module.exports.NEWTAG = NEWTAG = new Identifier("tag$");
		
		
		
		
		
		
		
		
		
		

	})()

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		
		var path = __webpack_require__(11);
		var util = __webpack_require__(3);
		
		function SourceMap(source){
			this._source = source;
			this._maps = [];
			this._map = "";
			this._js = "";
		};
		
		exports.SourceMap = SourceMap; // export class 
		SourceMap.prototype.source = function (){
			return this._source;
		};
		
		SourceMap.prototype.options = function (){
			return this._source;
		};
		
		SourceMap.prototype.filename = function (){
			return this.options().options.filename;
		};
		
		SourceMap.prototype.sourceCode = function (){
			return this.options().options._source;
		};
		
		SourceMap.prototype.targetPath = function (){
			return this.options().options.targetPath;
		};
		
		SourceMap.prototype.sourcePath = function (){
			return this.options().options.sourcePath;
		};
		
		SourceMap.prototype.sourceName = function (){
			return path.basename(this.sourcePath());
		};
		
		SourceMap.prototype.targetName = function (){
			return path.basename(this.targetPath());
		};
		
		
		SourceMap.prototype.sourceFiles = function (){
			return [this.sourceName()];
		};
		
		SourceMap.prototype.parse = function (){
			var self = this;
			var matcher = /\%\$(\d*)\$\%/;
			var replacer = /^(.*?)\%\$(\d*)\$\%/;
			var lines = this.options().js.split(/\n/g); // what about js?
			// return self
			var locmap = util.locationToLineColMap(this.sourceCode());
			this._maps = [];
			
			// console.log options:js
			
			var match;
			// split the code in lines. go through each line 
			// go through the code looking for LOC markers
			// remove markers along the way and keep track of
			// console.log source:js
			
			for (var i = 0, ary = iter$(lines), len = ary.length, line; i < len; i++) {
				// could split on these?
				line = ary[i];
				var col = 0;
				var caret = 0;
				
				this._maps[i] = [];
				while (line.match(matcher)){
					line = line.replace(replacer,function(m,pre,loc) {
						var lc = locmap[parseInt(loc)];
						caret = pre.length;
						var mapping = [[lc[0],lc[1]],[i,caret]]; // source and output
						self._maps[i].push(mapping);
						return pre;
					});
				};
				lines[i] = line;
			};
			
			
			self.source().js = lines.join('\n');
			return self;
		};
		
		SourceMap.prototype.generate = function (){
			this.parse();
			
			var lastColumn = 0;
			var lastSourceLine = 0;
			var lastSourceColumn = 0;
			var buffer = "";
			
			for (var lineNumber = 0, ary = iter$(this._maps), len = ary.length; lineNumber < len; lineNumber++) {
				lastColumn = 0;
				
				for (var nr = 0, items = iter$(ary[lineNumber]), len_ = items.length, map1; nr < len_; nr++) {
					map1 = items[nr];
					if (nr != 0) { buffer += ',' };
					var src = map1[0];
					var dest = map1[1];
					
					buffer += this.encodeVlq(dest[1] - lastColumn);
					lastColumn = dest[1];
					// add index
					buffer += this.encodeVlq(0);
					
					// The starting line in the original source, relative to the previous source line.
					buffer += this.encodeVlq(src[0] - lastSourceLine);
					lastSourceLine = src[0];
					// The starting column in the original source, relative to the previous column.
					buffer += this.encodeVlq(src[1] - lastSourceColumn);
					lastSourceColumn = src[1];
				};
				
				buffer += ";";
			};
			
			
			var rel = path.relative(path.dirname(this.targetPath()),this.sourcePath());
			
			var map = {
				version: 3,
				file: this.sourceName().replace(/\.imba/,'.js') || '',
				sourceRoot: this.options().sourceRoot || '',
				sources: [rel],
				sourcesContent: [this.sourceCode()],
				names: [],
				mappings: buffer
			};
			
			// source:sourcemap = sourcemap
			// var base64 = Buffer.new(JSON.stringify(map)).toString("base64")
			// source:js += "\n//# sourceMappingURL=data:application/json;base64,{base64}"
			return map;
		};
		
		VLQ_SHIFT = 5;
		VLQ_CONTINUATION_BIT = 1 << VLQ_SHIFT;
		VLQ_VALUE_MASK = VLQ_CONTINUATION_BIT - 1;
		BASE64_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
		
		// borrowed from CoffeeScript
		SourceMap.prototype.encodeVlq = function (value){
			var answer = '';
			// Least significant bit represents the sign.
			var signBit = value < 0 ? (1) : (0);
			var nextChunk;
			// The next bits are the actual value.
			var valueToEncode = (Math.abs(value) << 1) + signBit;
			// Make sure we encode at least one character, even if valueToEncode is 0.
			while (valueToEncode || !(answer)){
				nextChunk = valueToEncode & VLQ_VALUE_MASK;
				valueToEncode = valueToEncode >> VLQ_SHIFT;
				if (valueToEncode) {
					nextChunk |= VLQ_CONTINUATION_BIT;
				};
				
				answer += this.encodeBase64(nextChunk);
			};
			
			return answer;
		};
		
		SourceMap.prototype.encodeBase64 = function (value){
			return BASE64_CHARS[value]; // or throw Error.new("Cannot Base64 encode value: {value}")
		};
		return SourceMap;
		
		

	})()

/***/ },
/* 11 */
/***/ function(module, exports) {



/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYjBiZTdjMGM1NDY2YTI2NzIzZGYiLCJ3ZWJwYWNrOi8vL3NyYy9jb21waWxlci9jb21waWxlci5pbWJhIiwid2VicGFjazovLy9zcmMvY29tcGlsZXIvdG9rZW4uaW1iYSIsIndlYnBhY2s6Ly8vc3JjL2NvbXBpbGVyL2Vycm9ycy5pbWJhIiwid2VicGFjazovLy9zcmMvY29tcGlsZXIvaGVscGVycy5pbWJhIiwid2VicGFjazovLy9zcmMvY29tcGlsZXIvbGV4ZXIuaW1iYSIsIndlYnBhY2s6Ly8vc3JjL2NvbXBpbGVyL3Jld3JpdGVyLmltYmEiLCJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBpbGVyL3BhcnNlci5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovLy8od2VicGFjaykvfi9ub2RlLWxpYnMtYnJvd3Nlci9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vc3JjL2NvbXBpbGVyL25vZGVzLmltYmEiLCJ3ZWJwYWNrOi8vL3NyYy9jb21waWxlci9zb3VyY2VtYXAuaW1iYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7O21CQ3hCVzs7O01BWlAsRUFBRSxFQUFFO01BQ0osSUFBSSxFQUFFO01BQ04sS0FBSyxFQUFFO01BQ1AsTUFBTSxFQUFFO01BQ1IsU0FBUyxFQUFFO2lDQUNHLEVBQUU7TUFDaEIsSUFBSSxFQUFFOzs4Q0FFSDs7OzJCQUdRLE9BQUUsTUFBTTtpQkFDWixvQkFBUyxFQUFFLFNBQVM7O0VBRS9CLE9BQU8sTUFBTSxFQUFFLElB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF1QyxhQUFhO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBNkIsYUFBYTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFjLEdBQUc7SUFDakMsSUFBRztLQUNGLFVBQVUsR0FBRzs7O0lBRWQsT0FBTyxRQUFHLGFBQWE7OztVQUV4Qjs7O0VBRUQ7VUFDQyxhQUFhOztTQS9JRiIsImZpbGUiOiIuL2Rpc3QvaW1iYWMuZGV2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGlkOiBtb2R1bGVJZCxcbiBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiB3ZWJwYWNrL2Jvb3RzdHJhcCBiMGJlN2MwYzU0NjZhMjY3MjNkZlxuICoqLyIsIlxuIyB2YXIgaW1iYSA9IHJlcXVpcmUgJy4uL2ltYmEnXG52YXIgVCA9IHJlcXVpcmUgJy4vdG9rZW4nXG52YXIgRVJSID0gcmVxdWlyZSAnLi9lcnJvcnMnXG52YXIgdXRpbCA9IHJlcXVpcmUgJy4vaGVscGVycydcbnZhciBsZXhlciA9IHJlcXVpcmUgJy4vbGV4ZXInXG52YXIgcmV3cml0ZXIgPSByZXF1aXJlICcuL3Jld3JpdGVyJ1xuZXhwb3J0IHZhciBwYXJzZXIgPSByZXF1aXJlKCcuLi8uLi9saWIvY29tcGlsZXIvcGFyc2VyJylbJ3BhcnNlciddXG52YXIgYXN0ID0gcmVxdWlyZSAnLi9ub2RlcydcblxuaW1wb3J0IEltYmFQYXJzZUVycm9yIGZyb20gJy4vZXJyb3JzJ1xuXG4jIEluc3RhbnRpYXRlIGEgTGV4ZXIgZm9yIG91ciB1c2UgaGVyZS5cbmV4cG9ydCB2YXIgbGV4ID0gbGV4ZXIuTGV4ZXIubmV3XG5leHBvcnQgdmFyIFJld3JpdGVyID0gcmV3cml0ZXIuUmV3cml0ZXJcblxucGFyc2VyOmxleGVyID0gbGV4Lmppc29uQnJpZGdlXG5wYXJzZXI6eXkgPSBhc3QgIyBldmVyeXRoaW5nIGlzIGV4cG9ydGVkIHJpZ2h0IGhlcmUgbm93XG5cblxuZXhwb3J0IGRlZiB0b2tlbml6ZSBjb2RlLCBvID0ge31cblx0dHJ5XG5cdFx0by5Ac291cmNlID0gY29kZVxuXHRcdGxleC5yZXNldFxuXHRcdGxleC50b2tlbml6ZSBjb2RlLCBvXG5cdGNhdGNoIGVyclxuXHRcdHRocm93IGVyclxuXG5leHBvcnQgZGVmIHJld3JpdGUgdG9rZW5zLCBvID0ge31cblx0dmFyIHJld3JpdGVyID0gUmV3cml0ZXIubmV3XG5cdHRyeVxuXHRcdHJld3JpdGVyLnJld3JpdGUgdG9rZW5zLCBvXG5cdGNhdGNoIGVyclxuXHRcdHRocm93IGVyclxuXG5cbmV4cG9ydCBkZWYgcGFyc2UgY29kZSwgbyA9IHt9XG5cdHZhciB0b2tlbnMgPSBjb2RlIGlzYSBBcnJheSA/IGNvZGUgOiB0b2tlbml6ZShjb2RlLG8pXG5cdHRyeVxuXHRcdCMgY29uc29sZS5sb2coXCJUb2tlbnNcIix0b2tlbnMpXG5cdFx0by5Ac291cmNlIHx8PSBjb2RlIGlmIHRva2VucyAhPSBjb2RlXG5cdFx0by5AdG9rZW5zID0gdG9rZW5zXG5cdFx0cmV0dXJuIHBhcnNlci5wYXJzZSB0b2tlbnNcblx0Y2F0Y2ggZXJyXG5cdFx0ZXJyOl9maWxlbmFtZSA9IG86ZmlsZW5hbWUgaWYgbzpmaWxlbmFtZVxuXHRcdHRocm93IGVyclxuXG5cbmV4cG9ydCBkZWYgY29tcGlsZSBjb2RlLCBvID0ge31cblx0dHJ5XG5cdFx0dmFyIHRva2VucyA9IHRva2VuaXplKGNvZGUsIG8pXG5cdFx0dmFyIGFzdCA9IHBhcnNlKHRva2Vucywgbylcblx0XHRyZXR1cm4gYXN0LmNvbXBpbGUobylcblx0Y2F0Y2ggZXJyXG5cdFx0ZXJyOl9maWxlbmFtZSA9IG86ZmlsZW5hbWUgaWYgbzpmaWxlbmFtZVxuXHRcdHRva2VucyB8fD0gby5AdG9rZW5zXG5cblx0XHRpZiB0b2tlbnMgJiYgZXJyIGlzYSBJbWJhUGFyc2VFcnJvclxuXHRcdFx0dHJ5XG5cdFx0XHRcdHZhciB0b2sgPSBlcnIuc3RhcnRcblx0XHRcdGNhdGNoIGVcblx0XHRcdFx0dGhyb3cgZXJyXG5cblx0XHRcdHZhciBsb2NtYXAgPSB1dGlsLmxvY2F0aW9uVG9MaW5lQ29sTWFwKGNvZGUpXG5cdFx0XHR2YXIgbGluZXMgID0gY29kZS5zcGxpdCgvXFxuL2cpXG5cblx0XHRcdHZhciBsYyA9IGxvY21hcFt0b2suQGxvY10gb3IgWzAsMF1cblx0XHRcdHZhciBsbiA9IGxjWzBdXG5cdFx0XHR2YXIgY29sID0gbGNbMV1cblx0XHRcdHZhciBsaW5lID0gbGluZXNbbG5dXG5cblx0XHRcdHZhciBtZXNzYWdlID0gZXJyOm1lc3NhZ2UgKyBcIlxcblxcbntsbn1cIiArIFwiXFxue2xuICsgMX0ge2xpbmV9XCIgKyBcIlxcbntsbiArIDJ9XCJcblx0XHRcdHZhciByZWR1Y2VyID0gZG8gfHMsYyxpfFxuXHRcdFx0XHRzICs9IGkgPT0gY29sID8gXCJeXCIgOiAoYyA9PSBcIlxcdFwiID8gYyA6IFwiIFwiKVxuXHRcdFx0bWVzc2FnZSArPSBsaW5lLnNwbGl0KCcnKS5yZWR1Y2UocmVkdWNlciwgXCJcIilcblxuXHRcdFx0ZXJyOm1lc3NhZ2UgPSBtZXNzYWdlXG5cdFx0dGhyb3cgZXJyXG5cbmV4cG9ydCBkZWYgYW5hbHl6ZSBjb2RlLCBvID0ge31cblx0dmFyIG1ldGFcblx0dHJ5XG5cdFx0dmFyIGFzdCA9IHBhcnNlKGNvZGUsbylcblx0XHRtZXRhID0gYXN0LmFuYWx5emUobylcblx0Y2F0Y2ggZVxuXHRcdCMgY29uc29sZS5sb2cgXCJzb21ldGhpbmcgd3Jvbmcge2U6bWVzc2FnZX1cIlxuXHRcdHVubGVzcyBlIGlzYSBJbWJhUGFyc2VFcnJvclxuXHRcdFx0aWYgZTpsZXhlclxuXHRcdFx0XHRlID0gSW1iYVBhcnNlRXJyb3IubmV3KGUsIHRva2VuczogZTpsZXhlcjp0b2tlbnMsIHBvczogZTpsZXhlcjpwb3MpXG5cdFx0XHRlbHNlXG5cdFx0XHRcdHRocm93IGVcblx0XHRtZXRhID0ge3dhcm5pbmdzOiBbZV19XG5cdHJldHVybiBtZXRhXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBzcmMvY29tcGlsZXIvY29tcGlsZXIuaW1iYVxuICoqLyIsIlxuXG5leHBvcnQgdmFyIFRPSyA9IHt9XG52YXIgVFRFUk1JTkFUT1IgPSBUT0suVEVSTUlOQVRPUiA9IDFcbnZhciBUSURFTlRJRklFUiA9IFRPSy5JREVOVElGSUVSID0gVE9LLklWQVIgPSAyXG52YXIgQ09OU1QgPSBUT0suQ09OU1QgPSAzXG52YXIgVkFSID0gVE9LLlZBUiA9IDRcbnZhciBJRiA9IFRPSy5JRiA9IDVcbnZhciBFTFNFID0gVE9LLkVMU0UgPSA2XG52YXIgREVGID0gVE9LLkRFRiA9IDdcblxuZXhwb3J0IGNsYXNzIFRva2VuXG5cblx0ZGVmIGluaXRpYWxpemUgdHlwZSwgdmFsdWUsIGxvYywgbGVuXG5cdFx0QHR5cGUgID0gdHlwZVxuXHRcdEB2YWx1ZSA9IHZhbHVlXG5cdFx0QGxvYyAgID0gbG9jICE9IG51bGwgPyBsb2MgOiAtMVxuXHRcdEBsZW4gICA9IGxlbiBvciAwXG5cdFx0QG1ldGEgID0gbnVsbFxuXHRcdHRoaXM6Z2VuZXJhdGVkID0gbm9cblx0XHR0aGlzOm5ld0xpbmUgPSBub1xuXHRcdHRoaXM6c3BhY2VkID0gbm9cblx0XHRyZXR1cm4gc2VsZlxuXG5cdGRlZiB0eXBlXG5cdFx0QHR5cGVcblxuXHRkZWYgdmFsdWVcblx0XHRAdmFsdWVcblxuXHRkZWYgdHJhdmVyc2Vcblx0XHRyZXR1cm5cblx0XHRcblx0ZGVmIGNcblx0XHRcIlwiICsgQHZhbHVlXG5cblx0ZGVmIHRvU3RyaW5nXG5cdFx0QHZhbHVlXG5cblx0ZGVmIGNoYXJBdCBpXG5cdFx0QHZhbHVlLmNoYXJBdChpKVxuXG5cdGRlZiBzbGljZSBpXG5cdFx0QHZhbHVlLnNsaWNlKGkpXG5cblx0ZGVmIHJlZ2lvblxuXHRcdFtAbG9jLEBsb2MgKyAoQGxlbiBvciBAdmFsdWU6bGVuZ3RoKV1cblxuXHRkZWYgc291cmNlTWFwTWFya2VyXG5cdFx0QGxvYyA9PSAtMSA/ICc6JyA6IFwiJSR7QGxvY30kJVwiXG5cdFx0IyBAY29sID09IC0xID8gJycgOiBcIiUle0BsaW5lfSR7QGNvbH0lJVwiXG5cblxuZXhwb3J0IGRlZiBsZXhcblx0dmFyIHRva2VuID0gdGhpczp0b2tlbnNbdGhpczpwb3MrK11cblx0dmFyIHR0YWdcblxuXHRpZiB0b2tlblxuXHRcdHR0YWcgPSB0b2tlbi5AdHlwZVxuXHRcdHRoaXM6eXl0ZXh0ID0gdG9rZW5cblx0ZWxzZVxuXHRcdHR0YWcgPSAnJ1xuXG5cdHJldHVybiB0dGFnXG5cblxuIyBleHBvcnQgZGVmIHRva2VuIHR5cCwgdmFsLCBsaW5lLCBjb2wsIGxlbiBkbyBUb2tlbi5uZXcodHlwLHZhbCxsaW5lLCBjb2wgb3IgMCwgbGVuIG9yIDApICMgW251bGwsdHlwLHZhbCxsb2NdXG5leHBvcnQgZGVmIHRva2VuIHR5cCwgdmFsIGRvIFRva2VuLm5ldyh0eXAsdmFsLC0xLDApXG5cbmV4cG9ydCBkZWYgdHlwIHRvayBkbyB0b2suQHR5cGVcbmV4cG9ydCBkZWYgdmFsIHRvayBkbyB0b2suQHZhbHVlICMgdG9rW29mZnNldCArIDFdXG5leHBvcnQgZGVmIGxpbmUgdG9rIGRvIHRvay5AbGluZSAjIHRva1tvZmZzZXQgKyAyXVxuZXhwb3J0IGRlZiBsb2MgdG9rIGRvIHRvay5AbG9jICMgdG9rW29mZnNldCArIDJdXG5cbmV4cG9ydCBkZWYgc2V0VHlwIHRvaywgdiBkbyB0b2suQHR5cGUgPSB2XG5leHBvcnQgZGVmIHNldFZhbCB0b2ssIHYgZG8gdG9rLkB2YWx1ZSA9IHZcbmV4cG9ydCBkZWYgc2V0TGluZSB0b2ssIHYgZG8gdG9rLkBsaW5lID0gdlxuZXhwb3J0IGRlZiBzZXRMb2MgdG9rLCB2IGRvIHRvay5AbG9jID0gdlxuXG5cbmV4cG9ydCB2YXIgTEJSQUNLRVQgPSBUb2tlbi5uZXcoJ3snLCd7JywwLDAsMClcbmV4cG9ydCB2YXIgUkJSQUNLRVQgPSBUb2tlbi5uZXcoJ30nLCd9JywwLDAsMClcblxuZXhwb3J0IHZhciBMUEFSRU4gPSBUb2tlbi5uZXcoJygnLCcoJywwLDAsMClcbmV4cG9ydCB2YXIgUlBBUkVOID0gVG9rZW4ubmV3KCcpJywnKScsMCwwLDApXG5cbkxCUkFDS0VUOmdlbmVyYXRlZCA9IHllc1xuUkJSQUNLRVQ6Z2VuZXJhdGVkID0geWVzXG5MUEFSRU46Z2VuZXJhdGVkID0geWVzXG5SUEFSRU46Z2VuZXJhdGVkID0geWVzXG5cbmV4cG9ydCB2YXIgSU5ERU5UID0gVG9rZW4ubmV3KCdJTkRFTlQnLCcyJywwLDAsMClcbmV4cG9ydCB2YXIgT1VUREVOVCA9IFRva2VuLm5ldygnT1VUREVOVCcsJzInLDAsMCwwKVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHNyYy9jb21waWxlci90b2tlbi5pbWJhXG4gKiovIiwiIyBjcmVhdGUgc2VwYXJhdGUgZXJyb3ItdHlwZXMgd2l0aCBhbGwgdGhlIGxvZ2ljXG5cbmV4cG9ydCBjbGFzcyBJbWJhUGFyc2VFcnJvciA8IEVycm9yXG5cdFxuXHRkZWYgc2VsZi53cmFwIGVyclxuXHRcdCMgd2hhdCBhYm91dCB0aGUgc3RhY2t0cmFjZT9cblx0XHRJbWJhUGFyc2VFcnJvci5uZXcoZXJyKVxuXG5cdGRlZiBpbml0aWFsaXplIGUsb1xuXHRcdHRoaXM6ZXJyb3IgPSBlXG5cdFx0dGhpczptZXNzYWdlID0gZTptZXNzYWdlXG5cdFx0dGhpczpmaWxlbmFtZSA9IGU6ZmlsZW5hbWVcblx0XHR0aGlzOmxpbmUgPSBlOmxpbmVcblx0XHRAb3B0aW9ucyA9IG8gb3Ige31cblx0XHRzZWxmXG5cblx0ZGVmIHNldCBvcHRzXG5cdFx0QG9wdGlvbnMgfHw9IHt9XG5cdFx0Zm9yIG93biBrLHYgb2Ygb3B0c1xuXHRcdFx0QG9wdGlvbnNba10gPSB2XG5cdFx0c2VsZlxuXG5cdGRlZiBzdGFydFxuXHRcdHZhciBvID0gQG9wdGlvbnNcblx0XHR2YXIgaWR4ID0gbzpwb3MgLSAxXG5cdFx0dmFyIHRvayA9IG86dG9rZW5zIGFuZCBvOnRva2Vuc1tpZHhdXG5cdFx0dG9rID0gbzp0b2tlbnNbLS1pZHhdIHdoaWxlIHRvayBhbmQgdG9rLkBsb2MgPT0gLTFcblx0XHRyZXR1cm4gdG9rXG5cblx0ZGVmIGRlc2Ncblx0XHR2YXIgbyA9IEBvcHRpb25zXG5cdFx0bGV0IG1zZyA9IHNlbGY6bWVzc2FnZVxuXHRcdGlmIG86dG9rZW4gYW5kIG86dG9rZW4uQGxvYyA9PSAtMVxuXHRcdFx0J1N5bnRheCBFcnJvcidcblx0XHRlbHNlXG5cdFx0XHRtc2dcblx0XG5cdGRlZiBsb2Ncblx0XHRzdGFydD8ucmVnaW9uXG5cblx0ZGVmIHRvSlNPTlxuXHRcdHZhciBvID0gQG9wdGlvbnNcblx0XHR2YXIgdG9rID0gc3RhcnRcblx0XHQjIHZhciB0b2sgPSBvOnRva2VucyBhbmQgbzp0b2tlbnNbbzpwb3MgLSAxXVxuXHRcdCMgdmFyIGxvYyA9IHRvayBhbmQgW3Rvay5AbG9jLHRvay5AbG9jICsgKHRvay5AbGVuIG9yIHRvay5AdmFsdWU6bGVuZ3RoKV0gb3IgWzAsMF1cblx0XHQjICwgY29sOiB0b2suQGNvbCwgbGluZTogdG9rLkBsaW5lXG5cdFx0IyBnZXQgdGhlIHRva2VuIGl0c2VsZj9cblx0XHRyZXR1cm4ge3dhcm46IHllcywgbWVzc2FnZTogZGVzYywgbG9jOiBsb2N9XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBzcmMvY29tcGlsZXIvZXJyb3JzLmltYmFcbiAqKi8iLCJcbmV4cG9ydCBkZWYgYnJhY2Ugc3RyXG5cdHZhciBsaW5lcyA9IHN0ci5tYXRjaCgvXFxuLylcblx0IyB3aGF0IGFib3V0IGluZGVudGF0aW9uP1xuXG5cdGlmIGxpbmVzXG5cdFx0J3snICsgc3RyICsgJ1xcbn0nXG5cdGVsc2Vcblx0XHQne1xcbicgKyBzdHIgKyAnXFxufSdcblxuZXhwb3J0IGRlZiBub3JtYWxpemVJbmRlbnRhdGlvbiBzdHJcblx0dmFyIG1cblx0dmFyIHJlZyA9IC9cXG4rKFteXFxuXFxTXSopL2dcblx0dmFyIGluZCA9IG51bGxcblxuXHR3aGlsZSBtID0gcmVnLmV4ZWMoc3RyKVxuXHRcdHZhciBhdHRlbXB0ID0gbVsxXVxuXHRcdGlmIGluZCBpcyBudWxsIG9yIDAgPCBhdHRlbXB0Omxlbmd0aCA8IGluZDpsZW5ndGhcblx0XHRcdGluZCA9IGF0dGVtcHRcblxuXHRzdHIgPSBzdHIucmVwbGFjZShSZWdFeHAoXCJcXFxcbntpbmR9XCIsXCJnXCIpLCAnXFxuJykgaWYgaW5kXG5cdHJldHVybiBzdHJcblxuXG5leHBvcnQgZGVmIGZsYXR0ZW4gYXJyXG5cdHZhciBvdXQgPSBbXVxuXHRhcnIuZm9yRWFjaCBkbyB8dnwgdiBpc2EgQXJyYXkgPyBvdXQ6cHVzaC5hcHBseShvdXQsZmxhdHRlbih2KSkgOiBvdXQucHVzaCh2KVxuXHRyZXR1cm4gb3V0XG5cblxuZXhwb3J0IGRlZiBwYXNjYWxDYXNlIHN0clxuXHRzdHIucmVwbGFjZSgvKF58W1xcLVxcX1xcc10pKFxcdykvZykgZG8gfG0sdixsfCBsLnRvVXBwZXJDYXNlXG5cbmV4cG9ydCBkZWYgY2FtZWxDYXNlIHN0clxuXHRzdHIgPSBTdHJpbmcoc3RyKVxuXHQjIHNob3VsZCBhZGQgc2hvcnRjdXQgb3V0XG5cdHN0ci5yZXBsYWNlKC8oW1xcLVxcX1xcc10pKFxcdykvZykgZG8gfG0sdixsfCBsLnRvVXBwZXJDYXNlXG5cbmV4cG9ydCBkZWYgc25ha2VDYXNlIHN0clxuXHR2YXIgc3RyID0gc3RyLnJlcGxhY2UoLyhbXFwtXFxzXSkoXFx3KS9nLCdfJylcblx0c3RyLnJlcGxhY2UoLygpKFtBLVpdKS9nLFwiXyQxXCIpIGRvIHxtLHYsbHwgbC50b1VwcGVyQ2FzZVxuXG5leHBvcnQgZGVmIHNldHRlclN5bSBzeW1cblx0Y2FtZWxDYXNlKFwic2V0LXtzeW19XCIpXG5cbmV4cG9ydCBkZWYgcXVvdGUgc3RyXG5cdCdcIicgKyBzdHIgKyAnXCInXG5cbmV4cG9ydCBkZWYgc2luZ2xlcXVvdGUgc3RyXG5cdFwiJ1wiICsgc3RyICsgXCInXCJcblxuZXhwb3J0IGRlZiBzeW1ib2xpemUgc3RyXG5cdHN0ciA9IFN0cmluZyhzdHIpXG5cdHZhciBlbmQgPSBzdHIuY2hhckF0KHN0cjpsZW5ndGggLSAxKVxuXG5cdGlmIGVuZCA9PSAnPSdcblx0XHRzdHIgPSAnc2V0JyArIHN0clswXS50b1VwcGVyQ2FzZSArIHN0ci5zbGljZSgxLC0xKVxuXG5cdGlmIHN0ci5pbmRleE9mKFwiLVwiKSA+PSAwXG5cdFx0c3RyID0gc3RyLnJlcGxhY2UoLyhbXFwtXFxzXSkoXFx3KS9nKSBkbyB8bSx2LGx8IGwudG9VcHBlckNhc2Vcblx0XHRcdFxuXHRyZXR1cm4gc3RyXG5cblxuZXhwb3J0IGRlZiBpbmRlbnQgc3RyXG5cdFN0cmluZyhzdHIpLnJlcGxhY2UoL14vZyxcIlxcdFwiKS5yZXBsYWNlKC9cXG4vZyxcIlxcblxcdFwiKS5yZXBsYWNlKC9cXG5cXHQkL2csXCJcXG5cIilcblxuZXhwb3J0IGRlZiBicmFja2V0aXplIHN0ciwgaW5kID0geWVzXG5cdHN0ciA9IFwiXFxuXCIgKyBpbmRlbnQoc3RyKSArIFwiXFxuXCIgaWYgaW5kXG5cdCd7JyArIHN0ciArICd9J1xuXHRcbmV4cG9ydCBkZWYgcGFyZW50aGVzaXplIHN0clxuXHQnKCcgKyBTdHJpbmcoc3RyKSArICcpJ1xuXG5leHBvcnQgZGVmIGxvY2F0aW9uVG9MaW5lQ29sTWFwIGNvZGVcblx0dmFyIGxpbmVzID0gY29kZS5zcGxpdCgvXFxuL2cpXG5cdHZhciBtYXAgPSBbXVxuXG5cdHZhciBjaHJcblx0dmFyIGxvYyA9IDBcblx0dmFyIGNvbCA9IDBcblx0dmFyIGxpbmUgPSAwXG5cblx0d2hpbGUgY2hyID0gY29kZVtsb2NdXG5cdFx0bWFwW2xvY10gPSBbbGluZSxjb2xdXG5cblx0XHRpZiBjaHIgPT0gJ1xcbidcblx0XHRcdGxpbmUrK1xuXHRcdFx0Y29sID0gMFxuXHRcdGVsc2Vcblx0XHRcdGNvbCsrXG5cblx0XHRsb2MrK1xuXG5cdHJldHVybiBtYXBcblxuZXhwb3J0IGRlZiBtYXJrTGluZUNvbEZvclRva2VucyB0b2tlbnMsIGNvZGVcblx0c2VsZlxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHNyYy9jb21waWxlci9oZWxwZXJzLmltYmFcbiAqKi8iLCJcbnZhciBUID0gcmVxdWlyZSAnLi90b2tlbidcbnZhciBUb2tlbiA9IFQuVG9rZW5cblxudmFyIHJ3ID0gcmVxdWlyZSAnLi9yZXdyaXRlcidcbnZhciBSZXdyaXRlciA9IHJ3LlJld3JpdGVyXG52YXIgSU5WRVJTRVMgPSBydy5JTlZFUlNFU1xuXG52YXIgSyA9IDBcblxudmFyIEVSUiA9IHJlcXVpcmUgJy4vZXJyb3JzJ1xuXG4jIENvbnN0YW50c1xuIyAtLS0tLS0tLS1cblxuIyBLZXl3b3JkcyB0aGF0IEltYmEgc2hhcmVzIGluIGNvbW1vbiB3aXRoIEphdmFTY3JpcHQuXG52YXIgSlNfS0VZV09SRFMgPSBbXG5cdCd0cnVlJywgJ2ZhbHNlJywgJ251bGwnLCAndGhpcydcblx0J2RlbGV0ZScsICd0eXBlb2YnLCAnaW4nLCAnaW5zdGFuY2VvZidcblx0J3Rocm93JywgJ2JyZWFrJywgJ2NvbnRpbnVlJywgJ2RlYnVnZ2VyJ1xuXHQnaWYnLCAnZWxzZScsICdzd2l0Y2gnLCAnZm9yJywgJ3doaWxlJywgJ2RvJywgJ3RyeScsICdjYXRjaCcsICdmaW5hbGx5J1xuXHQnY2xhc3MnLCAnZXh0ZW5kcycsICdzdXBlcicsICdyZXR1cm4nXG5dXG5cbiMgbmV3IGNhbiBiZSB1c2VkIGFzIGEga2V5d29yZCBpbiBpbWJhLCBzaW5jZSBvYmplY3QgaW5pdGluZyBpcyBkb25lIHRocm91Z2hcbiMgTXlPYmplY3QubmV3LiBuZXcgaXMgYSB2ZXJ5IHVzZWZ1bCB2YXJuYW1lLlxuXG4jIFdlIHdhbnQgdG8gdHJlYXQgcmV0dXJuIGxpa2UgYW55IHJlZ3VsYXIgY2FsbCBmb3Igbm93XG4jIE11c3QgYmUgY2FyZWZ1bCB0byB0aHJvdyB0aGUgZXhjZXB0aW9ucyBpbiBBU1QsIHNpbmNlIHRoZSBwYXJzZXJcbiMgd29udFxuXG4jIEltYmEtb25seSBrZXl3b3Jkcy4gdmFyIHNob3VsZCBtb3ZlIHRvIEpTX0tleXdvcmRzXG4jIHNvbWUgd29yZHMgKGxpa2UgdG9raWQpIHNob3VsZCBiZSBjb250ZXh0LXNwZWNpZmljXG52YXIgSU1CQV9LRVlXT1JEUyA9IFtcblx0J3VuZGVmaW5lZCcsICd0aGVuJywgJ3VubGVzcycsICd1bnRpbCcsICdsb29wJywgJ29mJywgJ2J5Jyxcblx0J3doZW4nLCdkZWYnLCd0YWcnLCdkbycsJ2VsaWYnLCdiZWdpbicsJ3ZhcicsJ2xldCcsJ3NlbGYnLCdhd2FpdCcsJ2ltcG9ydCdcbl1cblxudmFyIElNQkFfQ09OVEVYVFVBTF9LRVlXT1JEUyA9IFsnZXh0ZW5kJywnc3RhdGljJywnbG9jYWwnLCdleHBvcnQnLCdnbG9iYWwnLCdwcm9wJ11cblxudmFyIElNQkFfQUxJQVNfTUFQID1cblx0J2FuZCcgIDogJyYmJ1xuXHQnb3InICAgOiAnfHwnXG5cdCdpcycgICA6ICc9PSdcblx0J2lzbnQnIDogJyE9J1xuXHQnbm90JyAgOiAnISdcblx0J3llcycgIDogJ3RydWUnXG5cdCdubycgICA6ICdmYWxzZSdcblx0J2lzYScgIDogJ2luc3RhbmNlb2YnXG5cdCdjYXNlJyA6ICdzd2l0Y2gnXG5cdCduaWwnICA6ICdudWxsJ1xuXG52YXIgSU1CQV9BTElBU0VTICA9IE9iamVjdC5rZXlzKElNQkFfQUxJQVNfTUFQKVxuSU1CQV9LRVlXT1JEUyA9IElNQkFfS0VZV09SRFMuY29uY2F0KElNQkFfQUxJQVNFUylcblxuIyBGaXhlZEFycmF5IGZvciBwZXJmb3JtYW5jZVxuIyB2YXIgQUxMX0tFWVdPUkRTID0gSlNfS0VZV09SRFMuY29uY2F0KElNQkFfS0VZV09SRFMpXG5leHBvcnQgdmFyIEFMTF9LRVlXT1JEUyA9IFtcblx0J3RydWUnLCAnZmFsc2UnLCAnbnVsbCcsICd0aGlzJyxcblx0J2RlbGV0ZScsICd0eXBlb2YnLCAnaW4nLCAnaW5zdGFuY2VvZicsXG5cdCd0aHJvdycsICdicmVhaycsICdjb250aW51ZScsICdkZWJ1Z2dlcicsXG5cdCdpZicsICdlbHNlJywgJ3N3aXRjaCcsICdmb3InLCAnd2hpbGUnLCAnZG8nLCAndHJ5JywgJ2NhdGNoJywgJ2ZpbmFsbHknLFxuXHQnY2xhc3MnLCAnZXh0ZW5kcycsICdzdXBlcicsICdyZXR1cm4nLFxuXHQndW5kZWZpbmVkJywgJ3RoZW4nLCAndW5sZXNzJywgJ3VudGlsJywgJ2xvb3AnLCAnb2YnLCAnYnknLFxuXHQnd2hlbicsJ2RlZicsJ3RhZycsJ2RvJywnZWxpZicsJ2JlZ2luJywndmFyJywnbGV0Jywnc2VsZicsJ2F3YWl0JywnaW1wb3J0Jyxcblx0J2FuZCcsJ29yJywnaXMnLCdpc250Jywnbm90JywneWVzJywnbm8nLCdpc2EnLCdjYXNlJywnbmlsJ1xuXVxuXG4jIFRoZSBsaXN0IG9mIGtleXdvcmRzIHRoYXQgYXJlIHJlc2VydmVkIGJ5IEphdmFTY3JpcHQsIGJ1dCBub3QgdXNlZCwgb3IgYXJlXG4jIHVzZWQgYnkgSW1iYSBpbnRlcm5hbGx5LiBXZSB0aHJvdyBhbiBlcnJvciB3aGVuIHRoZXNlIGFyZSBlbmNvdW50ZXJlZCxcbiMgdG8gYXZvaWQgaGF2aW5nIGEgSmF2YVNjcmlwdCBlcnJvciBhdCBydW50aW1lLiAgIyAndmFyJywgJ2xldCcsIC0gbm90IGluc2lkZSBoZXJlXG52YXIgUkVTRVJWRUQgPSBbJ2Nhc2UnLCAnZGVmYXVsdCcsICdmdW5jdGlvbicsICd2b2lkJywgJ3dpdGgnLCAnY29uc3QnLCAnZW51bScsICduYXRpdmUnXVxudmFyIFNUUklDVF9SRVNFUlZFRCA9IFsnY2FzZScsJ2Z1bmN0aW9uJywndm9pZCcsJ2NvbnN0J11cblxuIyBUaGUgc3VwZXJzZXQgb2YgYm90aCBKYXZhU2NyaXB0IGtleXdvcmRzIGFuZCByZXNlcnZlZCB3b3Jkcywgbm9uZSBvZiB3aGljaCBtYXlcbiMgYmUgdXNlZCBhcyBpZGVudGlmaWVycyBvciBwcm9wZXJ0aWVzLlxudmFyIEpTX0ZPUkJJRERFTiA9IEpTX0tFWVdPUkRTLmNvbmNhdCBSRVNFUlZFRFxuXG52YXIgTUVUSE9EX0lERU5USUZJRVIgPSAvLy8gXlxuXHQoIFxuXHRcdCgoW1xceDIzXT9bXFwkQS1aYS16X1xceDdmLVxcdWZmZmZdWyRcXC1cXHdcXHg3Zi1cXHVmZmZmXSopKFtcXD1dPykpIHwgXG5cdFx0KDw9PnxcXHwoPyFbXFx8PV0pKVxuXHQpXG4vLy9cbiMgcmVtb3ZlZCB+PXx+fCB8Jig/IVsmPV0pXG5cbiMgVG9rZW4gbWF0Y2hpbmcgcmVnZXhlcy5cbiMgYWRkZWQgaHlwaGVucyB0byBpZGVudGlmaWVycyBub3cgLSB0byB0ZXN0XG52YXIgSURFTlRJRklFUiA9IC8vLyBeXG5cdChcblx0XHQoXFwkfEBAfEB8XFwjKVtcXHdBLVphLXpfXFwtXFx4N2YtXFx1ZmZmZl1bJFxcd1xceDdmLVxcdWZmZmZdKiAoXFwtWyRcXHdcXHg3Zi1cXHVmZmZmXSspKiB8XG5cdFx0WyRBLVphLXpfXVskXFx3XFx4N2YtXFx1ZmZmZl0qIChcXC1bJFxcd1xceDdmLVxcdWZmZmZdKykqXG5cdClcblx0KCBbXlxcblxcU10qIDogKD8hW1xcKlxcPTokXFx3XFx4N2YtXFx1ZmZmZl0pICk/ICAjIElzIHRoaXMgYSBwcm9wZXJ0eSBuYW1lP1xuLy8vXG5cbnZhciBPQkpFQ1RfS0VZID0gLy8vIF5cblx0KCAoXFwkfEBAfEB8KVskQS1aYS16X1xceDdmLVxcdWZmZmZcXC1dWyRcXHdcXHg3Zi1cXHVmZmZmXFwtXSopXG5cdCggW15cXG5cXFNcXHNdKiA6ICg/IVtcXCpcXD06JFxcd1xceDdmLVxcdWZmZmZdKSApICAjIElzIHRoaXMgYSBwcm9wZXJ0eSBuYW1lP1xuLy8vXG5cbnZhciBUQUcgPSAvLy8gXlxuXHQoXFw8fCUpKD89W0EtWmEtelxcI1xcLlxce1xcQFxcPl0pXG4vLy9cblxudmFyIFRBR19UWVBFID0gL14oXFx3W1xcd1xcZF0qOik/KFxcd1tcXHdcXGRdKikoLVtcXHdcXGRdKykqL1xudmFyIFRBR19JRCA9IC9eIygoXFx3W1xcd1xcZF0qKSgtW1xcd1xcZF0rKSopL1xuXG52YXIgVEFHX0FUVFIgPSAvXihbXFwuXFw6XT9bXFx3XFxfXSsoW1xcLVxcOl1bXFx3XSspKikoXFxzKSpcXD0vXG5cbnZhciBTRUxFQ1RPUiA9IC9eKFslXFwkXXsxLDJ9KShbXFwoXFx3XFwjXFwuXFxbXSkvXG52YXIgU0VMRUNUT1JfUEFSVCA9IC9eKFxcI3xcXC58Onw6Oik/KFtcXHddKyhcXC1bXFx3XSspKikvXG52YXIgU0VMRUNUT1JfQ09NQklOQVRPUiA9IC9eIChcXCt8XFw+fFxcfikqXFxzKig/PVtcXHdcXC5cXCNcXDpcXHtcXCpcXFtdKS9cblxudmFyIFNFTEVDVE9SX1BTRVVET19DTEFTUyA9IC9eKDo6PykoW1xcd10rKFxcLVtcXHddKykqKS9cbnZhciBTRUxFQ1RPUl9BVFRSX09QID0gL14oXFwkPXxcXH49fFxcXj18XFwqPXxcXHw9fD18XFwhPSkvXG52YXIgU0VMRUNUT1JfQVRUUiA9IC9eXFxbKFtcXHdcXF9cXC1dKykoXFwkPXxcXH49fFxcXj18XFwqPXxcXHw9fD18XFwhPSkvXG5cbnZhciBTWU1CT0wgPSAvLy9eXG5cdFxcOihcblx0XHQoXG5cdFx0XHQoW1xcKlxcQCRcXHdcXHg3Zi1cXHVmZmZmXSspKyhbXFwtXFwvXFxcXFxcOl1bXFx3XFx4N2YtXFx1ZmZmZl0rKSpcblx0XHQpfD09fFxcPD1cXD58XFxbXFxdfFxcW1xcXVxcPXxcXCp8W1xcLyxcXFxcXVxuXHQpXG4vLy9cblxuXG52YXIgTlVNQkVSID0gLy8vXG5cdF4gMHhbXFxkYS1mXSsgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICMgaGV4XG5cdF4gMGJbMDFdKyB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIyBiaW5hcnlcblx0XiBcXGQqXFwuP1xcZCsgKD86ZVsrLV0/XFxkKyk/ICAjIGRlY2ltYWxcbi8vL2lcblxudmFyIEhFUkVET0MgPSAvLy8gXiAoXCJcIlwifCcnJykgKFtcXHNcXFNdKj8pICg/OlxcblteXFxuXFxTXSopPyBcXDEgLy8vXG5cbnZhciBPUEVSQVRPUiA9IC8vLyBeIChcblx0PzogWy09XT0+ICAgICAgICAgICAgICMgZnVuY3Rpb24gLSB3aGF0XG5cdCB8ID09PVxuXHQgfCAtPlxuXHQgfCAhPT1cblx0IHwgWy0rKi8lPD4mfF4hPz1dPSAgIyBjb21wb3VuZCBhc3NpZ24gLyBjb21wYXJlXG5cdCB8ID08XG5cdCB8ID4+Pj0/ICAgICAgICAgICAgICMgemVyby1maWxsIHJpZ2h0IHNoaWZ0XG5cdCB8IChbLSs6XSlcXDEgICAgICAgICAjIGRvdWJsZXNcblx0IHwgKFsmfDw+XSlcXDI9PyAgICAgICMgbG9naWMgLyBzaGlmdFxuXHQgfCBcXD9cXC4gICAgICAgICAgICAgICMgc29hayBhY2Nlc3Ncblx0IHwgXFw/XFw6ICAgICAgICAgICAgICAjIHNvYWsgc3ltYm9sXG5cdCB8IFxcLnsyLDN9ICAgICAgICAgICAjIHJhbmdlIG9yIHNwbGF0XG5cdCB8IFxcKig/PVthLXpBLVpcXF9dKSAgICMgc3BsYXQgLS0gXG4pIC8vL1xuXG4jIEZJWE1FIHNwbGF0IHNob3VsZCBvbmx5IGJlIGFsbG93ZWQgd2hlbiB0aGUgcHJldmlvdXMgdGhpbmcgaXMgc3BhY2VkIG9yIGluc2lkZSBjYWxsP1xuXG52YXIgV0hJVEVTUEFDRSA9IC9eW15cXG5cXFNdKy9cblxudmFyIENPTU1FTlQgICAgPSAvXiMjIyhbXiNdW1xcc1xcU10qPykoPzojIyNbXlxcblxcU10qfCg/OiMjIyk/JCkvXG4jIENPTU1FTlQgICAgPSAvXiMjIyhbXiNdW1xcc1xcU10qPykoPzojIyNbXlxcblxcU10qfCg/OiMjIyk/JCl8Xig/OlxccyooI1xccy4qfCNcXHMqJCkpKy9cbnZhciBJTkxJTkVfQ09NTUVOVCA9IC9eKFxccyopKCNbIFxcdFxcIV0oLiopfCNbIFxcdF0/KD89XFxufCQpKSsvXG5cbnZhciBDT0RFICAgICAgID0gL15bLT1dPT4vXG5cbnZhciBNVUxUSV9ERU5UID0gL14oPzpcXG5bXlxcblxcU10qKSsvXG5cbnZhciBTSU1QTEVTVFIgID0gL14nW15cXFxcJ10qKD86XFxcXC5bXlxcXFwnXSopKicvXG5cbnZhciBKU1RPS0VOICAgID0gL15gW15cXFxcYF0qKD86XFxcXC5bXlxcXFxgXSopKmAvXG5cbiMgUmVnZXgtbWF0Y2hpbmctcmVnZXhlcy5cbnZhciBSRUdFWCA9IC8vLyBeXG5cdCgvICg/ISBbXFxzPV0gKSAgICMgZGlzYWxsb3cgbGVhZGluZyB3aGl0ZXNwYWNlIG9yIGVxdWFscyBzaWduc1xuXHRbXiBbIC8gXFxuIFxcXFwgXSogICMgZXZlcnkgb3RoZXIgdGhpbmdcblx0KD86XG5cdFx0KD86IFxcXFxbXFxzXFxTXSAgICMgYW55dGhpbmcgZXNjYXBlZFxuXHRcdFx0fCBcXFsgICAgICAgICAjIGNoYXJhY3RlciBjbGFzc1xuXHRcdFx0XHRcdCBbXiBcXF0gXFxuIFxcXFwgXSpcblx0XHRcdFx0XHQgKD86IFxcXFxbXFxzXFxTXSBbXiBcXF0gXFxuIFxcXFwgXSogKSpcblx0XHRcdFx0IF1cblx0XHQpIFteIFsgLyBcXG4gXFxcXCBdKlxuXHQpKlxuXHQvKSAoW2ltZ3ldezAsNH0pICg/IVxcdylcbi8vL1xuXG52YXIgSEVSRUdFWCAgICAgID0gLy8vIF4gL3szfSAoW1xcc1xcU10rPykgL3szfSAoW2ltZ3ldezAsNH0pICg/IVxcdykgLy8vXG5cbnZhciBIRVJFR0VYX09NSVQgPSAvXFxzKyg/OiMuKik/L2dcblxuIyBUb2tlbiBjbGVhbmluZyByZWdleGVzLlxudmFyIE1VTFRJTElORVIgICAgICA9IC9cXG4vZ1xuXG52YXIgSEVSRURPQ19JTkRFTlQgID0gL1xcbisoW15cXG5cXFNdKikvZ1xuXG52YXIgSEVSRURPQ19JTExFR0FMID0gL1xcKlxcLy9cblxuIyBleHBlbnNpdmU/XG52YXIgTElORV9DT05USU5VRVIgID0gLy8vIF4gXFxzKiAoPzogLCB8IFxcPz9cXC4oPyFbLlxcZF0pIHwgOjogKSAvLy9cblxudmFyIFRSQUlMSU5HX1NQQUNFUyA9IC9cXHMrJC9cblxudmFyIENPTlNUX0lERU5USUZJRVIgPSAvXltBLVpdL1xuXG52YXIgQVJHVkFSID0gL15cXCRcXGQkL1xuXG4jIENvbXBvdW5kIGFzc2lnbm1lbnQgdG9rZW5zLlxudmFyIENPTVBPVU5EX0FTU0lHTiA9IFsgJy09JywgJys9JywgJy89JywgJyo9JywgJyU9JywgJ3x8PScsICcmJj0nLCAnPz0nLCAnPDw9JywgJz4+PScsICc+Pj49JywgJyY9JywgJ149JywgJ3w9JywnPTwnXVxuXG4jIFVuYXJ5IHRva2Vucy5cbnZhciBVTkFSWSA9IFsnIScsICd+JywgJ05FVycsICdUWVBFT0YnLCAnREVMRVRFJ11cblxuIyBMb2dpY2FsIHRva2Vucy5cbnZhciBMT0dJQyAgID0gWycmJicsICd8fCcsICcmJywgJ3wnLCAnXiddXG5cbiMgQml0LXNoaWZ0aW5nIHRva2Vucy5cbnZhciBTSElGVCAgID0gWyc8PCcsICc+PicsICc+Pj4nXVxuXG4jIENvbXBhcmlzb24gdG9rZW5zLlxudmFyIENPTVBBUkUgPSBbJz09PScsICchPT0nLCAnPT0nLCAnIT0nLCAnPCcsICc+JywgJzw9JywgJz49JywnPT09JywnIT09J11cblxuIyBPdmVyaWRlYWJsZSBtZXRob2RzXG52YXIgT1BfTUVUSE9EUyA9IFsnPD0+JywnPDwnLCcuLiddXG5cbiMgTWF0aGVtYXRpY2FsIHRva2Vucy5cbnZhciBNQVRIID0gWycqJywgJy8nLCAnJScsICfiiKonLCAn4oipJywn4oiaJ11cblxuIyBSZWxhdGlvbmFsIHRva2VucyB0aGF0IGFyZSBuZWdhdGFibGUgd2l0aCBgbm90YCBwcmVmaXguXG52YXIgUkVMQVRJT04gPSBbJ0lOJywgJ09GJywgJ0lOU1RBTkNFT0YnLCdJU0EnXVxuXG4jIEJvb2xlYW4gdG9rZW5zLlxudmFyIEJPT0wgPSBbJ1RSVUUnLCAnRkFMU0UnLCAnTlVMTCcsICdVTkRFRklORUQnXVxuXG4jIE91ciBsaXN0IGlzIHNob3J0ZXIsIGR1ZSB0byBzYW5zLXBhcmVudGhlc2VzIG1ldGhvZCBjYWxscy5cbnZhciBOT1RfUkVHRVggPSBbJ05VTUJFUicsICdSRUdFWCcsICdCT09MJywgJ1RSVUUnLCAnRkFMU0UnLCAnKysnLCAnLS0nLCAnXSddXG5cbiMgSWYgdGhlIHByZXZpb3VzIHRva2VuIGlzIG5vdCBzcGFjZWQsIHRoZXJlIGFyZSBtb3JlIHByZWNlZGluZyB0b2tlbnMgdGhhdFxuIyBmb3JjZSBhIGRpdmlzaW9uIHBhcnNlOlxudmFyIE5PVF9TUEFDRURfUkVHRVggPSBbJ05VTUJFUicsICdSRUdFWCcsICdCT09MJywgJ1RSVUUnLCAnRkFMU0UnLCAnKysnLCAnLS0nLCAnXScsJyknLCAnfScsICdUSElTJywgJ1NFTEYnICwgJ0lERU5USUZJRVInLCAnU1RSSU5HJ11cblxuIyBUb2tlbnMgd2hpY2ggY291bGQgbGVnaXRpbWF0ZWx5IGJlIGludm9rZWQgb3IgaW5kZXhlZC4gQW4gb3BlbmluZ1xuIyBwYXJlbnRoZXNlcyBvciBicmFja2V0IGZvbGxvd2luZyB0aGVzZSB0b2tlbnMgd2lsbCBiZSByZWNvcmRlZCBhcyB0aGUgc3RhcnRcbiMgb2YgYSBmdW5jdGlvbiBpbnZvY2F0aW9uIG9yIGluZGV4aW5nIG9wZXJhdGlvbi5cbiMgcmVhbGx5PyFcblxudmFyIFVORklOSVNIRUQgPSBbJ1xcXFwnLCcuJywgJz8uJywgJz86JywgJ1VOQVJZJywgJ01BVEgnLCAnKycsICctJywgJ1NISUZUJywgJ1JFTEFUSU9OJywgJ0NPTVBBUkUnLCAnTE9HSUMnLCAnQ09NUE9VTkRfQVNTSUdOJywgJ1RIUk9XJywgJ0VYVEVORFMnXVxuXG4jIH0gc2hvdWxkIG5vdCBiZSBjYWxsYWJsZSBhbnltb3JlISEhICd9JywgJzo6JyxcbnZhciBDQUxMQUJMRSAgPSBbJ0lERU5USUZJRVInLCAnU1RSSU5HJywgJ1JFR0VYJywgJyknLCAnXScsICdUSElTJywgJ1NVUEVSJywgJ1RBR19FTkQnLCAnSVZBUicsICdHVkFSJywnU0VMRicsJ0NPTlNUJywnTkVXJywnQVJHVkFSJywnU1lNQk9MJywnUkVUVVJOJ11cbiMgdmFyIElOREVYQUJMRSA9IENBTExBQkxFLmNvbmNhdCAnTlVNQkVSJywgJ0JPT0wnLCAnVEFHX1NFTEVDVE9SJywgJ0lEUkVGJywgJ0FSR1VNRU5UUycsJ30nICMgYXJlIGJvb2xlYW5zIGluZGV4YWJsZT8gcmVhbGx5P1xuIyBvcHRpbWl6ZSBmb3IgRml4ZWRBcnJheVxudmFyIElOREVYQUJMRSA9IFtcblx0J0lERU5USUZJRVInLCAnU1RSSU5HJywgJ1JFR0VYJywgJyknLCAnXScsICdUSElTJywgJ1NVUEVSJywgJ1RBR19FTkQnLCAnSVZBUicsICdHVkFSJywnU0VMRicsJ0NPTlNUJywnTkVXJywnQVJHVkFSJywnU1lNQk9MJywnUkVUVVJOJ1xuXHQnTlVNQkVSJywgJ0JPT0wnLCAnVEFHX1NFTEVDVE9SJywgJ0lEUkVGJywgJ0FSR1VNRU5UUycsJ30nLCdUQUdfVFlQRSdcbl1cblxudmFyIEdMT0JBTF9JREVOVElGSUVSUyA9IFsnZ2xvYmFsJywnZXhwb3J0cycsJ3JlcXVpcmUnXVxuXG4jIFRva2VucyB0aGF0LCB3aGVuIGltbWVkaWF0ZWx5IHByZWNlZGluZyBhIGBXSEVOYCwgaW5kaWNhdGUgdGhhdCB0aGUgYFdIRU5gXG4jIG9jY3VycyBhdCB0aGUgc3RhcnQgb2YgYSBsaW5lLiBXZSBkaXNhbWJpZ3VhdGUgdGhlc2UgZnJvbSB0cmFpbGluZyB3aGVucyB0b1xuIyBhdm9pZCBhbiBhbWJpZ3VpdHkgaW4gdGhlIGdyYW1tYXIuXG52YXIgTElORV9CUkVBSyA9IFsnSU5ERU5UJywgJ09VVERFTlQnLCAnVEVSTUlOQVRPUiddXG5cblxuZXhwb3J0IGNsYXNzIExleGVyRXJyb3IgPCBTeW50YXhFcnJvclxuXHRcblx0ZGVmIGluaXRpYWxpemUgbWVzc2FnZSwgZmlsZSwgbGluZVxuXHRcdHNlbGY6bWVzc2FnZSA9IG1lc3NhZ2Vcblx0XHRzZWxmOmZpbGUgPSBmaWxlXG5cdFx0c2VsZjpsaW5lID0gbGluZVxuXHRcdHJldHVybiBzZWxmXG5cblxuZGVmIGxhc3QgYXJyYXksIGJhY2sgPSAwXG5cdGFycmF5W2FycmF5Omxlbmd0aCAtIGJhY2sgLSAxXVxuXG5kZWYgY291bnQgc3RyLCBzdWJzdHJcblx0cmV0dXJuIHN0ci5zcGxpdChzdWJzdHIpOmxlbmd0aCAtIDFcblx0XG5kZWYgcmVwZWF0U3RyaW5nIHN0ciwgdGltZXNcblx0dmFyIHJlcyA9ICcnXG5cdHdoaWxlIHRpbWVzID4gMFxuXHRcdGlmIHRpbWVzICUgMiA9PSAxXG5cdFx0XHRyZXMgKz0gc3RyXG5cdFx0c3RyICs9IHN0clxuXHRcdHRpbWVzID4+PSAxXG5cdHJldHVybiByZXNcblxudmFyIHRUICA9IFQ6dHlwXG52YXIgdFYgID0gVDp2YWxcbnZhciB0VHMgPSBUOnNldFR5cFxudmFyIHRWcyA9IFQ6c2V0VmFsXG5cbiMgVGhlIExleGVyIGNsYXNzIHJlYWRzIGEgc3RyZWFtIG9mIEltYmEgYW5kIGRpdnZpZXMgaXQgdXAgaW50byB0b2tpZGdlZFxuIyB0b2tlbnMuIFNvbWUgcG90ZW50aWFsIGFtYmlndWl0eSBpbiB0aGUgZ3JhbW1hciBoYXMgYmVlbiBhdm9pZGVkIGJ5XG4jIHB1c2hpbmcgc29tZSBleHRyYSBzbWFydHMgaW50byB0aGUgTGV4ZXIuXG5cbiMgQmFzZWQgb24gdGhlIG9yaWdpbmFsIGxleGVyLmNvZmZlZSBmcm9tIENvZmZlZVNjcmlwdFxuZXhwb3J0IGNsYXNzIExleGVyXG5cblx0ZGVmIGluaXRpYWxpemVcblx0XHRyZXNldFxuXHRcdHNlbGZcblxuXHRkZWYgcmVzZXRcblx0XHRAY29kZSAgICA9IG51bGxcblx0XHRAY2h1bmsgICA9IG51bGwgICAgICAgICAgICMgVGhlIHJlbWFpbmRlciBvZiB0aGUgc291cmNlIGNvZGUuXG5cdFx0QG9wdHMgICAgPSBudWxsXG5cdFx0XG5cdFx0QGluZGVudCAgPSAwICAgICAgICAgICAgICAjIFRoZSBjdXJyZW50IGluZGVudGF0aW9uIGxldmVsLlxuXHRcdEBpbmRlYnQgID0gMCAgICAgICAgICAgICAgIyBUaGUgb3Zlci1pbmRlbnRhdGlvbiBhdCB0aGUgY3VycmVudCBsZXZlbC5cblx0XHRAb3V0ZGVidCA9IDAgICAgICAgICAgICAgICMgVGhlIHVuZGVyLW91dGRlbnRhdGlvbiBhdCB0aGUgY3VycmVudCBsZXZlbC5cblxuXHRcdEBpbmRlbnRzICA9IFtdICAgICAgICAgICAgICMgVGhlIHN0YWNrIG9mIGFsbCBjdXJyZW50IGluZGVudGF0aW9uIGxldmVscy5cblx0XHRAZW5kcyAgICAgPSBbXSAjIFRoZSBzdGFjayBmb3IgcGFpcmluZyB1cCB0b2tlbnMuXG5cdFx0QGNvbnRleHRzID0gW10gIyBzdXBsZW1lbnRzIEBlbmRzXG5cdFx0QHNjb3BlcyAgID0gW11cblx0XHRAbmV4dFNjb3BlID0gbnVsbCAjIHRoZSBzY29wZSB0byBhZGQgb24gdGhlIG5leHQgaW5kZW50XG5cdFx0IyBzaG91bGQgcmF0aGVyIG1ha2UgaXQgbGlrZSBhIHN0YXRlbWFjaGluZSB0aGF0IG1vdmVzIGZyb20gQ0xBU1NfREVGIHRvIENMQVNTX0JPRFkgZXRjXG5cdFx0IyBUaGluZ3Mgc2hvdWxkIGNvbXBpbGUgZGlmZmVyZW50bHkgd2hlbiB5b3UgYXJlIGluIGEgQ0xBU1NfQk9EWSB0aGFuIHdoZW4gaW4gYSBERUZfQk9EWSsrXG5cblx0XHRAaW5kZW50U3R5bGUgPSBudWxsXG5cblx0XHRAdG9rZW5zICA9IFtdICAgICAgICAgICAgICMgU3RyZWFtIG9mIHBhcnNlZCB0b2tlbnMgaW4gdGhlIGZvcm0gYFsnVFlQRScsIHZhbHVlLCBsaW5lXWAuXG5cdFx0QHNlZW5Gb3IgPSBub1xuXHRcdEBsb2MgPSAwXG5cdFx0QGxvY09mZnNldCA9IDBcblxuXHRcdEBlbmQgICAgID0gbnVsbFxuXHRcdEBjaGFyIFx0ID0gbnVsbFxuXHRcdEBicmlkZ2UgID0gbnVsbFxuXHRcdEBsYXN0ICAgID0gbnVsbFxuXHRcdEBsYXN0VHlwID0gJydcblx0XHRAbGFzdFZhbCA9IG51bGxcblx0XHRzZWxmXG5cblx0ZGVmIGppc29uQnJpZGdlIGppc29uXG5cdFx0QGJyaWRnZSA9IHtcblx0XHRcdGxleDogVDpsZXhcblx0XHRcdHNldElucHV0OiBkbyB8dG9rZW5zfFxuXHRcdFx0XHR0aGlzOnRva2VucyA9IHRva2Vuc1xuXHRcdFx0XHR0aGlzOnBvcyA9IDBcblxuXHRcdFx0dXBjb21pbmdJbnB1dDogZG8gXCJcIlxuXHRcdH1cblxuXG5cdGRlZiB0b2tlbml6ZSBjb2RlLCBvID0ge31cblxuXHRcdGlmIGNvZGU6bGVuZ3RoID09IDBcblx0XHRcdHJldHVybiBbXVxuXG5cdFx0dW5sZXNzIG86aW5saW5lXG5cdFx0XHRpZiBXSElURVNQQUNFLnRlc3QoY29kZSlcblx0XHRcdFx0Y29kZSA9IFwiXFxue2NvZGV9XCJcblx0XHRcdFx0cmV0dXJuIFtdIGlmIGNvZGUubWF0Y2goL15cXHMqJC9nKVxuXG5cdFx0XHRjb2RlID0gY29kZS5yZXBsYWNlKC9cXHIvZywgJycpLnJlcGxhY2UgL1tcXHQgXSskL2csICcnXG5cblx0XHRAbGFzdCAgICA9IG51bGxcblx0XHRAbGFzdFR5cCA9IG51bGxcblx0XHRAbGFzdFZhbCA9IG51bGxcblxuXHRcdEBjb2RlICAgID0gY29kZVxuXHRcdEBvcHRzICAgID0gb1xuXHRcdEBsb2NPZmZzZXQgPSBvOmxvYyBvciAwXG5cblx0XHRvOmluZGVudCB8fD0ge3N0eWxlOiBudWxsLCBzaXplOiBudWxsfVxuXHRcdCMgYWRkIGEgcmVmZXJlbmNlIHRvIHRoZSBvcHRpb25zIG9iamVjdFxuXHRcdG8uQHRva2VucyA9IEB0b2tlbnMgXG5cdFx0IyB3aGF0IGFib3V0IGNvbCBoZXJlP1xuXG5cdFx0IyBAaW5kZW50ICA9IDAgIyBUaGUgY3VycmVudCBpbmRlbnRhdGlvbiBsZXZlbC5cblx0XHQjIEBpbmRlYnQgID0gMCAjIFRoZSBvdmVyLWluZGVudGF0aW9uIGF0IHRoZSBjdXJyZW50IGxldmVsLlxuXHRcdCMgQG91dGRlYnQgPSAwICMgVGhlIHVuZGVyLW91dGRlbnRhdGlvbiBhdCB0aGUgY3VycmVudCBsZXZlbC5cblx0XHQjIEBpbmRlbnRzID0gW10gIyBUaGUgc3RhY2sgb2YgYWxsIGN1cnJlbnQgaW5kZW50YXRpb24gbGV2ZWxzLlxuXHRcdCMgQGVuZHMgICAgPSBbXSAjIFRoZSBzdGFjayBmb3IgcGFpcmluZyB1cCB0b2tlbnMuXG5cdFx0IyBAdG9rZW5zICA9IFtdICMgU3RyZWFtIG9mIHBhcnNlZCB0b2tlbnMgaW4gdGhlIGZvcm0gYFsnVFlQRScsIHZhbHVlLCBsaW5lXWAuXG5cdFx0IyBAY2hhciA9IG5pbFxuXHRcdFxuXHRcdGNvbnNvbGUudGltZShcInRva2VuaXplOmxleGVyXCIpIGlmIG86cHJvZmlsZVxuXHRcdHBhcnNlKGNvZGUpXG5cdFx0Y2xvc2VJbmRlbnRhdGlvbiB1bmxlc3MgbzppbmxpbmVcblx0XHRpZiAhbzpzaWxlbnQgYW5kIEBlbmRzOmxlbmd0aFxuXHRcdFx0ZXJyb3IgXCJtaXNzaW5nIHtAZW5kcy5wb3B9XCJcblxuXHRcdGNvbnNvbGUudGltZUVuZChcInRva2VuaXplOmxleGVyXCIpIGlmIG86cHJvZmlsZVxuXHRcdHJldHVybiBAdG9rZW5zIGlmIG86cmV3cml0ZSA9PSBubyBvciBvOm5vcmV3cml0ZVxuXHRcdHJldHVybiBSZXdyaXRlci5uZXcucmV3cml0ZShAdG9rZW5zLCBvKVxuXG5cdGRlZiBwYXJzZSBjb2RlXG5cdFx0dmFyIGkgPSAwXG5cdFx0dmFyIHBpID0gMFxuXG5cdFx0d2hpbGUgQGNodW5rID0gY29kZS5zbGljZShpKVxuXHRcdFx0QGxvYyA9IEBsb2NPZmZzZXQgKyBpXG5cdFx0XHRwaSA9IChAZW5kID09ICdUQUcnIGFuZCB0YWdEZWZDb250ZXh0VG9rZW4pIHx8IChAaW5UYWcgYW5kIHRhZ0NvbnRleHRUb2tlbikgfHwgYmFzaWNDb250ZXh0XG5cdFx0XHRpICs9IHBpXG5cblx0XHRyZXR1cm5cblxuXHRkZWYgYmFzaWNDb250ZXh0XG5cdFx0cmV0dXJuIHNlbGVjdG9yVG9rZW4gfHwgc3ltYm9sVG9rZW4gfHwgbWV0aG9kTmFtZVRva2VuIHx8IGlkZW50aWZpZXJUb2tlbiB8fCB3aGl0ZXNwYWNlVG9rZW4gfHwgbGluZVRva2VuIHx8IGNvbW1lbnRUb2tlbiB8fCBoZXJlZG9jVG9rZW4gfHwgdGFnVG9rZW4gfHwgc3RyaW5nVG9rZW4gfHwgbnVtYmVyVG9rZW4gfHwgcmVnZXhUb2tlbiB8fCBqc1Rva2VuIHx8IGxpdGVyYWxUb2tlbiB8fCAwXG5cblx0ZGVmIG1vdmVDYXJldCBpXG5cdFx0QGxvYyArPSBpXG5cblx0ZGVmIGNvbnRleHRcblx0XHRAZW5kc1tAZW5kczpsZW5ndGggLSAxXVxuXG5cdGRlZiBpbkNvbnRleHQga2V5XG5cdFx0dmFyIG8gPSBAY29udGV4dHNbQGNvbnRleHRzOmxlbmd0aCAtIDFdXG5cdFx0cmV0dXJuIG8gYW5kIG9ba2V5XVxuXG5cdGRlZiBwdXNoRW5kIHZhbFxuXHRcdCMgY29uc29sZS5sb2cgXCJwdXNoaW5nIGVuZFwiLHZhbFxuXHRcdEBlbmRzLnB1c2godmFsKVxuXHRcdEBjb250ZXh0cy5wdXNoKG5pbClcblx0XHRAZW5kID0gdmFsXG5cdFx0cmVmcmVzaFNjb3BlXG5cdFx0c2VsZlxuXG5cdGRlZiBwb3BFbmQgdmFsXG5cdFx0QGVuZHMucG9wXG5cdFx0QGNvbnRleHRzLnBvcFxuXHRcdEBlbmQgPSBAZW5kc1tAZW5kczpsZW5ndGggLSAxXVxuXHRcdHJlZnJlc2hTY29wZVxuXHRcdHNlbGZcblxuXHRkZWYgcmVmcmVzaFNjb3BlXG5cdFx0dmFyIGN0eDAgPSBAZW5kc1tAZW5kczpsZW5ndGggLSAxXVxuXHRcdHZhciBjdHgxID0gQGVuZHNbQGVuZHM6bGVuZ3RoIC0gMl1cblx0XHRAaW5UYWcgPSBjdHgwID09ICdUQUdfRU5EJyBvciAoY3R4MSA9PSAnVEFHX0VORCcgYW5kIGN0eDAgPT0gJ09VVERFTlQnKVxuXG5cdFx0XG5cblx0ZGVmIHF1ZXVlU2NvcGUgdmFsXG5cdFx0IyBjb25zb2xlLmxvZyhcInB1c2hpbmcgc2NvcGUge3ZhbH0gLSB7QGluZGVudHN9IHtAaW5kZW50czpsZW5ndGh9XCIpXG5cdFx0IyBAc2NvcGVzLnB1c2godmFsKSAjIG5vIG5vXG5cdFx0QHNjb3Blc1tAaW5kZW50czpsZW5ndGhdID0gdmFsXG5cdFx0c2VsZlxuXG5cdGRlZiBwb3BTY29wZSB2YWxcblx0XHRAc2NvcGVzLnBvcFxuXHRcdHNlbGZcblxuXHRkZWYgZ2V0U2NvcGVcblx0XHRAc2NvcGVzW0BpbmRlbnRzOmxlbmd0aCAtIDFdXG5cdFx0XG5cdGRlZiBzY29wZSBzeW0sIG9wdHNcblx0XHR2YXIgbGVuID0gQGVuZHMucHVzaChAZW5kID0gc3ltKVxuXHRcdEBjb250ZXh0cy5wdXNoKG9wdHMgb3IgbmlsKVxuXHRcdHJldHVybiBzeW1cblx0XG5cblx0ZGVmIGNsb3NlU2VsZWN0b3Jcblx0XHRpZiBAZW5kID09ICclJ1xuXHRcdFx0dG9rZW4oJ1NFTEVDVE9SX0VORCcsJyUnLDApXG5cdFx0XHRwYWlyKCclJylcblx0XG5cblx0ZGVmIG9wZW5EZWZcblx0XHRwdXNoRW5kKCdERUYnKVxuXG5cblx0ZGVmIGNsb3NlRGVmXG5cdFx0aWYgY29udGV4dCBpcyAnREVGJ1xuXHRcdFx0dmFyIHByZXYgPSBsYXN0KEB0b2tlbnMpXG5cdFx0XHQjIGNvbnNvbGUubG9nIFwiY2xvc2UgZGVmIHtwcmV2fVwiXG5cdFx0XHQjIGNvbnNvbGUubG9nKCdjbG9zZURlZiB3aXRoIGxhc3Q+JyxwcmV2KVxuXHRcdFx0aWYgdFQocHJldikgPT0gJ0RFRl9GUkFHTUVOVCdcblx0XHRcdFx0dHJ1ZVxuXHRcdFx0ZWxpZiB0VChwcmV2KSA9PSAnVEVSTUlOQVRPUidcblx0XHRcdFx0IyBjb25zb2xlLmxvZyBcImhlcmU/IT8/XCJcblx0XHRcdFx0bGV0IG4gPSBAdG9rZW5zLnBvcFxuXHRcdFx0XHQjIGNvbnNvbGUubG9nIG5cblx0XHRcdFx0dG9rZW4oJ0RFRl9CT0RZJywgJ0RFRl9CT0RZJywwKVxuXHRcdFx0XHQjIHRva2VuKCdURVJNSU5BVE9SJywgJycsMCkgdW5sZXNzIG4uQHZhbHVlLmluZGV4T2YoJy8vJykgPj0gMFxuXHRcdFx0XHRAdG9rZW5zLnB1c2gobilcblx0XHRcdGVsc2Vcblx0XHRcdFx0dG9rZW4oJ0RFRl9CT0RZJywgJ0RFRl9CT0RZJywwKVxuXG5cdFx0XHRwYWlyKCdERUYnKVxuXHRcdHJldHVyblxuXG5cdGRlZiB0YWdDb250ZXh0VG9rZW5cblx0XHRpZiBAY2h1bmtbMF0gPT0gJyMnXG5cdFx0XHQjIGNvbnNvbGUubG9nKCdmb3VuZCBpZCAjIGluIHRhZ0NvbnRleHRUb2tlbicpXG5cdFx0XHR0b2tlbignIycsJyMnLDEpXG5cdFx0XHRyZXR1cm4gMVxuXG5cdFx0aWYgdmFyIG1hdGNoID0gVEFHX0FUVFIuZXhlYyhAY2h1bmspXG5cdFx0XHQjIGNvbnNvbGUubG9nICdUQUdfU0REU0FUVFIgSU4gdG9raWQnLG1hdGNoXG5cdFx0XHQjIHZhciBwcmV2ID0gbGFzdCBAdG9rZW5zXG5cdFx0XHQjIGlmIHRoZSBwcmV2IGlzIGEgdGVybWluYXRvciwgd2UgZG9udCByZWFsbHkgbmVlZCB0byBjYXJlP1xuXHRcdFx0aWYgQGxhc3RUeXAgIT0gJ1RBR19OQU1FJ1xuXHRcdFx0XHRpZiBAbGFzdFR5cCA9PSAnVEVSTUlOQVRPUidcblx0XHRcdFx0XHQjIGNvbnNvbGUubG9nKCdwcmV2IHdhcyB0ZXJtaW5hdG9yIC0tIGRyb3AgaXQ/Jylcblx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHR0b2tlbihcIixcIiwgXCIsXCIpXG5cblx0XHRcdHZhciBsID0gbWF0Y2hbMF06bGVuZ3RoXG5cblx0XHRcdHRva2VuICdUQUdfQVRUUicsbWF0Y2hbMV0sbCAtIDEgICMgYWRkIHRvIGxvYz9cblx0XHRcdEBsb2MgKz0gbCAtIDFcblx0XHRcdHRva2VuICc9JywnPScsMVxuXHRcdFx0cmV0dXJuIGxcblx0XHRyZXR1cm4gMFxuXG5cdGRlZiB0YWdEZWZDb250ZXh0VG9rZW5cblx0XHQjIGNvbnNvbGUubG9nIFwidGFnQ29udGV4dFRva2VuXCJcblx0XHRpZiB2YXIgbWF0Y2ggPSBUQUdfVFlQRS5leGVjKEBjaHVuaylcblx0XHRcdHRva2VuICdUQUdfVFlQRScsIG1hdGNoWzBdLCBtYXRjaFswXTpsZW5ndGhcblx0XHRcdHJldHVybiBtYXRjaFswXTpsZW5ndGhcblxuXHRcdGlmIHZhciBtYXRjaCA9IFRBR19JRC5leGVjKEBjaHVuaylcblx0XHRcdHZhciBpbnB1dCA9IG1hdGNoWzBdXG5cdFx0XHR0b2tlbiAnVEFHX0lEJywgaW5wdXQsIGlucHV0Omxlbmd0aFxuXHRcdFx0cmV0dXJuIGlucHV0Omxlbmd0aFxuXG5cdFx0cmV0dXJuIDBcblxuXG5cdGRlZiB0YWdUb2tlblxuXHRcdHJldHVybiAwIHVubGVzcyB2YXIgbWF0Y2ggPSBUQUcuZXhlYyhAY2h1bmspXG5cdFx0dmFyIFtpbnB1dCwgdHlwZSwgaWRlbnRpZmllcl0gPSBtYXRjaFxuXG5cdFx0aWYgdHlwZSA9PSAnPCdcblx0XHRcdHRva2VuKCdUQUdfU1RBUlQnLCAnPCcsMSlcblx0XHRcdHB1c2hFbmQoSU5WRVJTRVNbJ1RBR19TVEFSVCddKVxuXG5cdFx0XHRpZiBtYXRjaCA9IFRBR19UWVBFLmV4ZWMoQGNodW5rLnN1YnN0cigxLDQwKSlcblx0XHRcdFx0IyBzcGVjaWFsIGNhc2Ugc2hvdWxkIHByb2JhYmx5IGJlIGhhbmRsZWQgaW4gQVNUXG5cdFx0XHRcdGlmIG1hdGNoWzBdICE9ICdzZWxmJ1xuXHRcdFx0XHRcdHRva2VuKCdUQUdfVFlQRScsbWF0Y2hbMF0sbWF0Y2hbMF06bGVuZ3RoLDEpXG5cdFx0XHRcdFx0cmV0dXJuIGlucHV0Omxlbmd0aCArIG1hdGNoWzBdOmxlbmd0aFxuXG5cdFx0XHRpZiBpZGVudGlmaWVyXG5cdFx0XHRcdGlmIGlkZW50aWZpZXIuc3Vic3RyKDAsMSkgPT0gJ3snXG5cdFx0XHRcdFx0cmV0dXJuIHR5cGU6bGVuZ3RoXG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHR0b2tlbignVEFHX05BTUUnLCBpbnB1dC5zdWJzdHIoMSksMClcblxuXHRcdHJldHVybiBpbnB1dDpsZW5ndGhcblxuXG5cdGRlZiBzZWxlY3RvclRva2VuXG5cdFx0dmFyIG1hdGNoXG5cblx0XHQjIHNwZWNpYWwgaGFuZGxpbmcgaWYgd2UgYXJlIGluIHRoaXMgY29udGV4dFxuXHRcdGlmIEBlbmQgPT0gJyUnXG5cdFx0XHR2YXIgY2hyID0gQGNodW5rLmNoYXJBdCgwKVxuXHRcdFx0dmFyIG9wZW4gPSBpbkNvbnRleHQoJ29wZW4nKVxuXG5cdFx0XHQjIHNob3VsZCBhZGQgZm9yICssIH4gZXRjXG5cdFx0XHQjIHNob3VsZCBtYXliZSByYXRoZXIgbG9vayBmb3IgdGhlIGNvcnJlY3QgdHlwZSBvZiBjaGFyYWN0ZXI/XG5cdFx0XG5cdFx0XHRpZiBvcGVuIGFuZCAoY2hyID09ICcgJyBvciBjaHIgPT0gJ1xcbicgb3IgY2hyID09ICcsJyBvciBjaHIgPT0gJysnIG9yIGNociA9PSAnficgb3IgY2hyID09ICcpJyBvciBjaHIgPT0gJ10nKVxuXHRcdFx0XHQjIGNvbnNvbGUubG9nIFwiY2xvc2UgdGhpcyBzZWxlY3RvciBkaXJlY3RseVwiXG5cdFx0XHRcdHRva2VuKCdTRUxFQ1RPUl9FTkQnLCclJywwKVxuXHRcdFx0XHRwYWlyICclJ1xuXHRcdFx0XHRyZXR1cm4gMFxuXG5cdFx0XHRpZiBtYXRjaCA9IFNFTEVDVE9SX0NPTUJJTkFUT1IuZXhlYyhAY2h1bmspXG5cdFx0XHRcdCMgc3BhY2VzIGJldHdlZW4/IC0tIGluY2x1ZGUgdGhlIHdob2xlXG5cdFx0XHRcdHRva2VuICdTRUxFQ1RPUl9DT01CSU5BVE9SJywgbWF0Y2hbMV0gfHwgXCIgXCIsIG1hdGNoWzBdOmxlbmd0aFxuXHRcdFx0XHRyZXR1cm4gbWF0Y2hbMF06bGVuZ3RoXG5cdFx0XHRcblx0XHRcdGVsaWYgbWF0Y2ggPSBTRUxFQ1RPUl9QQVJULmV4ZWMoQGNodW5rKVxuXHRcdFx0XHR2YXIgdHlwZSA9IG1hdGNoWzFdXG5cdFx0XHRcdHZhciBpZCA9IG1hdGNoWzJdXG5cblx0XHRcdFx0dmFyIHRva2lkID0gc3dpdGNoIHR5cGVcblx0XHRcdFx0XHR3aGVuICcuJyB0aGVuICdTRUxFQ1RPUl9DTEFTUydcblx0XHRcdFx0XHR3aGVuICcjJyB0aGVuICdTRUxFQ1RPUl9JRCdcblx0XHRcdFx0XHR3aGVuICc6JyB0aGVuICdTRUxFQ1RPUl9QU0VVRE9fQ0xBU1MnXG5cdFx0XHRcdFx0d2hlbiAnOjonIHRoZW4gJ1NFTEVDVE9SX1BTRVVET19DTEFTUydcblx0XHRcdFx0XHRlbHNlICdTRUxFQ1RPUl9UQUcnXG5cblx0XHRcdFx0dG9rZW4gdG9raWQsIG1hdGNoWzJdLCBtYXRjaFswXTpsZW5ndGhcblx0XHRcdFx0cmV0dXJuIG1hdGNoWzBdOmxlbmd0aFxuXG5cdFx0XHQjIGVsaWYgbWF0Y2ggPSBTRUxFQ1RPUl9QU0VVRE9fQ0xBU1MuZXhlYyhAY2h1bmspXG5cdFx0XHQjICB0b2tlbiB0b2tpZCwgbWF0Y2hbMl1cblx0XHRcdCMgIHJldHVybiBtYXRjaFswXTpsZW5ndGhcblx0XHRcdFxuXHRcdFx0ZWxpZiBjaHIgPT0gJ1snXG5cdFx0XHRcdHRva2VuKCdbJywnWycsMSlcblx0XHRcdFx0c2VsZi5wdXNoRW5kKCddJylcblx0XHRcdFx0aWYgbWF0Y2ggPSBTRUxFQ1RPUl9BVFRSLmV4ZWMoQGNodW5rKVxuXHRcdFx0XHRcdCMgZnVjayB0aGlzIGxlbmd0aCBzaGl0XG5cdFx0XHRcdFx0dmFyIGlkb2Zmc2V0ID0gbWF0Y2hbMF0uaW5kZXhPZihtYXRjaFsxXSlcblx0XHRcdFx0XHR2YXIgb3BvZmZzZXQgPSBtYXRjaFswXS5pbmRleE9mKG1hdGNoWzJdKVxuXHRcdFx0XHRcdHRva2VuKCdJREVOVElGSUVSJywgbWF0Y2hbMV0sIG1hdGNoWzFdOmxlbmd0aCwgaWRvZmZzZXQpXG5cdFx0XHRcdFx0dG9rZW4oJ1NFTEVDVE9SX0FUVFJfT1AnLCBtYXRjaFsyXSwgbWF0Y2hbMl06bGVuZ3RoLCBvcG9mZnNldClcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2hbMF06bGVuZ3RoXG5cdFx0XHRcdHJldHVybiAxXG5cblx0XHRcdGVsaWYgY2hyID09ICd8J1xuXHRcdFx0XHR2YXIgdG9rID0gQHRva2Vuc1tAdG9rZW5zOmxlbmd0aCAtIDFdXG5cdFx0XHRcdHRUcyh0b2ssJ1NFTEVDVE9SX05TJylcblx0XHRcdFx0IyB0b2tbMF0gPSAnU0VMRUNUT1JfTlMnICMgRklYXG5cdFx0XHRcdHJldHVybiAxXG5cblx0XHRcdGVsaWYgY2hyID09ICcsJ1xuXHRcdFx0XHR0b2tlbignU0VMRUNUT1JfR1JPVVAnLCcsJywxKVxuXHRcdFx0XHRyZXR1cm4gMVxuXHRcdFx0ZWxpZiBjaHIgPT0gJyonXG5cdFx0XHRcdHRva2VuKCdVTklWRVJTQUxfU0VMRUNUT1InLCcqJywxKVxuXHRcdFx0XHRyZXR1cm4gMVxuXHRcdFx0XG5cdFx0XHRlbGlmIGNociA9PSAnKSdcblx0XHRcdFx0cGFpciAnJSdcblx0XHRcdFx0dG9rZW4oJ1NFTEVDVE9SX0VORCcsJyknLDEpXG5cdFx0XHRcdHJldHVybiAxXG5cblx0XHRcdGVsaWYgY2hyIGluIFsnKScsJ30nLCddJywnJ11cblx0XHRcdFx0cGFpciAnJSdcblx0XHRcdFx0cmV0dXJuIDBcblxuXHRcdHJldHVybiAwIHVubGVzcyBtYXRjaCA9IFNFTEVDVE9SLmV4ZWMoQGNodW5rKVxuXHRcdHZhciBbaW5wdXQsIGlkLCBraW5kXSA9IG1hdGNoXG5cblx0XHQjIHRoaXMgaXMgYSBjbG9zZWQgc2VsZWN0b3Jcblx0XHRpZiBraW5kID09ICcoJ1xuXHRcdFx0IyB0b2tlbiAnKCcsJygnXG5cdFx0XHR0b2tlbiAnU0VMRUNUT1JfU1RBUlQnLCBpZCwgaWQ6bGVuZ3RoICsgMVxuXHRcdFx0IyBzZWxmLnB1c2hFbmQoJyknKSAjIGFyZSB3ZSBzbyBzdXJlIGFib3V0IHRoaXM/XG5cdFx0XHRzZWxmLnB1c2hFbmQoJyUnKVxuXG5cdFx0XHQjIEBlbmRzLnB1c2ggJyknXG5cdFx0XHQjIEBlbmRzLnB1c2ggJyUnXG5cdFx0XHRyZXR1cm4gaWQ6bGVuZ3RoICsgMVxuXG5cdFx0ZWxpZiBpZCA9PSAnJSdcblx0XHRcdCMgd2UgYXJlIGFscmVhZHkgc2NvcGVkIGluIG9uIGEgc2VsZWN0b3Jcblx0XHRcdHJldHVybiAxIGlmIGNvbnRleHQgPT0gJyUnXG5cdFx0XHR0b2tlbiAnU0VMRUNUT1JfU1RBUlQnLCBpZCwgaWQ6bGVuZ3RoXG5cdFx0XHQjIHRoaXMgaXMgYSBzZXBhcmF0ZSAtIHNjb3BlLiBGdWxsIHNlbGVjdG9yIHNob3VsZCByYXRoZXIgYmUgJCwgYW5kIGtlZXAgdGhlIHNpbmdsZSBzZWxlY3RvciBhcyAlXG5cdFx0XG5cdFx0XHRzY29wZSgnJScsIG9wZW46IHllcylcblx0XHRcdCMgQGVuZHMucHVzaCAnJSdcblx0XHRcdCMgbWFrZSBzdXJlIGEgdGVybWluYXRvciBicmVha3Mgb3V0XG5cdFx0XHRyZXR1cm4gaWQ6bGVuZ3RoXG5cdFx0ZWxzZVxuXHRcdFx0cmV0dXJuIDBcblx0XG5cdCMgaXMgdGhpcyByZWFsbHkgbmVlZGVkPyBTaG91bGQgYmUgcG9zc2libGUgdG9cblx0IyBwYXJzZSB0aGUgaWRlbnRpZmllcnMgYW5kID0gZXRjIGkgamlzb24/XG5cdCMgd2hhdCBpcyBzcGVjaWFsIGFib3V0IG1ldGhvZE5hbWVUb2tlbj8gcmVhbGx5P1xuXHRkZWYgbWV0aG9kTmFtZVRva2VuXG5cdFx0IyB3ZSBjYW4gb3B0aW1pemUgdGhpcyBieSBhZnRlciBhIGRlZiBzaW1wbHlcblx0XHQjIGZldGNoaW5nIGFsbCB0aGUgd2F5IGFmdGVyIHRoZSBkZWYgdW50aWwgYSBzcGFjZSBvciAoXG5cdFx0IyBhbmQgdGhlbiBhZGQgdGhpcyB0byB0aGUgZGVmLXRva2VuIGl0c2VsZiAoYXMgd2l0aCBmcmFnbWVudClcblx0XHRyZXR1cm4gMCBpZiBAY2h1bmsuY2hhckF0KDApID09ICcgJ1xuXG5cdFx0dmFyIG1hdGNoXG5cblx0XHRpZiBAZW5kID09ICcpJ1xuXHRcdFx0dmFyIG91dGVyY3R4ID0gQGVuZHNbQGVuZHM6bGVuZ3RoIC0gMl1cblx0XHRcdCMgd2VpcmQgYXNzdW1wdGlvbiwgbm8/XG5cdFx0XHQjIGNvbnNvbGUubG9nICdjb250ZXh0IGlzIGluc2lkZSEhISdcblx0XHRcdGlmIG91dGVyY3R4ID09ICclJyBhbmQgbWF0Y2ggPSBUQUdfQVRUUi5leGVjKEBjaHVuaylcblx0XHRcdFx0dG9rZW4oJ1RBR19BVFRSX1NFVCcsbWF0Y2hbMV0pXG5cdFx0XHRcdHJldHVybiBtYXRjaFswXTpsZW5ndGhcblxuXHRcdHVubGVzcyBtYXRjaCA9IE1FVEhPRF9JREVOVElGSUVSLmV4ZWMoQGNodW5rKVxuXHRcdFx0cmV0dXJuIDBcdFx0XHRcblx0XHQjIHZhciBwcmV2ID0gbGFzdCBAdG9rZW5zXG5cdFx0dmFyIGxlbmd0aCA9IG1hdGNoWzBdOmxlbmd0aFxuXHRcdFxuXHRcdHZhciBpZCA9IG1hdGNoWzBdXG5cdFx0dmFyIGx0eXAgPSBAbGFzdFR5cFxuXHRcdHZhciB0eXAgPSAnSURFTlRJRklFUidcblx0XHR2YXIgcHJlID0gaWQuY2hhckF0KDApXG5cdFx0dmFyIHNwYWNlID0gbm9cblxuXHRcdHZhciBtNCA9IG1hdGNoWzRdICMgbWlnaHQgYmUgb3V0IG9mIGJvdW5kcz8gc2hvdWxkIHJhdGhlciBjaGVjayBjaGFyQXRcblx0XHQjIGRyb3AgbWF0Y2ggND8/XG5cblx0XHQjIHNob3VsZCB0aGlzIG5vdCBxdWl0IGhlcmUgaW4gcHJhY3RpY2FsbHkgYWxsIGNhc2VzP1xuXHRcdHVubGVzcyAobHR5cCA9PSAnLicgb3IgbHR5cCA9PSAnREVGJykgb3IgKG00ID09ICchJyBvciBtNCA9PSAnPycpIG9yIG1hdGNoWzVdXG5cdFx0XHRyZXR1cm4gMFxuXG5cdFx0IyBhZ2Fpbiwgd2h5P1xuXHRcdGlmIGlkID09ICdzZWxmJyBvciBpZCA9PSAndGhpcycgb3IgaWQgPT0gJ3N1cGVyJyAjIGluIFsnU0VMRicsJ1RISVMnXVxuXHRcdFx0cmV0dXJuIDBcblxuXHRcdGlmIGlkID09ICduZXcnXG5cdFx0XHR0eXAgPSAnTkVXJ1xuXG5cdFx0aWYgaWQgPT0gJy4uLicgYW5kIFsnLCcsJygnLCdDQUxMX1NUQVJUJywnQkxPQ0tfUEFSQU1fU1RBUlQnLCdQQVJBTV9TVEFSVCddLmluZGV4T2YobHR5cCkgPj0gMFxuXHRcdFx0cmV0dXJuIDBcblxuXHRcdGlmIGlkID09ICd8J1xuXHRcdFx0IyBoYWNreSB3YXkgdG8gaW1wbGVtZW50IHRoaXNcblx0XHRcdCMgd2l0aCBuZXcgbGV4ZXIgd2UnbGwgdXNlIHsgLi4uIH0gaW5zdGVhZCwgYW5kIGFzc3VtZSBvYmplY3QtY29udGV4dCxcblx0XHRcdCMgdGhlbiBnbyBiYWNrIGFuZCBjb3JyZWN0IHdoZW4gd2Ugc2VlIHRoZSBjb250ZXh0IGlzIGludmFsaWRcblx0XHRcdGlmIGx0eXAgPT0gJygnIG9yIGx0eXAgPT0gJ0NBTExfU1RBUlQnXG5cdFx0XHRcdHRva2VuKCdETycsICdETycsMClcblx0XHRcdFx0c2VsZi5wdXNoRW5kKCd8Jylcblx0XHRcdFx0IyBAZW5kcy5wdXNoICd8J1xuXHRcdFx0XHR0b2tlbignQkxPQ0tfUEFSQU1fU1RBUlQnLCBpZCwxKVxuXHRcdFx0XHRyZXR1cm4gbGVuZ3RoXG5cblx0XHRcdGVsaWYgbHR5cCA9PSAnRE8nIG9yIGx0eXAgPT0gJ3snXG5cdFx0XHRcdCMgQGVuZHMucHVzaCAnfCdcblx0XHRcdFx0c2VsZi5wdXNoRW5kKCd8Jylcblx0XHRcdFx0dG9rZW4oJ0JMT0NLX1BBUkFNX1NUQVJUJywgaWQsMSlcblx0XHRcdFx0cmV0dXJuIGxlbmd0aFxuXHRcdFx0XHRcblx0XHRcdGVsaWYgQGVuZHNbQGVuZHM6bGVuZ3RoIC0gMV0gPT0gJ3wnXG5cdFx0XHRcdHRva2VuKCdCTE9DS19QQVJBTV9FTkQnLCAnfCcsMSlcblx0XHRcdFx0cGFpciAnfCdcblx0XHRcdFx0cmV0dXJuIGxlbmd0aFxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRyZXR1cm4gMFxuXG5cdFx0IyB3aGFhdD9cblx0XHQjIGNvbnNvbGUubG9nKFwibWV0aG9kIGlkZW50aWZpZXJcIixpZClcblx0XHRpZiAoWycmJywnXicsJzw8JywnPDw8JywnPj4nXS5pbmRleE9mKGlkKSA+PSAwIG9yIChpZCA9PSAnfCcgYW5kIGNvbnRleHQgIT0gJ3wnKSlcblx0XHRcdHJldHVybiAwXG5cblx0XHRpZiBPUF9NRVRIT0RTLmluZGV4T2YoaWQpID49IDBcblx0XHRcdHNwYWNlID0geWVzXG5cblx0XHQjIG5vdCBldmVuIGFueXRoaW5nIHdlIHNob3VsZCB1c2U/IT9cblx0XHRpZiBwcmUgPT0gJ0AnXG5cdFx0XHR0eXAgPSAnSVZBUidcblxuXHRcdGVsaWYgcHJlID09ICckJ1xuXHRcdFx0eWVzXG5cdFx0XHQjIHR5cCA9ICdHVkFSJ1xuXG5cblx0XHRlbGlmIHByZSA9PSAnIydcblx0XHRcdHR5cCA9ICdUQUdJRCdcblxuXHRcdGVsaWYgQ09OU1RfSURFTlRJRklFUi50ZXN0KHByZSkgb3IgaWQgPT0gJ3JlcXVpcmUnIG9yIGlkID09ICdnbG9iYWwnIG9yIGlkID09ICdleHBvcnRzJ1xuXHRcdFx0IyByZWFsbHk/IHNlZW1zIHZlcnkgc3RyYW5nZVxuXHRcdFx0IyBjb25zb2xlLmxvZygnZ2xvYmFsISEnLHR5cCxpZClcblx0XHRcdHR5cCA9ICdDT05TVCdcblx0XHRcblx0XHQjIHdoYXQgaXMgdGhpcyByZWFsbHkgZm9yP1xuXHRcdGlmIG1hdGNoWzVdIGFuZCBbJ0lERU5USUZJRVInLCdDT05TVCcsJ0dWQVInLCdDVkFSJywnSVZBUicsJ1NFTEYnLCdUSElTJywnXScsJ30nLCcpJywnTlVNQkVSJywnU1RSSU5HJywnSURSRUYnXS5pbmRleE9mKGx0eXApID49IDBcblx0XHRcdHRva2VuKCcuJywnLicsMClcblx0XG5cdFx0dG9rZW4odHlwLCBpZCwgbGVuZ3RoKVxuXG5cdFx0aWYgc3BhY2Vcblx0XHRcdEBsYXN0OnNwYWNlZCA9IHllc1xuXG5cdFx0cmV0dXJuIGxlbmd0aFxuXG5cblx0ZGVmIGluVGFnXG5cdFx0dmFyIGxlbiA9IEBlbmRzOmxlbmd0aFxuXHRcdGlmIGxlbiA+IDBcblx0XHRcdHZhciBjdHgwID0gQGVuZHNbbGVuIC0gMV1cblx0XHRcdHZhciBjdHgxID0gbGVuID4gMSA/IEBlbmRzW2xlbiAtIDJdIDogY3R4MFxuXHRcdFx0cmV0dXJuIGN0eDAgPT0gJ1RBR19FTkQnIG9yIChjdHgxID09ICdUQUdfRU5EJyBhbmQgY3R4MCA9PSAnT1VUREVOVCcpXG5cdFx0cmV0dXJuIGZhbHNlXG5cblx0ZGVmIGlzS2V5d29yZCBpZFxuXHRcdGlmIChpZCA9PSAnYXR0cicgb3IgaWQgPT0gJ3Byb3AnKVxuXHRcdFx0dmFyIHNjb3AgPSBnZXRTY29wZVxuXHRcdFx0dmFyIGluY2xzID0gc2NvcCA9PSAnQ0xBU1MnIG9yIHNjb3AgPT0gJ1RBRydcblx0XHRcdCMgdmFyIHNjb3BlcyA9IEBpbmRlbnRzLm1hcCh8aW5kLGl8IEBzY29wZXNbaV0gb3IgJ05PTkUnKVxuXHRcdFx0IyBjb25zb2xlLmxvZyBcImlkIGlzIHByb3A6IHtzY29wZXMuam9pbihcIiAtPiBcIil9IHwge0BpbmRlbnRzLmpvaW4oXCIgLT4gXCIpfVwiXG5cdFx0XHRyZXR1cm4gdHJ1ZSBpZiBpbmNsc1xuXG5cdFx0QUxMX0tFWVdPUkRTLmluZGV4T2YoaWQpID49IDBcblxuXHQjIE1hdGNoZXMgaWRlbnRpZnlpbmcgbGl0ZXJhbHM6IHZhcmlhYmxlcywga2V5d29yZHMsIG1ldGhvZCBuYW1lcywgZXRjLlxuXHQjIENoZWNrIHRvIGVuc3VyZSB0aGF0IEphdmFTY3JpcHQgcmVzZXJ2ZWQgd29yZHMgYXJlbid0IGJlaW5nIHVzZWQgYXNcblx0IyBpZGVudGlmaWVycy4gQmVjYXVzZSBJbWJhIHJlc2VydmVzIGEgaGFuZGZ1bCBvZiBrZXl3b3JkcyB0aGF0IGFyZVxuXHQjIGFsbG93ZWQgaW4gSmF2YVNjcmlwdCwgd2UncmUgY2FyZWZ1bCBub3QgdG8gdG9raWQgdGhlbSBhcyBrZXl3b3JkcyB3aGVuXG5cdCMgcmVmZXJlbmNlZCBhcyBwcm9wZXJ0eSBuYW1lcyBoZXJlLCBzbyB5b3UgY2FuIHN0aWxsIGRvIGBqUXVlcnkuaXMoKWAgZXZlblxuXHQjIHRob3VnaCBgaXNgIG1lYW5zIGA9PT1gIG90aGVyd2lzZS5cblx0ZGVmIGlkZW50aWZpZXJUb2tlblxuXHRcdHZhciBtYXRjaFxuXG5cdFx0dmFyIGN0eDAgPSBAZW5kc1tAZW5kczpsZW5ndGggLSAxXVxuXHRcdHZhciBjdHgxID0gQGVuZHNbQGVuZHM6bGVuZ3RoIC0gMl1cblx0XHR2YXIgaW5uZXJjdHggPSBjdHgwXG5cdFx0dmFyIHR5cFxuXHRcdHZhciByZXNlcnZlZCA9IG5vXG5cblx0XHR2YXIgYWRkTG9jID0gZmFsc2Vcblx0XHR2YXIgaW5UYWcgPSBjdHgwID09ICdUQUdfRU5EJyBvciAoY3R4MSA9PSAnVEFHX0VORCcgYW5kIGN0eDAgPT0gJ09VVERFTlQnKVxuXG5cdFx0IyBjb25zb2xlLmxvZyBjdHgxLGN0eDBcblx0XG5cdFx0aWYgaW5UYWcgJiYgbWF0Y2ggPSBUQUdfQVRUUi5leGVjKEBjaHVuaylcblx0XHRcdCMgY29uc29sZS5sb2cgJ1RBR19BVFRSIElOIHRva2lkJyxtYXRjaFxuXHRcdFx0IyB2YXIgcHJldiA9IGxhc3QgQHRva2Vuc1xuXHRcdFx0IyBpZiB0aGUgcHJldiBpcyBhIHRlcm1pbmF0b3IsIHdlIGRvbnQgcmVhbGx5IG5lZWQgdG8gY2FyZT9cblx0XHRcdGlmIEBsYXN0VHlwICE9ICdUQUdfTkFNRSdcblx0XHRcdFx0aWYgQGxhc3RUeXAgPT0gJ1RFUk1JTkFUT1InXG5cdFx0XHRcdFx0IyBjb25zb2xlLmxvZygncHJldiB3YXMgdGVybWluYXRvciAtLSBkcm9wIGl0PycpXG5cdFx0XHRcdFx0dHJ1ZVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0dG9rZW4oXCIsXCIsIFwiLFwiKVxuXG5cdFx0XHR2YXIgbCA9IG1hdGNoWzBdOmxlbmd0aFxuXG5cdFx0XHR0b2tlbiAnVEFHX0FUVFInLG1hdGNoWzFdLGwgLSAxICAjIGFkZCB0byBsb2M/XG5cdFx0XHRAbG9jICs9IGwgLSAxXG5cdFx0XHR0b2tlbiAnPScsJz0nLDFcblx0XHRcdHJldHVybiBsXG5cblx0XHQjIHNlZSBpZiB0aGlzIGlzIGEgcGxhaW4gb2JqZWN0LWtleVxuXHRcdCMgd2F5IHRvbyBtdWNoIGxvZ2ljIGdvaW5nIG9uIGhlcmU/XG5cdFx0IyB0aGUgYXN0IHNob3VsZCBub3JtYWxpemUgd2hldGhlciBrZXlzXG5cdFx0IyBhcmUgYWNjZXNzYWJsZSBhcyBrZXlzIG9yIHN0cmluZ3MgZXRjXG5cdFx0aWYgbWF0Y2ggPSBPQkpFQ1RfS0VZLmV4ZWMoQGNodW5rKVxuXHRcdFx0dmFyIGlkID0gbWF0Y2hbMV1cblx0XHRcdHZhciB0eXAgPSAnSURFTlRJRklFUidcblxuXHRcdFx0IyBGSVhNRSBsb2Mgb2Yga2V5IGluY2x1ZGVzIGNvbG9uXG5cdFx0XHQjIG1vdmVDYXJldChpZDpsZW5ndGgpXG5cdFx0XHQjIGNvbnNvbGUubG9nIFwib2tcIlxuXHRcdFx0aWYgdHJ1ZVxuXHRcdFx0XHQjIGNvbnNvbGUubG9nIFwiZ290IGhlcmU/IHttYXRjaH1cIlxuXHRcdFx0XHR0b2tlbih0eXAsIGlkLCBpZDpsZW5ndGgpXG5cdFx0XHRcdG1vdmVDYXJldChpZDpsZW5ndGgpXG5cdFx0XHRcdHRva2VuICc6JywgJzonLCBtYXRjaFszXTpsZW5ndGhcblx0XHRcdFx0bW92ZUNhcmV0KC1pZDpsZW5ndGgpXG5cdFx0XHRcdCMgbW92ZUNhcmV0KG1hdGNoWzNdOmxlbmd0aClcblx0XHRcdFx0cmV0dXJuIG1hdGNoWzBdOmxlbmd0aFxuXG5cdFx0XHQjIG1vdmVDYXJldChtYXRjaFsyXTpsZW5ndGgpXG5cdFx0XHQjIHJldHVybiAwXG5cdFx0XHQjIGNvbnNvbGUubG9nIG1hdGNoWzNdOmxlbmd0aFxuXHRcdFx0dG9rZW4gdHlwLCBpZCwgbWF0Y2hbMF06bGVuZ3RoXG5cdFx0XHR0b2tlbiAnOicsICc6JywxXG5cdFx0XHRyZXR1cm4gbWF0Y2hbMF06bGVuZ3RoXG5cblx0XHR1bmxlc3MgbWF0Y2ggPSBJREVOVElGSUVSLmV4ZWMoQGNodW5rKVxuXHRcdFx0cmV0dXJuIDBcblxuXHRcdHZhciBbaW5wdXQsIGlkLCB0eXAsIG0zLCBtNCwgY29sb25dID0gbWF0Y2hcblx0XHR2YXIgaWRsZW4gPSBpZDpsZW5ndGhcblxuXHRcdCMgV2hhdCBpcyB0aGUgbG9naWMgaGVyZT9cblx0XHRpZiBpZCBpcyAnb3duJyBhbmQgbGFzdFRva2VuVHlwZSA9PSAnRk9SJ1xuXHRcdFx0dG9rZW4gJ09XTicsIGlkLCBpZDpsZW5ndGhcblx0XHRcdHJldHVybiBpZDpsZW5ndGhcblxuXHRcdHZhciBwcmV2ID0gbGFzdChAdG9rZW5zKVxuXHRcdHZhciBsYXN0VHlwID0gQGxhc3RUeXBcblxuXHRcdCMgc2hvdWxkIHdlIGZvcmNlIHRoaXMgdG8gYmUgYW4gaWRlbnRpZmllciBldmVuIGlmIGl0IGlzIGEgcmVzZXJ2ZWQgd29yZD9cblx0XHQjIHRoaXMgc2hvdWxkIG9ubHkgaGFwcGVuIGZvciB3aGVuIHBhcnQgb2Ygb2JqZWN0IGV0Y1xuXHRcdCMgd2lsbCBwcmV2IGV2ZXIgYmUgQD8/P1xuXHRcdHZhciBmb3JjZWRJZGVudGlmaWVyXG5cblx0XHQjIGFnYWluXG5cdFx0Zm9yY2VkSWRlbnRpZmllciA9IGNvbG9uIHx8IGxhc3RUeXAgPT0gJy4nIG9yIGxhc3RUeXAgPT0gJz8uJyAjIGluIFsnLicsICc/LidcblxuXG5cdFx0IyB0ZW1wIGhhY2shIG5lZWQgdG8gc29sdmUgZm9yIG90aGVyIGtleXdvcmRzIGV0YyBhcyB3ZWxsXG5cdFx0IyBwcm9ibGVtIGFwcGVhcnMgd2l0aCB0ZXJuYXJ5IGNvbmRpdGlvbnMuXG5cblx0XHQjIHdlbGwgLS0gaXQgc2hvdWxkIHN0aWxsIGJlIGFuIGluZGVudGlmaWVyIGlmIGluIG9iamVjdD9cblx0XHQjIGZvcmNlZElkZW50aWZpZXIgPSBubyBpZiBpZCBpbiBbJ3VuZGVmaW5lZCcsJ2JyZWFrJ11cblxuXHRcdGZvcmNlZElkZW50aWZpZXIgPSBubyBpZiBjb2xvbiBhbmQgbGFzdFR5cCA9PSAnPycgIyBmb3IgdGVybmFyeVxuXG5cdFx0IyBpZiB3ZSBhcmUgbm90IGF0IHRoZSB0b3AgbGV2ZWw/IC0tIGhhY2t5XG5cdFx0aWYgaWQgPT0gJ3RhZycgYW5kIEBjaHVuay5pbmRleE9mKFwidGFnKFwiKSA9PSAwICMgQGNodW5rLm1hdGNoKC9edG9raWRcXCgvKVxuXHRcdFx0Zm9yY2VkSWRlbnRpZmllciA9IHllc1xuXG5cdFx0dmFyIGlzS2V5d29yZCA9IG5vXG5cblx0XHQjIGNvbnNvbGUubG9nIFwibWF0Y2hcIixtYXRjaFxuXHRcdCMgY29uc29sZS5sb2cgXCJ0eXAgaXMge3R5cH1cIlxuXHRcdCMgbGl0dGxlIHJlYXNvbiB0byBjaGVjayBmb3IgdGhpcyByaWdodCBoZXJlPyBidXQgSSBndWVzcyBpdCBpcyBvbmx5IGEgc2ltcGxlIGNoZWNrXG5cdFx0aWYgdHlwID09ICckJyBhbmQgQVJHVkFSLnRlc3QoaWQpICMgaWQubWF0Y2goL15cXCRcXGQkLylcblx0XHRcdCMgY29uc29sZS5sb2cgXCJUWVAgJFwiXG5cdFx0XHRpZiBpZCA9PSAnJDAnXG5cdFx0XHRcdHR5cCA9ICdBUkdVTUVOVFMnXG5cdFx0XHRlbHNlXG5cdFx0XHRcdHR5cCA9ICdBUkdWQVInXG5cdFx0XHRcdGlkID0gaWQuc3Vic3RyKDEpXG5cblx0XHRlbGlmIHR5cCA9PSAnQCdcblx0XHRcdHR5cCA9ICdJVkFSJ1xuXG5cdFx0XHQjIGlkOnJlc2VydmVkID0geWVzIGlmIGNvbG9uXG5cdFx0ZWxpZiB0eXAgPT0gJyMnXG5cdFx0XHQjIHdlIGFyZSB0cnlpbmcgdG8gbW92ZSB0byBnZW5lcmljIHRva2Vucyxcblx0XHRcdCMgc28gd2UgYXJlIHN0YXJ0aW5nIHRvIHNwbGl0dGluZyB1cCB0aGUgc3ltYm9scyBhbmQgdGhlIGl0ZW1zXG5cdFx0XHQjIHdlJ2xsIHNlZSBpZiB0aGF0IHdvcmtzXG5cdFx0XHR0eXAgPSAnSURFTlRJRklFUidcblx0XHRcdHRva2VuICcjJywgJyMnXG5cdFx0XHRpZCA9IGlkLnN1YnN0cigxKVxuXG5cdFx0ZWxpZiB0eXAgPT0gJ0BAJ1xuXHRcdFx0dHlwID0gJ0NWQVInXG5cblx0XHRlbGlmIHR5cCA9PSAnJCcgYW5kICFjb2xvblxuXHRcdFx0dHlwID0gJ0lERU5USUZJRVInXG5cdFx0XHQjIHR5cCA9ICdHVkFSJ1xuXG5cdFx0ZWxpZiBDT05TVF9JREVOVElGSUVSLnRlc3QoaWQpIG9yIGlkID09ICdyZXF1aXJlJyBvciBpZCA9PSAnZ2xvYmFsJyBvciBpZCA9PSAnZXhwb3J0cydcblx0XHRcdCMgdGhvdXMgc2hvdWxkIHJlYWxseSBiZSBoYW5kbGVkIGJ5IHRoZSBhc3QgaW5zdGVhZFxuXHRcdFx0dHlwID0gJ0NPTlNUJ1xuXG5cdFx0ZWxpZiBpZCA9PSAnZWxpZidcblx0XHRcdHRva2VuICdFTFNFJywgJ2VsaWYnLCBpZDpsZW5ndGhcblx0XHRcdHRva2VuICdJRicsICdpZidcblx0XHRcdHJldHVybiBpZDpsZW5ndGhcblxuXHRcdGVsc2Vcblx0XHRcdHR5cCA9ICdJREVOVElGSUVSJ1xuXG5cblxuXHRcdCMgdGhpcyBjYXRjaGVzIGFsbCBcblx0XHRpZiAhZm9yY2VkSWRlbnRpZmllciBhbmQgaXNLZXl3b3JkID0gc2VsZi5pc0tleXdvcmQoaWQpXG5cdFx0XHQjIChpZCBpbiBKU19LRVlXT1JEUyBvciBpZCBpbiBJTUJBX0tFWVdPUkRTKVxuXHRcdFx0dHlwID0gaWQudG9VcHBlckNhc2Vcblx0XHRcdGFkZExvYyA9IHRydWVcblxuXHRcdFx0IyBjbHVtc3kgLSBidXQgdGVzdGluZyBwZXJmb3JtYW5jZVxuXHRcdFx0aWYgdHlwID09ICdZRVMnXG5cdFx0XHRcdHR5cCA9ICdUUlVFJ1xuXHRcdFx0ZWxpZiB0eXAgPT0gJ05PJ1xuXHRcdFx0XHR0eXAgPSAnRkFMU0UnXG5cdFx0XHRlbGlmIHR5cCA9PSAnTklMJ1xuXHRcdFx0XHR0eXAgPSAnTlVMTCdcblxuXHRcdFx0ZWxpZiB0eXAgPT0gJ1ZBUidcblx0XHRcdFx0aWYgQGxhc3RWYWwgPT0gJ2V4cG9ydCdcblx0XHRcdFx0XHR0VHMocHJldiwnRVhQT1JUJylcblxuXHRcdFx0IyBza2lwcGluZyBcblx0XHRcdGVsaWYgdHlwID09ICdJRicgb3IgdHlwID09ICdFTFNFJyBvciB0eXAgPT0gJ1RSVUUnIG9yIHR5cCA9PSAnRkFMU0UnIG9yIHR5cCA9PSAnTlVMTCdcblx0XHRcdFx0dHJ1ZVxuXHRcdFx0ZWxpZiB0eXAgPT0gJ1RBRydcblx0XHRcdFx0c2VsZi5wdXNoRW5kKCdUQUcnKVxuXHRcdFx0XHQjIEBlbmRzLnB1c2goJ1RBRycpXG5cdFx0XHQjIEZJWE1FIEBlbmRzIGlzIG5vdCB1c2VkIHRoZSB3YXkgaXQgaXMgc3VwcG9zZWQgdG8uLlxuXHRcdFx0IyB3aGF0IHdlIHdhbnQgaXMgYSBjb250ZXh0LXN0YWNrXG5cdFx0XHRlbGlmIHR5cCA9PSAnREVGJ1xuXHRcdFx0XHQjIHNob3VsZCBwcm9iYWJseSBzaGlmdCBjb250ZXh0IGFuZCBvcHRpbWl6ZSB0aGlzXG5cdFx0XHRcdG9wZW5EZWZcblxuXHRcdFx0ZWxpZiB0eXAgPT0gJ0RPJ1xuXHRcdFx0XHRjbG9zZURlZiBpZiBjb250ZXh0ID09ICdERUYnXG5cblx0XHRcdGVsaWYgdHlwIGlzICdXSEVOJyBhbmQgTElORV9CUkVBSy5pbmRleE9mKGxhc3RUb2tlblR5cGUpID49IDBcblx0XHRcdFx0dHlwID0gJ0xFQURJTkdfV0hFTidcblxuXHRcdFx0ZWxpZiB0eXAgaXMgJ0ZPUidcblx0XHRcdFx0QHNlZW5Gb3IgPSB5ZXNcblxuXHRcdFx0ZWxpZiB0eXAgaXMgJ1VOTEVTUydcblx0XHRcdFx0dHlwID0gJ0lGJyAjIFdBUk5cblxuXHRcdFx0ZWxpZiBVTkFSWS5pbmRleE9mKHR5cCkgPj0gMFxuXHRcdFx0XHR0eXAgPSAnVU5BUlknXG5cblx0XHRcdGVsaWYgUkVMQVRJT04uaW5kZXhPZih0eXApID49IDBcblx0XHRcdFx0aWYgdHlwICE9ICdJTlNUQU5DRU9GJyBhbmQgdHlwICE9ICdJU0EnIGFuZCBAc2VlbkZvclxuXHRcdFx0XHRcdHR5cCA9ICdGT1InICsgdHlwICMgP1xuXHRcdFx0XHRcdEBzZWVuRm9yID0gbm9cblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHR5cCA9ICdSRUxBVElPTidcblx0XHRcdFx0XHRpZiBTdHJpbmcodmFsdWUpID09ICchJ1xuXHRcdFx0XHRcdFx0QHRva2Vucy5wb3AgIyBpcyBmdWNrZWQgdXA/PyFcblx0XHRcdFx0XHRcdCMgV0FSTiB3ZSBuZWVkIHRvIGtlZXAgdGhlIGxvYywgbm8/XG5cdFx0XHRcdFx0XHRpZCA9ICchJyArIGlkXG5cblx0XHRpZiBpZCA9PSAnc3VwZXInXG5cdFx0XHR0eXAgPSAnU1VQRVInXG5cblx0XHQjIGRvIHdlIHJlYWxseSB3YW50IHRvIGNoZWNrIHRoaXMgaGVyZVxuXHRcdGlmICFmb3JjZWRJZGVudGlmaWVyXG5cdFx0XHQjIHNob3VsZCBhbHJlYWR5IGhhdmUgZGVhbHQgd2l0aCB0aGlzXG5cblx0XHRcdGlkID0gSU1CQV9BTElBU19NQVBbaWRdIGlmIGlzS2V5d29yZCBhbmQgSU1CQV9BTElBU0VTLmluZGV4T2YoaWQpID49IDBcblx0XHRcdCMgdGhlc2UgcmVhbGx5IHNob3VsZCBub3QgZ28gaGVyZT8hP1xuXHRcdFx0c3dpdGNoIGlkXG5cdFx0XHRcdHdoZW4gJyEnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZW4gdHlwID0gJ1VOQVJZJ1xuXHRcdFx0XHR3aGVuICc9PScsICchPScsICc9PT0nLCAnIT09JyAgICAgICAgICAgICB0aGVuIHR5cCA9ICdDT01QQVJFJ1xuXHRcdFx0XHR3aGVuICcmJicsICd8fCcgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVuIHR5cCA9ICdMT0dJQydcblx0XHRcdFx0d2hlbiAnYnJlYWsnLCAnY29udGludWUnLCAnZGVidWdnZXInLCdhcmd1bWVudHMnIHRoZW4gdHlwID0gaWQudG9VcHBlckNhc2Vcblx0XHRcdFx0IyB3aGVuICd0cnVlJywgJ2ZhbHNlJywgJ251bGwnLCAndW5kZWZpbmVkJyB0aGVuIHR5cCA9ICdCT09MJ1xuXHRcdFx0XHQjIHJlYWxseT9cblxuXHRcdCMgcHJldiA9IGxhc3QgQHRva2Vuc1xuXHRcdHZhciBsZW4gPSBpbnB1dDpsZW5ndGhcblxuXHRcdCMgc2hvdWxkIGJlIHN0cmljdCBhYm91dCB0aGUgb3JkZXIsIGNoZWNrIHRoaXMgbWFudWFsbHkgaW5zdGVhZFxuXHRcdGlmIHR5cCA9PSAnQ0xBU1MnIG9yIHR5cCA9PSAnREVGJyBvciB0eXAgPT0gJ1RBRydcblx0XHRcdHF1ZXVlU2NvcGUodHlwKVxuXG5cdFx0XHR2YXIgaSA9IEB0b2tlbnM6bGVuZ3RoXG5cblx0XHRcdHdoaWxlIGlcblx0XHRcdFx0dmFyIHByZXYgPSBAdG9rZW5zWy0taV1cblx0XHRcdFx0dmFyIGN0cmwgPSBcIlwiICsgdFYocHJldilcblx0XHRcdFx0IyBjb25zb2xlLmxvZyhcImN0cmwgaXMge2N0cmx9XCIpXG5cdFx0XHRcdCMgbmVlZCB0byBjb2VyY2UgdG8gc3RyaW5nIGJlY2F1c2Ugb2Ygc3R1cGlkIENTID09PVxuXHRcdFx0XHQjIGNvbnNvbGUubG9nKFwicHJldiBpc1wiLHByZXZbMF0scHJldlsxXSlcblx0XHRcdFx0aWYgY3RybCBpbiBJTUJBX0NPTlRFWFRVQUxfS0VZV09SRFNcblx0XHRcdFx0XHR0VHMocHJldixjdHJsLnRvVXBwZXJDYXNlKVxuXHRcdFx0XHRcdCMgcHJldlswXSA9IGN0cmwudG9VcHBlckNhc2UgIyBGSVhcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdGJyZWFrXG5cblx0XHRlbGlmIHR5cCA9PSAnSUYnXG5cdFx0XHRxdWV1ZVNjb3BlKHR5cClcblxuXHRcdGVsaWYgdHlwID09ICdJTVBPUlQnXG5cdFx0XHQjIGNvdWxkIG1hbnVhbGx5IHBhcnNlIHRoZSB3aG9sZSB0aW5nIGhlcmU/XG5cdFx0XHRwdXNoRW5kKCdJTVBPUlQnKVxuXHRcdFx0IyBAZW5kcy5wdXNoICdJTVBPUlQnXG5cblx0XHRlbGlmIGlkID09ICdmcm9tJyBhbmQgY3R4MCA9PSAnSU1QT1JUJ1xuXHRcdFx0dHlwID0gJ0ZST00nXG5cdFx0XHRwYWlyICdJTVBPUlQnXG5cblx0XHQjIHdpbGwgYmUgbXVjaCBjbGVhbmVyIHdpdGggdGhlIG5ldyBoYW5kbWFkZSBjb21iaW5lZCBsZXhlcitwYXJzZXJcblx0XHQjIGZvciBub3cgd2UgbmVlZCB0byBkbyBzb21lIHRlc3Rpbmdcblx0XHRlbGlmIGlkID09ICdhcycgYW5kIGN0eDAgPT0gJ0lNUE9SVCdcblx0XHRcdHR5cCA9ICdBUydcblx0XHRcdHBhaXIgJ0lNUE9SVCdcblxuXHRcdGlmIHR5cCA9PSAnSURFTlRJRklFUidcblx0XHRcdCMgc2VlIGlmIHByZXZpb3VzIHdhcyBjYXRjaCAtLSBiZWxvbmdzIGluIHJld3JpdGVyP1xuXHRcdFx0aWYgbGFzdFR5cCA9PSAnQ0FUQ0gnXG5cdFx0XHRcdHR5cCA9ICdDQVRDSF9WQVInXG5cdFx0XG5cdFx0aWYgY29sb25cblx0XHRcdHRva2VuKHR5cCwgaWQsIGlkbGVuKVxuXHRcdFx0bW92ZUNhcmV0KGlkbGVuKVxuXHRcdFx0IyBjb25zb2xlLmxvZyBcImFkZCBjb2xvbj9cIlxuXHRcdFx0dG9rZW4oJzonLCAnOicsY29sb246bGVuZ3RoKVxuXHRcdFx0bW92ZUNhcmV0KC1pZGxlbilcblx0XHRlbHNlXG5cdFx0XHR0b2tlbih0eXAsIGlkLCBpZGxlbilcblxuXHRcdHJldHVybiBsZW5cblxuXHQjIE1hdGNoZXMgbnVtYmVycywgaW5jbHVkaW5nIGRlY2ltYWxzLCBoZXgsIGFuZCBleHBvbmVudGlhbCBub3RhdGlvbi5cblx0IyBCZSBjYXJlZnVsIG5vdCB0byBpbnRlcmZlcmUgd2l0aCByYW5nZXMtaW4tcHJvZ3Jlc3MuXG5cdGRlZiBudW1iZXJUb2tlblxuXHRcdHZhciBtYXRjaCwgbnVtYmVyLCBsZXhlZExlbmd0aFxuXG5cdFx0cmV0dXJuIDAgdW5sZXNzIG1hdGNoID0gTlVNQkVSLmV4ZWMoQGNodW5rKVxuXG5cdFx0bnVtYmVyID0gbWF0Y2hbMF1cblx0XHRsZXhlZExlbmd0aCA9IG51bWJlcjpsZW5ndGhcblxuXHRcdGlmIHZhciBiaW5hcnlMaXRlcmFsID0gLzBiKFswMV0rKS8uZXhlYyhudW1iZXIpXG5cdFx0XHRcblx0XHRcdG51bWJlciA9IFwiXCIgKyBwYXJzZUludChiaW5hcnlMaXRlcmFsWzFdLCAyKVxuXG5cdFx0dmFyIHByZXYgPSBsYXN0KEB0b2tlbnMpXG5cblx0XHRpZiBtYXRjaFswXVswXSA9PSAnLicgJiYgcHJldiAmJiAhcHJldjpzcGFjZWQgJiYgWydJREVOVElGSUVSJywnKScsJ30nLCddJywnTlVNQkVSJ10uaW5kZXhPZih0VChwcmV2KSkgPj0gMFxuXHRcdFx0IyBjb25zb2xlLmxvZyBcImdvdCBoZXJlXCJcblx0XHRcdHRva2VuIFwiLlwiLFwiLlwiXG5cdFx0XHRudW1iZXIgPSBudW1iZXIuc3Vic3RyKDEpXG5cdFx0XG5cblx0XHR0b2tlbignTlVNQkVSJyxudW1iZXIsbGV4ZWRMZW5ndGgpXG5cdFx0cmV0dXJuIGxleGVkTGVuZ3RoXG5cdFxuXHRkZWYgc3ltYm9sVG9rZW5cblx0XHR2YXIgbWF0Y2gsIHN5bWJvbCwgcHJldlxuXG5cdFx0cmV0dXJuIDAgdW5sZXNzIG1hdGNoID0gU1lNQk9MLmV4ZWMoQGNodW5rKVxuXHRcdHN5bWJvbCA9IG1hdGNoWzBdLnN1YnN0cigxKVxuXHRcdHByZXYgPSBsYXN0KEB0b2tlbnMpXG5cblx0XHQjIGlzIHRoaXMgYSBwcm9wZXJ0eS1hY2Nlc3M/XG5cdFx0IyBzaG91bGQgaW52ZXJ0IHRoaXMgLS0gb25seSBhbGxvdyB3aGVuIHByZXYgSVMgLi4gXG5cdFxuXHRcdCMgOiBzaG91bGQgYmUgYSB0b2tlbiBpdHNlbGYsIHdpdGggYSBzcGVjaWZpY2F0aW9uIG9mIHNwYWNpbmcgKExSLFIsTCxOT05FKVxuXG5cdFx0IyBGSVhcblx0XHRpZiBwcmV2IGFuZCAhcHJldjpzcGFjZWQgYW5kIHRUKHByZXYpIG5vdCBpbiBbJygnLCd7JywnWycsJy4nLCdDQUxMX1NUQVJUJywnSU5ERVhfU1RBUlQnLCcsJywnPScsJ0lOREVOVCcsJ1RFUk1JTkFUT1InXVxuXHRcdFx0dG9rZW4gJy46JywnOicsIDFcblx0XHRcdHZhciBzeW0gPSBzeW1ib2wuc3BsaXQoL1tcXDpcXFxcXFwvXS8pWzBdICMgcmVhbGx5P1xuXHRcdFx0IyB0b2tlbiAnU1lNQk9MJywgXCInI3tzeW1ib2x9J1wiXG5cdFx0XHR0b2tlbiAnSURFTlRJRklFUicsIHN5bSwgc3ltOmxlbmd0aCwgMVxuXHRcdFx0cmV0dXJuIChzeW06bGVuZ3RoICsgMSlcblx0XHRlbHNlXG5cdFx0XHQjIHRva2VuICdTWU1CT0wnLCBcIicje3N5bWJvbH0nXCJcblx0XHRcdHRva2VuICdTWU1CT0wnLCBzeW1ib2wsIG1hdGNoWzBdOmxlbmd0aFxuXHRcdFx0bWF0Y2hbMF06bGVuZ3RoXG5cblx0ZGVmIGVzY2FwZVN0ciBzdHIsIGhlcmVkb2MsIHFcblx0XHRzdHIgPSBzdHIucmVwbGFjZSBNVUxUSUxJTkVSLCAoaGVyZWRvYyA/ICdcXFxcbicgOiAnJylcblx0XHRpZiBxXG5cdFx0XHR2YXIgciA9IFJlZ0V4cChcIlxcXFxcXFxcW3txfV1cIixcImdcIilcblx0XHRcdHN0ciA9IHN0ci5yZXBsYWNlKHIscSlcblx0XHRcdHN0ciA9IHN0ci5yZXBsYWNlIFJlZ0V4cChcIntxfVwiLFwiZ1wiKSwgJ1xcXFwkJidcblx0XHRyZXR1cm4gc3RyXG5cblx0XHQjIHN0ciA9IHN0ci5yZXBsYWNlKE1VTFRJTElORVIsICdcXFxcbicpXG5cdFx0IyBzdHIgPSBzdHIucmVwbGFjZSgvXFx0L2csICdcXFxcdCcpXG5cdCMgTWF0Y2hlcyBzdHJpbmdzLCBpbmNsdWRpbmcgbXVsdGktbGluZSBzdHJpbmdzLiBFbnN1cmVzIHRoYXQgcXVvdGF0aW9uIG1hcmtzXG5cdCMgYXJlIGJhbGFuY2VkIHdpdGhpbiB0aGUgc3RyaW5nJ3MgY29udGVudHMsIGFuZCB3aXRoaW4gbmVzdGVkIGludGVycG9sYXRpb25zLlxuXHRkZWYgc3RyaW5nVG9rZW5cblx0XHR2YXIgbWF0Y2gsIHN0cmluZ1xuXG5cdFx0c3dpdGNoIEBjaHVuay5jaGFyQXQoMClcblx0XHRcdHdoZW4gXCInXCJcblx0XHRcdFx0cmV0dXJuIDAgdW5sZXNzIG1hdGNoID0gU0lNUExFU1RSLmV4ZWMoQGNodW5rKVxuXHRcdFx0XHRzdHJpbmcgPSBtYXRjaFswXVxuXHRcdFx0XHR0b2tlbiAnU1RSSU5HJywgZXNjYXBlU3RyKHN0cmluZyksIHN0cmluZzpsZW5ndGhcblx0XHRcdFx0IyB0b2tlbiAnU1RSSU5HJywgKHN0cmluZyA9IG1hdGNoWzBdKS5yZXBsYWNlKE1VTFRJTElORVIsICdcXFxcXFxuJyksIHN0cmluZzpsZW5ndGhcblxuXHRcdFx0d2hlbiAnXCInXG5cdFx0XHRcdHJldHVybiAwIHVubGVzcyBzdHJpbmcgPSBiYWxhbmNlZFN0cmluZyhAY2h1bmssICdcIicpXG5cdFx0XHRcdCMgd2hhdCBhYm91dCB0cmlwZSBxdW90ZWQgc3RyaW5ncz9cblxuXHRcdFx0XHRpZiBzdHJpbmcuaW5kZXhPZigneycpID49IDBcblx0XHRcdFx0XHR2YXIgbGVuID0gc3RyaW5nOmxlbmd0aFxuXHRcdFx0XHRcdCMgaWYgdGhpcyBoYXMgbm8gaW50ZXJwb2xhdGlvbj9cblx0XHRcdFx0XHQjIHdlIGFyZSBub3cgbWVzc2luZyB3aXRoIGxvY2F0aW9ucyAtIGJld2FyZVxuXHRcdFx0XHRcdHRva2VuICdTVFJJTkdfU1RBUlQnLCBzdHJpbmcuY2hhckF0KDApLCAxXG5cdFx0XHRcdFx0aW50ZXJwb2xhdGVTdHJpbmcoc3RyaW5nLnNsaWNlIDEsIC0xKVxuXHRcdFx0XHRcdHRva2VuICdTVFJJTkdfRU5EJywgc3RyaW5nLmNoYXJBdChsZW4gLSAxKSwgMSwgc3RyaW5nOmxlbmd0aCAtIDFcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHZhciBsZW4gPSBzdHJpbmc6bGVuZ3RoXG5cdFx0XHRcdFx0IyBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShNVUxUSUxJTkVSLCAnXFxcXFxcbicpXG5cdFx0XHRcdFx0dG9rZW4gJ1NUUklORycsIGVzY2FwZVN0cihzdHJpbmcpLCBsZW5cblx0XHRcdGVsc2Vcblx0XHRcdFx0cmV0dXJuIDBcblxuXHRcdG1vdmVIZWFkKHN0cmluZylcblx0XHRyZXR1cm4gc3RyaW5nOmxlbmd0aFxuXG5cdCMgTWF0Y2hlcyBoZXJlZG9jcywgYWRqdXN0aW5nIGluZGVudGF0aW9uIHRvIHRoZSBjb3JyZWN0IGxldmVsLCBhcyBoZXJlZG9jc1xuXHQjIHByZXNlcnZlIHdoaXRlc3BhY2UsIGJ1dCBpZ25vcmUgaW5kZW50YXRpb24gdG8gdGhlIGxlZnQuXG5cdGRlZiBoZXJlZG9jVG9rZW5cblx0XHR2YXIgbWF0Y2gsIGhlcmVkb2MsIHF1b3RlLCBkb2NcblxuXHRcdHJldHVybiAwIHVubGVzcyBtYXRjaCA9IEhFUkVET0MuZXhlYyhAY2h1bmspXG5cblx0XHRoZXJlZG9jID0gbWF0Y2hbMF1cblx0XHRxdW90ZSA9IGhlcmVkb2MuY2hhckF0IDBcblx0XHRkb2MgPSBzYW5pdGl6ZUhlcmVkb2MobWF0Y2hbMl0sIHF1b3RlOiBxdW90ZSwgaW5kZW50OiBudWxsKVxuXHRcdCMgY29uc29sZS5sb2cgXCJmb3VuZCBoZXJlZG9jIHttYXRjaFswXTpsZW5ndGh9IHtkb2M6bGVuZ3RofVwiXG5cblx0XHRpZiBxdW90ZSA9PSAnXCInICYmIGRvYy5pbmRleE9mKCd7JykgPj0gMFxuXHRcdFx0dmFyIG9wZW4gPSBtYXRjaFsxXVxuXHRcdFx0IyBjb25zb2xlLmxvZyBkb2Muc3Vic3RyKDAsMyksbWF0Y2hbMV1cblx0XHRcdHRva2VuICdTVFJJTkdfU1RBUlQnLCBvcGVuLCBvcGVuOmxlbmd0aFxuXHRcdFx0aW50ZXJwb2xhdGVTdHJpbmcoZG9jLCBoZXJlZG9jOiB5ZXMsIG9mZnNldDogb3BlbjpsZW5ndGgsIHF1b3RlOiBxdW90ZSlcblx0XHRcdHRva2VuICdTVFJJTkdfRU5EJywgb3Blbiwgb3BlbjpsZW5ndGgsIGhlcmVkb2M6bGVuZ3RoIC0gb3BlbjpsZW5ndGhcblx0XHRlbHNlXG5cdFx0XHR0b2tlbignU1RSSU5HJywgbWFrZVN0cmluZyhkb2MsIHF1b3RlLCB5ZXMpLCAwKVxuXG5cdFx0bW92ZUhlYWQoaGVyZWRvYylcblx0XHRyZXR1cm4gaGVyZWRvYzpsZW5ndGhcblxuXHQjIE1hdGNoZXMgYW5kIGNvbnN1bWVzIGNvbW1lbnRzLlxuXHRkZWYgY29tbWVudFRva2VuXG5cdFx0dmFyIG1hdGNoLCBsZW5ndGgsIGNvbW1lbnQsIGluZGVudCwgcHJldlxuXG5cdFx0dmFyIHR5cCA9ICdIRVJFQ09NTUVOVCdcblxuXHRcdGlmIG1hdGNoID0gSU5MSU5FX0NPTU1FTlQuZXhlYyhAY2h1bmspICMgLm1hdGNoKElOTElORV9DT01NRU5UKVxuXHRcdFx0IyBjb25zb2xlLmxvZyBcIm1hdGNoIGlubGluZSBjb21tZW50XCJcblx0XHRcdGxlbmd0aCA9IG1hdGNoWzBdOmxlbmd0aFxuXHRcdFx0aW5kZW50ID0gbWF0Y2hbMV1cblx0XHRcdGNvbW1lbnQgPSBtYXRjaFsyXVxuXG5cdFx0XHRwcmV2ID0gbGFzdChAdG9rZW5zKVxuXHRcdFx0dmFyIHB0ID0gcHJldiBhbmQgdFQocHJldilcblx0XHRcdHZhciBub3RlID0gJy8vJyArIGNvbW1lbnQuc3Vic3RyKDEpXG5cblx0XHRcdGlmIEBsYXN0IGFuZCBAbGFzdDpzcGFjZWRcblx0XHRcdFx0bm90ZSA9ICcgJyArIG5vdGVcblx0XHRcdFx0IyBjb25zb2xlLmxvZyBcInRoZSBwcmV2aW91cyBub2RlIHdhcyBTUEFDRURcIlxuXHRcdFx0IyBjb25zb2xlLmxvZyBcImNvbW1lbnQge25vdGV9IC0gaW5kZW50KHtpbmRlbnR9KSAtIHtsZW5ndGh9IHtjb21tZW50Omxlbmd0aH1cIlxuXG5cdFx0XHRpZiAocHQgYW5kIHB0ICE9ICdJTkRFTlQnIGFuZCBwdCAhPSAnVEVSTUlOQVRPUicpIG9yICFwdFxuXHRcdFx0XHQjIGNvbnNvbGUubG9nIFwic2tpcCBjb21tZW50XCJcblx0XHRcdFx0IyB0b2tlbiAnSU5MSU5FQ09NTUVOVCcsIGNvbW1lbnQuc3Vic3RyKDIpXG5cdFx0XHRcdCMgY29uc29sZS5sb2cgXCJhZGRpbmcgYXMgdGVybWluYXRvclwiXG5cdFx0XHRcdHRva2VuKCdURVJNSU5BVE9SJywgbm90ZSwgbGVuZ3RoKSAjICsgJ1xcbidcblx0XHRcdGVsc2Vcblx0XHRcdFx0IyBjb25zb2xlLmxvZyBcImFkZCBjb21tZW50ICh7bm90ZX0pXCJcblx0XHRcdFx0aWYgcHQgPT0gJ1RFUk1JTkFUT1InXG5cdFx0XHRcdFx0dFZzKHByZXYsdFYocHJldikgKyBub3RlKVxuXHRcdFx0XHRcdCMgcHJldlsxXSArPSBub3RlXG5cdFx0XHRcdGVsaWYgcHQgPT0gJ0lOREVOVCdcblx0XHRcdFx0XHQjIGNvbnNvbGUubG9nIFwiYWRkaW5nIGNvbW1lbnQgdG8gSU5ERU5UOiB7bm90ZX1cIiAjIHdoeSBub3QgYWRkIGRpcmVjdGx5IGhlcmU/XG5cdFx0XHRcdFx0YWRkTGluZWJyZWFrcygxLG5vdGUpXG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHQjIGNvbnNvbGUubG9nIFwiY29tbWVudCBoZXJlXCJcblx0XHRcdFx0XHQjIHNob3VsZCB3ZSBldmVyIGdldCBoZXJlP1xuXHRcdFx0XHRcdHRva2VuKHR5cCwgY29tbWVudC5zdWJzdHIoMiksIGxlbmd0aCkgIyBhcmUgd2Ugc3VyZT9cblx0XHRcdFxuXHRcdFx0cmV0dXJuIGxlbmd0aCAjIGRpc2FibGUgbm93IHdoaWxlIGNvbXBpbGluZ1xuXG5cdFx0IyBzaG91bGQgdXNlIGV4ZWM/XG5cdFx0cmV0dXJuIDAgdW5sZXNzIG1hdGNoID0gQ09NTUVOVC5leGVjKEBjaHVuaylcblxuXHRcdHZhciBjb21tZW50ID0gbWF0Y2hbMF1cblx0XHR2YXIgaGVyZSA9IG1hdGNoWzFdXG5cblx0XHRpZiBoZXJlXG5cdFx0XHR0b2tlbiAnSEVSRUNPTU1FTlQnLCBzYW5pdGl6ZUhlcmVkb2MoaGVyZSwgaGVyZWNvbW1lbnQ6IHRydWUsIGluZGVudDogQXJyYXkoQGluZGVudCArIDEpLmpvaW4oJyAnKSksIGNvbW1lbnQ6bGVuZ3RoXG5cdFx0XHR0b2tlbiAnVEVSTUlOQVRPUicsICdcXG4nXG5cdFx0ZWxzZVxuXHRcdFx0dG9rZW4gJ0hFUkVDT01NRU5UJywgY29tbWVudCwgY29tbWVudDpsZW5ndGhcblx0XHRcdHRva2VuICdURVJNSU5BVE9SJywgJ1xcbicgIyBhdXRvPyByZWFsbHk/XG5cblx0XHRtb3ZlSGVhZChjb21tZW50KVxuXHRcdHJldHVybiBjb21tZW50Omxlbmd0aFxuXG5cdCMgTWF0Y2hlcyBKYXZhU2NyaXB0IGludGVycG9sYXRlZCBkaXJlY3RseSBpbnRvIHRoZSBzb3VyY2UgdmlhIGJhY2t0aWNrcy5cblx0ZGVmIGpzVG9rZW5cblx0XHR2YXIgbWF0Y2gsIHNjcmlwdFxuXG5cdFx0cmV0dXJuIDAgdW5sZXNzIEBjaHVuay5jaGFyQXQoMCkgaXMgJ2AnIGFuZCBtYXRjaCA9IEpTVE9LRU4uZXhlYyhAY2h1bmspXG5cdFx0dG9rZW4gJ0pTJywgKHNjcmlwdCA9IG1hdGNoWzBdKS5zbGljZSAxLCAtMVxuXHRcdHNjcmlwdDpsZW5ndGhcblxuXHQjIE1hdGNoZXMgcmVndWxhciBleHByZXNzaW9uIGxpdGVyYWxzLiBMZXhpbmcgcmVndWxhciBleHByZXNzaW9ucyBpcyBkaWZmaWN1bHRcblx0IyB0byBkaXN0aW5ndWlzaCBmcm9tIGRpdmlzaW9uLCBzbyB3ZSBib3Jyb3cgc29tZSBiYXNpYyBoZXVyaXN0aWNzIGZyb21cblx0IyBKYXZhU2NyaXB0IGFuZCBSdWJ5LlxuXHRkZWYgcmVnZXhUb2tlblxuXHRcdHZhciBtYXRjaCwgbGVuZ3RoLCBwcmV2XG5cblx0XHRyZXR1cm4gMCBpZiBAY2h1bmsuY2hhckF0KDApIGlzbnQgJy8nXG5cdFx0aWYgbWF0Y2ggPSBIRVJFR0VYLmV4ZWMoQGNodW5rKVxuXHRcdFx0bGVuZ3RoID0gaGVyZWdleFRva2VuKG1hdGNoKVxuXHRcdFx0bW92ZUhlYWQobWF0Y2hbMF0pXG5cdFx0XHRyZXR1cm4gbGVuZ3RoXG5cblx0XHRwcmV2ID0gbGFzdCBAdG9rZW5zXG5cdFx0IyBGSVhcblx0XHRyZXR1cm4gMCBpZiBwcmV2IGFuZCAodFQocHJldikgaW4gKGlmIHByZXY6c3BhY2VkIHRoZW4gTk9UX1JFR0VYIGVsc2UgTk9UX1NQQUNFRF9SRUdFWCkpXG5cdFx0cmV0dXJuIDAgdW5sZXNzIG1hdGNoID0gUkVHRVguZXhlYyhAY2h1bmspXG5cdFx0dmFyIFttLCByZWdleCwgZmxhZ3NdID0gbWF0Y2hcblxuXHRcdCMgRklYTUVcblx0XHQjIGlmIHJlZ2V4Wy4uMV0gaXMgJy8qJ1xuXHRcdCNcdGVycm9yICdyZWd1bGFyIGV4cHJlc3Npb25zIGNhbm5vdCBiZWdpbiB3aXRoIGAqYCdcblxuXHRcdGlmIHJlZ2V4ID09ICcvLydcblx0XHRcdHJlZ2V4ID0gJy8oPzopLydcblxuXHRcdHRva2VuICdSRUdFWCcsIFwie3JlZ2V4fXtmbGFnc31cIiwgbTpsZW5ndGhcblx0XHRtOmxlbmd0aFxuXG5cdCMgTWF0Y2hlcyBtdWx0aWxpbmUgZXh0ZW5kZWQgcmVndWxhciBleHByZXNzaW9ucy5cblx0IyBUaGUgZXNjYXBpbmcgc2hvdWxkIHJhdGhlciBoYXBwZW4gaW4gQVNUIC0gcG9zc2libHkgYXMgYW4gYWRkaXRpb25hbCBmbGFnP1xuXHRkZWYgaGVyZWdleFRva2VuIG1hdGNoXG5cdFx0dmFyIFtoZXJlZ2V4LCBib2R5LCBmbGFnc10gPSBtYXRjaFxuXG5cdFx0aWYgMCA+IGJvZHkuaW5kZXhPZignI3snKVxuXG5cdFx0XHR2YXIgcmUgPSBib2R5LnJlcGxhY2UoSEVSRUdFWF9PTUlULCAnJykucmVwbGFjZSgvXFwvL2csICdcXFxcLycpXG5cblx0XHRcdGlmIHJlLm1hdGNoKC9eXFwqLylcblx0XHRcdFx0ZXJyb3IgJ3JlZ3VsYXIgZXhwcmVzc2lvbnMgY2Fubm90IGJlZ2luIHdpdGggYCpgJ1xuXG5cdFx0XHR0b2tlbiAnUkVHRVgnLCBcIi97IHJlIG9yICcoPzopJyB9L3tmbGFnc31cIiwgaGVyZWdleDpsZW5ndGhcblx0XHRcdHJldHVybiBoZXJlZ2V4Omxlbmd0aFxuXG5cdFx0IyB1c2UgbW9yZSBiYXNpYyByZWdleCB0eXBlXG5cblx0XHR0b2tlbiAnQ09OU1QnLCAnUmVnRXhwJ1xuXHRcdEB0b2tlbnMucHVzaCBULnRva2VuKCdDQUxMX1NUQVJUJywgJygnLDApXG5cdFx0dmFyIHRva2VucyA9IFtdXG5cblx0XHRmb3IgcGFpciBpbiBpbnRlcnBvbGF0ZVN0cmluZyhib2R5LCByZWdleDogeWVzKVxuXG5cdFx0XHR2YXIgdG9rID0gdFQocGFpcikgIyBGSVhcblx0XHRcdHZhciB2YWx1ZSA9IHRWKHBhaXIpICMgRklYXG5cblx0XHRcdGlmIHRvayA9PSAnVE9LRU5TJ1xuXHRcdFx0XHQjIEZJWE1FIHdoYXQgaXMgdGhpcz9cblx0XHRcdFx0dG9rZW5zLnB1c2ggKnZhbHVlXG5cdFx0XHRlbHNlXG5cdFx0XHRcdGlmICF2YWx1ZVxuXHRcdFx0XHRcdGNvbnNvbGUubG9nIFwid2hhdD8/XCJcblxuXHRcdFx0XHRjb250aW51ZSB1bmxlc3MgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKEhFUkVHRVhfT01JVCwgJycpXG5cblx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5yZXBsYWNlIC9cXFxcL2csICdcXFxcXFxcXCdcblx0XHRcdFx0dG9rZW5zLnB1c2ggVC50b2tlbignU1RSSU5HJywgbWFrZVN0cmluZyh2YWx1ZSwgJ1wiJywgeWVzKSwgMCkgIyBGSVhcblxuXHRcdFx0dG9rZW5zLnB1c2ggVC50b2tlbignKycsICcrJywgMCkgIyBGSVhcblxuXHRcdHRva2Vucy5wb3BcblxuXHRcdCMgRklYXG5cdFx0dW5sZXNzIHRva2Vuc1swXSBhbmQgdFQodG9rZW5zWzBdKSBpcyAnU1RSSU5HJ1xuXHRcdFx0IyBGSVhcblx0XHRcdEB0b2tlbnMucHVzaCBULnRva2VuKCdTVFJJTkcnLCAnXCJcIicpLCBULnRva2VuKCcrJywgJysnKVxuXG5cdFx0QHRva2Vucy5wdXNoICp0b2tlbnMgIyB3aGF0IGlzIHRoaXM/XG5cdFx0IyBGSVhcblxuXHRcdGlmIGZsYWdzXG5cdFx0XHRAdG9rZW5zLnB1c2goVC50b2tlbignLCcsICcsJywgMCkpXG5cdFx0XHRAdG9rZW5zLnB1c2goVC50b2tlbignU1RSSU5HJywgJ1wiJyArIGZsYWdzICsgJ1wiJywgMCkpXG5cblx0XHR0b2tlbignKScsICcpJywwKVxuXG5cdFx0cmV0dXJuIGhlcmVnZXg6bGVuZ3RoXG5cblx0IyBNYXRjaGVzIG5ld2xpbmVzLCBpbmRlbnRzLCBhbmQgb3V0ZGVudHMsIGFuZCBkZXRlcm1pbmVzIHdoaWNoIGlzIHdoaWNoLlxuXHQjIElmIHdlIGNhbiBkZXRlY3QgdGhhdCB0aGUgY3VycmVudCBsaW5lIGlzIGNvbnRpbnVlZCBvbnRvIHRoZSB0aGUgbmV4dCBsaW5lLFxuXHQjIHRoZW4gdGhlIG5ld2xpbmUgaXMgc3VwcHJlc3NlZDpcblx0I1xuXHQjICAgICBlbGVtZW50c1xuXHQjICAgICAgIC5lYWNoKCAuLi4gKVxuXHQjICAgICAgIC5tYXAoIC4uLiApXG5cdCNcblx0IyBLZWVwcyB0cmFjayBvZiB0aGUgbGV2ZWwgb2YgaW5kZW50YXRpb24sIGJlY2F1c2UgYSBzaW5nbGUgb3V0ZGVudCB0b2tlblxuXHQjIGNhbiBjbG9zZSBtdWx0aXBsZSBpbmRlbnRzLCBzbyB3ZSBuZWVkIHRvIGtub3cgaG93IGZhciBpbiB3ZSBoYXBwZW4gdG8gYmUuXG5cdGRlZiBsaW5lVG9rZW5cblx0XHR2YXIgbWF0Y2hcblxuXHRcdHJldHVybiAwIHVubGVzcyBtYXRjaCA9IE1VTFRJX0RFTlQuZXhlYyhAY2h1bmspXG5cblx0XHR2YXIgaW5kZW50ID0gbWF0Y2hbMF1cblx0XHR2YXIgYnJDb3VudCA9IG1vdmVIZWFkKGluZGVudClcblxuXHRcdEBzZWVuRm9yID0gbm9cblx0XHQjIHJlc2V0IGNvbHVtbiBhcyB3ZWxsP1xuXG5cdFx0dmFyIHByZXYgPSBsYXN0IEB0b2tlbnMsIDFcblx0XHRsZXQgd2hpdGVzcGFjZSA9IGluZGVudC5zdWJzdHIoaW5kZW50Lmxhc3RJbmRleE9mKCdcXG4nKSArIDEpXG5cdFx0dmFyIHNpemUgPSB3aGl0ZXNwYWNlOmxlbmd0aFxuXHRcdHZhciBub05ld2xpbmVzID0gc2VsZi51bmZpbmlzaGVkXG5cblx0XHRpZiAoL15cXG4jXFxzLykudGVzdChAY2h1bmspXG5cdFx0XHRhZGRMaW5lYnJlYWtzKDEpXG5cdFx0XHRyZXR1cm4gMFxuXG5cdFx0aWYgc2l6ZSA+IDBcblx0XHRcdHVubGVzcyBAaW5kZW50U3R5bGVcblx0XHRcdFx0QG9wdHM6aW5kZW50ID0gQGluZGVudFN0eWxlID0gd2hpdGVzcGFjZVxuXG5cdFx0XHRsZXQgaW5kZW50U2l6ZSA9IDBcblx0XHRcdGxldCBvZmZzZXQgPSAwXG5cblx0XHRcdHdoaWxlIHRydWVcblx0XHRcdFx0bGV0IGlkeCA9IHdoaXRlc3BhY2UuaW5kZXhPZihAaW5kZW50U3R5bGUsb2Zmc2V0KVxuXHRcdFx0XHRpZiBpZHggPT0gb2Zmc2V0XG5cdFx0XHRcdFx0aW5kZW50U2l6ZSsrXG5cdFx0XHRcdFx0b2Zmc2V0ICs9IEBpbmRlbnRTdHlsZVsnbGVuZ3RoJ11cblx0XHRcdFx0ZWxpZiBvZmZzZXQgPT0gd2hpdGVzcGFjZTpsZW5ndGhcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0IyB3b3JrYXJvdW5kIHRvIHJlcG9ydCBjb3JyZWN0IGxvY2F0aW9uXG5cdFx0XHRcdFx0QGxvYyArPSBpbmRlbnQ6bGVuZ3RoIC0gd2hpdGVzcGFjZTpsZW5ndGhcblx0XHRcdFx0XHR0b2tlbignSU5ERU5UJywgd2hpdGVzcGFjZSx3aGl0ZXNwYWNlOmxlbmd0aClcblx0XHRcdFx0XHRyZXR1cm4gZXJyb3IoJ2luY29uc2lzdGVudCBpbmRlbnRhdGlvbicpXG5cblx0XHRcdHNpemUgPSBpbmRlbnRTaXplXG5cblxuXHRcdGlmIHNpemUgLSBAaW5kZWJ0IGlzIEBpbmRlbnRcblx0XHRcdGlmIG5vTmV3bGluZXNcblx0XHRcdFx0c3VwcHJlc3NOZXdsaW5lcygpXG5cdFx0XHRlbHNlXG5cdFx0XHRcdG5ld2xpbmVUb2tlbihickNvdW50KVxuXHRcdFx0cmV0dXJuIGluZGVudDpsZW5ndGhcblxuXHRcdGlmIHNpemUgPiBAaW5kZW50XG5cdFx0XHRpZiBub05ld2xpbmVzXG5cdFx0XHRcdEBpbmRlYnQgPSBzaXplIC0gQGluZGVudFxuXHRcdFx0XHRzdXBwcmVzc05ld2xpbmVzXG5cdFx0XHRcdHJldHVybiBpbmRlbnQ6bGVuZ3RoXG5cblx0XHRcdGlmIGluVGFnKClcblx0XHRcdFx0IyBjb25zb2xlLmxvZyBcImluZGVudCBpbnNpZGUgdG9raWQ/IT9cIlxuXHRcdFx0XHQjIEBpbmRlYnQgPSBzaXplIC0gQGluZGVudFxuXHRcdFx0XHQjIHN1cHByZXNzTmV3bGluZXMoKVxuXHRcdFx0XHRyZXR1cm4gaW5kZW50Omxlbmd0aFxuXG5cblx0XHRcdHZhciBkaWZmID0gc2l6ZSAtIEBpbmRlbnQgKyBAb3V0ZGVidFxuXHRcdFx0Y2xvc2VEZWYoKVxuXG5cdFx0XHR2YXIgaW1tZWRpYXRlID0gbGFzdChAdG9rZW5zKVxuXG5cdFx0XHRpZiBpbW1lZGlhdGUgYW5kIHRUKGltbWVkaWF0ZSkgPT0gJ1RFUk1JTkFUT1InXG5cdFx0XHRcdHRUcyhpbW1lZGlhdGUsJ0lOREVOVCcpXG5cdFx0XHRcdGltbWVkaWF0ZS5AbWV0YSB8fD0ge3ByZTogdFYoaW1tZWRpYXRlKSwgcG9zdDogJyd9XG5cblx0XHRcdFx0IyBzaG91bGQgcmF0aGVyIGFkZCB0byBtZXRhIHNvbWVob3c/IT9cblx0XHRcdFx0IyB0VnMoaW1tZWRpYXRlLHRWKGltbWVkaWF0ZSkgKyAnJXwlJykgIyBjcmF6eVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHR0b2tlbignSU5ERU5UJywgXCJcIiArIGRpZmYsMClcblxuXHRcdFx0IyBjb25zb2xlLmxvZyBcImluZGVudGluZ1wiLCBwcmV2LCBsYXN0KEB0b2tlbnMsMSlcblx0XHRcdCMgaWYgcHJldiBhbmQgcHJldlswXSA9PSAnVEVSTUlOQVRPUidcblx0XHRcdCMgICBjb25zb2xlLmxvZyBcInRlcm1pbmF0b3IgYmVmb3JlIGluZGVudD8/XCJcblxuXHRcdFx0IyBjaGVjayBmb3IgY29tbWVudHMgYXMgd2VsbCA/XG5cblx0XHRcdEBpbmRlbnRzLnB1c2ggZGlmZlxuXHRcdFx0cHVzaEVuZCgnT1VUREVOVCcpXG5cdFx0XHQjIEBlbmRzLnB1c2ggJ09VVERFTlQnXG5cdFx0XHRAb3V0ZGVidCA9IEBpbmRlYnQgPSAwXG5cdFx0XHRhZGRMaW5lYnJlYWtzKGJyQ291bnQpXG5cdFx0ZWxzZVxuXHRcdFx0QGluZGVidCA9IDBcblx0XHRcdG91dGRlbnRUb2tlbihAaW5kZW50IC0gc2l6ZSwgbm9OZXdsaW5lcywgYnJDb3VudClcblx0XHRcdGFkZExpbmVicmVha3MoYnJDb3VudCAtIDEpXG5cdFx0XHQjIGNvbnNvbGUubG9nIFwib3V0ZGVudFwiLG5vTmV3bGluZXMsdG9raWQoKVxuXG5cdFx0QGluZGVudCA9IHNpemVcblx0XHRyZXR1cm4gaW5kZW50Omxlbmd0aFxuXG5cdCMgUmVjb3JkIGFuIG91dGRlbnQgdG9rZW4gb3IgbXVsdGlwbGUgdG9rZW5zLCBpZiB3ZSBoYXBwZW4gdG8gYmUgbW92aW5nIGJhY2tcblx0IyBpbndhcmRzIHBhc3Qgc2V2ZXJhbCByZWNvcmRlZCBpbmRlbnRzLlxuXHRkZWYgb3V0ZGVudFRva2VuIG1vdmVPdXQsIG5vTmV3bGluZXMsIG5ld2xpbmVDb3VudFxuXHRcdCMgaGVyZSB3ZSBzaG91bGQgYWxzbyB0YWtlIGNhcmUgdG8gcG9wIC8gcmVzZXQgdGhlIHNjb3BlLWJvZHlcblx0XHQjIG9yIGNvbnRleHQtdHlwZSBmb3IgaW5kZW50YXRpb24gXG5cdFx0dmFyIGRlbnQgPSAwXG5cdFx0d2hpbGUgbW92ZU91dCA+IDBcblx0XHRcdHZhciBsZW4gPSBAaW5kZW50czpsZW5ndGggLSAxXG5cdFx0XHRpZiBAaW5kZW50c1tsZW5dIGlzIHVuZGVmaW5lZFxuXHRcdFx0XHRtb3ZlT3V0ID0gMFxuXHRcdFx0ZWxpZiBAaW5kZW50c1tsZW5dIGlzIEBvdXRkZWJ0XG5cdFx0XHRcdG1vdmVPdXQgLT0gQG91dGRlYnRcblx0XHRcdFx0QG91dGRlYnQgPSAwXG5cdFx0XHRlbGlmIEBpbmRlbnRzW2xlbl0gPCBAb3V0ZGVidFxuXHRcdFx0XHRAb3V0ZGVidCAtPSBAaW5kZW50c1tsZW5dXG5cdFx0XHRcdG1vdmVPdXQgIC09IEBpbmRlbnRzW2xlbl1cblx0XHRcdGVsc2Vcblx0XHRcdFx0ZGVudCA9IEBpbmRlbnRzLnBvcCAtIEBvdXRkZWJ0XG5cdFx0XHRcdG1vdmVPdXQgLT0gZGVudFxuXHRcdFx0XHRAb3V0ZGVidCA9IDBcblxuXHRcdFx0XHRhZGRMaW5lYnJlYWtzKDEpIHVubGVzcyBub05ld2xpbmVzXG5cblx0XHRcdFx0cGFpciAnT1VUREVOVCdcblx0XHRcdFx0dG9rZW4oJ09VVERFTlQnLCBcIlwiICsgZGVudCwgMClcblxuXHRcdEBvdXRkZWJ0IC09IG1vdmVPdXQgaWYgZGVudFxuXG5cdFx0QHRva2Vucy5wb3Agd2hpbGUgbGFzdFRva2VuVmFsdWUgPT0gJzsnXG5cblx0XHR0b2tlbignVEVSTUlOQVRPUicsJ1xcbicsMCkgdW5sZXNzIGxhc3RUb2tlblR5cGUgPT0gJ1RFUk1JTkFUT1InIG9yIG5vTmV3bGluZXNcblxuXHRcdCMgY2FwcGluZyBzY29wZXMgc28gdGhleSBkb250IGhhbmcgYXJvdW5kIFxuXHRcdEBzY29wZXM6bGVuZ3RoID0gQGluZGVudHM6bGVuZ3RoXG5cblx0XHR2YXIgY3R4ID0gY29udGV4dFxuXHRcdHBhaXIoY3R4KSBpZiBjdHggPT0gJyUnIG9yIGN0eCA9PSAnVEFHJyAjIHJlYWxseT9cblx0XHRjbG9zZURlZlxuXHRcdHJldHVybiB0aGlzXG5cblx0IyBNYXRjaGVzIGFuZCBjb25zdW1lcyBub24tbWVhbmluZ2Z1bCB3aGl0ZXNwYWNlLiB0b2tpZCB0aGUgcHJldmlvdXMgdG9rZW5cblx0IyBhcyBiZWluZyBcInNwYWNlZFwiLCBiZWNhdXNlIHRoZXJlIGFyZSBzb21lIGNhc2VzIHdoZXJlIGl0IG1ha2VzIGEgZGlmZmVyZW5jZS5cblx0ZGVmIHdoaXRlc3BhY2VUb2tlblxuXHRcdHZhciBtYXRjaCwgbmxpbmUsIHByZXZcblx0XHRyZXR1cm4gMCB1bmxlc3MgKG1hdGNoID0gV0hJVEVTUEFDRS5leGVjKEBjaHVuaykpIHx8IChubGluZSA9IEBjaHVuay5jaGFyQXQoMCkgaXMgJ1xcbicpXG5cdFx0cHJldiA9IGxhc3QgQHRva2Vuc1xuXG5cdFx0IyBGSVggLSB3aHkgb2ggd2h5P1xuXHRcdGlmIHByZXZcblx0XHRcdGlmIG1hdGNoXG5cdFx0XHRcdHByZXY6c3BhY2VkID0geWVzXG5cdFx0XHRcdHJldHVybiBtYXRjaFswXTpsZW5ndGhcblx0XHRcdGVsc2Vcblx0XHRcdFx0cHJldjpuZXdMaW5lID0geWVzXG5cdFx0XHRcdHJldHVybiAwXG5cblx0ZGVmIGFkZE5ld2xpbmVcblx0XHR0b2tlbiAnVEVSTUlOQVRPUicsICdcXG4nXG5cblx0ZGVmIG1vdmVIZWFkIHN0clxuXHRcdHZhciBiciA9IGNvdW50KHN0ciwnXFxuJylcblx0XHRyZXR1cm4gYnJcblx0XHRcblxuXHRkZWYgYWRkTGluZWJyZWFrcyBjb3VudCwgcmF3XG5cdFx0dmFyIGJyXG5cblx0XHRyZXR1cm4gdGhpcyBpZiAhcmF3IGFuZCBjb3VudCA9PSAwICMgbm8gdGVybWluYXRvcnM/XG5cblx0XHR2YXIgcHJldiA9IEBsYXN0XG5cblx0XHRpZiAhcmF3XG5cdFx0XHRpZiBjb3VudCA9PSAxXG5cdFx0XHRcdGJyID0gJ1xcbidcblx0XHRcdGVsaWYgY291bnQgPT0gMlxuXHRcdFx0XHRiciA9ICdcXG5cXG4nXG5cdFx0XHRlbGlmIGNvdW50ID09IDNcblx0XHRcdFx0YnIgPSAnXFxuXFxuXFxuJ1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRiciA9IHJlcGVhdFN0cmluZygnXFxuJyxjb3VudClcblx0XHQjIEZJWFxuXHRcdGlmIHByZXZcblx0XHRcdHZhciB0ID0gcHJldi5AdHlwZSAjIEBsYXN0VHlwXG5cdFx0XHR2YXIgdiA9IHRWKHByZXYpXG5cblx0XHRcdCMgd2UgcmVhbGx5IHdhbnQgdG8gYWRkIHRoaXNcblx0XHRcdGlmIHQgPT0gJ0lOREVOVCdcblx0XHRcdFx0IyBUT0RPIHdlIHdhbnQgdG8gYWRkIHRvIHRoZSBpbmRlbnRcblx0XHRcdFx0IyBjb25zb2xlLmxvZyBcImFkZCB0aGUgY29tbWVudCB0byB0aGUgaW5kZW50IC0tIHByZT8ge3Jhd30ge2JyfVwiXG5cdFx0XHRcblx0XHRcdFx0dmFyIG1ldGEgPSBwcmV2LkBtZXRhIHx8PSB7cHJlOiAnJywgcG9zdDogJyd9XG5cdFx0XHRcdG1ldGE6cG9zdCArPSAocmF3IG9yIGJyKVxuXHRcdFx0XHQjIHRWcyh2ICsgKHJhdyBvciBicikpXG5cdFx0XHRcdHJldHVybiB0aGlzXG5cblx0XHRcdGVsaWYgdCA9PSAnVEVSTUlOQVRPUidcblx0XHRcdFx0IyBjb25zb2xlLmxvZyBcImFscmVhZHkgZXhpc3RzIHRlcm1pbmF0b3Ige2JyfSB7cmF3fVwiXG5cdFx0XHRcdHRWcyhwcmV2LHYgKyAocmF3IG9yIGJyKSlcblx0XHRcdFx0cmV0dXJuIHRoaXNcblx0XHRcblx0XHR0b2tlbignVEVSTUlOQVRPUicsIGJyLCAwKVxuXHRcdHJldHVyblxuXG5cdCMgR2VuZXJhdGUgYSBuZXdsaW5lIHRva2VuLiBDb25zZWN1dGl2ZSBuZXdsaW5lcyBnZXQgbWVyZ2VkIHRvZ2V0aGVyLlxuXHRkZWYgbmV3bGluZVRva2VuIGxpbmVzXG5cdFx0IyBjb25zb2xlLmxvZyBcIm5ld2xpbmVUb2tlblwiXG5cdFx0d2hpbGUgbGFzdFRva2VuVmFsdWUoKSA9PSAnOydcblx0XHRcdGNvbnNvbGUubG9nIFwicG9wIHRva2VuXCIsQHRva2Vuc1tAdG9rZW5zOmxlbmd0aCAtIDFdXG5cdFx0XHRAdG9rZW5zLnBvcFxuXG5cdFx0YWRkTGluZWJyZWFrcyhsaW5lcylcblxuXHRcdHZhciBjdHggPSBjb250ZXh0XG5cdFx0IyBXQVJOIG5vdyBpbXBvcnQgY2Fubm90IGdvIG92ZXIgbXVsdGlwbGUgbGluZXNcblx0XHRwYWlyKGN0eCkgaWYgY3R4ID09ICdUQUcnIG9yIGN0eCA9PSAnSU1QT1JUJ1xuXHRcdGNsb3NlRGVmKCkgICMgY2xvc2UgZGVmIC0tIHJlYWxseT9cblx0XHR0aGlzXG5cblx0IyBVc2UgYSBgXFxgIGF0IGEgbGluZS1lbmRpbmcgdG8gc3VwcHJlc3MgdGhlIG5ld2xpbmUuXG5cdCMgVGhlIHNsYXNoIGlzIHJlbW92ZWQgaGVyZSBvbmNlIGl0cyBqb2IgaXMgZG9uZS5cblx0ZGVmIHN1cHByZXNzTmV3bGluZXNcblx0XHRAdG9rZW5zLnBvcCBpZiB2YWx1ZSgpIGlzICdcXFxcJ1xuXHRcdHRoaXNcblxuXHQjIFdlIHRyZWF0IGFsbCBvdGhlciBzaW5nbGUgY2hhcmFjdGVycyBhcyBhIHRva2VuLiBFLmcuOiBgKCApICwgLiAhYFxuXHQjIE11bHRpLWNoYXJhY3RlciBvcGVyYXRvcnMgYXJlIGFsc28gbGl0ZXJhbCB0b2tlbnMsIHNvIHRoYXQgSmlzb24gY2FuIGFzc2lnblxuXHQjIHRoZSBwcm9wZXIgb3JkZXIgb2Ygb3BlcmF0aW9ucy4gVGhlcmUgYXJlIHNvbWUgc3ltYm9scyB0aGF0IHdlIHRva2lkIHNwZWNpYWxseVxuXHQjIGhlcmUuIGA7YCBhbmQgbmV3bGluZXMgYXJlIGJvdGggdHJlYXRlZCBhcyBhIGBURVJNSU5BVE9SYCwgd2UgZGlzdGluZ3Vpc2hcblx0IyBwYXJlbnRoZXNlcyB0aGF0IGluZGljYXRlIGEgbWV0aG9kIGNhbGwgZnJvbSByZWd1bGFyIHBhcmVudGhlc2VzLCBhbmQgc28gb24uXG5cdGRlZiBsaXRlcmFsVG9rZW5cblx0XHR2YXIgbWF0Y2gsIHZhbHVlXG5cdFx0aWYgbWF0Y2ggPSBPUEVSQVRPUi5leGVjKEBjaHVuaylcblx0XHRcdHZhbHVlID0gbWF0Y2hbMF1cblx0XHRcdHRhZ1BhcmFtZXRlcnMgaWYgQ09ERS50ZXN0KHZhbHVlKVxuXHRcdGVsc2Vcblx0XHRcdHZhbHVlID0gQGNodW5rLmNoYXJBdCgwKVxuXHRcdFxuXHRcdHZhciBlbmQxID0gQGVuZHNbQGVuZHM6bGVuZ3RoIC0gMV1cblx0XHR2YXIgZW5kMiA9IEBlbmRzW0BlbmRzOmxlbmd0aCAtIDJdXG5cblx0XHR2YXIgaW5UYWcgPSBlbmQxID09ICdUQUdfRU5EJyBvciBlbmQxICA9PSAnT1VUREVOVCcgYW5kIGVuZDIgPT0gJ1RBR19FTkQnXG5cblx0XHR2YXIgdG9raWQgPSB2YWx1ZVxuXHRcdHZhciBwcmV2ICA9IGxhc3QgQHRva2Vuc1xuXHRcdHZhciBwdCA9IHByZXYgYW5kIHRUKHByZXYpXG5cdFx0dmFyIHB2ID0gcHJldiBhbmQgdFYocHJldilcblx0XHR2YXIgbGVuZ3RoID0gdmFsdWU6bGVuZ3RoXG5cblx0XHQjIGlzIHRoaXMgbmVlZGVkP1xuXHRcdGlmIHZhbHVlID09ICc9JyBhbmQgcHJldlxuXG5cdFx0XHRpZiBwdiA9PSAnfHwnIG9yIHB2ID09ICcmJicgIyBpbiBbJ3x8JywgJyYmJ11cblx0XHRcdFx0dFRzKHByZXYsJ0NPTVBPVU5EX0FTU0lHTicpXG5cdFx0XHRcdHRWcyhwcmV2LHB2ICsgJz0nKVxuXHRcdFx0XHQjIHByZXZbMF0gPSAnQ09NUE9VTkRfQVNTSUdOJ1xuXHRcdFx0XHQjIHByZXZbMV0gKz0gJz0nXG5cdFx0XHRcdHJldHVybiB2YWx1ZTpsZW5ndGhcblxuXHRcdGlmIHZhbHVlIGlzICc7JyAgICAgICAgICAgICBcblx0XHRcdEBzZWVuRm9yID0gbm9cblx0XHRcdHRva2lkID0gJ1RFUk1JTkFUT1InXG5cblx0XHRlbGlmIHZhbHVlIGlzICcoJyBhbmQgaW5UYWcgYW5kIHB0ICE9ICc9JyBhbmQgcHJldjpzcGFjZWQgIyBGSVhlZFxuXHRcdFx0IyBjb25zb2xlLmxvZyAnc3BhY2VkIGJlZm9yZSAoIGluIHRva2lkJ1xuXHRcdFx0IyBGSVhNRSAtIHNob3VsZCByYXRoZXIgYWRkIGEgc3BlY2lhbCB0b2tlbiBsaWtlIFRBR19QQVJBTVNfU1RBUlRcblx0XHRcdHRva2VuICcsJywnLCdcblxuXHRcdGVsaWYgdmFsdWUgaXMgJy0+JyBhbmQgaW5UYWdcblx0XHRcdHRva2lkID0gJ1RBR19FTkQnXG5cdFx0XHRwYWlyICdUQUdfRU5EJ1xuXG5cdFx0ZWxpZiB2YWx1ZSBpcyAnLz4nIGFuZCBpblRhZ1xuXHRcdFx0dG9raWQgPSAnVEFHX0VORCdcblx0XHRcdHBhaXIgJ1RBR19FTkQnXG5cblx0XHRlbGlmIHZhbHVlIGlzICc+JyBhbmQgaW5UYWdcblx0XHRcdHRva2lkID0gJ1RBR19FTkQnXG5cdFx0XHRwYWlyICdUQUdfRU5EJ1xuXG5cdFx0IyB0aGlzIGlzIGEgdG9raWQtbWV0aG9kXG5cdFx0ZWxpZiB2YWx1ZSBpcyAnPicgYW5kIGNvbnRleHQgPT0gJ0RFRidcblx0XHRcdCMgY29uc29sZS5sb2coJ3BpY2tlZCB1cCA+ISEnKVxuXHRcdFx0dG9raWQgPSAnREVGX0ZSQUdNRU5UJ1xuXHRcblx0XHRcdCMgZWxpZiB2YWx1ZSBpcyAnVEVSTUlOQVRPUicgYW5kIGVuZDEgaXMgJyUnIFxuXHRcdFx0IyBcdGNsb3NlU2VsZWN0b3IoKVxuXG5cdFx0ZWxpZiB2YWx1ZSBpcyAnVEVSTUlOQVRPUicgYW5kIGVuZDEgaXMgJ0RFRidcblx0XHRcdGNsb3NlRGVmKClcblxuXHRcdCMgVE9ETyBCTE9DSyBQQVJBTSBCVUdcblx0XHQjIHJlYWxseStcblx0XHRlbGlmIHZhbHVlIGlzICcmJyBhbmQgY29udGV4dCA9PSAnREVGJ1xuXHRcdFx0IyBjb25zb2xlLmxvZyhcIm9rYXkhXCIpXG5cdFx0XHR0b2tpZCA9ICdCTE9DS19BUkcnXG5cdFx0XHQjIGNoYW5nZSB0aGUgbmV4dCBpZGVudGlmaWVyIGluc3RlYWQ/XG5cblx0XHQjIGVsaWYgdmFsdWUubWF0Y2goKVxuXHRcdGVsaWYgdmFsdWUgPT0gJyonIGFuZCBAY2h1bmsuY2hhckF0KDEpLm1hdGNoKC9bQS1aYS16XFxfXFxAXFxbXS8pIGFuZCAocHJldjpzcGFjZWQgb3IgWycsJywnKCcsJ1snLCd7JywnfCcsJ1xcbicsJ1xcdCddLmluZGV4T2YocHYpID49IDApXG5cdFx0XHR0b2tpZCA9IFwiU1BMQVRcIlxuXG5cdFx0ZWxpZiB2YWx1ZSA9PSAn4oiaJ1xuXHRcdFx0dG9raWQgPSAnU1FSVCdcblx0XHRlbGlmIHZhbHVlID09ICfGkidcblx0XHRcdHRva2lkID0gJ0ZVTkMnXG5cdFx0ZWxpZiB2YWx1ZSBpbiBNQVRIXG5cdFx0XHR0b2tpZCA9ICdNQVRIJ1xuXHRcdGVsaWYgdmFsdWUgaW4gQ09NUEFSRVxuXHRcdFx0dG9raWQgPSAnQ09NUEFSRSdcblx0XHRlbGlmIHZhbHVlIGluIENPTVBPVU5EX0FTU0lHTlxuXHRcdFx0dG9raWQgPSAnQ09NUE9VTkRfQVNTSUdOJ1xuXHRcdGVsaWYgdmFsdWUgaW4gVU5BUllcblx0XHRcdHRva2lkID0gJ1VOQVJZJ1xuXHRcdGVsaWYgdmFsdWUgaW4gU0hJRlRcblx0XHRcdHRva2lkID0gJ1NISUZUJ1xuXHRcdGVsaWYgdmFsdWUgaW4gTE9HSUNcblx0XHRcdHRva2lkID0gJ0xPR0lDJyAjIG9yIHZhbHVlIGlzICc/JyBhbmQgcHJldj86c3BhY2VkIFxuXG5cdFx0ZWxpZiBwcmV2IGFuZCAhcHJldjpzcGFjZWRcblx0XHRcdCMgbmVlZCBhIGJldHRlciB3YXkgdG8gZG8gdGhlc2Vcblx0XHRcdGlmIHZhbHVlIGlzICcoJyBhbmQgZW5kMSA9PSAnJSdcblx0XHRcdFx0dG9raWQgPSAnVEFHX0FUVFJTX1NUQVJUJ1xuXG5cdFx0XHRlbGlmIHZhbHVlIGlzICcoJyBhbmQgcHQgaW4gQ0FMTEFCTEVcblx0XHRcdFx0IyBub3QgdXNpbmcgdGhpcyA/Pz9cblx0XHRcdFx0IyBwcmV2WzBdID0gJ0ZVTkNfRVhJU1QnIGlmIHByZXZbMF0gaXMgJz8nXG5cdFx0XHRcdHRva2lkID0gJ0NBTExfU1RBUlQnXG5cblx0XHRcdGVsaWYgdmFsdWUgaXMgJ1snIGFuZCBwdCBpbiBJTkRFWEFCTEVcblx0XHRcdFx0dG9raWQgPSAnSU5ERVhfU1RBUlQnXG5cdFx0XHRcdHRUcyhwcmV2LCdJTkRFWF9TT0FLJykgaWYgcHQgPT0gJz8nXG5cdFx0XHRcdCMgcHJldlswXSA9ICdJTkRFWF9TT0FLJyBpZiBwcmV2WzBdID09ICc/J1xuXG5cdFx0c3dpdGNoIHZhbHVlXG5cdFx0XHR3aGVuICcoJywgJ3snLCAnWycgdGhlbiBwdXNoRW5kKElOVkVSU0VTW3ZhbHVlXSlcblx0XHRcdHdoZW4gJyknLCAnfScsICddJyB0aGVuIHBhaXIgdmFsdWVcblxuXHRcdCMgaGFja3kgcnVsZSB0byB0cnkgdG8gYWxsb3cgZm9yIHR1cGxlLWFzc2lnbm1lbnRzIGluIGJsb2Nrc1xuXHRcdCMgaWYgdmFsdWUgaXMgJywnIGFuZCBwcmV2WzBdIGlzICdJREVOVElGSUVSJyBhbmQgQHRva2Vuc1tAdG9rZW5zOmxlbmd0aCAtIDJdWzBdIGluIFsnVEVSTUlOQVRPUicsJ0lOREVOVCddXG5cdFx0IyAgICMgdG9rZW4gXCJUVVBMRVwiLCBcInR1cGxlXCIgIyBzaG91bGQgcmF0aGVyIGluc2VydCBpdCBzb21ld2hlcmUgZWxzZSwgbm8/XG5cdFx0IyAgIGNvbnNvbGUubG9nKFwiZm91bmQgY29tbWFcIilcblxuXHRcdHRva2VuKHRva2lkLCB2YWx1ZSwgdmFsdWU6bGVuZ3RoKVxuXHRcdHJldHVybiB2YWx1ZTpsZW5ndGhcblxuXHQjIFRva2VuIE1hbmlwdWxhdG9yc1xuXHQjIC0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdCMgU2FuaXRpemUgYSBoZXJlZG9jIG9yIGhlcmVjb21tZW50IGJ5XG5cdCMgZXJhc2luZyBhbGwgZXh0ZXJuYWwgaW5kZW50YXRpb24gb24gdGhlIGxlZnQtaGFuZCBzaWRlLlxuXHRkZWYgc2FuaXRpemVIZXJlZG9jIGRvYywgb3B0aW9uc1xuXHRcdHZhciBtYXRjaFxuXHRcdHZhciBpbmRlbnQgPSBvcHRpb25zOmluZGVudFxuXHRcdHZhciBoZXJlY29tbWVudCA9IG9wdGlvbnM6aGVyZWNvbW1lbnRcblxuXHRcdGlmIGhlcmVjb21tZW50XG5cdFx0XHRpZiBIRVJFRE9DX0lMTEVHQUwudGVzdChkb2MpXG5cdFx0XHRcdGVycm9yIFwiYmxvY2sgY29tbWVudCBjYW5ub3QgY29udGFpbiAnKi8nIHN0YXJ0aW5nXCJcblx0XHRcdHJldHVybiBkb2MgaWYgZG9jLmluZGV4T2YoJ1xcbicpIDw9IDBcblx0XHRlbHNlXG5cdFx0XHR3aGlsZSBtYXRjaCA9IEhFUkVET0NfSU5ERU5ULmV4ZWMoZG9jKVxuXHRcdFx0XHR2YXIgYXR0ZW1wdCA9IG1hdGNoWzFdXG5cdFx0XHRcdGlmIGluZGVudCBpcyBudWxsIG9yIDAgPCBhdHRlbXB0Omxlbmd0aCA8IGluZGVudDpsZW5ndGhcblx0XHRcdFx0XHRpbmRlbnQgPSBhdHRlbXB0XG5cblx0XHRkb2MgPSBkb2MucmVwbGFjZSBSZWdFeHAoXCJcXFxcbntpbmRlbnR9XCIsXCJnXCIpLCAnXFxuJyBpZiBpbmRlbnRcblx0XHRkb2MgPSBkb2MucmVwbGFjZSAvXlxcbi8sICcnIHVubGVzcyBoZXJlY29tbWVudFxuXHRcdHJldHVybiBkb2NcblxuXHQjIEEgc291cmNlIG9mIGFtYmlndWl0eSBpbiBvdXIgZ3JhbW1hciB1c2VkIHRvIGJlIHBhcmFtZXRlciBsaXN0cyBpbiBmdW5jdGlvblxuXHQjIGRlZmluaXRpb25zIHZlcnN1cyBhcmd1bWVudCBsaXN0cyBpbiBmdW5jdGlvbiBjYWxscy4gV2FsayBiYWNrd2FyZHMsIHRva2lkZ2luZ1xuXHQjIHBhcmFtZXRlcnMgc3BlY2lhbGx5IGluIG9yZGVyIHRvIG1ha2UgdGhpbmdzIGVhc2llciBmb3IgdGhlIHBhcnNlci5cblx0ZGVmIHRhZ1BhcmFtZXRlcnNcblx0XHRyZXR1cm4gdGhpcyBpZiBsYXN0VG9rZW5UeXBlICE9ICcpJ1xuXHRcdHZhciBzdGFjayA9IFtdXG5cdFx0dmFyIHRva2VucyA9IEB0b2tlbnNcblx0XHR2YXIgaSA9IHRva2VuczpsZW5ndGhcblxuXHRcdHRUcyh0b2tlbnNbLS1pXSwgJ1BBUkFNX0VORCcpXG5cblx0XHR3aGlsZSB2YXIgdG9rID0gdG9rZW5zWy0taV1cblx0XHRcdHZhciB0ID0gdFQodG9rKVxuXHRcdFx0c3dpdGNoIHRcblx0XHRcdFx0d2hlbiAnKSdcblx0XHRcdFx0XHRzdGFjay5wdXNoIHRva1xuXHRcdFx0XHR3aGVuICcoJywgJ0NBTExfU1RBUlQnXG5cdFx0XHRcdFx0aWYgc3RhY2s6bGVuZ3RoXG5cdFx0XHRcdFx0XHRzdGFjay5wb3Bcblx0XHRcdFx0XHRlbGlmIHQgaXMgJygnXG5cdFx0XHRcdFx0XHR0VHModG9rLCdQQVJBTV9TVEFSVCcpXG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpc1xuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzXG5cblx0XHRyZXR1cm4gdGhpc1xuXG5cdCMgQ2xvc2UgdXAgYWxsIHJlbWFpbmluZyBvcGVuIGJsb2NrcyBhdCB0aGUgZW5kIG9mIHRoZSBmaWxlLlxuXHRkZWYgY2xvc2VJbmRlbnRhdGlvblxuXHRcdCMgY3R4ID0gY29udGV4dFxuXHRcdCMgcGFpcihjdHgpIGlmIGN0eCBpbiBbJyUnLCdERUYnXVxuXHRcdGNsb3NlRGVmXG5cdFx0Y2xvc2VTZWxlY3RvclxuXHRcdG91dGRlbnRUb2tlbihAaW5kZW50LG5vLDApXG5cblx0IyBNYXRjaGVzIGEgYmFsYW5jZWQgZ3JvdXAgc3VjaCBhcyBhIHNpbmdsZSBvciBkb3VibGUtcXVvdGVkIHN0cmluZy4gUGFzcyBpblxuXHQjIGEgc2VyaWVzIG9mIGRlbGltaXRlcnMsIGFsbCBvZiB3aGljaCBtdXN0IGJlIG5lc3RlZCBjb3JyZWN0bHkgd2l0aGluIHRoZVxuXHQjIGNvbnRlbnRzIG9mIHRoZSBzdHJpbmcuIFRoaXMgbWV0aG9kIGFsbG93cyB1cyB0byBoYXZlIHN0cmluZ3Mgd2l0aGluXG5cdCMgaW50ZXJwb2xhdGlvbnMgd2l0aGluIHN0cmluZ3MsIGFkIGluZmluaXR1bS5cblx0ZGVmIGJhbGFuY2VkU3RyaW5nIHN0ciwgZW5kXG5cdFx0dmFyIG1hdGNoLCBsZXR0ZXIsIHByZXZcblxuXHRcdCMgY29uc29sZS5sb2cgJ2JhbGFuY2luZyBzdHJpbmchJywgc3RyLCBlbmRcblx0XHR2YXIgc3RhY2sgPSBbZW5kXVxuXHRcdHZhciBpID0gMFxuXG5cdFx0IyBjb3VsZCBpdCBub3QgaGFwcGVuIGhlcmU/XG5cdFx0d2hpbGUgaSA8IChzdHI6bGVuZ3RoIC0gMSlcblx0XHRcdGkrK1xuXHRcdFx0dmFyIGxldHRlciA9IHN0ci5jaGFyQXQoaSlcblx0XHRcdHN3aXRjaCBsZXR0ZXJcblx0XHRcdFx0d2hlbiAnXFxcXCdcblx0XHRcdFx0XHRpKytcblx0XHRcdFx0XHRjb250aW51ZVxuXHRcdFx0XHR3aGVuIGVuZFxuXHRcdFx0XHRcdHN0YWNrLnBvcFxuXHRcdFx0XHRcdHVubGVzcyBzdGFjazpsZW5ndGhcblx0XHRcdFx0XHRcdHZhciB2ID0gc3RyLnNsaWNlKDAsIGkgKyAxKVxuXHRcdFx0XHRcdFx0cmV0dXJuIHZcblx0XHRcdFx0XHRlbmQgPSBzdGFja1tzdGFjazpsZW5ndGggLSAxXVxuXHRcdFx0XHRcdGNvbnRpbnVlXG5cblx0XHRcdGlmIGVuZCBpcyAnfScgYW5kIChsZXR0ZXIgPT0gJ1wiJyBvciBsZXR0ZXIgPT0gXCInXCIpXG5cdFx0XHRcdHN0YWNrLnB1c2goZW5kID0gbGV0dGVyKVxuXG5cdFx0XHRlbGlmIGVuZCBpcyAnfScgYW5kIGxldHRlciBpcyAnLycgYW5kIG1hdGNoID0gKEhFUkVHRVguZXhlYyhzdHIuc2xpY2UgaSkgb3IgUkVHRVguZXhlYyhzdHIuc2xpY2UgaSkpXG5cdFx0XHRcdGkgKz0gbWF0Y2hbMF06bGVuZ3RoIC0gMVxuXG5cdFx0XHRlbGlmIGVuZCBpcyAnfScgYW5kIGxldHRlciBpcyAneydcblx0XHRcdFx0c3RhY2sucHVzaCBlbmQgPSAnfSdcblx0XHRcdGVsaWYgZW5kIGlzICdcIicgYW5kIGxldHRlciBpcyAneydcblx0XHRcdFx0c3RhY2sucHVzaCBlbmQgPSAnfSdcblx0XHRcdHByZXYgPSBsZXR0ZXJcblxuXHRcdGVycm9yIFwibWlzc2luZyB7IHN0YWNrLnBvcCB9LCBzdGFydGluZ1wiIHVubGVzcyBAb3B0czpzaWxlbnRcblxuXHQjIEV4cGFuZCB2YXJpYWJsZXMgYW5kIGV4cHJlc3Npb25zIGluc2lkZSBkb3VibGUtcXVvdGVkIHN0cmluZ3MgdXNpbmdcblx0IyBSdWJ5LWxpa2Ugbm90YXRpb24gZm9yIHN1YnN0aXR1dGlvbiBvZiBhcmJpdHJhcnkgZXhwcmVzc2lvbnMuXG5cdCNcblx0IyAgICAgXCJIZWxsbyAje25hbWUuY2FwaXRhbGl6ZSgpfS5cIlxuXHQjXG5cdCMgSWYgaXQgZW5jb3VudGVycyBhbiBpbnRlcnBvbGF0aW9uLCB0aGlzIG1ldGhvZCB3aWxsIHJlY3Vyc2l2ZWx5IGNyZWF0ZSBhXG5cdCMgbmV3IExleGVyLCB0b2tlbml6ZSB0aGUgaW50ZXJwb2xhdGVkIGNvbnRlbnRzLCBhbmQgbWVyZ2UgdGhlbSBpbnRvIHRoZVxuXHQjIHRva2VuIHN0cmVhbS5cblx0ZGVmIGludGVycG9sYXRlU3RyaW5nIHN0ciwgb3B0aW9ucyA9IHt9XG5cdFx0IyBjb25zb2xlLmxvZyBcImludGVycG9sYXRlIHN0cmluZ1wiXG5cdFx0dmFyIGhlcmVkb2MgPSBvcHRpb25zOmhlcmVkb2Ncblx0XHR2YXIgcXVvdGUgPSBvcHRpb25zOnF1b3RlXG5cdFx0dmFyIHJlZ2V4ID0gb3B0aW9uczpyZWdleFxuXHRcdHZhciBwcmVmaXggPSBvcHRpb25zOnByZWZpeFxuXG5cdFx0dmFyIHN0YXJ0TG9jID0gQGxvY1xuXHRcdHZhciB0b2tlbnMgPSBbXVxuXHRcdHZhciBwaSA9IDBcblx0XHR2YXIgaSAgPSAtMVxuXHRcdHZhciBsb2NPZmZzZXQgPSBvcHRpb25zOm9mZnNldCBvciAxXG5cdFx0dmFyIHN0cmxlbiA9IHN0cjpsZW5ndGhcblx0XHR2YXIgbGV0dGVyXG5cdFx0dmFyIGV4cHJcblxuXHRcdHZhciBpc0ludGVycG9sYXRlZCA9IG5vXG5cdFx0IyBvdXQgb2YgYm91bmRzXG5cdFx0d2hpbGUgbGV0dGVyID0gc3RyLmNoYXJBdChpICs9IDEpXG5cdFx0XHRpZiBsZXR0ZXIgaXMgJ1xcXFwnXG5cdFx0XHRcdGkgKz0gMVxuXHRcdFx0XHRjb250aW51ZVxuXG5cdFx0XHR1bmxlc3Mgc3RyLmNoYXJBdChpKSBpcyAneycgYW5kIChleHByID0gYmFsYW5jZWRTdHJpbmcoc3RyLnNsaWNlKGkpLCAnfScpKVxuXHRcdFx0XHRjb250aW51ZVxuXG5cdFx0XHRpc0ludGVycG9sYXRlZCA9IHllc1xuXG5cdFx0XHQjIHRoZXNlIGhhdmUgbm8gcmVhbCBzZW5zZSBvZiBsb2NhdGlvbiBvciBhbnl0aGluZz9cblx0XHRcdGlmIHBpIDwgaVxuXHRcdFx0XHQjIHRoaXMgaXMgdGhlIHByZWZpeC1zdHJpbmcgLSBiZWZvcmUgYW55IGl0ZW1cblx0XHRcdFx0dmFyIHRvayA9IFRva2VuLm5ldygnTkVPU1RSSU5HJywgZXNjYXBlU3RyKHN0ci5zbGljZShwaSwgaSksaGVyZWRvYyxxdW90ZSksQGxvYyArIHBpICsgbG9jT2Zmc2V0LGkgLSBwaSlcblx0XHRcdFx0IyB0b2suQGxvYyA9IEBsb2MgKyBwaVxuXHRcdFx0XHQjIHRvay5AbGVuID0gaSAtIHBpICsgMlxuXHRcdFx0XHR0b2tlbnMucHVzaCh0b2spXG5cblx0XHRcdHRva2Vucy5wdXNoIFRva2VuLm5ldygne3snLCd7JyxAbG9jICsgaSArIGxvY09mZnNldCwxKVxuXG5cdFx0XHR2YXIgaW5uZXIgPSBleHByLnNsaWNlKDEsIC0xKVxuXHRcdFx0IyBjb25zb2xlLmxvZyAnaW5uZXIgaXMnLGlubmVyXG5cdFx0XHQjIHJlbW92ZSBsZWFkaW5nIHNwYWNlcyBcblx0XHRcdCMgbmVlZCB0byBrZWVwIHRyYWNrIG9mIGhvdyBtdWNoIHdoaXRlc3BhY2Ugd2UgZHJvcHBlZCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0aW5uZXIgPSBpbm5lci5yZXBsYWNlKC9eW15cXG5cXFNdKy8sJycpXG5cblx0XHRcdGlmIGlubmVyOmxlbmd0aFxuXHRcdFx0XHQjIHdlIG5lZWQgdG8gcmVtZW1iZXIgdGhlIGxvYyB3ZSBzdGFydCBhdFxuXHRcdFx0XHQjIGNvbnNvbGUubG9nKCdpbnRlcnBvbGF0ZSBmcm9tIGxvYycsQGxvYyxpKVxuXHRcdFx0XHQjIHJlYWxseT8gd2h5IG5vdCBqdXN0IGFkZCB0byB0aGUgc3RhY2s/P1xuXHRcdFx0XHQjIHdoYXQgYWJvdXQgdGhlIGFkZGVkIFxuXHRcdFx0XHQjIHNob3VsZCBzaGFyZSB3aXRoIHRoZSBzZWxlY3RvciBubz9cblx0XHRcdFx0IyBjb25zb2xlLmxvZyBcInRva2VuaXplIGlubmVyIHBhcnRzIG9mIHN0cmluZ1wiLGlubmVyXG5cdFx0XHRcdHZhciBzcGFjZXMgPSAwXG5cdFx0XHRcdHZhciBvZmZzZXQgPSBAbG9jICsgaSArIChleHByOmxlbmd0aCAtIGlubmVyOmxlbmd0aCkgLSAxXG5cdFx0XHRcdCMgd2h5IGNyZWF0ZSBhIHdob2xlIG5ldyBsZXhlcj8gU2hvdWxkIHJhdGhlciByZXVzZSBvbmVcblx0XHRcdFx0IyBtdWNoIGJldHRlciB0byBzaW1wbHkgbW92ZSBpbnRvIGludGVycG9sYXRpb24gbW9kZSB3aGVyZVxuXHRcdFx0XHQjIHdlIGNvbnRpbnVlIHBhcnNpbmcgdW50aWwgd2UgbWVldCB1bnBhaXJlZCB9XG5cdFx0XHRcdHZhciBuZXN0ZWQgPSBMZXhlci5uZXcudG9rZW5pemUgaW5uZXIsIGlubGluZTogeWVzLCByZXdyaXRlOiBubywgbG9jOiBvZmZzZXQgKyBsb2NPZmZzZXRcblx0XHRcdFx0IyBjb25zb2xlLmxvZyBuZXN0ZWQucG9wXG5cblx0XHRcdFx0aWYgbmVzdGVkWzBdIGFuZCB0VChuZXN0ZWRbMF0pID09ICdURVJNSU5BVE9SJ1xuXHRcdFx0XHRcdG5lc3RlZC5zaGlmdFxuXG5cdFx0XHRcdGlmIG5lc3RlZDpsZW5ndGhcblx0XHRcdFx0XHR0b2tlbnMucHVzaCAqbmVzdGVkICMgVC50b2tlbignVE9LRU5TJyxuZXN0ZWQsMClcblx0XHRcdFxuXHRcdFx0IyBzaG91bGQgcmF0aGVyIGFkZCB0aGUgYW1vdW50IGJ5IHdoaWNoIG91ciBsZXhlciBoYXMgbW92ZWQ/XG5cdFx0XHRpICs9IGV4cHI6bGVuZ3RoIC0gMVxuXHRcdFx0dG9rZW5zLnB1c2ggVG9rZW4ubmV3KCd9fScsJ30nLEBsb2MgKyBpICsgbG9jT2Zmc2V0LDEpXG5cdFx0XHRwaSA9IGkgKyAxXG5cblx0XHQjIGFkZGluZyB0aGUgbGFzdCBwYXJ0IG9mIHRoZSBzdHJpbmcgaGVyZVxuXHRcdGlmIGkgPj0gcGkgYW5kIHBpIDwgc3RyOmxlbmd0aFxuXHRcdFx0IyBzZXQgdGhlIGxlbmd0aCBhcyB3ZWxsIC0gb3I/XG5cdFx0XHQjIHRoZSBzdHJpbmcgYWZ0ZXI/XG5cdFx0XHQjIGNvbnNvbGUubG9nICdwdXNoIG5lb3N0cmluZydcblx0XHRcdHRva2Vucy5wdXNoIFRva2VuLm5ldygnTkVPU1RSSU5HJywgZXNjYXBlU3RyKHN0ci5zbGljZShwaSksaGVyZWRvYyxxdW90ZSksQGxvYyArIHBpICsgbG9jT2Zmc2V0LCBzdHI6bGVuZ3RoIC0gcGkpXG5cblx0XHQjIGNvbnNvbGUubG9nIHRva2VuczpsZW5ndGhcblx0XHRyZXR1cm4gdG9rZW5zIGlmIHJlZ2V4XG5cblx0XHRyZXR1cm4gdG9rZW4gJ05FT1NUUklORycsICdcIlwiJyB1bmxlc3MgdG9rZW5zOmxlbmd0aFxuXG5cdFx0QHRva2Vucy5wdXNoKHRvaykgZm9yIHRvayBpbiB0b2tlbnNcblxuXHRcdHJldHVybiB0b2tlbnNcblxuXHQjIE1hdGNoZXMgYSBiYWxhbmNlZCBncm91cCBzdWNoIGFzIGEgc2luZ2xlIG9yIGRvdWJsZS1xdW90ZWQgc3RyaW5nLiBQYXNzIGluXG5cdCMgYSBzZXJpZXMgb2YgZGVsaW1pdGVycywgYWxsIG9mIHdoaWNoIG11c3QgYmUgbmVzdGVkIGNvcnJlY3RseSB3aXRoaW4gdGhlXG5cdCMgY29udGVudHMgb2YgdGhlIHN0cmluZy4gVGhpcyBtZXRob2QgYWxsb3dzIHVzIHRvIGhhdmUgc3RyaW5ncyB3aXRoaW5cblx0IyBpbnRlcnBvbGF0aW9ucyB3aXRoaW4gc3RyaW5ncywgYWQgaW5maW5pdHVtLlxuXHRkZWYgYmFsYW5jZWRTZWxlY3RvciBzdHIsIGVuZFxuXHRcdHZhciBwcmV2XG5cdFx0dmFyIGxldHRlclxuXHRcdHZhciBzdGFjayA9IFtlbmRdXG5cdFx0IyBGSVhNRVxuXHRcdGZvciBpIGluIFsxLi4uc3RyOmxlbmd0aF1cblx0XHRcdHN3aXRjaCBsZXR0ZXIgPSBzdHIuY2hhckF0KGkpXG5cdFx0XHRcdHdoZW4gJ1xcXFwnXG5cdFx0XHRcdFx0aSsrXG5cdFx0XHRcdFx0Y29udGludWVcblx0XHRcdFx0d2hlbiBlbmRcblx0XHRcdFx0XHRzdGFjay5wb3Bcblx0XHRcdFx0XHR1bmxlc3Mgc3RhY2s6bGVuZ3RoXG5cdFx0XHRcdFx0XHRyZXR1cm4gc3RyLnNsaWNlKDAsIGkgKyAxKVxuXG5cdFx0XHRcdFx0ZW5kID0gc3RhY2tbc3RhY2s6bGVuZ3RoIC0gMV1cblx0XHRcdFx0XHRjb250aW51ZVxuXHRcdFx0aWYgZW5kIGlzICd9JyBhbmQgbGV0dGVyIGlzIFsnKSddXG5cdFx0XHRcdHN0YWNrLnB1c2ggZW5kID0gbGV0dGVyXG5cdFx0XHRlbGlmIGVuZCBpcyAnfScgYW5kIGxldHRlciBpcyAneydcblx0XHRcdFx0c3RhY2sucHVzaCBlbmQgPSAnfSdcblx0XHRcdGVsaWYgZW5kIGlzICcpJyBhbmQgbGV0dGVyIGlzICd7J1xuXHRcdFx0XHRzdGFjay5wdXNoIGVuZCA9ICd9J1xuXHRcdFx0cHJldiA9IGxldHRlciAjIHdoYXQsIHdoeT9cblxuXHRcdGVycm9yIFwibWlzc2luZyB7IHN0YWNrLnBvcCB9LCBzdGFydGluZ1wiXG5cblx0IyBQYWlycyB1cCBhIGNsb3NpbmcgdG9rZW4sIGVuc3VyaW5nIHRoYXQgYWxsIGxpc3RlZCBwYWlycyBvZiB0b2tlbnMgYXJlXG5cdCMgY29ycmVjdGx5IGJhbGFuY2VkIHRocm91Z2hvdXQgdGhlIGNvdXJzZSBvZiB0aGUgdG9rZW4gc3RyZWFtLlxuXHRkZWYgcGFpciB0b2tcblx0XHR2YXIgd2FudGVkID0gbGFzdChAZW5kcylcblx0XHR1bmxlc3MgdG9rID09IHdhbnRlZFxuXHRcdFx0ZXJyb3IgXCJ1bm1hdGNoZWQge3Rva31cIiB1bmxlc3MgJ09VVERFTlQnIGlzIHdhbnRlZFxuXHRcdFx0dmFyIHNpemUgPSBsYXN0KEBpbmRlbnRzKVxuXHRcdFx0QGluZGVudCAtPSBzaXplXG5cdFx0XHRvdXRkZW50VG9rZW4oc2l6ZSwgdHJ1ZSwgMClcblx0XHRcdHJldHVybiBwYWlyKHRvaylcblx0XHRzZWxmLnBvcEVuZFxuXG5cblx0IyBIZWxwZXJzXG5cdCMgLS0tLS0tLVxuXG5cdCMgQWRkIGEgdG9rZW4gdG8gdGhlIHJlc3VsdHMsIHRha2luZyBub3RlIG9mIHRoZSBsaW5lIG51bWJlci5cblx0ZGVmIHRva2VuIGlkLCB2YWx1ZSwgbGVuLCBvZmZzZXRcblx0XHRAbGFzdFR5cCA9IGlkXG5cdFx0QGxhc3RWYWwgPSB2YWx1ZVxuXHRcdHZhciB0b2sgPSBAbGFzdCA9IFRva2VuLm5ldyhpZCwgdmFsdWUsIEBsb2MgKyAob2Zmc2V0IG9yIDApLCBsZW4gb3IgMClcblx0XHRAdG9rZW5zLnB1c2ggdG9rXG5cdFx0cmV0dXJuXG5cblx0ZGVmIGxhc3RUb2tlblR5cGVcblx0XHR2YXIgdG9rZW4gPSBAdG9rZW5zW0B0b2tlbnM6bGVuZ3RoIC0gMV1cblx0XHR0b2tlbiA/IHRUKHRva2VuKSA6ICdOT05FJ1xuXG5cdGRlZiBsYXN0VG9rZW5WYWx1ZVxuXHRcdHZhciB0b2tlbiA9IEB0b2tlbnNbQHRva2VuczpsZW5ndGggLSAxXVxuXHRcdHRva2VuID8gdG9rZW4uQHZhbHVlIDogJydcblx0XHRcblx0IyBQZWVrIGF0IGEgdG9raWQgaW4gdGhlIGN1cnJlbnQgdG9rZW4gc3RyZWFtLlxuXHRkZWYgdG9raWQgaW5kZXgsIHZhbFxuXHRcdGlmIHZhciB0b2sgPSBsYXN0KEB0b2tlbnMsIGluZGV4KVxuXHRcdFx0dFRzKHRvayx2YWwpIGlmIHZhbFxuXHRcdFx0cmV0dXJuIHRUKHRvaylcblx0XHRcdCMgdG9rLkB0eXBlID0gdG9raWQgaWYgdG9raWQgIyB3aHk/XG5cdFx0XHQjIHRvay5AdHlwZVxuXHRcdGVsc2UgbnVsbFxuXG5cdCMgUGVlayBhdCBhIHZhbHVlIGluIHRoZSBjdXJyZW50IHRva2VuIHN0cmVhbS5cblx0ZGVmIHZhbHVlIGluZGV4LCB2YWxcblx0XHRpZiB2YXIgdG9rID0gbGFzdChAdG9rZW5zLCBpbmRleClcblx0XHRcdHRWcyh0b2ssdmFsKSBpZiB2YWxcblx0XHRcdHJldHVybiB0Vih0b2spXG5cdFx0XHQjIHRvay5AdmFsdWUgPSB2YWwgaWYgdmFsICMgd2h5P1xuXHRcdFx0IyB0b2suQHZhbHVlXG5cdFx0ZWxzZSBudWxsXG5cdFx0XG5cblx0IyBBcmUgd2UgaW4gdGhlIG1pZHN0IG9mIGFuIHVuZmluaXNoZWQgZXhwcmVzc2lvbj9cblx0ZGVmIHVuZmluaXNoZWRcblx0XHRyZXR1cm4gdHJ1ZSBpZiBMSU5FX0NPTlRJTlVFUi50ZXN0KEBjaHVuaylcdFxuXHRcdHJldHVybiBVTkZJTklTSEVELmluZGV4T2YoQGxhc3RUeXApID49IDBcblx0XG5cdCMgdmFyIHRva2VucyA9IFsnXFxcXCcsJy4nLCAnPy4nLCAnVU5BUlknLCAnTUFUSCcsICcrJywgJy0nLCAnU0hJRlQnLCAnUkVMQVRJT04nLCAnQ09NUEFSRScsICdMT0dJQycsICdDT01QT1VORF9BU1NJR04nLCAnVEhST1cnLCAnRVhURU5EUyddXG5cblx0IyBDb252ZXJ0cyBuZXdsaW5lcyBmb3Igc3RyaW5nIGxpdGVyYWxzLlxuXHRkZWYgZXNjYXBlTGluZXMgc3RyLCBoZXJlZG9jXG5cdFx0c3RyLnJlcGxhY2UgTVVMVElMSU5FUiwgKGhlcmVkb2MgPyAnXFxcXG4nIDogJycpXG5cblx0IyBDb25zdHJ1Y3RzIGEgc3RyaW5nIHRva2VuIGJ5IGVzY2FwaW5nIHF1b3RlcyBhbmQgbmV3bGluZXMuXG5cdGRlZiBtYWtlU3RyaW5nIGJvZHksIHF1b3RlLCBoZXJlZG9jXG5cdFx0cmV0dXJuIHF1b3RlICsgcXVvdGUgdW5sZXNzIGJvZHlcblx0XHRib2R5ID0gYm9keS5yZXBsYWNlKC9cXFxcKFtcXHNcXFNdKS9nKSBkbyB8bWF0Y2gsIGNvbnRlbnRzfFxuXHRcdFx0KGNvbnRlbnRzID09ICdcXG4nIG9yIGNvbnRlbnRzID09IHF1b3RlKSA/IGNvbnRlbnRzIDogbWF0Y2hcblx0XHQjIERvZXMgbm90IHdvcmsgbm93XG5cdFx0Ym9keSA9IGJvZHkucmVwbGFjZSBSZWdFeHAoXCJ7cXVvdGV9XCIsXCJnXCIpLCAnXFxcXCQmJ1xuXHRcdHF1b3RlICsgZXNjYXBlTGluZXMoYm9keSwgaGVyZWRvYykgKyBxdW90ZVxuXHRcdFxuXHQjIFRocm93cyBhIHN5bnRheCBlcnJvciBvbiB0aGUgY3VycmVudCBgQGxpbmVgLlxuXHRkZWYgZXJyb3IgbWVzc2FnZSwgbGVuXG5cdFx0bWVzc2FnZSA9IFwie21lc3NhZ2V9IG9uIGxpbmUge0BsaW5lfVwiIGlmIEBsaW5lIGlzYSBOdW1iZXJcblxuXHRcdGlmIGxlblxuXHRcdFx0bWVzc2FnZSArPSBcIiBbe0Bsb2N9OntAbG9jICsgbGVufV1cIlxuXG5cdFx0dmFyIGVyciA9IFN5bnRheEVycm9yLm5ldyhtZXNzYWdlKVxuXHRcdGVycjpsaW5lID0gQGxpbmVcblx0XHQjIGVycjpjb2x1bW5OdW1iZXJcblx0XHR2YXIgZXJyID0gRVJSLkltYmFQYXJzZUVycm9yLm5ldyhlcnIsIHRva2VuczogQHRva2VucywgcG9zOiBAdG9rZW5zOmxlbmd0aClcblx0XHRlcnI6cmVnaW9uID0gW0Bsb2MsQGxvYyArIChsZW4gb3IgMCldXG5cdFx0dGhyb3cgZXJyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBzcmMvY29tcGlsZXIvbGV4ZXIuaW1iYVxuICoqLyIsIlxuIyBUaGUgSW1iYSBsYW5ndWFnZSBoYXMgYSBnb29kIGRlYWwgb2Ygb3B0aW9uYWwgc3ludGF4LCBpbXBsaWNpdCBzeW50YXgsXG4jIGFuZCBzaG9ydGhhbmQgc3ludGF4LiBUaGlzIGNhbiBncmVhdGx5IGNvbXBsaWNhdGUgYSBncmFtbWFyIGFuZCBibG9hdFxuIyB0aGUgcmVzdWx0aW5nIHBhcnNlIHRhYmxlLiBJbnN0ZWFkIG9mIG1ha2luZyB0aGUgcGFyc2VyIGhhbmRsZSBpdCBhbGwsIHdlIHRha2VcbiMgYSBzZXJpZXMgb2YgcGFzc2VzIG92ZXIgdGhlIHRva2VuIHN0cmVhbSwgdXNpbmcgdGhpcyAqKlJld3JpdGVyKiogdG8gY29udmVydFxuIyBzaG9ydGhhbmQgaW50byB0aGUgdW5hbWJpZ3VvdXMgbG9uZyBmb3JtLCBhZGQgaW1wbGljaXQgaW5kZW50YXRpb24gYW5kXG4jIHBhcmVudGhlc2VzLCBhbmQgZ2VuZXJhbGx5IGNsZWFuIHRoaW5ncyB1cC5cblxudmFyIFQgPSByZXF1aXJlICcuL3Rva2VuJ1xudmFyIFRva2VuID0gVC5Ub2tlblxuXG4jIEJhc2VkIG9uIHRoZSBvcmlnaW5hbCByZXdyaXRlci5jb2ZmZWUgZnJvbSBDb2ZmZWVTY3JpcHRcbmV4cG9ydCBjbGFzcyBSZXdyaXRlclxuXHRcblx0ZGVmIHRva2Vuc1xuXHRcdEB0b2tlbnNcblx0XHRcblx0IyBIZWxwZnVsIHNuaXBwZXQgZm9yIGRlYnVnZ2luZzpcblx0IyAgICAgY29uc29sZS5sb2cgKHRbMF0gKyAnLycgKyB0WzFdIGZvciB0IGluIEB0b2tlbnMpLmpvaW4gJyAnXG5cdCMgUmV3cml0ZSB0aGUgdG9rZW4gc3RyZWFtIGluIG11bHRpcGxlIHBhc3Nlcywgb25lIGxvZ2ljYWwgZmlsdGVyIGF0XG5cdCMgYSB0aW1lLiBUaGlzIGNvdWxkIGNlcnRhaW5seSBiZSBjaGFuZ2VkIGludG8gYSBzaW5nbGUgcGFzcyB0aHJvdWdoIHRoZVxuXHQjIHN0cmVhbSwgd2l0aCBhIGJpZyBvbCcgZWZmaWNpZW50IHN3aXRjaCwgYnV0IGl0J3MgbXVjaCBuaWNlciB0byB3b3JrIHdpdGhcblx0IyBsaWtlIHRoaXMuIFRoZSBvcmRlciBvZiB0aGVzZSBwYXNzZXMgbWF0dGVycyAtLSBpbmRlbnRhdGlvbiBtdXN0IGJlXG5cdCMgY29ycmVjdGVkIGJlZm9yZSBpbXBsaWNpdCBwYXJlbnRoZXNlcyBjYW4gYmUgd3JhcHBlZCBhcm91bmQgYmxvY2tzIG9mIGNvZGUuXG5cdGRlZiByZXdyaXRlIHRva2Vucywgb3B0cyA9IHt9XG5cdFx0QHRva2VucyAgPSB0b2tlbnNcblx0XHRAb3B0aW9ucyA9IG9wdHNcblxuXHRcdCMgY29uc29sZS5sb2cgXCJ0b2tlbnMgaW46IFwiICsgdG9rZW5zOmxlbmd0aFxuXHRcdGNvbnNvbGUudGltZShcInRva2VuaXplOnJld3JpdGVcIikgaWYgb3B0czpwcm9maWxlXG5cblx0XHR2YXIgaSA9IDBcblx0XHQjIGZsYWcgZW1wdHkgbWV0aG9kc1xuXHRcdHdoaWxlIHZhciB0b2tlbiA9IHRva2Vuc1tpXVxuXHRcdFx0dmFyIG5leHQgPSB0b2tlbnNbaSArIDFdXG5cdFx0XHRpZiB0b2tlbi5AdHlwZSA9PSAnREVGX0JPRFknIGFuZCBuZXh0IGFuZCBuZXh0LkB0eXBlID09ICdURVJNSU5BVE9SJ1xuXHRcdFx0XHR0b2tlbi5AdHlwZSA9ICdERUZfRU1QVFknXG5cdFx0XHRpKytcblxuXHRcdHN0ZXAoXCJlbnN1cmVGaXJzdExpbmVcIilcblx0XHRzdGVwKFwicmVtb3ZlTGVhZGluZ05ld2xpbmVzXCIpXG5cdFx0c3RlcChcInJlbW92ZU1pZEV4cHJlc3Npb25OZXdsaW5lc1wiKVxuXHRcdHN0ZXAoXCJ0YWdEZWZBcmd1bWVudHNcIilcblx0XHRzdGVwKFwiY2xvc2VPcGVuQ2FsbHNcIilcblx0XHRzdGVwKFwiY2xvc2VPcGVuSW5kZXhlc1wiKVxuXHRcdHN0ZXAoXCJjbG9zZU9wZW5UYWdzXCIpXG5cdFx0c3RlcChcImNsb3NlT3BlblRhZ0F0dHJMaXN0c1wiKVxuXHRcdHN0ZXAoXCJhZGRJbXBsaWNpdEluZGVudGF0aW9uXCIpXG5cdFx0c3RlcChcInRhZ1Bvc3RmaXhDb25kaXRpb25hbHNcIilcblx0XHRzdGVwKFwiYWRkSW1wbGljaXRCcmFjZXNcIilcblx0XHRzdGVwKFwiYWRkSW1wbGljaXRQYXJlbnRoZXNlc1wiKVxuXG5cdFx0Y29uc29sZS50aW1lRW5kKFwidG9rZW5pemU6cmV3cml0ZVwiKSBpZiBvcHRzOnByb2ZpbGVcblx0XHQjIGNvbnNvbGUubG9nIFwidG9rZW5zIG91dDogXCIgKyBAdG9rZW5zOmxlbmd0aFxuXHRcdEB0b2tlbnNcblxuXHRkZWYgc3RlcCBmblxuXHRcdGlmIEBvcHRpb25zOnByb2ZpbGVcblx0XHRcdGNvbnNvbGUubG9nIFwiLS0tLSBzdGFydGluZyB7Zm59IC0tLS0gXCJcblx0XHRcdGNvbnNvbGUudGltZShmbilcblxuXHRcdHRoaXNbZm5dKClcblxuXHRcdGlmIEBvcHRpb25zOnByb2ZpbGVcblx0XHRcdGNvbnNvbGUudGltZUVuZChmbilcblx0XHRcdGNvbnNvbGUubG9nIFwiXFxuXFxuXCJcblx0XHRyZXR1cm5cblxuXHQjIFJld3JpdGUgdGhlIHRva2VuIHN0cmVhbSwgbG9va2luZyBvbmUgdG9rZW4gYWhlYWQgYW5kIGJlaGluZC5cblx0IyBBbGxvdyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBibG9jayB0byB0ZWxsIHVzIGhvdyBtYW55IHRva2VucyB0byBtb3ZlXG5cdCMgZm9yd2FyZHMgKG9yIGJhY2t3YXJkcykgaW4gdGhlIHN0cmVhbSwgdG8gbWFrZSBzdXJlIHdlIGRvbid0IG1pc3MgYW55dGhpbmdcblx0IyBhcyB0b2tlbnMgYXJlIGluc2VydGVkIGFuZCByZW1vdmVkLCBhbmQgdGhlIHN0cmVhbSBjaGFuZ2VzIGxlbmd0aCB1bmRlclxuXHQjIG91ciBmZWV0LlxuXHRkZWYgc2NhblRva2VucyBibG9ja1xuXHRcdHZhciB0b2tlbnMgPSBAdG9rZW5zXG5cblx0XHR2YXIgaSA9IDBcblx0XHR3aGlsZSB2YXIgdG9rZW4gPSB0b2tlbnNbaV1cblx0XHRcdGkgKz0gYmxvY2suY2FsbChzZWxmLCB0b2tlbiwgaSwgdG9rZW5zKVxuXG5cdFx0dHJ1ZVxuXG5cdGRlZiBkZXRlY3RFbmQgaSwgY29uZGl0aW9uLCBhY3Rpb25cblx0XHR2YXIgdG9rZW5zID0gQHRva2Vuc1xuXHRcdHZhciBsZXZlbHMgPSAwXG5cdFx0dmFyIHN0YXJ0cyA9IFtdXG5cdFx0dmFyIHRva2VuXG5cdFx0dmFyIHQsdlxuXG5cdFx0d2hpbGUgdG9rZW4gPSB0b2tlbnNbaV1cblx0XHRcdGlmIGxldmVscyA9PSAwIGFuZCBjb25kaXRpb24uY2FsbCh0aGlzLHRva2VuLGksc3RhcnRzKVxuXHRcdFx0XHRyZXR1cm4gYWN0aW9uLmNhbGwoc2VsZiwgdG9rZW4sIGkpXG5cdFx0XHRpZiAhdG9rZW4gb3IgbGV2ZWxzIDwgMFxuXHRcdFx0XHRyZXR1cm4gYWN0aW9uLmNhbGwoc2VsZiwgdG9rZW4sIGkgLSAxKVxuXG5cdFx0XHR0ID0gVC50eXAodG9rZW4pXG5cblx0XHRcdGlmIEVYUFJFU1NJT05fU1RBUlQuaW5kZXhPZih0KSA+PSAwXG5cdFx0XHRcdHN0YXJ0cy5wdXNoKGkpIGlmIGxldmVscyA9PSAwXG5cdFx0XHRcdGxldmVscyArPSAxXG5cdFx0XHRlbGlmIEVYUFJFU1NJT05fRU5ELmluZGV4T2YodCkgPj0gMFxuXHRcdFx0XHRsZXZlbHMgLT0gMVxuXHRcdFx0aSArPSAxXG5cdFx0aSAtIDFcblxuXHRkZWYgZW5zdXJlRmlyc3RMaW5lXG5cdFx0dmFyIHRvayA9IEB0b2tlbnNbMF1cblxuXHRcdGlmIFQudHlwKHRvaykgPT0gJ1RFUk1JTkFUT1InXG5cdFx0XHQjIGNvbnNvbGUubG9nIFwiYWRkaW5nIGJvZHlzdGFydFwiXG5cdFx0XHRAdG9rZW5zID0gW1QudG9rZW4oJ0JPRFlTVEFSVCcsJ0JPRFlTVEFSVCcpXS5jb25jYXQoQHRva2Vucylcblx0XHRcdCMgVC5zZXRUeXAodG9rLCdIRUFERVInKVxuXHRcdHJldHVyblxuXG5cdCMgTGVhZGluZyBuZXdsaW5lcyB3b3VsZCBpbnRyb2R1Y2UgYW4gYW1iaWd1aXR5IGluIHRoZSBncmFtbWFyLCBzbyB3ZVxuXHQjIGRpc3BhdGNoIHRoZW0gaGVyZS5cblx0ZGVmIHJlbW92ZUxlYWRpbmdOZXdsaW5lc1xuXHRcdHZhciBhdCA9IDBcblxuXHRcdGZvciB0b2tlbixpIGluIEB0b2tlbnNcblx0XHRcdGlmIFQudHlwKHRva2VuKSAhPSAnVEVSTUlOQVRPUidcblx0XHRcdFx0YnJlYWsgYXQgPSBpXG5cdFx0XG5cdFx0QHRva2Vucy5zcGxpY2UoMCwgYXQpIGlmIGF0XG5cblx0XHRyZXR1cm5cblxuXHQjIFNvbWUgYmxvY2tzIG9jY3VyIGluIHRoZSBtaWRkbGUgb2YgZXhwcmVzc2lvbnMgLS0gd2hlbiB3ZSdyZSBleHBlY3Rpbmdcblx0IyB0aGlzLCByZW1vdmUgdGhlaXIgdHJhaWxpbmcgbmV3bGluZXMuXG5cdGRlZiByZW1vdmVNaWRFeHByZXNzaW9uTmV3bGluZXNcblx0XHRzY2FuVG9rZW5zIGRvIHx0b2tlbixpLHRva2Vuc3wgIyBkbyB8dG9rZW4saSx0b2tlbnN8XG5cdFx0XHR2YXIgbmV4dCA9IHRva2VuVHlwZShpICsgMSlcblxuXHRcdFx0cmV0dXJuIDEgdW5sZXNzIFQudHlwKHRva2VuKSBpcyAnVEVSTUlOQVRPUicgYW5kIEVYUFJFU1NJT05fQ0xPU0UuaW5kZXhPZihuZXh0KSA+PSAwXG5cdFx0XHRyZXR1cm4gMSBpZiBuZXh0ID09ICdPVVRERU5UJ1xuXHRcdFx0dG9rZW5zLnNwbGljZShpLCAxKVxuXHRcdFx0MFxuXG5cblx0ZGVmIHRhZ0RlZkFyZ3VtZW50c1xuXHRcdHllc1xuXG5cdCMgVGhlIGxleGVyIGhhcyB0YWdnZWQgdGhlIG9wZW5pbmcgcGFyZW50aGVzaXMgb2YgYSBtZXRob2QgY2FsbC4gTWF0Y2ggaXQgd2l0aFxuXHQjIGl0cyBwYWlyZWQgY2xvc2UuIFdlIGhhdmUgdGhlIG1pcy1uZXN0ZWQgb3V0ZGVudCBjYXNlIGluY2x1ZGVkIGhlcmUgZm9yXG5cdCMgY2FsbHMgdGhhdCBjbG9zZSBvbiB0aGUgc2FtZSBsaW5lLCBqdXN0IGJlZm9yZSB0aGVpciBvdXRkZW50LlxuXHRkZWYgY2xvc2VPcGVuQ2FsbHNcblx0XHR2YXIgY29uZGl0aW9uID0gZG8gfHRva2VuLGl8XG5cdFx0XHR2YXIgdCA9IFQudHlwKHRva2VuKVxuXHRcdFx0KHQgPT0gJyknIG9yIHQgPT0gJ0NBTExfRU5EJykgfHwgdCA9PSAnT1VUREVOVCcgYW5kIHRva2VuVHlwZShpIC0gMSkgPT0gJyknXG5cblx0XHR2YXIgYWN0aW9uID0gZG8gfHRva2VuLCBpfFxuXHRcdFx0dmFyIHQgPSBULnR5cCh0b2tlbilcblx0XHRcdHZhciB0b2sgPSBAdG9rZW5zW3QgPT0gJ09VVERFTlQnID8gaSAtIDEgOiBpXVxuXHRcdFx0VC5zZXRUeXAodG9rLCdDQUxMX0VORCcpXG5cblx0XHRzY2FuVG9rZW5zIGRvIHx0b2tlbixpfFxuXHRcdFx0ZGV0ZWN0RW5kKGkgKyAxLCBjb25kaXRpb24sIGFjdGlvbikgaWYgVC50eXAodG9rZW4pIGlzICdDQUxMX1NUQVJUJ1xuXHRcdFx0cmV0dXJuIDFcblxuXHQjIFRoZSBsZXhlciBoYXMgdGFnZ2VkIHRoZSBvcGVuaW5nIHBhcmVudGhlc2lzIG9mIGFuIGluZGV4aW5nIG9wZXJhdGlvbiBjYWxsLlxuXHQjIE1hdGNoIGl0IHdpdGggaXRzIHBhaXJlZCBjbG9zZS5cblx0ZGVmIGNsb3NlT3BlbkluZGV4ZXNcblx0XHR2YXIgY29uZGl0aW9uID0gZG8gfHRva2VuLCBpfCBULnR5cCh0b2tlbikgaW4gWyddJywgJ0lOREVYX0VORCddXG5cdFx0dmFyIGFjdGlvbiAgICA9IGRvIHx0b2tlbiwgaXwgVC5zZXRUeXAodG9rZW4sJ0lOREVYX0VORCcpXG5cdFx0XG5cdFx0c2NhblRva2VucyBkbyB8dG9rZW4saXxcblx0XHRcdGRldGVjdEVuZCBpICsgMSwgY29uZGl0aW9uLCBhY3Rpb24gaWYgVC50eXAodG9rZW4pIGlzICdJTkRFWF9TVEFSVCdcblx0XHRcdHJldHVybiAxXG5cblx0XG5cdGRlZiBjbG9zZU9wZW5UYWdBdHRyTGlzdHNcblx0XHR2YXIgY29uZGl0aW9uID0gZG8gfHRva2VuLCBpfCBULnR5cCh0b2tlbikgaW4gWycpJywgJ1RBR19BVFRSU19FTkQnXVxuXHRcdHZhciBhY3Rpb24gICAgPSBkbyB8dG9rZW4sIGl8IFQuc2V0VHlwKHRva2VuLCdUQUdfQVRUUlNfRU5EJykgIyAnVEFHX0FUVFJTX0VORCdcblxuXHRcdHNjYW5Ub2tlbnMgZG8gfHRva2VuLGl8XG5cdFx0XHRkZXRlY3RFbmQgaSArIDEsIGNvbmRpdGlvbiwgYWN0aW9uIGlmIFQudHlwKHRva2VuKSBpcyAnVEFHX0FUVFJTX1NUQVJUJ1xuXHRcdFx0cmV0dXJuIDFcblx0XG5cdCMgVGhlIGxleGVyIGhhcyB0YWdnZWQgdGhlIG9wZW5pbmcgcGFyZW50aGVzaXMgb2YgYW4gaW5kZXhpbmcgb3BlcmF0aW9uIGNhbGwuXG5cdCMgTWF0Y2ggaXQgd2l0aCBpdHMgcGFpcmVkIGNsb3NlLiBTaG91bGQgYmUgZG9uZSBpbiBsZXhlciBkaXJlY3RseVxuXHRkZWYgY2xvc2VPcGVuVGFnc1xuXHRcdHZhciBjb25kaXRpb24gPSBkbyB8dG9rZW4sIGl8IFQudHlwKHRva2VuKSBpbiBbJz4nLCAnVEFHX0VORCddXG5cdFx0dmFyIGFjdGlvbiAgICA9IGRvIHx0b2tlbiwgaXwgVC5zZXRUeXAodG9rZW4sJ1RBR19FTkQnKSAjIHRva2VuWzBdID0gJ1RBR19FTkQnXG5cblx0XHRzY2FuVG9rZW5zIGRvIHx0b2tlbixpfFxuXHRcdFx0ZGV0ZWN0RW5kIGkgKyAxLCBjb25kaXRpb24sIGFjdGlvbiBpZiBULnR5cCh0b2tlbikgaXMgJ1RBR19TVEFSVCdcblx0XHRcdHJldHVybiAxXG5cdFx0XG5cdGRlZiBhZGRJbXBsaWNpdENvbW1hc1xuXHRcdHJldHVyblxuXG5cdGRlZiBhZGRJbXBsaWNpdEJsb2NrQ2FsbHNcblx0XHR2YXIgaSA9IDFcblx0XHR2YXIgdG9rZW5zID0gQHRva2Vuc1xuXG5cdFx0d2hpbGUgdmFyIHRva2VuID0gdG9rZW5zW2ldXG5cdFx0XHR2YXIgdCA9IHRva2VuLkB0eXBlXG5cdFx0XHR2YXIgdiA9IHRva2VuLkB2YWx1ZVxuXHRcdFx0IyBobW1cblx0XHRcdGlmIHQgPT0gJ0RPJyBhbmQgKHYgPT0gJ0lOREVYX0VORCcgb3IgdiA9PSAnSURFTlRJRklFUicgb3IgdiA9PSAnTkVXJylcblx0XHRcdFx0dG9rZW5zLnNwbGljZSBpICsgMSwgMCwgVC50b2tlbignQ0FMTF9FTkQnLCcpJylcblx0XHRcdFx0dG9rZW5zLnNwbGljZSBpICsgMSwgMCwgVC50b2tlbignQ0FMTF9TVEFSVCcsJygnKVxuXHRcdFx0XHRpKytcblx0XHRcdGkrK1xuXG5cdFx0cmV0dXJuXG5cblx0IyBPYmplY3QgbGl0ZXJhbHMgbWF5IGJlIHdyaXR0ZW4gd2l0aCBpbXBsaWNpdCBicmFjZXMsIGZvciBzaW1wbGUgY2FzZXMuXG5cdCMgSW5zZXJ0IHRoZSBtaXNzaW5nIGJyYWNlcyBoZXJlLCBzbyB0aGF0IHRoZSBwYXJzZXIgZG9lc24ndCBoYXZlIHRvLlxuXHRkZWYgYWRkSW1wbGljaXRCcmFjZXNcblx0XHR2YXIgc3RhY2sgICAgICAgPSBbXVxuXHRcdHZhciBzdGFydCAgICAgICA9IG51bGxcblx0XHR2YXIgc3RhcnRJbmRlbnQgPSAwXG5cdFx0dmFyIHN0YXJ0SWR4ID0gbnVsbFxuXG5cdFx0dmFyIG5vQnJhY2VUYWcgPSBbJ0NMQVNTJywgJ0lGJywnVU5MRVNTJywnVEFHJywnV0hJTEUnLCdGT1InLCdVTlRJTCcsJ0NBVENIJywnRklOQUxMWScsJ01PRFVMRScsJ0xFQURJTkdfV0hFTiddXG5cdFx0dmFyIG5vQnJhY2VDb250ZXh0ID0gWydJRicsJ1RFUk5BUlknLCdGT1InXVxuXG5cdFx0dmFyIG5vQnJhY2UgPSBub1xuXG5cdFx0dmFyIHNjb3BlID0gZG8gXG5cdFx0XHRzdGFja1tzdGFjazpsZW5ndGggLSAxXSBvciBbXVxuXG5cdFx0dmFyIGFjdGlvbiA9IGRvIHx0b2tlbixpfFxuXHRcdFx0QHRva2Vucy5zcGxpY2UgaSwgMCwgVC5SQlJBQ0tFVFxuXG5cdFx0dmFyIG9wZW4gPSBkbyB8dG9rZW4saXxcblx0XHRcdEB0b2tlbnMuc3BsaWNlIGksIDAsIFQuTEJSQUNLRVRcblxuXHRcdHZhciBjbG9zZSA9IGRvIHx0b2tlbixpfFxuXHRcdFx0QHRva2Vucy5zcGxpY2UgaSwgMCwgVC5SQlJBQ0tFVFxuXG5cdFx0dmFyIHN0YWNrVG9rZW4gPSBkbyB8YSxifFxuXHRcdFx0cmV0dXJuIFthLGJdXG5cblx0XHRzY2FuVG9rZW5zIGRvIHx0b2tlbixpLHRva2Vuc3xcblx0XHRcdHZhciB0eXBlID0gVC50eXAodG9rZW4pXG5cdFx0XHR2YXIgdiA9IFQudmFsKHRva2VuKVxuXHRcdFx0dmFyIGN0eCA9IHN0YWNrW3N0YWNrOmxlbmd0aCAtIDFdIG9yIFtdXG5cdFx0XHR2YXIgaWR4XG5cblx0XHRcdGlmIG5vQnJhY2VDb250ZXh0LmluZGV4T2YodHlwZSkgPj0gMFxuXHRcdFx0XHQjIGNvbnNvbGUubG9nIFwiZm91bmQgbm9CcmFjZVRhZyB7dHlwZX1cIlxuXHRcdFx0XHRzdGFjay5wdXNoIHN0YWNrVG9rZW4odHlwZSxpKVxuXHRcdFx0XHRyZXR1cm4gMVxuXG5cdFx0XHRpZiB2ID09ICc/J1xuXHRcdFx0XHQjIGNvbnNvbGUubG9nKCdURVJOQVJZIE9QRVJBVE9SIScpXG5cdFx0XHRcdHN0YWNrLnB1c2ggc3RhY2tUb2tlbignVEVSTkFSWScsaSlcblx0XHRcdFx0cmV0dXJuIDFcblx0XHRcdFxuXHRcdFx0IyBubyBuZWVkIHRvIHRlc3QgZm9yIHRoaXMgaGVyZSBhcyB3ZWxsIGFzIGluXG5cdFx0XHRpZiBFWFBSRVNTSU9OX1NUQVJULmluZGV4T2YodHlwZSkgPj0gMFxuXHRcdFx0XHRpZiB0eXBlID09ICdJTkRFTlQnIGFuZCBub0JyYWNlQ29udGV4dC5pbmRleE9mKGN0eFswXSkgPj0gMFxuXHRcdFx0XHRcdHN0YWNrLnBvcFxuXG5cdFx0XHRcdCMgY29uc29sZS5sb2coJ2V4cHJlc3Npb24gc3RhcnQnLHR5cGUsY3R4WzBdKVxuXHRcdFx0XHRpZiB0eXBlID09ICdJTkRFTlQnIGFuZCB0b2tlblR5cGUoaSAtIDEpID09ICd7J1xuXHRcdFx0XHRcdCMgc3RhY2sgPyE/IG5vIHRva2VuXG5cdFx0XHRcdFx0c3RhY2sucHVzaCBzdGFja1Rva2VuKCd7JywgaSkgIyBzaG91bGQgbm90IGF1dG9nZW5lcmF0ZSBhbm90aGVyP1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0c3RhY2sucHVzaCBzdGFja1Rva2VuKHR5cGUsIGkpXG5cdFx0XHRcdHJldHVybiAxXG5cblx0XHRcdGlmIEVYUFJFU1NJT05fRU5ELmluZGV4T2YodHlwZSkgPj0gMFxuXHRcdFx0XHQjIGNvbnNvbGUubG9nIFwiRVhQUkVTU0lPTl9FTkQgYXQge3R5cGV9IC0gc3RhY2sgaXMge2N0eFswXX1cIlxuXHRcdFx0XHRpZiBjdHhbMF0gPT0gJ1RFUk5BUlknICMgRklYP1xuXHRcdFx0XHRcdHN0YWNrLnBvcFxuXG5cdFx0XHRcdHN0YXJ0ID0gc3RhY2sucG9wXG5cdFx0XHRcdHVubGVzcyBzdGFydFxuXHRcdFx0XHRcdGNvbnNvbGUubG9nIFwiTk8gU1RBQ0shIVwiXG5cdFx0XHRcdHN0YXJ0WzJdID0gaVxuXG5cdFx0XHRcdCMgc2VlbXMgbGlrZSB0aGUgc3RhY2sgc2hvdWxkIHVzZSB0b2tlbnMsIG5vPylcblx0XHRcdFx0aWYgc3RhcnRbMF0gPT0gJ3snIGFuZCBzdGFydDpnZW5lcmF0ZWQgIyAgIyB0eXBlICE9ICd9JyAjIGFuZCBzdGFydDpnZW5lcmF0ZWRcblx0XHRcdFx0XHRjbG9zZSh0b2tlbixpKVxuXHRcdFx0XHRcdHJldHVybiAxXG5cblx0XHRcdFx0cmV0dXJuIDFcblx0XHRcdFxuXHRcdFx0IyBpcyB0aGlzIGNvcnJlY3Q/IHNhbWUgZm9yIGlmL2NsYXNzIGV0Yz9cblx0XHRcdGlmIGN0eFswXSA9PSAnVEVSTkFSWScgYW5kICh0eXBlID09ICdURVJNSU5BVE9SJyBvciB0eXBlID09ICdPVVRERU5UJylcblx0XHRcdFx0c3RhY2sucG9wXG5cdFx0XHRcdHJldHVybiAxXG5cblx0XHRcdGlmIG5vQnJhY2VDb250ZXh0LmluZGV4T2YoY3R4WzBdKSA+PSAwIGFuZCB0eXBlID09ICdJTkRFTlQnXG5cdFx0XHRcdGNvbnNvbGUubG9nIFwicG9wcGluZyBub0JyYWNlQ29udGV4dFwiXG5cdFx0XHRcdHN0YWNrLnBvcFxuXHRcdFx0XHRyZXR1cm4gMVxuXG5cblx0XHRcdGlmIHR5cGUgPT0gJywnXG5cdFx0XHRcdCMgYXV0b21hdGljYWxseSBhZGQgYW4gZW5kaW5nIGhlcmUgaWYgaW5zaWRlOmdlbmVyYXRlZCBzY29wZT9cblx0XHRcdFx0IyBpdCBpcyBpbXBvcnRhbnQgdGhhdCB0aGlzIGlzOmdlbmVyYXRlZCghKVxuXHRcdFx0XHRpZiBjdHhbMF0gPT0gJ3snIGFuZCBjdHg6Z2VuZXJhdGVkXG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZShpLCAwLCBULlJCUkFDS0VUKVxuXHRcdFx0XHRcdHN0YWNrLnBvcFxuXHRcdFx0XHRcdHJldHVybiAyXG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRyZXR1cm4gMVxuXHRcdFx0XHR0cnVlXG5cblx0XHRcdCMgZm91bmQgYSB0eXBlXG5cdFx0XHRpZiB0eXBlID09ICc6JyBhbmQgY3R4WzBdICE9ICd7JyBhbmQgY3R4WzBdICE9ICdURVJOQVJZJyBhbmQgKG5vQnJhY2VDb250ZXh0LmluZGV4T2YoY3R4WzBdKSA9PSAtMSlcblx0XHRcdFx0IyBjb3VsZCBqdXN0IGNoZWNrIGlmIHRoZSBlbmQgd2FzIHJpZ2h0IGJlZm9yZSB0aGlzP1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgc3RhcnQgYW5kIHN0YXJ0WzJdID09IGkgLSAxXG5cdFx0XHRcdFx0IyBjb25zb2xlLmxvZygndGhpcyBleHByZXNzaW9uIHdhcyBqdXN0IGVuZGluZyBiZWZvcmUgY29sb24hJylcblx0XHRcdFx0XHRpZHggPSBzdGFydFsxXSAtIDEgIyB0aGVzZSBhcmUgdGhlIHN0YWNrVG9rZW5zXG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHQjIGNvbnNvbGUubG9nIFwicmV3cml0ZSBoZXJlPyAje2l9XCJcblx0XHRcdFx0XHRpZHggPSBpIC0gMiAjIGlmIHN0YXJ0IHRoZW4gc3RhcnRbMV0gLSAxIGVsc2UgaSAtIDJcblx0XHRcdFx0XHQjIGlkeCA9IGlkeCAtIDEgaWYgdG9rZW5UeXBlKGlkeCkgaXMgJ1RFUk1JTkFUT1InXG5cblx0XHRcdFx0aWR4IC09IDIgd2hpbGUgdG9rZW5UeXBlKGlkeCAtIDEpIGlzICdIRVJFQ09NTUVOVCdcblxuXHRcdFx0XHR2YXIgdDAgPSB0b2tlbnNbaWR4IC0gMV1cblxuXHRcdFx0XHRpZiB0MCBhbmQgVC50eXAodDApID09ICd9JyBhbmQgdDA6Z2VuZXJhdGVkXG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZShpZHggLSAxLDEpXG5cdFx0XHRcdFx0dmFyIHMgPSBzdGFja1Rva2VuKCd7Jylcblx0XHRcdFx0XHRzOmdlbmVyYXRlZCA9IHllc1xuXHRcdFx0XHRcdHN0YWNrLnB1c2ggc1xuXHRcdFx0XHRcdHJldHVybiAwXG5cblx0XHRcdFx0IyBoYWNreSBlZGdlY2FzZSBmb3IgaW5kZW50c1xuXHRcdFx0XHRlbGlmIHQwIGFuZCBULnR5cCh0MCkgPT0gJywnIGFuZCB0b2tlblR5cGUoaWR4IC0gMikgPT0gJ30nXG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZShpZHggLSAyLDEpXG5cdFx0XHRcdFx0dmFyIHMgPSBzdGFja1Rva2VuKCd7Jylcblx0XHRcdFx0XHRzOmdlbmVyYXRlZCA9IHllc1xuXHRcdFx0XHRcdHN0YWNrLnB1c2ggc1xuXHRcdFx0XHRcdHJldHVybiAwXG5cblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHZhciBzID0gc3RhY2tUb2tlbigneycpXG5cdFx0XHRcdFx0czpnZW5lcmF0ZWQgPSB5ZXNcblx0XHRcdFx0XHRzdGFjay5wdXNoIHNcblx0XHRcdFx0XHRvcGVuKHRva2VuLGlkeCArIDEpXG5cdFx0XHRcdFx0cmV0dXJuIDJcblxuXHRcdFx0IyB3ZSBwcm9iYWJseSBuZWVkIHRvIHJ1biB0aHJvdWdoIGF1dG9jYWxsIGZpcnN0PyFcblxuXHRcdFx0aWYgdHlwZSA9PSAnRE8nICMgYW5kIGN0eDpnZW5lcmF0ZWRcblx0XHRcdFx0dmFyIHByZXYgPSBULnR5cCh0b2tlbnNbaSAtIDFdKSAjIFswXVxuXHRcdFx0XHRpZiBbJ05VTUJFUicsJ1NUUklORycsJ1JFR0VYJywnU1lNQk9MJywnXScsJ30nLCcpJywnU1RSSU5HX0VORCddLmluZGV4T2YocHJldikgPj0gMFxuXG5cdFx0XHRcdFx0dmFyIHRvayA9IFQudG9rZW4oJywnLCAnLCcpXG5cdFx0XHRcdFx0dG9rOmdlbmVyYXRlZCA9IHllc1xuXHRcdFx0XHRcdHRva2Vucy5zcGxpY2UoaSwwLHRvaylcblxuXHRcdFx0XHRcdGlmIGN0eDpnZW5lcmF0ZWRcblx0XHRcdFx0XHRcdGNsb3NlKHRva2VuLGkpXG5cdFx0XHRcdFx0XHRzdGFjay5wb3Bcblx0XHRcdFx0XHRcdHJldHVybiAyXG5cblx0XHRcdGlmICh0eXBlID09ICdURVJNSU5BVE9SJyBvciB0eXBlID09ICdPVVRERU5UJyBvciB0eXBlID09ICdERUZfQk9EWScpIGFuZCBjdHg6Z2VuZXJhdGVkXG5cdFx0XHRcdGNsb3NlKHRva2VuLGkpXG5cdFx0XHRcdHN0YWNrLnBvcFxuXHRcdFx0XHRyZXR1cm4gMlxuXG5cdFx0XHRyZXR1cm4gMVxuXG5cdCMgTWV0aG9kcyBtYXkgYmUgb3B0aW9uYWxseSBjYWxsZWQgd2l0aG91dCBwYXJlbnRoZXNlcywgZm9yIHNpbXBsZSBjYXNlcy5cblx0IyBJbnNlcnQgdGhlIGltcGxpY2l0IHBhcmVudGhlc2VzIGhlcmUsIHNvIHRoYXQgdGhlIHBhcnNlciBkb2Vzbid0IGhhdmUgdG9cblx0IyBkZWFsIHdpdGggdGhlbS5cblx0IyBQcmFjdGljYWxseSBldmVyeXRoaW5nIHdpbGwgbm93IGJlIGNhbGxhYmxlIHRoaXMgd2F5IChldmVyeSBpZGVudGlmaWVyKVxuXHRkZWYgYWRkSW1wbGljaXRQYXJlbnRoZXNlc1xuXHRcdFxuXHRcdHZhciBub0NhbGxUYWcgPSBbJ0NMQVNTJywgJ0lGJywnVU5MRVNTJywnVEFHJywnV0hJTEUnLCdGT1InLCdVTlRJTCcsJ0NBVENIJywnRklOQUxMWScsJ01PRFVMRScsJ0xFQURJTkdfV0hFTiddXG5cdFx0XG5cdFx0dmFyIGFjdGlvbiA9IGRvIHx0b2tlbixpfFxuXHRcdFx0QHRva2Vucy5zcGxpY2UgaSwgMCwgVC50b2tlbignQ0FMTF9FTkQnLCAnKScpXG5cblx0XHQjIGNvbnNvbGUubG9nIFwiYWRkaW5nIGltcGxpY2l0IHBhcmVudGhlc2lzXCIgIyAsc2VsZjpzY2FuVG9rZW5zXG5cdFx0dmFyIHRva2VucyA9IEB0b2tlbnNcblxuXHRcdHZhciBub0NhbGwgPSBub1xuXHRcdHZhciBzZWVuRm9yID0gbm9cblx0XHR2YXIgZW5kQ2FsbEF0VGVybWluYXRvciA9IG5vXG5cblx0XHR2YXIgaSA9IDBcblx0XHR3aGlsZSB2YXIgdG9rZW4gPSB0b2tlbnNbaV1cblxuXHRcdFx0IyB0byBoYW5kbGUgY2FzZXMgbGlrZTpcblx0XHRcdCMgaWYgYShkbyB5ZXMpLnRlc3Rcblx0XHRcdCMgXHR5ZXNcblx0XHRcdCMgd2UgbmVlZCB0byBrZWVwIGEgc3RhY2sgZm9yIGJhbGFuY2VkIHBhaXJzXG5cdFx0XHQjIHVudGlsIHRoZW4geW91IG11c3QgZXhwbGljaXRseSBlbmQgdGhlIGNhbGwgbGlrZVxuXHRcdFx0IyBpZiBhKGRvIHllcykudGVzdCgpXG5cdFx0XHQjIFx0eWVzXG5cblx0XHRcdHZhciB0eXBlID0gdG9rZW4uQHR5cGVcblxuXHRcdFx0dmFyIHByZXYgICAgPSB0b2tlbnNbaSAtIDFdXG5cdFx0XHR2YXIgY3VycmVudCA9IHRva2Vuc1tpXVxuXHRcdFx0dmFyIG5leHQgICAgPSB0b2tlbnNbaSArIDFdXG5cblx0XHRcdHZhciBwdCA9IHByZXYgYW5kIHByZXYuQHR5cGVcblx0XHRcdHZhciBudCA9IG5leHQgYW5kIG5leHQuQHR5cGVcblxuXHRcdFx0IyBpZiBwdCA9PSAnV0hFTidcblx0XHRcdCMgTmV2ZXIgbWFrZSB0aGVzZSB0YWdzIGltcGxpY2l0bHkgY2FsbFxuXHRcdFx0IyBzaG91bGQgd2Ugbm90IGp1c3QgcmVtb3ZlIHRoZXNlIGZyb20gSU1QTElDSVRfRlVOQz9cblx0XHRcdGlmIChwdCA9PSAnKScgb3IgcHQgPT0gJ10nKSBhbmQgdHlwZSA9PSAnSU5ERU5UJ1xuXHRcdFx0XHRub0NhbGwgPSB5ZXNcblxuXHRcdFx0aWYgbm9DYWxsVGFnLmluZGV4T2YocHQpID49IDBcblx0XHRcdFx0IyBjb25zb2xlLmxvZyhcInNlZW4gbm9jYWxsIHRhZyB7cHR9ICh7cHR9IHt0eXBlfSB7bnR9KVwiKVxuXHRcdFx0XHRlbmRDYWxsQXRUZXJtaW5hdG9yID0geWVzXG5cdFx0XHRcdG5vQ2FsbCAgPSB5ZXNcblx0XHRcdFx0c2VlbkZvciA9IHllcyBpZiBwdCA9PSAnRk9SJ1xuXHRcdFx0XHRcblxuXHRcdFx0dmFyIGNhbGxPYmplY3QgPSBub1xuXHRcdFx0dmFyIGNhbGxJbmRlbnQgPSBub1xuXG5cdFx0XHQjIFtwcmV2LCBjdXJyZW50LCBuZXh0XSA9IHRva2Vuc1tpIC0gMSAuLiBpICsgMV1cblxuXHRcdFx0IyBjaGVjayBmb3IgY29tbWVudHNcblx0XHRcdCMgY29uc29sZS5sb2cgXCJkZXRlY3QgZW5kPz9cIlxuXHRcdFx0aWYgIW5vQ2FsbCBhbmQgdHlwZSA9PSAnSU5ERU5UJyBhbmQgbmV4dFxuXHRcdFx0XHR2YXIgcHJldkltcEZ1bmMgPSBwdCBhbmQgSU1QTElDSVRfRlVOQy5pbmRleE9mKHB0KSA+PSAwXG5cdFx0XHRcdHZhciBuZXh0SW1wQ2FsbCA9IG50IGFuZCBJTVBMSUNJVF9DQUxMLmluZGV4T2YobnQpID49IDBcblx0XHRcdFx0Y2FsbE9iamVjdCA9ICgobmV4dDpnZW5lcmF0ZWQgYW5kIG50IGlzICd7Jykgb3IgbmV4dEltcENhbGwpIGFuZCBwcmV2SW1wRnVuY1xuXHRcdFx0XHRjYWxsSW5kZW50ID0gbmV4dEltcENhbGwgYW5kIHByZXZJbXBGdW5jXG5cblx0XHRcdHZhciBzZWVuU2luZ2xlICA9IG5vXG5cdFx0XHR2YXIgc2VlbkNvbnRyb2wgPSBub1xuXHRcdFx0IyBIbW0gP1xuXG5cdFx0XHQjIHRoaXMgaXMgbm90IGNvcnJlY3QgaWYgdGhpcyBpcyBpbnNpZGUgYSBibG9jayxubz9cblx0XHRcdGlmICh0eXBlID09ICdURVJNSU5BVE9SJyBvciB0eXBlID09ICdPVVRERU5UJyBvciB0eXBlID09ICdJTkRFTlQnKVxuXHRcdFx0XHRlbmRDYWxsQXRUZXJtaW5hdG9yID0gbm9cblx0XHRcdFx0bm9DYWxsID0gbm8gXG5cblx0XHRcdHRva2VuOmNhbGwgID0geWVzIGlmIHR5cGUgaXMgJz8nIGFuZCBwcmV2IGFuZCAhcHJldjpzcGFjZWRcblxuXHRcdFx0IyB3aGVyZSBkb2VzIGZyb21UaGVtIGNvbWUgZnJvbT9cblx0XHRcdGlmIHRva2VuOmZyb21UaGVuXG5cdFx0XHRcdGNvbnRpbnVlIGkgKz0gMSBcblx0XHRcdCMgaGVyZSB3ZSBkZWFsIHdpdGggOnNwYWNlZCBhbmQgOm5ld0xpbmVcblx0XHRcdHVubGVzcyBjYWxsT2JqZWN0IG9yIGNhbGxJbmRlbnQgb3IgKHByZXYgYW5kIHByZXY6c3BhY2VkKSBhbmQgKHByZXY6Y2FsbCBvciBJTVBMSUNJVF9GVU5DLmluZGV4T2YocHQpID49IDApIGFuZCAoSU1QTElDSVRfQ0FMTC5pbmRleE9mKHR5cGUpID49IDAgb3IgISh0b2tlbjpzcGFjZWQgb3IgdG9rZW46bmV3TGluZSkgYW5kIElNUExJQ0lUX1VOU1BBQ0VEX0NBTEwuaW5kZXhPZih0eXBlKSA+PSAwKVxuXHRcdFx0XHRjb250aW51ZSBpICs9IDFcblxuXG5cdFx0XHR0b2tlbnMuc3BsaWNlIGksIDAsIFQudG9rZW4oJ0NBTExfU1RBUlQnLCAnKCcpXG5cdFx0XHQjIGNvbnNvbGUubG9nIFwiYWRkZWQgKCB7cHJldn1cIlxuXHRcdFx0dmFyIGNvbmQgPSBkbyB8dG9rZW4saXxcblx0XHRcdFx0dmFyIHR5cGUgPSBULnR5cCh0b2tlbilcblx0XHRcdFx0cmV0dXJuIHllcyBpZiAhc2VlblNpbmdsZSBhbmQgdG9rZW46ZnJvbVRoZW5cblx0XHRcdFx0dmFyIGlmZWxzZSA9IHR5cGUgPT0gJ0lGJyBvciB0eXBlID09ICdVTkxFU1MnIG9yIHR5cGUgPT0gJ0VMU0UnXG5cdFx0XHRcdHNlZW5TaW5nbGUgID0geWVzIGlmIGlmZWxzZSBvciB0eXBlID09ICdDQVRDSCdcblx0XHRcdFx0c2VlbkNvbnRyb2wgPSB5ZXMgaWYgaWZlbHNlIG9yIHR5cGUgPT0gJ1NXSVRDSCcgb3IgdHlwZSA9PSAnVFJZJ1xuXHRcdFx0XHR2YXIgcHJldiA9IHRva2VuVHlwZShpIC0gMSlcblxuXHRcdFx0XHRyZXR1cm4geWVzIGlmICh0eXBlID09ICcuJyBvciB0eXBlID09ICc/Licgb3IgdHlwZSA9PSAnOjonKSBhbmQgcHJldiBpcyAnT1VUREVOVCdcblx0XHRcdFx0cmV0dXJuIHllcyBpZiBlbmRDYWxsQXRUZXJtaW5hdG9yIGFuZCAodHlwZSA9PSAnSU5ERU5UJyBvciB0eXBlID09ICdURVJNSU5BVE9SJylcblx0XHRcdFx0aWYgKHR5cGUgPT0gJ1dIRU4nIG9yIHR5cGUgPT0gJ0JZJykgYW5kICFzZWVuRm9yXG5cdFx0XHRcdFx0IyBjb25zb2xlLmxvZyBcImRvbnQgY2xvc2UgaW1wbGljaXQgY2FsbCBvdXRzaWRlIGZvclwiXG5cdFx0XHRcdFx0cmV0dXJuIG5vIFxuXG5cdFx0XHRcdHZhciBwb3N0ID0gdG9rZW5zW2kgKyAxXVxuXHRcdFx0XHR2YXIgcG9zdFR5cCA9IHBvc3QgYW5kIFQudHlwKHBvc3QpXG5cdFx0XHRcdCMgV1RGXG5cdFx0XHRcdHJldHVybiAhdG9rZW46Z2VuZXJhdGVkIGFuZCBwcmV2IGlzbnQgJywnIGFuZCAoSU1QTElDSVRfRU5ELmluZGV4T2YodHlwZSkgPj0gMCBvciAodHlwZSBpcyAnSU5ERU5UJyBhbmQgIXNlZW5Db250cm9sKSBvciAodHlwZSBpcyAnRE9TJyBhbmQgcHJldiAhPSAnPScpKSBhbmQgKHR5cGUgaXNudCAnSU5ERU5UJyBvciAodG9rZW5UeXBlKGkgLSAyKSBpc250ICdDTEFTUycgYW5kIElNUExJQ0lUX0JMT0NLLmluZGV4T2YocHJldikgPT0gLTEgYW5kIG5vdCAocG9zdCBhbmQgKChwb3N0OmdlbmVyYXRlZCBhbmQgcG9zdFR5cCBpcyAneycpIG9yIElNUExJQ0lUX0NBTEwuaW5kZXhPZihwb3N0VHlwKSA+PSAwKSkpKVxuXG5cdFx0XHQjIFRoZSBhY3Rpb24gZm9yIGRldGVjdGluZyB3aGVuIHRoZSBjYWxsIHNob3VsZCBlbmRcblx0XHRcdCMgY29uc29sZS5sb2cgXCJkZXRlY3QgZW5kPz9cIlxuXHRcdFx0ZGV0ZWN0RW5kKGkgKyAxLCBjb25kLCBhY3Rpb24pXG5cdFx0XHRULnNldFR5cChwcmV2LCdGVU5DX0VYSVNUJykgaWYgVC50eXAocHJldikgPT0gJz8nXG5cdFx0XHRpICs9IDJcblx0XHRcdCMgbmVlZCB0byByZXNldCBhZnRlciBhIG1hdGNoXG5cdFx0XHRlbmRDYWxsQXRUZXJtaW5hdG9yID0gbm9cblx0XHRcdG5vQ2FsbCA9IG5vXG5cdFx0XHRzZWVuRm9yID0gbm9cblxuXG5cdFx0cmV0dXJuXG5cblx0IyBCZWNhdXNlIG91ciBncmFtbWFyIGlzIExBTFIoMSksIGl0IGNhbid0IGhhbmRsZSBzb21lIHNpbmdsZS1saW5lXG5cdCMgZXhwcmVzc2lvbnMgdGhhdCBsYWNrIGVuZGluZyBkZWxpbWl0ZXJzLiBUaGUgKipSZXdyaXRlcioqIGFkZHMgdGhlIGltcGxpY2l0XG5cdCMgYmxvY2tzLCBzbyBpdCBkb2Vzbid0IG5lZWQgdG8uICcpJyBjYW4gY2xvc2UgYSBzaW5nbGUtbGluZSBibG9jayxcblx0IyBidXQgd2UgbmVlZCB0byBtYWtlIHN1cmUgaXQncyBiYWxhbmNlZC5cblx0ZGVmIGFkZEltcGxpY2l0SW5kZW50YXRpb25cblxuXHRcdFxuXHRcdHZhciBpID0gMFxuXHRcdHZhciB0b2tlbnMgPSBAdG9rZW5zXG5cdFx0d2hpbGUgdmFyIHRva2VuID0gdG9rZW5zW2ldXG5cdFx0XHR2YXIgdHlwZSA9IFQudHlwKHRva2VuKVxuXHRcdFx0dmFyIG5leHQgPSB0b2tlblR5cGUoaSArIDEpXG5cblx0XHRcdCMgd2h5IGFyZSB3ZSByZW1vdmluZyB0ZXJtaW5hdG9ycyBhZnRlciB0aGVuPyBzaG91bGQgYmUgYWJsZSB0byBoYW5kbGVcblx0XHRcdGlmIHR5cGUgPT0gJ1RFUk1JTkFUT1InIGFuZCBuZXh0ID09ICdUSEVOJ1xuXHRcdFx0XHR0b2tlbnMuc3BsaWNlKGksIDEpXG5cdFx0XHRcdGNvbnRpbnVlXG5cblx0XHRcdGlmIHR5cGUgaXMgJ0NBVENIJyBhbmQgdG9rZW5UeXBlKGkgKyAyKSBpbiBbJ09VVERFTlQnLCAnVEVSTUlOQVRPUicsICdGSU5BTExZJ11cblx0XHRcdFx0dG9rZW5zLnNwbGljZSBpICsgMiwgMCwgKmluZGVudGF0aW9uKHRva2VuKVxuXHRcdFx0XHRjb250aW51ZSBpICs9IDRcblxuXHRcdFx0aWYgU0lOR0xFX0xJTkVSUy5pbmRleE9mKHR5cGUpID49IDAgYW5kIChuZXh0ICE9ICdJTkRFTlQnIGFuZCBuZXh0ICE9ICdCTE9DS19QQVJBTV9TVEFSVCcpIGFuZCBub3QgKHR5cGUgPT0gJ0VMU0UnIGFuZCBuZXh0ID09ICdJRicpIGFuZCB0eXBlICE9ICdFTElGJ1xuXG5cdFx0XHRcdHZhciBzdGFydGVyID0gdHlwZVxuXG5cdFx0XHRcdHZhciBpbmRlbnQgPSBULnRva2VuKCdJTkRFTlQnLCAnMicpXG5cdFx0XHRcdHZhciBvdXRkZW50ID0gVC5PVVRERU5UXG5cdFx0XHRcdCMgdmFyIGluZGVudCwgb3V0ZGVudCA9IGluZGVudGF0aW9uKHRva2VuKVxuXHRcdFx0XHRpbmRlbnQ6ZnJvbVRoZW4gICA9IHRydWUgaWYgc3RhcnRlciBpcyAnVEhFTicgIyBzZXR0aW5nIHNwZWNpYWwgdmFsdWVzIGZvciB0aGVzZSAtLSBjYW5ub3QgcmVhbGx5IHJldXNlP1xuXHRcdFx0XHRpbmRlbnQ6Z2VuZXJhdGVkICA9IHRydWVcblx0XHRcdFx0IyBvdXRkZW50OmdlbmVyYXRlZCA9IHRydWVcblx0XHRcdFx0dG9rZW5zLnNwbGljZSBpICsgMSwgMCwgaW5kZW50XG5cblx0XHRcdFx0dmFyIGNvbmRpdGlvbiA9IGRvIHx0b2tlbixpfFxuXHRcdFx0XHRcdHZhciB0ID0gVC50eXAodG9rZW4pXG5cdFx0XHRcdFx0VC52YWwodG9rZW4pICE9ICc7JyBhbmQgU0lOR0xFX0NMT1NFUlMuaW5kZXhPZih0KSA+PSAwIGFuZCBub3QgKHQgPT0gJ0VMU0UnIGFuZCBzdGFydGVyICE9ICdJRicgYW5kIHN0YXJ0ZXIgIT0gJ1RIRU4nKVxuXG5cdFx0XHRcdHZhciBhY3Rpb24gPSBkbyB8dG9rZW4saXxcblx0XHRcdFx0XHR2YXIgaWR4ID0gdG9rZW5UeXBlKGkgLSAxKSBpcyAnLCcgPyBpIC0gMSA6IGlcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlIGlkeCwgMCwgb3V0ZGVudFxuXG5cdFx0XHRcdGRldGVjdEVuZChpICsgMiwgY29uZGl0aW9uLCBhY3Rpb24pXG5cdFx0XHRcdHRva2Vucy5zcGxpY2UgaSwgMSBpZiB0eXBlIGlzICdUSEVOJ1xuXHRcdFx0XG5cdFx0XHRpKytcblxuXHRcdHJldHVyblxuXG5cdCMgVGFnIHBvc3RmaXggY29uZGl0aW9uYWxzIGFzIHN1Y2gsIHNvIHRoYXQgd2UgY2FuIHBhcnNlIHRoZW0gd2l0aCBhXG5cdCMgZGlmZmVyZW50IHByZWNlZGVuY2UuXG5cdGRlZiB0YWdQb3N0Zml4Q29uZGl0aW9uYWxzXG5cdFx0dmFyIGNvbmRpdGlvbiA9IGRvIHx0b2tlbixpfCBULnR5cCh0b2tlbikgaW4gWydURVJNSU5BVE9SJywgJ0lOREVOVCddXG5cblx0XHRzY2FuVG9rZW5zIGRvIHx0b2tlbiwgaXxcblx0XHRcdHZhciB0eXAgPSBULnR5cCh0b2tlbilcblx0XHRcdHJldHVybiAxIHVubGVzcyB0eXAgPT0gJ0lGJyBvciB0eXAgPT0gJ0ZPUidcblx0XHRcdHZhciBvcmlnaW5hbCA9IHRva2VuXG5cdFx0XHRkZXRlY3RFbmQoaSArIDEsIGNvbmRpdGlvbikgZG8gfHRva2VuLGl8XG5cdFx0XHRcdFQuc2V0VHlwKG9yaWdpbmFsLCAnUE9TVF8nICsgVC50eXAob3JpZ2luYWwpKSBpZiBULnR5cCh0b2tlbikgIT0gJ0lOREVOVCdcblx0XHRcdDFcblxuXHQjIEdlbmVyYXRlIHRoZSBpbmRlbnRhdGlvbiB0b2tlbnMsIGJhc2VkIG9uIGFub3RoZXIgdG9rZW4gb24gdGhlIHNhbWUgbGluZS5cblx0ZGVmIGluZGVudGF0aW9uIHRva2VuXG5cdFx0W1QudG9rZW4oJ0lOREVOVCcsICcyJyksIFQudG9rZW4oJ09VVERFTlQnLCAnMicpXVxuXG5cdCMgTG9vayB1cCBhIHR5cGUgYnkgdG9rZW4gaW5kZXguXG5cdGRlZiB0eXBlIGkgXG5cdFx0IyBpZiBpIDwgMCB0aGVuIHJldHVybiBudWxsXG5cdFx0dmFyIHRvayA9IEB0b2tlbnNbaV1cblx0XHR0b2sgYW5kIFQudHlwKHRvaylcblx0XHQjIGlmIHRvayB0aGVuIHRva1swXSBlbHNlIG51bGxcblxuXHRkZWYgdG9rZW5UeXBlIGkgXG5cdFx0dmFyIHRvayA9IEB0b2tlbnNbaV1cblx0XHR0b2sgYW5kIFQudHlwKHRvaylcblx0XHQjIHJldHVybiB0b2sgYW5kIHRva1swXVxuXG4jIENvbnN0YW50c1xuIyAtLS0tLS0tLS1cblxuIyBMaXN0IG9mIHRoZSB0b2tlbiBwYWlycyB0aGF0IG11c3QgYmUgYmFsYW5jZWQuXG52YXIgQkFMQU5DRURfUEFJUlMgPSBbXG5cdFsnKCcsICcpJ11cblx0WydbJywgJ10nXVxuXHRbJ3snLCAnfSddXG5cdFsne3snLCAnfX0nXVxuXHRbJ0lOREVOVCcsICdPVVRERU5UJ10sXG5cdFsnQ0FMTF9TVEFSVCcsICdDQUxMX0VORCddXG5cdFsnUEFSQU1fU1RBUlQnLCAnUEFSQU1fRU5EJ11cblx0WydJTkRFWF9TVEFSVCcsICdJTkRFWF9FTkQnXVxuXHRbJ1RBR19TVEFSVCcsJ1RBR19FTkQnXVxuXHRbJ1RBR19QQVJBTV9TVEFSVCcsJ1RBR19QQVJBTV9FTkQnXVxuXHRbJ1RBR19BVFRSU19TVEFSVCcsJ1RBR19BVFRSU19FTkQnXVxuXHRbJ0JMT0NLX1BBUkFNX1NUQVJUJywnQkxPQ0tfUEFSQU1fRU5EJ11cbl1cblxuIyBUaGUgaW52ZXJzZSBtYXBwaW5ncyBvZiBgQkFMQU5DRURfUEFJUlNgIHdlJ3JlIHRyeWluZyB0byBmaXggdXAsIHNvIHdlIGNhblxuIyBsb29rIHRoaW5ncyB1cCBmcm9tIGVpdGhlciBlbmQuXG5leHBvcnQgdmFyIElOVkVSU0VTID0ge31cblxuIyBUaGUgdG9rZW5zIHRoYXQgc2lnbmFsIHRoZSBzdGFydC9lbmQgb2YgYSBiYWxhbmNlZCBwYWlyLlxuIyB2YXIgRVhQUkVTU0lPTl9TVEFSVCA9IFtdXG4jIHZhciBFWFBSRVNTSU9OX0VORCAgID0gW11cblxuZm9yIHBhaXIgaW4gQkFMQU5DRURfUEFJUlNcblx0dmFyIGxlZnQgPSBwYWlyWzBdXG5cdHZhciByaXRlID0gcGFpclsxXVxuXHRJTlZFUlNFU1tyaXRlXSA9IGxlZnRcblx0SU5WRVJTRVNbbGVmdF0gPSByaXRlXG5cbnZhciBFWFBSRVNTSU9OX1NUQVJUID0gWycoJywnWycsJ3snLCdJTkRFTlQnLCdDQUxMX1NUQVJUJywnUEFSQU1fU1RBUlQnLCdJTkRFWF9TVEFSVCcsJ1RBR19QQVJBTV9TVEFSVCcsJ0JMT0NLX1BBUkFNX1NUQVJUJywnU1RSSU5HX1NUQVJUJywne3snLCAnVEFHX1NUQVJUJ11cbnZhciBFWFBSRVNTSU9OX0VORCA9IFsnKScsJ10nLCd9JywnT1VUREVOVCcsJ0NBTExfRU5EJywnUEFSQU1fRU5EJywnSU5ERVhfRU5EJywnVEFHX1BBUkFNX0VORCcsJ0JMT0NLX1BBUkFNX0VORCcsJ1NUUklOR19FTkQnLCd9fScsICdUQUdfRU5EJ11cblxudmFyIElERU5USUZJRVJTID0gWydJREVOVElGSUVSJywgJ0dWQVInLCAnSVZBUicsICdDVkFSJywgJ0NPTlNUJywgJ0FSR1ZBUiddXG5cbiMgVG9rZW5zIHRoYXQgaW5kaWNhdGUgdGhlIGNsb3NlIG9mIGEgY2xhdXNlIG9mIGFuIGV4cHJlc3Npb24uXG52YXIgRVhQUkVTU0lPTl9DTE9TRSA9IFsnQ0FUQ0gnLCAnV0hFTicsICdFTFNFJywgJ0ZJTkFMTFknXS5jb25jYXQgRVhQUkVTU0lPTl9FTkRcblxuIyBUb2tlbnMgdGhhdCwgaWYgZm9sbG93ZWQgYnkgYW4gYElNUExJQ0lUX0NBTExgLCBpbmRpY2F0ZSBhIGZ1bmN0aW9uIGludm9jYXRpb24uXG52YXIgSU1QTElDSVRfRlVOQyAgICA9IFsnSURFTlRJRklFUicsICdTVVBFUicsICMgJyknLCAnSU5ERVhfRU5EJywgIyAgJ0NBTExfRU5EJyxcblx0J0AnLCAnVEhJUycsJ1NFTEYnLCAnRVZFTlQnLCdUUklHR0VSJywnVEFHX0VORCcsICdJVkFSJywgXG5cdCdHVkFSJywgJ0NPTlNUJywgJ0FSR1ZBUicsICdORVcnLCAnQlJFQUsnLCAnQ09OVElOVUUnLCdSRVRVUk4nXG5dXG5cbiMgSWYgcHJlY2VkZWQgYnkgYW4gYElNUExJQ0lUX0ZVTkNgLCBpbmRpY2F0ZXMgYSBmdW5jdGlvbiBpbnZvY2F0aW9uLlxudmFyIElNUExJQ0lUX0NBTEwgICAgPSBbXG5cdCdTRUxFQ1RPUicsJ0lERU5USUZJRVInLCAnTlVNQkVSJywgJ1NUUklORycsICdTWU1CT0wnLCAnSlMnLCAnUkVHRVgnLCAnTkVXJywgJ1BBUkFNX1NUQVJUJywgJ0NMQVNTJ1xuXHQnSUYnLCAnVU5MRVNTJywgJ1RSWScsICdTV0lUQ0gnLCAnVEhJUycsICdCT09MJywgJ1RSVUUnLCdGQUxTRScsICdOVUxMJywgJ1VOREVGSU5FRCcsICdVTkFSWScsICdTVVBFUicsICdJVkFSJywgJ0dWQVInLCAnQ09OU1QnLCAnQVJHVkFSJywnU0VMRicsIFxuXHQnQCcsICdbJywgJygnLCAneycsICctLScsICcrKycsJ1NFTEVDVE9SJywgJ1RBR19TVEFSVCcsICdUQUdJRCcsICcjJywgJ1NFTEVDVE9SX1NUQVJUJywgJ0lEUkVGJywgJ1NQTEFUJywgJ0RPJywgJ0JMT0NLX0FSRydcblx0J0ZPUicsICdTVFJJTkdfU1RBUlQnLCdDT05USU5VRScsJ0JSRUFLJ1xuXSAjICctPicsICc9PicsIHdoeSBkb2VzIGl0IG5vdCB3b3JrIHdpdGggc3ltYm9sP1xuXG52YXIgSU1QTElDSVRfSU5ERU5UX0NBTEwgPSBbXG5cdCdGT1InXG5dXG4jIGlzIG5vdCBkbyBhbiBpbXBsaWNpdCBjYWxsPz9cblxudmFyIElNUExJQ0lUX1VOU1BBQ0VEX0NBTEwgPSBbJysnLCAnLSddXG5cbiMgVG9rZW5zIGluZGljYXRpbmcgdGhhdCB0aGUgaW1wbGljaXQgY2FsbCBtdXN0IGVuY2xvc2UgYSBibG9jayBvZiBleHByZXNzaW9ucy5cbnZhciBJTVBMSUNJVF9CTE9DSyAgID0gWyd7JywgJ1snLCAnLCcsJ0JMT0NLX1BBUkFNX0VORCcsICdETyddICMgJy0+JywgJz0+JywgXG5cbnZhciBDT05ESVRJT05BTF9BU1NJR04gPSBbJ3x8PScsICcmJj0nLCAnPz0nLCAnJj0nLCAnfD0nXVxudmFyIENPTVBPVU5EX0FTU0lHTiA9IFsnLT0nLCAnKz0nLCAnLz0nLCAnKj0nLCAnJT0nLCAnfHw9JywgJyYmPScsICc/PScsICc8PD0nLCAnPj49JywgJz4+Pj0nLCAnJj0nLCAnXj0nLCAnfD0nXVxudmFyIFVOQVJZID0gWychJywgJ34nLCAnTkVXJywgJ1RZUEVPRicsICdERUxFVEUnXVxudmFyIExPR0lDICAgPSBbJyYmJywgJ3x8JywgJyYnLCAnfCcsICdeJ11cblxuIyBvcHRpbWl6ZSBmb3IgZml4ZWQgYXJyYXlzXG52YXIgTk9fSU1QTElDSVRfQkxPQ0tfQ0FMTCA9IFtcblx0J0NBTExfRU5EJywnPScsJ0RFRl9CT0RZJywnKCcsJ0NBTExfU1RBUlQnLCcsJywnOicsJ1JFVFVSTidcblx0Jy09JywgJys9JywgJy89JywgJyo9JywgJyU9JywgJ3x8PScsICcmJj0nLCAnPz0nLCAnPDw9JywgJz4+PScsICc+Pj49JywgJyY9JywgJ149JywgJ3w9J1xuXSAjIC5jb25jYXQoQ09NUE9VTkRfQVNTSUdOKVxuXG5cbiMgY29uc29sZS5sb2cgTk9fSU1QTElDSVRfQkxPQ0tfQ0FMTDpsZW5ndGhcbiMgTk9fSU1QTElDSVRfQkxPQ0tfQ0FMTFxuIyBJTVBMSUNJVF9DT01NQSA9IFsnLT4nLCAnPT4nLCAneycsICdbJywgJ05VTUJFUicsICdTVFJJTkcnLCAnU1lNQk9MJywgJ0lERU5USUZJRVInLCdETyddXG5cbnZhciBJTVBMSUNJVF9DT01NQSA9IFsnRE8nXVxuXG4jIFRva2VucyB0aGF0IGFsd2F5cyBtYXJrIHRoZSBlbmQgb2YgYW4gaW1wbGljaXQgY2FsbCBmb3Igc2luZ2xlLWxpbmVycy5cbnZhciBJTVBMSUNJVF9FTkQgICAgID0gWydQT1NUX0lGJywgJ1BPU1RfVU5MRVNTJywgJ1BPU1RfRk9SJywgJ1dISUxFJywgJ1VOVElMJywgJ1dIRU4nLCAnQlknLCAnTE9PUCcsICdURVJNSU5BVE9SJywnREVGX0JPRFknLCdERUZfRlJBR01FTlQnXVxuXG4jIFNpbmdsZS1saW5lIGZsYXZvcnMgb2YgYmxvY2sgZXhwcmVzc2lvbnMgdGhhdCBoYXZlIHVuY2xvc2VkIGVuZGluZ3MuXG4jIFRoZSBncmFtbWFyIGNhbid0IGRpc2FtYmlndWF0ZSB0aGVtLCBzbyB3ZSBpbnNlcnQgdGhlIGltcGxpY2l0IGluZGVudGF0aW9uLlxudmFyIFNJTkdMRV9MSU5FUlMgICAgPSBbJ0VMU0UnLCAnVFJZJywgJ0ZJTkFMTFknLCAnVEhFTicsJ0JMT0NLX1BBUkFNX0VORCcsJ0RPJywnQkVHSU4nLCdDQVRDSF9WQVInXSAjICctPicsICc9PicsIHJlYWxseT9cbnZhciBTSU5HTEVfQ0xPU0VSUyAgID0gWydURVJNSU5BVE9SJywgJ0NBVENIJywgJ0ZJTkFMTFknLCAnRUxTRScsICdPVVRERU5UJywgJ0xFQURJTkdfV0hFTiddXG5cbiMgVG9rZW5zIHRoYXQgZW5kIGEgbGluZS5cbnZhciBMSU5FQlJFQUtTICAgICAgID0gWydURVJNSU5BVE9SJywgJ0lOREVOVCcsICdPVVRERU5UJ11cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHNyYy9jb21waWxlci9yZXdyaXRlci5pbWJhXG4gKiovIiwiLyogcGFyc2VyIGdlbmVyYXRlZCBieSBqaXNvbi1mb3JrICovXG52YXIgcGFyc2VyID0gKGZ1bmN0aW9uKCl7XG52YXIgbz1mdW5jdGlvbihrLHYsbyxsKXtmb3Iobz1vfHx7fSxsPWsubGVuZ3RoO2wtLTtvW2tbbF1dPXYpO3JldHVybiBvfSwkVjA9WzEsNF0sJFYxPVsxLDZdLCRWMj1bMSwzMl0sJFYzPVsxLDMzXSwkVjQ9WzEsMzRdLCRWNT1bMSwzNV0sJFY2PVsxLDc1XSwkVjc9WzEsMTE1XSwkVjg9WzEsMTI4XSwkVjk9WzEsMTIxXSwkVmE9WzEsMTIyXSwkVmI9WzEsMTIzXSwkVmM9WzEsMTIwXSwkVmQ9WzEsMTI0XSwkVmU9WzEsMTMxXSwkVmY9WzEsMTE0XSwkVmc9WzEsMTMyXSwkVmg9WzEsODBdLCRWaT1bMSw4MV0sJFZqPVsxLDgyXSwkVms9WzEsODNdLCRWbD1bMSw4NF0sJFZtPVsxLDg1XSwkVm49WzEsODZdLCRWbz1bMSw3M10sJFZwPVsxLDExOF0sJFZxPVsxLDk1XSwkVnI9WzEsOTFdLCRWcz1bMSw4OF0sJFZ0PVsxLDcxXSwkVnU9WzEsNjVdLCRWdj1bMSw2Nl0sJFZ3PVsxLDExMV0sJFZ4PVsxLDkwXSwkVnk9WzEsODddLCRWej1bMSwyOF0sJFZBPVsxLDI5XSwkVkI9WzEsOTZdLCRWQz1bMSw5NF0sJFZEPVsxLDExMl0sJFZFPVsxLDExM10sJFZGPVsxLDEyNl0sJFZHPVsxLDY3XSwkVkg9WzEsNjhdLCRWST1bMSwxMTldLCRWSj1bMSwxMV0sJFZLPVsxLDEyN10sJFZMPVsxLDc4XSwkVk09WzEsMzddLCRWTj1bMSw0M10sJFZPPVsxLDExMF0sJFZQPVsxLDY5XSwkVlE9WzEsODldLCRWUj1bMSwxMjVdLCRWUz1bMSw1OV0sJFZUPVsxLDc0XSwkVlU9WzEsMTA1XSwkVlY9WzEsMTA2XSwkVlc9WzEsMTA3XSwkVlg9WzEsMTI5XSwkVlk9WzEsMTMwXSwkVlo9WzEsNjNdLCRWXz1bMSwxMDRdLCRWJD1bMSw1MV0sJFYwMT1bMSw1Ml0sJFYxMT1bMSw1M10sJFYyMT1bMSw1NF0sJFYzMT1bMSw1NV0sJFY0MT1bMSw1Nl0sJFY1MT1bMSwxMzRdLCRWNjE9WzEsNiwxMSwxMzddLCRWNzE9WzEsMTM2XSwkVjgxPVsxLDYsMTEsMTQsMTM3XSwkVjkxPVsxLDE0NF0sJFZhMT1bMSwxNDVdLCRWYjE9WzEsMTQ3XSwkVmMxPVsxLDE0OF0sJFZkMT1bMSwxNDFdLCRWZTE9WzEsMTQwXSwkVmYxPVsxLDE0Ml0sJFZnMT1bMSwxNDNdLCRWaDE9WzEsMTQ2XSwkVmkxPVsxLDE1MV0sJFZqMT1bMSw2LDEwLDExLDE0LDIyLDcxLDkwLDk3LDEwNiwxMTIsMTI2LDEzNSwxMzcsMTQ3LDE3MSwyMDAsMjAxLDIxMiwyMTMsMjE0LDIxOSwyMjAsMjI5LDIzOCwyMzksMjQyLDI0MywyNDYsMjQ3LDI0OF0sJFZrMT1bMiwyNjNdLCRWbDE9WzEsMTU4XSwkVm0xPVsxLDE2NF0sJFZuMT1bMSwxNjJdLCRWbzE9WzEsMTYwXSwkVnAxPVsxLDE2MV0sJFZxMT1bMSwxNjVdLCRWcjE9WzEsMTYzXSwkVnMxPVsxLDYsMTAsMTEsMTQsMjIsOTAsOTcsMTM3XSwkVnQxPVsxLDYsMTEsMTQsMTM3LDIxMiwyMTQsMjE5LDIyMCwyMzhdLCRWdTE9WzEsNiwxMCwxMSwxNCwyMSwyMiw3MSw4OCw4OSw5MCw5NywxMDYsMTExLDExMiwxMjYsMTM1LDEzNywxNDQsMTQ3LDE3MSwxODAsMTgxLDE4MywxOTYsMjAwLDIwMSwyMTIsMjEzLDIxNCwyMTksMjIwLDIyOSwyMzgsMjM5LDI0MiwyNDMsMjQ2LDI0NywyNDhdLCRWdjE9WzIsMjMxXSwkVncxPVsxLDE3OF0sJFZ4MT1bMSwxNzZdLCRWeTE9WzEsNiwxMCwxMSwxNCwyMSwyMiw3MSw4OCw4OSw5MCw5NywxMDYsMTExLDExMiwxMTcsMTI2LDEzNSwxMzcsMTQ0LDE0NywxNzEsMTgwLDE4MSwxODMsMTk2LDIwMCwyMDEsMjEyLDIxMywyMTQsMjE5LDIyMCwyMjksMjM4LDIzOSwyNDIsMjQzLDI0NiwyNDcsMjQ4XSwkVnoxPVsyLDIyN10sJFZBMT1bNiwxNCw1Myw1NCw4OCw5MSwxMDYsMTExLDExMywxMTZdLCRWQjE9WzEsMjEyXSwkVkMxPVsxLDIxN10sJFZEMT1bMSw2LDEwLDExLDE0LDIxLDIyLDcxLDg4LDg5LDkwLDk3LDEwNiwxMTEsMTEyLDExNywxMjYsMTM1LDEzNywxNDQsMTQ3LDE3MSwxODAsMTgxLDE4MywxOTYsMjAwLDIwMSwyMTIsMjEzLDIxNCwyMTksMjIwLDIyOSwyMzgsMjM5LDI0MiwyNDMsMjQ0LDI0NSwyNDYsMjQ3LDI0OCwyNDldLCRWRTE9WzEsMjI3XSwkVkYxPVsxLDIyNF0sJFZHMT1bMSwyMjldLCRWSDE9WzYsMTAsMTQsOTBdLCRWSTE9WzIsMjQ0XSwkVkoxPVsxLDI1N10sJFZLMT1bMSwyNDddLCRWTDE9WzEsMjc2XSwkVk0xPVsxLDI3N10sJFZOMT1bNTEsODldLCRWTzE9Wzg1LDg2LDg3LDg4LDkxLDkyLDkzLDk0LDk1LDk2LDEwMCwxMDJdLCRWUDE9WzEsMjg5XSwkVlExPVsxLDYsMTAsMTEsMTQsMjEsMjIsNTMsNTQsNzEsODgsODksOTAsOTEsOTcsMTA2LDExMSwxMTIsMTEzLDExNiwxMTcsMTI2LDEzNSwxMzcsMTQ0LDE0NywxNzEsMTgwLDE4MSwxODMsMTk2LDIwMCwyMDEsMjEyLDIxMywyMTQsMjE5LDIyMCwyMjksMjM4LDIzOSwyNDIsMjQzLDI0NCwyNDUsMjQ2LDI0NywyNDgsMjQ5XSwkVlIxPVsxLDI5NV0sJFZTMT1bNTEsODksOTYsMjI1XSwkVlQxPVsxLDYsMTAsMTEsMTQsMjEsMjIsNjcsNjksNzAsNzEsODgsODksOTAsOTcsMTA2LDExMSwxMTIsMTI2LDEzNSwxMzcsMTQ0LDE0NywxNzEsMTgwLDE4MSwxODMsMTk2LDIwMCwyMDEsMjEyLDIxMywyMTQsMjE5LDIyMCwyMjksMjM4LDIzOSwyNDIsMjQzLDI0NiwyNDcsMjQ4XSwkVlUxPVsxLDYsMTAsMTEsMTQsMjEsMjIsNzEsODgsODksOTAsOTcsMTA2LDExMSwxMTIsMTI2LDEzNSwxMzcsMTQ0LDE0NywxNzEsMTgwLDE4MSwxODMsMTk2LDIwMCwyMDEsMjA3LDIwOCwyMTIsMjEzLDIxNCwyMTksMjIwLDIyOSwyMzIsMjM0LDIzNywyMzgsMjM5LDI0MiwyNDMsMjQ2LDI0NywyNDhdLCRWVjE9WzUxLDUzLDU0LDU4XSwkVlcxPVsxLDMyNl0sJFZYMT1bMSwzMjddLCRWWTE9WzEsNiwxMCwxMSwxNCwyMiw3MSw5MCw5NywxMDYsMTEyLDEzNSwxMzcsMTQ3LDIwMCwyMDEsMjEyLDIxMywyMTQsMjE5LDIyMCwyMjksMjM4XSwkVloxPVsxLDM0MF0sJFZfMT1bMSwzNDRdLCRWJDE9WzEsNiwxMSwxNCwyMiw3MSw5MCw5NywxMDYsMTEyLDEyNiwxMzUsMTM3LDE0NywxNzEsMjAwLDIwMSwyMTIsMjEzLDIxNCwyMTksMjIwLDIyOSwyMzgsMjM5LDI0MiwyNDMsMjQ2LDI0NywyNDhdLCRWMDI9WzYsMTQsMTA2XSwkVjEyPVsxLDM1NF0sJFYyMj1bMSw2LDEwLDExLDE0LDIxLDIyLDcxLDg5LDkwLDk3LDEwNiwxMTIsMTI2LDEzNSwxMzcsMTQ3LDE3MSwyMDAsMjAxLDIxMiwyMTMsMjE0LDIxOSwyMjAsMjI5LDIzOCwyMzksMjQyLDI0MywyNDYsMjQ3LDI0OF0sJFYzMj1bMTQsMjhdLCRWNDI9WzEsNiwxMSwxNCwyOCwxMzcsMjEyLDIxNCwyMTksMjIwLDIzOF0sJFY1Mj1bMiwyODRdLCRWNjI9WzEsNiwxMCwxMSwxNCwyMSwyMiw3MSw4OCw4OSw5MCw5NywxMDYsMTExLDExMiwxMTcsMTI2LDEzNSwxMzcsMTQ0LDE0NywxNzEsMTgwLDE4MSwxODMsMTk2LDIwMCwyMDEsMjEyLDIxMywyMTQsMjE5LDIyMCwyMjcsMjI4LDIyOSwyMzgsMjM5LDI0MiwyNDMsMjQ0LDI0NSwyNDYsMjQ3LDI0OCwyNDldLCRWNzI9WzIsMTg0XSwkVjgyPVsxLDM2OV0sJFY5Mj1bNiwxMCwxMSwxNCwyMiw5N10sJFZhMj1bMTQsMTQ3XSwkVmIyPVsyLDE4Nl0sJFZjMj1bMSwzNzldLCRWZDI9WzEsMzgwXSwkVmUyPVsxLDM4MV0sJFZmMj1bMSwzODVdLCRWZzI9WzYsMTAsMTEsMTQsOTBdLCRWaDI9WzYsMTAsMTEsMTQsOTAsMTM1XSwkVmkyPVsxLDYsMTAsMTEsMTQsMjIsNzEsOTAsOTcsMTA2LDExMiwxMzUsMTM3LDE0NywyMDAsMjAxLDIyMCwyMjksMjM4XSwkVmoyPVsxLDYsMTAsMTEsMTQsMjIsNzEsOTAsOTcsMTA2LDExMiwxMzUsMTM3LDE0NywyMDAsMjAxLDIxMywyMjAsMjI5LDIzOF0sJFZrMj1bMjI3LDIyOF0sJFZsMj1bMTQsMjI3LDIyOF0sJFZtMj1bMSw2LDExLDE0LDIyLDcxLDkwLDk3LDEwNiwxMTIsMTM1LDEzNywxNDcsMTcxLDIwMCwyMDEsMjEyLDIxMywyMTQsMjE5LDIyMCwyMjksMjM4LDIzOSwyNDIsMjQzLDI0NiwyNDcsMjQ4XSwkVm4yPVs4OCw5MV0sJFZvMj1bMSw0MDZdLCRWcDI9WzEsNDA3XSwkVnEyPVsyMSw4OCw5MSwxNjQsMTY1XSwkVnIyPVsxLDYsMTAsMTEsMTQsMjIsNzEsOTAsOTcsMTA2LDExMiwxMjYsMTM1LDEzNywxNDcsMTcxLDIwMCwyMDEsMjEyLDIxMywyMTQsMjE5LDIyMCwyMjksMjM4LDIzOSwyNDIsMjQzLDI0NywyNDhdLCRWczI9WzEsNiwxMCwxMSwxNCwyMiw3MSw5MCw5NywxMDYsMTEyLDEzNSwxMzcsMTQ3LDIwMCwyMDEsMjEzLDIyOV0sJFZ0Mj1bMTksMjAsMjMsMjQsMjYsMzIsNTEsNTMsNTQsNTYsNTgsNjAsNjIsNjQsNjYsNzMsNzQsNzUsNzYsNzcsNzgsNzksODAsODMsODksOTEsOTYsMTAzLDExMiwxMjIsMTIzLDEyNCwxMzAsMTM2LDE0MywxNDQsMTUxLDE1MiwxNTQsMTU2LDE1NywxNTgsMTc1LDE4NCwxODUsMTg4LDE5MywxOTQsMTk3LDE5OCwyMDQsMjEwLDIxMiwyMTQsMjE2LDIxOSwyMjAsMjMwLDIzNiwyNDAsMjQxLDI0MiwyNDMsMjQ0LDI0NV0sJFZ1Mj1bMSw2LDEwLDExLDE0LDIyLDcxLDkwLDk3LDEwNiwxMTIsMTI2LDEzNSwxMzcsMTQ3LDE3MSwyMDAsMjAxLDIxMiwyMTMsMjE0LDIxOSwyMjAsMjI5LDIzMiwyMzcsMjM4LDIzOSwyNDIsMjQzLDI0NiwyNDcsMjQ4XSwkVnYyPVsxMSwyMzIsMjM0XSwkVncyPVsxLDQ1M10sJFZ4Mj1bMiwxODVdLCRWeTI9WzYsMTAsMTFdLCRWejI9WzEsNDYxXSwkVkEyPVsxNCwyMiwxNDddLCRWQjI9WzEsNDY5XSwkVkMyPVsxLDYsMTAsMTEsMTQsMjIsNzEsOTAsOTcsMTA2LDExMiwxMzUsMTM3LDE0NywyMDAsMjAxLDIxMiwyMTQsMjE5LDIyMCwyMjksMjM4XSwkVkQyPVs1MSw1OCw4OV0sJFZFMj1bMTQsMjJdLCRWRjI9WzEsNDkyXSwkVkcyPVsxMCwxNF0sJFZIMj1bMSw1NDJdLCRWSTI9WzYsMTBdO1xudmFyIHBhcnNlciA9IHt0cmFjZTogZnVuY3Rpb24gdHJhY2UoKSB7IH0sXG55eToge30sXG5zeW1ib2xzXzoge1wiZXJyb3JcIjoyLFwiUm9vdFwiOjMsXCJCb2R5XCI6NCxcIkJsb2NrXCI6NSxcIlRFUk1JTkFUT1JcIjo2LFwiQk9EWVNUQVJUXCI6NyxcIkxpbmVcIjo4LFwiVGVybWluYXRvclwiOjksXCJJTkRFTlRcIjoxMCxcIk9VVERFTlRcIjoxMSxcIlNwbGF0XCI6MTIsXCJFeHByZXNzaW9uXCI6MTMsXCIsXCI6MTQsXCJDb21tZW50XCI6MTUsXCJTdGF0ZW1lbnRcIjoxNixcIlJldHVyblwiOjE3LFwiVGhyb3dcIjoxOCxcIlNUQVRFTUVOVFwiOjE5LFwiQlJFQUtcIjoyMCxcIkNBTExfU1RBUlRcIjoyMSxcIkNBTExfRU5EXCI6MjIsXCJDT05USU5VRVwiOjIzLFwiREVCVUdHRVJcIjoyNCxcIkltcG9ydFN0YXRlbWVudFwiOjI1LFwiSU1QT1JUXCI6MjYsXCJJbXBvcnRBcmdMaXN0XCI6MjcsXCJGUk9NXCI6MjgsXCJJbXBvcnRGcm9tXCI6MjksXCJBU1wiOjMwLFwiSW1wb3J0QXJnXCI6MzEsXCJTVFJJTkdcIjozMixcIlZhcklkZW50aWZpZXJcIjozMyxcIkF3YWl0XCI6MzQsXCJWYWx1ZVwiOjM1LFwiQ29kZVwiOjM2LFwiT3BlcmF0aW9uXCI6MzcsXCJBc3NpZ25cIjozOCxcIklmXCI6MzksXCJUZXJuYXJ5XCI6NDAsXCJUcnlcIjo0MSxcIldoaWxlXCI6NDIsXCJGb3JcIjo0MyxcIlN3aXRjaFwiOjQ0LFwiQ2xhc3NcIjo0NSxcIk1vZHVsZVwiOjQ2LFwiVGFnRGVjbGFyYXRpb25cIjo0NyxcIlRhZ1wiOjQ4LFwiUHJvcGVydHlcIjo0OSxcIklkZW50aWZpZXJcIjo1MCxcIklERU5USUZJRVJcIjo1MSxcIkl2YXJcIjo1MixcIklWQVJcIjo1MyxcIkNWQVJcIjo1NCxcIkd2YXJcIjo1NSxcIkdWQVJcIjo1NixcIkNvbnN0XCI6NTcsXCJDT05TVFwiOjU4LFwiQXJndmFyXCI6NTksXCJBUkdWQVJcIjo2MCxcIlN5bWJvbFwiOjYxLFwiU1lNQk9MXCI6NjIsXCJBbHBoYU51bWVyaWNcIjo2MyxcIk5VTUJFUlwiOjY0LFwiSW50ZXJwb2xhdGVkU3RyaW5nXCI6NjUsXCJTVFJJTkdfU1RBUlRcIjo2NixcIk5FT1NUUklOR1wiOjY3LFwiSW50ZXJwb2xhdGlvblwiOjY4LFwiU1RSSU5HX0VORFwiOjY5LFwie3tcIjo3MCxcIn19XCI6NzEsXCJMaXRlcmFsXCI6NzIsXCJKU1wiOjczLFwiUkVHRVhcIjo3NCxcIkJPT0xcIjo3NSxcIlRSVUVcIjo3NixcIkZBTFNFXCI6NzcsXCJOVUxMXCI6NzgsXCJVTkRFRklORURcIjo3OSxcIlJFVFVSTlwiOjgwLFwiQXJndW1lbnRzXCI6ODEsXCJUYWdTZWxlY3RvclwiOjgyLFwiU0VMRUNUT1JfU1RBUlRcIjo4MyxcIlRhZ1NlbGVjdG9yVHlwZVwiOjg0LFwiU0VMRUNUT1JfTlNcIjo4NSxcIlNFTEVDVE9SX0lEXCI6ODYsXCJTRUxFQ1RPUl9DTEFTU1wiOjg3LFwiLlwiOjg4LFwie1wiOjg5LFwifVwiOjkwLFwiI1wiOjkxLFwiU0VMRUNUT1JfQ09NQklOQVRPUlwiOjkyLFwiU0VMRUNUT1JfUFNFVURPX0NMQVNTXCI6OTMsXCJTRUxFQ1RPUl9HUk9VUFwiOjk0LFwiVU5JVkVSU0FMX1NFTEVDVE9SXCI6OTUsXCJbXCI6OTYsXCJdXCI6OTcsXCJTRUxFQ1RPUl9BVFRSX09QXCI6OTgsXCJUYWdTZWxlY3RvckF0dHJWYWx1ZVwiOjk5LFwiU0VMRUNUT1JfVEFHXCI6MTAwLFwiU2VsZWN0b3JcIjoxMDEsXCJTRUxFQ1RPUl9FTkRcIjoxMDIsXCJUQUdfU1RBUlRcIjoxMDMsXCJUYWdPcHRpb25zXCI6MTA0LFwiVGFnQXR0cmlidXRlc1wiOjEwNSxcIlRBR19FTkRcIjoxMDYsXCJUYWdCb2R5XCI6MTA3LFwiVGFnVHlwZU5hbWVcIjoxMDgsXCJTZWxmXCI6MTA5LFwiVEFHX1RZUEVcIjoxMTAsXCJJTkRFWF9TVEFSVFwiOjExMSxcIklOREVYX0VORFwiOjExMixcIkBcIjoxMTMsXCJUYWdBdHRyXCI6MTE0LFwiT3B0Q29tbWFcIjoxMTUsXCJUQUdfQVRUUlwiOjExNixcIj1cIjoxMTcsXCJUYWdBdHRyVmFsdWVcIjoxMTgsXCJBcmdMaXN0XCI6MTE5LFwiVGFnVHlwZURlZlwiOjEyMCxcIlRhZ0RlY2xhcmF0aW9uQmxvY2tcIjoxMjEsXCJFWFRFTkRcIjoxMjIsXCJMT0NBTFwiOjEyMyxcIlRBR1wiOjEyNCxcIlRhZ1R5cGVcIjoxMjUsXCJDT01QQVJFXCI6MTI2LFwiVGFnRGVjbEtleXdvcmRzXCI6MTI3LFwiVEFHX0lEXCI6MTI4LFwiVGFnSWRcIjoxMjksXCJJRFJFRlwiOjEzMCxcIkFzc2lnbmFibGVcIjoxMzEsXCJPdXRkZW50XCI6MTMyLFwiQXNzaWduT2JqXCI6MTMzLFwiT2JqQXNzaWduYWJsZVwiOjEzNCxcIjpcIjoxMzUsXCIoXCI6MTM2LFwiKVwiOjEzNyxcIkhFUkVDT01NRU5UXCI6MTM4LFwiQ09NTUVOVFwiOjEzOSxcIk1ldGhvZFwiOjE0MCxcIkRvXCI6MTQxLFwiQmVnaW5cIjoxNDIsXCJCRUdJTlwiOjE0MyxcIkRPXCI6MTQ0LFwiQkxPQ0tfUEFSQU1fU1RBUlRcIjoxNDUsXCJQYXJhbUxpc3RcIjoxNDYsXCJCTE9DS19QQVJBTV9FTkRcIjoxNDcsXCJQcm9wVHlwZVwiOjE0OCxcIlByb3BlcnR5SWRlbnRpZmllclwiOjE0OSxcIk9iamVjdFwiOjE1MCxcIlBST1BcIjoxNTEsXCJBVFRSXCI6MTUyLFwiVHVwbGVBc3NpZ25cIjoxNTMsXCJWQVJcIjoxNTQsXCJNZXRob2REZWNsYXJhdGlvblwiOjE1NSxcIkdMT0JBTFwiOjE1NixcIkVYUE9SVFwiOjE1NyxcIkRFRlwiOjE1OCxcIk1ldGhvZFNjb3BlXCI6MTU5LFwiTWV0aG9kU2NvcGVUeXBlXCI6MTYwLFwiTWV0aG9kSWRlbnRpZmllclwiOjE2MSxcIk1ldGhvZEJvZHlcIjoxNjIsXCJNZXRob2RSZWNlaXZlclwiOjE2MyxcIkRFRl9CT0RZXCI6MTY0LFwiREVGX0VNUFRZXCI6MTY1LFwiVGhpc1wiOjE2NixcIlBhcmFtXCI6MTY3LFwiQXJyYXlcIjoxNjgsXCJQYXJhbVZhclwiOjE2OSxcIlNQTEFUXCI6MTcwLFwiTE9HSUNcIjoxNzEsXCJCTE9DS19BUkdcIjoxNzIsXCJWYXJSZWZlcmVuY2VcIjoxNzMsXCJWYXJBc3NpZ25hYmxlXCI6MTc0LFwiTEVUXCI6MTc1LFwiU2ltcGxlQXNzaWduYWJsZVwiOjE3NixcIk5FV1wiOjE3NyxcIlN1cGVyXCI6MTc4LFwiU29ha2FibGVPcFwiOjE3OSxcIj86XCI6MTgwLFwiLjpcIjoxODEsXCJJbmRleFZhbHVlXCI6MTgyLFwiPy5cIjoxODMsXCJTVVBFUlwiOjE4NCxcIkFXQUlUXCI6MTg1LFwiUGFyZW50aGV0aWNhbFwiOjE4NixcIlJhbmdlXCI6MTg3LFwiQVJHVU1FTlRTXCI6MTg4LFwiSW52b2NhdGlvblwiOjE4OSxcIlNsaWNlXCI6MTkwLFwiQXNzaWduTGlzdFwiOjE5MSxcIkNsYXNzU3RhcnRcIjoxOTIsXCJDTEFTU1wiOjE5MyxcIk1PRFVMRVwiOjE5NCxcIk9wdEZ1bmNFeGlzdFwiOjE5NSxcIkZVTkNfRVhJU1RcIjoxOTYsXCJUSElTXCI6MTk3LFwiU0VMRlwiOjE5OCxcIlJhbmdlRG90c1wiOjE5OSxcIi4uXCI6MjAwLFwiLi4uXCI6MjAxLFwiQXJnXCI6MjAyLFwiU2ltcGxlQXJnc1wiOjIwMyxcIlRSWVwiOjIwNCxcIkNhdGNoXCI6MjA1LFwiRmluYWxseVwiOjIwNixcIkZJTkFMTFlcIjoyMDcsXCJDQVRDSFwiOjIwOCxcIkNBVENIX1ZBUlwiOjIwOSxcIlRIUk9XXCI6MjEwLFwiV2hpbGVTb3VyY2VcIjoyMTEsXCJXSElMRVwiOjIxMixcIldIRU5cIjoyMTMsXCJVTlRJTFwiOjIxNCxcIkxvb3BcIjoyMTUsXCJMT09QXCI6MjE2LFwiRm9yQm9keVwiOjIxNyxcIkZvcktleXdvcmRcIjoyMTgsXCJGT1JcIjoyMTksXCJQT1NUX0ZPUlwiOjIyMCxcIkZvckJsb2NrXCI6MjIxLFwiRm9yU3RhcnRcIjoyMjIsXCJGb3JTb3VyY2VcIjoyMjMsXCJGb3JWYXJpYWJsZXNcIjoyMjQsXCJPV05cIjoyMjUsXCJGb3JWYWx1ZVwiOjIyNixcIkZPUklOXCI6MjI3LFwiRk9ST0ZcIjoyMjgsXCJCWVwiOjIyOSxcIlNXSVRDSFwiOjIzMCxcIldoZW5zXCI6MjMxLFwiRUxTRVwiOjIzMixcIldoZW5cIjoyMzMsXCJMRUFESU5HX1dIRU5cIjoyMzQsXCJJZkJsb2NrXCI6MjM1LFwiSUZcIjoyMzYsXCJFTElGXCI6MjM3LFwiUE9TVF9JRlwiOjIzOCxcIj9cIjoyMzksXCJVTkFSWVwiOjI0MCxcIlNRUlRcIjoyNDEsXCItXCI6MjQyLFwiK1wiOjI0MyxcIi0tXCI6MjQ0LFwiKytcIjoyNDUsXCJNQVRIXCI6MjQ2LFwiU0hJRlRcIjoyNDcsXCJSRUxBVElPTlwiOjI0OCxcIkNPTVBPVU5EX0FTU0lHTlwiOjI0OSxcIiRhY2NlcHRcIjowLFwiJGVuZFwiOjF9LFxudGVybWluYWxzXzogezI6XCJlcnJvclwiLDY6XCJURVJNSU5BVE9SXCIsNzpcIkJPRFlTVEFSVFwiLDEwOlwiSU5ERU5UXCIsMTE6XCJPVVRERU5UXCIsMTQ6XCIsXCIsMTk6XCJTVEFURU1FTlRcIiwyMDpcIkJSRUFLXCIsMjE6XCJDQUxMX1NUQVJUXCIsMjI6XCJDQUxMX0VORFwiLDIzOlwiQ09OVElOVUVcIiwyNDpcIkRFQlVHR0VSXCIsMjY6XCJJTVBPUlRcIiwyODpcIkZST01cIiwzMDpcIkFTXCIsMzI6XCJTVFJJTkdcIiw1MTpcIklERU5USUZJRVJcIiw1MzpcIklWQVJcIiw1NDpcIkNWQVJcIiw1NjpcIkdWQVJcIiw1ODpcIkNPTlNUXCIsNjA6XCJBUkdWQVJcIiw2MjpcIlNZTUJPTFwiLDY0OlwiTlVNQkVSXCIsNjY6XCJTVFJJTkdfU1RBUlRcIiw2NzpcIk5FT1NUUklOR1wiLDY5OlwiU1RSSU5HX0VORFwiLDcwOlwie3tcIiw3MTpcIn19XCIsNzM6XCJKU1wiLDc0OlwiUkVHRVhcIiw3NTpcIkJPT0xcIiw3NjpcIlRSVUVcIiw3NzpcIkZBTFNFXCIsNzg6XCJOVUxMXCIsNzk6XCJVTkRFRklORURcIiw4MDpcIlJFVFVSTlwiLDgzOlwiU0VMRUNUT1JfU1RBUlRcIiw4NTpcIlNFTEVDVE9SX05TXCIsODY6XCJTRUxFQ1RPUl9JRFwiLDg3OlwiU0VMRUNUT1JfQ0xBU1NcIiw4ODpcIi5cIiw4OTpcIntcIiw5MDpcIn1cIiw5MTpcIiNcIiw5MjpcIlNFTEVDVE9SX0NPTUJJTkFUT1JcIiw5MzpcIlNFTEVDVE9SX1BTRVVET19DTEFTU1wiLDk0OlwiU0VMRUNUT1JfR1JPVVBcIiw5NTpcIlVOSVZFUlNBTF9TRUxFQ1RPUlwiLDk2OlwiW1wiLDk3OlwiXVwiLDk4OlwiU0VMRUNUT1JfQVRUUl9PUFwiLDEwMDpcIlNFTEVDVE9SX1RBR1wiLDEwMjpcIlNFTEVDVE9SX0VORFwiLDEwMzpcIlRBR19TVEFSVFwiLDEwNjpcIlRBR19FTkRcIiwxMTA6XCJUQUdfVFlQRVwiLDExMTpcIklOREVYX1NUQVJUXCIsMTEyOlwiSU5ERVhfRU5EXCIsMTEzOlwiQFwiLDExNjpcIlRBR19BVFRSXCIsMTE3OlwiPVwiLDEyMjpcIkVYVEVORFwiLDEyMzpcIkxPQ0FMXCIsMTI0OlwiVEFHXCIsMTI2OlwiQ09NUEFSRVwiLDEyODpcIlRBR19JRFwiLDEzMDpcIklEUkVGXCIsMTM1OlwiOlwiLDEzNjpcIihcIiwxMzc6XCIpXCIsMTM4OlwiSEVSRUNPTU1FTlRcIiwxMzk6XCJDT01NRU5UXCIsMTQzOlwiQkVHSU5cIiwxNDQ6XCJET1wiLDE0NTpcIkJMT0NLX1BBUkFNX1NUQVJUXCIsMTQ3OlwiQkxPQ0tfUEFSQU1fRU5EXCIsMTUxOlwiUFJPUFwiLDE1MjpcIkFUVFJcIiwxNTQ6XCJWQVJcIiwxNTY6XCJHTE9CQUxcIiwxNTc6XCJFWFBPUlRcIiwxNTg6XCJERUZcIiwxNjQ6XCJERUZfQk9EWVwiLDE2NTpcIkRFRl9FTVBUWVwiLDE3MDpcIlNQTEFUXCIsMTcxOlwiTE9HSUNcIiwxNzI6XCJCTE9DS19BUkdcIiwxNzU6XCJMRVRcIiwxNzc6XCJORVdcIiwxODA6XCI/OlwiLDE4MTpcIi46XCIsMTgzOlwiPy5cIiwxODQ6XCJTVVBFUlwiLDE4NTpcIkFXQUlUXCIsMTg4OlwiQVJHVU1FTlRTXCIsMTkzOlwiQ0xBU1NcIiwxOTQ6XCJNT0RVTEVcIiwxOTY6XCJGVU5DX0VYSVNUXCIsMTk3OlwiVEhJU1wiLDE5ODpcIlNFTEZcIiwyMDA6XCIuLlwiLDIwMTpcIi4uLlwiLDIwNDpcIlRSWVwiLDIwNzpcIkZJTkFMTFlcIiwyMDg6XCJDQVRDSFwiLDIwOTpcIkNBVENIX1ZBUlwiLDIxMDpcIlRIUk9XXCIsMjEyOlwiV0hJTEVcIiwyMTM6XCJXSEVOXCIsMjE0OlwiVU5USUxcIiwyMTY6XCJMT09QXCIsMjE5OlwiRk9SXCIsMjIwOlwiUE9TVF9GT1JcIiwyMjU6XCJPV05cIiwyMjc6XCJGT1JJTlwiLDIyODpcIkZPUk9GXCIsMjI5OlwiQllcIiwyMzA6XCJTV0lUQ0hcIiwyMzI6XCJFTFNFXCIsMjM0OlwiTEVBRElOR19XSEVOXCIsMjM2OlwiSUZcIiwyMzc6XCJFTElGXCIsMjM4OlwiUE9TVF9JRlwiLDIzOTpcIj9cIiwyNDA6XCJVTkFSWVwiLDI0MTpcIlNRUlRcIiwyNDI6XCItXCIsMjQzOlwiK1wiLDI0NDpcIi0tXCIsMjQ1OlwiKytcIiwyNDY6XCJNQVRIXCIsMjQ3OlwiU0hJRlRcIiwyNDg6XCJSRUxBVElPTlwiLDI0OTpcIkNPTVBPVU5EX0FTU0lHTlwifSxcbnByb2R1Y3Rpb25zXzogWzAsWzMsMF0sWzMsMV0sWzMsMl0sWzQsMV0sWzQsMV0sWzQsM10sWzQsMl0sWzksMV0sWzUsMl0sWzUsM10sWzUsNF0sWzgsMV0sWzgsMV0sWzgsM10sWzgsM10sWzgsMV0sWzgsMV0sWzE2LDFdLFsxNiwxXSxbMTYsMV0sWzE2LDFdLFsxNiw0XSxbMTYsMV0sWzE2LDRdLFsxNiwxXSxbMTYsMV0sWzI1LDRdLFsyNSw0XSxbMjUsMl0sWzI5LDFdLFsyNywxXSxbMjcsM10sWzMxLDFdLFsxMywxXSxbMTMsMV0sWzEzLDFdLFsxMywxXSxbMTMsMV0sWzEzLDFdLFsxMywxXSxbMTMsMV0sWzEzLDFdLFsxMywxXSxbMTMsMV0sWzEzLDFdLFsxMywxXSxbMTMsMV0sWzEzLDFdLFsxMywxXSxbNTAsMV0sWzUyLDFdLFs1MiwxXSxbNTUsMV0sWzU3LDFdLFs1OSwxXSxbNjEsMV0sWzYzLDFdLFs2MywxXSxbNjMsMV0sWzYzLDFdLFs2NSwxXSxbNjUsMl0sWzY1LDJdLFs2NSwyXSxbNjgsMl0sWzY4LDNdLFs3MiwxXSxbNzIsMV0sWzcyLDFdLFs3MiwxXSxbNzIsMV0sWzcyLDFdLFs3MiwxXSxbNzIsMV0sWzE3LDJdLFsxNywyXSxbMTcsMV0sWzgyLDFdLFs4MiwyXSxbODIsMl0sWzgyLDJdLFs4MiwyXSxbODIsNV0sWzgyLDVdLFs4MiwyXSxbODIsMl0sWzgyLDJdLFs4MiwyXSxbODIsNF0sWzgyLDZdLFs4NCwxXSxbMTAxLDJdLFs5OSwxXSxbOTksMV0sWzk5LDNdLFs0OCw0XSxbNDgsNV0sWzQ4LDVdLFsxMDgsMV0sWzEwOCwxXSxbMTA4LDFdLFsxMDgsMF0sWzEwNCwxXSxbMTA0LDNdLFsxMDQsNF0sWzEwNCwzXSxbMTA0LDVdLFsxMDQsNV0sWzEwNCwzXSxbMTA0LDJdLFsxMDQsNV0sWzEwNSwwXSxbMTA1LDFdLFsxMDUsM10sWzEwNSw0XSxbMTE0LDFdLFsxMTQsM10sWzExOCwxXSxbMTA3LDNdLFsxMDcsM10sWzEyMCwxXSxbMTIwLDNdLFs0NywxXSxbNDcsMl0sWzQ3LDJdLFsxMjEsMl0sWzEyMSwzXSxbMTIxLDRdLFsxMjEsNV0sWzEyNywwXSxbMTI3LDFdLFsxMjUsMV0sWzEyNSwxXSxbMTI5LDFdLFsxMjksMl0sWzM4LDNdLFszOCw1XSxbMTMzLDFdLFsxMzMsM10sWzEzMyw1XSxbMTMzLDFdLFsxMzQsMV0sWzEzNCwxXSxbMTM0LDFdLFsxMzQsMV0sWzEzNCwxXSxbMTM0LDNdLFsxNSwxXSxbMTUsMV0sWzM2LDFdLFszNiwxXSxbMzYsMV0sWzE0MiwyXSxbMTQxLDJdLFsxNDEsNV0sWzE0MSw2XSxbNDksM10sWzQ5LDVdLFs0OSwyXSxbMTQ4LDFdLFsxNDgsMV0sWzE0OSwxXSxbMTQ5LDNdLFsxNTMsNF0sWzE0MCwxXSxbMTQwLDJdLFsxNDAsMl0sWzE1NSw4XSxbMTU1LDVdLFsxNTUsNl0sWzE1NSwzXSxbMTYwLDFdLFsxNjAsMV0sWzE2MSwxXSxbMTYxLDFdLFsxNjEsM10sWzE2MiwyXSxbMTYyLDJdLFsxNjIsMV0sWzE1OSwxXSxbMTU5LDFdLFsxNTksMV0sWzE1OSwxXSxbMTE1LDBdLFsxMTUsMV0sWzE0NiwwXSxbMTQ2LDFdLFsxNDYsM10sWzE2NywxXSxbMTY3LDFdLFsxNjcsMV0sWzE2NywyXSxbMTY3LDJdLFsxNjcsMl0sWzE2NywzXSxbMTY5LDFdLFsxMiwyXSxbMTczLDNdLFsxNzMsMl0sWzE3MywyXSxbMTczLDNdLFsxNzMsMl0sWzMzLDFdLFszMywxXSxbMTc0LDFdLFsxNzQsMV0sWzE3NCwxXSxbMTc2LDFdLFsxNzYsMV0sWzE3NiwxXSxbMTc2LDFdLFsxNzYsMV0sWzE3NiwxXSxbMTc2LDFdLFsxNzYsM10sWzE3NiwzXSxbMTc2LDNdLFsxNzYsM10sWzE3NiwzXSxbMTc2LDNdLFsxNzYsM10sWzE3NiwzXSxbMTc2LDRdLFsxNzksMV0sWzE3OSwxXSxbMTc4LDFdLFsxMzEsMV0sWzEzMSwxXSxbMTMxLDFdLFszNCwyXSxbMzUsMV0sWzM1LDFdLFszNSwxXSxbMzUsMV0sWzM1LDFdLFszNSwxXSxbMzUsMV0sWzM1LDFdLFszNSwxXSxbMzUsMV0sWzE4MiwxXSxbMTgyLDFdLFsxNTAsNF0sWzE5MSwwXSxbMTkxLDFdLFsxOTEsM10sWzE5MSw0XSxbMTkxLDZdLFs0NSwxXSxbNDUsMl0sWzQ1LDJdLFs0NSwyXSxbNDUsMl0sWzQ1LDNdLFsxOTIsMl0sWzE5MiwzXSxbMTkyLDRdLFsxOTIsNV0sWzQ2LDJdLFs0NiwzXSxbMTg5LDNdLFsxODksMl0sWzE5NSwwXSxbMTk1LDFdLFs4MSwyXSxbODEsNF0sWzE2NiwxXSxbMTA5LDFdLFsxNjgsMl0sWzE2OCw0XSxbMTk5LDFdLFsxOTksMV0sWzE4Nyw1XSxbMTkwLDNdLFsxOTAsMl0sWzE5MCwyXSxbMTE5LDFdLFsxMTksM10sWzExOSw0XSxbMTE5LDRdLFsxMTksNl0sWzEzMiwyXSxbMTMyLDFdLFsyMDIsMV0sWzIwMiwxXSxbMjAyLDFdLFsyMDIsMV0sWzIwMywxXSxbMjAzLDNdLFs0MSwyXSxbNDEsM10sWzQxLDNdLFs0MSw0XSxbMjA2LDJdLFsyMDUsM10sWzE4LDJdLFsxODYsM10sWzE4Niw1XSxbMjExLDJdLFsyMTEsNF0sWzIxMSwyXSxbMjExLDRdLFs0MiwyXSxbNDIsMl0sWzQyLDJdLFs0MiwxXSxbMjE1LDJdLFsyMTUsMl0sWzQzLDJdLFs0MywyXSxbNDMsMl0sWzIxOCwxXSxbMjE4LDFdLFsyMjEsMl0sWzIxNywyXSxbMjE3LDJdLFsyMjIsMl0sWzIyMiwzXSxbMjI2LDFdLFsyMjYsMV0sWzIyNiwxXSxbMjI0LDFdLFsyMjQsM10sWzIyMywyXSxbMjIzLDJdLFsyMjMsNF0sWzIyMyw0XSxbMjIzLDRdLFsyMjMsNl0sWzIyMyw2XSxbNDQsNV0sWzQ0LDddLFs0NCw0XSxbNDQsNl0sWzIzMSwxXSxbMjMxLDJdLFsyMzMsM10sWzIzMyw0XSxbMjM1LDNdLFsyMzUsNV0sWzIzNSw0XSxbMjM1LDNdLFszOSwxXSxbMzksM10sWzM5LDNdLFs0MCw1XSxbMzcsMl0sWzM3LDJdLFszNywyXSxbMzcsMl0sWzM3LDJdLFszNywyXSxbMzcsMl0sWzM3LDJdLFszNywzXSxbMzcsM10sWzM3LDNdLFszNywzXSxbMzcsM10sWzM3LDNdLFszNywzXSxbMzcsM10sWzM3LDVdXSxcbnBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uIHBlcmZvcm1BY3Rpb24oc2VsZiwgeXl0ZXh0LCB5eSwgeXlzdGF0ZSAvKiBhY3Rpb25bMV0gKi8sICQkIC8qIHZzdGFjayAqLykge1xuLyogc2VsZiA9PSB5eXZhbCAqL1xuXG52YXIgJDAgPSAkJC5sZW5ndGggLSAxO1xuc3dpdGNoICh5eXN0YXRlKSB7XG5jYXNlIDE6XG5yZXR1cm4gc2VsZi4kID0gbmV3IHl5LlJvb3QoW10pO1xuYnJlYWs7XG5jYXNlIDI6XG5yZXR1cm4gc2VsZi4kID0gbmV3IHl5LlJvb3QoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAzOlxucmV0dXJuIHNlbGYuJCA9ICQkWyQwLTFdO1xuYnJlYWs7XG5jYXNlIDQ6XG5zZWxmLiQgPSBuZXcgeXkuQmxvY2soW10pO1xuYnJlYWs7XG5jYXNlIDU6XG5zZWxmLiQgPSBuZXcgeXkuQmxvY2soWyQkWyQwXV0pO1xuYnJlYWs7XG5jYXNlIDY6XG5zZWxmLiQgPSAkJFskMC0yXS5icmVhaygkJFskMC0xXSkuYWRkKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgNzpcbnNlbGYuJCA9ICQkWyQwLTFdLmJyZWFrKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgODpcbnNlbGYuJCA9IG5ldyB5eS5UZXJtaW5hdG9yKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgOTpcbnNlbGYuJCA9IG5ldyB5eS5CbG9jayhbXSkuaW5kZW50ZWQoJCRbJDAtMV0sJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAxMDogY2FzZSAxMTk6XG5zZWxmLiQgPSAkJFskMC0xXS5pbmRlbnRlZCgkJFskMC0yXSwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDExOlxuc2VsZi4kID0gJCRbJDAtMV0ucHJlYnJlYWsoJCRbJDAtMl0pLmluZGVudGVkKCQkWyQwLTNdLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMTI6IGNhc2UgMTM6IGNhc2UgMTY6IGNhc2UgMTc6IGNhc2UgMTg6IGNhc2UgMTk6IGNhc2UgMjY6IGNhc2UgMzA6IGNhc2UgMzM6IGNhc2UgMzQ6IGNhc2UgMzU6IGNhc2UgMzY6IGNhc2UgMzc6IGNhc2UgMzg6IGNhc2UgMzk6IGNhc2UgNDA6IGNhc2UgNDE6IGNhc2UgNDI6IGNhc2UgNDM6IGNhc2UgNDQ6IGNhc2UgNDU6IGNhc2UgNDY6IGNhc2UgNDc6IGNhc2UgNDg6IGNhc2UgNDk6IGNhc2UgNTk6IGNhc2UgNjA6IGNhc2UgNjc6IGNhc2UgOTM6IGNhc2UgOTQ6IGNhc2UgOTk6IGNhc2UgMTE4OiBjYXNlIDEyMzogY2FzZSAxMzA6IGNhc2UgMTQxOiBjYXNlIDE0MjogY2FzZSAxNDM6IGNhc2UgMTQ0OiBjYXNlIDE0NTogY2FzZSAxNDY6IGNhc2UgMTUwOiBjYXNlIDE1MTogY2FzZSAxNTI6IGNhc2UgMTYwOiBjYXNlIDE2MTogY2FzZSAxNjI6IGNhc2UgMTY1OiBjYXNlIDE3NDogY2FzZSAxNzU6IGNhc2UgMTc3OiBjYXNlIDE4MDogY2FzZSAxODE6IGNhc2UgMTgyOiBjYXNlIDE4MzogY2FzZSAxODQ6IGNhc2UgMTg1OiBjYXNlIDE5NjogY2FzZSAyMDM6IGNhc2UgMjA0OiBjYXNlIDIwNTogY2FzZSAyMDY6IGNhc2UgMjA3OiBjYXNlIDIwODogY2FzZSAyMTA6IGNhc2UgMjExOiBjYXNlIDIxMjogY2FzZSAyMTM6IGNhc2UgMjI3OiBjYXNlIDIyODogY2FzZSAyMjk6IGNhc2UgMjMxOiBjYXNlIDIzMjogY2FzZSAyMzM6IGNhc2UgMjM0OiBjYXNlIDIzNTogY2FzZSAyMzc6IGNhc2UgMjM4OiBjYXNlIDIzOTogY2FzZSAyNDA6IGNhc2UgMjQ5OiBjYXNlIDI4MzogY2FzZSAyODQ6IGNhc2UgMjg1OiBjYXNlIDI4NjogY2FzZSAyODc6IGNhc2UgMjg4OiBjYXNlIDMwNjogY2FzZSAzMTI6IGNhc2UgMzEzOiBjYXNlIDMxOTogY2FzZSAzMzU6IGNhc2UgMzQzOlxuc2VsZi4kID0gJCRbJDBdO1xuYnJlYWs7XG5jYXNlIDE0OiBjYXNlIDE1Olxuc2VsZi4kID0gJCRbJDAtMl0uYWRkRXhwcmVzc2lvbigkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDIwOiBjYXNlIDY4Olxuc2VsZi4kID0gbmV3IHl5LkxpdGVyYWwoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyMTpcbnNlbGYuJCA9IG5ldyB5eS5CcmVha1N0YXRlbWVudCgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDIyOlxuc2VsZi4kID0gbmV3IHl5LkJyZWFrU3RhdGVtZW50KCQkWyQwLTNdLCQkWyQwLTFdKTtcbmJyZWFrO1xuY2FzZSAyMzpcbnNlbGYuJCA9IG5ldyB5eS5Db250aW51ZVN0YXRlbWVudCgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDI0Olxuc2VsZi4kID0gbmV3IHl5LkNvbnRpbnVlU3RhdGVtZW50KCQkWyQwLTNdLCQkWyQwLTFdKTtcbmJyZWFrO1xuY2FzZSAyNTpcbnNlbGYuJCA9IG5ldyB5eS5EZWJ1Z2dlclN0YXRlbWVudCgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDI3Olxuc2VsZi4kID0gbmV3IHl5LkltcG9ydFN0YXRlbWVudCgkJFskMC0yXSwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDI4Olxuc2VsZi4kID0gbmV3IHl5LkltcG9ydFN0YXRlbWVudChudWxsLCQkWyQwLTJdLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjk6XG5zZWxmLiQgPSBuZXcgeXkuSW1wb3J0U3RhdGVtZW50KG51bGwsJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAzMTogY2FzZSAxMTM6IGNhc2UgMTg3OiBjYXNlIDMyMjpcbnNlbGYuJCA9IFskJFskMF1dO1xuYnJlYWs7XG5jYXNlIDMyOiBjYXNlIDExNDogY2FzZSAxODg6XG5zZWxmLiQgPSAkJFskMC0yXS5jb25jYXQoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSA1MDpcbnNlbGYuJCA9IG5ldyB5eS5JZGVudGlmaWVyKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgNTE6IGNhc2UgNTI6XG5zZWxmLiQgPSBuZXcgeXkuSXZhcigkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDUzOlxuc2VsZi4kID0gbmV3IHl5Lkd2YXIoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSA1NDpcbnNlbGYuJCA9IG5ldyB5eS5Db25zdCgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDU1Olxuc2VsZi4kID0gbmV3IHl5LkFyZ3ZhcigkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDU2Olxuc2VsZi4kID0gbmV3IHl5LlN5bWJvbCgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDU3Olxuc2VsZi4kID0gbmV3IHl5Lk51bSgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDU4Olxuc2VsZi4kID0gbmV3IHl5LlN0cigkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDYxOlxuc2VsZi4kID0gbmV3IHl5LkludGVycG9sYXRlZFN0cmluZyhbXSx7b3BlbjogJCRbJDBdfSk7XG5icmVhaztcbmNhc2UgNjI6XG5zZWxmLiQgPSAkJFskMC0xXS5hZGQoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSA2MzpcbnNlbGYuJCA9ICQkWyQwXSA/ICgkJFskMC0xXS5hZGQoJCRbJDBdKSkgOiAoJCRbJDAtMV0pO1xuYnJlYWs7XG5jYXNlIDY0Olxuc2VsZi4kID0gJCRbJDAtMV0ub3B0aW9uKCdjbG9zZScsJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSA2NTpcbnNlbGYuJCA9IG51bGw7XG5icmVhaztcbmNhc2UgNjY6IGNhc2UgOTI6IGNhc2UgOTU6IGNhc2UgMTIwOiBjYXNlIDE0NzogY2FzZSAxNjM6IGNhc2UgMTc2OiBjYXNlIDI4MjpcbnNlbGYuJCA9ICQkWyQwLTFdO1xuYnJlYWs7XG5jYXNlIDY5Olxuc2VsZi4kID0gbmV3IHl5LlJlZ0V4cCgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDcwOlxuc2VsZi4kID0gbmV3IHl5LkJvb2woJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSA3MTpcbnNlbGYuJCA9IHl5LlRSVUU7XG5icmVhaztcbmNhc2UgNzI6XG5zZWxmLiQgPSB5eS5GQUxTRTtcbmJyZWFrO1xuY2FzZSA3MzpcbnNlbGYuJCA9IHl5Lk5JTDtcbmJyZWFrO1xuY2FzZSA3NDpcbnNlbGYuJCA9IHl5LlVOREVGSU5FRDtcbmJyZWFrO1xuY2FzZSA3NTogY2FzZSA3NjpcbnNlbGYuJCA9IG5ldyB5eS5SZXR1cm4oJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSA3NzpcbnNlbGYuJCA9IG5ldyB5eS5SZXR1cm4oKTtcbmJyZWFrO1xuY2FzZSA3ODpcbnNlbGYuJCA9IG5ldyB5eS5TZWxlY3RvcihbXSx7dHlwZTogJCRbJDBdfSk7XG5icmVhaztcbmNhc2UgNzk6XG5zZWxmLiQgPSAkJFskMC0xXS5hZGQobmV3IHl5LlNlbGVjdG9yVHlwZSgkJFskMF0pLCd0YWcnKTtcbmJyZWFrO1xuY2FzZSA4MDpcbnNlbGYuJCA9ICQkWyQwLTFdLmFkZChuZXcgeXkuU2VsZWN0b3JOYW1lc3BhY2UoJCRbJDBdKSwnbnMnKTtcbmJyZWFrO1xuY2FzZSA4MTpcbnNlbGYuJCA9ICQkWyQwLTFdLmFkZChuZXcgeXkuU2VsZWN0b3JJZCgkJFskMF0pLCdpZCcpO1xuYnJlYWs7XG5jYXNlIDgyOlxuc2VsZi4kID0gJCRbJDAtMV0uYWRkKG5ldyB5eS5TZWxlY3RvckNsYXNzKCQkWyQwXSksJ2NsYXNzJyk7XG5icmVhaztcbmNhc2UgODM6XG5zZWxmLiQgPSAkJFskMC00XS5hZGQobmV3IHl5LlNlbGVjdG9yQ2xhc3MoJCRbJDAtMV0pLCdjbGFzcycpO1xuYnJlYWs7XG5jYXNlIDg0Olxuc2VsZi4kID0gJCRbJDAtNF0uYWRkKG5ldyB5eS5TZWxlY3RvcklkKCQkWyQwLTFdKSwnaWQnKTtcbmJyZWFrO1xuY2FzZSA4NTpcbnNlbGYuJCA9ICQkWyQwLTFdLmFkZChuZXcgeXkuU2VsZWN0b3JDb21iaW5hdG9yKCQkWyQwXSksJ3NlcCcpO1xuYnJlYWs7XG5jYXNlIDg2Olxuc2VsZi4kID0gJCRbJDAtMV0uYWRkKG5ldyB5eS5TZWxlY3RvclBzZXVkb0NsYXNzKCQkWyQwXSksJ3BzZXVkb2NsYXNzJyk7XG5icmVhaztcbmNhc2UgODc6XG5zZWxmLiQgPSAkJFskMC0xXS5ncm91cCgpO1xuYnJlYWs7XG5jYXNlIDg4Olxuc2VsZi4kID0gJCRbJDAtMV0uYWRkKG5ldyB5eS5TZWxlY3RvclVuaXZlcnNhbCgkJFskMF0pLCd1bml2ZXJzYWwnKTtcbmJyZWFrO1xuY2FzZSA4OTpcbnNlbGYuJCA9ICQkWyQwLTNdLmFkZChuZXcgeXkuU2VsZWN0b3JBdHRyaWJ1dGUoJCRbJDAtMV0pLCdhdHRyJyk7XG5icmVhaztcbmNhc2UgOTA6XG5zZWxmLiQgPSAkJFskMC01XS5hZGQobmV3IHl5LlNlbGVjdG9yQXR0cmlidXRlKCQkWyQwLTNdLCQkWyQwLTJdLCQkWyQwLTFdKSwnYXR0cicpO1xuYnJlYWs7XG5jYXNlIDkxOiBjYXNlIDEwMDogY2FzZSAxMDE6IGNhc2UgMTMyOiBjYXNlIDEzMzpcbnNlbGYuJCA9IG5ldyB5eS5UYWdUeXBlSWRlbnRpZmllcigkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDk2Olxuc2VsZi4kID0gJCRbJDAtMl0uc2V0KHthdHRyaWJ1dGVzOiAkJFskMC0xXSxvcGVuOiAkJFskMC0zXSxjbG9zZTogJCRbJDBdfSk7XG5icmVhaztcbmNhc2UgOTc6XG5zZWxmLiQgPSAkJFskMC0zXS5zZXQoe2F0dHJpYnV0ZXM6ICQkWyQwLTJdLGJvZHk6ICQkWyQwXSxvcGVuOiAkJFskMC00XSxjbG9zZTogJCRbJDAtMV19KTtcbmJyZWFrO1xuY2FzZSA5ODpcbnNlbGYuJCA9IG5ldyB5eS5UYWdXcmFwcGVyKCQkWyQwLTJdLCQkWyQwLTRdLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMTAyOlxuc2VsZi4kID0gbmV3IHl5LlRhZ1R5cGVJZGVudGlmaWVyKCdkaXYnKTtcbmJyZWFrO1xuY2FzZSAxMDM6XG5zZWxmLiQgPSBuZXcgeXkuVGFnKHt0eXBlOiAkJFskMF19KTtcbmJyZWFrO1xuY2FzZSAxMDQ6XG5zZWxmLiQgPSAkJFskMC0yXS5hZGRTeW1ib2woJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAxMDU6XG5zZWxmLiQgPSAkJFskMC0zXS5hZGRJbmRleCgkJFskMC0xXSk7XG5icmVhaztcbmNhc2UgMTA2Olxuc2VsZi4kID0gJCRbJDAtMl0uYWRkQ2xhc3MoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAxMDc6XG5zZWxmLiQgPSAkJFskMC00XS5hZGRDbGFzcygkJFskMC0xXSk7XG5icmVhaztcbmNhc2UgMTA4Olxuc2VsZi4kID0gJCRbJDAtNF0uc2V0KHtrZXk6ICQkWyQwLTFdfSk7XG5icmVhaztcbmNhc2UgMTA5Olxuc2VsZi4kID0gJCRbJDAtMl0uc2V0KHtpZDogJCRbJDBdfSk7XG5icmVhaztcbmNhc2UgMTEwOlxuc2VsZi4kID0gJCRbJDAtMV0uc2V0KHtpdmFyOiAkJFskMF19KTtcbmJyZWFrO1xuY2FzZSAxMTE6XG5zZWxmLiQgPSAkJFskMC00XS5zZXQoe2lkOiAkJFskMC0xXX0pO1xuYnJlYWs7XG5jYXNlIDExMjogY2FzZSAxNzk6IGNhc2UgMTg2Olxuc2VsZi4kID0gW107XG5icmVhaztcbmNhc2UgMTE1Olxuc2VsZi4kID0gJCRbJDAtM10uY29uY2F0KCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMTE2Olxuc2VsZi4kID0gbmV3IHl5LlRhZ0F0dHIoJCRbJDBdLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMTE3Olxuc2VsZi4kID0gbmV3IHl5LlRhZ0F0dHIoJCRbJDAtMl0sJCRbJDBdLCQkWyQwLTFdKTtcbmJyZWFrO1xuY2FzZSAxMjE6XG5zZWxmLiQgPSBuZXcgeXkuVGFnRGVzYygkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDEyMjpcbnNlbGYuJCA9ICQkWyQwLTJdLmNsYXNzZXMoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAxMjQ6XG5zZWxmLiQgPSAkJFskMF0uc2V0KHtleHRlbnNpb246IHRydWV9KTtcbmJyZWFrO1xuY2FzZSAxMjU6XG5zZWxmLiQgPSAkJFskMF0uc2V0KHtsb2NhbDogdHJ1ZX0pO1xuYnJlYWs7XG5jYXNlIDEyNjpcbnNlbGYuJCA9IG5ldyB5eS5UYWdEZWNsYXJhdGlvbigkJFskMF0pLnNldCh7a2V5d29yZDogJCRbJDAtMV19KTtcbmJyZWFrO1xuY2FzZSAxMjc6XG5zZWxmLiQgPSBuZXcgeXkuVGFnRGVjbGFyYXRpb24oJCRbJDAtMV0sbnVsbCwkJFskMF0pLnNldCh7a2V5d29yZDogJCRbJDAtMl19KTtcbmJyZWFrO1xuY2FzZSAxMjg6XG5zZWxmLiQgPSBuZXcgeXkuVGFnRGVjbGFyYXRpb24oJCRbJDAtMl0sJCRbJDBdKS5zZXQoe2tleXdvcmQ6ICQkWyQwLTNdfSk7XG5icmVhaztcbmNhc2UgMTI5Olxuc2VsZi4kID0gbmV3IHl5LlRhZ0RlY2xhcmF0aW9uKCQkWyQwLTNdLCQkWyQwLTFdLCQkWyQwXSkuc2V0KHtrZXl3b3JkOiAkJFskMC00XX0pO1xuYnJlYWs7XG5jYXNlIDEzMTpcbnNlbGYuJCA9IFsneXkuZXh0ZW5kJ107XG5icmVhaztcbmNhc2UgMTM0OiBjYXNlIDEzNTpcbnNlbGYuJCA9IG5ldyB5eS5UYWdJZCgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDEzNjpcbnNlbGYuJCA9IG5ldyB5eS5Bc3NpZ24oJCRbJDAtMV0sJCRbJDAtMl0sJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAxMzc6XG5zZWxmLiQgPSBuZXcgeXkuQXNzaWduKCQkWyQwLTNdLCQkWyQwLTRdLCQkWyQwLTFdLmluZGVudGVkKCQkWyQwLTJdLCQkWyQwXSkpO1xuYnJlYWs7XG5jYXNlIDEzODpcbnNlbGYuJCA9IG5ldyB5eS5PYmpBdHRyKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMTM5Olxuc2VsZi4kID0gbmV3IHl5Lk9iakF0dHIoJCRbJDAtMl0sJCRbJDBdLCdvYmplY3QnKTtcbmJyZWFrO1xuY2FzZSAxNDA6XG5zZWxmLiQgPSBuZXcgeXkuT2JqQXR0cigkJFskMC00XSwkJFskMC0xXS5pbmRlbnRlZCgkJFskMC0yXSwkJFskMF0pLCdvYmplY3QnKTtcbmJyZWFrO1xuY2FzZSAxNDg6XG5zZWxmLiQgPSBuZXcgeXkuQ29tbWVudCgkJFskMF0sdHJ1ZSk7XG5icmVhaztcbmNhc2UgMTQ5Olxuc2VsZi4kID0gbmV3IHl5LkNvbW1lbnQoJCRbJDBdLGZhbHNlKTtcbmJyZWFrO1xuY2FzZSAxNTM6XG5zZWxmLiQgPSBuZXcgeXkuQmVnaW4oJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAxNTQ6XG5zZWxmLiQgPSBuZXcgeXkuTGFtYmRhKFtdLCQkWyQwXSxudWxsLG51bGwse2JvdW5kOiB0cnVlfSk7XG5icmVhaztcbmNhc2UgMTU1Olxuc2VsZi4kID0gbmV3IHl5LkxhbWJkYSgkJFskMC0yXSwkJFskMF0sbnVsbCxudWxsLHtib3VuZDogdHJ1ZX0pO1xuYnJlYWs7XG5jYXNlIDE1NjpcbnNlbGYuJCA9IG5ldyB5eS5MYW1iZGEoJCRbJDAtM10sJCRbJDAtMV0sbnVsbCxudWxsLHtib3VuZDogdHJ1ZX0pO1xuYnJlYWs7XG5jYXNlIDE1NzpcbnNlbGYuJCA9IG5ldyB5eS5Qcm9wZXJ0eURlY2xhcmF0aW9uKCQkWyQwLTFdLCQkWyQwXSwkJFskMC0yXSk7XG5icmVhaztcbmNhc2UgMTU4Olxuc2VsZi4kID0gbmV3IHl5LlByb3BlcnR5RGVjbGFyYXRpb24oJCRbJDAtM10sJCRbJDAtMV0sJCRbJDAtNF0pO1xuYnJlYWs7XG5jYXNlIDE1OTpcbnNlbGYuJCA9IG5ldyB5eS5Qcm9wZXJ0eURlY2xhcmF0aW9uKCQkWyQwXSxudWxsLCQkWyQwLTFdKTtcbmJyZWFrO1xuY2FzZSAxNjQ6XG5zZWxmLiQgPSAkJFskMC0zXTtcbmJyZWFrO1xuY2FzZSAxNjY6IGNhc2UgMjUyOlxuc2VsZi4kID0gJCRbJDBdLnNldCh7Z2xvYmFsOiAkJFskMC0xXX0pO1xuYnJlYWs7XG5jYXNlIDE2NzogY2FzZSAyMDI6IGNhc2UgMjUzOlxuc2VsZi4kID0gJCRbJDBdLnNldCh7ZXhwb3J0OiAkJFskMC0xXX0pO1xuYnJlYWs7XG5jYXNlIDE2ODpcbnNlbGYuJCA9IG5ldyB5eS5NZXRob2REZWNsYXJhdGlvbigkJFskMC0yXSwkJFskMF0sJCRbJDAtNF0sJCRbJDAtNl0sJCRbJDAtNV0pLnNldCh7ZGVmOiAkJFskMC03XX0pO1xuYnJlYWs7XG5jYXNlIDE2OTpcbnNlbGYuJCA9IG5ldyB5eS5NZXRob2REZWNsYXJhdGlvbihbXSwkJFskMF0sJCRbJDAtMV0sJCRbJDAtM10sJCRbJDAtMl0pLnNldCh7ZGVmOiAkJFskMC00XX0pO1xuYnJlYWs7XG5jYXNlIDE3MDpcbnNlbGYuJCA9IG5ldyB5eS5NZXRob2REZWNsYXJhdGlvbigkJFskMC0yXSwkJFskMF0sJCRbJDAtNF0sbnVsbCkuc2V0KHtkZWY6ICQkWyQwLTVdfSk7XG5icmVhaztcbmNhc2UgMTcxOlxuc2VsZi4kID0gbmV3IHl5Lk1ldGhvZERlY2xhcmF0aW9uKFtdLCQkWyQwXSwkJFskMC0xXSxudWxsKS5zZXQoe2RlZjogJCRbJDAtMl19KTtcbmJyZWFrO1xuY2FzZSAxNzI6XG5zZWxmLiQgPSB7c3RhdGljOiB0cnVlfTtcbmJyZWFrO1xuY2FzZSAxNzM6XG5zZWxmLiQgPSB7fTtcbmJyZWFrO1xuY2FzZSAxNzg6XG5zZWxmLiQgPSAkJFskMF0uYm9keSgpO1xuYnJlYWs7XG5jYXNlIDE4OTpcbnNlbGYuJCA9IG5ldyB5eS5OYW1lZFBhcmFtcygkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDE5MDpcbnNlbGYuJCA9IG5ldyB5eS5BcnJheVBhcmFtcygkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDE5MTpcbnNlbGYuJCA9IG5ldyB5eS5SZXF1aXJlZFBhcmFtKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMTkyOlxuc2VsZi4kID0gbmV3IHl5LlNwbGF0UGFyYW0oJCRbJDBdLG51bGwsJCRbJDAtMV0pO1xuYnJlYWs7XG5jYXNlIDE5MzogY2FzZSAxOTQ6XG5zZWxmLiQgPSBuZXcgeXkuQmxvY2tQYXJhbSgkJFskMF0sbnVsbCwkJFskMC0xXSk7XG5icmVhaztcbmNhc2UgMTk1Olxuc2VsZi4kID0gbmV3IHl5Lk9wdGlvbmFsUGFyYW0oJCRbJDAtMl0sJCRbJDBdLCQkWyQwLTFdKTtcbmJyZWFrO1xuY2FzZSAxOTc6XG5zZWxmLiQgPSB5eS5TUExBVCgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDE5ODogY2FzZSAyMDE6XG5zZWxmLiQgPSB5eS5TUExBVChuZXcgeXkuVmFyUmVmZXJlbmNlKCQkWyQwXSwkJFskMC0yXSksJCRbJDAtMV0pO1xuYnJlYWs7XG5jYXNlIDE5OTogY2FzZSAyMDA6XG5zZWxmLiQgPSBuZXcgeXkuVmFyUmVmZXJlbmNlKCQkWyQwXSwkJFskMC0xXSk7XG5icmVhaztcbmNhc2UgMjA5Olxuc2VsZi4kID0gbmV3IHl5Lkl2YXJBY2Nlc3MoJy4nLG51bGwsJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyMTQ6XG5zZWxmLiQgPSBuZXcgeXkuVmFyT3JBY2Nlc3MoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyMTU6XG5zZWxmLiQgPSBuZXcgeXkuTmV3KCQkWyQwLTJdKTtcbmJyZWFrO1xuY2FzZSAyMTY6XG5zZWxmLiQgPSBuZXcgeXkuU3VwZXJBY2Nlc3MoJy4nLCQkWyQwLTJdLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjE3Olxuc2VsZi4kID0gbmV3IHl5LlByb3BlcnR5QWNjZXNzKCQkWyQwLTFdLCQkWyQwLTJdLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjE4OiBjYXNlIDIxOTogY2FzZSAyMjA6IGNhc2UgMjIyOlxuc2VsZi4kID0gbmV3IHl5LkFjY2VzcygkJFskMC0xXSwkJFskMC0yXSwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDIyMTpcbnNlbGYuJCA9IG5ldyB5eS5BY2Nlc3MoJy4nLCQkWyQwLTJdLG5ldyB5eS5JZGVudGlmaWVyKCQkWyQwXS52YWx1ZSgpKSk7XG5icmVhaztcbmNhc2UgMjIzOlxuc2VsZi4kID0gbmV3IHl5LkluZGV4QWNjZXNzKCcuJywkJFskMC0zXSwkJFskMC0xXSk7XG5icmVhaztcbmNhc2UgMjI2Olxuc2VsZi4kID0geXkuU1VQRVI7XG5icmVhaztcbmNhc2UgMjMwOlxuc2VsZi4kID0gbmV3IHl5LkF3YWl0KCQkWyQwXSkuc2V0KHtrZXl3b3JkOiAkJFskMC0xXX0pO1xuYnJlYWs7XG5jYXNlIDIzNjpcbnNlbGYuJCA9IHl5LkFSR1VNRU5UUztcbmJyZWFrO1xuY2FzZSAyNDE6XG5zZWxmLiQgPSBuZXcgeXkuSW5kZXgoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyNDI6XG5zZWxmLiQgPSBuZXcgeXkuU2xpY2UoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyNDM6XG5zZWxmLiQgPSBuZXcgeXkuT2JqKCQkWyQwLTJdLCQkWyQwLTNdLmdlbmVyYXRlZCk7XG5icmVhaztcbmNhc2UgMjQ0Olxuc2VsZi4kID0gbmV3IHl5LkFzc2lnbkxpc3QoW10pO1xuYnJlYWs7XG5jYXNlIDI0NTpcbnNlbGYuJCA9IG5ldyB5eS5Bc3NpZ25MaXN0KFskJFskMF1dKTtcbmJyZWFrO1xuY2FzZSAyNDY6IGNhc2UgMjc4Olxuc2VsZi4kID0gJCRbJDAtMl0uYWRkKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjQ3OiBjYXNlIDI3OTpcbnNlbGYuJCA9ICQkWyQwLTNdLmFkZCgkJFskMC0xXSkuYWRkKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjQ4Olxuc2VsZi4kID0gJCRbJDAtNV0uY29uY2F0KCQkWyQwLTJdLmluZGVudGVkKCQkWyQwLTNdLCQkWyQwXSkpO1xuYnJlYWs7XG5jYXNlIDI1MDpcbnNlbGYuJCA9ICQkWyQwXS5zZXQoe2V4dGVuc2lvbjogJCRbJDAtMV19KTtcbmJyZWFrO1xuY2FzZSAyNTE6XG5zZWxmLiQgPSAkJFskMF0uc2V0KHtsb2NhbDogJCRbJDAtMV19KTtcbmJyZWFrO1xuY2FzZSAyNTQ6XG5zZWxmLiQgPSAkJFskMF0uc2V0KHtleHBvcnQ6ICQkWyQwLTJdLGxvY2FsOiAkJFskMC0xXX0pO1xuYnJlYWs7XG5jYXNlIDI1NTpcbnNlbGYuJCA9IG5ldyB5eS5DbGFzc0RlY2xhcmF0aW9uKCQkWyQwXSxudWxsLFtdKS5zZXQoe2tleXdvcmQ6ICQkWyQwLTFdfSk7XG5icmVhaztcbmNhc2UgMjU2Olxuc2VsZi4kID0gbmV3IHl5LkNsYXNzRGVjbGFyYXRpb24oJCRbJDAtMV0sbnVsbCwkJFskMF0pLnNldCh7a2V5d29yZDogJCRbJDAtMl19KTtcbmJyZWFrO1xuY2FzZSAyNTc6XG5zZWxmLiQgPSBuZXcgeXkuQ2xhc3NEZWNsYXJhdGlvbigkJFskMC0yXSwkJFskMF0sW10pLnNldCh7a2V5d29yZDogJCRbJDAtM119KTtcbmJyZWFrO1xuY2FzZSAyNTg6XG5zZWxmLiQgPSBuZXcgeXkuQ2xhc3NEZWNsYXJhdGlvbigkJFskMC0zXSwkJFskMC0xXSwkJFskMF0pLnNldCh7a2V5d29yZDogJCRbJDAtNF19KTtcbmJyZWFrO1xuY2FzZSAyNTk6XG5zZWxmLiQgPSBuZXcgeXkuTW9kdWxlKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjYwOlxuc2VsZi4kID0gbmV3IHl5Lk1vZHVsZSgkJFskMC0xXSxudWxsLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjYxOlxuc2VsZi4kID0gbmV3IHl5LkNhbGwoJCRbJDAtMl0sJCRbJDBdLCQkWyQwLTFdKTtcbmJyZWFrO1xuY2FzZSAyNjI6XG5zZWxmLiQgPSAkJFskMC0xXS5hZGRCbG9jaygkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDI2MzpcbnNlbGYuJCA9IGZhbHNlO1xuYnJlYWs7XG5jYXNlIDI2NDpcbnNlbGYuJCA9IHRydWU7XG5icmVhaztcbmNhc2UgMjY1Olxuc2VsZi4kID0gbmV3IHl5LkFyZ0xpc3QoW10pO1xuYnJlYWs7XG5jYXNlIDI2NjpcbnNlbGYuJCA9ICQkWyQwLTJdO1xuYnJlYWs7XG5jYXNlIDI2NzpcbnNlbGYuJCA9IG5ldyB5eS5UaGlzKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjY4Olxuc2VsZi4kID0gbmV3IHl5LlNlbGYoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyNjk6XG5zZWxmLiQgPSBuZXcgeXkuQXJyKG5ldyB5eS5BcmdMaXN0KFtdKSk7XG5icmVhaztcbmNhc2UgMjcwOlxuc2VsZi4kID0gbmV3IHl5LkFycigkJFskMC0yXSk7XG5icmVhaztcbmNhc2UgMjcxOlxuc2VsZi4kID0gJy4uJztcbmJyZWFrO1xuY2FzZSAyNzI6XG5zZWxmLiQgPSAnLi4uJztcbmJyZWFrO1xuY2FzZSAyNzM6XG5zZWxmLiQgPSB5eS5PUCgkJFskMC0yXSwkJFskMC0zXSwkJFskMC0xXSk7XG5icmVhaztcbmNhc2UgMjc0Olxuc2VsZi4kID0gbmV3IHl5LlJhbmdlKCQkWyQwLTJdLCQkWyQwXSwkJFskMC0xXSk7XG5icmVhaztcbmNhc2UgMjc1Olxuc2VsZi4kID0gbmV3IHl5LlJhbmdlKCQkWyQwLTFdLG51bGwsJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyNzY6XG5zZWxmLiQgPSBuZXcgeXkuUmFuZ2UobnVsbCwkJFskMF0sJCRbJDAtMV0pO1xuYnJlYWs7XG5jYXNlIDI3NzpcbnNlbGYuJCA9IG5ldyB5eS5BcmdMaXN0KFskJFskMF1dKTtcbmJyZWFrO1xuY2FzZSAyODA6XG5zZWxmLiQgPSAkJFskMC0yXS5pbmRlbnRlZCgkJFskMC0zXSwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDI4MTpcbnNlbGYuJCA9ICQkWyQwLTVdLmNvbmNhdCgkJFskMC0yXSk7XG5icmVhaztcbmNhc2UgMjg5Olxuc2VsZi4kID0gW10uY29uY2F0KCQkWyQwLTJdLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjkwOlxuc2VsZi4kID0gbmV3IHl5LlRyeSgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDI5MTpcbnNlbGYuJCA9IG5ldyB5eS5UcnkoJCRbJDAtMV0sJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyOTI6XG5zZWxmLiQgPSBuZXcgeXkuVHJ5KCQkWyQwLTFdLG51bGwsJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyOTM6XG5zZWxmLiQgPSBuZXcgeXkuVHJ5KCQkWyQwLTJdLCQkWyQwLTFdLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjk0Olxuc2VsZi4kID0gbmV3IHl5LkZpbmFsbHkoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyOTU6XG5zZWxmLiQgPSBuZXcgeXkuQ2F0Y2goJCRbJDBdLCQkWyQwLTFdKTtcbmJyZWFrO1xuY2FzZSAyOTY6XG5zZWxmLiQgPSBuZXcgeXkuVGhyb3coJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyOTc6XG5zZWxmLiQgPSBuZXcgeXkuUGFyZW5zKCQkWyQwLTFdLCQkWyQwLTJdLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjk4Olxuc2VsZi4kID0gbmV3IHl5LlBhcmVucygkJFskMC0yXSwkJFskMC00XSwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDI5OTpcbnNlbGYuJCA9IG5ldyB5eS5XaGlsZSgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDMwMDpcbnNlbGYuJCA9IG5ldyB5eS5XaGlsZSgkJFskMC0yXSx7Z3VhcmQ6ICQkWyQwXX0pO1xuYnJlYWs7XG5jYXNlIDMwMTpcbnNlbGYuJCA9IG5ldyB5eS5XaGlsZSgkJFskMF0se2ludmVydDogdHJ1ZX0pO1xuYnJlYWs7XG5jYXNlIDMwMjpcbnNlbGYuJCA9IG5ldyB5eS5XaGlsZSgkJFskMC0yXSx7aW52ZXJ0OiB0cnVlLGd1YXJkOiAkJFskMF19KTtcbmJyZWFrO1xuY2FzZSAzMDM6IGNhc2UgMzExOiBjYXNlIDMxNDpcbnNlbGYuJCA9ICQkWyQwLTFdLmFkZEJvZHkoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAzMDQ6IGNhc2UgMzA1Olxuc2VsZi4kID0gJCRbJDBdLmFkZEJvZHkoeXkuQmxvY2sud3JhcChbJCRbJDAtMV1dKSk7XG5icmVhaztcbmNhc2UgMzA3Olxuc2VsZi4kID0gbmV3IHl5LldoaWxlKG5ldyB5eS5MaXRlcmFsKCd0cnVlJykpLmFkZEJvZHkoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAzMDg6XG5zZWxmLiQgPSBuZXcgeXkuV2hpbGUobmV3IHl5LkxpdGVyYWwoJ3RydWUnKSkuYWRkQm9keSh5eS5CbG9jay53cmFwKFskJFskMF1dKSk7XG5icmVhaztcbmNhc2UgMzA5OiBjYXNlIDMxMDpcbnNlbGYuJCA9ICQkWyQwXS5hZGRCb2R5KFskJFskMC0xXV0pO1xuYnJlYWs7XG5jYXNlIDMxNTpcbnNlbGYuJCA9IHtzb3VyY2U6IG5ldyB5eS5WYWx1ZU5vZGUoJCRbJDBdKX07XG5icmVhaztcbmNhc2UgMzE2Olxuc2VsZi4kID0gJCRbJDBdLmNvbmZpZ3VyZSh7b3duOiAkJFskMC0xXS5vd24sbmFtZTogJCRbJDAtMV1bMF0saW5kZXg6ICQkWyQwLTFdWzFdLGtleXdvcmQ6ICQkWyQwLTFdLmtleXdvcmR9KTtcbmJyZWFrO1xuY2FzZSAzMTc6XG5zZWxmLiQgPSAoJCRbJDBdLmtleXdvcmQgPSAkJFskMC0xXSkgJiYgJCRbJDBdO1xuYnJlYWs7XG5jYXNlIDMxODpcbnNlbGYuJCA9ICgkJFskMF0ub3duID0gdHJ1ZSkgJiYgKCQkWyQwXS5rZXl3b3JkID0gJCRbJDAtMl0pICYmICQkWyQwXTtcbmJyZWFrO1xuY2FzZSAzMjA6IGNhc2UgMzIxOlxuc2VsZi4kID0gbmV3IHl5LlZhbHVlTm9kZSgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDMyMzpcbnNlbGYuJCA9IFskJFskMC0yXSwkJFskMF1dO1xuYnJlYWs7XG5jYXNlIDMyNDpcbnNlbGYuJCA9IG5ldyB5eS5Gb3JJbih7c291cmNlOiAkJFskMF19KTtcbmJyZWFrO1xuY2FzZSAzMjU6XG5zZWxmLiQgPSBuZXcgeXkuRm9yT2Yoe3NvdXJjZTogJCRbJDBdLG9iamVjdDogdHJ1ZX0pO1xuYnJlYWs7XG5jYXNlIDMyNjpcbnNlbGYuJCA9IG5ldyB5eS5Gb3JJbih7c291cmNlOiAkJFskMC0yXSxndWFyZDogJCRbJDBdfSk7XG5icmVhaztcbmNhc2UgMzI3Olxuc2VsZi4kID0gbmV3IHl5LkZvck9mKHtzb3VyY2U6ICQkWyQwLTJdLGd1YXJkOiAkJFskMF0sb2JqZWN0OiB0cnVlfSk7XG5icmVhaztcbmNhc2UgMzI4Olxuc2VsZi4kID0gbmV3IHl5LkZvckluKHtzb3VyY2U6ICQkWyQwLTJdLHN0ZXA6ICQkWyQwXX0pO1xuYnJlYWs7XG5jYXNlIDMyOTpcbnNlbGYuJCA9IG5ldyB5eS5Gb3JJbih7c291cmNlOiAkJFskMC00XSxndWFyZDogJCRbJDAtMl0sc3RlcDogJCRbJDBdfSk7XG5icmVhaztcbmNhc2UgMzMwOlxuc2VsZi4kID0gbmV3IHl5LkZvckluKHtzb3VyY2U6ICQkWyQwLTRdLHN0ZXA6ICQkWyQwLTJdLGd1YXJkOiAkJFskMF19KTtcbmJyZWFrO1xuY2FzZSAzMzE6XG5zZWxmLiQgPSBuZXcgeXkuU3dpdGNoKCQkWyQwLTNdLCQkWyQwLTFdKTtcbmJyZWFrO1xuY2FzZSAzMzI6XG5zZWxmLiQgPSBuZXcgeXkuU3dpdGNoKCQkWyQwLTVdLCQkWyQwLTNdLCQkWyQwLTFdKTtcbmJyZWFrO1xuY2FzZSAzMzM6XG5zZWxmLiQgPSBuZXcgeXkuU3dpdGNoKG51bGwsJCRbJDAtMV0pO1xuYnJlYWs7XG5jYXNlIDMzNDpcbnNlbGYuJCA9IG5ldyB5eS5Td2l0Y2gobnVsbCwkJFskMC0zXSwkJFskMC0xXSk7XG5icmVhaztcbmNhc2UgMzM2Olxuc2VsZi4kID0gJCRbJDAtMV0uY29uY2F0KCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMzM3Olxuc2VsZi4kID0gW25ldyB5eS5Td2l0Y2hDYXNlKCQkWyQwLTFdLCQkWyQwXSldO1xuYnJlYWs7XG5jYXNlIDMzODpcbnNlbGYuJCA9IFtuZXcgeXkuU3dpdGNoQ2FzZSgkJFskMC0yXSwkJFskMC0xXSldO1xuYnJlYWs7XG5jYXNlIDMzOTpcbnNlbGYuJCA9IG5ldyB5eS5JZigkJFskMC0xXSwkJFskMF0se3R5cGU6ICQkWyQwLTJdfSk7XG5icmVhaztcbmNhc2UgMzQwOlxuc2VsZi4kID0gJCRbJDAtNF0uYWRkRWxzZShuZXcgeXkuSWYoJCRbJDAtMV0sJCRbJDBdLHt0eXBlOiAkJFskMC0yXX0pKTtcbmJyZWFrO1xuY2FzZSAzNDE6XG5zZWxmLiQgPSAkJFskMC0zXS5hZGRFbHNlKG5ldyB5eS5JZigkJFskMC0xXSwkJFskMF0se3R5cGU6ICQkWyQwLTJdfSkpO1xuYnJlYWs7XG5jYXNlIDM0MjpcbnNlbGYuJCA9ICQkWyQwLTJdLmFkZEVsc2UoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAzNDQ6XG5zZWxmLiQgPSBuZXcgeXkuSWYoJCRbJDBdLG5ldyB5eS5CbG9jayhbJCRbJDAtMl1dKSx7dHlwZTogJCRbJDAtMV0sc3RhdGVtZW50OiB0cnVlfSk7XG5icmVhaztcbmNhc2UgMzQ1Olxuc2VsZi4kID0gbmV3IHl5LklmKCQkWyQwXSxuZXcgeXkuQmxvY2soWyQkWyQwLTJdXSkse3R5cGU6ICQkWyQwLTFdfSk7XG5icmVhaztcbmNhc2UgMzQ2Olxuc2VsZi4kID0geXkuSWYudGVybmFyeSgkJFskMC00XSwkJFskMC0yXSwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDM0NzogY2FzZSAzNDg6XG5zZWxmLiQgPSB5eS5PUCgkJFskMC0xXSwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDM0OTpcbnNlbGYuJCA9IG5ldyB5eS5PcCgnLScsJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAzNTA6XG5zZWxmLiQgPSBuZXcgeXkuT3AoJysnLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMzUxOlxuc2VsZi4kID0gbmV3IHl5LlVuYXJ5T3AoJy0tJyxudWxsLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMzUyOlxuc2VsZi4kID0gbmV3IHl5LlVuYXJ5T3AoJysrJyxudWxsLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMzUzOlxuc2VsZi4kID0gbmV3IHl5LlVuYXJ5T3AoJy0tJywkJFskMC0xXSxudWxsLHRydWUpO1xuYnJlYWs7XG5jYXNlIDM1NDpcbnNlbGYuJCA9IG5ldyB5eS5VbmFyeU9wKCcrKycsJCRbJDAtMV0sbnVsbCx0cnVlKTtcbmJyZWFrO1xuY2FzZSAzNTU6IGNhc2UgMzU2Olxuc2VsZi4kID0gbmV3IHl5Lk9wKCQkWyQwLTFdLCQkWyQwLTJdLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMzU3OiBjYXNlIDM1ODogY2FzZSAzNTk6IGNhc2UgMzYwOlxuc2VsZi4kID0geXkuT1AoJCRbJDAtMV0sJCRbJDAtMl0sJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAzNjE6XG5zZWxmLiQgPSAoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZiAoJCRbJDAtMV0uY2hhckF0KDApID09ICchJykge1xuXHRcdFx0XHRcdHJldHVybiB5eS5PUCgkJFskMC0xXS5zbGljZSgxKSwkJFskMC0yXSwkJFskMF0pLmludmVydCgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiB5eS5PUCgkJFskMC0xXSwkJFskMC0yXSwkJFskMF0pO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSgpKTtcbmJyZWFrO1xuY2FzZSAzNjI6XG5zZWxmLiQgPSB5eS5PUF9DT01QT1VORCgkJFskMC0xXS5fdmFsdWUsJCRbJDAtMV0sJCRbJDAtMl0sJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAzNjM6XG5zZWxmLiQgPSB5eS5PUF9DT01QT1VORCgkJFskMC0zXS5fdmFsdWUsJCRbJDAtNF0sJCRbJDAtMV0uaW5kZW50ZWQoJCRbJDAtMl0sJCRbJDBdKSk7XG5icmVhaztcbn1cbn0sXG50YWJsZTogW3sxOlsyLDFdLDM6MSw0OjIsNTozLDc6JFYwLDg6NSwxMDokVjEsMTI6NywxMzo4LDE1OjksMTY6MTAsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDEzODokVnosMTM5OiRWQSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzA6JFZKLDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezE6WzNdfSx7MTpbMiwyXSw2OiRWNTEsOToxMzN9LHs2OlsxLDEzNV19LG8oJFY2MSxbMiw0XSksbygkVjYxLFsyLDVdLHsxNDokVjcxfSksezQ6MTM4LDY6WzEsMTM5XSw3OiRWMCw4OjUsMTE6WzEsMTM3XSwxMjo3LDEzOjgsMTU6OSwxNjoxMCwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTM4OiRWeiwxMzk6JFZBLDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MDokVkosMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWODEsWzIsMTJdKSxvKCRWODEsWzIsMTNdLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDEyNjokVjkxLDE3MTokVmExLDIxMjokVlUsMjE0OiRWViwyMTk6JFZYLDIyMDokVlksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSxvKCRWODEsWzIsMTZdKSxvKCRWODEsWzIsMTddLHsyMTg6MTA4LDIyMjoxMDksMjExOjE1MiwyMTc6MTUzLDIxMjokVlUsMjE0OiRWViwyMTk6JFZYLDIyMDokVlksMjM4OiRWaTF9KSx7MTM6MTU0LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWajEsWzIsMzRdKSxvKCRWajEsWzIsMzVdLHsxOTU6MTU2LDE0MToxNTcsMTc5OjE1OSwyMTokVmsxLDg4OiRWbDEsODk6JFZtMSwxMTE6JFZuMSwxNDQ6JFZDLDE4MDokVm8xLDE4MTokVnAxLDE4MzokVnExLDE5NjokVnIxfSksbygkVmoxLFsyLDM2XSksbygkVmoxLFsyLDM3XSksbygkVmoxLFsyLDM4XSksbygkVmoxLFsyLDM5XSksbygkVmoxLFsyLDQwXSksbygkVmoxLFsyLDQxXSksbygkVmoxLFsyLDQyXSksbygkVmoxLFsyLDQzXSksbygkVmoxLFsyLDQ0XSksbygkVmoxLFsyLDQ1XSksbygkVmoxLFsyLDQ2XSksbygkVmoxLFsyLDQ3XSksbygkVmoxLFsyLDQ4XSksbygkVmoxLFsyLDQ5XSksbygkVnMxLFsyLDE0OF0pLG8oJFZzMSxbMiwxNDldKSxvKCRWdDEsWzIsMThdKSxvKCRWdDEsWzIsMTldKSxvKCRWdDEsWzIsMjBdKSxvKCRWdDEsWzIsMjFdLHsyMTpbMSwxNjZdfSksbygkVnQxLFsyLDIzXSx7MjE6WzEsMTY3XX0pLG8oJFZ0MSxbMiwyNV0pLG8oJFZ0MSxbMiwyNl0pLHsxMzoxNjgsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oJFZ1MSwkVnYxLHsxMTc6WzEsMTY5XX0pLG8oJFZ1MSxbMiwyMzJdKSxvKCRWdTEsWzIsMjMzXSksbygkVnUxLFsyLDIzNF0pLG8oJFZ1MSxbMiwyMzVdKSxvKCRWdTEsWzIsMjM2XSksbygkVnUxLFsyLDIzN10pLG8oJFZ1MSxbMiwyMzhdKSxvKCRWdTEsWzIsMjM5XSksbygkVnUxLFsyLDI0MF0pLG8oJFZqMSxbMiwxNTBdKSxvKCRWajEsWzIsMTUxXSksbygkVmoxLFsyLDE1Ml0pLHsxMzoxNzAsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHsxMzoxNzEsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHsxMzoxNzIsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHsxMzoxNzMsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHszMjokVjcsMzU6MTc1LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODI6OTIsODM6JFZwLDg5OiRWdzEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTA5OjEwMSwxMjk6NDUsMTMwOiRWeCwxMzE6MTc3LDEzNjokVnksMTUwOjc3LDE1NDokVkYsMTU3OiRWeDEsMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjE3NCwxNzg6MzksMTg0OiRWTCwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5NzokVlEsMTk4OiRWUn0sezMyOiRWNywzNToxNzUsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4Mjo5Miw4MzokVnAsODk6JFZ3MSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDk6MTAxLDEyOTo0NSwxMzA6JFZ4LDEzMToxNzcsMTM2OiRWeSwxNTA6NzcsMTU0OiRWRiwxNTc6JFZ4MSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6MTc5LDE3ODozOSwxODQ6JFZMLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTk3OiRWUSwxOTg6JFZSfSxvKCRWeTEsJFZ6MSx7MjQ0OlsxLDE4MF0sMjQ1OlsxLDE4MV0sMjQ5OlsxLDE4Ml19KSxvKCRWajEsWzIsMzQzXSx7MjMyOlsxLDE4M10sMjM3OlsxLDE4NF19KSx7NToxODUsMTA6JFYxfSx7NToxODYsMTA6JFYxfSxvKCRWajEsWzIsMzA2XSksezU6MTg3LDEwOiRWMX0sezEwOlsxLDE4OV0sMTM6MTg4LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWajEsWzIsMjQ5XSksezEyMToxOTEsMTI0OiRWdywxOTI6MTkwLDE5MzokVk99LHsxMjE6MTkzLDEyNDokVncsMTkyOjE5MiwxOTM6JFZPfSx7MTU1OjE5NSwxNTg6JFZJLDE5MjoxOTQsMTkzOiRWT30sezEyMzpbMSwxOTddLDE1NDokVkYsMTU1OjE5OCwxNTc6JFZ4MSwxNTg6JFZJLDE3MzoxOTksMTc1OiRWSywxOTI6MTk2LDE5MzokVk99LHszMjokVjcsMzU6MTc1LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODI6OTIsODM6JFZwLDg5OiRWdzEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTA5OjEwMSwxMjk6NDUsMTMwOiRWeCwxMzE6MTc3LDEzNjokVnksMTUwOjc3LDE1NDokVkYsMTU3OiRWeDEsMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjIwMCwxNzg6MzksMTg0OiRWTCwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5NzokVlEsMTk4OiRWUn0sbygkVmoxLFsyLDEyM10pLG8oJFZBMSxbMiwxMDJdLHsxMDQ6MjAxLDEwODoyMDMsMTA5OjIwNCw1MTpbMSwyMDVdLDg5OlsxLDIwMl0sMTEwOlsxLDIwNl0sMTk4OiRWUn0pLHs1MDoyMDgsNTE6JFY4LDg5OlsxLDIwOV0sMTQ5OjIwN30sbygkVnQxLFsyLDc3XSx7MzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsMTc6MzAsMTg6MzEsMjU6MzYsMTMxOjM4LDE3ODozOSw3Mjo0MCwxODY6NDEsMTg3OjQyLDE2Njo0NCwxMjk6NDUsMTAxOjQ2LDE4OTo0NywxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNzY6NTcsMjM1OjU4LDIxMTo2MCwyMTU6NjEsMjE3OjYyLDE5Mjo2NCwxMjE6NzAsMTQ4OjcyLDE2ODo3NiwxNTA6NzcsNjM6NzksODI6OTIsMTU1OjkzLDU3Ojk3LDUyOjk4LDU1Ojk5LDU5OjEwMCwxMDk6MTAxLDE3MzoxMDIsNTA6MTAzLDIxODoxMDgsMjIyOjEwOSw2MToxMTYsNjU6MTE3LDE2OjE1NSwxMzoyMTAsODE6MjExLDE5OiRWMiwyMDokVjMsMjE6JFZCMSwyMzokVjQsMjQ6JFY1LDI2OiRWNiwzMjokVjcsNTE6JFY4LDUzOiRWOSw1NDokVmEsNTY6JFZiLDU4OiRWYyw2MDokVmQsNjI6JFZlLDY0OiRWZiw2NjokVmcsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAzOiRWdCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMzA6JFZ4LDEzNjokVnksMTQzOiRWQiwxNDQ6JFZDLDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE3NTokVkssMTg0OiRWTCwxODU6JFZNLDE4ODokVk4sMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjE2OiRWVywyMzA6JFZaLDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0pLHsxMzoyMTMsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHsyNzoyMTQsMjk6MjE1LDMxOjIxNiwzMjokVkMxLDMzOjIxOCw1MDoyMjAsNTE6JFY4LDU3OjIxOSw1ODokVmN9LG8oJFZ5MSxbMiwyMjhdKSxvKCRWeTEsWzIsMjI5XSksbygkVkQxLFsyLDIyNl0pLG8oJFZ1MSxbMiw2N10pLG8oJFZ1MSxbMiw2OF0pLG8oJFZ1MSxbMiw2OV0pLG8oJFZ1MSxbMiw3MF0pLG8oJFZ1MSxbMiw3MV0pLG8oJFZ1MSxbMiw3Ml0pLG8oJFZ1MSxbMiw3M10pLG8oJFZ1MSxbMiw3NF0pLHs0OjIyMSw3OiRWMCw4OjUsMTA6WzEsMjIyXSwxMjo3LDEzOjgsMTU6OSwxNjoxMCwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTM4OiRWeiwxMzk6JFZBLDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MDokVkosMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTA6JFZFMSwxMjoyMjgsMTM6MjIzLDE1OjIzMCwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDk3OiRWRjEsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMTk6MjI1LDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxMzg6JFZ6LDEzOTokVkEsMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTcwOiRWSiwxNzE6JFZHMSwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDI6MjI2LDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sbyhbMSw2LDEwLDExLDE0LDIxLDIyLDcxLDg4LDg5LDkwLDkxLDk3LDEwNiwxMTEsMTEyLDEyNiwxMzUsMTM3LDE0NCwxNDcsMTcxLDE4MCwxODEsMTgzLDE5NiwyMDAsMjAxLDIxMiwyMTMsMjE0LDIxOSwyMjAsMjI5LDIzOCwyMzksMjQyLDI0MywyNDYsMjQ3LDI0OF0sWzIsMjY3XSksbygkVnUxLFsyLDEzNF0pLHs1MDoyMzEsNTE6JFY4fSx7ODQ6MjMzLDg1OlsxLDIzNF0sODY6WzEsMjM1XSw4NzpbMSwyMzZdLDg4OlsxLDIzN10sOTE6WzEsMjM4XSw5MjpbMSwyMzldLDkzOlsxLDI0MF0sOTQ6WzEsMjQxXSw5NTpbMSwyNDJdLDk2OlsxLDI0M10sMTAwOlsxLDI0NF0sMTAyOlsxLDIzMl19LG8oJFZqMSxbMiwxNjVdKSx7NToyNDUsMTA6JFYxLDE0NTpbMSwyNDZdfSxvKCRWSDEsJFZJMSx7NjE6MTE2LDY1OjExNywxOTE6MjQ4LDEzMzoyNDksMTM0OjI1MCwxNToyNTEsNTA6MjUyLDU3OjI1Myw2MzoyNTQsNTI6MjU1LDU1OjI1NiwzMjokVjcsNTE6JFY4LDUzOiRWOSw1NDokVmEsNTY6JFZiLDU4OiRWYyw2MjokVmUsNjQ6JFZmLDY2OiRWZywxMzY6JFZKMSwxMzg6JFZ6LDEzOTokVkEsMTQ1OiRWSzF9KSx7NToyNTgsMTA6JFYxfSxvKCRWRDEsWzIsMjA4XSksbygkVkQxLFsyLDIwOV0pLG8oJFZEMSxbMiwyMTBdKSxvKCRWRDEsWzIsMjExXSksbygkVkQxLFsyLDIxMl0pLG8oJFZEMSxbMiwyMTNdKSxvKCRWRDEsWzIsMjE0XSksezEzOjI1OSwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezEzOjI2MCwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezEzOjI2MSwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezU6MjYyLDEwOiRWMSwxMzoyNjMsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHs1MDoyNjgsNTE6JFY4LDg5OiRWdzEsOTY6JFZzLDE1MDoyNzAsMTY4OjI2OSwxODc6MjY0LDIyNDoyNjUsMjI1OlsxLDI2Nl0sMjI2OjI2N30sezIyMzoyNzEsMjI3OlsxLDI3Ml0sMjI4OlsxLDI3M119LHszMjokVjcsMzU6MTc1LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODI6OTIsODM6JFZwLDg5OiRWdzEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTA5OjEwMSwxMjk6NDUsMTMwOiRWeCwxMzE6MTc3LDEzNjokVnksMTUwOjc3LDE1NDokVkYsMTU3OiRWeDEsMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjI3NCwxNzg6MzksMTg0OiRWTCwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5NzokVlEsMTk4OiRWUn0sezExMDokVkwxLDEyNToyNzUsMTI4OiRWTTF9LG8oJFZOMSxbMiwxNjBdKSxvKCRWTjEsWzIsMTYxXSksbygkVnUxLFsyLDU3XSksbygkVnUxLFsyLDU4XSksbygkVnUxLFsyLDU5XSksbygkVnUxLFsyLDYwXSx7Njg6Mjc5LDY3OlsxLDI3OF0sNjk6WzEsMjgwXSw3MDpbMSwyODFdfSksbygkVk8xLFsyLDc4XSksezUwOjI4Nyw1MTokVjgsNTU6Mjg2LDU2OiRWYiw1NzoyODgsNTg6JFZjLDg5OiRWUDEsMTA5OjI4NSwxNTk6MjgyLDE2MToyODMsMTY2OjI4NCwxOTc6JFZRLDE5ODokVlJ9LG8oWzEsNiwxMCwxMSwxNCwyMSwyMiwyOCw3MSw4OCw4OSw5MCw5MSw5NywxMDYsMTExLDExMiwxMTcsMTI2LDEzNSwxMzcsMTQ0LDE0NywxNjQsMTY1LDE3MSwxODAsMTgxLDE4MywxOTYsMjAwLDIwMSwyMTIsMjEzLDIxNCwyMTksMjIwLDIyOSwyMzgsMjM5LDI0MiwyNDMsMjQ0LDI0NSwyNDYsMjQ3LDI0OCwyNDldLFsyLDU0XSksbygkVlExLFsyLDUxXSksbygkVlExLFsyLDUyXSksbyhbMSw2LDEwLDExLDE0LDIxLDIyLDcxLDg4LDg5LDkwLDkxLDk3LDEwNiwxMTEsMTEyLDExNywxMjYsMTM1LDEzNywxNDQsMTQ3LDE3MSwxODAsMTgxLDE4MywxOTYsMjAwLDIwMSwyMTIsMjEzLDIxNCwyMTksMjIwLDIyOSwyMzgsMjM5LDI0MiwyNDMsMjQ0LDI0NSwyNDYsMjQ3LDI0OCwyNDldLFsyLDUzXSksbygkVkQxLFsyLDU1XSksbygkVlExLFsyLDI2OF0pLHs1MDoyOTMsNTE6JFY4LDU3OjI5Miw1ODokVmMsOTY6JFZSMSwxNjg6Mjk0LDE3MDpbMSwyOTBdLDE3NDoyOTF9LHs1MDoyOTMsNTE6JFY4LDU3OjI5Miw1ODokVmMsOTY6JFZSMSwxNjg6Mjk0LDE3MDpbMSwyOTddLDE3NDoyOTZ9LG8oWzEsNiwxMCwxMSwxNCwyMSwyMiwyOCw3MSw4OCw4OSw5MCw5MSw5Nyw5OCwxMDYsMTExLDExMiwxMTcsMTI2LDEzNSwxMzcsMTQ0LDE0NywxNjQsMTY1LDE3MSwxODAsMTgxLDE4MywxOTYsMjAwLDIwMSwyMTIsMjEzLDIxNCwyMTksMjIwLDIyNywyMjgsMjI5LDIzOCwyMzksMjQyLDI0MywyNDQsMjQ1LDI0NiwyNDcsMjQ4LDI0OV0sWzIsNTBdKSxvKCRWUzEsWzIsMzEyXSksbygkVlMxLFsyLDMxM10pLG8oJFZEMSxbMiw1Nl0pLG8oJFZUMSxbMiw2MV0pLG8oJFY2MSxbMiw3XSx7MTI6NywxMzo4LDE1OjksMTY6MTAsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsMTc6MzAsMTg6MzEsMjU6MzYsMTMxOjM4LDE3ODozOSw3Mjo0MCwxODY6NDEsMTg3OjQyLDE2Njo0NCwxMjk6NDUsMTAxOjQ2LDE4OTo0NywxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNzY6NTcsMjM1OjU4LDIxMTo2MCwyMTU6NjEsMjE3OjYyLDE5Mjo2NCwxMjE6NzAsMTQ4OjcyLDE2ODo3NiwxNTA6NzcsNjM6NzksODI6OTIsMTU1OjkzLDU3Ojk3LDUyOjk4LDU1Ojk5LDU5OjEwMCwxMDk6MTAxLDE3MzoxMDIsNTA6MTAzLDIxODoxMDgsMjIyOjEwOSw2MToxMTYsNjU6MTE3LDg6Mjk4LDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNjokVjYsMzI6JFY3LDUxOiRWOCw1MzokVjksNTQ6JFZhLDU2OiRWYiw1ODokVmMsNjA6JFZkLDYyOiRWZSw2NDokVmYsNjY6JFZnLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMzokVnQsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTMwOiRWeCwxMzY6JFZ5LDEzODokVnosMTM5OiRWQSwxNDM6JFZCLDE0NDokVkMsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTcwOiRWSiwxNzU6JFZLLDE4NDokVkwsMTg1OiRWTSwxODg6JFZOLDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMjokVlUsMjE0OiRWViwyMTY6JFZXLDIxOTokVlgsMjIwOiRWWSwyMzA6JFZaLDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0pLG8oWzEsNiwxMSwxOSwyMCwyMywyNCwyNiwzMiw1MSw1Myw1NCw1Niw1OCw2MCw2Miw2NCw2Niw3Myw3NCw3NSw3Niw3Nyw3OCw3OSw4MCw4Myw4OSw5MSw5NiwxMDMsMTIyLDEyMywxMjQsMTMwLDEzNiwxMzcsMTM4LDEzOSwxNDMsMTQ0LDE1MSwxNTIsMTU0LDE1NiwxNTcsMTU4LDE3MCwxNzEsMTc1LDE4NCwxODUsMTg4LDE5MywxOTQsMTk3LDE5OCwyMDQsMjEwLDIxMiwyMTQsMjE2LDIxOSwyMjAsMjMwLDIzNiwyNDAsMjQxLDI0MiwyNDMsMjQ0LDI0NV0sWzIsOF0pLHsxOlsyLDNdfSx7MTI6MzAwLDEzOjI5OSwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MDokVkosMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWVTEsWzIsOV0pLHs2OiRWNTEsOToxMzMsMTE6WzEsMzAxXX0sezQ6MzAyLDc6JFYwLDg6NSwxMjo3LDEzOjgsMTU6OSwxNjoxMCwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTM4OiRWeiwxMzk6JFZBLDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MDokVkosMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTM6MzAzLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTM6MzA0LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTM6MzA1LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTM6MzA2LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTM6MzA3LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTM6MzA4LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTM6MzA5LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTM6MzEwLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTM6MzExLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWajEsWzIsMzA1XSksbygkVmoxLFsyLDMxMF0pLHsxMzozMTIsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oJFZqMSxbMiwzMDRdKSxvKCRWajEsWzIsMzA5XSksbyhbMSw2LDEwLDExLDE0LDIyLDk3LDEzN10sWzIsMTk3XSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwxMjY6JFY5MSwxNzE6JFZhMSwyMTI6JFZVLDIxNDokVlYsMjE5OiRWWCwyMjA6JFZZLDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSksezIxMToxNTIsMjEyOiRWVSwyMTQ6JFZWLDIxNzoxNTMsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzg6JFZpMX0sezIxOiRWQjEsODE6MzEzfSxvKCRWdTEsWzIsMjYyXSksbygkVlYxLFsyLDIyNF0sezE3ODozMTUsNjE6MzE2LDYyOiRWZSwxNzc6WzEsMzE0XSwxODQ6JFZMfSksezUwOjMxNyw1MTokVjgsNTI6MzE4LDUzOiRWOSw1NDokVmEsNTc6MzE5LDU4OiRWY30sezUwOjMyMCw1MTokVjh9LHs1MDozMjEsNTE6JFY4fSx7MTM6MzIzLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTgyOjMyMiwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTA6MzI0LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDE5OTozMjUsMjAwOiRWVzEsMjAxOiRWWDEsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MjE6WzIsMjY0XX0sezE0NTokVksxfSxvKCRWVjEsWzIsMjI1XSksezEzOjMyOCwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezEzOjMyOSwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sbygkVlkxLFsyLDIzMF0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMTI2OiRWOTEsMTcxOiRWYTEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSx7MTA6WzEsMzMxXSwxMzozMzAsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oJFZqMSxbMiwzNDddLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwfSksbygkVmoxLFsyLDM0OF0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTB9KSxvKCRWajEsWzIsMzQ5XSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MH0pLG8oJFZqMSxbMiwzNTBdLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwfSksbygkVmoxLFsyLDM1MV0sezIxOiRWejEsODg6JFZ6MSw4OTokVnoxLDExMTokVnoxLDE0NDokVnoxLDE4MDokVnoxLDE4MTokVnoxLDE4MzokVnoxLDE5NjokVnoxfSksezIxOiRWazEsODg6JFZsMSw4OTokVm0xLDExMTokVm4xLDE0MToxNTcsMTQ0OiRWQywxNzk6MTU5LDE4MDokVm8xLDE4MTokVnAxLDE4MzokVnExLDE5NToxNTYsMTk2OiRWcjF9LHsxNTQ6JFZGLDE1NzokVngxLDE3MzoxOTksMTc1OiRWS30sbyhbMjEsODgsODksMTExLDE0NCwxODAsMTgxLDE4MywxOTZdLCRWdjEpLG8oJFZIMSwkVkkxLHs2MToxMTYsNjU6MTE3LDE5MToyNDgsMTMzOjI0OSwxMzQ6MjUwLDE1OjI1MSw1MDoyNTIsNTc6MjUzLDYzOjI1NCw1MjoyNTUsNTU6MjU2LDMyOiRWNyw1MTokVjgsNTM6JFY5LDU0OiRWYSw1NjokVmIsNTg6JFZjLDYyOiRWZSw2NDokVmYsNjY6JFZnLDEzNjokVkoxLDEzODokVnosMTM5OiRWQX0pLG8oJFZqMSxbMiwzNTJdLHsyMTokVnoxLDg4OiRWejEsODk6JFZ6MSwxMTE6JFZ6MSwxNDQ6JFZ6MSwxODA6JFZ6MSwxODE6JFZ6MSwxODM6JFZ6MSwxOTY6JFZ6MX0pLG8oJFZqMSxbMiwzNTNdKSxvKCRWajEsWzIsMzU0XSksezEwOlsxLDMzM10sMTM6MzMyLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7NTozMzUsMTA6JFYxLDIzNjpbMSwzMzRdfSx7MTM6MzM2LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWajEsWzIsMjkwXSx7MjA1OjMzNywyMDY6MzM4LDIwNzokVloxLDIwODpbMSwzMzldfSksbygkVmoxLFsyLDMwM10pLG8oJFZqMSxbMiwzMTFdKSx7MTA6WzEsMzQxXSwxMjY6JFY5MSwxNzE6JFZhMSwyMTE6MTQ5LDIxMjokVlUsMjE0OiRWViwyMTc6MTUwLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9LHsyMzE6MzQyLDIzMzozNDMsMjM0OiRWXzF9LG8oJFZqMSxbMiwyNTBdKSxvKCRWajEsWzIsMTI0XSksbygkVmoxLFsyLDI1MV0pLG8oJFZqMSxbMiwxMjVdKSxvKCRWajEsWzIsMjUyXSksbygkVmoxLFsyLDE2Nl0pLG8oJFZqMSxbMiwyNTNdKSx7MTkyOjM0NSwxOTM6JFZPfSxvKCRWajEsWzIsMTY3XSksbygkVkQxLFsyLDIwMl0pLG8oJFYkMSxbMiwyNTldLHs1OjM0NiwxMDokVjEsMjE6JFZ6MSw4ODokVnoxLDg5OiRWejEsMTExOiRWejEsMTQ0OiRWejEsMTgwOiRWejEsMTgxOiRWejEsMTgzOiRWejEsMTk2OiRWejF9KSxvKCRWMDIsWzIsMTEyXSx7MTA1OjM0Nyw1MjozNTIsMTE0OjM1Myw1MzokVjksNTQ6JFZhLDg4OlsxLDM0OF0sOTE6WzEsMzUxXSwxMTE6WzEsMzQ5XSwxMTM6WzEsMzUwXSwxMTY6JFYxMn0pLHsxMzozNTUsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oJFZBMSxbMiwxMDNdKSxvKCRWQTEsWzIsOTldKSxvKCRWQTEsWzIsMTAwXSksbygkVkExLFsyLDEwMV0pLG8oJFZqMSxbMiwxNTldLHsxNTA6MzU2LDIxOlsxLDM1N10sODk6JFZ3MX0pLG8oJFYyMixbMiwxNjJdKSx7MTM6MzU4LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWdDEsWzIsNzVdLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDEyNjokVjkxLDE3MTokVmExLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSksbygkVnQxLFsyLDc2XSksezEwOiRWRTEsMTI6MjI4LDEzOjM2MSwxNToyMzAsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjI6WzEsMzU5XSwyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTE5OjM2MCwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTM4OiRWeiwxMzk6JFZBLDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MDokVkosMTcxOiRWRzEsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjAyOjIyNiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oJFZ0MSxbMiwyOTZdLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDEyNjokVjkxLDE3MTokVmExLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSksezE0OlsxLDM2M10sMjg6WzEsMzYyXX0sbygkVnQxLFsyLDI5XSx7MzA6WzEsMzY0XX0pLG8oJFYzMixbMiwzMV0pLG8oWzEsNiwxMSwxNCwzMCwxMzcsMjEyLDIxNCwyMTksMjIwLDIzOF0sWzIsMzBdKSxvKCRWNDIsWzIsMzNdKSxvKCRWNDIsWzIsMjAzXSksbygkVjQyLFsyLDIwNF0pLHs2OiRWNTEsOToxMzMsMTM3OlsxLDM2NV19LHs0OjM2Niw3OiRWMCw4OjUsMTI6NywxMzo4LDE1OjksMTY6MTAsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDEzODokVnosMTM5OiRWQSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzA6JFZKLDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sbyhbNiwxMCwxNCw5N10sJFY1Mix7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwxOTk6MzY3LDEyNjokVjkxLDE3MTokVmExLDIwMDokVlcxLDIwMTokVlgxLDIxMjokVlUsMjE0OiRWViwyMTk6JFZYLDIyMDokVlksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSxvKCRWNjIsWzIsMjY5XSksbyhbNiwxMCw5N10sJFY3Mix7MTE1OjM2OCwxNDokVjgyfSksbygkVjkyLFsyLDI3N10pLHsxMDokVkUxLDEyOjIyOCwxMzozNjEsMTU6MjMwLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMTk6MzcwLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxMzg6JFZ6LDEzOTokVkEsMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTcwOiRWSiwxNzE6JFZHMSwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDI6MjI2LDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sbygkVjkyLFsyLDI4NV0pLG8oJFY5MixbMiwyODZdKSxvKCRWOTIsWzIsMjg3XSksbygkVnUxLFsyLDEzNV0pLG8oJFZ1MSxbMiw5Ml0pLG8oJFZPMSxbMiw3OV0pLG8oJFZPMSxbMiw4MF0pLG8oJFZPMSxbMiw4MV0pLG8oJFZPMSxbMiw4Ml0pLHs4OTpbMSwzNzFdfSx7ODk6WzEsMzcyXX0sbygkVk8xLFsyLDg1XSksbygkVk8xLFsyLDg2XSksbygkVk8xLFsyLDg3XSksbygkVk8xLFsyLDg4XSksezUwOjM3Myw1MTokVjh9LG8oJFZPMSxbMiw5MV0pLG8oJFZ1MSxbMiwxNTRdKSxvKCRWYTIsJFZiMix7MTQ2OjM3NCwxNjc6Mzc1LDE1MDozNzYsMTY4OjM3NywxNjk6Mzc4LDUwOjM4Miw1MTokVjgsODk6JFZ3MSw5NjokVlIxLDE3MDokVmMyLDE3MTokVmQyLDE3MjokVmUyfSksbygkVmEyLCRWYjIsezE2NzozNzUsMTUwOjM3NiwxNjg6Mzc3LDE2OTozNzgsNTA6MzgyLDE0NjozODMsNTE6JFY4LDg5OiRWdzEsOTY6JFZSMSwxNzA6JFZjMiwxNzE6JFZkMiwxNzI6JFZlMn0pLG8oWzYsMTAsOTBdLCRWNzIsezExNTozODQsMTQ6JFZmMn0pLG8oJFZnMixbMiwyNDVdKSxvKCRWZzIsWzIsMTM4XSx7MTM1OlsxLDM4Nl19KSxvKCRWZzIsWzIsMTQxXSksbygkVmgyLFsyLDE0Ml0pLG8oJFZoMixbMiwxNDNdKSxvKCRWaDIsWzIsMTQ0XSksbygkVmgyLFsyLDE0NV0pLG8oJFZoMixbMiwxNDZdKSx7MTM6Mzg3LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWajEsWzIsMTUzXSksezU6Mzg4LDEwOiRWMSwxMjY6JFY5MSwxNzE6JFZhMSwyMTE6MTQ5LDIxMjokVlUsMjE0OiRWViwyMTc6MTUwLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9LG8oJFZpMixbMiwyOTldLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDEyNjokVjkxLDE3MTokVmExLDIxMjokVlUsMjEzOlsxLDM4OV0sMjE0OiRWViwyMTk6JFZYLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSksbygkVmkyLFsyLDMwMV0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMTI2OiRWOTEsMTcxOiRWYTEsMjEyOiRWVSwyMTM6WzEsMzkwXSwyMTQ6JFZWLDIxOTokVlgsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSxvKCRWajEsWzIsMzA3XSksbygkVmoyLFsyLDMwOF0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMTI2OiRWOTEsMTcxOiRWYTEsMjEyOiRWVSwyMTQ6JFZWLDIxOTokVlgsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSxvKCRWajEsWzIsMzE1XSksbygkVmsyLFsyLDMxN10pLHs1MDoyNjgsNTE6JFY4LDg5OiRWdzEsOTY6JFZSMSwxNTA6MjcwLDE2ODoyNjksMjI0OjM5MSwyMjY6MjY3fSxvKCRWazIsWzIsMzIyXSx7MTQ6WzEsMzkyXX0pLG8oJFZsMixbMiwzMTldKSxvKCRWbDIsWzIsMzIwXSksbygkVmwyLFsyLDMyMV0pLG8oJFZqMSxbMiwzMTZdKSx7MTM6MzkzLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTM6Mzk0LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWbTIsWzIsMjU1XSx7NTozOTUsMTA6JFYxLDIxOiRWejEsODg6JFZ6MSw4OTokVnoxLDExMTokVnoxLDE0NDokVnoxLDE4MDokVnoxLDE4MTokVnoxLDE4MzokVnoxLDE5NjokVnoxLDEyNjpbMSwzOTZdfSksbygkVm0yLFsyLDEyNl0sezU6Mzk3LDEwOiRWMSwxMjY6WzEsMzk4XX0pLG8oJFZqMSxbMiwxMzJdKSxvKCRWajEsWzIsMTMzXSksbygkVlQxLFsyLDYyXSksbygkVlQxLFsyLDYzXSksbygkVlQxLFsyLDY0XSksezEzOjQwMCwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcxOlsxLDM5OV0sNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7ODg6WzEsNDAyXSw5MTpbMSw0MDNdLDE2MDo0MDF9LG8oJFZuMixbMiwxODBdLHsxNjI6NDA1LDIxOlsxLDQwNF0sMTY0OiRWbzIsMTY1OiRWcDJ9KSxvKCRWbjIsWzIsMTgxXSksbygkVm4yLFsyLDE4Ml0pLG8oJFZuMixbMiwxODNdKSxvKCRWcTIsWzIsMTc0XSksbygkVnEyLFsyLDE3NV0pLHsxMzo0MDgsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHs1MDoyOTMsNTE6JFY4LDU3OjI5Miw1ODokVmMsOTY6JFZSMSwxNjg6Mjk0LDE3NDo0MDl9LG8oJFZEMSxbMiwxOTldKSxvKCRWRDEsWzIsMjA1XSksbygkVkQxLFsyLDIwNl0pLG8oJFZEMSxbMiwyMDddKSx7MTA6JFZFMSwxMjoyMjgsMTM6MzYxLDE1OjIzMCwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDk3OiRWRjEsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMTk6MjI1LDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxMzg6JFZ6LDEzOTokVkEsMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTcwOiRWSiwxNzE6JFZHMSwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDI6MjI2LDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sbygkVkQxLFsyLDIwMF0pLHs1MDoyOTMsNTE6JFY4LDU3OjI5Miw1ODokVmMsOTY6JFZSMSwxNjg6Mjk0LDE3NDo0MTB9LG8oJFY2MSxbMiw2XSx7MTQ6JFY3MX0pLG8oJFY4MSxbMiwxNF0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMTI2OiRWOTEsMTcxOiRWYTEsMjEyOiRWVSwyMTQ6JFZWLDIxOTokVlgsMjIwOiRWWSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0pLG8oJFY4MSxbMiwxNV0pLG8oJFZVMSxbMiwxMF0pLHs2OiRWNTEsOToxMzMsMTE6WzEsNDExXX0sbygkVnIyLFsyLDM1NV0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMjQ2OiRWZjF9KSxvKCRWcjIsWzIsMzU2XSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwyNDY6JFZmMX0pLG8oJFZqMSxbMiwzNTddLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwfSksbyhbMSw2LDEwLDExLDE0LDIyLDcxLDkwLDk3LDEwNiwxMTIsMTI2LDEzNSwxMzcsMTQ3LDE3MSwyMDAsMjAxLDIxMiwyMTMsMjE0LDIxOSwyMjAsMjI5LDIzOCwyMzksMjQ3LDI0OF0sWzIsMzU4XSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMX0pLG8oWzEsNiwxMCwxMSwxNCwyMiw3MSw5MCw5NywxMDYsMTEyLDEyNiwxMzUsMTM3LDE0NywxNzEsMjAwLDIwMSwyMTIsMjEzLDIxNCwyMTksMjIwLDIyOSwyMzgsMjM5XSxbMiwzNTldLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSksbyhbMSw2LDEwLDExLDE0LDIyLDcxLDkwLDk3LDEwNiwxMTIsMTM1LDEzNywxNDcsMTcxLDIwMCwyMDEsMjEyLDIxMywyMTQsMjE5LDIyMCwyMjksMjM4LDIzOV0sWzIsMzYwXSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwxMjY6JFY5MSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0pLG8oWzEsNiwxMCwxMSwxNCwyMiw3MSw5MCw5NywxMDYsMTEyLDEyNiwxMzUsMTM3LDE0NywxNzEsMjAwLDIwMSwyMTIsMjEzLDIxNCwyMTksMjIwLDIyOSwyMzgsMjM5LDI0OF0sWzIsMzYxXSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMX0pLG8oJFZzMixbMiwzNDVdLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDEyNjokVjkxLDE3MTokVmExLDIxMjokVlUsMjE0OiRWViwyMTk6JFZYLDIyMDokVlksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSx7MTI2OiRWOTEsMTM1OlsxLDQxMl0sMTcxOiRWYTEsMjExOjE0OSwyMTI6JFZVLDIxNDokVlYsMjE3OjE1MCwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSxvKCRWczIsWzIsMzQ0XSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwxMjY6JFY5MSwxNzE6JFZhMSwyMTI6JFZVLDIxNDokVlYsMjE5OiRWWCwyMjA6JFZZLDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSksbygkVnUxLFsyLDI2MV0pLG8oJFZEMSxbMiwyMTVdKSxvKCRWRDEsWzIsMjE2XSksbygkVkQxLFsyLDIyMV0pLG8oJFZEMSxbMiwyMTddKSxvKCRWRDEsWzIsMjIwXSksbygkVkQxLFsyLDIyMl0pLG8oJFZEMSxbMiwyMThdKSxvKCRWRDEsWzIsMjE5XSksezExMjpbMSw0MTNdfSx7MTEyOlsyLDI0MV0sMTI2OiRWOTEsMTcxOiRWYTEsMTk5OjQxNCwyMDA6JFZXMSwyMDE6JFZYMSwyMTE6MTQ5LDIxMjokVlUsMjE0OiRWViwyMTc6MTUwLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9LHsxMTI6WzIsMjQyXX0sezEzOjQxNSwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sbygkVnQyLFsyLDI3MV0pLG8oJFZ0MixbMiwyNzJdKSx7MjI6WzEsNDE2XSwxMjY6JFY5MSwxNzE6JFZhMSwyMTE6MTQ5LDIxMjokVlUsMjE0OiRWViwyMTc6MTUwLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9LHsyMjpbMSw0MTddLDEyNjokVjkxLDE3MTokVmExLDIxMToxNDksMjEyOiRWVSwyMTQ6JFZWLDIxNzoxNTAsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0sbygkVlkxLFsyLDEzNl0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMTI2OiRWOTEsMTcxOiRWYTEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSx7MTM6NDE4LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWWTEsWzIsMzYyXSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwxMjY6JFY5MSwxNzE6JFZhMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0pLHsxMzo0MTksMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHsxMzo0MjAsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oJFZ1MixbMiwzNDJdKSx7NTo0MjEsMTA6JFYxLDEyNjokVjkxLDE3MTokVmExLDIxMToxNDksMjEyOiRWVSwyMTQ6JFZWLDIxNzoxNTAsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0sbygkVmoxLFsyLDI5MV0sezIwNjo0MjIsMjA3OiRWWjF9KSxvKCRWajEsWzIsMjkyXSksezIwOTpbMSw0MjNdfSx7NTo0MjQsMTA6JFYxfSx7MjMxOjQyNSwyMzM6MzQzLDIzNDokVl8xfSx7MTE6WzEsNDI2XSwyMzI6WzEsNDI3XSwyMzM6NDI4LDIzNDokVl8xfSxvKCRWdjIsWzIsMzM1XSksezEzOjQzMCwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwMzo0MjksMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWajEsWzIsMjU0XSksbygkVmoxLFsyLDI2MF0pLHs2OiRWNzIsMTQ6WzEsNDMyXSwxMDY6WzEsNDMxXSwxMTU6NDMzfSx7NTE6WzEsNDM1XSw2MjpbMSw0MzRdLDg5OlsxLDQzNl19LHsxMzo0MzcsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHs4OTpbMSw0MzhdfSx7NTE6WzEsNDM5XSw4OTpbMSw0NDBdfSxvKCRWQTEsWzIsMTEwXSksbygkVjAyLFsyLDExM10pLG8oJFYwMixbMiwxMTZdLHsxMTc6WzEsNDQxXX0pLHs5MDpbMSw0NDJdLDEyNjokVjkxLDE3MTokVmExLDIxMToxNDksMjEyOiRWVSwyMTQ6JFZWLDIxNzoxNTAsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0sbygkVmoxLFsyLDE1N10pLHs4OTokVncxLDE1MDo0NDN9LHs5MDpbMSw0NDRdLDEyNjokVjkxLDE3MTokVmExLDIxMToxNDksMjEyOiRWVSwyMTQ6JFZWLDIxNzoxNTAsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0sbygkVnUxLFsyLDI2NV0pLG8oWzYsMTAsMjJdLCRWNzIsezExNTo0NDUsMTQ6JFY4Mn0pLG8oJFY5MiwkVjUyLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDEyNjokVjkxLDE3MTokVmExLDIxMjokVlUsMjE0OiRWViwyMTk6JFZYLDIyMDokVlksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSx7Mjk6NDQ2LDMyOiRWQzF9LHszMTo0NDcsMzM6MjE4LDUwOjIyMCw1MTokVjgsNTc6MjE5LDU4OiRWY30sezMxOjQ0OCwzMzoyMTgsNTA6MjIwLDUxOiRWOCw1NzoyMTksNTg6JFZjfSxvKCRWdTEsWzIsMjk3XSksezY6JFY1MSw5OjEzMywxMTpbMSw0NDldfSx7MTM6NDUwLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7NjokVjUxLDk6NDUyLDEwOiRWdzIsOTc6WzEsNDUxXX0sbyhbNiwxMCwxMSwyMiw5N10sJFZ4Mix7MzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsMTc6MzAsMTg6MzEsMjU6MzYsMTMxOjM4LDE3ODozOSw3Mjo0MCwxODY6NDEsMTg3OjQyLDE2Njo0NCwxMjk6NDUsMTAxOjQ2LDE4OTo0NywxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNzY6NTcsMjM1OjU4LDIxMTo2MCwyMTU6NjEsMjE3OjYyLDE5Mjo2NCwxMjE6NzAsMTQ4OjcyLDE2ODo3NiwxNTA6NzcsNjM6NzksODI6OTIsMTU1OjkzLDU3Ojk3LDUyOjk4LDU1Ojk5LDU5OjEwMCwxMDk6MTAxLDE3MzoxMDIsNTA6MTAzLDIxODoxMDgsMjIyOjEwOSw2MToxMTYsNjU6MTE3LDE2OjE1NSwxMjoyMjgsMTU6MjMwLDEzOjM2MSwyMDI6NDU0LDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNjokVjYsMzI6JFY3LDUxOiRWOCw1MzokVjksNTQ6JFZhLDU2OiRWYiw1ODokVmMsNjA6JFZkLDYyOiRWZSw2NDokVmYsNjY6JFZnLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMzokVnQsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTMwOiRWeCwxMzY6JFZ5LDEzODokVnosMTM5OiRWQSwxNDM6JFZCLDE0NDokVkMsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTcwOiRWSiwxNzE6JFZHMSwxNzU6JFZLLDE4NDokVkwsMTg1OiRWTSwxODg6JFZOLDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMjokVlUsMjE0OiRWViwyMTY6JFZXLDIxOTokVlgsMjIwOiRWWSwyMzA6JFZaLDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0pLG8oJFZ5MiwkVjcyLHsxMTU6NDU1LDE0OiRWODJ9KSx7MTM6NDU2LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTM6NDU3LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7OTc6WzEsNDU4XSw5ODpbMSw0NTldfSx7MTQ6JFZ6MiwxNDc6WzEsNDYwXX0sbygkVkEyLFsyLDE4N10pLG8oJFZBMixbMiwxODldKSxvKCRWQTIsWzIsMTkwXSksbygkVkEyLFsyLDE5MV0sezExNzpbMSw0NjJdfSksezUwOjM4Miw1MTokVjgsMTY5OjQ2M30sezUwOjM4Miw1MTokVjgsMTY5OjQ2NH0sezUwOjM4Miw1MTokVjgsMTY5OjQ2NX0sbyhbMTQsMjIsMTE3LDE0N10sWzIsMTk2XSksezE0OiRWejIsMTQ3OlsxLDQ2Nl19LHs2OiRWNTEsOTo0NjgsMTA6JFZCMiw5MDpbMSw0NjddfSxvKFs2LDEwLDExLDkwXSwkVngyLHs2MToxMTYsNjU6MTE3LDEzNDoyNTAsMTU6MjUxLDUwOjI1Miw1NzoyNTMsNjM6MjU0LDUyOjI1NSw1NToyNTYsMTMzOjQ3MCwzMjokVjcsNTE6JFY4LDUzOiRWOSw1NDokVmEsNTY6JFZiLDU4OiRWYyw2MjokVmUsNjQ6JFZmLDY2OiRWZywxMzY6JFZKMSwxMzg6JFZ6LDEzOTokVkF9KSx7MTA6WzEsNDcyXSwxMzo0NzEsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHsxMjY6JFY5MSwxMzc6WzEsNDczXSwxNzE6JFZhMSwyMTE6MTQ5LDIxMjokVlUsMjE0OiRWViwyMTc6MTUwLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9LG8oJFZ1MixbMiwzMzldKSx7MTM6NDc0LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTM6NDc1LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWazIsWzIsMzE4XSksezUwOjI2OCw1MTokVjgsODk6JFZ3MSw5NjokVlIxLDE1MDoyNzAsMTY4OjI2OSwyMjY6NDc2fSxvKFsxLDYsMTAsMTEsMTQsMjIsNzEsOTAsOTcsMTA2LDExMiwxMzUsMTM3LDE0NywyMDAsMjAxLDIxMiwyMTQsMjE5LDIyMCwyMzhdLFsyLDMyNF0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMTI2OiRWOTEsMTcxOiRWYTEsMjEzOlsxLDQ3N10sMjI5OlsxLDQ3OF0sMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSxvKCRWQzIsWzIsMzI1XSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwxMjY6JFY5MSwxNzE6JFZhMSwyMTM6WzEsNDc5XSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0pLG8oJFZqMSxbMiwyNTZdKSx7MTM6NDgwLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWajEsWzIsMTI3XSksezExMDokVkwxLDEyNTo0ODEsMTI4OiRWTTF9LG8oJFZUMSxbMiw2NV0pLHs3MTpbMSw0ODJdLDEyNjokVjkxLDE3MTokVmExLDIxMToxNDksMjEyOiRWVSwyMTQ6JFZWLDIxNzoxNTAsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0sezUwOjI4Nyw1MTokVjgsNTc6Mjg4LDU4OiRWYyw4OTokVlAxLDE2MTo0ODN9LG8oJFZEMixbMiwxNzJdKSxvKCRWRDIsWzIsMTczXSksbygkVkUyLCRWYjIsezE2NzozNzUsMTUwOjM3NiwxNjg6Mzc3LDE2OTozNzgsNTA6MzgyLDE0Njo0ODQsNTE6JFY4LDg5OiRWdzEsOTY6JFZSMSwxNzA6JFZjMiwxNzE6JFZkMiwxNzI6JFZlMn0pLG8oJFZqMSxbMiwxNzFdKSx7NTo0ODUsMTA6JFYxLDg5OiRWbTEsMTQxOjQ4NiwxNDQ6JFZDfSxvKCRWajEsWzIsMTc5XSksezkwOlsxLDQ4N10sMTI2OiRWOTEsMTcxOiRWYTEsMjExOjE0OSwyMTI6JFZVLDIxNDokVlYsMjE3OjE1MCwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSxvKCRWRDEsWzIsMTk4XSksbygkVkQxLFsyLDIwMV0pLG8oJFZVMSxbMiwxMV0pLHsxMzo0ODgsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oJFZEMSxbMiwyMjNdKSx7MTM6NDg5LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMTI6WzIsMjc1XSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTEyOlsyLDI3Nl0sMTI2OiRWOTEsMTcxOiRWYTEsMjExOjE0OSwyMTI6JFZVLDIxNDokVlYsMjE3OjE1MCwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSxvKCRWdDEsWzIsMjJdKSxvKCRWdDEsWzIsMjRdKSx7NjokVjUxLDk6NDkxLDExOiRWRjIsMTI2OiRWOTEsMTMyOjQ5MCwxNzE6JFZhMSwyMTE6MTQ5LDIxMjokVlUsMjE0OiRWViwyMTc6MTUwLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9LHs2OiRWNTEsOTo0OTEsMTE6JFZGMiwxMjY6JFY5MSwxMzI6NDkzLDE3MTokVmExLDIxMToxNDksMjEyOiRWVSwyMTQ6JFZWLDIxNzoxNTAsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0sezU6NDk0LDEwOiRWMSwxMjY6JFY5MSwxNzE6JFZhMSwyMTE6MTQ5LDIxMjokVlUsMjE0OiRWViwyMTc6MTUwLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9LG8oJFZ1MixbMiwzNDFdKSxvKCRWajEsWzIsMjkzXSksezU6NDk1LDEwOiRWMX0sbygkVmoxLFsyLDI5NF0pLHsxMTpbMSw0OTZdLDIzMjpbMSw0OTddLDIzMzo0MjgsMjM0OiRWXzF9LG8oJFZqMSxbMiwzMzNdKSx7NTo0OTgsMTA6JFYxfSxvKCRWdjIsWzIsMzM2XSksezU6NDk5LDEwOiRWMSwxNDpbMSw1MDBdfSxvKCRWRzIsWzIsMjg4XSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwxMjY6JFY5MSwxNzE6JFZhMSwyMTI6JFZVLDIxNDokVlYsMjE5OiRWWCwyMjA6JFZZLDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSksbygkViQxLFsyLDk2XSx7MTA3OjUwMSwxMDpbMSw1MDJdLDIxOlsxLDUwM119KSx7NjokVngyLDExNDo1MDQsMTE2OiRWMTJ9LHs2OlsxLDUwNV19LG8oJFZBMSxbMiwxMDRdKSxvKCRWQTEsWzIsMTA2XSksezEzOjUwNiwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezExMjpbMSw1MDddLDEyNjokVjkxLDE3MTokVmExLDIxMToxNDksMjEyOiRWVSwyMTQ6JFZWLDIxNzoxNTAsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0sezEzOjUwOCwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sbygkVkExLFsyLDEwOV0pLHsxMzo1MDksMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHsxMzo1MTEsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDExODo1MTAsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezEwNjpbMSw1MTJdfSx7MjI6WzEsNTEzXX0sbygkVjIyLFsyLDE2M10pLHs2OiRWNTEsOTo0NTIsMTA6JFZ3MiwyMjpbMSw1MTRdfSxvKCRWdDEsWzIsMjddKSxvKCRWMzIsWzIsMzJdKSxvKCRWdDEsWzIsMjhdKSx7MTM3OlsxLDUxNV19LHs5NzpbMSw1MTZdLDEyNjokVjkxLDE3MTokVmExLDIxMToxNDksMjEyOiRWVSwyMTQ6JFZWLDIxNzoxNTAsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0sbygkVjYyLFsyLDI3MF0pLHsxMjoyMjgsMTM6MzYxLDE1OjIzMCwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDEzODokVnosMTM5OiRWQSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzA6JFZKLDE3MTokVkcxLDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwMjo1MTcsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTA6JFZFMSwxMjoyMjgsMTM6MzYxLDE1OjIzMCwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTE5OjUxOCwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTM4OiRWeiwxMzk6JFZBLDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MDokVkosMTcxOiRWRzEsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjAyOjIyNiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oJFY5MixbMiwyNzhdKSx7NjokVjUxLDk6NTIwLDEwOiRWdzIsMTE6JFZGMiwxMzI6NTE5fSx7OTA6WzEsNTIxXSwxMjY6JFY5MSwxNzE6JFZhMSwyMTE6MTQ5LDIxMjokVlUsMjE0OiRWViwyMTc6MTUwLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9LHs5MDpbMSw1MjJdLDEyNjokVjkxLDE3MTokVmExLDIxMToxNDksMjEyOiRWVSwyMTQ6JFZWLDIxNzoxNTAsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0sbygkVk8xLFsyLDg5XSksezMyOiRWNyw1MTpbMSw1MjRdLDYxOjExNiw2MjokVmUsNjM6NTI1LDY0OiRWZiw2NToxMTcsNjY6JFZnLDg5OlsxLDUyNl0sOTk6NTIzfSx7NTo1MjcsMTA6JFYxfSx7NTA6MzgyLDUxOiRWOCw4OTokVncxLDk2OiRWUjEsMTUwOjM3NiwxNjc6NTI4LDE2ODozNzcsMTY5OjM3OCwxNzA6JFZjMiwxNzE6JFZkMiwxNzI6JFZlMn0sezEzOjUyOSwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sbygkVkEyLFsyLDE5Ml0pLG8oJFZBMixbMiwxOTNdKSxvKCRWQTIsWzIsMTk0XSksezU6NTMwLDEwOiRWMX0sbyhbMSw2LDEwLDExLDE0LDIxLDIyLDcxLDg4LDg5LDkwLDk3LDEwNiwxMTEsMTEyLDExNywxMjYsMTM1LDEzNywxNDQsMTQ3LDE3MSwxODAsMTgxLDE4MywxOTYsMjAwLDIwMSwyMTIsMjEzLDIxNCwyMTksMjIwLDIyNywyMjgsMjI5LDIzOCwyMzksMjQyLDI0MywyNDYsMjQ3LDI0OF0sWzIsMjQzXSksezE1OjI1MSwzMjokVjcsNTA6MjUyLDUxOiRWOCw1MjoyNTUsNTM6JFY5LDU0OiRWYSw1NToyNTYsNTY6JFZiLDU3OjI1Myw1ODokVmMsNjE6MTE2LDYyOiRWZSw2MzoyNTQsNjQ6JFZmLDY1OjExNyw2NjokVmcsMTMzOjUzMSwxMzQ6MjUwLDEzNjokVkoxLDEzODokVnosMTM5OiRWQX0sbyhbNiwxMCwxMSwxNF0sJFZJMSx7NjE6MTE2LDY1OjExNywxMzM6MjQ5LDEzNDoyNTAsMTU6MjUxLDUwOjI1Miw1NzoyNTMsNjM6MjU0LDUyOjI1NSw1NToyNTYsMTkxOjUzMiwzMjokVjcsNTE6JFY4LDUzOiRWOSw1NDokVmEsNTY6JFZiLDU4OiRWYyw2MjokVmUsNjQ6JFZmLDY2OiRWZywxMzY6JFZKMSwxMzg6JFZ6LDEzOTokVkF9KSxvKCRWZzIsWzIsMjQ2XSksbygkVmcyLFsyLDEzOV0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMTI2OiRWOTEsMTcxOiRWYTEsMjEyOiRWVSwyMTQ6JFZWLDIxOTokVlgsMjIwOiRWWSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0pLHsxMzo1MzMsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oJFZoMixbMiwxNDddKSxvKCRWajIsWzIsMzAwXSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwxMjY6JFY5MSwxNzE6JFZhMSwyMTI6JFZVLDIxNDokVlYsMjE5OiRWWCwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0pLG8oJFZqMixbMiwzMDJdLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDEyNjokVjkxLDE3MTokVmExLDIxMjokVlUsMjE0OiRWViwyMTk6JFZYLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSksbygkVmsyLFsyLDMyM10pLHsxMzo1MzQsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHsxMzo1MzUsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHsxMzo1MzYsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oWzEsNiwxMSwxNCwyMiw3MSw5MCw5NywxMDYsMTEyLDEzNSwxMzcsMTQ3LDIwMCwyMDEsMjEzLDIyMCwyMjksMjM4XSxbMiwyNTddLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDU6NTM3LDEwOiRWMSwxMjY6JFY5MSwxNzE6JFZhMSwyMTI6JFZVLDIxNDokVlYsMjE5OiRWWCwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0pLG8oJFYkMSxbMiwxMjhdLHs1OjUzOCwxMDokVjF9KSxvKCRWVDEsWzIsNjZdKSx7MjE6WzEsNTM5XSwxNjI6NTQwLDE2NDokVm8yLDE2NTokVnAyfSx7MTQ6JFZ6MiwyMjpbMSw1NDFdfSxvKCRWajEsWzIsMTc3XSksbygkVmoxLFsyLDE3OF0pLG8oJFZxMixbMiwxNzZdKSxvKFsxLDYsMTAsMTEsMTQsMjIsNzEsOTAsOTcsMTA2LDExMiwxMzUsMTM3LDE0NywyMDAsMjAxLDIxMiwyMTMsMjE0LDIxOSwyMjAsMjI5LDIzOCwyMzldLFsyLDM0Nl0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMTI2OiRWOTEsMTcxOiRWYTEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSx7MTEyOlsyLDI3NF0sMTI2OiRWOTEsMTcxOiRWYTEsMjExOjE0OSwyMTI6JFZVLDIxNDokVlYsMjE3OjE1MCwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSxvKCRWajEsWzIsMTM3XSksezExOiRWSDJ9LG8oJFZqMSxbMiwyODNdKSxvKCRWajEsWzIsMzYzXSksbygkVnUyLFsyLDM0MF0pLG8oWzEsNiwxMCwxMSwxNCwyMiw3MSw5MCw5NywxMDYsMTEyLDEyNiwxMzUsMTM3LDE0NywxNzEsMjAwLDIwMSwyMDcsMjEyLDIxMywyMTQsMjE5LDIyMCwyMjksMjM4LDIzOSwyNDIsMjQzLDI0NiwyNDcsMjQ4XSxbMiwyOTVdKSxvKCRWajEsWzIsMzMxXSksezU6NTQzLDEwOiRWMX0sezExOlsxLDU0NF19LG8oJFZ2MixbMiwzMzddLHs2OlsxLDU0NV19KSx7MTM6NTQ2LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWajEsWzIsOTddKSx7MTA6JFZFMSwxMjoyMjgsMTM6MzYxLDE1OjIzMCwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTE5OjU0NywxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTM4OiRWeiwxMzk6JFZBLDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MDokVkosMTcxOiRWRzEsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjAyOjIyNiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHsxMDokVkUxLDEyOjIyOCwxMzozNjEsMTU6MjMwLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMTk6NTQ4LDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxMzg6JFZ6LDEzOTokVkEsMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTcwOiRWSiwxNzE6JFZHMSwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDI6MjI2LDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sbygkVjAyLFsyLDExNF0pLHsxMTQ6NTQ5LDExNjokVjEyfSx7OTA6WzEsNTUwXSwxMjY6JFY5MSwxNzE6JFZhMSwyMTE6MTQ5LDIxMjokVlUsMjE0OiRWViwyMTc6MTUwLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9LG8oJFZBMSxbMiwxMDVdKSx7OTA6WzEsNTUxXSwxMjY6JFY5MSwxNzE6JFZhMSwyMTE6MTQ5LDIxMjokVlUsMjE0OiRWViwyMTc6MTUwLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9LHs5MDpbMSw1NTJdLDEyNjokVjkxLDE3MTokVmExLDIxMToxNDksMjEyOiRWVSwyMTQ6JFZWLDIxNzoxNTAsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0sbygkVjAyLFsyLDExN10pLG8oJFYwMixbMiwxMThdLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDEyNjokVjkxLDE3MTokVmExLDIxMjokVlUsMjE0OiRWViwyMTk6JFZYLDIyMDokVlksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSxvKCRWajEsWzIsOThdKSxvKCRWajEsWzIsMTU4XSksbygkVnUxLFsyLDI2Nl0pLG8oJFZ1MSxbMiwyOThdKSxvKCRWdTEsWzIsMjczXSksbygkVjkyLFsyLDI3OV0pLG8oJFZ5MiwkVjcyLHsxMTU6NTUzLDE0OiRWODJ9KSxvKCRWOTIsWzIsMjgwXSksezExOiRWSDIsMTI6MjI4LDEzOjM2MSwxNToyMzAsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxMzg6JFZ6LDEzOTokVkEsMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTcwOiRWSiwxNzE6JFZHMSwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDI6NTE3LDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sbygkVk8xLFsyLDgzXSksbygkVk8xLFsyLDg0XSksezk3OlsxLDU1NF19LHs5NzpbMiw5M119LHs5NzpbMiw5NF19LHsxMzo1NTUsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oJFZ1MSxbMiwxNTVdKSxvKCRWQTIsWzIsMTg4XSksbygkVkEyLFsyLDE5NV0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMTI2OiRWOTEsMTcxOiRWYTEsMjEyOiRWVSwyMTQ6JFZWLDIxOTokVlgsMjIwOiRWWSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0pLHs5MDpbMSw1NTZdfSxvKCRWZzIsWzIsMjQ3XSksbygkVnkyLCRWNzIsezExNTo1NTcsMTQ6JFZmMn0pLHs2OiRWNTEsOTo0OTEsMTE6JFZGMiwxMjY6JFY5MSwxMzI6NTU4LDE3MTokVmExLDIxMToxNDksMjEyOiRWVSwyMTQ6JFZWLDIxNzoxNTAsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0sbyhbMSw2LDEwLDExLDE0LDIyLDcxLDkwLDk3LDEwNiwxMTIsMTM1LDEzNywxNDcsMjAwLDIwMSwyMTIsMjEzLDIxNCwyMTksMjIwLDIzOF0sWzIsMzI2XSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwxMjY6JFY5MSwxNzE6JFZhMSwyMjk6WzEsNTU5XSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0pLG8oJFZDMixbMiwzMjhdLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDEyNjokVjkxLDE3MTokVmExLDIxMzpbMSw1NjBdLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSksbygkVlkxLFsyLDMyN10sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMTI2OiRWOTEsMTcxOiRWYTEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSxvKCRWajEsWzIsMjU4XSksbygkVmoxLFsyLDEyOV0pLG8oJFZFMiwkVmIyLHsxNjc6Mzc1LDE1MDozNzYsMTY4OjM3NywxNjk6Mzc4LDUwOjM4MiwxNDY6NTYxLDUxOiRWOCw4OTokVncxLDk2OiRWUjEsMTcwOiRWYzIsMTcxOiRWZDIsMTcyOiRWZTJ9KSxvKCRWajEsWzIsMTY5XSksezE2Mjo1NjIsMTY0OiRWbzIsMTY1OiRWcDJ9LG8oJFZqMSxbMiwyODJdKSx7NjokVjUxLDk6NDkxLDExOiRWRjIsMTMyOjU2M30sbygkVmoxLFsyLDMzNF0pLG8oJFZ2MixbMiwzMzhdKSxvKCRWRzIsWzIsMjg5XSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwxMjY6JFY5MSwxNzE6JFZhMSwyMTI6JFZVLDIxNDokVlYsMjE5OiRWWCwyMjA6JFZZLDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSksbygkVkkyLCRWNzIsezExNTo1NjUsMTE6WzEsNTY0XSwxNDokVjgyfSksbygkVkkyLCRWNzIsezExNTo1NjUsMTQ6JFY4MiwyMjpbMSw1NjZdfSksbygkVjAyLFsyLDExNV0pLG8oJFZBMSxbMiwxMDddKSxvKCRWQTEsWzIsMTA4XSksbygkVkExLFsyLDExMV0pLHs2OiRWNTEsOTo1MjAsMTA6JFZ3MiwxMTokVkYyLDEzMjo1Njd9LG8oJFZPMSxbMiw5MF0pLHs5MDpbMSw1NjhdLDEyNjokVjkxLDE3MTokVmExLDIxMToxNDksMjEyOiRWVSwyMTQ6JFZWLDIxNzoxNTAsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0sbygkVnUxLFsyLDE1Nl0pLHs2OiRWNTEsOTo1NzAsMTA6JFZCMiwxMTokVkYyLDEzMjo1Njl9LG8oJFZnMixbMiwxNDBdKSx7MTM6NTcxLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTM6NTcyLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTQ6JFZ6MiwyMjpbMSw1NzNdfSxvKCRWajEsWzIsMTcwXSksbygkVmoxLFsyLDMzMl0pLG8oJFZqMSxbMiwxMTldKSx7NjokVjUxLDk6NDUyLDEwOiRWdzJ9LG8oJFZqMSxbMiwxMjBdKSxvKCRWOTIsWzIsMjgxXSksezk3OlsyLDk1XX0sbygkVmcyLFsyLDI0OF0pLHsxMTokVkgyLDE1OjI1MSwzMjokVjcsNTA6MjUyLDUxOiRWOCw1MjoyNTUsNTM6JFY5LDU0OiRWYSw1NToyNTYsNTY6JFZiLDU3OjI1Myw1ODokVmMsNjE6MTE2LDYyOiRWZSw2MzoyNTQsNjQ6JFZmLDY1OjExNyw2NjokVmcsMTMzOjUzMSwxMzQ6MjUwLDEzNjokVkoxLDEzODokVnosMTM5OiRWQX0sbygkVlkxLFsyLDMyOV0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMTI2OiRWOTEsMTcxOiRWYTEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSxvKCRWWTEsWzIsMzMwXSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwxMjY6JFY5MSwxNzE6JFZhMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0pLHsxNjI6NTc0LDE2NDokVm8yLDE2NTokVnAyfSxvKCRWajEsWzIsMTY4XSldLFxuZGVmYXVsdEFjdGlvbnM6IHsxMzU6WzIsM10sMTYzOlsyLDI2NF0sMzI0OlsyLDI0Ml0sNTI0OlsyLDkzXSw1MjU6WzIsOTRdLDU2ODpbMiw5NV19LFxucGFyc2VFcnJvcjogZnVuY3Rpb24gcGFyc2VFcnJvcihzdHIsIGhhc2gpIHtcbiAgICBpZiAoaGFzaC5yZWNvdmVyYWJsZSkge1xuICAgICAgICB0aGlzLnRyYWNlKHN0cik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHN0cik7XG4gICAgfVxufSxcbnBhcnNlOiBmdW5jdGlvbiBwYXJzZShpbnB1dCkge1xuXG4gICAgLy8gRm9yIEltYmEgd2UgYXJlIGdvaW5nIHRvIGRyb3AgbW9zdCBvZiB0aGUgZmVhdHVyZXMgdGhhdCBhcmUgbm90IHVzZWRcbiAgICAvLyBMb2NhdGlvbnMgYXJlIHByb3ZpZGVkIGJ5IHRoZSB0b2tlbnMgZnJvbSB0aGUgbGV4ZXIgZGlyZWN0bHkgLSBzbyBkcm9wIHl5bGxvY1xuICAgIC8vIFdlIGRvbnQgcmVhbGx5IG5lZWQgdGhlIHNoYXJlZCBzdGF0ZSAoaXQgc2VlbXMpXG5cbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIHN0YWNrID0gWzBdLFxuICAgICAgICB0c3RhY2sgPSBbXSwgLy8gdG9rZW4gc3RhY2tcbiAgICAgICAgdnN0YWNrID0gW251bGxdLCAvLyBzZW1hbnRpYyB2YWx1ZSBzdGFja1xuICAgICAgICB0YWJsZSA9IHRoaXMudGFibGUsXG4gICAgICAgIHl5dGV4dCA9ICcnLFxuICAgICAgICB5eWxpbmVubyA9IDAsXG4gICAgICAgIHl5bGVuZyA9IDAsXG4gICAgICAgIHJlY292ZXJpbmcgPSAwLFxuICAgICAgICBURVJST1IgPSAyLFxuICAgICAgICBFT0YgPSAxO1xuXG4gICAgLy8gdmFyIGFyZ3MgPSBsc3RhY2suc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIC8vdGhpcy5yZWR1Y3Rpb25Db3VudCA9IHRoaXMuc2hpZnRDb3VudCA9IDA7XG5cbiAgICB2YXIgbGV4ZXIgPSBPYmplY3QuY3JlYXRlKHRoaXMubGV4ZXIpO1xuICAgIHZhciB5eSA9IHRoaXMueXk7XG5cbiAgICBsZXhlci5zZXRJbnB1dChpbnB1dCx5eSk7XG5cbiAgICBpZiAodHlwZW9mIHl5LnBhcnNlRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5wYXJzZUVycm9yID0geXkucGFyc2VFcnJvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhcnNlRXJyb3IgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykucGFyc2VFcnJvcjsgLy8gd2hhdD9cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb3BTdGFjayAobikge1xuICAgICAgICBzdGFjay5sZW5ndGggPSBzdGFjay5sZW5ndGggLSAyICogbjtcbiAgICAgICAgdnN0YWNrLmxlbmd0aCA9IHZzdGFjay5sZW5ndGggLSBuO1xuICAgIH1cblxuICAgIHZhciBzeW1ib2wsIHByZUVycm9yU3ltYm9sLCBzdGF0ZSwgYWN0aW9uLCBhLCByLCB5eXZhbCA9IHt9LCBwLCBsZW4sIG5ld1N0YXRlLCBleHBlY3RlZDtcblxuICAgIGZ1bmN0aW9uIGhhbmRsZUVycm9yKCl7XG4gICAgICAgIHZhciBlcnJvcl9ydWxlX2RlcHRoO1xuICAgICAgICB2YXIgZXJyU3RyID0gJyc7XG5cbiAgICAgICAgLy8gUmV0dXJuIHRoZSBydWxlIHN0YWNrIGRlcHRoIHdoZXJlIHRoZSBuZWFyZXN0IGVycm9yIHJ1bGUgY2FuIGJlIGZvdW5kLlxuICAgICAgICAvLyBSZXR1cm4gRkFMU0Ugd2hlbiBubyBlcnJvciByZWNvdmVyeSBydWxlIHdhcyBmb3VuZC5cbiAgICAgICAgLy8gd2UgaGF2ZSBubyBydWxlcyBub3dcbiAgICAgICAgZnVuY3Rpb24gbG9jYXRlTmVhcmVzdEVycm9yUmVjb3ZlcnlSdWxlKHN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgc3RhY2tfcHJvYmUgPSBzdGFjay5sZW5ndGggLSAxO1xuICAgICAgICAgICAgdmFyIGRlcHRoID0gMDtcblxuICAgICAgICAgICAgLy8gdHJ5IHRvIHJlY292ZXIgZnJvbSBlcnJvclxuICAgICAgICAgICAgZm9yKDs7KSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGVycm9yIHJlY292ZXJ5IHJ1bGUgaW4gdGhpcyBzdGF0ZVxuICAgICAgICAgICAgICAgIGlmICgoVEVSUk9SLnRvU3RyaW5nKCkpIGluIHRhYmxlW3N0YXRlXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVwdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gMCB8fCBzdGFja19wcm9iZSA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBObyBzdWl0YWJsZSBlcnJvciByZWNvdmVyeSBydWxlIGF2YWlsYWJsZS5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhY2tfcHJvYmUgLT0gMjsgLy8gcG9wU3RhY2soMSk6IFtzeW1ib2wsIGFjdGlvbl1cbiAgICAgICAgICAgICAgICBzdGF0ZSA9IHN0YWNrW3N0YWNrX3Byb2JlXTtcbiAgICAgICAgICAgICAgICArK2RlcHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyZWNvdmVyaW5nKSB7XG4gICAgICAgICAgICAvLyBmaXJzdCBzZWUgaWYgdGhlcmUncyBhbnkgY2hhbmNlIGF0IGhpdHRpbmcgYW4gZXJyb3IgcmVjb3ZlcnkgcnVsZTpcbiAgICAgICAgICAgIGVycm9yX3J1bGVfZGVwdGggPSBsb2NhdGVOZWFyZXN0RXJyb3JSZWNvdmVyeVJ1bGUoc3RhdGUpO1xuXG4gICAgICAgICAgICAvLyBSZXBvcnQgZXJyb3JcbiAgICAgICAgICAgIGV4cGVjdGVkID0gW107XG5cbiAgICAgICAgICAgIHZhciB0c3ltID0gbGV4ZXIueXl0ZXh0O1xuICAgICAgICAgICAgdmFyIHRvayA9IHNlbGYudGVybWluYWxzX1tzeW1ib2xdIHx8IHN5bWJvbDtcbiAgICAgICAgICAgIHZhciB0bG9jID0gdHN5bSA/IHRzeW0uX2xvYyA6IC0xO1xuICAgICAgICAgICAgdmFyIHRwb3MgPSB0bG9jICE9IC0xID8gXCJbXCIgKyB0c3ltLl9sb2MgKyBcIjpcIiArIHRzeW0uX2xlbiArIFwiXVwiIDogJ1swOjBdJztcblxuICAgICAgICAgICAgaWYgKGxleGVyLnNob3dQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIGVyclN0ciA9ICdQYXJzZSBlcnJvciBhdCAnKyh0cG9zKStcIjpcXG5cIitsZXhlci5zaG93UG9zaXRpb24oKStcIlxcbkV4cGVjdGluZyBcIitleHBlY3RlZC5qb2luKCcsICcpICsgXCIsIGdvdCAnXCIgKyAoc2VsZi50ZXJtaW5hbHNfW3N5bWJvbF0gfHwgc3ltYm9sKSsgXCInXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVyclN0ciA9ICdQYXJzZSBlcnJvciBhdCAnKyh0cG9zKStcIjogVW5leHBlY3RlZCBcIiArIChzeW1ib2wgPT0gRU9GID8gXCJlbmQgb2YgaW5wdXRcIiA6IChcIidcIisodG9rKStcIidcIikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLnBhcnNlRXJyb3IoZXJyU3RyLCB7XG4gICAgICAgICAgICAgICAgbGV4ZXI6IGxleGVyLFxuICAgICAgICAgICAgICAgIHRleHQ6IGxleGVyLm1hdGNoLFxuICAgICAgICAgICAgICAgIHRva2VuOiB0b2ssXG4gICAgICAgICAgICAgICAgbGluZTogbGV4ZXIueXlsaW5lbm8sXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgICAgICAgICAgIHJlY292ZXJhYmxlOiAoZXJyb3JfcnVsZV9kZXB0aCAhPT0gZmFsc2UpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChwcmVFcnJvclN5bWJvbCAhPT0gRU9GKSB7XG4gICAgICAgICAgICBlcnJvcl9ydWxlX2RlcHRoID0gbG9jYXRlTmVhcmVzdEVycm9yUmVjb3ZlcnlSdWxlKHN0YXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGp1c3QgcmVjb3ZlcmVkIGZyb20gYW5vdGhlciBlcnJvclxuICAgICAgICBpZiAocmVjb3ZlcmluZyA9PSAzKSB7XG4gICAgICAgICAgICBpZiAoc3ltYm9sID09PSBFT0YgfHwgcHJlRXJyb3JTeW1ib2wgPT09IEVPRikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJTdHIgfHwgJ1BhcnNpbmcgaGFsdGVkIHdoaWxlIHN0YXJ0aW5nIHRvIHJlY292ZXIgZnJvbSBhbm90aGVyIGVycm9yLicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBkaXNjYXJkIGN1cnJlbnQgbG9va2FoZWFkIGFuZCBncmFiIGFub3RoZXJcbiAgICAgICAgICAgIHl5dGV4dCA9IGxleGVyLnl5dGV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyeSB0byByZWNvdmVyIGZyb20gZXJyb3JcbiAgICAgICAgaWYgKGVycm9yX3J1bGVfZGVwdGggPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyU3RyIHx8ICdQYXJzaW5nIGhhbHRlZC4gTm8gc3VpdGFibGUgZXJyb3IgcmVjb3ZlcnkgcnVsZSBhdmFpbGFibGUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcG9wU3RhY2soZXJyb3JfcnVsZV9kZXB0aCk7XG4gICAgICAgIHByZUVycm9yU3ltYm9sID0gKHN5bWJvbCA9PSBURVJST1IgPyBudWxsIDogc3ltYm9sKTsgLy8gc2F2ZSB0aGUgbG9va2FoZWFkIHRva2VuXG4gICAgICAgIHN5bWJvbCA9IFRFUlJPUjsgICAgICAgICAvLyBpbnNlcnQgZ2VuZXJpYyBlcnJvciBzeW1ib2wgYXMgbmV3IGxvb2thaGVhZFxuICAgICAgICBzdGF0ZSA9IHN0YWNrW3N0YWNrLmxlbmd0aC0xXTtcbiAgICAgICAgYWN0aW9uID0gdGFibGVbc3RhdGVdICYmIHRhYmxlW3N0YXRlXVtURVJST1JdO1xuICAgICAgICByZWNvdmVyaW5nID0gMzsgLy8gYWxsb3cgMyByZWFsIHN5bWJvbHMgdG8gYmUgc2hpZnRlZCBiZWZvcmUgcmVwb3J0aW5nIGEgbmV3IGVycm9yXG4gICAgfVxuXG5cbiAgICB2YXIgX19zeW0gPSB0aGlzLnN5bWJvbHNfO1xuICAgIHZhciBfX3Byb2QgPSB0aGlzLnByb2R1Y3Rpb25zXztcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIC8vIHJldHJlaXZlIHN0YXRlIG51bWJlciBmcm9tIHRvcCBvZiBzdGFja1xuICAgICAgICBzdGF0ZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmIChzeW1ib2wgPT09IG51bGwgfHwgdHlwZW9mIHN5bWJvbCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgc3ltYm9sID0gX19zeW1bbGV4ZXIubGV4KCldIHx8IEVPRjtcbiAgICAgICAgfVxuICAgICAgICBhY3Rpb24gPSB0YWJsZVtzdGF0ZV0gJiYgdGFibGVbc3RhdGVdW3N5bWJvbF07XG5cbl9oYW5kbGVfZXJyb3I6XG4gICAgICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSAndW5kZWZpbmVkJyB8fCAhYWN0aW9uLmxlbmd0aCB8fCAhYWN0aW9uWzBdKSB7XG4gICAgICAgICAgICBoYW5kbGVFcnJvcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChhY3Rpb25bMF0pIHtcbiAgICAgICAgICAgIGNhc2UgMTogLy8gc2hpZnRcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHN5bWJvbCk7XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChhY3Rpb25bMV0pOyAvLyBwdXNoIHN0YXRlXG4gICAgICAgICAgICAgICAgdnN0YWNrLnB1c2gobGV4ZXIueXl0ZXh0KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghcHJlRXJyb3JTeW1ib2wpIHsgLy8gbm9ybWFsIGV4ZWN1dGlvbi9ubyBlcnJvclxuICAgICAgICAgICAgICAgICAgICB5eXRleHQgPSBsZXhlci55eXRleHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNvdmVyaW5nID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3ZlcmluZy0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXJyb3IganVzdCBvY2N1cnJlZCwgcmVzdW1lIG9sZCBsb29rYWhlYWQgZi8gYmVmb3JlIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IHByZUVycm9yU3ltYm9sO1xuICAgICAgICAgICAgICAgICAgICBwcmVFcnJvclN5bWJvbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgbGVuID0gX19wcm9kW2FjdGlvblsxXV1bMV07XG4gICAgICAgICAgICAgICAgLy8gcGVyZm9ybSBzZW1hbnRpYyBhY3Rpb25cbiAgICAgICAgICAgICAgICB5eXZhbC4kID0gdnN0YWNrW3ZzdGFjay5sZW5ndGgtbGVuXTtcbiAgICAgICAgICAgICAgICByID0gdGhpcy5wZXJmb3JtQWN0aW9uKHl5dmFsLCB5eXRleHQsIHl5LCBhY3Rpb25bMV0sIHZzdGFjayk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB3aGlsZShsZW4gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgdnN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBsZW4tLTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKF9fcHJvZFthY3Rpb25bMV1dWzBdKTtcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IHRhYmxlW3N0YWNrW3N0YWNrLmxlbmd0aC0yXV1bc3RhY2tbc3RhY2subGVuZ3RoLTFdXTtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKG5ld1N0YXRlKTtcbiAgICAgICAgICAgICAgICB2c3RhY2sucHVzaCh5eXZhbC4kKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59fTtcblxuZnVuY3Rpb24gUGFyc2VyICgpIHtcbiAgdGhpcy55eSA9IHt9O1xufVxuUGFyc2VyLnByb3RvdHlwZSA9IHBhcnNlcjtwYXJzZXIuUGFyc2VyID0gUGFyc2VyO1xucmV0dXJuIG5ldyBQYXJzZXI7XG59KSgpO1xuXG5cbmlmICh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG5leHBvcnRzLnBhcnNlciA9IHBhcnNlcjtcbmV4cG9ydHMuUGFyc2VyID0gcGFyc2VyLlBhcnNlcjtcbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBwYXJzZXIucGFyc2UuYXBwbHkocGFyc2VyLCBhcmd1bWVudHMpOyB9O1xuLy8gZXhwb3J0cy5tYWluID0gZnVuY3Rpb24gY29tbW9uanNNYWluKGFyZ3MpIHtcbi8vICAgICBpZiAoIWFyZ3NbMV0pIHtcbi8vICAgICAgICAgY29uc29sZS5sb2coJ1VzYWdlOiAnK2FyZ3NbMF0rJyBGSUxFJyk7XG4vLyAgICAgICAgIHByb2Nlc3MuZXhpdCgxKTtcbi8vICAgICB9XG4vLyAgICAgdmFyIHNvdXJjZSA9IHJlcXVpcmUoJ2ZzJykucmVhZEZpbGVTeW5jKHJlcXVpcmUoJ3BhdGgnKS5ub3JtYWxpemUoYXJnc1sxXSksIFwidXRmOFwiKTtcbi8vICAgICByZXR1cm4gZXhwb3J0cy5wYXJzZXIucGFyc2Uoc291cmNlKTtcbi8vIH07XG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgcmVxdWlyZS5tYWluID09PSBtb2R1bGUpIHtcbiAgZXhwb3J0cy5tYWluKHByb2Nlc3MuYXJndi5zbGljZSgxKSk7XG59XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9jb21waWxlci9wYXJzZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdGlmKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XHJcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xyXG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59XHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzXG4gKiogbW9kdWxlIGlkID0gN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS9+L25vZGUtbGlicy1icm93c2VyL34vcHJvY2Vzcy9icm93c2VyLmpzXG4gKiogbW9kdWxlIGlkID0gOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiIyBUT0RPIENyZWF0ZSBFeHByZXNzaW9uIC0gbWFrZSBhbGwgZXhwcmVzc2lvbnMgaW5oZXJpdCBmcm9tIHRoZXNlP1xuXG5leHRlcm4gcGFyc2VJbnRcblxudmFyIGhlbHBlcnMgPSByZXF1aXJlICcuL2hlbHBlcnMnXG52YXIgRVJSID0gcmVxdWlyZSAnLi9lcnJvcnMnXG52YXIgdjggPSBudWxsICMgcmVxdWlyZSAndjgtbmF0aXZlcydcblxudmFyIFQgPSByZXF1aXJlICcuL3Rva2VuJ1xudmFyIFRva2VuID0gVC5Ub2tlblxuXG5pbXBvcnQgU291cmNlTWFwIGZyb20gJy4vc291cmNlbWFwJ1xuXG5leHBvcnQgdmFyIEFTVCA9IHt9XG5cbiMgSGVscGVycyBmb3Igb3BlcmF0b3JzXG5leHBvcnQgdmFyIE9QID0gZG8gfG9wLCBsLCByfFxuXHR2YXIgbyA9IFN0cmluZyhvcClcblx0IyBjb25zb2xlLmxvZyBcIm9wZXJhdG9yXCIsb1xuXHRzd2l0Y2ggb1xuXHRcdHdoZW4gJy4nXG5cdFx0XHRyID0gSWRlbnRpZmllci5uZXcocikgaWYgciBpc2EgU3RyaW5nXG5cdFx0XHQjIHIgPSByLnZhbHVlIGlmIHIgaXNhIFZhck9yQWNjZXNzXG5cdFx0XHRBY2Nlc3MubmV3KG9wLGwscilcblx0XHR3aGVuICc9J1xuXHRcdFx0cmV0dXJuIFR1cGxlQXNzaWduLm5ldyhvcCxsLHIpIGlmIGwgaXNhIFR1cGxlXG5cdFx0XHRBc3NpZ24ubmV3KG9wLGwscilcblxuXHRcdHdoZW4gJz89JywnfHw9JywnJiY9J1xuXHRcdFx0Q29uZGl0aW9uYWxBc3NpZ24ubmV3KG9wLGwscilcblx0XHR3aGVuICcrPScsJy09JywnKj0nLCcvPScsJ149JywnJT0nXG5cdFx0XHRDb21wb3VuZEFzc2lnbi5uZXcob3AsbCxyKVxuXG5cdFx0d2hlbiAnPy4nXG5cdFx0XHRpZiByIGlzYSBWYXJPckFjY2Vzc1xuXHRcdFx0XHQjIGNvbnNvbGUubG9nIFwiaXMgdmFyIG9yIGFjY2Vzc1wiXG5cdFx0XHRcdHIgPSByLnZhbHVlXG5cdFx0XHQjIGRlcGVuZHMgb24gdGhlIHJpZ2h0IHNpZGUgLSB0aGlzIGlzIHdyb25nXG5cdFx0XHRQcm9wZXJ0eUFjY2Vzcy5uZXcob3AsbCxyKVxuXG5cdFx0d2hlbiAnaW5zdGFuY2VvZidcblx0XHRcdEluc3RhbmNlT2YubmV3KG9wLGwscilcblx0XHR3aGVuICdpbidcblx0XHRcdEluLm5ldyhvcCxsLHIpXG5cdFx0d2hlbiAndHlwZW9mJ1xuXHRcdFx0VHlwZU9mLm5ldyhvcCxsLHIpXG5cdFx0d2hlbiAnZGVsZXRlJ1xuXHRcdFx0RGVsZXRlLm5ldyhvcCxsLHIpXG5cdFx0d2hlbiAnLS0nLCcrKycsJyEnLCfiiJonXG5cdFx0XHRVbmFyeU9wLm5ldyhvcCxsLHIpXG5cdFx0d2hlbiAnPicsJzwnLCc+PScsJzw9JywnPT0nLCc9PT0nLCchPScsJyE9PSdcblx0XHRcdENvbXBhcmlzb25PcC5uZXcob3AsbCxyKVxuXHRcdHdoZW4gJ+KIqScsJ+KIqidcblx0XHRcdE1hdGhPcC5uZXcob3AsbCxyKVxuXHRcdHdoZW4gJy4uJywnLi4uJ1xuXHRcdFx0UmFuZ2UubmV3KG9wLGwscilcblx0XHRlbHNlXG5cdFx0XHRPcC5uZXcob3AsbCxyKVxuXG5leHBvcnQgdmFyIE9QX0NPTVBPVU5EID0gZG8gfHN5bSxvcCxsLHJ8XG5cdCMgY29uc29sZS5sb2cgXCI/LiBzb2FrIG9wZXJhdG9yXCIsc3ltXG5cdGlmIHN5bSA9PSAnPy4nXG5cdFx0Y29uc29sZS5sb2cgXCI/LiBzb2FrIG9wZXJhdG9yXCJcblx0XHRyZXR1cm4gbnVsbFxuXHRpZiBzeW0gPT0gJz89JyBvciBzeW0gPT0gJ3x8PScgb3Igc3ltID09ICcmJj0nXG5cdFx0cmV0dXJuIENvbmRpdGlvbmFsQXNzaWduLm5ldyhvcCxsLHIpXG5cdGVsc2Vcblx0XHRyZXR1cm4gQ29tcG91bmRBc3NpZ24ubmV3KG9wLGwscilcblxudmFyIE9QVFMgPSB7fVxudmFyIFJPT1QgPSBudWxsXG5cbmV4cG9ydCB2YXIgTk9ERVMgPSBbXVxuXG52YXIgTElUID0gZG8gfHZhbHxcblx0TGl0ZXJhbC5uZXcodmFsKVxuXG52YXIgU1lNID0gZG8gfHZhbHxcblx0U3ltYm9sLm5ldyh2YWwpXG5cbnZhciBJRiA9IGRvIHxjb25kLGJvZHksYWx0fFxuXHR2YXIgbm9kZSA9IElmLm5ldyhjb25kLGJvZHkpXG5cdG5vZGUuYWRkRWxzZShhbHQpIGlmIGFsdFxuXHRub2RlXG5cbnZhciBGTiA9IGRvIHxwYXJzLGJvZHl8XG5cdEZ1bmMubmV3KHBhcnMsYm9keSlcblxudmFyIENBTEwgPSBkbyB8Y2FsbGVlLHBhcnMgPSBbXXxcblx0IyBwb3NzaWJseSByZXR1cm4gaW5zdGVhZCghKVxuXHRDYWxsLm5ldyhjYWxsZWUscGFycylcblxudmFyIENBTExTRUxGID0gZG8gfG5hbWUscGFycyA9IFtdfFxuXHR2YXIgcmVmID0gSWRlbnRpZmllci5uZXcobmFtZSlcblx0Q2FsbC5uZXcoT1AoJy4nLFNFTEYscmVmKSxwYXJzKVxuXG52YXIgQkxPQ0sgPSBkb1xuXHRCbG9jay53cmFwKFtdOnNsaWNlLmNhbGwoYXJndW1lbnRzKSlcblxudmFyIFdISUxFID0gZG8gfHRlc3QsY29kZXxcblx0V2hpbGUubmV3KHRlc3QpLmFkZEJvZHkoY29kZSlcblxuZXhwb3J0IHZhciBTUExBVCA9IGRvIHx2YWx1ZXxcblx0aWYgdmFsdWUgaXNhIEFzc2lnblxuXHRcdCMgcCBcIldBUk5cIlxuXHRcdHZhbHVlLmxlZnQgPSBTcGxhdC5uZXcodmFsdWUubGVmdClcblx0XHRyZXR1cm4gdmFsdWVcblx0ZWxzZVxuXHRcdFNwbGF0Lm5ldyh2YWx1ZSlcblx0XHQjIG5vdCBzdXJlIGFib3V0IHRoaXNcblxuIyBPUC5BU1NJR05NRU5UID0gWyBcIj1cIiAsIFwiKz1cIiAsIFwiLT1cIiAsIFwiKj1cIiAsIFwiLz1cIiAsIFwiJT1cIiwgXCI8PD1cIiAsIFwiPj49XCIgLCBcIj4+Pj1cIiwgXCJ8PVwiICwgXCJePVwiICwgXCImPVwiIF1cbiMgT1AuTE9HSUNBTCA9IFsgXCJ8fFwiICwgXCImJlwiIF1cbiMgT1AuVU5BUlkgPSBbIFwiKytcIiAsIFwiLS1cIiBdXG5cbnZhciBTRU1JQ09MT05fVEVTVCA9IC87KFxccypcXC9cXC8uKik/W1xcblxcc1xcdF0qJC9cbnZhciBSRVNFUlZFRF9URVNUID0gL14oZGVmYXVsdHxjaGFyKSQvXG5cbiMgY2FwdHVyZXMgZXJyb3IgZnJvbSBwYXJzZXJcbmV4cG9ydCBkZWYgcGFyc2VFcnJvciBzdHIsIG9cblx0IyBjb25zb2xlLmxvZyAncGFyc2VFcnJvcicsbzp0b2tlblxuXG5cdCMgZmluZCBuZWFyZXN0IHRva2VuXG5cdHZhciBlcnJcblxuXHRpZiBvOmxleGVyXG5cdFx0dmFyIHRva2VuID0gbzpsZXhlcjp5eXRleHRcblx0XHQjIGNvbnNvbGUubG9nIG86bGV4ZXI6cG9zLHRva2VuLkBsb2Ncblx0XHRlcnIgPSBFUlIuSW1iYVBhcnNlRXJyb3IubmV3KHttZXNzYWdlOiBzdHJ9LHtcblx0XHRcdHBvczogbzpsZXhlcjpwb3Ncblx0XHRcdHRva2VuczogbzpsZXhlcjp0b2tlbnNcblx0XHRcdHRva2VuOiBvOmxleGVyOnl5dGV4dFxuXHRcdFx0bWV0YTogb1xuXHRcdH0pXG5cblx0XHR0aHJvdyBlcnJcblxuXHRcdCMgc2hvdWxkIGZpbmQgdGhlIGNsb3Nlc3QgdG9rZW4gd2l0aCBhY3R1YWwgcG9zaXRpb25cblx0XHQjIHN0ciA9IFwiW3t0b2tlbi5AbG9jfTp7dG9rZW4uQGxlbiB8fCBTdHJpbmcodG9rZW4pOmxlbmd0aH1dIHtzdHJ9XCJcblx0dmFyIGUgPSBFcnJvci5uZXcoc3RyKVxuXHRlOmxleGVyID0gbzpsZXhlclxuXHRlOm9wdGlvbnMgPSBvXG5cdHRocm93IGVcblxuZGVmIGNfXyBvYmpcblx0dHlwZW9mIG9iaiA9PSAnc3RyaW5nJyA/IG9iaiA6IG9iai5jXG5cbmRlZiBtYXJrX18gdG9rXG5cdGlmIHRvayBhbmQgKE9QVFM6c291cmNlTWFwSW5saW5lIG9yIE9QVFM6c291cmNlTWFwKSBhbmQgdG9rOnNvdXJjZU1hcE1hcmtlclxuXHRcdHRvay5zb3VyY2VNYXBNYXJrZXJcblx0ZWxzZVxuXHRcdCcnXG5cbmRlZiBudW1fXyBudW1cblx0TnVtLm5ldyhudW0pXG5cbmRlZiBzdHJfXyBzdHJcblx0IyBzaG91bGQgcGFjayBpbiB0b2tlbj8hP1xuXHRTdHIubmV3KHN0cilcblxuZGVmIGJsa19fIG9ialxuXHRvYmogaXNhIEFycmF5ID8gQmxvY2sud3JhcChvYmopIDogb2JqXG5cbmRlZiBzeW1fXyBvYmpcblx0IyBjb25zb2xlLmxvZyBcInN5bSB7b2JqfVwiXG5cdGhlbHBlcnMuc3ltYm9saXplKFN0cmluZyhvYmopKVxuXG5kZWYgY2FyeV9fIGFyeVxuXHRhcnkubWFwKHx2fCB0eXBlb2YgdiA9PSAnc3RyaW5nJyA/IHYgOiB2LmMgKVxuXG5kZWYgZHVtcF9fIG9iaiwga2V5XG5cdGlmIG9iaiBpc2EgQXJyYXlcblx0XHRvYmoubWFwIGRvIHx2fCB2ICYmIHY6ZHVtcCA/IHYuZHVtcChrZXkpIDogdlxuXHRlbGlmIG9iaiBhbmQgb2JqOmR1bXBcblx0XHRvYmouZHVtcFxuXG5kZWYgY29tcGFjdF9fIGFyeVxuXHRpZiBhcnkgaXNhIExpc3ROb2RlXG5cdFx0cmV0dXJuIGFyeS5jb21wYWN0XG5cblx0YXJ5LmZpbHRlciBkbyB8dnwgdiAhPSB1bmRlZmluZWQgJiYgdiAhPSBudWxsXG5cbmRlZiByZWR1Y2VfXyByZXMsYXJ5XG5cdGZvciB2IGluIGFyeVxuXHRcdHYgaXNhIEFycmF5ID8gcmVkdWNlX18ocmVzLHYpIDogcmVzLnB1c2godilcblx0cmV0dXJuXG5cbmRlZiBmbGF0dGVuX18gYXJ5LCBjb21wYWN0ID0gbm9cblx0dmFyIG91dCA9IFtdXG5cdGZvciB2IGluIGFyeVxuXHRcdHYgaXNhIEFycmF5ID8gcmVkdWNlX18ob3V0LHYpIDogb3V0LnB1c2godilcblx0cmV0dXJuIG91dFxuXHRcbmRlZiBBU1QucGFyc2Ugc3RyLCBvcHRzID0ge31cblx0dmFyIGluZGVudCA9IHN0ci5tYXRjaCgvXFx0Ky8pWzBdXG5cdCMgcmVhbGx5PyBSZXF1aXJlIHRoZSBjb21waWxlciwgbm90IHRoaXNcblx0SW1iYWMucGFyc2Uoc3RyLG9wdHMpXG5cbmRlZiBBU1QuaW5saW5lIHN0ciwgb3B0cyA9IHt9XG5cdHBhcnNlKHN0cixvcHRzKS5ib2R5XG5cbmRlZiBBU1Qubm9kZSB0eXAsIHBhcnNcblx0aWYgdHlwID09ICdjYWxsJ1xuXHRcdGlmIHBhcnNbMF0uYyA9PSAncmV0dXJuJ1xuXHRcdFx0cGFyc1swXSA9ICd0YXRhJ1x0XG5cdFx0Q2FsbC5uZXcocGFyc1swXSxwYXJzWzFdLHBhcnNbMl0pXG5cblxuZGVmIEFTVC5lc2NhcGVDb21tZW50cyBzdHJcblx0cmV0dXJuICcnIHVubGVzcyBzdHJcblx0cmV0dXJuIHN0clxuXG5leHBvcnQgY2xhc3MgSW5kZW50YXRpb25cblxuXHRwcm9wIG9wZW5cblx0cHJvcCBjbG9zZVxuXG5cdGRlZiBpbml0aWFsaXplIGEsYlxuXHRcdEBvcGVuID0gYVxuXHRcdEBjbG9zZSA9IGJcblx0XHRzZWxmXG5cblx0ZGVmIGlzR2VuZXJhdGVkXG5cdFx0QG9wZW4gYW5kIEBvcGVuOmdlbmVyYXRlZFxuXG5cdGRlZiBhbG9jXG5cdFx0QG9wZW4gYW5kIEBvcGVuLkBsb2Mgb3IgMFxuXG5cdGRlZiBibG9jXG5cdFx0QGNsb3NlIGFuZCBAY2xvc2UuQGxvYyBvciAwXG5cblx0IyBzaG91bGQgcmF0aGVyIHBhcnNlIGFuZCBleHRyYWN0IHRoZSBjb21tZW50cywgbm8/XG5cdGRlZiB3cmFwIHN0clxuXHRcdCMgdmFyIHByZSwgcG9zdFxuXHRcblx0XHQjIGNvbnNvbGUubG9nIFwiSU5ERU5UIHtAb3BlbiBhbmQgSlNPTi5zdHJpbmdpZnkoQG9wZW4uQG1ldGEpfVwiXG5cdFx0IyBjb25zb2xlLmxvZyBcIk9VVERFTlQge0BjbG9zZX1cIlxuXHRcdCMgdmFyIG92ID0gQG9wZW4gYW5kIEBvcGVuLkB2YWx1ZVxuXHRcdCMgaWYgb3YgYW5kIG92Omxlbmd0aCA+IDFcblx0XHQjIFx0Y29uc29sZS5sb2cgXCJ2YWx1ZSBmb3IgaW5kZW50XCIsb3Zcblx0XHQjIFx0aWYgb3YuaW5kZXhPZignJXwlJylcblx0XHQjIFx0XHRwcmUgPSBvdi5zdWJzdHJcblx0XHR2YXIgb20gPSBAb3BlbiBhbmQgQG9wZW4uQG1ldGFcblx0XHR2YXIgcHJlID0gb20gYW5kIG9tOnByZSBvciAnJ1xuXHRcdHZhciBwb3N0ID0gb20gYW5kIG9tOnBvc3Qgb3IgJydcblx0XHR2YXIgZXNjID0gQVNUOmVzY2FwZUNvbW1lbnRzXG5cdFx0dmFyIG91dCA9IEBjbG9zZVxuXG5cdFx0IyB0aGUgZmlyc3QgbmV3bGluZSBzaG91bGQgbm90IGJlIGluZGVudGVkP1xuXHRcdHN0ciA9IHBvc3QucmVwbGFjZSgvXlxcbi8sJycpICsgc3RyXG5cdFx0c3RyID0gc3RyLnJlcGxhY2UoL14vZyxcIlxcdFwiKS5yZXBsYWNlKC9cXG4vZyxcIlxcblxcdFwiKS5yZXBsYWNlKC9cXG5cXHQkL2csXCJcXG5cIilcblxuXHRcdHN0ciA9IHByZSArICdcXG4nICsgc3RyXG5cdFx0c3RyICs9IG91dC5jIGlmIG91dCBpc2EgVGVybWluYXRvclxuXHRcdHN0ciA9IHN0ciArICdcXG4nIHVubGVzcyBzdHJbc3RyOmxlbmd0aCAtIDFdID09ICdcXG4nXG5cdFx0cmV0dXJuIHN0clxuXHRcdFxudmFyIElOREVOVCA9IEluZGVudGF0aW9uLm5ldyh7fSx7fSlcblxuY2xhc3MgU3Rhc2hcblxuXHRkZWYgaW5pdGlhbGl6ZVxuXHRcdEBlbnRpdGllcyA9IFtdXG5cblx0ZGVmIGFkZCBpdGVtXG5cdFx0QGVudGl0aWVzLnVuc2hpZnQoaXRlbSlcblx0XHRzZWxmXG5cblx0ZGVmIHBsdWNrIGl0ZW1cblx0XHR2YXIgbWF0Y2ggPSBudWxsXG5cdFx0Zm9yIGVudGl0eSxpIGluIEBlbnRpdGllc1xuXHRcdFx0aWYgZW50aXR5ID09IGl0ZW0gb3IgZW50aXR5IGlzYSBpdGVtXG5cdFx0XHRcdG1hdGNoID0gZW50aXR5XG5cdFx0XHRcdEBlbnRpdGllcy5zcGxpY2UoaSwxKVxuXHRcdFx0XHRyZXR1cm4gbWF0Y2hcblx0XHRyZXR1cm4gbnVsbFxuXG5cbmV4cG9ydCBjbGFzcyBTdGFja1xuXG5cdHByb3AgbG9nbGV2ZWxcblx0cHJvcCBub2Rlc1xuXHRwcm9wIHNjb3Blc1xuXG5cdGRlZiBpbml0aWFsaXplXG5cdFx0cmVzZXRcblxuXHRkZWYgcmVzZXRcblx0XHRAbm9kZXMgICAgPSBbXVxuXHRcdEBzY29waW5nICA9IFtdXG5cdFx0QHNjb3BlcyAgID0gW10gIyBmb3IgYW5hbHlzaXMgLSBzaG91bGQgcmVuYW1lXG5cdFx0QHN0YXNoICAgID0gU3Rhc2gubmV3KHNlbGYpXG5cdFx0QGxvZ2xldmVsID0gM1xuXHRcdEBjb3VudGVyICA9IDBcblx0XHRAY291bnRlcnMgPSB7fVxuXHRcdHNlbGZcblxuXHRkZWYgaW5jciBuYW1lXG5cdFx0QGNvdW50ZXJzW25hbWVdIHx8PSAwXG5cdFx0QGNvdW50ZXJzW25hbWVdICs9IDFcblxuXHRkZWYgc3Rhc2hcblx0XHRAc3Rhc2hcblxuXHRkZWYgb3B0aW9uIGtleVxuXHRcdEBvcHRpb25zIGFuZCBAb3B0aW9uc1trZXldXG5cblx0ZGVmIGFkZFNjb3BlIHNjb3BlXG5cdFx0QHNjb3Blcy5wdXNoKHNjb3BlKVxuXHRcdHNlbGZcblxuXHRkZWYgdHJhdmVyc2Ugbm9kZVxuXHRcdHNlbGZcblxuXHRkZWYgcHVzaCBub2RlXG5cdFx0QG5vZGVzLnB1c2gobm9kZSlcblx0XHQjIG5vdCBzdXJlIGlmIHdlIGhhdmUgYWxyZWFkeSBkZWZpbmVkIGEgc2NvcGU/XG5cdFx0c2VsZlxuXG5cdGRlZiBwb3Agbm9kZVxuXHRcdEBub2Rlcy5wb3AgIyAobm9kZSlcblx0XHRzZWxmXG5cblx0ZGVmIHBhcmVudFxuXHRcdEBub2Rlc1tAbm9kZXM6bGVuZ3RoIC0gMl1cblxuXHRkZWYgY3VycmVudFxuXHRcdEBub2Rlc1tAbm9kZXM6bGVuZ3RoIC0gMV1cblxuXHRkZWYgdXAgdGVzdFxuXHRcdHRlc3QgfHw9IGRvIHx2fCAhKHYgaXNhIFZhck9yQWNjZXNzKVxuXG5cdFx0aWYgdGVzdDpwcm90b3R5cGUgaXNhIE5vZGVcblx0XHRcdHZhciB0eXAgPSB0ZXN0XG5cdFx0XHR0ZXN0ID0gZG8gfHZ8IHYgaXNhIHR5cFxuXG5cdFx0dmFyIGkgPSBAbm9kZXM6bGVuZ3RoIC0gMiAjIGtleVxuXHRcdHdoaWxlIGkgPj0gMFxuXHRcdFx0dmFyIG5vZGUgPSBAbm9kZXNbaV1cblx0XHRcdHJldHVybiBub2RlIGlmIHRlc3Qobm9kZSlcblx0XHRcdGkgLT0gMVxuXHRcdHJldHVybiBudWxsXG5cblx0ZGVmIHJlbGF0aXZlIG5vZGUsIG9mZnNldCA9IDBcblx0XHR2YXIgaWR4ID0gQG5vZGVzLmluZGV4T2Yobm9kZSlcblx0XHRpZHggPj0gMCA/IEBub2Rlc1tpZHggKyBvZmZzZXRdIDogbnVsbFxuXG5cdGRlZiBzY29wZSBsdmwgPSAwXG5cdFx0dmFyIGkgPSBAbm9kZXM6bGVuZ3RoIC0gMSAtIGx2bFxuXHRcdHdoaWxlIGkgPj0gMFxuXHRcdFx0dmFyIG5vZGUgPSBAbm9kZXNbaV1cblx0XHRcdHJldHVybiBub2RlLkBzY29wZSBpZiBub2RlLkBzY29wZVxuXHRcdFx0aSAtPSAxXG5cdFx0cmV0dXJuIG51bGxcblxuXHRkZWYgc2NvcGVzXG5cdFx0IyBpbmNsdWRlIGRlZXBlciBzY29wZXMgYXMgd2VsbD9cblx0XHR2YXIgc2NvcGVzID0gW11cblx0XHR2YXIgaSA9IEBub2RlczpsZW5ndGggLSAxXG5cdFx0d2hpbGUgaSA+PSAwXG5cdFx0XHR2YXIgbm9kZSA9IEBub2Rlc1tpXVxuXHRcdFx0c2NvcGVzLnB1c2gobm9kZS5Ac2NvcGUpIGlmIG5vZGUuQHNjb3BlXG5cdFx0XHRpIC09IDFcblx0XHRyZXR1cm4gc2NvcGVzXG5cblx0ZGVmIG1ldGhvZFxuXHRcdHVwKE1ldGhvZERlY2xhcmF0aW9uKVxuXG5cdGRlZiBibG9ja1xuXHRcdHVwKEJsb2NrKVxuXG5cdGRlZiBpc0V4cHJlc3Npb25cblx0XHR2YXIgaSA9IEBub2RlczpsZW5ndGggLSAxXG5cdFx0d2hpbGUgaSA+PSAwXG5cdFx0XHR2YXIgbm9kZSA9IEBub2Rlc1tpXVxuXHRcdFx0IyB3aHkgYXJlIHdlIG5vdCB1c2luZyBpc0V4cHJlc3Npb24gaGVyZSBhcyB3ZWxsP1xuXHRcdFx0aWYgbm9kZSBpc2EgQ29kZSBvciBub2RlIGlzYSBMb29wXG5cdFx0XHRcdHJldHVybiBmYWxzZVxuXHRcdFx0aWYgbm9kZS5pc0V4cHJlc3Npb25cblx0XHRcdFx0cmV0dXJuIHRydWVcblx0XHRcdCMgcHJvYmFibHkgbm90IHRoZSByaWdodCB0ZXN0IC0gbmVlZCB0byBiZSBtb3JlIGV4cGxpY2l0XG5cdFx0XHRpIC09IDFcblx0XHRyZXR1cm4gZmFsc2VcblxuXHRkZWYgdG9TdHJpbmdcblx0XHRcIlN0YWNrKHtAbm9kZXMuam9pbihcIiAtPiBcIil9KVwiXG5cblx0ZGVmIHNjb3Bpbmdcblx0XHRAbm9kZXMuZmlsdGVyKHxufCBuLkBzY29wZSApLm1hcCh8bnwgbi5Ac2NvcGUgKVxuXG4jIExvdHMgb2YgZ2xvYmFscyAtLSByZWFsbHkgbmVlZCB0byBkZWFsIHdpdGggb25lIHN0YWNrIHBlciBmaWxlIC8gY29udGV4dFxuZXhwb3J0IHZhciBTVEFDSyA9IFN0YWNrLm5ld1xuXG5HTE9CU1RBQ0sgPSBTVEFDS1xuXG4jIHVzZSBhIGJpdG1hc2sgZm9yIHRoZXNlXG5cbmV4cG9ydCBjbGFzcyBOb2RlXG5cblx0cHJvcCBvXG5cdHByb3Agb3B0aW9uc1xuXHRwcm9wIHRyYXZlcnNlZFxuXG5cdGRlZiBzYWZlY2hhaW5cblx0XHRub1xuXG5cdCMgZGVmIGRvbVxuXHQjIFx0dmFyIG5hbWUgPSBcImFzdF9cIiArIHNlbGY6Y29uc3RydWN0b3I6bmFtZS5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLFwiJDFfJDJcIikudG9Mb3dlckNhc2Vcblx0IyBcdCMgcCBcInRyeSB0byBnZXQgdGhlIGRvbS1ub2RlIGZvciB0aGlzIGFzdC1ub2RlXCIsbmFtZVxuXHQjIFx0aWYgSW1iYS5UQUdTW25hbWVdXG5cdCMgXHRcdHZhciBub2RlID0gSW1iYS50YWcobmFtZSlcblx0IyBcdFx0bm9kZS5iaW5kKHNlbGYpLmJ1aWxkXG5cdCMgXHRcdHJldHVybiBub2RlXG5cdCMgXHRlbHNlXG5cdCMgXHRcdHJldHVybiBcIlt7bmFtZX1dXCJcblxuXHRkZWYgcFxuXHRcblx0XHQjIGFsbG93IGNvbnRyb2xsaW5nIHRoaXMgZnJvbSBjb21tYW5kbGluZVxuXHRcdGlmIFNUQUNLLmxvZ2xldmVsID4gMFxuXHRcdFx0Y29uc29sZS5sb2coKmFyZ3VtZW50cylcblx0XHRzZWxmXG5cblx0ZGVmIHR5cGVOYW1lXG5cdFx0c2VsZjpjb25zdHJ1Y3RvcjpuYW1lXG5cblx0ZGVmIG5hbWVwYXRoXG5cdFx0dHlwZU5hbWVcblxuXHRkZWYgaW5pdGlhbGl6ZVxuXHRcdHNldHVwXG5cdFx0c2VsZlxuXG5cdGRlZiBzZXR1cFxuXHRcdEBleHByZXNzaW9uID0gbm9cblx0XHRAdHJhdmVyc2VkID0gbm9cblx0XHRAcGFyZW5zID0gbm9cblx0XHRAY2FjaGUgPSBudWxsXG5cdFx0QHZhbHVlID0gbnVsbFxuXHRcdHNlbGZcblxuXHRkZWYgc2V0IG9ialxuXHRcdCMgY29uc29sZS5sb2cgXCJzZXR0aW5nIG9wdGlvbnMge0pTT04uc3RyaW5naWZ5KG9iail9XCJcblx0XHRAb3B0aW9ucyB8fD0ge31cblx0XHRmb3Igb3duIGssdiBvZiBvYmpcblx0XHRcdEBvcHRpb25zW2tdID0gdlxuXHRcdHNlbGZcblxuXHQjIGdldCBhbmQgc2V0XG5cdGRlZiBvcHRpb24ga2V5LCB2YWxcblx0XHRpZiB2YWwgIT0gdW5kZWZpbmVkXG5cdFx0XHQjIGNvbnNvbGUubG9nIFwic2V0dGluZyBvcHRpb24ge2tleX0ge3ZhbH1cIlxuXHRcdFx0QG9wdGlvbnMgfHw9IHt9XG5cdFx0XHRAb3B0aW9uc1trZXldID0gdmFsXG5cdFx0XHRyZXR1cm4gc2VsZlxuXG5cdFx0QG9wdGlvbnMgJiYgQG9wdGlvbnNba2V5XVxuXG5cdGRlZiBjb25maWd1cmUgb2JqXG5cdFx0c2V0KG9iailcblxuXHRkZWYgcmVnaW9uXG5cdFx0WzAsMF1cblxuXHRkZWYgbG9jXG5cdFx0WzAsMF1cblxuXHRkZWYgdG9rZW5cblx0XHRudWxsXG5cblx0ZGVmIGNvbXBpbGVcblx0XHRzZWxmXG5cblx0ZGVmIHZpc2l0XG5cdFx0c2VsZlxuXG5cdGRlZiBzdGFja1xuXHRcdFNUQUNLXG5cblx0ZGVmIGlzU3RyaW5nXG5cdFx0bm9cblxuXHRkZWYgaXNQcmltaXRpdmUgZGVlcFxuXHRcdG5vXG5cblx0ZGVmIGlzUmVzZXJ2ZWRcblx0XHRub1xuXG5cdCMgc2hvdWxkIHJhdGhlciBkbyB0cmF2ZXJzYWxzXG5cdCMgbyA9IHt9LCB1cCwga2V5LCBpbmRleFxuXHRkZWYgdHJhdmVyc2Vcblx0XHRpZiBAdHJhdmVyc2VkXG5cdFx0XHRyZXR1cm4gc2VsZiBcblx0XHQjIE5PREVTLnB1c2goc2VsZilcblx0XHRAdHJhdmVyc2VkID0geWVzXG5cdFx0U1RBQ0sucHVzaCBzZWxmXG5cdFx0dmlzaXQoU1RBQ0spXG5cdFx0U1RBQ0sucG9wIHNlbGZcblx0XHRyZXR1cm4gc2VsZlxuXG5cdGRlZiBpbnNwZWN0XG5cdFx0e3R5cGU6IHNlbGY6Y29uc3RydWN0b3IudG9TdHJpbmd9XG5cblx0ZGVmIGpzIG9cblx0XHRcIk5PREVcIlxuXG5cdGRlZiB0b1N0cmluZ1xuXHRcdFwie3NlbGY6Y29uc3RydWN0b3I6bmFtZX1cIlxuXG5cdCMgc3dhbGxvdyBtaWdodCBiZSBiZXR0ZXIgbmFtZVxuXHRkZWYgY29uc3VtZSBub2RlXG5cdFx0aWYgbm9kZSBpc2EgUHVzaEFzc2lnblxuXHRcdFx0cmV0dXJuIFB1c2hBc3NpZ24ubmV3KG5vZGUub3Asbm9kZS5sZWZ0LHNlbGYpXG5cblx0XHRpZiBub2RlIGlzYSBBc3NpZ25cblx0XHRcdCMgcCBcImNvbnN1bWUgYXNzaWdubWVudFwiLmN5YW5cblx0XHRcdCMgbm9kZS5yaWdodCA9IHNlbGZcblx0XHRcdHJldHVybiBPUChub2RlLm9wLG5vZGUubGVmdCxzZWxmKVxuXHRcdGVsaWYgbm9kZSBpc2EgT3Bcblx0XHRcdHJldHVybiBPUChub2RlLm9wLG5vZGUubGVmdCxzZWxmKVxuXHRcdGVsaWYgbm9kZSBpc2EgUmV0dXJuXG5cdFx0XHQjIHAgXCJjb25zdW1lIHJldHVyblwiLmN5YW5cblx0XHRcdHJldHVybiBSZXR1cm4ubmV3KHNlbGYpXG5cdFx0cmV0dXJuIHNlbGZcblxuXHRkZWYgdG9FeHByZXNzaW9uXG5cdFx0QGV4cHJlc3Npb24gPSB0cnVlXG5cdFx0c2VsZlxuXG5cdGRlZiBmb3JjZUV4cHJlc3Npb25cblx0XHRAZXhwcmVzc2lvbiA9IHRydWVcblx0XHRzZWxmXG5cblx0ZGVmIGlzRXhwcmVzc2FibGVcblx0XHR0cnVlXG5cblx0ZGVmIGlzRXhwcmVzc2lvblxuXHRcdEBleHByZXNzaW9uIHx8IGZhbHNlXG5cblx0ZGVmIGhhc1NpZGVFZmZlY3RzXG5cdFx0dHJ1ZVxuXG5cdGRlZiBpc1VzZWRcblx0XHR0cnVlXG5cdFx0XG5cdGRlZiBzaG91bGRQYXJlbnRoZXNpemVcblx0XHRmYWxzZVxuXG5cdGRlZiBibG9ja1xuXHRcdEJsb2NrLndyYXAoW3NlbGZdKVxuXG5cdGRlZiBub2RlXG5cdFx0c2VsZlxuXG5cdGRlZiBzY29wZV9fXG5cdFx0U1RBQ0suc2NvcGVcblxuXHRkZWYgdXBcblx0XHRTVEFDSy5wYXJlbnRcblxuXHRkZWYgdXRpbFxuXHRcdFV0aWxcblxuXHRkZWYgcmVjZWl2ZXJcblx0XHRzZWxmXG5cblx0ZGVmIGFkZEV4cHJlc3Npb24gZXhwclxuXHRcdCMgbWlnaHQgYmUgYmV0dGVyIHRvIG5lc3QgdGhpcyB1cCBhZnRlciBwYXJzaW5nIGlzIGRvbmU/XG5cdFx0IyBwIFwiYWRkRXhwcmVzc2lvbiB7c2VsZn0gPC0ge2V4cHJ9XCJcblx0XHR2YXIgbm9kZSA9IEV4cHJlc3Npb25CbG9jay5uZXcoW3NlbGZdKVxuXHRcdHJldHVybiBub2RlLmFkZEV4cHJlc3Npb24oZXhwcilcblxuXG5cdGRlZiBpbmRlbnRlZCBhLGJcblxuXHRcdGlmIGEgaXNhIEluZGVudGF0aW9uXG5cdFx0XHRAaW5kZW50YXRpb24gPSBhXG5cdFx0XHRyZXR1cm4gc2VsZlxuXG5cdFx0IyB0aGlzIGlzIGEgX0JJR18gaGFja1xuXHRcdGlmIGIgaXNhIEFycmF5XG5cdFx0XHRhZGQoYlswXSlcblx0XHRcdGIgPSBiWzFdXG5cblx0XHQjIGlmIGluZGVudCBhbmQgaW5kZW50Lm1hdGNoKC9cXDovKVxuXHRcdEBpbmRlbnRhdGlvbiB8fD0gYSBhbmQgYiA/IEluZGVudGF0aW9uLm5ldyhhLGIpIDogSU5ERU5UXG5cdFx0c2VsZlxuXG5cdGRlZiBwcmVicmVhayB0ZXJtID0gJ1xcbidcblx0XHQjIGluIG9wdGlvbnMgaW5zdGVhZD9cblx0XHQjIGNvbnNvbGUubG9nIFwicHJlYnJlYWshISEhXCJcblx0XHQjIEBwcmVicmVhayA9IEBwcmVicmVhayBvciB0ZXJtXG5cdFx0c2VsZlxuXG5cdGRlZiBpbnZlcnRcblx0XHRyZXR1cm4gT1AoJyEnLHNlbGYpXG5cblx0ZGVmIGNhY2hlIG8gPSB7fVxuXHRcdEBjYWNoZSA9IG9cblx0XHRvOnZhciA9IHNjb3BlX18udGVtcG9yYXJ5KHNlbGYsbylcblx0XHRvOmxvb2t1cHMgPSAwXG5cdFx0c2VsZlxuXG5cdGRlZiBjYWNoZXZhclxuXHRcdEBjYWNoZSAmJiBAY2FjaGU6dmFyXG5cblx0ZGVmIGRlY2FjaGVcblx0XHRpZiBAY2FjaGVcblx0XHRcdGNhY2hldmFyLmZyZWVcblx0XHRcdEBjYWNoZSA9IG51bGxcblx0XHRzZWxmXG5cblx0IyBpcyB0aGlzIHdpdGhvdXQgc2lkZS1lZmZlY3RzPyBobW0gLSB3aGF0IGRvZXMgaXQgZXZlbiBkbz9cblx0ZGVmIHByZWRlY2xhcmVcblx0XHRpZiBAY2FjaGVcblx0XHRcdHNjb3BlX18udmFycy5zd2FwKEBjYWNoZTp2YXIsc2VsZilcblx0XHRzZWxmXG5cblx0IyB0aGUgXCJuYW1lLXN1Z2dlc3Rpb25cIiBmb3Igbm9kZXMgaWYgdGhleSBuZWVkIHRvIGJlIGNhY2hlZFxuXHRkZWYgYWxpYXNcblx0XHRudWxsXG5cblx0ZGVmIHdhcm4gdGV4dCwgb3B0cyA9IHt9XG5cdFx0b3B0czptZXNzYWdlID0gdGV4dFxuXHRcdG9wdHM6bG9jIHx8PSBsb2Ncblx0XHRzY29wZV9fLnJvb3Qud2FybiBvcHRzXG5cdFx0c2VsZlxuXG5cdGRlZiBjIG9cblx0XHR2YXIgcyA9IFNUQUNLXG5cdFx0dmFyIGNoID0gQGNhY2hlXG5cdFx0cmV0dXJuIGNfY2FjaGVkKGNoKSBpZiBjaCBhbmQgY2g6Y2FjaGVkXG5cblx0XHRzLnB1c2goc2VsZilcblx0XHRmb3JjZUV4cHJlc3Npb24gaWYgbyAmJiBvOmV4cHJlc3Npb25cblxuXHRcdHY4IGFuZCBjb25zb2xlLmxvZyB2OC5oYXNGYXN0T2JqZWN0RWxlbWVudHMoc2VsZilcblxuXHRcdGlmIG8gYW5kIG86aW5kZW50XG5cdFx0XHRAaW5kZW50YXRpb24gfHw9IElOREVOVFxuXG5cdFx0dmFyIG91dCA9IGpzKHMsbylcblxuXHRcdCMgcmVhbGx5PyB3aHkgbm90IGNhbGwgdGhpcyBzb21ld2hlcmUgZWxzZT9cblx0XHR2YXIgcGFyZW4gPSBzaG91bGRQYXJlbnRoZXNpemVcblx0XHRcblx0XHRpZiB2YXIgaW5kZW50ID0gQGluZGVudGF0aW9uXG5cdFx0XHRvdXQgPSBpbmRlbnQud3JhcChvdXQsbylcblxuXHRcdCMgc2hvdWxkIG1vdmUgdGhpcyBzb21ld2hlcmUgZWxzZSByZWFsbHlcblx0XHRvdXQgPSBcIih7b3V0fSlcIiBpZiBwYXJlblxuXHRcdGlmIG8gYW5kIG86YnJhY2VzXG5cdFx0XHRpZiBpbmRlbnRcblx0XHRcdFx0b3V0ID0gJ3snICsgb3V0ICsgJ30nIFxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRvdXQgPSAneyAnICsgb3V0ICsgJyB9J1xuXG5cdFx0cy5wb3Aoc2VsZilcblxuXHRcdGlmIGNoID0gQGNhY2hlXG5cdFx0XHRvdXQgPSBcIntjaDp2YXIuY30gPSB7b3V0fVwiIHVubGVzcyBjaDptYW51YWxcblx0XHRcdHZhciBwYXIgPSBzLmN1cnJlbnRcblx0XHRcdG91dCA9ICcoJyArIG91dCArICcpJyBpZiBwYXIgaXNhIEFjY2VzcyB8fCBwYXIgaXNhIE9wICMgb3RoZXJzPyAjIFxuXHRcdFx0Y2g6Y2FjaGVkID0geWVzXG5cdFx0cmV0dXJuIG91dFxuXG5cdGRlZiBjX2NhY2hlZCBjYWNoZVxuXHRcdGNhY2hlOmxvb2t1cHMrK1xuXHRcdGNhY2hlOnZhci5mcmVlIGlmIGNhY2hlOnVzZXMgPT0gY2FjaGU6bG9va3Vwc1xuXHRcdHJldHVybiBjYWNoZTp2YXIuYyAjIHJlY29tcGlsZSBldmVyeSB0aW1lPz9cblxuZXhwb3J0IGNsYXNzIFZhbHVlTm9kZSA8IE5vZGVcblxuXHRwcm9wIHZhbHVlXG5cblx0ZGVmIGluaXRpYWxpemUgdmFsdWVcblx0XHRzZXR1cFxuXHRcdEB2YWx1ZSA9IGxvYWQodmFsdWUpXG5cblx0ZGVmIGxvYWQgdmFsdWVcblx0XHR2YWx1ZVxuXG5cdGRlZiBqcyBvXG5cdFx0dHlwZW9mIEB2YWx1ZSA9PSAnc3RyaW5nJyA/IEB2YWx1ZSA6IEB2YWx1ZS5jXG5cblx0ZGVmIHZpc2l0XG5cdFxuXHRcdEB2YWx1ZS50cmF2ZXJzZSBpZiBAdmFsdWUgaXNhIE5vZGUgIyAgJiYgQHZhbHVlOnRyYXZlcnNlXG5cdFx0c2VsZlxuXG5cdGRlZiByZWdpb25cblx0XHRbQHZhbHVlLkBsb2MsQHZhbHVlLkBsb2MgKyBAdmFsdWUuQGxlbl1cblxuXG5leHBvcnQgY2xhc3MgU3RhdGVtZW50IDwgVmFsdWVOb2RlXG5cblx0ZGVmIGlzRXhwcmVzc2FibGVcblx0XHRyZXR1cm4gbm9cblxuXG5leHBvcnQgY2xhc3MgTWV0YSA8IFZhbHVlTm9kZVxuXG5cdGRlZiBpc1ByaW1pdGl2ZSBkZWVwXG5cdFx0eWVzXG5cbmV4cG9ydCBjbGFzcyBDb21tZW50IDwgTWV0YVxuXHRcblx0ZGVmIHZpc2l0XG5cdFx0IyBzdGFjay5zdGFzaC5hZGQoc2VsZilcblxuXHRcdGlmIHZhciBibG9jayA9IHVwXG5cdFx0XHR2YXIgaWR4ID0gYmxvY2suaW5kZXhPZihzZWxmKSArIDFcblx0XHRcdGlkeCArPSAxIGlmIGJsb2NrLmluZGV4KGlkeCkgaXNhIFRlcm1pbmF0b3Jcblx0XHRcdGlmIHZhciBuZXh0ID0gYmxvY2suaW5kZXgoaWR4KVxuXHRcdFx0XHRuZXh0LkBkZXNjID0gc2VsZlxuXG5cdFx0XHQjIGNvbnNvbGUubG9nIFwiTmV4dCBpdGVtIGFmdGVyIGNvbW1lbnQgaXMge2Jsb2NrLmluZGV4KGlkeCl9XCJcblxuXHRcdHNlbGZcblxuXHRkZWYgdG9Eb2Ncblx0XHRoZWxwZXJzLm5vcm1hbGl6ZUluZGVudGF0aW9uKFwiXCIgKyBAdmFsdWUuQHZhbHVlKVxuXG5cdGRlZiB0b0pTT05cblx0XHRoZWxwZXJzLm5vcm1hbGl6ZUluZGVudGF0aW9uKFwiXCIgKyBAdmFsdWUuQHZhbHVlKVxuXG5cdGRlZiBjIG9cblx0XHR2YXIgdiA9IEB2YWx1ZS5AdmFsdWVcblx0XHQjIHAgQHZhbHVlLnR5cGVcblx0XHRpZiBvIGFuZCBvOmV4cHJlc3Npb24gb3Igdi5tYXRjaCgvXFxuLykgb3IgQHZhbHVlLnR5cGUgPT0gJ0hFUkVDT01NRU5UJyAjIG11bHRpbGluZT9cblx0XHRcdFwiLyp7dn0qL1wiXG5cdFx0ZWxzZVxuXHRcdFx0XCIvLyB7dn1cIlxuXG5leHBvcnQgY2xhc3MgVGVybWluYXRvciA8IE1ldGFcblx0XG5cdGRlZiBpbml0aWFsaXplIHZcblx0XHRAdmFsdWUgPSB2XG5cdFx0c2VsZlxuXG5cdGRlZiB0cmF2ZXJzZVxuXHRcdHNlbGZcblxuXHRkZWYgY1xuXHRcdCMgVE9ETyB0aGlzIGNhbiBjb250YWluIHNldmVyYWwgbmV3bGluZXNcblx0XHQjIGZvciBzb3VyY2VtYXBzIGl0IHdvdWxkIGJlIG5pY2UgdG8gcGFyc2UgdGhpc1xuXHRcdCMgYW5kIGZpeCBpdCB1cCBtYXJrX18oQHZhbHVlKSArIFxuXHRcdHJldHVybiBAdmFsdWUuY1xuXHRcdCMgdmFyIHYgPSB2YWx1ZS5yZXBsYWNlKC9cXFxcbi9nLCdcXG4nKVxuXHRcdCMgdiAjIC5zcGxpdCgpXG5cdFx0IyB2LnNwbGl0KFwiXFxuXCIpLm1hcCh8dnwgdiA/IFwiIC8vIHt2fVwiIDogdikuam9pbihcIlxcblwiKVxuXG5leHBvcnQgY2xhc3MgTmV3bGluZSA8IFRlcm1pbmF0b3JcblxuXHRkZWYgaW5pdGlhbGl6ZSB2XG5cdFx0QHRyYXZlcnNlZCA9IG5vXG5cdFx0QHZhbHVlID0gdiBvciAnXFxuJ1xuXG5cdGRlZiBjXG5cdFx0Y19fKEB2YWx1ZSlcblx0XHRcblxuIyB3ZWlyZCBwbGFjZT9cbmV4cG9ydCBjbGFzcyBJbmRleCA8IFZhbHVlTm9kZVxuXG5cdGRlZiBqcyBvXG5cdFx0QHZhbHVlLmNcblxuZXhwb3J0IGNsYXNzIExpc3ROb2RlIDwgTm9kZVxuXG5cdHByb3Agbm9kZXNcblxuXHRkZWYgaW5pdGlhbGl6ZSBsaXN0XG5cdFx0c2V0dXBcblx0XHRAbm9kZXMgPSBsb2FkKGxpc3Qgb3IgW10pXG5cdFx0QGluZGVudGF0aW9uID0gbnVsbFxuXG5cdCMgUEVSRiBhY2NlcyBAbm9kZXMgZGlyZWN0bHk/XG5cdGRlZiBsaXN0XG5cdFx0QG5vZGVzXG5cblx0ZGVmIGNvbXBhY3Rcblx0XHRAbm9kZXMgPSBjb21wYWN0X18oQG5vZGVzKVxuXHRcdHNlbGZcblxuXHRkZWYgbG9hZCBsaXN0XG5cdFx0bGlzdFxuXG5cdGRlZiBjb25jYXQgb3RoZXJcblx0XHQjIG5lZWQgdG8gc3RvcmUgaW5kZW50ZWQgY29udGVudCBhcyB3ZWxsP1xuXHRcdEBub2RlcyA9IG5vZGVzLmNvbmNhdChvdGhlciBpc2EgQXJyYXkgPyBvdGhlciA6IG90aGVyLm5vZGVzKVxuXHRcdHNlbGZcblxuXHRkZWYgc3dhcCBpdGVtLCBvdGhlclxuXHRcdHZhciBpZHggPSBpbmRleE9mKGl0ZW0pXG5cdFx0bm9kZXNbaWR4XSA9IG90aGVyIGlmIGlkeCA+PSAwXG5cdFx0c2VsZlxuXG5cdGRlZiBwdXNoIGl0ZW1cblx0XHRAbm9kZXMucHVzaChpdGVtKVxuXHRcdHNlbGZcblxuXHRkZWYgcG9wXG5cdFx0dmFyIGVuZCA9IEBub2Rlcy5wb3Bcblx0XHRyZXR1cm4gZW5kXG5cblx0ZGVmIGFkZCBpdGVtXG5cdFx0QG5vZGVzLnB1c2goaXRlbSlcblx0XHRzZWxmXG5cblx0ZGVmIHVuc2hpZnQgaXRlbSwgYnJcblx0XHRAbm9kZXMudW5zaGlmdChCUikgaWYgYnJcblx0XHRAbm9kZXMudW5zaGlmdChpdGVtKVxuXHRcdHNlbGZcblxuXHQjIHRlc3Rcblx0ZGVmIHNsaWNlIGEsIGJcblx0XHRzZWxmOmNvbnN0cnVjdG9yLm5ldyhAbm9kZXMuc2xpY2UoYSxiKSlcblxuXHRcblxuXHRkZWYgYnJlYWsgYnIsIHByZSA9IG5vXG5cdFx0YnIgPSBUZXJtaW5hdG9yLm5ldyhicikgaWYgdHlwZW9mIGJyID09ICdzdHJpbmcnXG5cdFx0cHJlID8gdW5zaGlmdChicikgOiBwdXNoKGJyKVxuXHRcdHNlbGZcblxuXHRkZWYgc29tZSBjYlxuXHRcdGZvciBub2RlIGluIEBub2Rlc1xuXHRcdFx0cmV0dXJuIHllcyBpZiBjYihub2RlKVxuXHRcdHJldHVybiBub1xuXG5cdGRlZiBldmVyeSBjYlxuXHRcdGZvciBub2RlIGluIEBub2Rlc1xuXHRcdFx0cmV0dXJuIG5vIHVubGVzcyBjYihub2RlKVxuXHRcdHJldHVybiB5ZXNcblxuXHRkZWYgZmlsdGVyIGNiXG5cdFx0QG5vZGVzLmZpbHRlcihjYilcblxuXHRkZWYgcGx1Y2sgY2Jcblx0XHR2YXIgaXRlbSA9IGZpbHRlcihjYilbMF1cblx0XHRyZW1vdmUoaXRlbSkgaWYgaXRlbVxuXHRcdHJldHVybiBpdGVtXG5cblx0ZGVmIGluZGV4T2YgaXRlbVxuXHRcdEBub2Rlcy5pbmRleE9mKGl0ZW0pXG5cblx0ZGVmIGluZGV4IGlcblx0XHRAbm9kZXNbaV1cblxuXHRkZWYgcmVtb3ZlIGl0ZW1cblx0XHR2YXIgaWR4ID0gQG5vZGVzLmluZGV4T2YoaXRlbSlcblx0XHRAbm9kZXMuc3BsaWNlKGlkeCwgMSkgaWYgaWR4ID49IDBcblx0XHRzZWxmXG5cblx0ZGVmIHJlbW92ZUF0IGlkeFxuXHRcdHZhciBpdGVtID0gQG5vZGVzW2lkeF1cblx0XHRAbm9kZXMuc3BsaWNlKGlkeCwgMSkgaWYgaWR4ID49IDBcblx0XHRyZXR1cm4gaXRlbVxuXHRcdFxuXG5cdGRlZiByZXBsYWNlIG9yaWdpbmFsLCByZXBsYWNlbWVudFxuXHRcdHZhciBpZHggPSBAbm9kZXMuaW5kZXhPZihvcmlnaW5hbClcblx0XHRpZiBpZHggPj0gMFxuXHRcdFx0aWYgcmVwbGFjZW1lbnQgaXNhIEFycmF5XG5cdFx0XHRcdCMgcCBcInJlcGxhY2Vpbmcgd2l0aCBhcnJheSBvZiBpdGVtc1wiXG5cdFx0XHRcdEBub2Rlcy5zcGxpY2UoaWR4LDEsKnJlcGxhY2VtZW50KVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRAbm9kZXNbaWR4XSA9IHJlcGxhY2VtZW50IFxuXHRcdHNlbGZcblxuXHRkZWYgZmlyc3Rcblx0XHRAbm9kZXNbMF1cblxuXHRkZWYgbGFzdFxuXHRcdHZhciBpID0gQG5vZGVzOmxlbmd0aFxuXHRcdHdoaWxlIGlcblx0XHRcdGkgPSBpIC0gMVxuXHRcdFx0dmFyIHYgPSBAbm9kZXNbaV1cblx0XHRcdHJldHVybiB2IHVubGVzcyB2IGlzYSBNZXRhXG5cdFx0cmV0dXJuIG51bGxcblxuXHRkZWYgbWFwIGZuXG5cdFx0QG5vZGVzLm1hcChmbilcblxuXHRkZWYgZm9yRWFjaCBmblxuXHRcdEBub2Rlcy5mb3JFYWNoKGZuKVxuXG5cdGRlZiByZW1hcCBmblxuXHRcdEBub2RlcyA9IG1hcChmbilcblx0XHRzZWxmXG5cblx0ZGVmIGNvdW50XG5cdFx0QG5vZGVzOmxlbmd0aFxuXG5cdGRlZiByZWFsQ291bnRcblx0XHR2YXIgayA9IDBcblx0XHRmb3Igbm9kZSBpbiBAbm9kZXNcblx0XHRcdGsrKyBpZiBub2RlIGFuZCAhKG5vZGUgaXNhIE1ldGEpXG5cdFx0cmV0dXJuIGtcblxuXHRkZWYgdmlzaXRcblx0XHRmb3Igbm9kZSBpbiBAbm9kZXNcblx0XHRcdG5vZGUgYW5kIG5vZGUudHJhdmVyc2Vcblx0XHRzZWxmXG5cblx0ZGVmIGlzRXhwcmVzc2FibGVcblx0XHRmb3Igbm9kZSBpbiBub2Rlc1xuXHRcdFx0cmV0dXJuIG5vIGlmIG5vZGUgYW5kICFub2RlLmlzRXhwcmVzc2FibGVcblx0XHQjIHJldHVybiBubyB1bmxlc3Mgbm9kZXMuZXZlcnkofHZ8IHYuaXNFeHByZXNzYWJsZSApXG5cdFx0cmV0dXJuIHllc1xuXG5cdGRlZiB0b0FycmF5XG5cdFx0QG5vZGVzXG5cblx0ZGVmIGRlbGltaXRlclxuXHRcdEBkZWxpbWl0ZXIgb3IgXCIsXCJcblxuXHRkZWYganMgbywgbm9kZXM6IEBub2Rlc1xuXHRcdHZhciBkZWxpbSA9ICcsJ1xuXHRcdHZhciBleHByZXNzID0gZGVsaW0gIT0gJzsnXG5cdFx0dmFyIGxhc3QgPSBsYXN0XG5cblx0XHR2YXIgaSA9IDBcblx0XHR2YXIgbCA9IG5vZGVzOmxlbmd0aFxuXHRcdHZhciBzdHIgPSBcIlwiXG5cblx0XHRmb3IgYXJnIGluIG5vZGVzXG5cdFx0XHR2YXIgcGFydCA9IHR5cGVvZiBhcmcgPT0gJ3N0cmluZycgPyBhcmcgOiAoYXJnID8gYXJnLmMoZXhwcmVzc2lvbjogZXhwcmVzcykgOiAnJylcblx0XHRcdHN0ciArPSBwYXJ0XG5cdFx0XHRzdHIgKz0gZGVsaW0gaWYgcGFydCBhbmQgKCFleHByZXNzIG9yIGFyZyAhPSBsYXN0KSBhbmQgIShhcmcgaXNhIE1ldGEpXG5cblx0XHRyZXR1cm4gc3RyXG5cblx0ZGVmIGluZGVudGVkIGEsYlxuXHRcdGlmIGEgaXNhIEluZGVudGF0aW9uXG5cdFx0XHRAaW5kZW50YXRpb24gPSBhXG5cdFx0XHRyZXR1cm4gc2VsZlxuXG5cdFx0QGluZGVudGF0aW9uIHx8PSBhIGFuZCBiID8gSW5kZW50YXRpb24ubmV3KGEsYikgOiBJTkRFTlRcblx0XHRzZWxmXG5cdFx0XG5cbmV4cG9ydCBjbGFzcyBBcmdMaXN0IDwgTGlzdE5vZGVcblxuI1x0ZGVmIGluZGVudGVkIGEsYlxuI1x0XHRpZiBhIGlzYSBJbmRlbnRhdGlvblxuI1x0XHRcdEBpbmRlbnRhdGlvbiA9IGFcbiNcdFx0XHRyZXR1cm4gc2VsZlxuI1xuI1x0XHRAaW5kZW50YXRpb24gfHw9IGEgYW5kIGIgPyBJbmRlbnRhdGlvbi5uZXcoYSxiKSA6IElOREVOVFxuI1x0XHRzZWxmXG5cbiMgZGVmIGhhc1NwbGF0XG4jIFx0QG5vZGVzLnNvbWUgZG8gfHZ8IHYgaXNhIFNwbGF0XG4jIGRlZiBkZWxpbWl0ZXJcbiMgXHRcIixcIlxuXG5cbmV4cG9ydCBjbGFzcyBBc3NpZ25MaXN0IDwgQXJnTGlzdFx0XG5cblx0ZGVmIGNvbmNhdCBvdGhlclxuXHRcdGlmIEBub2RlczpsZW5ndGggPT0gMCBhbmQgb3RoZXIgaXNhIEFzc2lnbkxpc3Rcblx0XHRcdHJldHVybiBvdGhlclxuXHRcdGVsc2Vcblx0XHRcdHN1cGVyKG90aGVyKVxuXHRcdCMgbmVlZCB0byBzdG9yZSBpbmRlbnRlZCBjb250ZW50IGFzIHdlbGw/XG5cdFx0IyBAbm9kZXMgPSBub2Rlcy5jb25jYXQob3RoZXIgaXNhIEFycmF5ID8gb3RoZXIgOiBvdGhlci5ub2Rlcylcblx0XHRzZWxmXG5cblxuZXhwb3J0IGNsYXNzIEJsb2NrIDwgTGlzdE5vZGVcdFxuXHRcblx0cHJvcCBoZWFkXG5cblx0ZGVmIGluaXRpYWxpemUgbGlzdFxuXHRcdHNldHVwXG5cdFx0IyBAbm9kZXMgPSBjb21wYWN0X18oZmxhdHRlbl9fKGxpc3QpKSBvciBbXVxuXHRcdEBub2RlcyA9IGxpc3Qgb3IgW11cblx0XHRAaGVhZCA9IG51bGxcblx0XHRAaW5kZW50YXRpb24gPSBudWxsXG5cblx0ZGVmIHNlbGYud3JhcCBhcnlcblx0XHR1bmxlc3MgYXJ5IGlzYSBBcnJheVxuXHRcdFx0dGhyb3cgU3ludGF4RXJyb3IubmV3KFwid2hhdFwiKVxuXHRcdGFyeTpsZW5ndGggPT0gMSAmJiBhcnlbMF0gaXNhIEJsb2NrID8gYXJ5WzBdIDogQmxvY2submV3KGFyeSlcblxuXHRkZWYgdmlzaXRcblx0XHRAc2NvcGUudmlzaXQgaWYgQHNjb3BlXG5cblx0XHRmb3Igbm9kZSxpIGluIEBub2Rlc1xuXHRcdFx0bm9kZSBhbmQgbm9kZS50cmF2ZXJzZVxuXHRcdHNlbGZcblxuXHRkZWYgYmxvY2tcblx0XHRzZWxmXG5cblx0IyBkZWYgaW5kZW50ZWQgYSxiXG5cdCMgXHRAaW5kZW50YXRpb24gfHw9IGEgYW5kIGIgPyBJbmRlbnRhdGlvbi5uZXcoYSxiKSA6IElOREVOVFxuXHQjIFx0c2VsZlxuXG5cdGRlZiBsb2Ncblx0XHQjIHJhdGhlciBpbmRlbnRzLCBubz9cblx0XHRpZiB2YXIgb3B0ID0gb3B0aW9uKDplbmRzKVxuXHRcdFx0IyBwIFwibG9jYXRpb24gaXNcIixvcHRcblx0XHRcdHZhciBhID0gb3B0WzBdLmxvY1xuXHRcdFx0dmFyIGIgPSBvcHRbMV0ubG9jXG5cblx0XHRcdHAgXCJubyBsb2MgZm9yIHtvcHRbMF19XCIgdW5sZXNzIGFcblx0XHRcdHAgXCJubyBsb2MgZm9yIHtvcHRbMV19XCIgdW5sZXNzIGJcblxuXHRcdFx0W2FbMF0sYlsxXV1cblx0XHRlbGlmIHZhciBpbmQgPSBAaW5kZW50YXRpb25cblx0XHRcdFtpbmQuYWxvYyxpbmQuYmxvY11cblx0XHRlbHNlXG5cdFx0XHRbMCwwXVxuXG5cdCMgZ28gdGhyb3VnaCBjaGlsZHJlbiBhbmQgdW53cmFwIGlubmVyIG5vZGVzXG5cdGRlZiB1bndyYXBcblx0XHR2YXIgYXJ5ID0gW11cblx0XHRmb3Igbm9kZSxpIGluIG5vZGVzXG5cdFx0XHRpZiBub2RlIGlzYSBCbG9ja1xuXHRcdFx0XHQjIHAgXCJ1bndyYXBwaW5nIGlubmVyIGJsb2NrXCJcblx0XHRcdFx0YXJ5OnB1c2guYXBwbHkoYXJ5LG5vZGUudW53cmFwKVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRhcnkucHVzaChub2RlKVxuXHRcdHJldHVybiBhcnlcblxuXHRkZWYgcHVzaCBpdGVtXG5cdFx0QG5vZGVzLnB1c2goaXRlbSlcblx0XHRzZWxmXG5cblx0ZGVmIGFkZCBpdGVtXG5cdFx0QG5vZGVzLnB1c2goaXRlbSlcblx0XHRzZWxmXG5cblx0IyBUaGlzIGlzIGp1c3QgdG8gd29yayBhcyBhbiBpbnBsYWNlIHJlcGxhY2VtZW50IG9mIG5vZGVzLmNvZmZlZVxuXHQjIEFmdGVyIHRoaW5ncyBhcmUgd29ya2luZyBva2F5IHdlJ2xsIGRvIGJpZ2dlciByZWZhY3RvcmluZ3Ncblx0ZGVmIGNvbXBpbGUgbyA9IHt9XG5cdFx0dmFyIHJvb3QgPSBSb290Lm5ldyhzZWxmLG8pXG5cdFx0cm9vdC5jb21waWxlKG8pXG5cblxuXHQjIE5vdCBzdXJlIGlmIHdlIHNob3VsZCBjcmVhdGUgYSBzZXBhcmF0ZSBibG9jaz9cblx0ZGVmIGFuYWx5emUgbyA9IHt9XG5cdFx0IyBwIFwiYW5hbHl6aW5nIGJsb2NrISEhXCIsb1xuXHRcdHNlbGZcblxuXHRkZWYgY3BhcnQgbm9kZVxuXHRcdHZhciBvdXQgPSB0eXBlb2Ygbm9kZSA9PSAnc3RyaW5nJyA/IG5vZGUgOiAobm9kZSA/IG5vZGUuYyA6IFwiXCIpXG5cdFx0cmV0dXJuIFwiXCIgaWYgb3V0ID09IG51bGwgb3Igb3V0ID09IHVuZGVmaW5lZCBvciBvdXQgPT0gXCJcIlxuXG5cdFx0aWYgb3V0IGlzYSBBcnJheVxuXHRcdFx0dmFyIHN0ciA9IFwiXCJcblx0XHRcdHZhciBsID0gb3V0Omxlbmd0aFxuXHRcdFx0dmFyIGkgPSAwXG5cdFx0XHR3aGlsZSBpIDwgbFxuXHRcdFx0XHRzdHIgKz0gY3BhcnQob3V0W2krK10pXG5cdFx0XHRyZXR1cm4gc3RyXG5cblx0XHR2YXIgaGFzU2VtaUNvbG9uID0gU0VNSUNPTE9OX1RFU1QudGVzdChvdXQpXG5cdFx0b3V0ICs9IFwiO1wiIHVubGVzcyBoYXNTZW1pQ29sb24gb3Igbm9kZSBpc2EgTWV0YVxuXHRcdHJldHVybiBvdXRcblxuXHRkZWYganMgbywgb3B0c1xuXHRcdHZhciBhc3QgPSBAbm9kZXNcblx0XHR2YXIgbCA9IGFzdDpsZW5ndGhcblx0XHQjIHJlYWxseT9cblx0XHR2YXIgZXhwcmVzcyA9IGlzRXhwcmVzc2lvbiBvciBvLmlzRXhwcmVzc2lvbiBvciAob3B0aW9uKDpleHByZXNzKSBhbmQgaXNFeHByZXNzYWJsZSlcblx0XHRyZXR1cm4gJycgaWYgYXN0Omxlbmd0aCA9PSAwXG5cblx0XHRpZiBleHByZXNzXG5cdFx0XHRyZXR1cm4gc3VwZXIobyxub2RlczogYXN0KVxuXG5cdFx0dmFyIHN0ciA9IFwiXCJcblx0XHRmb3IgdiBpbiBhc3Rcblx0XHRcdHN0ciArPSBjcGFydCh2KVxuXG5cdFx0IyBub3cgYWRkIHRoZSBoZWFkIGl0ZW1zIGFzIHdlbGxcblx0XHRpZiBAaGVhZCBhbmQgQGhlYWQ6bGVuZ3RoID4gMFxuXHRcdFx0dmFyIHByZWZpeCA9IFwiXCJcblx0XHRcdGZvciB2IGluIEBoZWFkXG5cdFx0XHRcdHZhciBodiA9IGNwYXJ0KHYpXG5cdFx0XHRcdHByZWZpeCArPSBodiArICdcXG4nIGlmIGh2XG5cdFx0XHRzdHIgPSBwcmVmaXggKyBzdHJcblx0XHRyZXR1cm4gc3RyXG5cblxuXHQjIFNob3VsZCB0aGlzIGNyZWF0ZSB0aGUgZnVuY3Rpb24gYXMgd2VsbD9cblx0ZGVmIGRlZmVycyBvcmlnaW5hbCwgcmVwbGFjZW1lbnRcblx0XHR2YXIgaWR4ID0gQG5vZGVzLmluZGV4T2Yob3JpZ2luYWwpXG5cdFx0QG5vZGVzW2lkeF0gPSByZXBsYWNlbWVudCBpZiBpZHggPj0gMFxuXHRcdHZhciByZXN0ID0gQG5vZGVzLnNwbGljZShpZHggKyAxKVxuXHRcdHJldHVybiByZXN0XG5cblx0ZGVmIGV4cHJlc3Npb25zXG5cdFx0dmFyIGV4cHJlc3Npb25zID0gW11cblx0XHRmb3Igbm9kZSBpbiBub2Rlc1xuXHRcdFx0ZXhwcmVzc2lvbnMucHVzaChub2RlKSB1bmxlc3Mgbm9kZSBpc2EgVGVybWluYXRvclxuXHRcdHJldHVybiBleHByZXNzaW9uc1xuXHRcdFxuXG5cdGRlZiBjb25zdW1lIG5vZGVcblx0XHRpZiBub2RlIGlzYSBUYWdUcmVlICMgc3BlY2lhbCBjYXNlPyE/XG5cdFx0XHRAbm9kZXMgPSBAbm9kZXMubWFwIGRvIHxjaGlsZHxcblx0XHRcdFx0Y2hpbGQuY29uc3VtZShub2RlKVxuXG5cdFx0XHRsZXQgcmVhbCA9IGV4cHJlc3Npb25zXG5cdFx0XHQjIEZJWE1FIHNob3VsZCBub3QgaW5jbHVkZSB0ZXJtaW5hdG9ycyBhbmQgY29tbWVudHMgd2hlbiBjb3VudGluZ1xuXHRcdFx0IyBzaG91bGQgb25seSB3cmFwIHRoZSBjb250ZW50IGluIGFycmF5IChyZXR1cm5pbmcgYWxsIHBhcnRzKVxuXHRcdFx0IyBmb3IgaWYvZWxzZSBibG9ja3MgLS0gbm90IGxvb3BzXG5cblx0XHRcdCMgd2UgbmVlZCB0byBjb21wYXJlIHRoZSByZWFsIGxlbmd0aFxuXHRcdFx0aWYgIW5vZGUuQGxvb3AgJiYgcmVhbDpsZW5ndGggPiAxXG5cdFx0XHRcdCMgcCBcImxlbmd0aHNcIixAbm9kZXM6bGVuZ3RoLGV4cHJlc3Npb25zOmxlbmd0aFxuXHRcdFx0XHRsZXQgbnIgPSBub2RlLmJsb2Nrcy5wdXNoKHNlbGYpXG5cdFx0XHRcdHZhciBhcnIgPSBBcnIubmV3KEFyZ0xpc3QubmV3KCBAbm9kZXMgKSlcblx0XHRcdFx0YXJyLmluZGVudGVkKEBpbmRlbnRhdGlvbilcblx0XHRcdFx0QGluZGVudGF0aW9uID0gbnVsbFxuXG5cdFx0XHRcdGlmIG5vZGUucmVhY3RpdmVcblx0XHRcdFx0XHRAbm9kZXMgPSBbVXRpbC5jYWxsSW1iYShcInN0YXRpY1wiLFthcnIsTnVtLm5ldyhucildKV1cblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdEBub2RlcyA9IFthcnJdXG5cblx0XHRcdFxuXHRcdFxuXHRcdFx0cmV0dXJuIHNlbGZcblxuXHRcdCMgY2FuIGFsc28gcmV0dXJuIHN1cGVyIGlmIGl0IGlzIGV4cHJlc3NhYmxlLCBidXQgc2hvdWxkIHdlIHJlYWxseT9cblx0XHRpZiB2YXIgYmVmb3JlID0gbGFzdFxuXHRcdFx0dmFyIGFmdGVyID0gYmVmb3JlLmNvbnN1bWUobm9kZSlcblx0XHRcdGlmIGFmdGVyICE9IGJlZm9yZVxuXHRcdFx0XHQjIHAgXCJyZXBsYWNlIG5vZGUgaW4gYmxvY2sge2JlZm9yZX0gLT4ge2FmdGVyfVwiXG5cdFx0XHRcdGlmIGFmdGVyIGlzYSBCbG9ja1xuXHRcdFx0XHRcdCMgcCBcInJlcGxhY2VkIHdpdGggYmxvY2sgLS0gc2hvdWxkIGJhc2ljYWxseSBhZGQgaXQgaW5zdGVhZD9cIlxuXHRcdFx0XHRcdGFmdGVyID0gYWZ0ZXIubm9kZXNcblxuXHRcdFx0XHRyZXBsYWNlKGJlZm9yZSxhZnRlcilcblx0XHQjIHJlYWxseT9cblx0XHRyZXR1cm4gc2VsZlxuXG5cblx0ZGVmIGlzRXhwcmVzc2FibGVcblx0XHRyZXR1cm4gbm8gdW5sZXNzIEBub2Rlcy5ldmVyeSh8dnwgdi5pc0V4cHJlc3NhYmxlIClcblx0XHRyZXR1cm4geWVzXG5cblx0ZGVmIGlzRXhwcmVzc2lvblxuXHRcblx0XHRvcHRpb24oOmV4cHJlc3MpIHx8IEBleHByZXNzaW9uXG5cblxuIyB0aGlzIGlzIGFsbW9zdCBsaWtlIHRoZSBvbGQgVmFyRGVjbGFyYXRpb25zIGJ1dCB3aXRob3V0IHRoZSB2YWx1ZXNcbmV4cG9ydCBjbGFzcyBWYXJCbG9jayA8IExpc3ROb2RlXG5cblxuXHRkZWYgbG9hZCBsaXN0XG5cdFx0dmFyIGZpcnN0ID0gbGlzdFswXVxuXG5cdFx0aWYgZmlyc3QgaXNhIEFzc2lnblxuXHRcdFx0QHR5cGUgPSBmaXJzdC5sZWZ0LkB0eXBlXG5cdFx0ZWxpZiBmaXJzdCBpc2EgVmFyUmVmZXJlbmNlXG5cdFx0XHRAdHlwZSA9IGZpcnN0LkB0eXBlXG5cdFx0IyBwIFwiaGVyZSB7bGlzdFswXX0gLSB7QHR5cGV9XCJcblx0XHQjIEB0eXBlID0gbGlzdFswXSBhbmQgbGlzdFswXS50eXBlXG5cdFx0bGlzdFxuXHRcdFxuXHQjIFRPRE8gQWxsIHRoZXNlIGlubmVyIGl0ZW1zIHNob3VsZCByYXRoZXIgYmUgc3RyYWlnaHQgdXAgbGl0ZXJhbHNcblx0IyBvciBiYXNpYyBsb2NhbHZhcnMgLSB3aXRob3V0IGFueSBjYXJlIHdoYXRzb2V2ZXIgYWJvdXQgYWRkaW5nIHZhciB0byB0aGVcblx0IyBiZWdpbm5pbmcgZXRjLiBcblx0ZGVmIGFkZEV4cHJlc3Npb24gZXhwclxuXHRcdCMgcCBcIlZhckJsb2NrLmFkZEV4cHJlc3Npb24ge3NlbGZ9IDwtIHtleHByfVwiXG5cblx0XHRpZiBleHByIGlzYSBBc3NpZ25cblx0XHRcdCMgbWFrZSBzdXJlIHRoZSBsZWZ0LXNpZGUgaXMgYSB2YXItcmVmZXJlbmNlXG5cdFx0XHQjIHRoaXMgc2hvdWxkIGJlIGEgZGlmZmVyZW50IHR5cGUgb2YgYXNzaWduLCBubz9cblx0XHRcdGlmIGV4cHIubGVmdCBpc2EgVmFyT3JBY2Nlc3Ncblx0XHRcdFx0ZXhwci5sZWZ0ID0gVmFyUmVmZXJlbmNlLm5ldyhleHByLmxlZnQudmFsdWUsQHR5cGUpXG5cblx0XHRcdHB1c2goZXhwcilcblxuXHRcdGVsaWYgZXhwciBpc2EgQXNzaWduXG5cdFx0XHRhZGRFeHByZXNzaW9uKGV4cHIubGVmdCkgIyBtYWtlIHN1cmUgdGhpcyBpcyBhIHZhbGlkIHRoaW5nP1xuXHRcdFx0IyBtYWtlIHRoaXMgaW50byBhIHR1cGxlIGluc3RlYWRcblx0XHRcdCMgZG9lcyBub3QgbmVlZCB0byBiZSBhIHR1cGxlP1xuXHRcdFx0cmV0dXJuIFR1cGxlQXNzaWduLm5ldygnPScsVHVwbGUubmV3KG5vZGVzKSxleHByLnJpZ2h0KVxuXG5cdFx0ZWxpZiBleHByIGlzYSBWYXJPckFjY2Vzc1xuXHRcdFx0IyB0aGlzIGlzIHJlYWxseSBhIFZhclJlZmVyZW5jZVxuXHRcdFx0cHVzaChWYXJSZWZlcmVuY2UubmV3KGV4cHIudmFsdWUsQHR5cGUpKVxuXG5cdFx0ZWxpZiBleHByIGlzYSBTcGxhdCAmJiBleHByLm5vZGUgaXNhIFZhck9yQWNjZXNzXG5cdFx0XHQjIHAgXCJpcyBhIHNwbGF0IC0gb25seSBhbGxvd2VkIGluIHR1cGxlLWFzc2lnbm1lbnRcIlxuXHRcdFx0IyB3aGF0P1xuXHRcdFx0ZXhwci52YWx1ZSA9IFZhclJlZmVyZW5jZS5uZXcoZXhwci5ub2RlLnZhbHVlLEB0eXBlKVxuXHRcdFx0cHVzaChleHByKVxuXHRcdGVsc2Vcblx0XHRcdHAgXCJWYXJCbG9jay5hZGRFeHByZXNzaW9uIHtzZWxmfSA8LSB7ZXhwcn1cIlxuXHRcdFx0dGhyb3cgXCJWYXJCbG9jayBkb2VzIG5vdCBhbGxvdyBub24tdmFyaWFibGUgZXhwcmVzc2lvbnNcIlxuXHRcdHNlbGZcblxuXG5cdGRlZiBpc0V4cHJlc3NhYmxlXG5cdFx0IyB3ZSB3b3VsZCBuZWVkIHRvIGZvcmNlLWRyb3AgdGhlIHZhcmlhYmxlcywgbWFrZXMgbGl0dGxlIHNlbnNlXG5cdFx0IyBidXQsIGl0IGNvdWxkIGJlLCBjb3VsZCBqdXN0IHB1c2ggdGhlIHZhcmlhYmxlcyBvdXQ/XG5cdFx0bm9cblxuXHRkZWYganMgb1xuXHRcdCMgcCBcIlZhckJsb2NrXCJcblx0XHQjIGZvciBuIGluIEBub2Rlc1xuXHRcdCMgXHRwIFwiVmFyQmxvY2sgY2hpbGQge259XCJcblx0XHR2YXIgY29kZSA9IGNvbXBhY3RfXyhmbGF0dGVuX18oY2FyeV9fKG5vZGVzKSkpXG5cdFx0Y29kZSA9IGNvZGUuZmlsdGVyKHxufCBuICE9IG51bGwgJiYgbiAhPSB1bmRlZmluZWQgJiYgbiAhPSBFTVBUWSlcblx0XHR2YXIgb3V0ID0gY29kZS5qb2luKFwiLFwiKVxuXHRcdCMgd2UganVzdCBuZWVkIHRvIHRydXN0IHRoYXQgdGhlIHZhcmlhYmxlcyBoYXZlIGJlZW4gYXV0b2RlY2xhcmVkIGJlZm9yZWhhbmRcblx0XHQjIGlmIHdlIGFyZSBpbnNpZGUgYW4gZXhwcmVzc2lvblxuXHRcdG91dCA9IFwidmFyIFwiICsgb3V0IHVubGVzcyBvLmlzRXhwcmVzc2lvblxuXHRcdHJldHVybiBvdXRcblxuXG5cdGRlZiBjb25zdW1lIG5vZGVcblx0XHQjIEl0IGRvZXNudCBtYWtlIG11Y2ggc2Vuc2UgZm9yIGEgVmFyQmxvY2sgdG8gY29uc3VtZSBhbnl0aGluZ1xuXHRcdCMgaXQgc2hvdWxkIHByb2JhYmx5IHJldHVybiB2b2lkIGZvciBtZXRob2RzXG5cdFx0cmV0dXJuIHNlbGZcblxuXG4jIENvdWxkIGluaGVyaXQgZnJvbSB2YWx1ZU5vZGVcbmV4cG9ydCBjbGFzcyBQYXJlbnMgPCBWYWx1ZU5vZGVcblxuXHRkZWYgaW5pdGlhbGl6ZSB2YWx1ZSwgb3BlbiwgY2xvc2Vcblx0XHRzZXR1cFxuXHRcdEBvcGVuID0gb3BlblxuXHRcdEBjbG9zZSA9IGNsb3NlXG5cdFx0QHZhbHVlID0gbG9hZCh2YWx1ZSlcblx0XG5cdGRlZiBsb2FkIHZhbHVlXG5cdFx0QG5vcGFyZW4gPSBub1xuXHRcdHZhbHVlIGlzYSBCbG9jayBhbmQgdmFsdWUuY291bnQgPT0gMSA/IHZhbHVlLmZpcnN0IDogdmFsdWVcblxuXHRkZWYgaXNTdHJpbmdcblx0XHQjIGNoZWNraW5nIGlmIHRoaXMgaXMgYW4gaW50ZXJwb2xhdGVkIHN0cmluZ1xuXHRcdEBvcGVuIGFuZCBTdHJpbmcoQG9wZW4pID09ICcoXCInIG9yIHZhbHVlLmlzU3RyaW5nXG5cdFx0XG5cdGRlZiBqcyBvXG5cblx0XHR2YXIgcGFyID0gdXBcblx0XHR2YXIgdiA9IEB2YWx1ZVxuXHRcdHZhciBzdHIgPSBudWxsXG5cblx0XHRAbm9wYXJlbiA9IHllcyBpZiB2IGlzYSBGdW5jXG5cdFx0IyBwIFwiY29tcGlsZSBwYXJlbnMge3Z9IHt2IGlzYSBCbG9jayBhbmQgdi5jb3VudH1cIlxuXHRcdCMgcCBcIlBhcmVucyB1cCB7cGFyfSB7by5pc0V4cHJlc3Npb259XCJcblx0XHRpZiBwYXIgaXNhIEJsb2NrXG5cdFx0XHQjIGlzIGl0IHdvcnRoIGl0P1xuXHRcdFx0QG5vcGFyZW4gPSB5ZXMgdW5sZXNzIG8uaXNFeHByZXNzaW9uXG5cdFx0XHRzdHIgPSB2IGlzYSBBcnJheSA/IGNhcnlfXyh2KSA6IHYuYyhleHByZXNzaW9uOiBvLmlzRXhwcmVzc2lvbilcblx0XHRlbHNlXG5cdFx0XHRzdHIgPSB2IGlzYSBBcnJheSA/IGNhcnlfXyh2KSA6IHYuYyhleHByZXNzaW9uOiB5ZXMpXG5cblx0XHQjIGNoZWNrIGlmIHdlIHJlYWxseSBuZWVkIHBhcmVucyBoZXJlP1xuXHRcdHJldHVybiBzdHJcblxuXHRkZWYgc2V0IG9ialxuXHRcdGNvbnNvbGUubG9nIFwiUGFyZW5zIHNldCB7SlNPTi5zdHJpbmdpZnkob2JqKX1cIlxuXHRcdHN1cGVyKG9iailcblx0XHRcblxuXHRkZWYgc2hvdWxkUGFyZW50aGVzaXplXG5cdFx0IyBubyBuZWVkIHRvIHBhcmVudGhlc2l6ZSBpZiB0aGlzIGlzIGEgbGluZSBpbiBhIGJsb2NrXG5cdFx0cmV0dXJuIG5vIGlmIEBub3BhcmVuICMgIG9yIHBhciBpc2EgQXJnTGlzdFxuXHRcdHJldHVybiB5ZXNcblxuXG5cdGRlZiBwcmVicmVhayBiclxuXHRcdHN1cGVyKGJyKVxuXHRcdGNvbnNvbGUubG9nIFwiUFJFQlJFQUtcIlxuXHRcdEB2YWx1ZS5wcmVicmVhayhicikgaWYgQHZhbHVlXG5cdFx0c2VsZlxuXG5cblx0ZGVmIGlzRXhwcmVzc2FibGVcblx0XHRAdmFsdWUuaXNFeHByZXNzYWJsZVxuXG5cdGRlZiBjb25zdW1lIG5vZGVcblx0XHRAdmFsdWUuY29uc3VtZShub2RlKVxuXG5cbiMgQ291bGQgaW5oZXJpdCBmcm9tIHZhbHVlTm9kZVxuIyBhbiBleHBsaWNpdCBleHByZXNzaW9uLWJsb2NrICh3aXRoIHBhcmVucykgaXMgc29tZXdoYXQgZGlmZmVyZW50XG4jIGNhbiBiZSB1c2VkIHRvIHJldHVybiBhZnRlciBhbiBleHByZXNzaW9uXG5leHBvcnQgY2xhc3MgRXhwcmVzc2lvbkJsb2NrIDwgTGlzdE5vZGVcblxuXG5cdGRlZiBjXG5cdFx0bWFwKHxpdGVtfCBpdGVtLmMpLmpvaW4oXCIsXCIpXG5cblx0ZGVmIGNvbnN1bWUgbm9kZVxuXHRcdHZhbHVlLmNvbnN1bWUobm9kZSlcblxuXHRkZWYgYWRkRXhwcmVzc2lvbiBleHByXG5cdFx0IyBOZWVkIHRvIHRha2UgY2FyZSBvZiB0aGUgc3BsYXQgaGVyZSB0by4uIGhhenpsZVxuXHRcdGlmIGV4cHIubm9kZSBpc2EgQXNzaWduXG5cdFx0XHQjIHAgXCJpcyBhc3NpZ25tZW50IVwiXG5cdFx0XHRwdXNoKGV4cHIubGVmdClcblx0XHRcdCMgbWFrZSB0aGlzIGludG8gYSB0dXBsZSBpbnN0ZWFkXG5cdFx0XHQjIHBvc3NpYmx5IGZpeCB0aGlzIGFzIHdlbGw/IT9cblx0XHRcdHJldHVybiBUdXBsZUFzc2lnbi5uZXcoJz0nLFR1cGxlLm5ldyhub2RlcyksZXhwci5yaWdodClcblx0XHRlbHNlXG5cdFx0XHRwdXNoKGV4cHIpXG5cdFx0c2VsZlxuXG5cblxuIyBTVEFURU1FTlRTXG5cbmV4cG9ydCBjbGFzcyBSZXR1cm4gPCBTdGF0ZW1lbnRcblxuXHRwcm9wIHZhbHVlXG5cblx0ZGVmIGluaXRpYWxpemUgdlxuXHRcdEB0cmF2ZXJzZWQgPSBub1xuXHRcdEB2YWx1ZSA9IHYgaXNhIEFyZ0xpc3QgYW5kIHYuY291bnQgPT0gMSA/IHYubGFzdCA6IHZcblx0XHQjIEBwcmVicmVhayA9IHYgYW5kIHYuQHByZWJyZWFrXG5cdFx0IyBjb25zb2xlLmxvZyBcInJldHVybj8hPyB7dn1cIixAcHJlYnJlYWtcblx0XHQjIGlmIHYgaXNhIEFyZ0xpc3QgYW5kIHYuY291bnQgPT0gMVxuXHRcdHJldHVybiBzZWxmXG5cblx0ZGVmIHZpc2l0XG5cdFx0QHZhbHVlLnRyYXZlcnNlIGlmIEB2YWx1ZSAmJiBAdmFsdWU6dHJhdmVyc2VcblxuXHRkZWYganMgb1xuXHRcdHZhciB2ID0gQHZhbHVlXG5cblx0XHRpZiB2IGlzYSBBcmdMaXN0XG5cdFx0XHRyZXR1cm4gXCJyZXR1cm4gW3t2LmMoZXhwcmVzc2lvbjogeWVzKX1dXCJcblx0XHRlbGlmIHZcblx0XHRcdHJldHVybiBcInJldHVybiB7di5jKGV4cHJlc3Npb246IHllcyl9XCJcblx0XHRlbHNlXG5cdFx0XHRcInJldHVyblwiXG5cblx0ZGVmIGNcblx0XHRyZXR1cm4gc3VwZXIgaWYgIXZhbHVlIG9yIHZhbHVlLmlzRXhwcmVzc2FibGVcblx0XHQjIHAgXCJyZXR1cm4gbXVzdCBjYXNjYWRlIGludG8gdmFsdWVcIi5yZWRcblx0XHR2YWx1ZS5jb25zdW1lKHNlbGYpLmNcblxuXHRkZWYgY29uc3VtZSBub2RlXG5cdFx0cmV0dXJuIHNlbGZcblxuZXhwb3J0IGNsYXNzIEltcGxpY2l0UmV0dXJuIDwgUmV0dXJuXG5cbmV4cG9ydCBjbGFzcyBHcmVlZHlSZXR1cm4gPCBJbXBsaWNpdFJldHVyblxuXG4jIGNhbm5vdCBsaXZlIGluc2lkZSBhbiBleHByZXNzaW9uKCEpXG5leHBvcnQgY2xhc3MgVGhyb3cgPCBTdGF0ZW1lbnRcblxuXHRkZWYganMgb1xuXHRcdFwidGhyb3cge3ZhbHVlLmN9XCJcblxuXHRkZWYgY29uc3VtZSBub2RlXG5cdFx0IyBST0FETUFQIHNob3VsZCBwb3NzaWJseSBjb25zdW1lIHRvIHRoZSB2YWx1ZSBvZiB0aHJvdyBhbmQgdGhlbiB0aHJvdz9cblx0XHRyZXR1cm4gc2VsZlxuXHRcdFxuXG5leHBvcnQgY2xhc3MgTG9vcEZsb3dTdGF0ZW1lbnQgPCBTdGF0ZW1lbnRcblxuXHRwcm9wIGxpdGVyYWxcblx0cHJvcCBleHByZXNzaW9uXG5cblx0ZGVmIGluaXRpYWxpemUgbGl0LCBleHByXG5cdFx0c2VsZi5saXRlcmFsID0gbGl0XG5cdFx0c2VsZi5leHByZXNzaW9uID0gZXhwciAjICYmIEFyZ0xpc3QubmV3KGV4cHIpICMgcmVhbGx5P1xuXG5cdGRlZiB2aXNpdFxuXHRcdGV4cHJlc3Npb24udHJhdmVyc2UgaWYgZXhwcmVzc2lvblxuXG5cdGRlZiBjb25zdW1lIG5vZGVcblx0XHQjIHAgXCJicmVhay9jb250aW51ZSBzaG91bGQgY29uc3VtZT8hXCJcblx0XHRzZWxmXG5cblx0ZGVmIGNcblx0XHRyZXR1cm4gc3VwZXIgdW5sZXNzIGV4cHJlc3Npb25cblx0XHQjIGdldCB1cCB0byB0aGUgb3V0ZXIgbG9vcFxuXHRcdHZhciBfbG9vcCA9IFNUQUNLLnVwKExvb3ApXG5cdFx0IyBwIFwiZm91bmQgbG9vcD9cIixfbG9vcFxuXG5cdFx0IyBuZWVkIHRvIGZpeCB0aGUgZ3JhbW1hciBmb3IgdGhpcy4gUmlnaHQgbm93IGl0IFxuXHRcdCMgaXMgbGlrZSBhIGZha2UgY2FsbCwgYnV0IHNob3VsZCBvbmx5IGNhcmUgYWJvdXQgdGhlIGZpcnN0IGFyZ3VtZW50XG5cdFx0dmFyIGV4cHIgPSBzZWxmLmV4cHJlc3Npb25cblxuXHRcdGlmIF9sb29wLmNhdGNoZXJcblx0XHRcdGV4cHIgPSBleHByLmNvbnN1bWUoX2xvb3AuY2F0Y2hlcilcblx0XHRcdHZhciBjb3B5ID0gc2VsZjpjb25zdHJ1Y3Rvci5uZXcobGl0ZXJhbClcblx0XHRcdEJsb2NrLm5ldyhbZXhwcixjb3B5XSkuY1xuXHRcdGVsaWYgZXhwclxuXHRcdFx0dmFyIGNvcHkgPSBzZWxmOmNvbnN0cnVjdG9yLm5ldyhsaXRlcmFsKVxuXHRcdFx0QmxvY2submV3KFtleHByLGNvcHldKS5jXG5cdFx0ZWxzZVxuXHRcdFx0c3VwZXJcblx0XHQjIHJldHVybiBcImxvb3BmbG93XCJcblx0XHRcblxuZXhwb3J0IGNsYXNzIEJyZWFrU3RhdGVtZW50IDwgTG9vcEZsb3dTdGF0ZW1lbnRcblx0ZGVmIGpzIG8gZG8gXCJicmVha1wiXG5cbmV4cG9ydCBjbGFzcyBDb250aW51ZVN0YXRlbWVudCA8IExvb3BGbG93U3RhdGVtZW50XG5cdGRlZiBqcyBvIGRvIFwiY29udGludWVcIlxuXG5leHBvcnQgY2xhc3MgRGVidWdnZXJTdGF0ZW1lbnQgPCBTdGF0ZW1lbnRcblxuXG4jIFBBUkFNU1xuXG5leHBvcnQgY2xhc3MgUGFyYW0gPCBOb2RlXG5cblx0cHJvcCBuYW1lXG5cdHByb3AgaW5kZXhcblx0cHJvcCBkZWZhdWx0c1xuXHRwcm9wIHNwbGF0XG5cdHByb3AgdmFyaWFibGVcblxuXHQjIHdoYXQgYWJvdXQgb2JqZWN0LXBhcmFtcz9cblxuXHRkZWYgaW5pdGlhbGl6ZSBuYW1lLCBkZWZhdWx0cywgdHlwXG5cdFx0IyBjb3VsZCBoYXZlIGludHJvZHVjZWQgYnVncyBieSBtb3ZpbmcgYmFjayB0byBpZGVudGlmaWVyIGhlcmVcblx0XHRAdHJhdmVyc2VkID0gbm9cblx0XHRAbmFtZSA9IG5hbWUgIyAudmFsdWUgIyB0aGlzIGlzIGFuIGlkZW50aWZpZXIoISlcblx0XHRAZGVmYXVsdHMgPSBkZWZhdWx0c1xuXHRcdEB0eXAgPSB0eXBcblx0XHRAdmFyaWFibGUgPSBudWxsXG5cblx0ZGVmIHZhcm5hbWVcblx0XHRAdmFyaWFibGUgPyBAdmFyaWFibGUuYyA6IG5hbWVcblxuXHRkZWYganMgb1xuXHRcdHJldHVybiBAdmFyaWFibGUuYyBpZiBAdmFyaWFibGVcblxuXHRcdGlmIGRlZmF1bHRzXG5cdFx0XHQjIHNob3VsZCBub3QgaW5jbHVkZSBhbnkgc291cmNlLW1hcHBpbmcgaGVyZT9cblx0XHRcdFwiaWYoe25hbWUuY30gPT0gbnVsbCkge25hbWUuY30gPSB7ZGVmYXVsdHMuY31cIlxuXHRcdCMgc2VlIGlmIHRoaXMgaXMgdGhlIGluaXRpYWwgZGVjbGFyYXRvcj9cblxuXHRkZWYgdmlzaXRcblx0XHRAZGVmYXVsdHMudHJhdmVyc2UgaWYgQGRlZmF1bHRzXG5cdFx0c2VsZi52YXJpYWJsZSB8fD0gc2NvcGVfXy5yZWdpc3RlcihuYW1lLHNlbGYpXG5cblx0XHRpZiBAbmFtZSBpc2EgSWRlbnRpZmllclxuXHRcdFx0IyBjaGFuZ2UgdHlwZSBoZXJlP1xuXHRcdFx0QG5hbWUuQHZhbHVlLkB0eXBlID0gXCJQQVJBTVZBUlwiIGlmIEBuYW1lLkB2YWx1ZVxuXHRcdFx0QG5hbWUucmVmZXJlbmNlcyhAdmFyaWFibGUpXG5cdFx0XHQjIGNvbnNvbGUubG9nIFwiZ290IGhlcmUhISB7QG5hbWU6Y29uc3RydWN0b3J9XCJcblx0XHRcdCMgQG5hbWUuQHRva2VuLkB2YXJpYWJsZSA9IEB2YXJpYWJsZSBpZiBAbmFtZS5AdG9rZW5cblx0XHRcblx0XHRzZWxmXG5cblx0ZGVmIGFzc2lnbm1lbnRcblx0XHRPUCgnPScsdmFyaWFibGUuYWNjZXNzb3IsZGVmYXVsdHMpXG5cblx0ZGVmIGlzRXhwcmVzc2FibGVcblx0XHQhZGVmYXVsdHMgfHwgZGVmYXVsdHMuaXNFeHByZXNzYWJsZVxuXHRcdCMgcCBcInZpc2l0aW5nIHBhcmFtISEhXCJcblxuXHRkZWYgZHVtcFxuXHRcdHtsb2M6IGxvY31cblxuXHRkZWYgbG9jXG5cdFx0QG5hbWUgJiYgQG5hbWUucmVnaW9uXG5cblx0ZGVmIHRvSlNPTlxuXHRcdHtcblx0XHRcdHR5cGU6IHR5cGVOYW1lXG5cdFx0XHRuYW1lOiBuYW1lXG5cdFx0XHRkZWZhdWx0czogZGVmYXVsdHNcblx0XHR9XG5cdFx0XG5cbmV4cG9ydCBjbGFzcyBTcGxhdFBhcmFtIDwgUGFyYW1cblxuXHRkZWYgbG9jXG5cdFx0IyBoYWNreS4uIGNhbm5vdCBrbm93IGZvciBzdXJlIHRoYXQgdGhpcyBpcyByaWdodD9cblx0XHR2YXIgciA9IG5hbWUucmVnaW9uXG5cdFx0W3JbMF0gLSAxLHJbMV1dXG5cbmV4cG9ydCBjbGFzcyBCbG9ja1BhcmFtIDwgUGFyYW1cblxuXHRkZWYgY1xuXHRcdFwiYmxvY2twYXJhbVwiXG5cblx0ZGVmIGxvY1xuXHRcdCMgaGFja3kuLiBjYW5ub3Qga25vdyBmb3Igc3VyZSB0aGF0IHRoaXMgaXMgcmlnaHQ/XG5cdFx0dmFyIHIgPSBuYW1lLnJlZ2lvblxuXHRcdFtyWzBdIC0gMSxyWzFdXVxuXG5cbmV4cG9ydCBjbGFzcyBPcHRpb25hbFBhcmFtIDwgUGFyYW1cblxuZXhwb3J0IGNsYXNzIE5hbWVkUGFyYW0gPCBQYXJhbVxuXG5leHBvcnQgY2xhc3MgUmVxdWlyZWRQYXJhbSA8IFBhcmFtXG5cbmV4cG9ydCBjbGFzcyBOYW1lZFBhcmFtcyA8IExpc3ROb2RlXG5cblx0cHJvcCBpbmRleFxuXHRwcm9wIHZhcmlhYmxlXG5cblx0ZGVmIGxvYWQgbGlzdFxuXHRcdHZhciBsb2FkID0gKHxrfCBOYW1lZFBhcmFtLm5ldyhrLmtleSxrLnZhbHVlKSApXG5cdFx0bGlzdCBpc2EgT2JqID8gbGlzdC52YWx1ZS5tYXAobG9hZCkgOiBsaXN0XG5cblx0ZGVmIHZpc2l0XG5cdFx0dmFyIHMgPSBzY29wZV9fXG5cdFx0QHZhcmlhYmxlIHx8PSBzLnRlbXBvcmFyeShzZWxmLCBwb29sOiAna2V5cGFycycpXG5cdFx0QHZhcmlhYmxlLnByZWRlY2xhcmVkXG5cblx0XHQjIHRoaXMgaXMgYSBsaXN0bm9kZSwgd2hpY2ggd2lsbCBhdXRvbWF0aWNhbGx5IHRyYXZlcnNlXG5cdFx0IyBhbmQgdmlzaXQgYWxsIGNoaWxkcmVuXG5cdFx0c3VwZXJcblx0XHQjIHJlZ2lzdGVyIHRoZSBpbm5lciB2YXJpYWJsZXMgYXMgd2VsbCghKVxuXHRcdHNlbGZcblxuXG5cdGRlZiB2YXJuYW1lXG5cdFx0dmFyaWFibGUuY1xuXG5cdGRlZiBuYW1lXG5cdFx0dmFybmFtZVxuXG5cdGRlZiBqcyBvXG5cdFx0XCJuYW1lZHBhclwiXG5cblx0ZGVmIHRvSlNPTlxuXHRcdHtcblx0XHRcdHR5cGU6IHR5cGVOYW1lXG5cdFx0XHRub2RlczogZmlsdGVyKHx2fCB2IGlzYSBOYW1lZFBhcmFtKVxuXHRcdH1cblxuXG5leHBvcnQgY2xhc3MgSW5kZXhlZFBhcmFtIDwgUGFyYW1cblxuXHRwcm9wIHBhcmVudFxuXHRwcm9wIHN1YmluZGV4XG5cblx0ZGVmIHZpc2l0XG5cdFx0IyBwIFwiVklTSVQgUEFSQU0ge25hbWV9IVwiXG5cdFx0IyBhcnkuWy0xXSAjIHBvc3NpYmxlXG5cdFx0IyBhcnkuKC0xKSAjIHBvc3NpYmxlXG5cdFx0IyBzdHIoL29rLywtMSlcblx0XHQjIHNjb3BlLnJlZ2lzdGVyKEBuYW1lLHNlbGYpXG5cdFx0IyBCVUcgVGhlIGRlZmF1bHRzIHNob3VsZCBwcm9iYWJseSBiZSBsb29rZWQgdXAgbGlrZSB2YXJzXG5cdFx0c2VsZi52YXJpYWJsZSB8fD0gc2NvcGVfXy5yZWdpc3RlcihuYW1lLHNlbGYpXG5cdFx0c2VsZi52YXJpYWJsZS5wcm94eShwYXJlbnQudmFyaWFibGUsc3ViaW5kZXgpXG5cdFx0c2VsZlxuXG5cbmV4cG9ydCBjbGFzcyBBcnJheVBhcmFtcyA8IExpc3ROb2RlXG5cblx0cHJvcCBpbmRleFxuXHRwcm9wIHZhcmlhYmxlXG5cblx0ZGVmIHZpc2l0XG5cdFx0dmFyIHMgPSBzY29wZV9fXG5cdFx0QHZhcmlhYmxlIHx8PSBzLnRlbXBvcmFyeShzZWxmLCBwb29sOiAna2V5cGFycycpXG5cdFx0QHZhcmlhYmxlLnByZWRlY2xhcmVkXG5cblx0XHQjIG5vdyB3aGVuIHdlIGxvb3AgdGhyb3VnaCB0aGVzZSBpbm5lciBwYXJhbXMgLSB3ZSBjcmVhdGUgdGhlIHBhcnNcblx0XHQjIHdpdGggdGhlIGNvcnJlY3QgbmFtZSwgYnV0IGJpbmQgdGhlbSB0byB0aGUgcGFyZW50XG5cdFx0c3VwZXJcblxuXHRkZWYgbmFtZVxuXHRcdHZhcmlhYmxlLmNcblxuXHRkZWYgbG9hZCBsaXN0XG5cdFx0cmV0dXJuIG51bGwgdW5sZXNzIGxpc3QgaXNhIEFyclxuXHRcdCMgcCBcImxvYWRpbmcgYXJyYXlwYXJhbXNcIlxuXHRcdCMgdHJ5IHRoZSBiYXNpYyBmaXJzdFxuXHRcdHVubGVzcyBsaXN0LnNwbGF0XG5cdFx0XHRsaXN0LnZhbHVlLm1hcCBkbyB8dixpfFxuXHRcdFx0XHQjIG11c3QgbWFrZSBzdXJlIHRoZSBwYXJhbXMgYXJlIHN1cHBvcnRlZCBoZXJlXG5cdFx0XHRcdCMgc2hvdWxkIHJlYWxseSBub3QgcGFyc2UgYW55IGFycmF5IGF0IGFsbCghKVxuXHRcdFx0XHR2YXIgbmFtZSA9IHZcblx0XHRcdFx0aWYgdiBpc2EgVmFyT3JBY2Nlc3Ncblx0XHRcdFx0XHQjIHAgXCJ2YXJvcmFjY2VzcyB7di52YWx1ZX1cIlxuXHRcdFx0XHRcdCMgRklYP1xuXHRcdFx0XHRcdG5hbWUgPSB2LnZhbHVlLnZhbHVlXG5cdFx0XHRcdFx0IyB0aGlzIGlzIGFjY2VwdGVkXG5cdFx0XHRcdHBhcnNlKG5hbWUsdixpKVxuXG5cdGRlZiBwYXJzZSBuYW1lLGNoaWxkLGlcblx0XHR2YXIgcGFyYW0gPSBJbmRleGVkUGFyYW0ubmV3KG5hbWUsbnVsbClcblxuXHRcdHBhcmFtLnBhcmVudCA9IHNlbGZcblx0XHRwYXJhbS5zdWJpbmRleCA9IGlcblx0XHRwYXJhbVxuXG5cdGRlZiBoZWFkIGFzdFxuXHRcdCMgXCJhcnJheXBhcmFtc1wiXG5cdFx0c2VsZlxuXG5leHBvcnQgY2xhc3MgUGFyYW1MaXN0IDwgTGlzdE5vZGVcblxuXHRwcm9wIHNwbGF0XG5cdHByb3AgYmxvY2tcblxuXHRkZWYgYXQgaW5kZXgsIGZvcmNlID0gbm8sIG5hbWUgPSBudWxsXG5cdFx0aWYgZm9yY2Vcblx0XHRcdGFkZChQYXJhbS5uZXcoY291bnQgPT0gaW5kZXggJiYgbmFtZSB8fCBcIl97Y291bnR9XCIpKSB1bnRpbCBjb3VudCA+IGluZGV4XG5cdFx0XHQjIG5lZWQgdG8gdmlzaXQgYXQgdGhlIHNhbWUgdGltZSwgbm8/XG5cdFx0bGlzdFtpbmRleF1cblxuXHRkZWYgbWV0YWRhdGFcblx0XHRmaWx0ZXIofHBhcnwgIShwYXIgaXNhIE1ldGEpKVxuXG5cdGRlZiB0b0pTT05cblx0XHRtZXRhZGF0YVxuXG5cdGRlZiB2aXNpdFxuXHRcdEBzcGxhdCA9IGZpbHRlcih8cGFyfCBwYXIgaXNhIFNwbGF0UGFyYW0pWzBdXG5cdFx0dmFyIGJsayA9IGZpbHRlcih8cGFyfCBwYXIgaXNhIEJsb2NrUGFyYW0pXG5cblx0XHRpZiBibGs6bGVuZ3RoID4gMVxuXHRcdFx0YmxrWzFdLndhcm4gXCJhIG1ldGhvZCBjYW4gb25seSBoYXZlIG9uZSAmYmxvY2sgcGFyYW1ldGVyXCJcblxuXHRcdGVsaWYgYmxrWzBdICYmIGJsa1swXSAhPSBsYXN0XG5cdFx0XHRibGtbMF0ud2FybiBcIiZibG9jayBtdXN0IGJlIHRoZSBsYXN0IHBhcmFtZXRlciBvZiBhIG1ldGhvZFwiXG5cdFx0XHQjIHdhcm4gXCImYmxvY2sgbXVzdCBiZSB0aGUgbGFzdCBwYXJhbWV0ZXIgb2YgYSBtZXRob2RcIiwgYmxrWzBdXG5cblx0XHQjIGFkZCBtb3JlIHdhcm5pbmdzIGxhdGVyKCEpXG5cdFx0IyBzaG91bGQgcHJvYmFibHkgdGhyb3cgZXJyb3IgYXMgd2VsbCB0byBzdG9wIGNvbXBpbGF0aW9uXG5cblx0XHQjIG5lZWQgdG8gcmVnaXN0ZXIgdGhlIHJlcXVpcmVkLXBhcnMgYXMgdmFyaWFibGVzXG5cdFx0c3VwZXJcblxuXHRkZWYganMgb1xuXHRcdHJldHVybiBFTVBUWSBpZiBjb3VudCA9PSAwXG5cdFx0cmV0dXJuIGhlYWQobykgaWYgby5wYXJlbnQgaXNhIEJsb2NrXG5cblx0XHQjIGl0ZW1zID0gbWFwKHxhcmd8IGFyZy5uYW1lLmMgKS5jb21wYWN0XG5cdFx0IyByZXR1cm4gbnVsbCB1bmxlc3MgaXRlbXNbMF1cblxuXHRcdGlmIG8ucGFyZW50IGlzYSBDb2RlXG5cdFx0XHQjIHJlbW92ZSB0aGUgc3BsYXQsIGZvciBzdXJlLi4gbmVlZCB0byBoYW5kbGUgdGhlIG90aGVyIGl0ZW1zIGFzIHdlbGxcblx0XHRcdCMgdGhpcyBpcyBtZXNzeSB3aXRoIHJlZmVyZW5jZXMgdG8gYXJndmFycyBldGMgZXRjLiBGaXhcblx0XHRcdHZhciBwYXJzID0gbm9kZXNcblx0XHRcdCMgcGFycyA9IGZpbHRlcih8YXJnfCBhcmcgIT0gQHNwbGF0ICYmICEoYXJnIGlzYSBCbG9ja1BhcmFtKSkgaWYgQHNwbGF0XG5cdFx0XHRwYXJzID0gZmlsdGVyKHxhcmd8IGFyZyBpc2EgUmVxdWlyZWRQYXJhbSBvciBhcmcgaXNhIE9wdGlvbmFsUGFyYW0pIGlmIEBzcGxhdFxuXHRcdFx0Y29tcGFjdF9fKHBhcnMubWFwKHxhcmd8IGNfXyhhcmcudmFybmFtZSkgKSkuam9pbihcIixcIilcblx0XHRlbHNlXG5cdFx0XHR0aHJvdyBcIm5vdCBpbXBsZW1lbnRlZCBwYXJhbWxpc3QganNcIlxuXHRcdFx0XCJ0YVwiICsgY29tcGFjdF9fKG1hcCh8YXJnfCBhcmcuYyApKS5qb2luKFwiLFwiKVxuXG5cdGRlZiBoZWFkIG9cblx0XHR2YXIgcmVnID0gW11cblx0XHR2YXIgb3B0ID0gW11cblx0XHR2YXIgYmxrID0gbnVsbFxuXHRcdHZhciBzcGxhdCA9IG51bGxcblx0XHR2YXIgbmFtZWQgPSBudWxsXG5cdFx0dmFyIGFyeXMgPSBbXVxuXHRcdHZhciBzaWduYXR1cmUgPSBbXVxuXHRcdHZhciBpZHggPSAwXG5cblx0XHRub2Rlcy5mb3JFYWNoIGRvIHxwYXIsaXxcblx0XHRcdHBhci5pbmRleCA9IGlkeFxuXHRcdFx0aWYgcGFyIGlzYSBOYW1lZFBhcmFtc1xuXHRcdFx0XHRzaWduYXR1cmUucHVzaCgnbmFtZWQnKVxuXHRcdFx0XHRuYW1lZCA9IHBhclxuXHRcdFx0ZWxpZiBwYXIgaXNhIE9wdGlvbmFsUGFyYW0gXG5cdFx0XHRcdHNpZ25hdHVyZS5wdXNoKCdvcHQnKVxuXHRcdFx0XHRvcHQucHVzaChwYXIpXG5cdFx0XHRlbGlmIHBhciBpc2EgQmxvY2tQYXJhbVxuXHRcdFx0XHRzaWduYXR1cmUucHVzaCgnYmxrJylcblx0XHRcdFx0YmxrID0gcGFyXG5cdFx0XHRlbGlmIHBhciBpc2EgU3BsYXRQYXJhbVxuXHRcdFx0XHRzaWduYXR1cmUucHVzaCgnc3BsYXQnKVxuXHRcdFx0XHRzcGxhdCA9IHBhclxuXHRcdFx0XHRpZHggLT0gMSAjIHRoaXMgc2hvdWxkIHJlYWxseSBiZSByZW1vdmVkIGZyb20gdGhlIGxpc3QsIG5vP1xuXHRcdFx0ZWxpZiBwYXIgaXNhIEFycmF5UGFyYW1zXG5cdFx0XHRcdGFyeXMucHVzaChwYXIpXG5cdFx0XHRcdHNpZ25hdHVyZS5wdXNoKCdhcnknKVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRzaWduYXR1cmUucHVzaCgncmVnJylcblx0XHRcdFx0cmVnLnB1c2gocGFyKVxuXHRcdFx0aWR4KytcblxuXHRcdGlmIG5hbWVkXG5cdFx0XHR2YXIgbmFtZWR2YXIgPSBuYW1lZC52YXJpYWJsZVxuXG5cdFx0IyB2YXIgb3B0ID0gbm9kZXMuZmlsdGVyKHxufCBuIGlzYSBPcHRpb25hbFBhcmFtKVxuXHRcdCMgdmFyIGJsayA9IG5vZGVzLmZpbHRlcih8bnwgbiBpc2EgQmxvY2tQYXJhbSlbMF1cblx0XHQjIHZhciBzcGxhdCA9IG5vZGVzLmZpbHRlcih8bnwgbiBpc2EgU3BsYXRQYXJhbSlbMF1cblxuXHRcdCMgc2ltcGxlIHNpdHVhdGlvbiB3aGVyZSB3ZSBzaW1wbHkgc3dpdGNoXG5cdFx0IyBjYW4gcHJvYmFibHkgb3B0aW1pemUgYnkgbm90IGxvb2tpbmcgYXQgYXJndW1lbnRzIGF0IGFsbFxuXHRcdHZhciBhc3QgPSBbXVxuXHRcdHZhciBpc0Z1bmMgPSBkbyB8anN8IFwidHlwZW9mIHtqc30gPT0gJ2Z1bmN0aW9uJ1wiXG5cblx0XHQjIFRoaXMgaXMgYnJva2VuIHdoZW4gZGVhbGluZyB3aXRoIGlmcmFtZXMgYW5jIFhTUyBzY3JpcHRpbmdcblx0XHQjIGJ1dCBmb3Igbm93IGl0IGlzIHRoZSBiZXN0IHRlc3QgZm9yIGFjdHVhbCBhcmd1bWVudHNcblx0XHQjIGNhbiBhbHNvIGRvIGNvbnN0cnVjdG9yLm5hbWUgPT0gJ09iamVjdCdcblx0XHR2YXIgaXNPYmogPSBkbyB8anN8IFwie2pzfS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0XCJcblx0XHR2YXIgaXNudE9iaiA9IGRvIHxqc3wgXCJ7anN9LmNvbnN0cnVjdG9yICE9PSBPYmplY3RcIlxuXHRcdCMgc2hvdWxkIGhhbmRsZSBzb21lIGNvbW1vbiBjYXNlcyBpbiBhIGNsZWFuZXIgKGxlc3MgdmVyYm9zZSkgbWFubmVyXG5cdFx0IyBkb2VzIHRoaXMgd29yayB3aXRoIGRlZmF1bHQgcGFyYW1zIGFmdGVyIG9wdGlvbmFsIG9uZXM/IElzIHRoYXQgZXZlbiB3b3J0aCBhbnl0aGluZz9cblx0XHQjIHRoaXMgb25seSB3b3JrcyBpbiBvbmUgZGlyZWN0aW9uIG5vdywgdW5saWtlIFR1cGxlQXNzaWduXG5cblx0XHQjIHdlIGRvbnQgcmVhbGx5IGNoZWNrIHRoZSBsZW5ndGggZXRjIG5vdyAtLSBzbyBpdCBpcyBidWdneSBmb3IgbG90cyBvZiBhcmd1bWVudHNcblxuXHRcdCMgaWYgd2UgaGF2ZSBvcHRpb25hbCBwYXJhbXMgaW4gdGhlIHJlZ3VsYXIgb3JkZXIgZXRjIHdlIGNhbiBnbyB0aGUgZWFzeSByb3V0ZVxuXHRcdCMgc2xpZ2h0bHkgaGFja3kgbm93LiBTaG91bGQgcmVmYWN0b3IgYWxsIG9mIHRoZXNlIHRvIHVzZSB0aGUgc2lnbmF0dXJlP1xuXHRcdGlmICFuYW1lZCAmJiAhc3BsYXQgJiYgIWJsayAmJiBvcHQ6bGVuZ3RoID4gMCAmJiBzaWduYXR1cmUuam9pbihcIiBcIikubWF0Y2goL29wdCQvKVxuXHRcdFx0Zm9yIHBhcixpIGluIG9wdFxuXHRcdFx0XHRhc3QucHVzaCBcImlmKHtwYXIubmFtZS5jfSA9PT0gdW5kZWZpbmVkKSB7cGFyLm5hbWUuY30gPSB7cGFyLmRlZmF1bHRzLmN9XCJcblxuXHRcdFxuXHRcdGVsaWYgbmFtZWQgJiYgIXNwbGF0ICYmICFibGsgJiYgb3B0Omxlbmd0aCA9PSAwICMgYW5kIG5vIGJsb2NrPyFcblx0XHRcdCMgZGlmZmVyZW50IHNob3J0aGFuZHNcblx0XHRcdCMgaWYgbmFtZWRcblx0XHRcdGFzdC5wdXNoIFwiaWYoIXtuYW1lZHZhci5jfXx8e2lzbnRPYmoobmFtZWR2YXIuYyl9KSB7bmFtZWR2YXIuY30gPSBcXHtcXH1cIlxuXG5cdFx0ZWxpZiBibGsgJiYgb3B0Omxlbmd0aCA9PSAxICYmICFzcGxhdCAmJiAhbmFtZWRcblx0XHRcdHZhciBvcCA9IG9wdFswXVxuXHRcdFx0dmFyIG9wbiA9IG9wLm5hbWUuY1xuXHRcdFx0dmFyIGJuID0gYmxrLm5hbWUuY1xuXHRcdFx0YXN0LnB1c2ggXCJpZih7Ym59PT11bmRlZmluZWQgJiYge2lzRnVuYyhvcG4pfSkge2JufSA9IHtvcG59LHtvcG59ID0ge29wLmRlZmF1bHRzLmN9XCJcblx0XHRcdGFzdC5wdXNoIFwiaWYoe29wbn09PXVuZGVmaW5lZCkge29wbn0gPSB7b3AuZGVmYXVsdHMuY31cIlxuXG5cdFx0ZWxpZiBibGsgJiYgbmFtZWQgJiYgb3B0Omxlbmd0aCA9PSAwICYmICFzcGxhdFxuXHRcdFx0dmFyIGJuID0gYmxrLm5hbWUuY1xuXHRcdFx0YXN0LnB1c2ggXCJpZih7Ym59PT11bmRlZmluZWQgJiYge2lzRnVuYyhuYW1lZHZhci5jKX0pIHtibn0gPSB7bmFtZWR2YXIuY30se25hbWVkdmFyLmN9ID0gXFx7XFx9XCJcblx0XHRcdGFzdC5wdXNoIFwiZWxzZSBpZighe25hbWVkdmFyLmN9fHx7aXNudE9iaihuYW1lZHZhci5jKX0pIHtuYW1lZHZhci5jfSA9IFxce1xcfVwiXG5cblx0XHRlbGlmIG9wdDpsZW5ndGggPiAwIHx8IHNwbGF0ICMgJiYgYmxrICAjICYmICFzcGxhdFxuXG5cdFx0XHR2YXIgYXJndmFyID0gc2NvcGVfXy50ZW1wb3Jhcnkoc2VsZiwgcG9vbDogJ2FyZ3VtZW50cycpLnByZWRlY2xhcmVkLmNcblx0XHRcdHZhciBsZW4gPSBzY29wZV9fLnRlbXBvcmFyeShzZWxmLCBwb29sOiAnY291bnRlcicpLnByZWRlY2xhcmVkLmNcblxuXHRcdFx0dmFyIGxhc3QgPSBcInthcmd2YXJ9W3tsZW59LTFdXCJcblx0XHRcdHZhciBwb3AgPSBcInthcmd2YXJ9Wy0te2xlbn1dXCJcblx0XHRcdGFzdC5wdXNoIFwidmFyIHthcmd2YXJ9ID0gYXJndW1lbnRzLCB7bGVufSA9IHthcmd2YXJ9Lmxlbmd0aFwiXG5cblx0XHRcdGlmIGJsa1xuXHRcdFx0XHR2YXIgYm4gPSBibGsubmFtZS5jXG5cdFx0XHRcdGlmIHNwbGF0XG5cdFx0XHRcdFx0YXN0LnB1c2ggXCJ2YXIge2JufSA9IHtpc0Z1bmMobGFzdCl9ID8ge3BvcH0gOiBudWxsXCJcblx0XHRcdFx0ZWxpZiByZWc6bGVuZ3RoID4gMFxuXHRcdFx0XHRcdCMgYXN0LnB1c2ggXCIvLyBzZXZlcmFsIHJlZ3MgcmVhbGx5P1wiXG5cdFx0XHRcdFx0YXN0LnB1c2ggXCJ2YXIge2JufSA9IHtsZW59ID4ge3JlZzpsZW5ndGh9ICYmIHtpc0Z1bmMobGFzdCl9ID8ge3BvcH0gOiBudWxsXCJcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdGFzdC5wdXNoIFwidmFyIHtibn0gPSB7aXNGdW5jKGxhc3QpfSA/IHtwb3B9IDogbnVsbFwiXG5cblx0XHRcdCMgaWYgd2UgaGF2ZSBuYW1lZCBwYXJhbXMgLSBsb29rIGZvciB0aGVtIGJlZm9yZSBzcGxhdFxuXHRcdFx0IyBzaG91bGQgcHJvYmFibHkgbG9vcCB0aHJvdWdoIHBhcnMgaW4gdGhlIHNhbWUgb3JkZXIgdGhleSB3ZXJlIGFkZGVkXG5cdFx0XHQjIHNob3VsZCBpdCBiZSBwcmlvcml0aXplZCBhYm92ZSBvcHRpb25hbCBvYmplY3RzPz9cblx0XHRcdGlmIG5hbWVkXG5cdFx0XHRcdCMgc2hvdWxkIG5vdCBpbmNsdWRlIGl0IHdoZW4gdGhlcmUgaXMgYSBzcGxhdD9cblx0XHRcdFx0YXN0LnB1c2ggXCJ2YXIge25hbWVkdmFyLmN9ID0ge2xhc3R9JiZ7aXNPYmoobGFzdCl9ID8ge3BvcH0gOiBcXHtcXH1cIlxuXG5cdFx0XHRmb3IgcGFyLGkgaW4gb3B0XG5cdFx0XHRcdGFzdC5wdXNoIFwiaWYoe2xlbn0gPCB7cGFyLmluZGV4ICsgMX0pIHtwYXIubmFtZS5jfSA9IHtwYXIuZGVmYXVsdHMuY31cIlxuXG5cdFx0XHQjIGFkZCB0aGUgc3BsYXRcblx0XHRcdGlmIHNwbGF0XG5cdFx0XHRcdHZhciBzbiA9IHNwbGF0Lm5hbWUuY1xuXHRcdFx0XHR2YXIgc2kgPSBzcGxhdC5pbmRleFxuXG5cdFx0XHRcdGlmIHNpID09IDBcblx0XHRcdFx0XHRhc3QucHVzaCBcInZhciB7c259ID0gbmV3IEFycmF5KHtsZW59PntzaX0gPyB7bGVufSA6IDApXCJcblx0XHRcdFx0XHRhc3QucHVzaCBcIndoaWxlKHtsZW59PntzaX0pIHtzbn1be2xlbn0tMV0gPSB7cG9wfVwiXG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRhc3QucHVzaCBcInZhciB7c259ID0gbmV3IEFycmF5KHtsZW59PntzaX0gPyB7bGVufS17c2l9IDogMClcIlxuXHRcdFx0XHRcdGFzdC5wdXNoIFwid2hpbGUoe2xlbn0+e3NpfSkge3NufVstLXtsZW59IC0ge3NpfV0gPSB7YXJndmFyfVt7bGVufV1cIlxuXG5cdFx0XHQjIGlmIG5hbWVkXG5cdFx0XHQjIFx0Zm9yIGssaSBpbiBuYW1lZC5ub2Rlc1xuXHRcdFx0IyBcdFx0IyBPUCgnLicsbmFtZWR2YXIpIDwtIHRoaXMgaXMgdGhlIHJpZ2h0IHdheSwgd2l0aCBpbnZhbGlkIG5hbWVzIGV0Y1xuXHRcdFx0IyBcdFx0dmFyIG9wID0gT1AoJy4nLG5hbWVkdmFyLGsua2V5KS5jXG5cdFx0XHQjIFx0XHRhc3QucHVzaCBcInZhciB7ay5rZXkuY30gPSB7b3B9ICE9PSB1bmRlZmluZWQgPyB7b3B9IDoge2sudmFsdWUuY31cIlxuXG5cdFx0XHQjIGlmIG5hbWVkXG5cblx0XHRcdCMgcmV0dXJuIGFzdC5qb2luKFwiO1xcblwiKSArIFwiO1wiXG5cdFx0XHQjIHJldHVybiBcImlmKHtvcHRbMF0ubmFtZS5jfSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7YmxrLmN9ID0ge29wdFswXS5jfTtcIlxuXG5cblx0XHRlbGlmIG9wdDpsZW5ndGggPiAwXG5cdFx0XHRmb3IgcGFyLGkgaW4gb3B0XG5cdFx0XHRcdGFzdC5wdXNoIFwiaWYoe3Bhci5uYW1lLmN9ID09PSB1bmRlZmluZWQpIHtwYXIubmFtZS5jfSA9IHtwYXIuZGVmYXVsdHMuY31cIlxuXG5cdFx0IyBub3cgc2V0IHN0dWZmIGlmIG5hbWVkIHBhcmFtcyghKVxuXG5cdFx0aWYgbmFtZWRcblx0XHRcdGZvciBrLGkgaW4gbmFtZWQubm9kZXNcblx0XHRcdFx0IyBjb25zb2xlLmxvZyBcIm5hbWVkIHZhciB7ay5jfVwiXG5cdFx0XHRcdHZhciBvcCA9IE9QKCcuJyxuYW1lZHZhcixrLmMpLmNcblx0XHRcdFx0YXN0LnB1c2ggXCJ2YXIge2suY30gPSB7b3B9ICE9PSB1bmRlZmluZWQgPyB7b3B9IDoge2suZGVmYXVsdHMuY31cIlxuXG5cdFx0aWYgYXJ5czpsZW5ndGhcblx0XHRcdGZvciB2LGkgaW4gYXJ5c1xuXHRcdFx0XHQjIGNyZWF0ZSB0dXBsZXNcblx0XHRcdFx0IyBwIFwiYWRkaW5nIGFycmF5cGFyYW1zXCJcblx0XHRcdFx0di5oZWFkKG8sYXN0LHNlbGYpXG5cdFx0XHRcdCMgYXN0LnB1c2ggdi5jXG5cdFx0XHRcdFxuXG5cblx0XHQjIGlmIG9wdDpsZW5ndGggPT0gMFxuXHRcdHJldHVybiBhc3Q6bGVuZ3RoID4gMCA/IChhc3Quam9pbihcIjtcXG5cIikgKyBcIjtcIikgOiBFTVBUWVxuXG5cbiMgTGVnYWN5LiBTaG91bGQgbW92ZSBhd2F5IGZyb20gdGhpcz9cbmV4cG9ydCBjbGFzcyBWYXJpYWJsZURlY2xhcmF0aW9uIDwgTGlzdE5vZGVcblxuXHQjIGZvciBsYXRlciwgbW96LWFzdCBzdHlsZVxuXHRwcm9wIGtpbmRcblxuXHQjIHdlIHdhbnQgdG8gcmVnaXN0ZXIgdGhlc2UgdmFyaWFibGVzIGluXG5cdGRlZiBhZGQgbmFtZSwgaW5pdCwgcG9zID0gLTFcblx0XHR2YXIgdmFyZGVjID0gVmFyaWFibGVEZWNsYXJhdG9yLm5ldyhuYW1lLGluaXQpXG5cdFx0dmFyZGVjLnZhcmlhYmxlID0gbmFtZSBpZiBuYW1lIGlzYSBWYXJpYWJsZVxuXHRcdHBvcyA9PSAwID8gdW5zaGlmdCh2YXJkZWMpIDogcHVzaCh2YXJkZWMpXG5cdFx0dmFyZGVjXG5cblx0XHQjIFRPRE8gKHRhcmdldCkgPDwgKG5vZGUpIHJld3JpdGVzIHRvIGEgY2FjaGluZyBwdXNoIHdoaWNoIHJldHVybnMgbm9kZVxuXG5cdCMgZGVmIHJlbW92ZSBpdGVtXG5cdCMgXHRpZiBpdGVtIGlzYSBWYXJpYWJsZVxuXHQjIFx0XHRtYXAgZG8gfHYsaXxcblx0IyBcdFx0XHRpZiB2LnZhcmlhYmxlID09IGl0ZW1cblx0IyBcdFx0XHRcdHAgXCJmb3VuZCB2YXJpYWJsZSB0byByZW1vdmVcIlxuXHQjIFx0XHRcdFx0c3VwZXIucmVtb3ZlKHYpXG5cdCMgXHRlbHNlXG5cdCMgXHRcdHN1cGVyLnJlbW92ZShpdGVtKVxuXHQjIFx0c2VsZlxuXHRcblx0ZGVmIGxvYWQgbGlzdFxuXHRcdCMgdGVtcG9yYXJ5IHNvbHV0aW9uISEhXG5cdFx0bGlzdC5tYXAgZG8gfHBhcnwgVmFyaWFibGVEZWNsYXJhdG9yLm5ldyhwYXIubmFtZSxwYXIuZGVmYXVsdHMscGFyLnNwbGF0KVxuXG5cdGRlZiBpc0V4cHJlc3NhYmxlXG5cdFx0bm9kZXMuZXZlcnkofGl0ZW18IGl0ZW0uaXNFeHByZXNzYWJsZSlcblxuXHRkZWYganMgb1xuXHRcdHJldHVybiBFTVBUWSBpZiBjb3VudCA9PSAwXG5cblx0XHRpZiBjb3VudCA9PSAxICYmICFpc0V4cHJlc3NhYmxlXG5cdFx0XHQjIHAgXCJTSE9VTEQgQUxURVIgVkFSREVDISEhXCIuY3lhblxuXHRcdFx0Zmlyc3QudmFyaWFibGUuYXV0b2RlY2xhcmVcblx0XHRcdHZhciBub2RlID0gZmlyc3QuYXNzaWdubWVudFxuXHRcdFx0cmV0dXJuIG5vZGUuY1xuXG5cdFx0IyBGSVggUEVSRk9STUFOQ0Vcblx0XHR2YXIgb3V0ID0gY29tcGFjdF9fKGNhcnlfXyhub2RlcykpLmpvaW4oXCIsIFwiKVxuXHRcdG91dCA/IFwidmFyIHtvdXR9XCIgOiBcIlwiXG5cdFx0IyBcInZhciBcIiArIGNvbXBhY3RfXyhjYXJ5X18obm9kZXMpKS5qb2luKFwiLCBcIikgKyBcIlwiXG5cbmV4cG9ydCBjbGFzcyBWYXJpYWJsZURlY2xhcmF0b3IgPCBQYXJhbVxuXG5cdCMgY2FuIHBvc3NpYmx5IGNyZWF0ZSB0aGUgdmFyaWFibGUgaW1tZWRpYXRlbHkgYnV0IHdhaXQgd2l0aCBzY29wZS1kZWNsYXJpbmdcblx0IyBXaGF0IGlmIHRoaXMgaXMgbWVyZWx5IHRoZSBkZWNsYXJhdGlvbiBvZiBhIHN5c3RlbS90ZW1wb3JhcnkgdmFyaWFibGU/XG5cdGRlZiB2aXNpdFxuXHRcdCMgZXZlbiBpZiB3ZSBzaG91bGQgdHJhdmVyc2UgdGhlIGRlZmF1bHRzIGFzIGlmIHRoaXMgdmFyaWFibGUgZG9lcyBub3QgZXhpc3Rcblx0XHQjIHdlIG5lZWQgdG8gcHJlcmVnaXN0ZXIgaXQgYW5kIHRoZW4gYWN0aXZhdGUgaXQgbGF0ZXJcblx0XHRzZWxmLnZhcmlhYmxlIHx8PSBzY29wZV9fLnJlZ2lzdGVyKG5hbWUsbnVsbClcblx0XHRkZWZhdWx0cy50cmF2ZXJzZSBpZiBkZWZhdWx0c1xuXHRcdCMgV0FSTiB3aGF0IGlmIGl0IGlzIGFscmVhZHkgZGVjbGFyZWQ/XG5cdFx0c2VsZi52YXJpYWJsZS5kZWNsYXJhdG9yID0gc2VsZlxuXHRcdHNlbGYudmFyaWFibGUuYWRkUmVmZXJlbmNlKG5hbWUpXG5cdFx0c2VsZlxuXHRcdFxuXHQjIG5lZWRzIHRvIGJlIGxpbmtlZCB1cCB0byB0aGUgYWN0dWFsIHNjb3BlZCB2YXJpYWJsZXMsIG5vP1xuXHRkZWYganMgb1xuXHRcdHJldHVybiBudWxsIGlmIHZhcmlhYmxlLkBwcm94eVxuXG5cdFx0dmFyIGRlZnMgPSBkZWZhdWx0c1xuXHRcdCMgRklYTUUgbmVlZCB0byBkZWFsIHdpdGggdmFyLWRlZmluZXMgd2l0aGluIG90aGVyIHN0YXRlbWVudHMgZXRjXG5cdFx0IyBGSVhNRSBuZWVkIGJldHRlciBzeW50YXggZm9yIHRoaXNcblx0XHRpZiBkZWZzICE9IG51bGwgJiYgZGVmcyAhPSB1bmRlZmluZWRcblx0XHRcdCMgY29uc29sZS5sb2cgXCJkZWZhdWx0cyBpcyB7ZGVmYXVsdHN9XCJcblx0XHRcdGRlZnMgPSBkZWZzLmMoZXhwcmVzc2lvbjogeWVzKSBpZiBkZWZzIGlzYSBOb2RlXG5cblx0XHRcdFwie3ZhcmlhYmxlLmN9ID0ge2RlZnN9XCJcblx0XHRlbHNlXG5cdFx0XHRcInt2YXJpYWJsZS5jfVwiXG5cblx0ZGVmIGFjY2Vzc29yXG5cdFx0c2VsZlxuXG5cbiMgVE9ETyBjbGVhbiB1cCBhbmQgcmVmYWN0b3IgYWxsIHRoZSBkaWZmZXJlbnQgcmVwcmVzZW50YXRpb25zIG9mIHZhcnNcbiMgVmFyTmFtZSwgVmFyUmVmZXJlbmNlLCBMb2NhbFZhckFjY2Vzcz9cbmV4cG9ydCBjbGFzcyBWYXJOYW1lIDwgVmFsdWVOb2RlXG5cblx0cHJvcCB2YXJpYWJsZVxuXHRwcm9wIHNwbGF0XG5cblx0ZGVmIGluaXRpYWxpemUgYSxiXG5cdFx0c3VwZXJcblx0XHRAc3BsYXQgPSBiXG5cblx0ZGVmIHZpc2l0XG5cdFx0IyBwIFwidmlzaXRpbmcgdmFybmFtZSghKVwiLCB2YWx1ZS5jXG5cdFx0IyBzaG91bGQgd2Ugbm90IGxvb2t1cCBpbnN0ZWFkP1xuXHRcdCMgRklYTUUgcCBcInJlZ2lzdGVyIHZhbHVlIHt2YWx1ZS5jfVwiXG5cdFx0c2VsZi52YXJpYWJsZSB8fD0gc2NvcGVfXy5yZWdpc3Rlcih2YWx1ZS5jLG51bGwpXG5cdFx0c2VsZi52YXJpYWJsZS5kZWNsYXJhdG9yID0gc2VsZlxuXHRcdHNlbGYudmFyaWFibGUuYWRkUmVmZXJlbmNlKHZhbHVlKVxuXHRcdHNlbGZcblxuXHRkZWYganMgb1xuXHRcdHZhcmlhYmxlLmNcblxuXHRkZWYgY1xuXHRcdHZhcmlhYmxlLmNcdFx0XG5cdFx0XG5cbmV4cG9ydCBjbGFzcyBWYXJMaXN0IDwgTm9kZVxuXG5cdHByb3AgdHlwZSAjIGxldCAvIHZhciAvIGNvbnN0XG5cdHByb3AgbGVmdFxuXHRwcm9wIHJpZ2h0XG5cblx0IyBmb3JtYXQgOnR5cGUsIDpsZWZ0LCA6cmlnaHRcblxuXHQjIHNob3VsZCB0aHJvdyBlcnJvciBpZiB0aGVyZSBhcmUgbW9yZSB2YWx1ZXMgb24gcmlnaHQgdGhhbiBsZWZ0XG5cblx0ZGVmIGluaXRpYWxpemUgdCxsLHJcblx0XHRAdHJhdmVyc2VkID0gbm9cblx0XHRAdHlwZSA9IHR5cGVcblx0XHRAbGVmdCA9IGxcblx0XHRAcmlnaHQgPSByXG5cblx0ZGVmIHZpc2l0XG5cblx0XHQjIHdlIG5lZWQgdG8gY2FyZWZ1bGx5IHRyYXZlcnNlIGNoaWxkcmVuIGluIHRoZSByaWdodCBvcmRlclxuXHRcdCMgc2luY2Ugd2Ugc2hvdWxkIGJlIGFibGUgdG8gcmVmZXJlbmNlXG5cdFx0Zm9yIGwsaSBpbiBsZWZ0XG5cdFx0XHRsLnRyYXZlcnNlICMgdGhpcyBzaG91bGQgcmVhbGx5IGJlIGEgdmFyLWRlY2xhcmF0aW9uXG5cdFx0XHRyLnRyYXZlcnNlIGlmIHZhciByID0gcmlnaHRbaV1cblx0XHRzZWxmXG5cblx0ZGVmIGpzIG9cblx0XHQjIGZvciB0aGUgcmVndWxhciBpdGVtcyBcblx0XHR2YXIgcGFpcnMgPSBbXVxuXHRcdHZhciBsbCA9IGxlZnQ6bGVuZ3RoXG5cdFx0dmFyIHJsID0gcmlnaHQ6bGVuZ3RoXG5cdFx0dmFyIHYgPSBudWxsXG5cblx0XHQjIHNwbGF0dGluZyBoZXJlIHdlIGNvbWVcblx0XHRpZiBsbCA+IDEgJiYgcmwgPT0gMVxuXHRcdFx0cCBcIm11bHRpYXNzaWduIVwiXG5cdFx0XHR2YXIgciA9IHJpZ2h0WzBdXG5cdFx0XHRyLmNhY2hlXG5cdFx0XHRmb3IgbCxpIGluIGxlZnRcblx0XHRcdFx0aWYgbC5zcGxhdFxuXHRcdFx0XHRcdHRocm93IFwibm90IHN1cHBvcnRlZD9cIlxuXHRcdFx0XHRcdHAgXCJzcGxhdFwiICMgRklYIHJlaW1wbGVtZW50IHNsaWNlP1xuXHRcdFx0XHRcdGlmIGkgPT0gbGwgLSAxXG5cdFx0XHRcdFx0XHR2ID0gdXRpbC5zbGljZShyLGkpXG5cdFx0XHRcdFx0XHRwIFwibGFzdFwiXG5cdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0diA9IHV0aWwuc2xpY2UocixpLC0obGwgLSBpKSArIDEpXG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHR2ID0gT1AoJy4nLHIsbnVtX18oaSkpXG5cdFx0XHRcdFxuXHRcdFx0XHRwYWlycy5wdXNoKE9QKCc9JyxsLHYpKVxuXG5cdFx0ZWxzZVxuXHRcdFx0Zm9yIGwsaSBpbiBsZWZ0XG5cdFx0XHRcdHZhciByID0gcmlnaHRbaV1cblx0XHRcdFx0cGFpcnMucHVzaChyID8gT1AoJz0nLGwudmFyaWFibGUuYWNjZXNzb3IscikgOiBsKVxuXG5cdFx0cmV0dXJuIFwidmFyIHtwYWlycy5jfVwiXG5cblxuIyBDT0RFXG5cbmV4cG9ydCBjbGFzcyBDb2RlIDwgTm9kZVxuXG5cdHByb3AgaGVhZFxuXHRwcm9wIGJvZHlcblx0cHJvcCBzY29wZVxuXHRwcm9wIHBhcmFtc1xuXG5cdGRlZiBzY29wZXR5cGVcblx0XHRTY29wZVxuXG5cdGRlZiB2aXNpdFxuXHRcdEBzY29wZS52aXNpdCBpZiBAc2NvcGVcblx0XHQjIEBzY29wZS5wYXJlbnQgPSBTVEFDSy5zY29wZSgxKSBpZiBAc2NvcGVcblx0XHRzZWxmXG5cblxuIyBSZW5hbWUgdG8gUHJvZ3JhbT9cbmV4cG9ydCBjbGFzcyBSb290IDwgQ29kZVxuXG5cdGRlZiBpbml0aWFsaXplIGJvZHksIG9wdHNcblx0XHQjIHAgXCJjcmVhdGUgcm9vdCFcIlxuXHRcdEB0cmF2ZXJzZWQgPSBub1xuXHRcdEBib2R5ID0gYmxrX18oYm9keSlcblx0XHRAc2NvcGUgPSBSb290U2NvcGUubmV3KHNlbGYsbnVsbClcblx0XHRAb3B0aW9ucyA9IHt9XG5cblx0ZGVmIHZpc2l0XG5cdFx0Uk9PVCA9IFNUQUNLLlJPT1QgPSBAc2NvcGVcblx0XHRzY29wZS52aXNpdFxuXHRcdGJvZHkudHJhdmVyc2VcblxuXHRkZWYgY29tcGlsZSBvXG5cdFx0U1RBQ0sucmVzZXQgIyAtLSBuZXN0ZWQgY29tcGlsYXRpb24gZG9lcyBub3Qgd29yayBub3dcblx0XHRPUFRTID0gU1RBQ0suQG9wdGlvbnMgPSBAb3B0aW9ucyA9IG8gb3Ige31cblxuXHRcdHRyYXZlcnNlXG5cblx0XHR2YXIgb3V0ID0gY1xuXHRcdHZhciByZXN1bHQgPSB7XG5cdFx0XHRqczogb3V0LFxuXHRcdFx0YXN0OiBzZWxmLFxuXHRcdFx0d2FybmluZ3M6IHNjb3BlLndhcm5pbmdzLFxuXHRcdFx0b3B0aW9uczogbyxcblx0XHRcdHRvU3RyaW5nOiAoZG8gdGhpczpqcylcblx0XHR9XG5cdFx0aWYgbzpzb3VyY2VNYXBJbmxpbmUgb3Igbzpzb3VyY2VNYXBcblx0XHRcdHJlc3VsdDpzb3VyY2VtYXAgPSBTb3VyY2VNYXAubmV3KHJlc3VsdCkuZ2VuZXJhdGVcblxuXHRcdHJldHVybiByZXN1bHRcblxuXHRkZWYganMgb1xuXHRcdHZhciBvdXRcblx0XHRpZiBAb3B0aW9uczpiYXJlXG5cdFx0XHRvdXQgPSBzY29wZS5jXG5cdFx0ZWxzZVxuXHRcdFx0Ym9keS5jb25zdW1lKEltcGxpY2l0UmV0dXJuLm5ldylcblx0XHRcdG91dCA9IHNjb3BlLmMoaW5kZW50OiB5ZXMpXG5cdFx0XHRvdXQgPSBvdXQucmVwbGFjZSgvXlxcbj8vLCdcXG4nKVxuXHRcdFx0b3V0ID0gb3V0LnJlcGxhY2UoL1xcbj8kLywnXFxuXFxuJylcblx0XHRcdG91dCA9ICcoZnVuY3Rpb24oKXsnICsgb3V0ICsgJ30pKCknXG5cblx0XHQjIGZpbmQgYW5kIHJlcGxhY2Ugc2hlYmFuZ3Ncblx0XHR2YXIgc2hlYmFuZ3MgPSBbXVxuXHRcdG91dCA9IG91dC5yZXBsYWNlKC9eWyBcXHRdKlxcL1xcLyhcXCEuKykkL21nKSBkbyB8bSxzaGViYW5nfFxuXHRcdFx0IyBwIFwiZm91bmQgc2hlYmFuZyB7c2hlYmFuZ31cIlxuXHRcdFx0c2hlYmFuZyA9IHNoZWJhbmcucmVwbGFjZSgvXFxiaW1iYVxcYi9nLCdub2RlJylcblx0XHRcdHNoZWJhbmdzLnB1c2goXCIje3NoZWJhbmd9XFxuXCIpXG5cdFx0XHRyZXR1cm4gXCJcIlxuXG5cdFx0b3V0ID0gc2hlYmFuZ3Muam9pbignJykgKyBvdXRcblxuXHRcdHJldHVybiBvdXRcblxuXG5cdGRlZiBhbmFseXplIGxvZ2xldmVsOiAwLCBlbnRpdGllczogbm8sIHNjb3BlczogeWVzXG5cdFx0U1RBQ0subG9nbGV2ZWwgPSBsb2dsZXZlbFxuXHRcdFNUQUNLLkBhbmFseXppbmcgPSB0cnVlXG5cdFx0Uk9PVCA9IFNUQUNLLlJPT1QgPSBAc2NvcGVcblxuXHRcdE9QVFMgPSB7XG5cdFx0XHRhbmFseXNpczoge1xuXHRcdFx0XHRlbnRpdGllczogZW50aXRpZXMsXG5cdFx0XHRcdHNjb3Blczogc2NvcGVzXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dHJhdmVyc2Vcblx0XHRTVEFDSy5AYW5hbHl6aW5nID0gZmFsc2VcblxuXHRcdHJldHVybiBzY29wZS5kdW1wXG5cblx0ZGVmIGluc3BlY3Rcblx0XHR0cnVlXG5cbmV4cG9ydCBjbGFzcyBDbGFzc0RlY2xhcmF0aW9uIDwgQ29kZVxuXG5cdHByb3AgbmFtZVxuXHRwcm9wIHN1cGVyY2xhc3Ncblx0cHJvcCBpbml0b3JcblxuXHRkZWYgY29uc3VtZSBub2RlXG5cdFx0aWYgbm9kZSBpc2EgUmV0dXJuXG5cdFx0XHRvcHRpb24oJ3JldHVybicseWVzKVxuXHRcdFx0cmV0dXJuIHNlbGZcblx0XHRzdXBlclxuXG5cdGRlZiBuYW1lcGF0aFxuXHRcdEBuYW1lcGF0aCB8fD0gXCJ7bmFtZS5jfVwiXG5cblx0ZGVmIG1ldGFkYXRhXG5cdFx0e1xuXHRcdFx0dHlwZTogJ2NsYXNzJ1xuXHRcdFx0bmFtZXBhdGg6IG5hbWVwYXRoXG5cdFx0XHRpbmhlcml0czogc3VwZXJjbGFzcz8ubmFtZXBhdGhcblx0XHRcdHBhdGg6IG5hbWUuYy50b1N0cmluZ1xuXHRcdFx0ZGVzYzogQGRlc2Ncblx0XHRcdGxvYzogbG9jXG5cdFx0fVx0XG5cblx0ZGVmIHRvSlNPTlxuXHRcdG1ldGFkYXRhXG5cblx0ZGVmIGluaXRpYWxpemUgbmFtZSwgc3VwZXJjbGFzcywgYm9keVxuXHRcdCMgd2hhdCBhYm91dCB0aGUgbmFtZXNwYWNlP1xuXHRcdEB0cmF2ZXJzZWQgPSBub1xuXHRcdEBuYW1lID0gbmFtZVxuXHRcdEBzdXBlcmNsYXNzID0gc3VwZXJjbGFzc1xuXHRcdEBzY29wZSA9IENsYXNzU2NvcGUubmV3KHNlbGYpXG5cdFx0QGJvZHkgPSBibGtfXyhib2R5KVxuXHRcdHNlbGZcblxuXHRkZWYgdmlzaXRcblx0XHQjIHJlcGxhY2Ugd2l0aCBzb21lIGFkdmFuY2VkIGxvb2t1cD9cblx0XHRST09ULmVudGl0aWVzLmFkZChuYW1lcGF0aCxzZWxmKVxuXHRcdHNjb3BlLnZpc2l0XG5cdFx0Ym9keS50cmF2ZXJzZVxuXHRcdHNlbGZcblxuXHRkZWYganMgb1xuXHRcdHNjb3BlLnZpcnR1YWxpemUgIyBpcyB0aGlzIGFsd2F5cyBuZWVkZWQ/XG5cdFx0c2NvcGUuY29udGV4dC52YWx1ZSA9IG5hbWVcblxuXHRcdCMgc2hvdWxkIHByb2JhYmx5IGFsc28gd2FybiBhYm91dCBzdHVmZiBldGNcblx0XHRpZiBvcHRpb24oOmV4dGVuc2lvbilcblx0XHRcdHJldHVybiBib2R5LmNcblxuXHRcdHZhciBoZWFkID0gW11cblx0XHR2YXIgbyA9IEBvcHRpb25zIG9yIHt9XG5cdFx0dmFyIGNuYW1lID0gbmFtZSBpc2EgQWNjZXNzID8gbmFtZS5yaWdodCA6IG5hbWVcblx0XHR2YXIgbmFtZXNwYWNlZCA9IG5hbWUgIT0gY25hbWVcblx0XHR2YXIgaW5pdG9yID0gbnVsbFxuXHRcdHZhciBzdXAgPSBzdXBlcmNsYXNzXG5cblx0XHR2YXIgYm9keWluZGV4ID0gLTFcblx0XHR2YXIgc3BhY2VzID0gYm9keS5maWx0ZXIgZG8gfGl0ZW18IGl0ZW0gaXNhIFRlcm1pbmF0b3Jcblx0XHR2YXIgbWFyayA9IG1hcmtfXyhvcHRpb24oJ2tleXdvcmQnKSlcblxuXHRcdGJvZHkubWFwIGRvIHxjLGl8XG5cdFx0XHRpZiBjIGlzYSBNZXRob2REZWNsYXJhdGlvbiAmJiBjLnR5cGUgPT0gOmNvbnN0cnVjdG9yXG5cdFx0XHRcdGJvZHlpbmRleCA9IGlcblxuXHRcdGlmIGJvZHlpbmRleCA+PSAwXG5cdFx0XHRpbml0b3IgPSBib2R5LnJlbW92ZUF0KGJvZHlpbmRleClcblxuXHRcdCMgdmFyIGluaXRvciA9IGJvZHkucGx1Y2sgZG8gfGN8IGMgaXNhIE1ldGhvZERlY2xhcmF0aW9uICYmIGMudHlwZSA9PSA6Y29uc3RydWN0b3Jcblx0XHQjIGNvbXBpbGUgdGhlIGNuYW1lXG5cdFx0Y25hbWUgPSBjbmFtZS5jIHVubGVzcyB0eXBlb2YgY25hbWUgPT0gJ3N0cmluZydcblxuXHRcdHZhciBjcGF0aCA9IHR5cGVvZiBuYW1lICA9PSAnc3RyaW5nJyA/IG5hbWUgOiBuYW1lLmNcblxuXHRcdGlmICFpbml0b3Jcblx0XHRcdGlmIHN1cFxuXHRcdFx0XHRpbml0b3IgPSBcInttYXJrfWZ1bmN0aW9uIHtjbmFtZX0oKVxceyByZXR1cm4ge3N1cC5jfS5hcHBseSh0aGlzLGFyZ3VtZW50cykgXFx9O1xcblxcblwiXG5cdFx0XHRlbHNlXG5cdFx0XHRcdGluaXRvciA9IFwie21hcmt9ZnVuY3Rpb24ge2NuYW1lfSgpXCIgKyAneyB9O1xcblxcbidcblx0XHRcdFxuXHRcdGVsc2Vcblx0XHRcdGluaXRvci5uYW1lID0gY25hbWVcblx0XHRcdGluaXRvciA9IGluaXRvci5jICsgJzsnXG5cdFx0XG5cdFx0IyBpZiB3ZSBhcmUgZGVmaW5pbmcgYSBjbGFzcyBpbnNpZGUgYSBuYW1lc3BhY2UgZXRjIC0tIGhvdyBzaG91bGQgd2Ugc2V0IHVwIHRoZSBjbGFzcz9cblx0XHRcblx0XHRpZiBuYW1lc3BhY2VkXG5cdFx0XHQjIHNob3VsZCB1c2UgTm9kZXMgdG8gYnVpbGQgdGhpcyBpbnN0ZWFkXG5cdFx0XHRpbml0b3IgPSBcIntjcGF0aH0gPSB7aW5pdG9yfVwiICMgT1AoJz0nLG5hbWUsaW5pdG9yKVxuXG5cdFx0aGVhZC5wdXNoKGluaXRvcikgIyAvLyBAY2xhc3Mge2NuYW1lfVxcblxuXG5cdFx0aWYgYm9keWluZGV4ID49IDBcblx0XHRcdCMgYWRkIHRoZSBzcGFjZSBhZnRlciBpbml0b3I/XG5cdFx0XHRpZiBib2R5LmluZGV4KGJvZHlpbmRleCkgaXNhIFRlcm1pbmF0b3Jcblx0XHRcdFx0aGVhZC5wdXNoKGJvZHkucmVtb3ZlQXQoYm9keWluZGV4KSlcblx0XHRlbHNlXG5cdFx0XHQjIGhlYWQucHVzaChUZXJtaW5hdG9yLm5ldygnXFxuXFxuJykpXG5cdFx0XHR0cnVlXG5cdFx0XG5cblxuXHRcdGlmIHN1cFxuXHRcdFx0IyBjb25zb2xlLmxvZyBcImRlYWwgd2l0aCBzdXBlcmNsYXNzIVwiXG5cdFx0XHQjIGhlYWQucHVzaChcIi8vIGV4dGVuZGluZyB0aGUgc3VwZXJjbGFzc1xcbmltYmEkY2xhc3Moe25hbWUuY30se3N1cC5jfSk7XFxuXFxuXCIpXG5cdFx0XHRoZWFkLnB1c2goVXRpbC5TdWJjbGFzcy5uZXcoW25hbWUsc3VwXSkpXG5cblx0XHQjIG9ubHkgaWYgaXQgaXMgbm90IG5hbWVzcGFjZWRcblx0XHRpZiBvOmdsb2JhbCBhbmQgIW5hbWVzcGFjZWQgIyBvcHRpb24oOmdsb2JhbClcblx0XHRcdGhlYWQucHVzaChcImdsb2JhbC57Y25hbWV9ID0ge2NwYXRofTsgLy8gZ2xvYmFsIGNsYXNzIFxcblwiKVxuXG5cdFx0aWYgbzpleHBvcnQgYW5kICFuYW1lc3BhY2VkXG5cdFx0XHRoZWFkLnB1c2goXCJleHBvcnRzLntjbmFtZX0gPSB7Y3BhdGh9OyAvLyBleHBvcnQgY2xhc3MgXFxuXCIpXG5cblx0XHQjIEZJWE1FXG5cdFx0IyBpZiBuYW1lc3BhY2VkIGFuZCAobzpsb2NhbCBvciBvOmV4cG9ydClcblx0XHQjIFx0Y29uc29sZS5sb2cgXCJuYW1lc3BhY2VkIGNsYXNzZXMgYXJlIGltcGxpY2l0bHkgbG9jYWwvZ2xvYmFsIGRlcGVuZGluZyBvbiB0aGUgbmFtZXNwYWNlXCJcblxuXHRcdGlmIG9wdGlvbigncmV0dXJuJylcblx0XHRcdGJvZHkucHVzaChcInJldHVybiB7Y3BhdGh9O1wiKVxuXG5cdFx0Ym9keS51bnNoaWZ0KHBhcnQpIGZvciBwYXJ0IGluIGhlYWQucmV2ZXJzZVxuXHRcdGJvZHkuQGluZGVudGF0aW9uID0gbnVsbFxuXHRcdHZhciBlbmQgPSBib2R5LmluZGV4KGJvZHkuY291bnQgLSAxKVxuXHRcdGJvZHkucG9wIGlmIGVuZCBpc2EgVGVybWluYXRvciBhbmQgZW5kLmM6bGVuZ3RoID09IDFcblxuXHRcdHZhciBvdXQgPSBib2R5LmNcblxuXHRcdHJldHVybiBvdXRcblxuXG5leHBvcnQgY2xhc3MgVGFnRGVjbGFyYXRpb24gPCBDb2RlXG5cblx0cHJvcCBuYW1lXG5cdHByb3Agc3VwZXJjbGFzc1xuXHRwcm9wIGluaXRvclxuXG5cdGRlZiBuYW1lcGF0aFxuXHRcdFwiPHtuYW1lfT5cIlxuXG5cdGRlZiB0b0pTT05cblx0XHR7XG5cdFx0XHR0eXBlOiAndGFnJ1xuXHRcdFx0bmFtZXBhdGg6IG5hbWVwYXRoXG5cdFx0XHRpbmhlcml0czogc3VwZXJjbGFzcyA/IFwiPHtzdXBlcmNsYXNzLm5hbWV9PlwiIDogbnVsbFxuXHRcdFx0bG9jOiBsb2Ncblx0XHRcdGRlc2M6IEBkZXNjXG5cdFx0fVxuXG5cdGRlZiBpbml0aWFsaXplIG5hbWUsIHN1cGVyY2xhc3MsIGJvZHlcblx0XHQjIHdoYXQgYWJvdXQgdGhlIG5hbWVzcGFjZT9cblx0XHQjIEBuYW1lID0gVGFnVHlwZVJlZi5uZXcobmFtZSlcblx0XHRAdHJhdmVyc2VkID0gbm9cblx0XHRAbmFtZSA9IG5hbWVcblx0XHRAc3VwZXJjbGFzcyA9IHN1cGVyY2xhc3Ncblx0XHRAc2NvcGUgPSBUYWdTY29wZS5uZXcoc2VsZilcblx0XHRAYm9keSA9IGJsa19fKGJvZHkgfHwgW10pXG5cblx0ZGVmIHZpc2l0XG5cdFx0Uk9PVC5lbnRpdGllcy5yZWdpc3RlcihzZWxmKSAjIHdoYXQgaWYgdGhpcyBpcyBub3QgbG9jYWw/XG5cblx0XHRmb3Igc2NvcGUsaSBpbiBTVEFDSy5zY29wZXNcblx0XHRcdGlmIGkgPiAwIGFuZCBzY29wZSBpc2EgVGFnU2NvcGVcblx0XHRcdFx0IyByZWdpc3RlciBpbnNpZGUgaGVyZT9cblx0XHRcdFx0c2NvcGUubm9kZS5vcHRpb24oOmhhc0xvY2FsVGFncyx5ZXMpXG5cdFx0XHRcdG9wdGlvbig6cGFyZW50LHNjb3BlLm5vZGUpXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRcdCMgY29uc29sZS5sb2cgXCJ0YWcgaXMgbG9jYWwhISFcIlxuXHRcdCMgcmVwbGFjZSB3aXRoIHNvbWUgYWR2YW5jZWQgbG9va3VwP1xuXHRcdHNjb3BlLnZpc2l0XG5cdFx0Ym9keS50cmF2ZXJzZVxuXG5cdGRlZiBpZFxuXHRcdG5hbWUuaWRcblxuXHRkZWYgdGFnc3BhY2Vcblx0XHR2YXIgY3R4ID0gc2NvcGUuY2xvc3VyZS50YWdDb250ZXh0UGF0aFxuXHRcdG5hbWUubnMgPyBcIntjdHh9LntuYW1lLm5zLnRvVXBwZXJDYXNlfVwiIDogY3R4XG5cblx0ZGVmIGpzIG9cblx0XHRzY29wZS5jb250ZXh0LnZhbHVlID0gQGN0eCA9IHNjb3BlLmRlY2xhcmUoJ3RhZycsbnVsbCxzeXN0ZW06IHllcylcblxuXHRcdHZhciBucyA9IG5hbWUubnNcblx0XHR2YXIgbWFyayA9IG1hcmtfXyhvcHRpb24oJ2tleXdvcmQnKSlcblxuXHRcdHZhciBwYXJhbXMgPSBbaGVscGVycy5zaW5nbGVxdW90ZShuYW1lLm5hbWUpXVxuXHRcdHZhciBjYm9keSA9IGJvZHkuY1xuXHRcdCMgdmFyIG91dGJvZHkgPSBib2R5LmNvdW50ID8gXCIsIGZ1bmN0aW9uKHtAY3R4LmN9KVxce3tjYm9keX1cXH1cIiA6ICcnXG5cblx0XHRpZiBzdXBlcmNsYXNzXG5cdFx0XHQjIFdBUk4gd2hhdCBpZiB0aGUgc3VwZXJjbGFzcyBoYXMgYSBuYW1lc3BhY2U/XG5cdFx0XHRwYXJhbXMucHVzaChoZWxwZXJzLnNpbmdsZXF1b3RlKHN1cGVyY2xhc3MubmFtZSkpXG5cblx0XHRpZiBib2R5LmNvdW50XG5cdFx0XHRpZiBvcHRpb24oOmhhc0xvY2FsVGFncylcblx0XHRcdFx0cGFyYW1zLnB1c2goXCJmdW5jdGlvbih7QGN0eC5jfSx7c2NvcGUuY2xvc3VyZS50YWdDb250ZXh0UGF0aH0pXFx7e2Nib2R5fVxcfVwiKVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRwYXJhbXMucHVzaChcImZ1bmN0aW9uKHtAY3R4LmN9KVxce3tjYm9keX1cXH1cIilcblxuXHRcdHZhciBtZXRoID0gb3B0aW9uKDpleHRlbnNpb24pID8gJ2V4dGVuZFRhZycgOiAnZGVmaW5lVGFnJ1xuXHRcdCMgcmV0dXJuIFwie21hcmt9e3RhZ3NwYWNlfS5leHRlbmRUYWcoJ3tuYW1lLm5hbWV9J3tvdXRib2R5fSlcIlxuXG5cdFx0IyB2YXIgc3VwID0gc3VwZXJjbGFzcyBhbmQgXCIsXCIgKyBoZWxwZXJzLnNpbmdsZXF1b3RlKHN1cGVyY2xhc3MuZnVuYykgb3IgXCJcIlxuXG5cdFx0IyB2YXIgb3V0ID0gaWYgbmFtZS5pZFxuXHRcdCNcdFwie21hcmt9e3RhZ3NwYWNlfS5kZWZpbmVTaW5nbGV0b24oJ3tuYW1lLm5hbWV9J3tzdXB9e291dGJvZHl9KVwiXG5cdFx0IyBlbHNlXG5cblx0XHRyZXR1cm4gXCJ7bWFya317dGFnc3BhY2V9LnttZXRofSh7cGFyYW1zLmpvaW4oJywgJyl9KVwiXG5cblx0XHQjIHJldHVybiBvdXRcblxuZXhwb3J0IGNsYXNzIEZ1bmMgPCBDb2RlXG5cblx0cHJvcCBuYW1lXG5cdHByb3AgcGFyYW1zXG5cdHByb3AgdGFyZ2V0XG5cdHByb3Agb3B0aW9uc1xuXHRwcm9wIHR5cGVcblx0cHJvcCBjb250ZXh0XG5cblx0ZGVmIHNjb3BldHlwZSBkbyBGdW5jdGlvblNjb3BlXG5cblx0ZGVmIGluaXRpYWxpemUgcGFyYW1zLCBib2R5LCBuYW1lLCB0YXJnZXQsIG9cblx0XHQjIHAgXCJJTklUIEZ1bmN0aW9uISFcIixwYXJhbXMsYm9keSxuYW1lXG5cdFx0dmFyIHR5cCA9IHNjb3BldHlwZVxuXHRcdEB0cmF2ZXJzZWQgPSBub1xuXHRcdEBib2R5ID0gYmxrX18oYm9keSlcblx0XHRAc2NvcGUgfHw9IChvIGFuZCBvOnNjb3BlKSB8fCB0eXAubmV3KHNlbGYpXG5cdFx0QHNjb3BlLnBhcmFtcyA9IEBwYXJhbXMgPSBQYXJhbUxpc3QubmV3KHBhcmFtcylcblx0XHRAbmFtZSA9IG5hbWUgfHwgJydcblx0XHRAdGFyZ2V0ID0gdGFyZ2V0XG5cdFx0QG9wdGlvbnMgPSBvXG5cdFx0QHR5cGUgPSA6ZnVuY3Rpb25cblx0XHRAdmFyaWFibGUgPSBudWxsXG5cdFx0c2VsZlxuXG5cdGRlZiB2aXNpdFxuXHRcdHNjb3BlLnZpc2l0XG5cdFx0QGNvbnRleHQgPSBzY29wZS5wYXJlbnRcblx0XHRAcGFyYW1zLnRyYXZlcnNlXG5cdFx0QGJvZHkudHJhdmVyc2UgIyBzbyBzb29uP1xuXHRcdFxuXG5cdGRlZiBqcyBvXG5cdFx0Ym9keS5jb25zdW1lKEltcGxpY2l0UmV0dXJuLm5ldykgdW5sZXNzIG9wdGlvbig6bm9yZXR1cm4pXG5cdFx0dmFyIGluZCA9IGJvZHkuQGluZGVudGF0aW9uXG5cdFx0IyB2YXIgcyA9IGluZCBhbmQgaW5kLkBvcGVuXG5cdFx0IyBwIFwiaW5kZW50IGZ1bmN0aW9uPyB7Ym9keS5AaW5kZW50YXRpb259IHtzfSB7czpnZW5lcmF0ZWR9IHtib2R5LmNvdW50fVwiXG5cdFx0Ym9keS5AaW5kZW50YXRpb24gPSBudWxsIGlmIGluZCBhbmQgaW5kLmlzR2VuZXJhdGVkXG5cdFx0dmFyIGNvZGUgPSBzY29wZS5jKGluZGVudDogKCFpbmQgb3IgIWluZC5pc0dlbmVyYXRlZCksIGJyYWNlczogeWVzKVxuXG5cdFx0IyBhcmdzID0gcGFyYW1zLm1hcCBkbyB8cGFyfCBwYXIubmFtZVxuXHRcdCMgaGVhZCA9IHBhcmFtcy5tYXAgZG8gfHBhcnwgcGFyLmNcblx0XHQjIGNvZGUgPSBbaGVhZCxib2R5LmMoZXhwcmVzc2lvbjogbm8pXS5mbGF0dGVuX18uY29tcGFjdC5qb2luKFwiXFxuXCIpLndyYXBcblx0XHQjIEZJWE1FIGNyZWF0aW5nIHRoZSBmdW5jdGlvbi1uYW1lIHRoaXMgd2F5IGlzIHByb25lIHRvIGNyZWF0ZSBuYW1pbmctY29sbGlzaW9uc1xuXHRcdCMgd2lsbCBuZWVkIHRvIHdyYXAgdGhlIHZhbHVlIGluIGEgRnVuY3Rpb25OYW1lIHdoaWNoIHRha2VzIGNhcmUgb2YgbG9va2luZyB1cCBzY29wZVxuXHRcdCMgYW5kIHBvc3NpYmx5IGRlYWxpbmcgd2l0aCBpdFxuXHRcdHZhciBuYW1lID0gdHlwZW9mIEBuYW1lID09ICdzdHJpbmcnID8gQG5hbWUgOiBAbmFtZS5jXG5cdFx0dmFyIG5hbWUgPSBuYW1lID8gJyAnICsgbmFtZS5yZXBsYWNlKC9cXC4vZywnXycpIDogJydcblx0XHR2YXIgb3V0ID0gXCJmdW5jdGlvbntuYW1lfSh7cGFyYW1zLmN9KSBcIiArIGNvZGVcblx0XHRvdXQgPSBcIih7b3V0fSkoKVwiIGlmIG9wdGlvbig6ZXZhbClcblx0XHRyZXR1cm4gb3V0XG5cblx0ZGVmIHNob3VsZFBhcmVudGhlc2l6ZSBwYXIgPSB1cFxuXHRcdHBhciBpc2EgQ2FsbCAmJiBwYXIuY2FsbGVlID09IHNlbGZcblx0XHQjIGlmIHVwIGFzIGEgY2FsbD8gT25seSBpZiB3ZSBhcmUgXG5cbmV4cG9ydCBjbGFzcyBMYW1iZGEgPCBGdW5jXG5cdGRlZiBzY29wZXR5cGUgZG8gTGFtYmRhU2NvcGVcblxuZXhwb3J0IGNsYXNzIFRhZ0ZyYWdtZW50RnVuYyA8IEZ1bmNcblxuIyBNZXRob2REZWNsYXJhdGlvblxuIyBDcmVhdGUgYSBzaGFyZWQgYm9keT9cblxuZXhwb3J0IGNsYXNzIE1ldGhvZERlY2xhcmF0aW9uIDwgRnVuY1xuXG5cdHByb3AgdmFyaWFibGVcblxuXHRkZWYgc2NvcGV0eXBlIGRvIE1ldGhvZFNjb3BlXG5cblx0ZGVmIGNvbnN1bWUgbm9kZVxuXHRcdGlmIG5vZGUgaXNhIFJldHVyblxuXHRcdFx0b3B0aW9uKCdyZXR1cm4nLHllcylcblx0XHRcdHJldHVybiBzZWxmXG5cdFx0c3VwZXJcblxuXHRkZWYgbWV0YWRhdGFcblx0XHR7XG5cdFx0XHR0eXBlOiBcIm1ldGhvZFwiXG5cdFx0XHRuYW1lOiBcIlwiICsgbmFtZVxuXHRcdFx0bmFtZXBhdGg6IG5hbWVwYXRoXG5cdFx0XHRwYXJhbXM6IEBwYXJhbXMubWV0YWRhdGFcblx0XHRcdGRlc2M6IEBkZXNjXG5cdFx0XHRzY29wZW5yOiBzY29wZS5AbnJcblx0XHRcdGxvYzogbG9jXG5cdFx0fVxuXG5cdGRlZiBsb2Ncblx0XHRpZiBsZXQgZCA9IG9wdGlvbig6ZGVmKVxuXHRcdFx0W2QuQGxvYyxib2R5LmxvY1sxXV1cblx0XHRlbHNlXG5cdFx0XHRbMCwwXVxuXHRcdFxuXG5cdGRlZiB0b0pTT05cblx0XHRtZXRhZGF0YVxuXG5cdGRlZiBuYW1lcGF0aFxuXHRcdHJldHVybiBAbmFtZXBhdGggaWYgQG5hbWVwYXRoXG5cdFx0XG5cdFx0dmFyIG5hbWUgPSBTdHJpbmcobmFtZSlcblx0XHR2YXIgc2VwID0gKG9wdGlvbignc3RhdGljJykgPyAnLicgOiAnIycpXG5cdFx0aWYgdGFyZ2V0XG5cdFx0XHRAbmFtZXBhdGggPSBAdGFyZ2V0Lm5hbWVwYXRoICsgc2VwICsgbmFtZVxuXHRcdGVsc2Vcblx0XHRcdEBuYW1lcGF0aCA9ICcmJyArIG5hbWVcblxuXHRkZWYgdmlzaXRcblx0XHQjIEBkZXNjID0gc3RhY2suc3Rhc2gucGx1Y2soQ29tbWVudClcblx0XHQjIEBkZXNjID0gc3RhY2suc3Rhc2gucGx1Y2soQ29tbWVudClcblx0XHQjIHByZWJyZWFrICMgbWFrZSBzdXJlIHRoaXMgaGFzIGEgYnJlYWs/XG5cdFx0c2NvcGUudmlzaXRcblxuXHRcdGlmIFN0cmluZyhuYW1lKSA9PSAnaW5pdGlhbGl6ZSdcblx0XHRcdHNlbGYudHlwZSA9IDpjb25zdHJ1Y3RvclxuXG5cdFx0aWYgb3B0aW9uKDpncmVlZHkpXG5cdFx0XHR3YXJuIFwiZGVwcmVjYXRlZFwiXG5cdFx0XHQjIHNldChncmVlZHk6IHRydWUpXG5cdFx0XHQjIHAgXCJCT0RZIEVYUFJFU1NJT05TISEgVGhpcyBpcyBhIGZyYWdtZW50XCJcblx0XHRcdHZhciB0cmVlID0gVGFnVHJlZS5uZXdcblx0XHRcdEBib2R5ID0gYm9keS5jb25zdW1lKHRyZWUpXG5cdFx0XHQjIGJvZHkubm9kZXMgPSBbQXJyLm5ldyhib2R5Lm5vZGVzKV1cblx0XHRcblx0XHRAY29udGV4dCA9IHNjb3BlLnBhcmVudC5jbG9zdXJlXG5cdFx0QHBhcmFtcy50cmF2ZXJzZVxuXG5cdFx0aWYgdGFyZ2V0IGlzYSBTZWxmXG5cdFx0XHRAdGFyZ2V0ID0gQGNvbnRleHQuY29udGV4dFxuXHRcdFx0c2V0KHN0YXRpYzogeWVzKVxuXG5cdFx0aWYgY29udGV4dCBpc2EgQ2xhc3NTY29wZVxuXHRcdFx0Y29udGV4dC5hbm5vdGF0ZShzZWxmKVxuXHRcdFx0QHRhcmdldCB8fD0gY29udGV4dC5jb250ZXh0XG5cdFx0XHQjIHJlZ2lzdGVyIGFzIGNsYXNzLW1ldGhvZD9cblx0XHRcdCMgc2hvdWxkIHJlZ2lzdGVyIGZvciB0aGlzXG5cdFx0XHQjIGNvbnNvbGUubG9nIFwiY29udGV4dCBpcyBjbGFzc3Njb3BlIHtAbmFtZX1cIlxuXG5cdFx0aWYgIUB0YXJnZXRcblx0XHRcdCMgc2hvdWxkIG5vdCBiZSByZWdpc3RlcmVkIG9uIHRoZSBvdXRlcm1vc3QgY2xvc3VyZT9cblx0XHRcdEB2YXJpYWJsZSA9IGNvbnRleHQucmVnaXN0ZXIobmFtZSwgc2VsZiwgdHlwZTogJ21ldGgnKVxuXG5cdFx0Uk9PVC5lbnRpdGllcy5hZGQobmFtZXBhdGgsc2VsZilcblx0XHRAYm9keS50cmF2ZXJzZSAjIHNvIHNvb24/XG5cdFx0c2VsZlxuXG5cdGRlZiBzdXBlcm5hbWVcblx0XHR0eXBlID09IDpjb25zdHJ1Y3RvciA/IHR5cGUgOiBuYW1lXG5cblxuXHQjIEZJWE1FIGV4cG9ydCBnbG9iYWwgZXRjIGFyZSBOT1QgdmFsaWQgZm9yIG1ldGhvZHMgaW5zaWRlIGFueSBvdGhlciBzY29wZSB0aGFuXG5cdCMgdGhlIG91dGVybW9zdCBzY29wZSAocm9vdClcblxuXHRkZWYganMgb1xuXHRcdCMgRklYTUUgRG8gdGhpcyBpbiB0aGUgZ3JhbW1hciAtIHJlbW5hbnRzIG9mIG9sZCBpbXBsZW1lbnRhdGlvblxuXHRcdHVubGVzcyB0eXBlID09IDpjb25zdHJ1Y3RvciBvciBvcHRpb24oOm5vcmV0dXJuKVxuXHRcdFx0aWYgb3B0aW9uKDpncmVlZHkpXG5cdFx0XHRcdCMgaGFhYWNrXG5cdFx0XHRcdGJvZHkuY29uc3VtZShHcmVlZHlSZXR1cm4ubmV3KVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRib2R5LmNvbnN1bWUoSW1wbGljaXRSZXR1cm4ubmV3KVxuXG5cdFx0dmFyIGNvZGUgPSBzY29wZS5jKGluZGVudDogeWVzLCBicmFjZXM6IHllcylcblxuXHRcdCMgc2FtZSBmb3IgRnVuYyAtLSBzaG91bGQgZ2VuZXJhbGl6ZVxuXHRcdHZhciBuYW1lID0gdHlwZW9mIEBuYW1lID09ICdzdHJpbmcnID8gQG5hbWUgOiBAbmFtZS5jXG5cdFx0bmFtZSA9IG5hbWUucmVwbGFjZSgvXFwuL2csJ18nKVxuXG5cdFx0IyB2YXIgbmFtZSA9IHNlbGYubmFtZS5jLnJlcGxhY2UoL1xcLi9nLCdfJykgIyBXSEFUP1xuXHRcdHZhciBmb290ID0gW11cblxuXHRcdHZhciBsZWZ0ID0gXCJcIlxuXHRcdHZhciBmdW5jID0gXCIoe3BhcmFtcy5jfSlcIiArIGNvZGUgIyAud3JhcFxuXHRcdHZhciB0YXJnZXQgPSBzZWxmLnRhcmdldFxuXHRcdHZhciBkZWNsID0gIW9wdGlvbig6Z2xvYmFsKSBhbmQgIW9wdGlvbig6ZXhwb3J0KVxuXG5cdFx0aWYgdGFyZ2V0IGlzYSBTY29wZUNvbnRleHRcblx0XHRcdCMgdGhlIHRhcmdldCBpcyBhIHNjb3BlIGNvbnRleHRcblx0XHRcdHRhcmdldCA9IG51bGxcblxuXHRcdHZhciBjdHggPSBjb250ZXh0XG5cdFx0dmFyIG91dCA9IFwiXCJcblx0XHR2YXIgbWFyayA9IG1hcmtfXyhvcHRpb24oJ2RlZicpKVxuXHRcdCMgaWYgY3R4IFxuXG5cdFx0dmFyIGZuYW1lID0gc3ltX18oc2VsZi5uYW1lKVxuXHRcdCMgY29uc29sZS5sb2cgXCJzeW1ib2xpemUge3NlbGYubmFtZX0gLS0ge2ZuYW1lfVwiXG5cdFx0dmFyIGZkZWNsID0gZm5hbWUgIyBkZWNsID8gZm5hbWUgOiAnJ1xuXG5cdFx0aWYgY3R4IGlzYSBDbGFzc1Njb3BlIGFuZCAhdGFyZ2V0XG5cdFx0XHRpZiB0eXBlID09IDpjb25zdHJ1Y3RvclxuXHRcdFx0XHRvdXQgPSBcInttYXJrfWZ1bmN0aW9uIHtmbmFtZX17ZnVuY31cIlxuXHRcdFx0ZWxpZiBvcHRpb24oOnN0YXRpYylcblx0XHRcdFx0b3V0ID0gXCJ7bWFya317Y3R4LmNvbnRleHQuY30ue2ZuYW1lfSA9IGZ1bmN0aW9uIHtmdW5jfVwiXG5cdFx0XHRlbHNlXG5cdFx0XHRcdG91dCA9IFwie21hcmt9e2N0eC5jb250ZXh0LmN9LnByb3RvdHlwZS57Zm5hbWV9ID0gZnVuY3Rpb24ge2Z1bmN9XCJcblxuXHRcdGVsaWYgY3R4IGlzYSBSb290U2NvcGUgYW5kICF0YXJnZXRcblx0XHRcdCMgcmVnaXN0ZXIgbWV0aG9kIGFzIGEgcm9vdC1mdW5jdGlvbiwgYnV0IHdpdGggYXV0by1jYWxsPyBobW1cblx0XHRcdCMgc2hvdWxkIHByb2JhYmx5IHNldCB1c2luZyB2YXJpYWJsZSBkaXJlY3RseSBpbnN0ZWFkLCBubz9cblx0XHRcdG91dCA9IFwie21hcmt9ZnVuY3Rpb24ge2ZkZWNsfXtmdW5jfVwiXG5cblx0XHRlbGlmIHRhcmdldCBhbmQgb3B0aW9uKDpzdGF0aWMpXG5cdFx0XHRvdXQgPSBcInttYXJrfXt0YXJnZXQuY30ue2ZuYW1lfSA9IGZ1bmN0aW9uIHtmdW5jfVwiXG5cblx0XHRlbGlmIHRhcmdldFxuXHRcdFx0b3V0ID0gXCJ7bWFya317dGFyZ2V0LmN9LnByb3RvdHlwZS57Zm5hbWV9ID0gZnVuY3Rpb24ge2Z1bmN9XCJcblx0XHRlbHNlXG5cdFx0XHRvdXQgPSBcInttYXJrfWZ1bmN0aW9uIHtmZGVjbH17ZnVuY31cIlxuXG5cdFx0aWYgb3B0aW9uKDpnbG9iYWwpXG5cdFx0XHRvdXQgPSBcIntmbmFtZX0gPSB7b3V0fVwiXG5cblx0XHRpZiBvcHRpb24oOmV4cG9ydClcblx0XHRcdG91dCA9IFwie291dH07IGV4cG9ydHMue2ZuYW1lfSA9IHtmbmFtZX07XCJcblx0XHRcdG91dCA9IFwie291dH07IHJldHVybiB7Zm5hbWV9O1wiIGlmIG9wdGlvbig6cmV0dXJuKVxuXG5cdFx0ZWxpZiBvcHRpb24oOnJldHVybilcblx0XHRcdG91dCA9IFwicmV0dXJuIHtvdXR9XCJcblxuXHRcdG91dFxuXG5cbmV4cG9ydCBjbGFzcyBUYWdGcmFnbWVudERlY2xhcmF0aW9uIDwgTWV0aG9kRGVjbGFyYXRpb25cblxuXG5leHBvcnQgY2xhc3MgUHJvcGVydHlEZWNsYXJhdGlvbiA8IE5vZGVcblxuXHR2YXIgcHJvcFRlbXBsYXRlID0gJycnXG5cdCR7aGVhZGVyc31cblx0JHtwYXRofS4ke2dldHRlcn0gPSBmdW5jdGlvbih2KXsgcmV0dXJuICR7Z2V0fTsgfVxuXHQke3BhdGh9LiR7c2V0dGVyfSA9IGZ1bmN0aW9uKHYpeyAke3NldH07IHJldHVybiB0aGlzOyB9XG5cdCR7aW5pdH1cblx0JycnXG5cblx0dmFyIHByb3BXYXRjaFRlbXBsYXRlID0gJycnXG5cdCR7aGVhZGVyc31cblx0JHtwYXRofS4ke2dldHRlcn0gPSBmdW5jdGlvbih2KXsgcmV0dXJuICR7Z2V0fTsgfVxuXHQke3BhdGh9LiR7c2V0dGVyfSA9IGZ1bmN0aW9uKHYpe1xuXHRcdHZhciBhID0gdGhpcy4ke2dldHRlcn0oKTtcblx0XHRpZih2ICE9IGEpIHsgJHtzZXR9OyB9XG5cdFx0aWYodiAhPSBhKSB7ICR7b25kaXJ0eX0gfVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdCR7aW5pdH1cblx0JycnXG5cblx0cHJvcCBuYW1lXG5cdHByb3Agb3B0aW9uc1xuXG5cdGRlZiBpbml0aWFsaXplIG5hbWUsIG9wdGlvbnMsIHRva2VuXG5cdFx0QHRva2VuID0gdG9rZW5cblx0XHRAdHJhdmVyc2VkID0gbm9cblx0XHRAbmFtZSA9IG5hbWVcblx0XHRAb3B0aW9ucyA9IG9wdGlvbnMgfHwgT2JqLm5ldyhBc3NpZ25MaXN0Lm5ldylcblxuXHRkZWYgdmlzaXRcblx0XHRAb3B0aW9ucy50cmF2ZXJzZVxuXHRcdHNlbGZcblxuXHQjIFRoaXMgd2lsbCBzb29uIHN1cHBvcnQgYmluZGluZ3MgLyBsaXN0ZW5lcnMgZXRjLCBtdWNoIG1vcmVcblx0IyBhZHZhbmNlZCBnZW5lcmF0ZWQgY29kZSBiYXNlZCBvbiBvcHRpb25zIHBhc3NlZCBpbi5cblx0ZGVmIGNcblx0XHR2YXIgbyA9IG9wdGlvbnNcblx0XHR2YXIgYXN0ID0gXCJcIlxuXHRcdHZhciBrZXkgPSBuYW1lLmpzXG5cdFx0dmFyIHNjb3BlID0gU1RBQ0suc2NvcGVcblxuXHRcdHZhciBhZGREZXNjID0gby5rZXlzOmxlbmd0aFxuXG5cdFx0dmFyIHBhcnMgPSBvLmhhc2hcblxuXHRcdHZhciBpc0F0dHIgPSAoQHRva2VuIGFuZCBTdHJpbmcoQHRva2VuKSA9PSAnYXR0cicpIG9yIG8ua2V5KDphdHRyKVxuXG5cdFx0dmFyIGpzID1cblx0XHRcdGtleToga2V5XG5cdFx0XHRnZXR0ZXI6IGtleVxuXHRcdFx0c2V0dGVyOiBzeW1fXyhcInNldC17a2V5fVwiKVxuXHRcdFx0c2NvcGU6IFwie3Njb3BlLmNvbnRleHQuY31cIiBcblx0XHRcdHBhdGg6ICcke3Njb3BlfS5wcm90b3R5cGUnXG5cdFx0XHRzZXQ6IFwidGhpcy5fe2tleX0gPSB2XCJcblx0XHRcdGdldDogXCJ0aGlzLl97a2V5fVwiXG5cdFx0XHRpbml0OiBcIlwiXG5cdFx0XHRoZWFkZXJzOiBcIlwiXG5cdFx0XHRvbmRpcnR5OiBcIlwiXG5cblxuXHRcdGlmIHBhcnM6aW5saW5lXG5cdFx0XHRpZiBwYXJzOmlubGluZSBpc2EgQm9vbCBhbmQgIXBhcnM6aW5saW5lLnRydXRoeVxuXHRcdFx0XHRvLnJlbW92ZSgnaW5saW5lJylcblx0XHRcdFx0IyBwIFwiZG9udCBtYWtlIGF0dHIgaW5saW5lKCEpXCJcblx0XHRcdFx0cmV0dXJuIFwiSW1iYS57QHRva2VufSh7anM6c2NvcGV9LCd7bmFtZS52YWx1ZX0nLHtvLmN9KVwiLnJlcGxhY2UoJyx7fSknLCcpJylcblxuXHRcdFx0IyBwIFwicGFycyBpbmxpbmU/IT8ge3BhcnM6aW5saW5lfVwiLCB0eXBlb2YgcGFyczppbmxpbmVcblxuXHRcdHZhciB0cGwgPSBwcm9wVGVtcGxhdGVcblxuXHRcdG8uYWRkKCduYW1lJyxTeW1ib2wubmV3KGtleSkpXG5cblx0XHRpZiBwYXJzOndhdGNoXG5cdFx0XHQjIHAgXCJ3YXRjaCBpcyBhIHByb3BlcnR5IHtwYXJzOndhdGNofVwiXG5cdFx0XHR0cGwgPSBwcm9wV2F0Y2hUZW1wbGF0ZSB1bmxlc3MgcGFyczp3YXRjaCBpc2EgQm9vbCBhbmQgIXBhcnM6d2F0Y2gudHJ1dGh5XG5cdFx0XHR2YXIgd2ZuID0gXCJ7a2V5fURpZFNldFwiXG5cblx0XHRcdGlmIHBhcnM6d2F0Y2ggaXNhIFN5bWJvbFxuXHRcdFx0XHR3Zm4gPSBwYXJzOndhdGNoXG5cdFx0XHRlbGlmIHBhcnM6d2F0Y2ggaXNhIEJvb2xcblx0XHRcdFx0by5rZXkoOndhdGNoKS52YWx1ZSA9IFN5bWJvbC5uZXcoXCJ7a2V5fURpZFNldFwiKVxuXG5cdFx0XHR2YXIgZm4gPSBPUCgnLicsVGhpcy5uZXcsd2ZuKVxuXHRcdFx0anM6b25kaXJ0eSA9IE9QKCcmJicsZm4sQ0FMTChmbixbJ3YnLCdhJyxcInRoaXMuX197a2V5fVwiXSkpLmNcblxuXHRcdGlmIHBhcnM6b2JzZXJ2ZVxuXHRcdFx0aWYgcGFyczpvYnNlcnZlIGlzYSBCb29sXG5cdFx0XHRcdG8ua2V5KDpvYnNlcnZlKS52YWx1ZSA9IFN5bWJvbC5uZXcoXCJ7a2V5fURpZEVtaXRcIilcblxuXHRcdFx0dHBsID0gcHJvcFdhdGNoVGVtcGxhdGVcblx0XHRcdGpzOm9uZGlydHkgPSBcIkltYmEub2JzZXJ2ZVByb3BlcnR5KHRoaXMsJ3trZXl9Jyx7by5rZXkoOm9ic2VydmUpLnZhbHVlLmN9LHYsYSk7XCIgK8KgKGpzOm9uZGlydHkgb3IgJycpXG5cdFx0XHQjIE9QKCcmJicsZm4sQ0FMTChmbixbJ3YnLCdhJyxcInRoaXMuX197a2V5fVwiXSkpLmNcblxuXHRcdGlmIChAdG9rZW4gYW5kIFN0cmluZyhAdG9rZW4pID09ICdhdHRyJykgb3Igby5rZXkoOmRvbSkgb3Igby5rZXkoOmF0dHIpXG5cdFx0XHRsZXQgYXR0cktleSA9IG8ua2V5KDpkb20pIGlzYSBTdHIgPyBvLmtleSg6ZG9tKSA6IG5hbWUudmFsdWVcblx0XHRcdCMgbmVlZCB0byBtYWtlIHN1cmUgbyBoYXMgYSBrZXkgZm9yIGF0dHIgdGhlbiAtIHNvIHRoYXQgdGhlIGRlbGVnYXRlIGNhbiBrbm93P1xuXHRcdFx0anM6c2V0ID0gXCJ0aGlzLnNldEF0dHJpYnV0ZSgne2F0dHJLZXl9Jyx2KVwiXG5cdFx0XHRqczpnZXQgPSBcInRoaXMuZ2V0QXR0cmlidXRlKCd7YXR0cktleX0nKVwiXG5cblx0XHRlbGlmIG8ua2V5KDpkZWxlZ2F0ZSlcblx0XHRcdCMgaWYgd2UgaGF2ZSBhIGRlbGVnYXRlXG5cdFx0XHRqczpzZXQgPSBcInYgPSB0aGlzLl9fe2tleX0uZGVsZWdhdGUuc2V0KHRoaXMsJ3trZXl9Jyx2LHRoaXMuX197a2V5fSlcIlxuXHRcdFx0anM6Z2V0ID0gXCJ0aGlzLl9fe2tleX0uZGVsZWdhdGUuZ2V0KHRoaXMsJ3trZXl9Jyx0aGlzLl9fe2tleX0pXCJcblxuXG5cblx0XHRpZiBwYXJzOmRlZmF1bHRcblx0XHRcdGlmIG8ua2V5KDpkb20pXG5cdFx0XHRcdCMgRklYTUUgZ28gdGhyb3VnaCBjbGFzcy1tZXRob2Qgc2V0QXR0cmlidXRlIGluc3RlYWRcblx0XHRcdFx0anM6aW5pdCA9IFwie2pzOnNjb3BlfS5kb20oKS5zZXRBdHRyaWJ1dGUoJ3trZXl9Jyx7cGFyczpkZWZhdWx0LmN9KTtcIlxuXHRcdFx0ZWxzZVxuXHRcdFx0XHQjIGlmIHRoaXMgaXMgbm90IGEgcHJpbWl0aXZlIC0gaXQgTVVTVCBiZSBpbmNsdWRlZCBpbiB0aGVcblx0XHRcdFx0IyBnZXR0ZXIgLyBzZXR0ZXIgaW5zdGVhZFxuXHRcdFx0XHRqczppbml0ID0gXCJ7anM6c2NvcGV9LnByb3RvdHlwZS5fe2tleX0gPSB7cGFyczpkZWZhdWx0LmN9O1wiXG5cblx0XHRpZiBvLmtleSg6Y2hhaW5hYmxlKVxuXHRcdFx0anM6Z2V0ID0gXCJ2ICE9PSB1bmRlZmluZWQgPyAodGhpcy57anM6c2V0dGVyfSh2KSx0aGlzKSA6IHtqczpnZXR9XCJcblxuXG5cdFx0anM6b3B0aW9ucyA9IG8uY1xuXG5cdFx0aWYgYWRkRGVzY1xuXHRcdFx0anM6aGVhZGVycyA9IFwie2pzOnBhdGh9Ll9fe2pzOmdldHRlcn0gPSB7anM6b3B0aW9uc307XCJcblxuXHRcdHZhciByZWcgPSAvXFwkXFx7KFxcdyspXFx9L2dtXG5cdFx0IyB2YXIgdHBsID0gby5rZXkoOndhdGNoKSA/IHByb3BXYXRjaFRlbXBsYXRlIDogcHJvcFRlbXBsYXRlXG5cdFx0dmFyIG91dCA9IHRwbC5yZXBsYWNlKHJlZykgZG8gfG0sYXwganNbYV1cblx0XHQjIHJ1biBhbm90aGVyIHRpbWUgZm9yIG5lc3RpbmcuIGhhY2t5XG5cdFx0b3V0ID0gb3V0LnJlcGxhY2UocmVnKSBkbyB8bSxhfCBqc1thXVxuXHRcdCMgb3V0ID0gb3V0LnJlcGxhY2UoL1xcblxccyokLywnJylcblx0XHRvdXQgPSBvdXQucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG5cdFx0XG5cdFx0IyBpZiBvLmtleSg6dilcblx0XHRyZXR1cm4gb3V0XG5cblxuXG4jIExpdGVyYWxzIHNob3VsZCBwcm9iYWJseSBub3QgaW5oZXJpdCBmcm9tIHRoZSBzYW1lIHBhcmVudFxuIyBhcyBhcnJheXMsIHR1cGxlcywgb2JqZWN0cyB3b3VsZCBiZSBiZXR0ZXIgb2ZmIGluaGVyaXRpbmdcbiMgZnJvbSBsaXN0bm9kZS5cblxuZXhwb3J0IGNsYXNzIExpdGVyYWwgPCBWYWx1ZU5vZGVcblx0XG5cdGRlZiBpbml0aWFsaXplIHZcblx0XHRAdHJhdmVyc2VkID0gbm9cblx0XHRAZXhwcmVzc2lvbiA9IHllc1xuXHRcdEBjYWNoZSA9IG51bGxcblx0XHRAcmF3ID0gbnVsbFxuXHRcdEB2YWx1ZSA9IHZcblxuXHRkZWYgdG9TdHJpbmdcblx0XHRcIlwiICsgdmFsdWVcblxuXHRkZWYgaGFzU2lkZUVmZmVjdHNcblx0XHRmYWxzZVxuXHRcdFxuXG5leHBvcnQgY2xhc3MgQm9vbCA8IExpdGVyYWxcblx0XG5cdCMgU2hvdWxkIGtlZXAgdGhlIHJlYWwgdmFsdWUgKHllcy9uby90cnVlL2ZhbHNlKT9cblx0ZGVmIGluaXRpYWxpemUgdlxuXHRcdEB2YWx1ZSA9IHZcblx0XHRAcmF3ID0gU3RyaW5nKHYpID09IFwidHJ1ZVwiID8gdHJ1ZSA6IGZhbHNlXG5cblx0ZGVmIGNhY2hlXG5cdFx0c2VsZlxuXG5cdGRlZiBpc1ByaW1pdGl2ZVxuXHRcdHllc1xuXG5cdGRlZiB0cnV0aHlcblx0XHQjIHAgXCJib29sIGlzIHRydXRoeT8ge3ZhbHVlfVwiXG5cdFx0U3RyaW5nKHZhbHVlKSA9PSBcInRydWVcIlxuXHRcdCMgeWVzXG5cblx0ZGVmIGpzIG9cblx0XHRTdHJpbmcoQHZhbHVlKVxuXG5cdGRlZiBjXG5cdFx0U1RBQ0suQGNvdW50ZXIgKz0gMVxuXHRcdCMgdW5kZWZpbmVkIHNob3VsZCBub3QgYmUgYSBib29sXG5cdFx0U3RyaW5nKEB2YWx1ZSlcblx0XHQjIEByYXcgPyBcInRydWVcIiA6IFwiZmFsc2VcIlxuXG5cdGRlZiB0b0pTT05cblx0XHR7dHlwZTogJ0Jvb2wnLCB2YWx1ZTogQHZhbHVlfVxuXG5leHBvcnQgY2xhc3MgVW5kZWZpbmVkIDwgTGl0ZXJhbFxuXHRcblx0ZGVmIGlzUHJpbWl0aXZlXG5cdFx0eWVzXG5cblx0ZGVmIGNcblx0XHRtYXJrX18oQHZhbHVlKSArIFwidW5kZWZpbmVkXCJcblxuZXhwb3J0IGNsYXNzIE5pbCA8IExpdGVyYWxcblx0XG5cdGRlZiBpc1ByaW1pdGl2ZVxuXHRcdHllc1xuXG5cdGRlZiBjXG5cdFx0bWFya19fKEB2YWx1ZSkgKyBcIm51bGxcIlxuXG5leHBvcnQgY2xhc3MgVHJ1ZSA8IEJvb2xcblxuXHRkZWYgcmF3XG5cdFx0dHJ1ZVxuXG5cdGRlZiBjXG5cdFx0bWFya19fKEB2YWx1ZSkgKyBcInRydWVcIlxuXHRcdFxuZXhwb3J0IGNsYXNzIEZhbHNlIDwgQm9vbFxuXG5cdGRlZiByYXdcblx0XHRmYWxzZVxuXG5cdGRlZiBjXG5cdFx0bWFya19fKEB2YWx1ZSkgKyBcImZhbHNlXCJcblxuZXhwb3J0IGNsYXNzIE51bSA8IExpdGVyYWxcblx0XG5cdCMgdmFsdWUgaXMgdG9rZW4gLSBzaG91bGQgbm90IGJlXG5cdGRlZiBpbml0aWFsaXplIHZcblx0XHRAdHJhdmVyc2VkID0gbm9cblx0XHRAdmFsdWUgPSB2XG5cblx0ZGVmIHRvU3RyaW5nXG5cdFx0U3RyaW5nKEB2YWx1ZSlcblxuXHRkZWYgaXNQcmltaXRpdmUgZGVlcFxuXHRcdHllc1xuXG5cdGRlZiBzaG91bGRQYXJlbnRoZXNpemUgcGFyID0gdXBcblx0XHRwYXIgaXNhIEFjY2VzcyBhbmQgcGFyLmxlZnQgPT0gc2VsZlxuXG5cdGRlZiBqcyBvXG5cdFx0dmFyIG51bSA9IFN0cmluZyhAdmFsdWUpXG5cdFx0IyBjb25zb2xlLmxvZyBcImNvbXBpbGVkIG51bSB0byB7bnVtfVwiXG5cdFx0cmV0dXJuIG51bVxuXG5cdGRlZiBjIG9cblx0XHRyZXR1cm4gc3VwZXIobykgaWYgQGNhY2hlXG5cdFx0dmFyIGpzID0gU3RyaW5nKEB2YWx1ZSlcblx0XHR2YXIgcGFyID0gU1RBQ0suY3VycmVudFxuXHRcdHZhciBwYXJlbiA9IHBhciBpc2EgQWNjZXNzIGFuZCBwYXIubGVmdCA9PSBzZWxmXG5cdFx0IyBvbmx5IGlmIHRoaXMgaXMgdGhlIHJpZ2h0IHBhcnQgb2YgdGVoIGFjY2VzXG5cdFx0IyBjb25zb2xlLmxvZyBcInNob3VsZCBwYXJlbj8/IHtzaG91bGRQYXJlbnRoZXNpemV9XCJcblx0XHRwYXJlbiA/IFwiKHttYXJrX18oQHZhbHVlKX1cIiArIGpzICsgXCIpXCIgOiAobWFya19fKEB2YWx1ZSkgKyBqcylcblx0XHQjIEBjYWNoZSA/IHN1cGVyKG8pIDogU3RyaW5nKEB2YWx1ZSlcblxuXHRkZWYgY2FjaGUgb1xuXHRcdCMgcCBcImNhY2hlIG51bVwiLG9cblx0XHRyZXR1cm4gc2VsZiB1bmxlc3MgbyBhbmQgKG86Y2FjaGUgb3Igbzpwb29sKVxuXHRcdHN1cGVyKG8pXG5cblx0ZGVmIHJhd1xuXHRcdCMgcmVhbGx5P1xuXHRcdEpTT04ucGFyc2UoU3RyaW5nKHZhbHVlKSlcblxuXHRkZWYgdG9KU09OXG5cdFx0e3R5cGU6IHR5cGVOYW1lLCB2YWx1ZTogcmF3fVxuXG4jIHNob3VsZCBiZSBxdW90ZWQgbm8/XG4jIHdoYXQgYWJvdXQgc3RyaW5ncyBpbiBvYmplY3QtbGl0ZXJhbHM/XG4jIHdlIHdhbnQgdG8gYmUgYWJsZSB0byBzZWUgaWYgdGhlIHZhbHVlcyBhcmUgYWxsb3dlZFxuZXhwb3J0IGNsYXNzIFN0ciA8IExpdGVyYWxcblxuXHRkZWYgaW5pdGlhbGl6ZSB2XG5cdFx0QHRyYXZlcnNlZCA9IG5vXG5cdFx0QGV4cHJlc3Npb24gPSB5ZXNcblx0XHRAY2FjaGUgPSBudWxsXG5cdFx0QHZhbHVlID0gdlxuXHRcdCMgc2hvdWxkIGdyYWIgdGhlIGFjdHVhbCB2YWx1ZSBpbW1lZGlhdGVseT9cblxuXHRkZWYgaXNTdHJpbmdcblx0XHR5ZXNcblxuXHRkZWYgaXNQcmltaXRpdmUgZGVlcFxuXHRcdHllc1xuXG5cdGRlZiByYXdcblx0XHQjIEpTT04ucGFyc2UgcmVxdWlyZXMgZG91YmxlLXF1b3RlZCBzdHJpbmdzLFxuXHRcdCMgd2hpbGUgZXZhbCBhbHNvIGFsbG93cyBzaW5nbGUgcXVvdGVzLiBcblx0XHQjIE5FWFQgZXZhbCBpcyBub3QgYWNjZXNzaWJsZSBsaWtlIHRoaXNcblx0XHQjIFdBUk5JTkcgVE9ETyBiZSBjYXJlZnVsISAtIHNob3VsZCBjbGVhbiB1cFxuXG5cdFx0QHJhdyB8fD0gU3RyaW5nKHZhbHVlKS5zbGljZSgxLC0xKSAjIGluY3JlZGlibHkgc3R1cGlkIHNvbHV0aW9uXG5cblx0ZGVmIGlzVmFsaWRJZGVudGlmaWVyXG5cdFx0IyB0aGVyZSBhcmUgYWxzbyBzb21lIHZhbHVlcyB3ZSBjYW5ub3QgdXNlXG5cdFx0cmF3Lm1hdGNoKC9eW2EtekEtWlxcJFxcX10rW1xcZFxcd1xcJFxcX10qJC8pID8gdHJ1ZSA6IGZhbHNlXG5cblx0ZGVmIGpzIG9cblx0XHRTdHJpbmcoQHZhbHVlKVxuXG5cdGRlZiBjIG9cblx0XHRAY2FjaGUgPyBzdXBlcihvKSA6IFN0cmluZyhAdmFsdWUpXG5cblxuZXhwb3J0IGNsYXNzIEludGVycG9sYXRpb24gPCBWYWx1ZU5vZGVcblxuIyBDdXJyZW50bHkgbm90IHVzZWQgLSBpdCB3b3VsZCBiZSBiZXR0ZXIgdG8gdXNlIHRoaXNcbiMgZm9yIHJlYWwgaW50ZXJwb2xhdGVkIHN0cmluZ3MgdGhvdWdoLCB0aGFuIHRvIGJyZWFrXG4jIHRoZW0gdXAgaW50byB0aGVpciBwYXJ0cyBiZWZvcmUgcGFyc2luZ1xuZXhwb3J0IGNsYXNzIEludGVycG9sYXRlZFN0cmluZyA8IE5vZGVcblxuXHRkZWYgaW5pdGlhbGl6ZSBub2RlcywgbyA9IHt9XG5cdFx0QG5vZGVzID0gbm9kZXNcblx0XHRAb3B0aW9ucyA9IG9cblx0XHRzZWxmXG5cblx0ZGVmIGFkZCBwYXJ0XG5cdFx0QG5vZGVzLnB1c2gocGFydCkgaWYgcGFydFxuXHRcdHNlbGZcblxuXHRkZWYgdmlzaXRcblx0XHRmb3Igbm9kZSBpbiBAbm9kZXNcblx0XHRcdG5vZGUudHJhdmVyc2Vcblx0XHRzZWxmXG5cblx0ZGVmIGVzY2FwZVN0cmluZyBzdHJcblx0XHQjIHZhciBpZHggPSAwXG5cdFx0IyB2YXIgbGVuID0gc3RyOmxlbmd0aFxuXHRcdCMgdmFyIGNoclxuXHRcdCMgd2hpbGUgY2hyID0gc3RyW2lkeCsrXVxuXHRcdHN0ciA9IHN0ci5yZXBsYWNlKC9cXG4vZywgJ1xcXFxcXG4nKVxuXG5cdGRlZiBqcyBvXG5cdFx0IyBjcmVhdGluZyB0aGUgc3RyaW5nXG5cdFx0dmFyIHBhcnRzID0gW11cblx0XHR2YXIgc3RyID0gJygnXG5cblx0XHRAbm9kZXMubWFwIGRvIHxwYXJ0LGl8XG5cdFx0XHRpZiBwYXJ0IGlzYSBUb2tlbiBhbmQgcGFydC5AdHlwZSA9PSAnTkVPU1RSSU5HJ1xuXHRcdFx0XHQjIGVzY2Fcblx0XHRcdFx0cGFydHMucHVzaCgnXCInICsgZXNjYXBlU3RyaW5nKHBhcnQuQHZhbHVlKSArICdcIicpXG5cdFx0XHRlbGlmIHBhcnRcblx0XHRcdFx0aWYgaSA9PSAwXG5cdFx0XHRcdFx0IyBmb3JjZSBmaXJzdCBwYXJ0IHRvIGJlIHN0cmluZ1xuXHRcdFx0XHRcdHBhcnRzLnB1c2goJ1wiXCInKVxuXHRcdFx0XHRwYXJ0LkBwYXJlbnMgPSB5ZXNcblx0XHRcdFx0cGFydHMucHVzaChwYXJ0LmMoZXhwcmVzc2lvbjogeWVzKSlcblxuXHRcdHN0ciArPSBwYXJ0cy5qb2luKFwiICsgXCIpXG5cdFx0c3RyICs9ICcpJ1xuXHRcdHJldHVybiBzdHJcblxuXG5leHBvcnQgY2xhc3MgVHVwbGUgPCBMaXN0Tm9kZVxuXG5cdGRlZiBjXG5cdFx0IyBjb21waWxlcyBhcyBhbiBhcnJheVxuXHRcdEFyci5uZXcobm9kZXMpLmNcblxuXHRkZWYgaGFzU3BsYXRcblx0XHRmaWx0ZXIofHZ8IHYgaXNhIFNwbGF0IClbMF1cblxuXHRkZWYgY29uc3VtZSBub2RlXG5cdFx0aWYgY291bnQgPT0gMVxuXHRcdFx0cmV0dXJuIGZpcnN0LmNvbnN1bWUobm9kZSlcblx0XHRlbHNlXG5cdFx0XHR0aHJvdyBcIm11bHRpdHVwbGUgY2Fubm90IGNvbnN1bWVcIlxuXHRcdFxuXHRcbiMgQmVjYXVzZSB3ZSd2ZSBkcm9wcGVkIHRoZSBTdHItd3JhcHBlciBpdCBpcyBraW5kYSBkaWZmaWN1bHRcbmV4cG9ydCBjbGFzcyBTeW1ib2wgPCBMaXRlcmFsXG5cblx0ZGVmIGlzVmFsaWRJZGVudGlmaWVyXG5cdFx0cmF3Lm1hdGNoKC9eW2EtekEtWlxcJFxcX10rW1xcZFxcd1xcJFxcX10qJC8pID8gdHJ1ZSA6IGZhbHNlXG5cblx0ZGVmIGlzUHJpbWl0aXZlIGRlZXBcblx0XHR5ZXNcblxuXHRkZWYgcmF3XG5cdFx0QHJhdyB8fD0gc3ltX18odmFsdWUpXG5cblx0ZGVmIGpzIG9cblx0XHRcIid7c3ltX18odmFsdWUpfSdcIlxuXG5leHBvcnQgY2xhc3MgUmVnRXhwIDwgTGl0ZXJhbFxuXG5cdGRlZiBpc1ByaW1pdGl2ZVxuXHRcdHllc1xuXG5cdCMgZGVmIHRvU3RyaW5nXG5cdCMgXHRcIlwiICsgdmFsdWVcblxuIyBTaG91bGQgaW5oZXJpdCBmcm9tIExpc3ROb2RlIC0gd291bGQgc2ltcGxpZnlcbmV4cG9ydCBjbGFzcyBBcnIgPCBMaXRlcmFsXG5cblx0ZGVmIGxvYWQgdmFsdWVcblx0XHR2YWx1ZSBpc2EgQXJyYXkgPyBBcmdMaXN0Lm5ldyh2YWx1ZSkgOiB2YWx1ZVxuXG5cdGRlZiBwdXNoIGl0ZW1cblx0XHR2YWx1ZS5wdXNoKGl0ZW0pXG5cdFx0c2VsZlxuXG5cdGRlZiBjb3VudFxuXHRcdHZhbHVlOmxlbmd0aFxuXG5cdGRlZiBub2Rlc1xuXHRcdHZhciB2YWwgPSB2YWx1ZVxuXHRcdHZhbCBpc2EgQXJyYXkgPyB2YWwgOiB2YWwubm9kZXNcblxuXHRkZWYgc3BsYXRcblx0XHR2YWx1ZS5zb21lKHx2fCB2IGlzYSBTcGxhdClcblxuXHRkZWYgdmlzaXRcblx0XHRAdmFsdWUudHJhdmVyc2UgaWYgQHZhbHVlIGFuZCBAdmFsdWU6dHJhdmVyc2Vcblx0XHRzZWxmXG5cblx0ZGVmIGlzUHJpbWl0aXZlIGRlZXBcblx0XHQhdmFsdWUuc29tZSh8dnwgIXYuaXNQcmltaXRpdmUoeWVzKSApXG5cblx0ZGVmIGpzIG9cblxuXHRcdHZhciB2YWwgPSBAdmFsdWVcblx0XHRyZXR1cm4gXCJbXVwiIHVubGVzcyB2YWxcblxuXHRcdHZhciBzcGxhdCA9IHNwbGF0XG5cdFx0dmFyIG5vZGVzID0gdmFsIGlzYSBBcnJheSA/IHZhbCA6IHZhbC5ub2Rlc1xuXHRcdCMgcCBcInZhbHVlIG9mIGFycmF5IGlzYSB7QHZhbHVlfVwiXG5cblx0XHQjIGZvciB2IGluIEB2YWx1ZVxuXHRcdCMgXHRicmVhayBzcGxhdCA9IHllcyBpZiB2IGlzYSBTcGxhdFxuXHRcdCMgdmFyIHNwbGF0ID0gdmFsdWUuc29tZSh8dnwgdiBpc2EgU3BsYXQpXG5cblx0XHRpZiBzcGxhdFxuXHRcdFx0IyBcIlNQTEFUVEVEIEFSUkFZIVwiXG5cdFx0XHQjIGlmIHdlIGtub3cgZm9yIGNlcnRhaW4gdGhhdCB0aGUgc3BsYXRzIGFyZSBhcnJheXMgd2UgY2FuIGRyb3AgdGhlIHNsaWNlP1xuXHRcdFx0IyBwIFwiYXJyYXkgaXMgc3BsYXQ/IT9cIlxuXHRcdFx0dmFyIHNsaWNlcyA9IFtdXG5cdFx0XHR2YXIgZ3JvdXAgPSBudWxsXG5cblx0XHRcdGZvciB2IGluIG5vZGVzXG5cdFx0XHRcdGlmIHYgaXNhIFNwbGF0XG5cdFx0XHRcdFx0c2xpY2VzLnB1c2godilcblx0XHRcdFx0XHRncm91cCA9IG51bGxcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHNsaWNlcy5wdXNoKGdyb3VwID0gQXJyLm5ldyhbXSkpIHVubGVzcyBncm91cFxuXHRcdFx0XHRcdGdyb3VwLnB1c2godilcblxuXHRcdFx0XCJbXS5jb25jYXQoe2NhcnlfXyhzbGljZXMpLmpvaW4oXCIsIFwiKX0pXCJcblx0XHRlbHNlXG5cdFx0XHQjIHZlcnkgdGVtcG9yYXJ5LiBuZWVkIGEgbW9yZSBnZW5lcmljIHdheSB0byBwcmV0dGlmeSBjb2RlXG5cdFx0XHQjIHNob3VsZCBkZXBlbmQgb24gdGhlIGxlbmd0aCBvZiB0aGUgaW5uZXIgaXRlbXMgZXRjXG5cdFx0XHQjIGlmIEBpbmRlbnRlZCBvciBvcHRpb24oOmluZGVudCkgb3IgdmFsdWUuQGluZGVudGVkXG5cdFx0XHQjXHRcIltcXG57dmFsdWUuYy5qb2luKFwiLFxcblwiKS5pbmRlbnR9XFxuXVwiXG5cdFx0XHR2YXIgb3V0ID0gdmFsIGlzYSBBcnJheSA/IGNhcnlfXyh2YWwpIDogdmFsLmNcblx0XHRcdFwiW3tvdXR9XVwiXG5cblx0ZGVmIGhhc1NpZGVFZmZlY3RzXG5cdFx0dmFsdWUuc29tZSh8dnwgdi5oYXNTaWRlRWZmZWN0cyApXG5cblx0ZGVmIHRvU3RyaW5nXG5cdFx0XCJBcnJcIlxuXHRcblx0ZGVmIGluZGVudGVkIGEsYlxuXHRcdEB2YWx1ZS5pbmRlbnRlZChhLGIpXG5cdFx0c2VsZlxuXG5cdGRlZiBzZWxmLndyYXAgdmFsXG5cdFx0QXJyLm5ldyh2YWwpXG5cbiMgc2hvdWxkIG5vdCBiZSBja2xhc3NpZmllZCBhcyBhIGxpdGVyYWw/XG5leHBvcnQgY2xhc3MgT2JqIDwgTGl0ZXJhbFxuXG5cdGRlZiBsb2FkIHZhbHVlXG5cdFx0dmFsdWUgaXNhIEFycmF5ID8gQXNzaWduTGlzdC5uZXcodmFsdWUpIDogdmFsdWVcblxuXHRkZWYgdmlzaXRcblx0XHRAdmFsdWUudHJhdmVyc2UgaWYgQHZhbHVlXG5cdFx0IyBmb3IgdiBpbiB2YWx1ZVxuXHRcdCMgXHR2LnRyYXZlcnNlXG5cdFx0c2VsZlxuXG5cdGRlZiBqcyBvXG5cdFx0dmFyIGR5biA9IHZhbHVlLmZpbHRlcih8dnwgdiBpc2EgT2JqQXR0ciBhbmQgKHYua2V5IGlzYSBPcCBvciB2LmtleSBpc2EgSW50ZXJwb2xhdGVkU3RyaW5nKSAgKVxuXG5cdFx0aWYgZHluOmxlbmd0aCA+IDBcblx0XHRcdHZhciBpZHggPSB2YWx1ZS5pbmRleE9mKGR5blswXSlcblx0XHRcdCMgcCBcImR5bmFtaWMga2V5cyEge2R5bn1cIlxuXHRcdFx0IyBjcmVhdGUgYSB0ZW1wIHZhcmlhYmxlXG5cblx0XHRcdHZhciB0bXAgPSBzY29wZV9fLnRlbXBvcmFyeShzZWxmKVxuXHRcdFx0IyBzZXQgdGhlIHRlbXBvcmFyeSBvYmplY3QgdG8gdGhlIHNhbWVcblx0XHRcdHZhciBmaXJzdCA9IHZhbHVlLnNsaWNlKDAsaWR4KVxuXHRcdFx0dmFyIG9iaiA9IE9iai5uZXcoZmlyc3QpXG5cdFx0XHR2YXIgYXN0ID0gW09QKCc9Jyx0bXAsb2JqKV1cblxuXHRcdFx0dmFsdWUuc2xpY2UoaWR4KS5mb3JFYWNoIGRvIHxhdHJ8XG5cdFx0XHRcdGFzdC5wdXNoKE9QKCc9JyxPUCgnLicsdG1wLGF0ci5rZXkpLGF0ci52YWx1ZSkpXG5cdFx0XHRhc3QucHVzaCh0bXApICMgYWNjZXNzIHRoZSB0bXAgYXQgaW4gdGhlIGxhc3QgcGFydFxuXHRcdFx0cmV0dXJuIFBhcmVucy5uZXcoYXN0KS5jXG5cblx0XHQjIGZvciBvYmplY3RzIHdpdGggZXhwcmVzc2lvbi1rZXlzIHdlIG5lZWQgdG8gdGhpbmsgZGlmZmVyZW50bHlcblx0XHQneycgKyB2YWx1ZS5jICsgJ30nXG5cblx0ZGVmIGFkZCBrLCB2XG5cdFx0ayA9IElkZW50aWZpZXIubmV3KGspIGlmIGsgaXNhIFN0cmluZ1xuXHRcdHZhciBrdiA9IE9iakF0dHIubmV3KGssdilcblx0XHR2YWx1ZS5wdXNoKGt2KVxuXHRcdHJldHVybiBrdlxuXG5cdGRlZiByZW1vdmUga2V5XG5cdFx0Zm9yIGsgaW4gdmFsdWVcblx0XHRcdHZhbHVlLnJlbW92ZShrKSBpZiBrLmtleS5zeW1ib2wgPT0ga2V5XG5cdFx0c2VsZlxuXG5cdGRlZiBrZXlzXG5cdFx0T2JqZWN0LmtleXMoaGFzaClcblxuXHRkZWYgaGFzaFxuXHRcdHZhciBoYXNoID0ge31cblx0XHRmb3IgayBpbiB2YWx1ZVxuXHRcdFx0aGFzaFtrLmtleS5zeW1ib2xdID0gay52YWx1ZSBpZiBrIGlzYSBPYmpBdHRyXG5cdFx0cmV0dXJuIGhhc2hcblx0XHQjIHJldHVybiBrIGlmIGsua2V5LnN5bWJvbCA9PSBrZXlcblxuXHQjIGFkZCBtZXRob2QgZm9yIGZpbmRpbmcgcHJvcGVydGllcyBldGM/XG5cdGRlZiBrZXkga2V5XG5cdFx0Zm9yIGsgaW4gdmFsdWVcblx0XHRcdHJldHVybiBrIGlmIGsgaXNhIE9iakF0dHIgYW5kIGsua2V5LnN5bWJvbCA9PSBrZXlcblx0XHRudWxsXG5cblx0ZGVmIGluZGVudGVkIGEsYlxuXHRcdEB2YWx1ZS5pbmRlbnRlZChhLGIpXG5cdFx0c2VsZlxuXG5cdGRlZiBoYXNTaWRlRWZmZWN0c1xuXHRcdHZhbHVlLnNvbWUofHZ8IHYuaGFzU2lkZUVmZmVjdHMgKVxuXG5cdCMgZm9yIGNvbnZlcnRpbmcgYSByZWFsIG9iamVjdCBpbnRvIGFuIGFzdC1yZXByZXNlbnRhdGlvblxuXHRkZWYgc2VsZi53cmFwIG9ialxuXHRcdHZhciBhdHRycyA9IFtdXG5cdFx0Zm9yIG93biBrLHYgb2Ygb2JqXG5cdFx0XHRpZiB2IGlzYSBBcnJheVxuXHRcdFx0XHR2ID0gQXJyLndyYXAodilcblx0XHRcdGVsaWYgdjpjb25zdHJ1Y3RvciA9PSBPYmplY3Rcblx0XHRcdFx0diA9IE9iai53cmFwKHYpXG5cdFx0XHRhdHRycy5wdXNoKE9iakF0dHIubmV3KGssdikpXG5cdFx0cmV0dXJuIE9iai5uZXcoYXR0cnMpXG5cblx0ZGVmIHRvU3RyaW5nXG5cdFx0XCJPYmpcIlxuXHRcdFxuZXhwb3J0IGNsYXNzIE9iakF0dHIgPCBOb2RlXG5cblx0cHJvcCBrZXlcblx0cHJvcCB2YWx1ZVxuXHRwcm9wIG9wdGlvbnNcblxuXHRkZWYgaW5pdGlhbGl6ZSBrZXksIHZhbHVlXG5cdFx0QHRyYXZlcnNlZCA9IG5vXG5cdFx0QGtleSA9IGtleVxuXHRcdEB2YWx1ZSA9IHZhbHVlXG5cdFx0QGR5bmFtaWMgPSBrZXkgaXNhIE9wXG5cdFx0c2VsZlxuXG5cdGRlZiB2aXNpdFxuXHRcdCMgc2hvdWxkIHByb2JhYmx5IHRyYXZlcnNlIGtleSBhcyB3ZWxsLCB1bmxlc3MgaXQgaXMgYSBkZWFkIHNpbXBsZSBpZGVudGlmaWVyXG5cdFx0a2V5LnRyYXZlcnNlXG5cdFx0dmFsdWUudHJhdmVyc2VcblxuXHRkZWYganMgb1xuXHRcdHZhciBrID0ga2V5LmlzUmVzZXJ2ZWQgPyBcIid7a2V5LmN9J1wiIDoga2V5LmNcblx0XHRcIntrfToge3ZhbHVlLmN9XCJcblxuXHRkZWYgaGFzU2lkZUVmZmVjdHNcblx0XHR0cnVlXG5cdFx0XG5cblxuZXhwb3J0IGNsYXNzIEFyZ3NSZWZlcmVuY2UgPCBOb2RlXG5cblx0IyBzaG91bGQgcmVnaXN0ZXIgaW4gdGhpcyBzY29wZSAtLVxuXHRkZWYgY1xuXHRcdFwiYXJndW1lbnRzXCJcblxuIyBzaG91bGQgYmUgYSBzZXBhcmF0ZSBDb250ZXh0IG9yIHNvbWV0aGluZ1xuZXhwb3J0IGNsYXNzIFNlbGYgPCBMaXRlcmFsXG5cblx0cHJvcCBzY29wZVxuXG5cdGRlZiBpbml0aWFsaXplIHNjb3BlXG5cdFx0QHNjb3BlID0gc2NvcGVcblxuXHRkZWYgY2FjaGVcblx0XHRzZWxmXG5cblx0ZGVmIHJlZmVyZW5jZVxuXHRcdHJldHVybiBzZWxmXG5cblx0ZGVmIGNcblx0XHR2YXIgcyA9IHNjb3BlX19cblx0XHQocyA/IHMuY29udGV4dC5jIDogXCJ0aGlzXCIpXG5cbmV4cG9ydCBjbGFzcyBJbXBsaWNpdFNlbGYgPCBTZWxmXG5cdFx0XG5leHBvcnQgY2xhc3MgVGhpcyA8IFNlbGZcblxuXHRkZWYgY2FjaGVcblx0XHRzZWxmXG5cblx0ZGVmIHJlZmVyZW5jZVxuXHRcdCMgcCBcInJlZmVyZW5jaW5nIHRoaXNcIlxuXHRcdHNlbGZcblxuXHRkZWYgY1xuXHRcdFwidGhpc1wiXG5cblxuXG5cbiMgT1BFUkFUT1JTXG5cbmV4cG9ydCBjbGFzcyBPcCA8IE5vZGVcblxuXHRwcm9wIG9wXG5cdHByb3AgbGVmdFxuXHRwcm9wIHJpZ2h0XG5cblx0ZGVmIGluaXRpYWxpemUgbywgbCwgciBcblx0XHQjIHNldCBleHByZXNzaW9uIHllcywgbm8/XG5cdFx0QGV4cHJlc3Npb24gPSBub1xuXHRcdEB0cmF2ZXJzZWQgPSBub1xuXHRcdEBwYXJlbnMgPSBub1xuXHRcdEBjYWNoZSA9IG51bGxcblx0XHRAaW52ZXJ0ID0gbm9cblx0XHRAb3BUb2tlbiA9IG9cblx0XHRAb3AgPSBvIGFuZCBvLkB2YWx1ZSBvciBvXG5cdFx0QGxlZnQgPSBsXG5cdFx0QHJpZ2h0ID0gclxuXHRcdHJldHVybiBzZWxmXG5cblx0ZGVmIHZpc2l0XG5cdFx0QHJpZ2h0LnRyYXZlcnNlIGlmIEByaWdodFxuXHRcdEBsZWZ0LnRyYXZlcnNlIGlmIEBsZWZ0XG5cdFx0cmV0dXJuIHNlbGZcblxuXHRkZWYgaXNFeHByZXNzYWJsZVxuXHRcdCMgd2hhdCBpZiByaWdodCBpcyBhIHN0cmluZz8hP1xuXHRcdCFyaWdodCB8fCByaWdodC5pc0V4cHJlc3NhYmxlXG5cblx0ZGVmIGpzIG9cblx0XHR2YXIgb3V0ID0gbnVsbFxuXHRcdHZhciBvcCA9IEBvcFxuXG5cdFx0dmFyIGwgPSBAbGVmdFxuXHRcdHZhciByID0gQHJpZ2h0XG5cblx0XHRsID0gbC5jIGlmIGwgaXNhIE5vZGVcblx0XHRyID0gci5jIGlmIHIgaXNhIE5vZGVcblxuXHRcdGlmIGwgJiYgclxuXHRcdFx0b3V0ID0gXCJ7bH0ge21hcmtfXyhAb3BUb2tlbil9e29wfSB7cn1cIlxuXHRcdGVsaWYgbFxuXHRcdFx0b3V0ID0gXCJ7bWFya19fKEBvcFRva2VuKX17b3B9e2x9XCJcblx0XHQjIG91dCA9IG91dC5wYXJlbnRoZXNpemUgaWYgdXAgaXNhIE9wICMgcmVhbGx5P1xuXHRcdG91dFxuXG5cdGRlZiBzaG91bGRQYXJlbnRoZXNpemVcblx0XHRAcGFyZW5zXG5cdFx0IyBvcHRpb24oOnBhcmVucylcblxuXHRkZWYgcHJlY2VkZW5jZVxuXHRcdDEwXG5cblx0ZGVmIGNvbnN1bWUgbm9kZVxuXHRcdCMgcCAnYXNzaWduaWZ5IGlmPyEnXG5cdFx0IyBpZiBpdCBpcyBwb3NzaWJsZSwgY29udmVydCBpbnRvIGV4cHJlc3Npb25cblx0XHRpZiBub2RlIGlzYSBUYWdUcmVlXG5cdFx0XHRAbGVmdC5jb25zdW1lKG5vZGUpIGlmIEBsZWZ0XG5cdFx0XHRAcmlnaHQuY29uc3VtZShub2RlKSBpZiBAcmlnaHRcblx0XHRcdCMgQGJvZHkgPSBAYm9keS5jb25zdW1lKG5vZGUpXG5cdFx0XHQjIEBhbHQgPSBAYWx0LmNvbnN1bWUobm9kZSkgaWYgQGFsdFxuXHRcdFx0cmV0dXJuIHNlbGZcblx0XHQjIHAgXCJPcC5jb25zdW1lIHtub2RlfVwiLmN5YW5cblx0XHRyZXR1cm4gc3VwZXIgaWYgaXNFeHByZXNzYWJsZVxuXG5cdFx0IyBUT0RPIGNhbiByYXRoZXIgdXNlIGdsb2JhbCBjYWNoaW5nP1xuXHRcdHZhciB0bXB2YXIgPSBzY29wZV9fLmRlY2xhcmUoOnRtcCxudWxsLHN5c3RlbTogeWVzKVxuXHRcdHZhciBjbG9uZSA9IE9QKG9wLGxlZnQsbnVsbClcblx0XHR2YXIgYXN0ID0gcmlnaHQuY29uc3VtZShjbG9uZSlcblx0XHRhc3QuY29uc3VtZShub2RlKSBpZiBub2RlXG5cdFx0cmV0dXJuIGFzdFxuXG5leHBvcnQgY2xhc3MgQ29tcGFyaXNvbk9wIDwgT3BcblxuXHRkZWYgaW52ZXJ0XG5cdFx0IyBhcmUgdGhlcmUgb3RoZXIgY29tcGFyaXNvbiBvcHM/XG5cdFx0IyB3aGF0IGFib3V0IGEgY2hhaW4/XG5cdFx0dmFyIG9wID0gQG9wXG5cdFx0dmFyIHBhaXJzID0gWyBcIj09XCIsXCIhPVwiICwgXCI9PT1cIixcIiE9PVwiICwgXCI+XCIsXCI8PVwiICwgXCI8XCIsXCI+PVwiIF1cblx0XHR2YXIgaWR4ID0gcGFpcnMuaW5kZXhPZihvcClcblx0XHRpZHggKz0gKGlkeCAlIDIgPyAtMSA6IDEpXG5cblx0XHQjIHAgXCJpbnZlcnQge0BvcH1cIlxuXHRcdCMgcCBcImludmVydGVkIGNvbXBhcmlzb24oISkge2lkeH0ge29wfSAtPiB7cGFpcnNbaWR4XX1cIlxuXHRcdHNlbGYub3AgPSBwYWlyc1tpZHhdXG5cdFx0QGludmVydCA9ICFAaW52ZXJ0XG5cdFx0c2VsZlxuXG5cdGRlZiBjXG5cdFx0aWYgbGVmdCBpc2EgQ29tcGFyaXNvbk9wXG5cdFx0XHRsZWZ0LnJpZ2h0LmNhY2hlXG5cdFx0XHRPUCgnJiYnLGxlZnQsT1Aob3AsbGVmdC5yaWdodCxyaWdodCkpLmNcblx0XHRlbHNlXG5cdFx0XHRzdXBlclxuXG5cdGRlZiBqcyBvXG5cdFx0dmFyIG9wID0gQG9wXG5cdFx0dmFyIGwgPSBAbGVmdFxuXHRcdHZhciByID0gQHJpZ2h0XG5cblx0XHRsID0gbC5jIGlmIGwgaXNhIE5vZGVcblx0XHRyID0gci5jIGlmIHIgaXNhIE5vZGVcblx0XHRyZXR1cm4gXCJ7bH0ge21hcmtfXyhAb3BUb2tlbil9e29wfSB7cn1cIlxuXG5cdFx0XG5leHBvcnQgY2xhc3MgTWF0aE9wIDwgT3Bcblx0IyBCVUcgaWYgd2UgaGF2ZSBhIHN0YXRlbWVudCBpbiBsZWZ0IG9yIHJpZ2h0IHdlIG5lZWRcblx0IyB0byBGT1JDRSBpdCBpbnRvIGFuIGV4cHJlc3Npb24sIGFuZCByZWdpc3RlciB3YXJuaW5nXG5cdCMgc2hvdWxkIG5vdCBhdCBhbGwgY29uc3VtZSBhbnl0aGluZyBsaWtlIGEgcmVndWxhciBPcFxuXHRkZWYgY1xuXHRcdGlmIG9wID09ICfiiKonXG5cdFx0XHRyZXR1cm4gdXRpbC51bmlvbihsZWZ0LHJpZ2h0KS5jXG5cdFx0ZWxpZiBvcCA9PSAn4oipJ1xuXHRcdFx0cmV0dXJuIHV0aWwuaW50ZXJzZWN0KGxlZnQscmlnaHQpLmNcblxuXG5leHBvcnQgY2xhc3MgVW5hcnlPcCA8IE9wXG5cblx0ZGVmIGludmVydFxuXHRcdGlmIG9wID09ICchJ1xuXHRcdFx0cmV0dXJuIGxlZnRcblx0XHRlbHNlXG5cdFx0XHRzdXBlciAjIHJlZ3VsYXIgaW52ZXJ0XG5cblx0ZGVmIGpzIG9cblx0XHR2YXIgbCA9IEBsZWZ0XG5cdFx0dmFyIHIgPSBAcmlnaHRcblx0XHQjIGFsbCBvZiB0aGlzIGNvdWxkIHJlYWxseSBiZSBkb25lIGkgYSBtdWNoXG5cdFx0IyBjbGVhbmVyIHdheS5cblx0XHQjIGwuc2V0KHBhcmVuczogeWVzKSBpZiBsICMgYXJlIHdlIHJlYWxseSBzdXJlIGFib3V0IHRoaXM/XG5cdFx0IyByLnNldChwYXJlbnM6IHllcykgaWYgclxuXG5cdFx0aWYgb3AgPT0gJyEnXG5cdFx0XHQjIGwuQHBhcmVucyA9IHllc1xuXHRcdFx0dmFyIHN0ciA9IGwuY1xuXHRcdFx0dmFyIHBhcmVuID0gbC5zaG91bGRQYXJlbnRoZXNpemUoc2VsZilcblx0XHRcdCMgcCBcImNoZWNrIGZvciBwYXJlbnMgaW4gIToge3N0cn0ge2x9IHtsLkBwYXJlbnN9IHtsLnNob3VsZFBhcmVudGhlc2l6ZShzZWxmKX1cIlxuXHRcdFx0IyBGSVhNRSB0aGlzIGlzIGEgdmVyeSBoYWNreSB3b3JrYXJvdW5kLiBOZWVkIHRvIGhhbmRsZSBhbGwgdGhpc1xuXHRcdFx0IyBpbiB0aGUgY2hpbGQgaW5zdGVhZCwgcHJvYmxlbXMgYXJpc2UgZHVlIHRvIGF1dG9tYXRpYyBjYWNoaW5nXG5cdFx0XHRzdHIgPSAnKCcgKyBzdHIgKyAnKScgdW5sZXNzIHN0ci5tYXRjaCgvXlxcIT8oW1xcd1xcLl0rKSQvKSBvciBsIGlzYSBQYXJlbnMgb3IgcGFyZW4gb3IgbCBpc2EgQWNjZXNzIG9yIGwgaXNhIENhbGxcblx0XHRcdCMgbC5zZXQocGFyZW5zOiB5ZXMpICMgc3VyZT9cblx0XHRcdFwie29wfXtzdHJ9XCJcblxuXHRcdGVsaWYgb3AgPT0gJ+KImidcblx0XHRcdFwiTWF0aC5zcXJ0KHtsLmN9KVwiXG5cblx0XHRlbGlmIGxlZnRcblx0XHRcdFwie2wuY317b3B9XCJcblxuXHRcdGVsc2Vcblx0XHRcdFwie29wfXtyLmN9XCJcblxuXHRkZWYgbm9ybWFsaXplXG5cdFx0cmV0dXJuIHNlbGYgaWYgb3AgPT0gJyEnIG9yIG9wID09ICfiiJonXG5cdFx0dmFyIG5vZGUgPSAobGVmdCB8fCByaWdodCkubm9kZVxuXHRcdCMgZm9yIHByb3BlcnR5LWFjY2Vzc29ycyB3ZSBuZWVkIHRvIHJld3JpdGUgdGhlIGFzdFxuXHRcdHJldHVybiBzZWxmIHVubGVzcyBub2RlIGlzYSBQcm9wZXJ0eUFjY2Vzc1xuXG5cdFx0IyBhc2sgdG8gY2FjaGUgdGhlIHBhdGhcblx0XHRub2RlLmxlZnQuY2FjaGUgaWYgbm9kZSBpc2EgQWNjZXNzICYmIG5vZGUubGVmdFxuXG5cdFx0dmFyIG51bSA9IE51bS5uZXcoMSlcblx0XHR2YXIgYXN0ID0gT1AoJz0nLG5vZGUsT1Aob3BbMF0sbm9kZSxudW0pKVxuXHRcdGFzdCA9IE9QKG9wWzBdID09ICctJyA/ICcrJyA6ICctJyxhc3QsbnVtKSBpZiBsZWZ0XG5cblx0XHRyZXR1cm4gYXN0XG5cblx0ZGVmIGNvbnN1bWUgbm9kZVxuXHRcdHZhciBub3JtID0gbm9ybWFsaXplXG5cdFx0bm9ybSA9PSBzZWxmID8gc3VwZXIgOiBub3JtLmNvbnN1bWUobm9kZSlcblxuXHRkZWYgY1xuXHRcdHZhciBub3JtID0gbm9ybWFsaXplXG5cdFx0bm9ybSA9PSBzZWxmID8gc3VwZXIgOiBub3JtLmNcblxuZXhwb3J0IGNsYXNzIEluc3RhbmNlT2YgPCBPcFxuXG5cdGRlZiBqcyBvXG5cdFx0IyBmaXggY2hlY2tzIGZvciBTdHJpbmcgYW5kIE51bWJlclxuXHRcdCMgcCByaWdodC5pbnNwZWN0XG5cblx0XHRpZiByaWdodCBpc2EgQ29uc3Rcblx0XHRcdCMgV0FSTiBvdGhlcndpc2UgLSB3aGF0IGRvIHdlIGRvPyBkb2VzIG5vdCB3b3JrIHdpdGggZHluYW1pY1xuXHRcdFx0IyBjbGFzc2VzIGV0Yz8gU2hvdWxkIHByb2JhYmx5IHNlbmQgdG8gdXRpbGl0eSBmdW5jdGlvbiBpc2EkXG5cdFx0XHR2YXIgbmFtZSA9IGNfXyhyaWdodC52YWx1ZSlcblx0XHRcdHZhciBvYmogPSBsZWZ0Lm5vZGVcblx0XHRcdCMgVE9ETyBhbHNvIGNoZWNrIGZvciBwcmltaXRpdmUtY29uc3RydWN0b3Jcblx0XHRcdGlmIG5hbWUgaW4gWydTdHJpbmcnLCdOdW1iZXInLCdCb29sZWFuJ11cblx0XHRcdFx0dW5sZXNzIG9iaiBpc2EgTG9jYWxWYXJBY2Nlc3Ncblx0XHRcdFx0XHRvYmouY2FjaGVcblx0XHRcdFx0IyBuZWVkIGEgZG91YmxlIGNoZWNrIGZvciB0aGVzZSAoY2FjaGUgbGVmdCkgLSBwb3NzaWJseVxuXHRcdFx0XHRyZXR1cm4gXCIodHlwZW9mIHtvYmouY309PSd7bmFtZS50b0xvd2VyQ2FzZX0nfHx7b2JqLmN9IGluc3RhbmNlb2Yge25hbWV9KVwiXG5cdFx0XHRcblx0XHRcdFx0IyBjb252ZXJ0XG5cdFx0dmFyIG91dCA9IFwie2xlZnQuY30ge29wfSB7cmlnaHQuY31cIlxuXG5cdFx0IyBzaG91bGQgdGhpcyBub3QgaGFwcGVuIGluICNjP1xuXHRcdG91dCA9IGhlbHBlcnMucGFyZW50aGVzaXplKG91dCkgaWYgby5wYXJlbnQgaXNhIE9wXG5cdFx0b3V0XG5cbmV4cG9ydCBjbGFzcyBUeXBlT2YgPCBPcFxuXG5cdGRlZiBqcyBvXG5cdFx0XCJ0eXBlb2Yge2xlZnQuY31cIlxuXG5leHBvcnQgY2xhc3MgRGVsZXRlIDwgT3BcblxuXHRkZWYganMgb1xuXHRcdCMgVE9ETyB0aGlzIHdpbGwgZXhlY3V0ZSBjYWxscyBzZXZlcmFsIHRpbWVzIGlmIHRoZSBwYXRoIGlzIG5vdCBkaXJlY3RseSB0byBhbiBvYmplY3Rcblx0XHQjIG5lZWQgdG8gY2FjaGUgdGhlIHJlY2VpdmVyXG5cdFx0dmFyIGwgPSBsZWZ0XG5cdFx0dmFyIHRtcCA9IHNjb3BlX18udGVtcG9yYXJ5KHNlbGYsIHBvb2w6ICd2YWwnKVxuXHRcdHZhciBvID0gT1AoJz0nLHRtcCxsKVxuXHRcdCMgRklYTUVcblx0XHRyZXR1cm4gXCIoe28uY30sZGVsZXRlIHtsLmN9LCB7dG1wLmN9KVwiICMgb2ggd2VsbFxuXHRcdCMgdmFyIGFzdCA9IFtPUCgnPScsdG1wLGxlZnQpLFwiZGVsZXRlIHtsZWZ0LmN9XCIsdG1wXVxuXHRcdCMgc2hvdWxkIHBhcmVudGhlc2l6ZSBkaXJlY3RseSBubz9cblx0XHQjIGFzdC5jXG5cblx0ZGVmIHNob3VsZFBhcmVudGhlc2l6ZVxuXHRcdHllc1xuXG5leHBvcnQgY2xhc3MgSW4gPCBPcFxuXG5cdGRlZiBpbnZlcnRcblx0XHRAaW52ZXJ0ID0gIUBpbnZlcnRcblx0XHRzZWxmXG5cblx0ZGVmIGpzIG9cblx0XHR2YXIgY29uZCA9IEBpbnZlcnQgPyBcIj09IC0xXCIgOiBcIj49IDBcIlxuXHRcdHZhciBpZHggPSBVdGlsLmluZGV4T2YobGVmdCxyaWdodClcblx0XHRcIntpZHguY30ge2NvbmR9XCJcblx0XG5cblxuXG5cblxuXG4jIEFDQ0VTU1xuXG5leHBvcnQgdmFyIEtfSVZBUiA9IDFcbmV4cG9ydCB2YXIgS19TWU0gPSAyXG5leHBvcnQgdmFyIEtfU1RSID0gM1xuZXhwb3J0IHZhciBLX1BST1AgPSA0XG5cbmV4cG9ydCBjbGFzcyBBY2Nlc3MgPCBPcFxuXG5cdGRlZiBpbml0aWFsaXplIG8sIGwsIHIgXG5cdFx0IyBzZXQgZXhwcmVzc2lvbiB5ZXMsIG5vP1xuXHRcdEBleHByZXNzaW9uID0gbm9cblx0XHRAdHJhdmVyc2VkID0gbm9cblx0XHRAcGFyZW5zID0gbm9cblx0XHRAY2FjaGUgPSBudWxsXG5cdFx0QGludmVydCA9IG5vXG5cdFx0QG9wID0gbyBhbmQgby5AdmFsdWUgb3Igb1xuXHRcdEBsZWZ0ID0gbFxuXHRcdEByaWdodCA9IHJcblx0XHRyZXR1cm4gc2VsZlxuXG5cdGRlZiBjbG9uZSBsZWZ0LCByaWdodFxuXHRcdHZhciBjdG9yID0gc2VsZjpjb25zdHJ1Y3RvclxuXHRcdGN0b3IubmV3KG9wLGxlZnQscmlnaHQpXG5cblx0ZGVmIGpzIG9cblx0XHR2YXIgcmF3ID0gbnVsbFxuXHRcdHZhciByZ3QgPSByaWdodFxuXHRcdHZhciBjdHggPSAobGVmdCB8fCBzY29wZV9fLmNvbnRleHQpXG5cdFx0dmFyIHByZSA9IFwiXCJcblx0XHR2YXIgbWFyayA9ICcnXG5cblx0XHQjIGlmIHNhZmVjaGFpblxuXHRcdCNcdHAgXCJBY2Nlc3MgaXMgc2FmZWNoYWluZWQge3JndC5jfVwiXG5cblxuXHRcdGlmIHJndCBpc2EgTnVtXG5cdFx0XHRyZXR1cm4gY3R4LmMgKyBcIltcIiArIHJndC5jICsgXCJdXCJcblxuXHRcdCMgaXMgdGhpcyByaWdodD8gU2hvdWxkIG5vdCB0aGUgaW5kZXggY29tcGlsZSB0aGUgYnJhY2tldHNcblx0XHQjIG9yIHZhbHVlIGlzIGEgc3ltYm9sIC0tIHNob3VsZCBiZSB0aGUgc2FtZSwgbm8/XG5cdFx0aWYgcmd0IGlzYSBJbmRleCBhbmQgKHJndC52YWx1ZSBpc2EgU3RyIG9yIHJndC52YWx1ZSBpc2EgU3ltYm9sKVxuXHRcdFx0cmd0ID0gcmd0LnZhbHVlXG5cblx0XHQjIFRPRE8gZG8gdGhlIGlkZW50aWZpZXItdmFsaWRhdGlvbiBpbiBhIGNlbnRyYWwgcGxhY2UgaW5zdGVhZFxuXHRcdGlmIHJndCBpc2EgU3RyIGFuZCByZ3QuaXNWYWxpZElkZW50aWZpZXJcblx0XHRcdHJhdyA9IHJndC5yYXdcblxuXHRcdGVsaWYgcmd0IGlzYSBTeW1ib2wgYW5kIHJndC5pc1ZhbGlkSWRlbnRpZmllclxuXHRcdFx0cmF3ID0gcmd0LnJhd1xuXG5cdFx0ZWxpZiByZ3QgaXNhIElkZW50aWZpZXIgYW5kIHJndC5pc1ZhbGlkSWRlbnRpZmllclxuXHRcdFx0bWFyayA9IG1hcmtfXyhyZ3QuQHZhbHVlKVxuXHRcdFx0cmF3ID0gcmd0LmNcblxuXHRcdGlmIHNhZmVjaGFpbiBhbmQgY3R4XG5cdFx0XHRjdHguY2FjaGUoZm9yY2U6IHllcylcblx0XHRcdHByZSA9IGN0eC5jICsgXCIgJiYgXCJcblxuXHRcdCMgcmVhbGx5P1xuXHRcdCMgdmFyIGN0eCA9IChsZWZ0IHx8IHNjb3BlX18uY29udGV4dClcblx0XHR2YXIgb3V0ID0gaWYgcmF3XG5cdFx0XHQjIHNlZSBpZiBpdCBuZWVkcyBxdW90aW5nXG5cdFx0XHQjIG5lZWQgdG8gY2hlY2sgdG8gc2VlIGlmIGl0IGlzIGxlZ2FsXG5cdFx0XHRjdHggPyBcIntjdHguY30ue21hcmt9e3Jhd31cIiA6IHJhd1xuXHRcdGVsc2Vcblx0XHRcdHZhciByID0gcmd0IGlzYSBOb2RlID8gcmd0LmMoZXhwcmVzc2lvbjogeWVzKSA6IHJndFxuXHRcdFx0XCJ7Y3R4LmN9W3tyfV1cIlxuXG5cdFx0IyBpZiBzYWZlY2hhaW4gYW5kIGN0eFxuXHRcdCMgXHRvdXQgPSBcIntjdHguY30gJiYge291dH1cIlxuXG5cdFx0cmV0dXJuIHByZSArIG91dFxuXG5cdGRlZiB2aXNpdFxuXHRcdGxlZnQudHJhdmVyc2UgaWYgbGVmdFxuXHRcdHJpZ2h0LnRyYXZlcnNlIGlmIHJpZ2h0XG5cdFx0cmV0dXJuXG5cblx0ZGVmIGlzRXhwcmVzc2FibGVcblx0XHR0cnVlXG5cblx0ZGVmIGFsaWFzXG5cdFx0cmlnaHQgaXNhIElkZW50aWZpZXIgPyByaWdodC5hbGlhcyA6IHN1cGVyKClcblxuXHRkZWYgc2FmZWNoYWluXG5cdFx0IyByaWdodC5zYWZlY2hhaW5cblx0XHRTdHJpbmcoQG9wKSA9PSAnPy4nIG9yIFN0cmluZyhAb3ApID09ICc/OidcblxuXHRkZWYgY2FjaGUgb1xuXHRcdChyaWdodCBpc2EgSXZhciAmJiAhbGVmdCkgPyBzZWxmIDogc3VwZXIobylcblx0XHRcblxuXG4jIFNob3VsZCBjaGFuZ2UgdGhpcyB0byBqdXN0IHJlZmVyIGRpcmVjdGx5IHRvIHRoZSB2YXJpYWJsZT8gT3IgVmFyUmVmZXJlbmNlXG5leHBvcnQgY2xhc3MgTG9jYWxWYXJBY2Nlc3MgPCBBY2Nlc3NcblxuXHRwcm9wIHNhZmVjaGFpblxuXG5cdGRlZiBqcyBvXG5cdFx0aWYgcmlnaHQgaXNhIFZhcmlhYmxlIGFuZCByaWdodC50eXBlID09ICdtZXRoJ1xuXHRcdFx0cmV0dXJuIFwie3JpZ2h0LmN9KClcIiB1bmxlc3MgdXAgaXNhIENhbGxcblxuXHRcdHJpZ2h0LmNcblxuXHRkZWYgdmFyaWFibGVcblx0XHRyaWdodFxuXG5cdGRlZiBjYWNoZSBvID0ge31cblx0XHRzdXBlcihvKSBpZiBvOmZvcmNlXG5cdFx0c2VsZlxuXG5cdGRlZiBhbGlhc1xuXHRcdHZhcmlhYmxlLkBhbGlhcyBvciBzdXBlcigpXG5cblxuZXhwb3J0IGNsYXNzIEdsb2JhbFZhckFjY2VzcyA8IFZhbHVlTm9kZVxuXG5cdGRlZiBqcyBvXG5cdFx0dmFsdWUuY1xuXG5cbmV4cG9ydCBjbGFzcyBPYmplY3RBY2Nlc3MgPCBBY2Nlc3NcblxuXG5leHBvcnQgY2xhc3MgUHJvcGVydHlBY2Nlc3MgPCBBY2Nlc3NcblxuXHRkZWYgaW5pdGlhbGl6ZSBvLCBsLCByIFxuXHRcdEB0cmF2ZXJzZWQgPSBub1xuXHRcdEBpbnZlcnQgPSBub1xuXHRcdEBwYXJlbnMgPSBub1xuXHRcdEBleHByZXNzaW9uID0gbm8gIyB5ZXM/XG5cdFx0QGNhY2hlID0gbnVsbFxuXHRcdEBvcCA9IG9cblx0XHRAbGVmdCA9IGxcblx0XHRAcmlnaHQgPSByXG5cdFx0cmV0dXJuIHNlbGZcblxuXHRkZWYgdmlzaXRcblx0XHRAcmlnaHQudHJhdmVyc2UgaWYgQHJpZ2h0XG5cdFx0QGxlZnQudHJhdmVyc2UgaWYgQGxlZnRcblx0XHRyZXR1cm4gc2VsZlxuXG5cdCMgcmlnaHQgaW4gYyB3ZSBzaG91bGQgcG9zc2libHkgb3ZlcnJpZGVcblx0IyB0byBjcmVhdGUgYSBjYWxsIGFuZCByZWd1bGFyIGFjY2VzcyBpbnN0ZWFkXG5cblx0ZGVmIGpzIG9cblx0XG5cdFx0aWYgdmFyIHJlYyA9IHJlY2VpdmVyXG5cdFx0XHQjIHAgXCJjb252ZXJ0aW5nIHRvIGNhbGxcIlxuXHRcdFx0dmFyIGFzdCA9IENBTEwoT1AoJy4nLGxlZnQscmlnaHQpLFtdKSAjIGNvbnZlcnQgdG8gQXJnTGlzdCBvciBudWxsXG5cdFx0XHRhc3QucmVjZWl2ZXIgPSByZWNcblx0XHRcdHJldHVybiBhc3QuY1xuXG5cdFx0dmFyIHVwID0gdXBcblxuXHRcdHVubGVzcyB1cCBpc2EgQ2FsbFxuXHRcdFx0IyBwIFwiY29udmVydCB0byBjYWxsIGluc3RlYWRcIlxuXHRcdFx0dmFyIGFzdCA9IENBTEwoQWNjZXNzLm5ldyhvcCxsZWZ0LHJpZ2h0KSxbXSlcblx0XHRcdHJldHVybiBhc3QuY1xuXG5cdFx0IyByZWFsbHkgbmVlZCB0byBmaXggdGhpcyAtIGZvciBzdXJlXG5cdFx0IyBzaG91bGQgYmUgcG9zc2libGUgZm9yIHRoZSBmdW5jdGlvbiB0byByZW1vdmUgdGhpcyB0aGlzIGluc3RlYWQ/XG5cdFx0dmFyIGpzID0gXCJ7c3VwZXIobyl9XCJcblxuXHRcdHVubGVzcyAodXAgaXNhIENhbGwgb3IgdXAgaXNhIFV0aWwuSXNGdW5jdGlvbilcblx0XHRcdCMgcCBcIkNhbGxlZFwiXG5cdFx0XHRqcyArPSBcIigpXCJcblxuXHRcdHJldHVybiBqc1xuXG5cblx0ZGVmIHJlY2VpdmVyXG5cdFx0aWYgbGVmdCBpc2EgU3VwZXJBY2Nlc3MgfHwgbGVmdCBpc2EgU3VwZXJcblx0XHRcdFNFTEZcblx0XHRlbHNlXG5cdFx0XHRudWxsXG5cblxuZXhwb3J0IGNsYXNzIEl2YXJBY2Nlc3MgPCBBY2Nlc3NcblxuXHRkZWYgY2FjaGVcblx0XHQjIFdBUk4gaG1tLCB0aGlzIGlzIG5vdCByaWdodC4uLiB3aGVuIGFjY2Vzc2luZyBvbiBhbm90aGVyIG9iamVjdCBpdCB3aWxsIG5lZWQgdG8gYmUgY2FjaGVkXG5cdFx0cmV0dXJuIHNlbGZcblxuXG5leHBvcnQgY2xhc3MgQ29uc3RBY2Nlc3MgPCBBY2Nlc3NcblxuXG5leHBvcnQgY2xhc3MgSW5kZXhBY2Nlc3MgPCBBY2Nlc3NcblxuXHRkZWYgY2FjaGUgbyA9IHt9XG5cdFx0cmV0dXJuIHN1cGVyIGlmIG86Zm9yY2Vcblx0XHRyaWdodC5jYWNoZVxuXHRcdHNlbGZcblxuXG5leHBvcnQgY2xhc3MgU3VwZXJBY2Nlc3MgPCBBY2Nlc3NcblxuXHRkZWYganMgb1xuXHRcdHZhciBtID0gby5tZXRob2Rcblx0XHR2YXIgdXAgPSBvLnBhcmVudFxuXHRcdHZhciBkZWVwID0gby5wYXJlbnQgaXNhIEFjY2Vzc1xuXG5cdFx0dmFyIG91dCA9IFwie2xlZnQuY30uX19zdXBlcl9fXCJcblxuXHRcdHVubGVzcyB1cCBpc2EgQWNjZXNzXG5cdFx0XHRvdXQgKz0gXCIue20uc3VwZXJuYW1lLmN9XCJcblx0XHRcdHVubGVzcyB1cCBpc2EgQ2FsbCAjIGF1dG9jYWxsP1xuXHRcdFx0XHRvdXQgKz0gXCIuYXBwbHkoe20uc2NvcGUuY29udGV4dC5jfSxhcmd1bWVudHMpXCJcblxuXHRcdHJldHVybiBvdXRcblxuXHRkZWYgcmVjZWl2ZXJcblx0XHRTRUxGXG5cblxuZXhwb3J0IGNsYXNzIFZhck9yQWNjZXNzIDwgVmFsdWVOb2RlXG5cblx0ZGVmIGluaXRpYWxpemUgdmFsdWVcblx0XHQjIHNob3VsZCByYXRoZXIgY2FsbCB1cCB0byB2YWx1ZW5vZGU/XG5cdFx0QHRyYXZlcnNlZCBcdD0gbm9cblx0XHRAcGFyZW5zIFx0PSBub1xuXHRcdEB2YWx1ZSBcdFx0PSB2YWx1ZVxuXHRcdEBpZGVudGlmaWVyID0gdmFsdWVcblx0XHRAdG9rZW4gXHRcdD0gdmFsdWUuQHZhbHVlXG5cdFx0QHZhcmlhYmxlID0gbnVsbFxuXHRcdHNlbGZcblxuXHQjIFNob3J0Y2lyY3VpdCB0cmF2ZXJzZSBzbyB0aGF0IGl0IGlzIG5vdCBhZGRlZCB0byB0aGUgc3RhY2s/IVxuXHRkZWYgdmlzaXRcblx0XHQjIEBpZGVudGlmaWVyID0gdmFsdWUgIyB0aGlzIGlzIG5vdCBhIHJlYWwgaWRlbnRpZmllcj9cblx0XHQjIGNvbnNvbGUubG9nIFwiVmFyT3JBY2Nlc3Mge0BpZGVudGlmaWVyfVwiXG5cdFx0IyBwIFwidmlzaXQge3NlbGZ9XCJcblxuXG5cdFx0dmFyIHNjb3BlID0gc2NvcGVfX1xuXG5cdFx0dmFyIHZhcmlhYmxlID0gc2NvcGUubG9va3VwKHZhbHVlKVxuXG5cdFx0IyBkb2VzIG5vdCByZWFsbHkgbmVlZCB0byBoYXZlIGEgZGVjbGFyYXRvciBhbHJlYWR5PyAtLSB0cmlja3lcblx0XHRpZiB2YXJpYWJsZSAmJiB2YXJpYWJsZS5kZWNsYXJhdG9yXG5cdFx0XHQjIHZhciBkZWNsID0gdmFyaWFibGUuZGVjbGFyYXRvclxuXG5cdFx0XHQjIGlmIHRoZSB2YXJpYWJsZSBpcyBub3QgaW5pdGlhbGl6ZWQganVzdCB5ZXQgYW5kIHdlIGFyZVxuXHRcdFx0IyBpbiB0aGUgc2FtZSBzY29wZSAtIHdlIHNob3VsZCBub3QgdHJlYXQgdGhpcyBhcyBhIHZhci1sb29rdXBcblx0XHRcdCMgaWUuICB2YXIgeCA9IHggd291bGQgcmVzb2x2ZSB0byB2YXIgeCA9IHRoaXMueCgpIGlmIHhcblx0XHRcdCMgd2FzIG5vdCBwcmV2aW91c2x5IGRlZmluZWRcblxuXHRcdFx0IyBzaG91bGQgZG8gdGhpcyBldmVuIGlmIHdlIGFyZSBub3QgaW4gdGhlIHNhbWUgc2NvcGU/XG5cdFx0XHQjIHdlIG9ubHkgbmVlZCB0byBiZSBpbiB0aGUgc2FtZSBjbG9zdXJlKCEpXG5cblx0XHRcdGlmIHZhcmlhYmxlLkBpbml0aWFsaXplZCBvciAoc2NvcGUuY2xvc3VyZSAhPSB2YXJpYWJsZS5zY29wZS5jbG9zdXJlKVxuXHRcdFx0XHRAdmFyaWFibGUgPSB2YXJpYWJsZVxuXHRcdFx0XHR2YXJpYWJsZS5hZGRSZWZlcmVuY2Uoc2VsZilcblx0XHRcdFx0QHZhbHVlID0gdmFyaWFibGUgIyB2YXJpYWJsZS5hY2Nlc3NvcihzZWxmKVxuXHRcdFx0XHRAdG9rZW4uQHZhcmlhYmxlID0gdmFyaWFibGVcblx0XHRcdFx0cmV0dXJuIHNlbGZcblxuXHRcdFx0IyBwIFwidmFyIGlzIG5vdCB5ZXQgaW5pdGlhbGl6ZWQhXCJcblx0XHRcdCMgcCBcImRlY2xhcmF0b3IgZm9yIHZhciB7ZGVjbC5AZGVjbGFyZWR9XCJcblx0XHRcdCMgRklYXG5cdFx0XHQjIEB2YWx1ZS5zYWZlY2hhaW4gPSBzYWZlY2hhaW5cblxuXHRcdCMgVE9ETyBkZXByZWNhdGUgYW5kIHJlbW92ZVxuXHRcdGlmIHZhbHVlLnN5bWJvbC5pbmRleE9mKCckJykgPj0gMFxuXHRcdFx0IyBiaWcgaGFjayAtIHNob3VsZCBkaXNhYmxlXG5cdFx0XHQjIG1ham9yIGhhY2sgaGVyZSwgbm8/XG5cdFx0XHQjIGNvbnNvbGUubG9nIFwiR2xvYmFsVmFyQWNjZXNzXCJcblx0XHRcdEB2YWx1ZSA9IEdsb2JhbFZhckFjY2Vzcy5uZXcodmFsdWUpXG5cdFx0XHRyZXR1cm4gc2VsZlxuXG5cdFx0IyByZWFsbHk/IHdoYXQgYWJvdXQganVzdCBtaW1pY2tpbmcgdGhlIHR3byBkaWZmcmVudCBpbnN0ZWFkP1xuXHRcdCMgU2hvdWxkIHdlIG5vdCByZXR1cm4gYSBjYWxsIGRpcmVjdGx5IGluc3RlYWQ/XG5cdFx0QHZhbHVlID0gUHJvcGVydHlBY2Nlc3MubmV3KFwiLlwiLHNjb3BlLmNvbnRleHQsdmFsdWUpXG5cdFx0IyBtYXJrIHRoZSBzY29wZSAvIGNvbnRleHQgLS0gc28gd2UgY2FuIHNob3cgY29ycmVjdCBpbXBsaWNpdFxuXHRcdEB0b2tlbi5AbWV0YSA9IHt0eXBlOiAnQUNDRVNTJ31cblx0XHQjIEB2YWx1ZS50cmF2ZXJzZSAjIG5haFxuXHRcdHNlbGZcblxuXHRkZWYgY1xuXHRcdG1hcmtfXyhAdG9rZW4pICsgKEB2YXJpYWJsZSA/IHN1cGVyKCkgOiB2YWx1ZS5jKVxuXG5cdGRlZiBqcyBvXG5cdFxuXHRcdGlmIHZhciB2ID0gQHZhcmlhYmxlXG5cdFx0XHR2YXIgb3V0ID0gdi5jXG5cdFx0XHRvdXQgKz0gXCIoKVwiIGlmIHYuQHR5cGUgPT0gJ21ldGgnIGFuZCAhKG8udXAgaXNhIENhbGwpXG5cdFx0XHRyZXR1cm4gb3V0XG5cdFx0cmV0dXJuIFwiTk9OT1wiXG5cdFx0XG5cdGRlZiBub2RlXG5cdFx0QHZhcmlhYmxlID8gc2VsZiA6IHZhbHVlXG5cblx0ZGVmIHN5bWJvbFxuXHRcdEBpZGVudGlmaWVyLnN5bWJvbFxuXHRcdCMgdmFsdWUgYW5kIHZhbHVlLnN5bWJvbFxuXG5cdGRlZiBjYWNoZSBvID0ge31cblx0XHRAdmFyaWFibGUgPyAobzpmb3JjZSBhbmQgc3VwZXIobykpIDogdmFsdWUuY2FjaGUobylcblx0XHQjIHNob3VsZCB3ZSByZWFsbHkgY2FjaGUgdGhpcz9cblx0XHQjIHZhbHVlLmNhY2hlKG8pXG5cblx0ZGVmIGRlY2FjaGVcblx0XHRAdmFyaWFibGUgPyBzdXBlcigpIDogdmFsdWUuZGVjYWNoZVxuXHRcdHNlbGZcblxuXHRkZWYgZG9tXG5cdFx0dmFsdWUuZG9tXG5cblx0ZGVmIHNhZmVjaGFpblxuXHRcdEBpZGVudGlmaWVyLnNhZmVjaGFpblxuXG5cdGRlZiBkdW1wXG5cdFx0eyBsb2M6IGxvYyB9XG5cblx0ZGVmIGxvY1xuXHRcdHZhciBsb2MgPSBAaWRlbnRpZmllci5yZWdpb25cblx0XHRyZXR1cm4gbG9jIG9yIFswLDBdXG5cblx0ZGVmIHJlZ2lvblxuXHRcdEBpZGVudGlmaWVyLnJlZ2lvblxuXG5cdGRlZiB0b1N0cmluZ1xuXHRcdFwiVmFyT3JBY2Nlc3Moe3ZhbHVlfSlcIlxuXG5cdGRlZiB0b0pTT05cblx0XHR7dHlwZTogdHlwZU5hbWUsIHZhbHVlOiBAaWRlbnRpZmllci50b1N0cmluZ31cblxuI1x0ZGVmIGpzXG4jXHRcdGlmIHJpZ2h0IGlzYSBWYXJpYWJsZSBhbmQgcmlnaHQudHlwZSA9PSAnbWV0aCdcbiNcdFx0XHRyZXR1cm4gXCJ7cmlnaHQuY30oKVwiIHVubGVzcyB1cCBpc2EgQ2FsbFxuI1xuI1x0XHRyaWdodC5jXG4jXG4jXHRkZWYgdmFyaWFibGVcbiNcdFx0cmlnaHRcbiNcbiNcdGRlZiBjYWNoZSBvID0ge31cbiNcdFx0c3VwZXIgaWYgbzpmb3JjZVxuI1x0XHRzZWxmXG4jXG4jXHRkZWYgYWxpYXNcbiNcdFx0dmFyaWFibGUuQGFsaWFzIG9yIHN1cGVyICMgaWYgcmVzb2x2ZWQ/XG4jXG5cbmV4cG9ydCBjbGFzcyBWYXJSZWZlcmVuY2UgPCBWYWx1ZU5vZGVcblxuXHQjIFRPRE8gVmFyQmxvY2sgc2hvdWxkIGNvbnZlcnQgdGhlc2UgdG8gcGxhaW4gLyBkdW1iIG5vZGVzXG5cblx0cHJvcCB2YXJpYWJsZVxuXHRwcm9wIGRlY2xhcmVkXG5cdHByb3AgdHlwZVxuXG5cdGRlZiBpbml0aWFsaXplIHZhbHVlLCB0eXBlXG5cdFx0aWYgdmFsdWUgaXNhIFZhck9yQWNjZXNzXG5cdFx0XHR2YWx1ZSA9IHZhbHVlLnZhbHVlXG5cdFx0IyBmb3Igbm93IC0gdGhpcyBjYW4gaGFwcGVuXG5cdFx0c3VwZXIodmFsdWUpXG5cdFx0QGV4cG9ydCA9IG5vXG5cdFx0QHR5cGUgPSB0eXBlIGFuZCBTdHJpbmcodHlwZSlcblx0XHRAdmFyaWFibGUgPSBudWxsXG5cdFx0QGRlY2xhcmVkID0geWVzICMganVzdCB0ZXN0aW5nIG5vd1xuXG5cblx0ZGVmIGxvY1xuXHRcdCMgcCBcImxvYyBmb3IgVmFyUmVmZXJlbmNlIHtAdmFsdWU6Y29uc3RydWN0b3J9IHtAdmFsdWUuQHZhbHVlOmNvbnN0cnVjdG9yfSB7QHZhbHVlLnJlZ2lvbn1cIlxuXHRcdEB2YWx1ZS5yZWdpb25cblxuXHRkZWYgc2V0IG9cblx0XHQjIGhhY2sgLSB3b3JrYXJvdW5kIGZvciBoaWRkZW4gY2xhc3NlcyBwZXJmXG5cdFx0QGV4cG9ydCA9IHllcyBpZiBvOmV4cG9ydFxuXHRcdHJldHVybiBzZWxmXG5cblx0ZGVmIGpzIG9cblx0XHQjIGV4cGVyaW1lbnRhbCBmaXhcblx0XHRcblx0XHQjIHdoYXQgYWJvdXQgcmVzb2x2aW5nP1xuXHRcdHZhciByZWYgPSBAdmFyaWFibGVcblx0XHR2YXIgb3V0ID0gXCJ7bWFya19fKEB2YWx1ZSl9e3JlZi5jfVwiXG5cblx0XHQjIHAgXCJWYXJSZWZlcmVuY2Uge291dH0gLSB7by51cH0ge28udXAgPT0gc2VsZn1cXG57b31cIlxuXG5cdFx0aWYgcmVmICYmICFyZWYuQGRlY2xhcmVkICMgLm9wdGlvbig6ZGVjbGFyZWQpXG5cdFx0XHRpZiBvLnVwKFZhckJsb2NrKSAjIHVwIHZhcmJsb2NrPz9cblx0XHRcdFx0cmVmLkBkZWNsYXJlZCA9IHllc1xuXG5cdFx0XHRcdCMgcmVmLnNldChkZWNsYXJlZDogeWVzKVxuXHRcdFx0ZWxpZiBvLmlzRXhwcmVzc2lvbiBvciBAZXhwb3J0ICMgd2h5P1xuXHRcdFx0XHQjIHAgXCJhdXRvZGVjbGFyZVwiXG5cdFx0XHRcdHJlZi5hdXRvZGVjbGFyZVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRvdXQgPSBcInZhciB7b3V0fVwiXG5cdFx0XHRcdHJlZi5AZGVjbGFyZWQgPSB5ZXNcblx0XHRcdFx0IyByZWYuc2V0KGRlY2xhcmVkOiB5ZXMpXG5cblx0XHQjIG5lZWQgdG8gdGhpbmsgdGhlIGV4cG9ydCB0aHJvdWdoIC0tIGxpa2UgcmVnaXN0ZXJpbmcgc29tZWhvd1xuXHRcdCMgc2hvdWxkIHJlZ2lzdGVyIGluIHNjb3BlIC0gZXhwb3J0IG9uIGFuYWx5c2lzKytcblx0XHRpZiBAZXhwb3J0XG5cdFx0XHRvdXQgPSBcIm1vZHVsZS5leHBvcnRzLntyZWYuY30gPSB7cmVmLmN9XCJcblxuXHRcdHJldHVybiBvdXRcblxuXHRkZWYgZGVjbGFyZVxuXHRcdHNlbGZcblxuXHRkZWYgY29uc3VtZSBub2RlXG5cdFx0IyByZWFsbHk/IHRoZSBjb25zdW1lZCBub2RlIGRpc3NhcHBlYXI/XG5cdFx0QHZhcmlhYmxlICYmIEB2YXJpYWJsZS5hdXRvZGVjbGFyZVxuXHRcdHNlbGZcblxuXHRkZWYgdmlzaXRcblx0XHRcblx0XHQjIGNvbnNvbGUubG9nIFwidmFsdWUgdHlwZSBmb3IgVmFyUmVmZXJlbmNlIHtAdmFsdWV9IHtAdmFsdWUuQGxvY30ge0B2YWx1ZTpjb25zdHJ1Y3Rvcn1cIlxuXG5cdFx0IyBzaG91bGQgYmUgcG9zc2libGUgdG8gaGF2ZSBhIFZhclJlZmVyZW5jZSB3aXRob3V0IGEgbmFtZSBhcyB3ZWxsPyBmb3IgYSBzeXN0ZW0tdmFyaWFibGVcblx0XHQjIG5hbWUgc2hvdWxkIG5vdCBzZXQgdGhpcyB3YXkuXG5cdFx0IyBwIFwidmFybmFtZSB7dmFsdWV9IHt2YWx1ZTpjb25zdHJ1Y3Rvcn1cIlxuXHRcdHZhciBuYW1lID0gdmFsdWUuY1xuXHRcdCMgcCBcInZpc2l0IHZhcmRlY2wge25hbWV9IHt2YWx1ZX1cIlxuXG5cdFx0IyB3aGF0IGFib3V0IGxvb2tpbmcgdXA/IC0gb24gcmVnaXN0ZXIgd2Ugd2FudCB0byBtYXJrXG5cdFx0dmFyIHYgPSBAdmFyaWFibGUgfHw9IHNjb3BlX18ucmVnaXN0ZXIobmFtZSwgc2VsZiwgdHlwZTogQHR5cGUpXG5cdFx0IyBGSVhNRSAtLSBzaG91bGQgbm90IHNpbXBseSBvdmVycmlkZSB0aGUgZGVjbGFyYXRvciBoZXJlKCEpXG5cblx0XHRpZiAhdi5kZWNsYXJhdG9yXG5cdFx0XHR2LmRlY2xhcmF0b3IgPSBzZWxmXG5cblx0XHR2LmFkZFJlZmVyZW5jZShAdmFsdWUpIGlmIEB2YWx1ZSAjIGlzIHRoaXMgdGhlIGZpcnN0IHJlZmVyZW5jZT9cblxuXHRcdCMgb25seSBuZWVkZWQgd2hlbiBhbmFseXppbmc/XG5cdFx0QHZhbHVlLkB2YWx1ZS5AdmFyaWFibGUgPSB2XG5cdFx0c2VsZlxuXG5cdGRlZiByZWZuclxuXHRcdHZhcmlhYmxlLnJlZmVyZW5jZXMuaW5kZXhPZih2YWx1ZSlcblxuXHQjIGNvbnZlcnQgdGhpcyBpbnRvIGEgbGlzdCBvZiByZWZlcmVuY2VzXG5cdGRlZiBhZGRFeHByZXNzaW9uIGV4cHJcblxuXHRcdFZhckJsb2NrLm5ldyhbc2VsZl0pLmFkZEV4cHJlc3Npb24oZXhwcilcblxuXG4jIEFTU0lHTlxuXG5leHBvcnQgY2xhc3MgQXNzaWduIDwgT3BcblxuXHRkZWYgaW5pdGlhbGl6ZSBvLCBsLCByXG5cblx0XHQjIHdvcmthcm91bmQgdW50aWwgd2UgY29tcGxldGUgdHJhbnNpdGlvbiBmcm9tIGx1YS1zdHlsZSBhc3NpZ25tZW50c1xuXHRcdCMgdG8gYWx3YXlzIHVzZSBleHBsaWNpdCB0dXBsZXMgLSB0aGVuIHdlIGNhbiBtb3ZlIGFzc2lnbm1lbnRzIG91dCBldGNcblx0XHQjIHRoaXMgd2lsbCBub3QgYmUgbmVlZGVkIGFmdGVyIHdlIHJlbW92ZSBzdXBwb3J0IGZvciB2YXIgYSxiLGMgPSAxLDIsM1xuXHRcdGlmIGwgaXNhIFZhclJlZmVyZW5jZSBhbmQgbC52YWx1ZSBpc2EgQXJyXG5cdFx0XHQjIGNvbnZlcnRpbmcgYWxsIG5vZGVzIHRvIHZhci1yZWZlcmVuY2VzID9cblx0XHRcdCMgZG8gd2UgbmVlZCB0byBrZWVwIGl0IGluIGEgdmFyYmxvY2sgYXQgYWxsP1xuXHRcdFx0dmFyIHZhcnMgPSBsLnZhbHVlLm5vZGVzLm1hcCBkbyB8dnxcblx0XHRcdFx0IyB3aGF0IGFib3V0IGlubmVyIHR1cGxlcyBldGM/XG5cdFx0XHRcdCMga2VlcCB0aGUgc3BsYXRzIC0tIGNsdW1zeSBidXQgdHJ1ZVxuXHRcdFx0XHRpZiB2IGlzYSBTcGxhdFxuXHRcdFx0XHRcdCMgcCBcInZhbHVlIGlzIGEgc3BsYXQhIVwiXG5cdFx0XHRcdFx0di52YWx1ZSA9IFZhclJlZmVyZW5jZS5uZXcodi52YWx1ZSxsLnR5cGUpIHVubGVzcyB2LnZhbHVlIGlzYSBWYXJSZWZlcmVuY2Vcblx0XHRcdFx0ZWxpZiB2IGlzYSBWYXJSZWZlcmVuY2Vcblx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHQjIHdoYXQgYWJvdXQgcmV0YWluaW5nIGxvY2F0aW9uP1xuXHRcdFx0XHRcdCMgdiA9IHYudmFsdWUgaWYgdiBpc2EgVmFyT3JBY2Nlc3Ncblx0XHRcdFx0XHR2ID0gVmFyUmVmZXJlbmNlLm5ldyh2LGwudHlwZSlcblxuXHRcdFx0XHRyZXR1cm4gdlxuXHRcdFx0XHRcblx0XHRcdFx0IyB2IGlzYSBWYXJSZWZlcmVuY2UgPyB2IDogVmFyUmVmZXJlbmNlLm5ldyh2KVxuXHRcdFx0cmV0dXJuIFR1cGxlQXNzaWduLm5ldyhvLFR1cGxlLm5ldyh2YXJzKSxyKVxuXG5cdFx0aWYgbCBpc2EgQXJyXG5cdFx0XHRyZXR1cm4gVHVwbGVBc3NpZ24ubmV3KG8sVHVwbGUubmV3KGwubm9kZXMpLHIpXG5cdFx0XHQjIHAgXCJsZWZ0IGlzIGFycmF5IGluIGFzc2lnbiAtIGluIGluaXRcIlxuXG5cblx0XHQjIHNldCBleHByZXNzaW9uIHllcywgbm8/XG5cdFx0QGV4cHJlc3Npb24gPSBub1xuXHRcdEB0cmF2ZXJzZWQgPSBub1xuXHRcdEBwYXJlbnMgPSBub1xuXHRcdEBjYWNoZSA9IG51bGxcblx0XHRAaW52ZXJ0ID0gbm9cblx0XHRAb3BUb2tlbiA9IG9cblx0XHRAb3AgPSBvIGFuZCBvLkB2YWx1ZSBvciBvXG5cdFx0QGxlZnQgPSBsXG5cdFx0QHJpZ2h0ID0gclxuXHRcdHJldHVybiBzZWxmXG5cblx0ZGVmIGlzRXhwcmVzc2FibGVcblx0XHQhcmlnaHQgfHwgcmlnaHQuaXNFeHByZXNzYWJsZVxuXG5cdGRlZiBpc1VzZWRcblx0XHQjIHJlYWxseT9cblx0XHQjIGlmIHVwIGlzIGEgYmxvY2sgaW4gZ2VuZXJhbCB0aGlzIHNob3VsZCBub3QgYmUgdXNlZCAtLSBzaW5jZSBpdCBzaG91bGQgYWxyZWFkeSBoYXZlIHJlY2VpdmVkIGltcGxpY2l0IHNlbGY/XG5cdFx0aWYgdXAgaXNhIEJsb2NrICMgJiYgdXAubGFzdCAhPSBzZWxmXG5cdFx0XHRyZXR1cm4gbm8gXG5cdFx0cmV0dXJuIHllc1xuXG5cdCMgRklYTUUgb3B0aW1pemVcblx0ZGVmIHZpc2l0XG5cdFx0dmFyIGwgPSBAbGVmdFxuXHRcdHZhciByID0gQHJpZ2h0XG5cblx0XHQjIFdBUk5JTkcgLSBzbGlnaHRseSB1bmRlZmluZWRcblx0XHQjIE1BUksgVEhFIFNUQUNLXG5cdFx0bC50cmF2ZXJzZSBpZiBsXG5cblx0XHR2YXIgbHZhciA9IGwgaXNhIFZhclJlZmVyZW5jZSBhbmQgbC52YXJpYWJsZVxuXG5cdFx0IyBob3cgZG9lcyB0aGlzIHdvcmsgd2l0aCBjb25zdGFudHMgdGhhdCBhcmUgcmVhbGx5IHZhciByZWZlcmVuY2VzP1xuXHRcdCMgc2hvdWxkIHdvcmsgd2hlbiB0aGluZ3MgYXJlIG5vdCBkZXNjcmliZWQgYXMgd2VsbCAtIGJ1dCB0aGlzIGlzIGZvciB0ZXN0aW5nXG5cdFx0IyBidXQgaWYgaXQgcmVmZXJzIHRvIHNvbWV0aGluZyBlbHNlIFxuXHRcdGlmICFsdmFyIGFuZCBAZGVzY1xuXHRcdFx0IyBlbnRpdGllcyBzaG91bGQgYmUgYWJsZSB0byBleHRyYWN0IHRoZSBuZWVkZWQgaW5mbyBpbnN0ZWFkXG5cdFx0XHRST09ULmVudGl0aWVzLmFkZChsLm5hbWVwYXRoLHtuYW1lcGF0aDogbC5uYW1lcGF0aCwgdHlwZTogci50eXBlTmFtZSwgZGVzYzogQGRlc2N9KVxuXG5cdFx0IyB0aGlzIHNob3VsZCBwcm9iYWJseSBiZSBkb25lIGluIGEgZGlmZmVyZW50IG1hbm5lclxuXHRcdGlmIGx2YXIgYW5kIGx2YXIuZGVjbGFyYXRvciA9PSBsXG5cdFx0XHRsdmFyLkBpbml0aWFsaXplZCA9IG5vXG5cdFx0XHRyLnRyYXZlcnNlIGlmIHJcblx0XHRcdGx2YXIuQGluaXRpYWxpemVkID0geWVzXG5cblx0XHRlbHNlXG5cdFx0XHRyLnRyYXZlcnNlIGlmIHJcblxuXHRcdGlmIGwgaXNhIFZhclJlZmVyZW5jZSBvciBsLkB2YXJpYWJsZVxuXHRcdFx0bC5AdmFyaWFibGUuYXNzaWduZWQocixzZWxmKVxuXG5cdFx0cmV0dXJuIHNlbGZcblx0XG5cdGRlZiBjIG9cblx0XHR1bmxlc3MgcmlnaHQuaXNFeHByZXNzYWJsZVxuXHRcdFx0IyBwIFwiQXNzaWduI2MgcmlnaHQgaXMgbm90IGV4cHJlc3NhYmxlIFwiXG5cdFx0XHRyZXR1cm4gcmlnaHQuY29uc3VtZShzZWxmKS5jKG8pXG5cdFx0IyB0ZXN0aW5nIHRoaXNcblx0XHRyZXR1cm4gc3VwZXIobylcblxuXHRkZWYganMgb1xuXHRcdHVubGVzcyByaWdodC5pc0V4cHJlc3NhYmxlXG5cdFx0XHRwIFwiQXNzaWduI2pzIHJpZ2h0IGlzIG5vdCBleHByZXNzYWJsZSBcIlxuXHRcdFx0IyBoZXJlIHRoaXMgc2hvdWxkIGJlIGdvIG91dCBvZiB0aGUgc3RhY2soISlcblx0XHRcdCMgaXQgc2hvdWxkIGFscmVhZHkgYmUgY29uc3VtZWQ/XG5cdFx0XHRyZXR1cm4gcmlnaHQuY29uc3VtZShzZWxmKS5jXG5cblx0XHQjIHAgXCJhc3NpZ24gbGVmdCB7bGVmdDpjb250cnN0cnV9XCJcblx0XHR2YXIgbCA9IGxlZnQubm9kZVxuXHRcdHZhciByID0gcmlnaHRcblxuXHRcdCMgV2UgYXJlIHNldHRpbmcgc2VsZighKVxuXHRcdCMgVE9ETyBkb2N1bWVudCBmdW5jdGlvbmFsaXR5XG5cdFx0aWYgbCBpc2EgU2VsZlxuXHRcdFx0dmFyIGN0eCA9IHNjb3BlX18uY29udGV4dFxuXHRcdFx0bCA9IGN0eC5yZWZlcmVuY2VcblxuXG5cdFx0aWYgbCBpc2EgUHJvcGVydHlBY2Nlc3Ncblx0XHRcdHZhciBhc3QgPSBDQUxMKE9QKCcuJyxsLmxlZnQsbC5yaWdodC5zZXR0ZXIpLFtyaWdodF0pXG5cdFx0XHRhc3QucmVjZWl2ZXIgPSBsLnJlY2VpdmVyXG5cblx0XHRcdGlmIGlzVXNlZFxuXHRcdFx0XHQjIHAgXCJBc3NpZ24gaXMgdXNlZCB7c3RhY2t9XCJcblx0XHRcdFx0IyBkb250IGNhY2hlIGl0IGFnYWluIGlmIGl0IGlzIGFscmVhZHkgY2FjaGVkKCEpXG5cdFx0XHRcdHJpZ2h0LmNhY2hlKHBvb2w6ICd2YWwnLCB1c2VzOiAxKSB1bmxlc3MgcmlnaHQuY2FjaGV2YXIgIyBcblx0XHRcdFx0IyB0aGlzIGlzIG9ubHkgd2hlbiB1c2VkLi4gc2hvdWxkIGJlIG1vcmUgY2xldmVyIGFib3V0IGl0XG5cdFx0XHRcdGFzdCA9IFBhcmVucy5uZXcoYmxrX18oW2FzdCxyaWdodF0pKVxuXG5cdFx0XHQjIHNob3VsZCBjaGVjayB0aGUgdXAtdmFsdWUgbm8/XG5cdFx0XHRyZXR1cm4gYXN0LmMoZXhwcmVzc2lvbjogeWVzKVxuXG5cdFx0IyBpZiBsIGlzYSBWYXJSZWZlcmVuY2Vcblx0XHQjIFx0cCBcImFzc2lnbiB2YXItcmVmXCJcblx0XHQjIFx0bC5AdmFyaWFibGUuYXNzaWduZWQocilcblxuXHRcdCMgRklYTUUgLS0gZG9lcyBub3QgYWx3YXlzIG5lZWQgdG8gYmUgYW4gZXhwcmVzc2lvbj9cblx0XHQjIHAgXCJ0eXBlb2Ygb3Age0BvcFRva2VuIGFuZCBAb3BUb2tlbjpjb25zdHJ1Y3Rvcn1cIlxuXHRcdHZhciBvdXQgPSBcIntsLmN9IHttYXJrX18oQG9wVG9rZW4pfXtvcH0ge3JpZ2h0LmMoZXhwcmVzc2lvbjogdHJ1ZSl9XCJcblxuXHRcdHJldHVybiBvdXRcblxuXHQjIEZJWE1FIG9wIGlzIGEgdG9rZW4/IF9GSVhfXG5cdCMgdGhpcyAoYW5kIHNpbWlsYXIgY2FzZXMpIGlzIGJyb2tlbiB3aGVuIGNhbGxlZCBmcm9tXG5cdCMgYW5vdGhlciBwb3NpdGlvbiBpbiB0aGUgc3RhY2ssIHNpbmNlICd1cCcgaXMgZHluYW1pY1xuXHQjIHNob3VsZCBtYXliZSBmcmVlemUgdXA/XG5cdGRlZiBzaG91bGRQYXJlbnRoZXNpemUgcGFyID0gdXBcblx0XHRAcGFyZW5zIG9yIHBhciBpc2EgT3AgJiYgcGFyLm9wICE9ICc9J1xuXG5cdGRlZiBjb25zdW1lIG5vZGVcblx0XHRpZiBpc0V4cHJlc3NhYmxlXG5cdFx0XHRmb3JjZUV4cHJlc3Npb25cblx0XHRcdHJldHVybiBzdXBlcihub2RlKVxuXG5cdFx0dmFyIGFzdCA9IHJpZ2h0LmNvbnN1bWUoc2VsZilcblx0XHRyZXR1cm4gYXN0LmNvbnN1bWUobm9kZSlcblxuXHQjIG1vcmUgd29ya2Fyb3VuZCBkdXJpbmcgdHJhbnNpdGlvbiBhd2F5IGZyb20gYSxiLGMgPSAxLDIsMyBzdHlsZSBhc3NpZ25cblx0ZGVmIGFkZEV4cHJlc3Npb24gZXhwclxuXHRcdHZhciB0eXAgPSBFeHByZXNzaW9uQmxvY2tcblx0XHRpZiBAbGVmdCBhbmQgQGxlZnQgaXNhIFZhclJlZmVyZW5jZVxuXHRcdFx0dHlwID0gVmFyQmxvY2tcblx0XHQjIG1pZ2h0IGJlIGJldHRlciB0byBuZXN0IHRoaXMgdXAgYWZ0ZXIgcGFyc2luZyBpcyBkb25lP1xuXHRcdCMgcCBcIkFzc2lnbi5hZGRFeHByZXNzaW9uIHtzZWxmfSA8LSB7ZXhwcn1cIlxuXHRcdHZhciBub2RlID0gdHlwLm5ldyhbc2VsZl0pXG5cdFx0cmV0dXJuIG5vZGUuYWRkRXhwcmVzc2lvbihleHByKVxuXG5cbmV4cG9ydCBjbGFzcyBQdXNoQXNzaWduIDwgQXNzaWduXG5cblx0ZGVmIGpzIG9cblx0XHRcIntsZWZ0LmN9LnB1c2goe3JpZ2h0LmN9KVwiXG5cblx0ZGVmIGNvbnN1bWUgbm9kZVxuXHRcdHJldHVybiBzZWxmXG5cblxuZXhwb3J0IGNsYXNzIENvbmRpdGlvbmFsQXNzaWduIDwgQXNzaWduXG5cblx0ZGVmIGNvbnN1bWUgbm9kZVxuXHRcdG5vcm1hbGl6ZS5jb25zdW1lKG5vZGUpXG5cblx0ZGVmIG5vcm1hbGl6ZVxuXHRcdHZhciBsID0gbGVmdC5ub2RlXG5cdFx0dmFyIGxzID0gbFxuXG5cdFx0aWYgbCBpc2EgQWNjZXNzXG5cdFx0XHQjIHAgXCJjb25kaXRpb25hbC1hc3NpZ24ge2x9IHtsLmxlZnR9IHtsLnJpZ2h0fVwiXG5cdFx0XHRpZiBsLmxlZnRcblx0XHRcdFx0IyBwIFwiY2FjaGUgbC5sZWZ0IHtsLmxlZnQ6Y29uc3RydWN0b3J9zItcIlxuXHRcdFx0XHRsLmxlZnQuY2FjaGUgXG5cdFx0XHRscyA9IGwuY2xvbmUobC5sZWZ0LGwucmlnaHQpICMgdGhpcyBzaG91bGQgc3RpbGwgYmUgY2FjaGVkP1xuXHRcdFx0bC5jYWNoZSBpZiBsIGlzYSBQcm9wZXJ0eUFjY2VzcyAjIGNvcnJlY3Qgbm93LCB0byBhIGNlcnRhaW4gZGVncmVlXG5cdFx0XHRpZiBsIGlzYSBJbmRleEFjY2Vzc1xuXHRcdFx0XHQjIHAgXCJjYWNoZSB0aGUgcmlnaHQgc2lkZSBvZiBpbmRleEFjY2VzcyEhISB7bC5yaWdodH1cIlxuXHRcdFx0XHRsLnJpZ2h0LmNhY2hlIFxuXG5cdFx0XHQjIHdlIHNob3VsZCBvbmx5IGNhY2hlIHRoZSB2YWx1ZSBpdHNlbGYgaWYgaXQgaXMgZHluYW1pYz9cblx0XHRcdCMgbC5jYWNoZSAjIGNhY2hlIHRoZSB2YWx1ZSBhcyB3ZWxsIC0tIHdlIGNhbm5vdCB1c2UgdGhpcyBpbiBhc3NpZ25zIHRoZW1cblxuXHRcdCMgc29tZSBvcHMgYXJlIGxlc3MgbWVzc3lcblx0XHQjIG5lZWQgb3AgdG8gc3VwcG9ydCBjb25zdW1lIHRoZW4/XG5cdFx0dmFyIGV4cHIgPSByaWdodC5pc0V4cHJlc3NhYmxlXG5cdFx0dmFyIGFzdCA9IG51bGxcblx0XHQjIGhlcmUgd2Ugc2hvdWxkIHVzZSBhc3QgPSBpZiAuLi5cblx0XHRpZiBleHByICYmIG9wID09ICd8fD0nXG5cdFx0XHRhc3QgPSBPUCgnfHwnLGwsIE9QKCc9JyxscyxyaWdodCkpXG5cdFx0ZWxpZiBleHByICYmIG9wID09ICcmJj0nXG5cdFx0XHRhc3QgPSBPUCgnJiYnLGwsIE9QKCc9JyxscyxyaWdodCkpXG5cdFx0ZWxzZVxuXHRcdFx0YXN0ID0gSUYoY29uZGl0aW9uLCBPUCgnPScsbHMscmlnaHQpLCBsKSAjIGRvIHdlIG5lZWQgYSBzY29wZSBmb3IgdGhlc2U/XG5cdFx0XHRhc3Quc2NvcGUgPSBudWxsXG5cdFx0XHQjIGRyb3AgdGhlIHNjb3BlXG5cdFx0XHQjIHRvdWNoIHNjb3BlIC0tIHNob3VsZCBwcm9iYWJseSB2aXNpdCB0aGUgd2hvbGUgdGhpbmc/XG5cdFx0XHQjIGFzdC5zY29wZS52aXNpdFxuXHRcdGFzdC50b0V4cHJlc3Npb24gaWYgYXN0LmlzRXhwcmVzc2FibGVcblx0XHRhc3RcblxuXG5cdGRlZiBjXG5cdFx0IyBXQVJOIHdoYXQgaWYgd2UgcmV0dXJuIHRoZSBzYW1lP1xuXHRcdG5vcm1hbGl6ZS5jXG5cblx0ZGVmIGNvbmRpdGlvblxuXG5cdFx0IyB1c2Ugc3dpdGNoIGluc3RlYWQgdG8gY2FjaGUgb3AgYWNjZXNzXG5cdFx0aWYgb3AgPT0gJz89J1xuXHRcdFx0T1AoJz09JyxsZWZ0LE5VTEwpXG5cdFx0ZWxpZiBvcCA9PSAnfHw9J1xuXHRcdFx0T1AoJyEnLGxlZnQpXG5cdFx0ZWxpZiBvcCA9PSAnJiY9J1xuXHRcdFx0bGVmdFxuXHRcdGVsaWYgb3AgPT0gJyE/PSdcblx0XHRcdE9QKCchPScsbGVmdCxOVUxMKVxuXHRcdGVsc2Vcblx0XHRcdGxlZnRcblx0XHRcblx0ZGVmIGpzIG9cblx0XHQjIHAgXCJDb25kaXRpb25hbEFzc2lnbi5qc1wiLnJlZFxuXHRcdHZhciBhc3QgPSBJRihjb25kaXRpb24sIE9QKCc9JyxsZWZ0LHJpZ2h0KSwgbGVmdClcblx0XHRhc3Quc2NvcGUgPSBudWxsICMgbm90IHN1cmUgYWJvdXQgdGhpc1xuXHRcdGFzdC50b0V4cHJlc3Npb24gaWYgYXN0LmlzRXhwcmVzc2FibGUgIyBmb3JjZWQgZXhwcmVzc2lvbiBhbHJlYWR5XG5cdFx0cmV0dXJuIGFzdC5jXG5cbmV4cG9ydCBjbGFzcyBDb21wb3VuZEFzc2lnbiA8IEFzc2lnblxuXG5cdCMgRklYTUUgY2FuIHdlIG1lcmdlIGNvbnN1bWUgYW5kIGpzP1xuXHRkZWYgY29uc3VtZSBub2RlXG5cdFx0cmV0dXJuIHN1cGVyIGlmIGlzRXhwcmVzc2FibGVcblxuXHRcdHZhciBhc3QgPSBub3JtYWxpemVcblx0XHRyZXR1cm4gYXN0LmNvbnN1bWUobm9kZSkgdW5sZXNzIGFzdCA9PSBzZWxmXG5cblx0XHRhc3QgPSByaWdodC5jb25zdW1lKHNlbGYpXG5cdFx0cmV0dXJuIGFzdC5jb25zdW1lKG5vZGUpXG5cblx0ZGVmIG5vcm1hbGl6ZVxuXHRcdHZhciBsbiA9IGxlZnQubm9kZVxuXHRcdCMgd2UgZG9udCBuZWVkIHRvIGNoYW5nZSB0aGlzIGF0IGFsbFxuXHRcdHVubGVzcyBsbiBpc2EgUHJvcGVydHlBY2Nlc3Ncblx0XHRcdHJldHVybiBzZWxmXG5cblx0XHRpZiBsbiBpc2EgQWNjZXNzXG5cdFx0XHQjIGxlZnQgbWlnaHQgYmUgemVybz8hPyFcblx0XHRcdGxuLmxlZnQuY2FjaGUgaWYgbG4ubGVmdFxuXHRcdCMgVE9ETyBGSVhNRSB3ZSB3YW50IHRvIGNhY2hlIHRoZSBjb250ZXh0IG9mIHRoZSBhc3NpZ25tZW50XG5cdFx0IyBwIFwibm9ybWFsaXplIGNvbXBvdW5kIGFzc2lnbiB7bGVmdH1cIlxuXHRcdHZhciBhc3QgPSBPUCgnPScsbGVmdCxPUChvcFswXSxsZWZ0LHJpZ2h0KSlcblx0XHRhc3QudG9FeHByZXNzaW9uIGlmIGFzdC5pc0V4cHJlc3NhYmxlXG5cblx0XHRyZXR1cm4gYXN0XG5cdFx0XG5cdGRlZiBjXG5cdFx0dmFyIGFzdCA9IG5vcm1hbGl6ZVxuXHRcdHJldHVybiBzdXBlciBpZiBhc3QgPT0gc2VsZlxuXG5cdFx0IyBvdGhlcndpc2UgaXQgaXMgaW1wb3J0YW50IHRoYXQgd2UgYWN0dWFsbHkgcmVwbGFjZSB0aGlzIG5vZGUgaW4gdGhlIG91dGVyIGJsb2NrXG5cdFx0IyB3aGVuZXZlciB3ZSBub3JtYWxpemUgYW5kIG92ZXJyaWRlIGMgaXQgaXMgaW1wb3J0YW50IHRoYXQgd2UgY2FuIHBhc3Mgb24gY2FjaGluZ1xuXHRcdCMgZXRjIC0tIG90aGVyd2lzZSB0aGVyZSBXSUxMIGJlIGlzc3Vlcy5cblx0XHR2YXIgdXAgPSBTVEFDSy5jdXJyZW50XG5cdFx0aWYgdXAgaXNhIEJsb2NrXG5cdFx0XHQjIHAgXCJwYXJlbnQgaXMgYmxvY2ssIHNob3VsZCByZXBsYWNlIVwiXG5cdFx0XHQjIGFuIGFsdGVybmF0aXZlIHdvdWxkIGJlIHRvIGp1c3QgcGFzc1xuXHRcdFx0dXAucmVwbGFjZShzZWxmLGFzdClcblx0XHRhc3QuY1xuXG5cbmV4cG9ydCBjbGFzcyBBc3luY0Fzc2lnbiA8IEFzc2lnblxuXG5cdCMgdGhpcyB3aWxsIHRyYW5zZm9ybSB0aGUgdHJlZSBieSBhIGRlY2VudCBhbW91bnQuXG5cdCMgTmVlZCB0byBhZGp1c3QgQmxvY2sgdG8gYWxsb3cgdGhpc1xuXG5cbmV4cG9ydCBjbGFzcyBUdXBsZUFzc2lnbiA8IEFzc2lnblxuXG5cdHByb3Agb3Bcblx0cHJvcCBsZWZ0XG5cdHByb3AgcmlnaHRcblx0cHJvcCB0eXBlXG5cblx0ZGVmIGluaXRpYWxpemUgYSxiLGNcblx0XHRAdHJhdmVyc2VkID0gbm9cblx0XHRAb3AgPSBhXG5cdFx0QGxlZnQgPSBiXG5cdFx0QHJpZ2h0ID0gY1xuXHRcdEB0ZW1wb3JhcnkgPSBbXVxuXG5cdGRlZiBpc0V4cHJlc3NhYmxlXG5cdFx0cmlnaHQuaXNFeHByZXNzYWJsZVxuXG5cdGRlZiBhZGRFeHByZXNzaW9uIGV4cHJcblx0XHRpZiByaWdodCBpc2EgVHVwbGVcblx0XHRcdHJpZ2h0LnB1c2goZXhwcilcblx0XHRlbHNlXG5cdFx0XHQjIHAgXCJtYWtpbmcgY2hpbGQgYmVjb21lIGEgdHVwbGU/XCJcblx0XHRcdHNlbGYucmlnaHQgPSBUdXBsZS5uZXcoW3JpZ2h0LGV4cHJdKVxuXHRcdFxuXHRcdHJldHVybiBzZWxmXG5cblx0ZGVmIHZpc2l0XG5cdFx0IyBpZiB0aGUgZmlyc3QgbGVmdC12YWx1ZSBpcyBhIHZhci1yZWZlcmVuY2UsIHRoZW5cblx0XHQjIGFsbCB0aGUgdmFyaWFibGVzIHNob3VsZCBiZSBkZWNsYXJlZCBhcyB2YXJpYWJsZXMuXG5cdFx0IyBidXQgaWYgd2UgaGF2ZSBjb21wbGV4IGl0ZW1zIGluIHRoZSBvdGhlciBsaXN0IC0gaXQgZG9lcyBiZWNvbWUgbXVjaCBoYXJkZXJcblxuXHRcdCMgaWYgdGhlIGZpcnN0IGlzIGEgdmFyLXJlZmVyZW5jZSwgdGhleSBzaG91bGQgYWxsIGJlKCEpIC4uIG9yIHNwbGF0cz9cblx0XHQjIHRoaXMgaXMgcmVhbGx5IGEgaGFja3kgd2FvIHRvIGRvIGl0IHRob3VnaFxuXHRcdGlmIGxlZnQuZmlyc3Qubm9kZSBpc2EgVmFyUmVmZXJlbmNlXG5cdFx0XHRzZWxmLnR5cGUgPSAndmFyJ1xuXHRcdFx0IyBzaG91bGQgcG9zc2libHkgYWxsb3cgcmVhbCB2YXJzIGFzIHdlbGwsIG5vP1xuXHRcdFx0QHZhcnMgPSBsZWZ0Lm5vZGVzLmZpbHRlcih8bnwgbiBpc2EgVmFyUmVmZXJlbmNlKVxuXHRcdFx0IyBjb2xsZWN0IHRoZSB2YXJzIGZvciB0dXBsZSBmb3IgZWFzeSBhY2Nlc3NcblxuXHRcdFx0IyBOT1RFIGNhbiBpbXByb3ZlLi4gc2hvdWxkIHJhdGhlciBtYWtlIHRoZSB3aG9sZSBsZWZ0IGJlIGEgVmFyQmxvY2sgb3IgVHVwbGVWYXJCbG9ja1xuXHRcdFx0IyBwIFwidHlwZSBpcyB2YXIgLS0gc2tpcCB0aGUgcmVzdFwiXG5cblx0XHRyaWdodC50cmF2ZXJzZVxuXHRcdGxlZnQudHJhdmVyc2Vcblx0XHRzZWxmXG5cblx0ZGVmIGpzIG9cblx0XHQjIG9ubHkgZm9yIGFjdHVhbCBpbm5lciBleHByZXNzaW9ucywgb3RoZXJ3aXNlIGNhY2hlIHRoZSB3aG9sZSBhcnJheSwgbm8/XG5cdFx0dW5sZXNzIHJpZ2h0LmlzRXhwcmVzc2FibGVcblx0XHRcdCMgcCBcIlR1cGxlQXNzaWduLmNvbnN1bWUhIHtyaWdodH1cIi5ibHVlXG5cdFx0XG5cdFx0XHRyZXR1cm4gcmlnaHQuY29uc3VtZShzZWxmKS5jXG5cblx0XHQjIHAgXCJUVVBMRSB7dHlwZX1cIlxuXG5cdFx0IyMjIGEsYixjID0gYXJndW1lbnRzICMjI1xuXHRcdCMgLSBkaXJlY3QuIG5vIG1hdHRlciBpZiBsdmFsdWVzIGFyZSB2YXJpYWJsZXMgb3Igbm90LiBNYWtlIGZha2UgYXJndW1lbnRzIHVwIHRvIHRoZSBzYW1lIGNvdW50IGFzIHR1cGxlXG5cblx0XHQjIyMgYSwqYixiID0gYXJndW1lbnRzICMjI1xuXHRcdCMgTmVlZCB0byBjb252ZXJ0IGFyZ3VtZW50cyB0byBhbiBhcnJheS4gSUYgYXJndW1lbnRzIGlzIG5vdCByZWZlcmVuY2VkIGFueXdoZXJlIGVsc2UgaW4gc2NvcGUsIFxuXHRcdCMgd2UgY2FuIGRvIHRoZSBhc3NpZ25tZW50IGRpcmVjdGx5IHdoaWxlIHJvbGxpbmcgdGhyb3VnaCBhcmd1bWVudHNcblxuXHRcdCMjIyBhLGIgPSBiLGEgIyMjXG5cdFx0IyBpZGVhbGx5IHdlIG9ubHkgbmVlZCB0byBjYWNoZSB0aGUgZmlyc3QgdmFsdWUgKG9yIG4gLSAxKSwgYXNzaWduIGRpcmVjdGx5IHdoZW4gcG9zc2libGUuXG5cblx0XHQjIyMgYSxiLGMgPSAobWV0aG9kIHwgZXhwcmVzc2lvbikgIyMjXG5cdFx0IyBjb252ZXJ0IHJlcyBpbnRvIGFycmF5LCBhc3NpZ24gZnJvbSBhcnJheS4gQ2FuIGNhY2hlIHRoZSB2YXJpYWJsZSB3aGVuIGFzc2lnbmluZyBmaXJzdCB2YWx1ZVxuXG5cdFx0IyBGaXJzdCB3ZSBuZWVkIHRvIGZpbmQgb3V0IHdoZXRoZXIgd2UgYXJlIHJlcXVpcmVkIHRvIHN0b3JlIHRoZSByZXN1bHQgaW4gYW4gYXJyYXkgYmVmb3JlIGFzc2lnbmluZ1xuXHRcdCMgSWYgdGhpcyBuZWVkcyB0byBiZSBhbiBleHByZXNzaW9uIChyZXR1cm5zPywgd2UgbmVlZCB0byBmYWxsIGJhY2sgdG8gdGhlIENTLXdhKVxuXG5cdFx0dmFyIGFzdCA9IEJsb2NrLm5ldyhbXSlcblx0XHR2YXIgbGZ0ID0gc2VsZi5sZWZ0XG5cdFx0dmFyIHJndCA9IHNlbGYucmlnaHRcblx0XHR2YXIgdHlwID0gc2VsZi50eXBlXG5cdFx0dmFyIHZpYSA9IG51bGxcblxuXHRcdHZhciBsaSAgID0gMFxuXHRcdHZhciByaSAgID0gbGZ0LmNvdW50XG5cdFx0dmFyIGxsZW4gPSByaVxuXG5cblx0XHQjIGlmIEB2YXJzXG5cdFx0IyBcdHAgXCJ0dXBsZSBoYXMge0B2YXJzOmxlbmd0aH0gdmFyc1wiXG5cblx0XHQjIGlmIHdlIGhhdmUgYSBzcGxhdCBvbiB0aGUgbGVmdCBpdCBpcyBtdWNoIG1vcmUgbGlrZWx5IHRoYXQgd2UgbmVlZCB0byBzdG9yZSByaWdodFxuXHRcdCMgaW4gYSB0ZW1wb3JhcnkgYXJyYXksIGJ1dCBpZiB0aGUgcmlnaHQgc2lkZSBoYXMgYSBrbm93biBsZW5ndGgsIGl0IHNob3VsZCBzdGlsbCBub3QgYmUgbmVlZGVkXG5cdFx0dmFyIGxzcGxhdCA9IGxmdC5maWx0ZXIofHZ8IHYgaXNhIFNwbGF0IClbMF1cblxuXHRcdCMgaWYgcmlnaHQgaXMgYW4gYXJyYXkgd2l0aG91dCBhbnkgc3BsYXRzIChvciBpbm5lciB0dXBsZXM/KSwgbm9ybWFsaXplIGl0IHRvIHR1cGxlXG5cdFx0cmd0ID0gVHVwbGUubmV3KHJndC5ub2RlcykgaWYgcmd0IGlzYSBBcnIgJiYgIXJndC5zcGxhdFxuXHRcdHZhciBybGVuID0gcmd0IGlzYSBUdXBsZSA/IHJndC5jb3VudCA6IG51bGxcblxuXHRcdCMgaWYgYW55IHZhbHVlcyBhcmUgc3RhdGVtZW50cyB3ZSBuZWVkIHRvIGhhbmRsZSB0aGlzIGJlZm9yZSBjb250aW51aW5nXG5cblx0XHQjIyMgYSxiLGMgPSAxMCwyMCxhcnkgIyMjXG5cdFx0IyBpZGVhbGx5IHdlIG9ubHkgbmVlZCB0byBjYWNoZSB0aGUgZmlyc3QgdmFsdWUgKG9yIG4gLSAxKSwgYXNzaWduIGRpcmVjdGx5IHdoZW4gcG9zc2libGUuXG5cdFx0IyBvbmx5IGlmIHRoZSB2YXJpYWJsZXMgYXJlIG5vdCBwcmVkZWZpbmVkIG9yIHByZWRlY2xhcmVkIGNhbiBiZSB3ZSBjZXJ0YWluIHRoYXQgd2UgY2FuIGRvIGl0IHdpdGhvdXQgY2FjaGluZ1xuXHRcdCMgaWYgcmxlbiAmJiB0eXAgPT0gJ3ZhcicgJiYgIWxzcGxhdFxuXHRcdCMgXHQjIHRoaXMgY2FuIGJlIGRhbmdlcm91cyBpbiBlZGdlY2FzZXMgdGhhdCBhcmUgdmVyeSBoYXJkIHRvIGRldGVjdFxuXHRcdCMgXHQjIGlmIGl0IGJlY29tZXMgYW4gaXNzdWUsIGZhbGwgYmFjayB0byBzaW1wbGVyIHZlcnNpb25zXG5cdFx0IyBcdCMgZG9lcyBub3QgZXZlbiBtYXR0ZXIgaWYgdGhlcmUgaXMgYSBzcGxhdD9cblxuXHRcdCMgc3BlY2lhbCBjYXNlIGZvciBhcmd1bWVudHMoISlcblx0XHRpZiAhbHNwbGF0ICYmIHJndCA9PSBBUkdVTUVOVFNcblxuXHRcdFx0dmFyIHBhcnMgPSBzY29wZV9fLnBhcmFtc1xuXHRcdFx0IyBwIFwic3BlY2lhbCBjYXNlIHdpdGggYXJndW1lbnRzIHtwYXJzfVwiXG5cdFx0XHQjIGZvcmNpbmcgdGhlIGFyZ3VtZW50cyB0byBiZSBuYW1lZFxuXHRcdFx0IyBwIFwiZ290IGhlcmU/Pz8ge3BhcnN9XCJcblx0XHRcdGxmdC5tYXAgZG8gfGwsaXwgYXN0LnB1c2ggT1AoJz0nLGwubm9kZSxwYXJzLmF0KGkseWVzKS52aXNpdC52YXJpYWJsZSkgIyBzLnBhcmFtcy5hdCh2YWx1ZSAtIDEseWVzKVxuXG5cdFx0XG5cdFx0ZWxpZiBybGVuXG5cdFx0XHQjIHdlIGhhdmUgc2V2ZXJhbCBpdGVtcyBpbiB0aGUgcmlnaHQgcGFydC4gd2hhdCBhYm91dCBzcGxhdHMgaGVyZT9cblxuXHRcdFx0IyBwcmUtZXZhbHVhdGUgcnZhbHVlcyB0aGF0IG1pZ2h0IGJlIHJlZmVyZW5jZSBmcm9tIG90aGVyIGFzc2lnbm1lbnRzXG5cdFx0XHQjIHdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlIHJpZ2h0c2lkZSB2YWx1ZXMgaGFzIG5vIHNpZGUtZWZmZWN0cy4gQ2F1c2UgaWZcblx0XHRcdCMgdGhleSBkb250LCB3ZSByZWFsbHkgZG8gbm90IG5lZWQgdGVtcG9yYXJ5IHZhcmlhYmxlcy5cblxuXHRcdFx0IyBzb21lIG9mIHRoZXNlIG9wdGltaXphdGlvbnMgYXJlIHF1aXRlIHBldHR5IC0gbWFrZXMgdGhpbmdzIG1vcmUgY29tcGxpY2F0ZWRcblx0XHRcdCMgaW4gdGhlIGNvbXBpbGVyIG9ubHkgdG8gZ2V0IGFyb3VuZCBhZGRpbmcgYSBmZXcgdGVtcC12YXJpYWJsZXMgaGVyZSBhbmQgdGhlcmVcblxuXHRcdFx0IyB2YXIgZmlyc3RVbnNhZmUgPSAwXG5cdFx0XHQjIGxmdC5tYXAgZG8gfHYsaXxcblx0XHRcdCMgXHRpZiB2IGlzYSBWYXJSZWZlcmVuY2Vcblx0XHRcdCMgXHRcdHAgXCJsZWZ0IHNpZGUge2l9IHt2fSB7di5yZWZucn1cIlxuXG5cdFx0XHQjIHJndC5tYXAgZG8gfHYsaXxcblx0XHRcdCMgXHRpZiB2Lmhhc1NpZGVFZmZlY3RzXG5cdFx0XHQjIFx0XHQjIHJldHVybiBpZiBpID09IDAgb3IgIXYuaGFzU2lkZUVmZmVjdHNcblx0XHRcdCMgXHRcdCMgcmV0dXJuIGlmIHYgaXNhIE51bSB8fCB2IGlzYSBTdHIgfHwgaSA9PSAwXG5cdFx0XHQjIFx0XHQjIHdlIGNvdWxkIGV4cGxpY2l0bHkgY3JlYXRlIGEgdGVtcG9yYXJ5IHZhcmlhYmxlIGFuZCBhZGRpbmcgbm9kZXMgZm9yIGFjY2Vzc2luZyBldGNcblx0XHRcdCMgXHRcdCMgYnV0IHRoZSBidWlsdGluIGNhY2hpbmcgc2hvdWxkIHJlYWxseSB0YWtlIGNhcmUgb2YgdGhpcyBmb3IgdXNcblx0XHRcdCMgXHRcdCMgd2UgbmVlZCB0byByZWFsbHkgZm9yY2UgdGhlIGNhY2hpbmcgdGhvdWdoIC0tIHNpbmNlIHdlIG5lZWQgYSBjb3B5IG9mIGl0IGV2ZW4gaWYgaXQgaXMgYSBsb2NhbFxuXHRcdFx0IyBcdFx0IyB3ZSBuZWVkIHRvIHByZWRlY2xhcmUgdGhlIHZhcmlhYmxlcyBhdCB0aGUgdG9wIG9mIHNjb3BlIGlmIHRoaXMgZG9lcyBub3QgdGFrZSBjYXJlIG9mIGl0XG5cdFx0XHQjIFx0XHRcblx0XHRcdCMgXHRcdCMgdGhlc2UgYXJlIHRoZSBkZWNsYXJhdGlvbnMgLS0gd2UgbmVlZCB0byBhZGQgdGhlbSBzb21ld2hlcmUgc21hcnRcblx0XHRcdCMgXHRcdEB0ZW1wb3JhcnkucHVzaCh2KSAjIG5lZWQgYSBnZW5lcmFsaXplZCB3YXkgdG8gZG8gdGhpcyB0eXBlIG9mIHRoaW5nXG5cdFx0XHQjIFx0XHRhc3QucHVzaCh2LmNhY2hlKGZvcmNlOiB5ZXMsIHR5cGU6ICdzd2FwJywgZGVjbGFyZWQ6IHR5cCA9PSAndmFyJykpXG5cdFx0XHQjIFx0XHQjIHRoZXkgZG8gbmVlZCB0byBiZSBkZWNsYXJlZCwgbm8/XG5cblx0XHRcdCMgbm93IHdlIGNhbiBmcmVlIHRoZSBjYWNoZWQgdmFyaWFibGVzXG5cdFx0XHQjIGFzdC5tYXAgZG8gfG58IG4uZGVjYWNoZVxuXG5cdFx0XHR2YXIgcHJlID0gW11cblx0XHRcdHZhciByZXN0ID0gW11cblxuXHRcdFx0dmFyIHBhaXJzID0gbGZ0Lm1hcCBkbyB8bCxpfFxuXHRcdFx0XHR2YXIgdiA9IG51bGxcblx0XHRcdFx0IyBkZXRlcm1pbmUgaWYgdGhpcyBuZWVkcyB0byBiZSBwcmVjYWNoZWQ/XG5cdFx0XHRcdCMgaWYgbCBpc2EgVmFyUmVmZXJlbmNlXG5cdFx0XHRcdCMgXHQjIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgdGhlIHZhcmlhYmxlIGlzIHJlZmVyZW5jZWRcblx0XHRcdFx0IyBcdCMgc2hvdWxkIGFsc28gY291bnQgZXZlbiBpZiBpdCBpcyBwcmVkZWNsYXJlZCBhdCB0aGUgdG9wXG5cdFx0XHRcdCMgXHRpZiBsLnJlZm5yID09IDBcblxuXHRcdFx0XHRpZiBsID09IGxzcGxhdFxuXHRcdFx0XHRcdHYgPSBBcmdMaXN0Lm5ldyhbXSlcblx0XHRcdFx0XHR2YXIgdG8gPSAocmxlbiAtIChyaSAtIGkpKVxuXHRcdFx0XHRcdCMgcCBcImFzc2luZyBzcGxhdCBhdCBpbmRleCB7aX0gdG8gc2xpY2Uge2xpfSAtIHt0b31cIi5jeWFuXG5cdFx0XHRcdFx0di5wdXNoKHJndC5pbmRleChsaSsrKSkgd2hpbGUgbGkgPD0gdG9cblx0XHRcdFx0XHR2ID0gQXJyLm5ldyh2KVxuXHRcdFx0XHRcdCMgYXN0LnB1c2ggT1AoJz0nLGwubm9kZSxBcnIubmV3KHYpKVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0diA9IHJndC5pbmRleChsaSsrKVxuXHRcdFx0XHRbbC5ub2RlLHZdXG5cblx0XHRcdFx0IyBpZiBsIGlzYSBWYXJSZWZlcmVuY2UgJiYgbC5yZWZuciBcblx0XHRcdHZhciBjbGVhbiA9IHRydWVcblx0XHRcdFxuXHRcdFx0cGFpcnMubWFwIGRvIHx2LGl8XG5cdFx0XHRcdHZhciBsID0gdlswXVxuXHRcdFx0XHR2YXIgciA9IHZbMV1cblxuXHRcdFx0XHRpZiBjbGVhblxuXHRcdFx0XHRcdGlmIGwgaXNhIFZhclJlZmVyZW5jZSAmJiBsLnJlZm5yID09IDBcblx0XHRcdFx0XHRcdCMgc3RpbGwgY2xlYW5cblx0XHRcdFx0XHRcdGNsZWFuID0geWVzXG5cdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0Y2xlYW4gPSBub1xuXHRcdFx0XHRcdFx0IyBwIFwibm93IGNhY2hlXCJcblx0XHRcdFx0XHRcdHBhaXJzLnNsaWNlKGkpLm1hcCBkbyB8cGFydHxcblx0XHRcdFx0XHRcdFx0aWYgcGFydFsxXS5oYXNTaWRlRWZmZWN0c1xuXHRcdFx0XHRcdFx0XHRcdEB0ZW1wb3JhcnkucHVzaChwYXJ0WzFdKSAjIG5lZWQgYSBnZW5lcmFsaXplZCB3YXkgdG8gZG8gdGhpcyB0eXBlIG9mIHRoaW5nXG5cdFx0XHRcdFx0XHRcdFx0YXN0LnB1c2gocGFydFsxXS5jYWNoZShmb3JjZTogeWVzLCBwb29sOiAnc3dhcCcsIGRlY2xhcmVkOiB0eXAgPT0gJ3ZhcicpKVxuXHRcdFx0XHRcdFx0IyBwIFwiZnJvbSB7aX0gLSBjYWNoZSBhbGwgcmVtYWluaW5nIHdpdGggc2lkZS1lZmZlY3RzXCJcblxuXHRcdFx0XHQjIGlmIHRoZSBwcmV2aW91cyB2YWx1ZSBpbiBhc3QgaXMgYSByZWZlcmVuY2UgdG8gb3VyIHZhbHVlIC0gdGhlIGNhY2hpbmcgd2FzIG5vdCBuZWVkZWRcblx0XHRcdFx0aWYgYXN0Lmxhc3QgPT0gclxuXHRcdFx0XHRcdHIuZGVjYWNoZVxuXHRcdFx0XHRcdCMgcCBcIndhcyBjYWNoZWQgLSBub3QgbmVlZGVkXCJcblx0XHRcdFx0XHQjIHNpbXBsZSBhc3NpZ25cblx0XHRcdFx0XHRhc3QucmVwbGFjZShyLE9QKCc9JyxsLHIpKVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0YXN0LnB1c2ggT1AoJz0nLGwscilcblxuXHRcdFx0IyBXQVJOIEZJWE1FIElzIHRoZXJlIG5vdCBhbiBpc3N1ZSB3aXRoIFZhckJsb2NrIHZzIG5vdCBoZXJlP1xuXHRcdGVsc2UgXG5cdFx0XHQjIHRoaXMgaXMgd2hlcmUgd2UgbmVlZCB0byBjYWNoZSB0aGUgcmlnaHQgc2lkZSBiZWZvcmUgYXNzaWduaW5nXG5cdFx0XHQjIGlmIHRoZSByaWdodCBzaWRlIGlzIGEgZm9yIGxvb3AsIHdlIENPVUxEIHRyeSB0byBiZSBleHRyYSBjbGV2ZXIsIGJ1dFxuXHRcdFx0IyBmb3Igbm93IGl0IGlzIG5vdCB3b3J0aCB0aGUgYWRkZWQgY29tcGlsZXIgY29tcGxleGl0eVxuXHRcdFx0XG5cdFx0XHQjIGl0ZXIuY2FjaGUoZm9yY2U6IHllcywgdHlwZTogJ2l0ZXInKVxuXHRcdFx0dmFyIHRvcCA9IFZhckJsb2NrLm5ld1xuXHRcdFx0dmFyIGl0ZXIgPSB1dGlsLml0ZXJhYmxlKHJndCwgeWVzKVxuXHRcdFx0IyBjb3VsZCBzZXQgdGhlIHZhcnMgaW5zaWRlIC0tIG1vc3QgbGlrZWx5XG5cdFx0XHRhc3QucHVzaCh0b3ApXG5cdFx0XHR0b3AucHVzaChpdGVyKVxuXG5cdFx0XHRpZiBsc3BsYXRcblx0XHRcdFx0dmFyIGxlbiA9IHV0aWwubGVuKGl0ZXIsIHllcylcblx0XHRcdFx0dmFyIGlkeCA9IHV0aWwuY291bnRlcigwLCB5ZXMpXG5cdFx0XHRcdCMgY2FjaGUgdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXlcblx0XHRcdFx0dG9wLnB1c2gobGVuKSAjIHByZWFzc2lnbiB0aGUgbGVuZ3RoXG5cdFx0XHRcdCMgY2FjaGUgY291bnRlciB0byBsb29wIHRocm91Z2hcblx0XHRcdFx0dG9wLnB1c2goaWR4KVxuXG5cdFx0XHQjIG9ubHkgaWYgdGhlIGJsb2NrIGlzIHZhcmlhYmxlIGJhc2VkLCBubz9cblx0XHRcdCMgYXN0LnB1c2goYmxrID0gVmFyQmxvY2submV3KVxuXHRcdFx0IyBibGsgPSBudWxsXG5cdFx0XHRcblx0XHRcdHZhciBibGt0eXBlID0gdHlwID09ICd2YXInID8gVmFyQmxvY2sgOiBCbG9ja1xuXHRcdFx0dmFyIGJsayA9IGJsa3R5cGUubmV3KFtdKVxuXHRcdFx0IyBibGsgPSB0b3AgaWYgdHlwID09ICd2YXInXG5cdFx0XHRhc3QucHVzaChibGspXG5cblx0XHRcdCMgaWYgdGhlIGx2YWxzIGFyZSBub3QgdmFyaWFibGVzIC0gd2UgbmVlZCB0byBwcmVhc3NpZ25cblx0XHRcdCMgY2FuIGFsc28gdXNlIHNsaWNlIGhlcmUgZm9yIHNpbXBsaWNpdHksIGJ1dCB0cnkgd2l0aCB3aGlsZSBub3dcdFx0XHRcblx0XHRcdGxmdC5tYXAgZG8gfGwsaXxcblx0XHRcdFx0aWYgbCA9PSBsc3BsYXRcblx0XHRcdFx0XHR2YXIgbHZhciA9IGwubm9kZVxuXHRcdFx0XHRcdHZhciByZW0gPSBsbGVuIC0gaSAtIDEgIyByZW1haW5pbmcgYWZ0ZXIgc3BsYXRcblxuXHRcdFx0XHRcdGlmIHR5cCAhPSAndmFyJ1xuXHRcdFx0XHRcdFx0dmFyIGFyciA9IHV0aWwuYXJyYXkoT1AoJy0nLGxlbiwgbnVtX18oaSArIHJlbSkgKSx5ZXMpXG5cdFx0XHRcdFx0XHR0b3AucHVzaChhcnIpXG5cdFx0XHRcdFx0XHRsdmFyID0gYXJyLmNhY2hldmFyXG5cdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0YXN0LnB1c2goYmxrID0gYmxrdHlwZS5uZXcpIHVubGVzcyBibGtcblx0XHRcdFx0XHRcdHZhciBhcnIgPSB1dGlsLmFycmF5KCBPUCgnLScsbGVuLG51bV9fKGkgKyByZW0pICkgKVxuXHRcdFx0XHRcdFx0YmxrLnB1c2goT1AoJz0nLGx2YXIsYXJyKSlcblxuXHRcdFx0XHRcdCMgaWYgIWx2YXI6dmFyaWFibGUgfHwgIWx2YXIudmFyaWFibGUgIyBsdmFyID0gXG5cdFx0XHRcdFx0IyBcdHRvcC5wdXNoKClcblx0XHRcdFx0XHQjXHRwIFwiaGFzIHZhcmlhYmxlIC0gbm8gbmVlZCB0byBjcmVhdGUgYSB0ZW1wXCJcblx0XHRcdFx0XHQjIGJsay5wdXNoKE9QKCc9JyxsdmFyLEFyci5uZXcoW10pKSkgIyBkb250IHByZWNhbGN1bGF0ZSBzaXplIG5vd1xuXHRcdFx0XHRcdCMgbWF4ID0gdG8gPSAocmxlbiAtIChsbGVuIC0gaSkpXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0IFxuXHRcdFx0XHRcdHZhciB0ZXN0ID0gcmVtID8gT1AoJy0nLGxlbixyZW0pIDogbGVuXG5cblx0XHRcdFx0XHR2YXIgc2V0ID0gT1AoJz0nLFxuXHRcdFx0XHRcdFx0T1AoJy4nLGx2YXIsT1AoJy0nLGlkeCxudW1fXyhpKSkpLFxuXHRcdFx0XHRcdFx0T1AoJy4nLGl0ZXIsT1AoJysrJyxpZHgpKVxuXHRcdFx0XHRcdClcblxuXHRcdFx0XHRcdGFzdC5wdXNoKFdISUxFKE9QKCc8JyxpZHgsdGVzdCksIHNldCkpXG5cblx0XHRcdFx0XHRpZiB0eXAgIT0gJ3Zhcidcblx0XHRcdFx0XHRcdGFzdC5wdXNoKGJsayA9IEJsb2NrLm5ldykgXG5cdFx0XHRcdFx0XHRibGsucHVzaChPUCgnPScsbC5ub2RlLGx2YXIpKVxuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdGJsayA9IG51bGxcblxuXHRcdFx0XHRcdCMgbm90IGlmIHNwbGF0IHdhcyBsYXN0P1xuXHRcdFx0XHRcdCMgYXN0LnB1c2goYmxrID0gVmFyQmxvY2submV3KVxuXG5cdFx0XHRcdGVsaWYgbHNwbGF0XG5cdFx0XHRcdFx0YXN0LnB1c2goYmxrID0gYmxrdHlwZS5uZXcpIHVubGVzcyBibGtcblx0XHRcdFx0XHQjIHdlIGNvdWxkIGNhY2hlIHRoZSByYXcgY29kZSBvZiB0aGlzIG5vZGUgZm9yIGJldHRlciBwZXJmb3JtYW5jZVxuXHRcdFx0XHRcdGJsay5wdXNoKE9QKCc9JyxsLE9QKCcuJyxpdGVyLE9QKCcrKycsaWR4KSkpKVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0YXN0LnB1c2goYmxrID0gYmxrdHlwZS5uZXcpIHVubGVzcyBibGtcblx0XHRcdFx0XHRibGsucHVzaChPUCgnPScsbCxPUCgnLicsaXRlcixudW1fXyhpKSApKSlcblxuXHRcdCMgaWYgd2UgYXJlIGluIGFuIGV4cHJlc3Npb24gd2UgcmVhbGx5IG5lZWQgdG8gXG5cdFx0aWYgby5pc0V4cHJlc3Npb24gYW5kIEB2YXJzXG5cdFx0XHQjIHAgXCJ0dXBsZSBpcyBleHByZXNzaW9uXCIgIyB2YXJpYWJsZXMgTVVTVCBiZSBhdXRvZGVjbGFyZWQgb3V0c2lkZSBvZiB0aGUgZXhwcmVzc2lvblxuXHRcdFx0Zm9yIHYgaW4gQHZhcnNcblx0XHRcdFx0di52YXJpYWJsZS5hdXRvZGVjbGFyZVxuXG5cdFx0ZWxpZiBAdmFyc1xuXHRcdFx0Zm9yIHYgaW4gQHZhcnNcblx0XHRcdFx0IyBwIFwicHJlZGVjbGFyZSB2YXJpYWJsZSBiZWZvcmUgY29tcGlsYXRpb25cIlxuXHRcdFx0XHR2LnZhcmlhYmxlLnByZWRlY2xhcmVkXG5cblx0XHQjIGlzIHRoZXJlIGFueSByZWFzb24gdG8gbWFrZSBpdCBpbnRvIGFuIGV4cHJlc3Npb24/XG5cdFx0aWYgYXN0LmlzRXhwcmVzc2FibGUgIyBOTyFcblx0XHRcdCMgcCBcImV4cHJlc3NcIlxuXHRcdFx0IyBpZiB0aGlzIGlzIGFuIGV4cHJlc3Npb25cblx0XHRcdHZhciBvdXQgPSBhc3QuYyhleHByZXNzaW9uOiB5ZXMpXG5cdFx0XHRvdXQgPSBcInt0eXB9IHtvdXR9XCIgaWYgdHlwIGFuZCAhby5pc0V4cHJlc3Npb24gIyBub3QgaW4gZXhwcmVzc2lvblxuXHRcdFx0cmV0dXJuIG91dFxuXHRcdGVsc2Vcblx0XHRcdHZhciBvdXQgPSBhc3QuY1xuXHRcdFx0IyBpZiB0aGlzIGlzIGEgdmFyYmxvY2sgXG5cdFx0XHRyZXR1cm4gb3V0XG5cblxuXHRkZWYgYyBvXG5cdFx0dmFyIG91dCA9IHN1cGVyKG8pXG5cdFx0IyB0aGlzIGlzIG9ubHkgdXNlZCBpbiB0dXBsZSAtLSBiZXR0ZXIgdG8gbGV0IHRoZSB0dXBsZSBoYXYgYSBzZXBhcmF0ZSAjY1xuXHRcdGlmIEB0ZW1wb3JhcnkgJiYgQHRlbXBvcmFyeTpsZW5ndGhcblx0XHRcdEB0ZW1wb3JhcnkubWFwIGRvIHx0ZW1wfCB0ZW1wLmRlY2FjaGVcblx0XHRyZXR1cm4gb3V0XG5cblxuXG4jIElERU5USUZJRVJTXG5cbiMgcmVhbGx5IG5lZWQgdG8gY2xlYW4gdGhpcyB1cFxuIyBEcm9wIHRoZSB0b2tlbj9cbmV4cG9ydCBjbGFzcyBJZGVudGlmaWVyIDwgTm9kZVxuXG5cdHByb3Agc2FmZWNoYWluXG5cdHByb3AgdmFsdWVcblxuXHRkZWYgaW5pdGlhbGl6ZSB2YWx1ZVxuXHRcdEB2YWx1ZSA9IGxvYWQodmFsdWUpXG5cdFx0QHN5bWJvbCA9IG51bGxcblx0XHRAc2V0dGVyID0gbnVsbFxuXG5cdFx0aWYgKFwiXCIgKyB2YWx1ZSkuaW5kZXhPZihcIj9cIikgPj0gMFxuXHRcdFx0QHNhZmVjaGFpbiA9IHllc1xuXHRcdCMgQHNhZmVjaGFpbiA9IChcIlwiICsgdmFsdWUpLmluZGV4T2YoXCI/XCIpID49IDBcblx0XHRzZWxmXG5cblx0ZGVmIHJlZmVyZW5jZXMgdmFyaWFibGVcblx0XHRAdmFsdWUuQHZhcmlhYmxlID0gdmFyaWFibGUgaWYgQHZhbHVlXG5cdFx0c2VsZlxuXG5cdGRlZiBzb3VyY2VNYXBNYXJrZXJcblx0XHRAdmFsdWUuc291cmNlTWFwTWFya2VyXG5cblx0ZGVmIGxvYWQgdlxuXHRcdHJldHVybiAodiBpc2EgSWRlbnRpZmllciA/IHYudmFsdWUgOiB2KVxuXG5cdGRlZiB0cmF2ZXJzZVxuXHRcdCMgTk9ERVMucHVzaChzZWxmKVxuXHRcdHNlbGZcblxuXHRkZWYgdmlzaXRcblx0XG5cdFx0aWYgQHZhbHVlIGlzYSBOb2RlXG5cdFx0XHQjIGNvbnNvbGUubG9nIFwiSURFTlRJRklFUiBWQUxVRSBJUyBOT0RFXCJcblx0XHRcdEB2YWx1ZS50cmF2ZXJzZVxuXHRcdHNlbGZcblxuXHRkZWYgcmVnaW9uXG5cdFx0W0B2YWx1ZS5AbG9jLEB2YWx1ZS5AbG9jICsgQHZhbHVlLkBsZW5dXG5cblx0ZGVmIGlzVmFsaWRJZGVudGlmaWVyXG5cdFx0eWVzXG5cdFx0XG5cdGRlZiBpc1Jlc2VydmVkXG5cdFx0QHZhbHVlOnJlc2VydmVkIG9yIFJFU0VSVkVEX1RFU1QudGVzdChTdHJpbmcoQHZhbHVlKSlcblxuXHRkZWYgc3ltYm9sXG5cdFx0IyBjb25zb2xlLmxvZyBcIklkZW50aWZpZXIjc3ltYm9sIHt2YWx1ZX1cIlxuXHRcdEBzeW1ib2wgfHw9IHN5bV9fKHZhbHVlKVxuXG5cdGRlZiBzZXR0ZXJcblx0XHQjIGNvbnNvbGUubG9nIFwiSWRlbnRpZmllciNzZXR0ZXJcIlxuXHRcdEBzZXR0ZXIgfHw9IGlmIHRydWVcblx0XHRcdHZhciB0b2sgPSBUb2tlbi5uZXcoJ0lERU5USUZJRVInLHN5bV9fKCdzZXQtJyArIEB2YWx1ZSksQHZhbHVlLkBsb2Mgb3IgLTEpXG5cdFx0XHRJZGVudGlmaWVyLm5ldyh0b2spXG5cdFx0XHQjIElkZW50aWZpZXIubmV3KFwic2V0LXtzeW1ib2x9XCIpXG5cblx0ZGVmIHRvU3RyaW5nXG5cdFx0U3RyaW5nKEB2YWx1ZSlcblxuXHRkZWYgdG9KU09OXG5cdFx0dG9TdHJpbmdcblxuXHRkZWYgYWxpYXNcblx0XHRzeW1fXyhAdmFsdWUpXG5cblx0ZGVmIGpzIG9cblx0XHRzeW1ib2xcblxuXHRkZWYgY1xuXHRcdHJldHVybiAnJyArIHN5bWJvbCAjIG1hcmtfXyhAdmFsdWUpICsgXG5cblx0ZGVmIGR1bXBcblx0XHR7IGxvYzogcmVnaW9uIH1cblxuXHRkZWYgbmFtZXBhdGhcblx0XHR0b1N0cmluZ1xuXHRcdFxuZXhwb3J0IGNsYXNzIFRhZ0lkIDwgSWRlbnRpZmllclxuXG5cdGRlZiBpbml0aWFsaXplIHZcblx0XHRAdmFsdWUgPSB2IGlzYSBJZGVudGlmaWVyID8gdi52YWx1ZSA6IHZcblx0XHRzZWxmXG5cblx0ZGVmIGNcblx0XHRcImlkJCgne3ZhbHVlLmN9JylcIlxuXHRcdFxuIyBUaGlzIGlzIG5vdCBhbiBpZGVudGlmaWVyIC0gaXQgaXMgcmVhbGx5IGEgc3RyaW5nXG4jIElzIHRoaXMgbm90IGEgbGl0ZXJhbD9cblxuIyBGSVhNRSBSZW5hbWUgdG8gSXZhckxpdGVyYWw/IG9yIHNpbXBseSBMaXRlcmFsIHdpdGggdHlwZSBJdmFyXG5leHBvcnQgY2xhc3MgSXZhciA8IElkZW50aWZpZXJcblxuXHRkZWYgaW5pdGlhbGl6ZSB2XG5cdFx0QHZhbHVlID0gdiBpc2EgSWRlbnRpZmllciA/IHYudmFsdWUgOiB2XG5cdFx0c2VsZlxuXG5cdGRlZiBuYW1lXG5cdFx0aGVscGVycy5jYW1lbENhc2UoQHZhbHVlKS5yZXBsYWNlKC9eQC8sJycpXG5cdFx0IyB2YWx1ZS5jLmNhbWVsQ2FzZS5yZXBsYWNlKC9eQC8sJycpXG5cblx0ZGVmIGFsaWFzXG5cdFx0J18nICsgbmFtZVxuXG5cdCMgdGhlIEAgc2hvdWxkIHBvc3NpYmx5IGJlIGdvbmUgZnJvbSB0aGUgc3RhcnQ/XG5cdGRlZiBqcyBvXG5cdFx0J18nICsgbmFtZVxuXG5cdGRlZiBjXG5cdFx0J18nICsgaGVscGVycy5jYW1lbENhc2UoQHZhbHVlKS5zbGljZSgxKSAjIC5yZXBsYWNlKC9eQC8sJycpICMgbWFya19fKEB2YWx1ZSkgKyBcblxuXG5cbiMgQW1iaWd1b3VzIC0gV2UgbmVlZCB0byBiZSBjb25zaXN0ZW50IGFib3V0IENvbnN0IHZzIENvbnN0QWNjZXNzXG4jIEJlY29tZXMgbW9yZSBpbXBvcnRhbnQgd2hlbiB3ZSBpbXBsZW1lbnQgdHlwZWluZmVyZW5jZSBhbmQgY29kZS1hbmFseXNpc1xuZXhwb3J0IGNsYXNzIENvbnN0IDwgSWRlbnRpZmllclxuXHRcdFxuXHRkZWYgc3ltYm9sXG5cdFx0IyBjb25zb2xlLmxvZyBcIklkZW50aWZpZXIjc3ltYm9sIHt2YWx1ZX1cIlxuXHRcdEBzeW1ib2wgfHw9IHN5bV9fKHZhbHVlKVxuXG5cdGRlZiBqcyBvXG5cdFx0c3ltYm9sXG5cblx0ZGVmIGNcblx0XHRtYXJrX18oQHZhbHVlKSArIHN5bWJvbFxuXG5leHBvcnQgY2xhc3MgVGFnVHlwZUlkZW50aWZpZXIgPCBJZGVudGlmaWVyXG5cblx0cHJvcCBuYW1lXG5cdHByb3AgbnNcblxuXHRkZWYgaW5pdGlhbGl6ZSB2YWx1ZVxuXHRcdEB2YWx1ZSA9IGxvYWQodmFsdWUpXG5cdFx0c2VsZlxuXG5cdGRlZiBsb2FkIHZhbFxuXHRcdEBzdHIgPSAoXCJcIiArIHZhbClcblx0XHR2YXIgcGFydHMgPSBAc3RyLnNwbGl0KFwiOlwiKVxuXHRcdEByYXcgPSB2YWxcblx0XHRAbmFtZSA9IHBhcnRzLnBvcFxuXHRcdEBucyA9IHBhcnRzLnNoaWZ0ICMgaWYgYW55P1xuXHRcdHJldHVybiBAc3RyXG5cblx0ZGVmIGpzIG9cblx0XHRyZXR1cm4gXCJJbWJhLlRBR1Mue0BzdHIucmVwbGFjZShcIjpcIixcIiRcIil9XCJcblxuXHRkZWYgY1xuXHRcdGpzXG5cblx0ZGVmIGZ1bmNcblx0XHR2YXIgbmFtZSA9IEBuYW1lLnJlcGxhY2UoLy0vZywnXycpLnJlcGxhY2UoL1xcIy8sJycpXG5cdFx0bmFtZSArPSBcIiR7QG5zLnRvTG93ZXJDYXNlfVwiIGlmIEBuc1xuXHRcdG5hbWVcblxuXHRkZWYgc3Bhd25lclxuXHRcdGlmIEBuc1xuXHRcdFx0XCJ7QG5zLnRvVXBwZXJDYXNlfS4ke0BuYW1lLnJlcGxhY2UoLy0vZywnXycpfVwiXG5cdFx0ZWxzZVxuXHRcdFx0XCIke0BuYW1lLnJlcGxhY2UoLy0vZywnXycpfVwiXG5cblx0ZGVmIGlkXG5cdFx0dmFyIG0gPSBAc3RyLm1hdGNoKC9cXCMoW1xcd1xcLVxcZFxcX10rKVxcYi8pXG5cdFx0bSA/IG1bMV0gOiBudWxsXG5cdFx0XG5cblx0ZGVmIGZsYWdcblx0XHRcIl9cIiArIG5hbWUucmVwbGFjZSgvLS0vZywnXycpLnRvTG93ZXJDYXNlXG5cblx0ZGVmIHNlbFxuXHRcdFwiLntmbGFnfVwiICMgKyBuYW1lLnJlcGxhY2UoLy0vZywnXycpLnRvTG93ZXJDYXNlXG5cblx0ZGVmIHN0cmluZ1xuXHRcdHZhbHVlXG5cblxuZXhwb3J0IGNsYXNzIEFyZ3ZhciA8IFZhbHVlTm9kZVxuXG5cdGRlZiBjXG5cdFx0IyBORVhUIC0tIGdsb2JhbC5wYXJzZUludCBvciBOdW1iZXIucGFyc2VJbnQgKGJldHRlcilcblx0XHR2YXIgdiA9IHBhcnNlSW50KFN0cmluZyh2YWx1ZSkpXG5cdFx0IyBGSVhNRSBOb3QgbmVlZGVkIGFueW1vcmU/IEkgdGhpbmsgdGhlIGxleGVyIGhhbmRsZXMgdGhpc1xuXHRcdHJldHVybiBcImFyZ3VtZW50c1wiIGlmIHYgPT0gMFxuXG5cdFx0dmFyIHMgPSBzY29wZV9fXG5cdFx0IyBwYXJhbXMgbmVlZCB0byBnbyB1cCB0byB0aGUgY2xvc2VzdGUgbWV0aG9kLXNjb3BlXG5cdFx0dmFyIHBhciA9IHMucGFyYW1zLmF0KHYgLSAxLHllcylcblx0XHRcIntjX18ocGFyLm5hbWUpfVwiICMgY1xuXG5cbiMgQ0FMTFxuXG5leHBvcnQgY2xhc3MgQ2FsbCA8IE5vZGVcblxuXHRwcm9wIGNhbGxlZVxuXHRwcm9wIHJlY2VpdmVyXG5cdHByb3AgYXJnc1xuXHRwcm9wIGJsb2NrXG5cblx0ZGVmIGluaXRpYWxpemUgY2FsbGVlLCBhcmdzLCBvcGV4aXN0c1xuXHRcdEB0cmF2ZXJzZWQgPSBub1xuXHRcdEBleHByZXNzaW9uID0gbm9cblx0XHRAcGFyZW5zID0gbm9cblx0XHRAY2FjaGUgPSBudWxsXG5cdFx0QHJlY2VpdmVyID0gbnVsbFxuXHRcdEBvcGV4aXN0cyA9IG9wZXhpc3RzXG5cdFx0IyBzb21lIGF4aW9tcyB0aGF0IHNoYXJlIHRoZSBzYW1lIHN5bnRheCBhcyBjYWxscyB3aWxsIGJlIHJlZGlyZWN0ZWQgZnJvbSBoZXJlXG5cdFx0XG5cdFx0aWYgY2FsbGVlIGlzYSBWYXJPckFjY2Vzc1xuXHRcdFx0dmFyIHN0ciA9IGNhbGxlZS52YWx1ZS5zeW1ib2xcblx0XHRcdCMgcCBcIkNhbGwgY2FsbGVlIHtjYWxsZWV9IC0ge3N0cn1cIlxuXHRcdFx0aWYgc3RyID09ICdleHRlcm4nXG5cdFx0XHRcdCMgcCBcInJldHVybmluZyBleHRlcm4gaW5zdGVhZCFcIlxuXHRcdFx0XHRjYWxsZWUudmFsdWUudmFsdWUuQHR5cGUgPSAnRVhURVJOJ1xuXHRcdFx0XHRyZXR1cm4gRXh0ZXJuRGVjbGFyYXRpb24ubmV3KGFyZ3MpXG5cdFx0XHRpZiBzdHIgPT0gJ3RhZydcblx0XHRcdFx0IyBjb25zb2xlLmxvZyBcIkVSUk9SIC0gYWNjZXNzIGFyZ3MgYnkgc29tZSBtZXRob2RcIlxuXHRcdFx0XHRyZXR1cm4gVGFnV3JhcHBlci5uZXcoYXJncyBhbmQgYXJnczppbmRleCA/IGFyZ3MuaW5kZXgoMCkgOiBhcmdzWzBdKVxuXHRcdFx0aWYgc3RyID09ICdleHBvcnQnXG5cdFx0XHRcdHJldHVybiBFeHBvcnRTdGF0ZW1lbnQubmV3KGFyZ3MpXG5cblx0XHRAY2FsbGVlID0gY2FsbGVlXG5cdFx0QGFyZ3MgPSBhcmdzIG9yIEFyZ0xpc3QubmV3KFtdKVxuXG5cdFx0aWYgYXJncyBpc2EgQXJyYXlcblx0XHRcdEBhcmdzID0gQXJnTGlzdC5uZXcoYXJncylcblx0XHRcdCMgY29uc29sZS5sb2cgXCJBUkdVTUVOVFMgSVMgQVJSQVkgLSBlcnJvciB7YXJnc31cIlxuXHRcdCMgcCBcImNhbGwgb3BleGlzdHMge29wZXhpc3RzfVwiXG5cdFx0c2VsZlxuXG5cdGRlZiB2aXNpdFxuXHRcdCMgY29uc29sZS5sb2cgXCJ2aXNpdCBhcmdzIHthcmdzfVwiXG5cdFx0YXJncy50cmF2ZXJzZVxuXHRcdGNhbGxlZS50cmF2ZXJzZVxuXG5cdFx0IyBpZiB0aGUgY2FsbGVlIGlzIGEgUHJvcGVydHlBY2Nlc3MgLSBiZXR0ZXIgdG8gaW1tZWRpYXRlbHkgY2hhbmdlIGl0XG5cblx0XHRAYmxvY2sgJiYgQGJsb2NrLnRyYXZlcnNlIFxuXG5cdGRlZiBhZGRCbG9jayBibG9ja1xuXHRcdHZhciBwb3MgPSBAYXJncy5maWx0ZXIofG4saXwgbiA9PSAnJicpWzBdICMgV09VTEQgQkUgVE9LRU4gLSBDQVJFRlVMXG5cdFx0cG9zID8gYXJncy5yZXBsYWNlKHBvcyxibG9jaykgOiBhcmdzLnB1c2goYmxvY2spXG5cdFx0c2VsZlxuXG5cdGRlZiByZWNlaXZlclxuXHRcdEByZWNlaXZlciB8fD0gKGNhbGxlZSBpc2EgQWNjZXNzICYmIGNhbGxlZS5sZWZ0IHx8IE5VTEwpXG5cblx0IyBjaGVjayBpZiBhbGwgYXJndW1lbnRzIGFyZSBleHByZXNzaW9ucyAtIG90aGVyd2lzZSB3ZSBoYXZlIGFuIGlzc3VlXG5cblx0ZGVmIHNhZmVjaGFpblxuXHRcdGNhbGxlZS5zYWZlY2hhaW4gIyByZWFsbHk/XG5cblx0ZGVmIGpzIG9cblx0XHR2YXIgb3B0ID0gZXhwcmVzc2lvbjogeWVzXG5cdFx0dmFyIHJlYyA9IG51bGxcblx0XHQjIHZhciBhcmdzID0gY29tcGFjdF9fKGFyZ3MpICMgcmVhbGx5P1xuXHRcdHZhciBhcmdzID0gYXJnc1xuXG5cdFx0IyBkcm9wIHRoaXM/XG5cblx0XHR2YXIgc3BsYXQgPSBhcmdzLnNvbWUgZG8gfHZ8IHYgaXNhIFNwbGF0XG5cblx0XHR2YXIgb3V0ID0gbnVsbFxuXHRcdHZhciBsZnQgPSBudWxsXG5cdFx0dmFyIHJndCA9IG51bGxcblx0XHR2YXIgd3JhcCA9IG51bGxcblxuXHRcdHZhciBjYWxsZWUgPSBAY2FsbGVlID0gQGNhbGxlZS5ub2RlICMgZHJvcCB0aGUgdmFyIG9yIGFjY2Vzcz9cblxuXHRcdCMgaWYgY2FsbGVlIGlzYSBDYWxsICYmIGNhbGxlZS5zYWZlY2hhaW5cblx0XHQjXHR5ZXNcblxuXHRcdGlmIGNhbGxlZSBpc2EgQWNjZXNzXG5cdFx0XHRsZnQgPSBjYWxsZWUubGVmdFxuXHRcdFx0cmd0ID0gY2FsbGVlLnJpZ2h0XG5cblx0XHRpZiBjYWxsZWUgaXNhIFN1cGVyIG9yIGNhbGxlZSBpc2EgU3VwZXJBY2Nlc3Ncblx0XHRcdEByZWNlaXZlciA9IHNjb3BlX18uY29udGV4dFxuXHRcdFx0IyByZXR1cm4gXCJzdXBlcmNhbGxcIlxuXG5cdFx0IyBuZXZlciBjYWxsIHRoZSBwcm9wZXJ0eS1hY2Nlc3MgZGlyZWN0bHk/XG5cdFx0aWYgY2FsbGVlIGlzYSBQcm9wZXJ0eUFjY2VzcyAjICYmIHJlYyA9IGNhbGxlZS5yZWNlaXZlclxuXHRcdFx0IyBwIFwidW53cmFwcGluZyBwcm9wZXJ0eS1hY2Nlc3MgaW4gY2FsbFwiXG5cdFx0XHRAcmVjZWl2ZXIgPSBjYWxsZWUucmVjZWl2ZXJcblx0XHRcdGNhbGxlZSA9IEBjYWxsZWUgPSBBY2Nlc3MubmV3KGNhbGxlZS5vcCxjYWxsZWUubGVmdCxjYWxsZWUucmlnaHQpXG5cdFx0XHQjIHAgXCJnb3QgaGVyZT8ge2NhbGxlZX1cIlxuXHRcdFx0IyBjb25zb2xlLmxvZyBcInVud3JhcHBpbmcgdGhlIHByb3BlcnR5QWNjZXNzXCJcblxuXHRcdGlmIGNhbGxlZS5zYWZlY2hhaW5cblx0XHRcdCMgcCBcImNhbGxlZSBpcyBzYWZlY2hhaW5lZD8hP1wiXG5cdFx0XHQjIGlmIGxmdCBpc2EgQ2FsbFxuXHRcdFx0IyBpZiBsZnQgaXNhIENhbGwgIyBjb3VsZCBiZSBhIHByb3BlcnR5IGFjY2VzcyBhcyB3ZWxsIC0gaXQgaXMgdGhlIHNhbWU/XG5cdFx0XHQjIGlmIGl0IGlzIGEgbG9jYWwgdmFyIGFjY2VzcyB3ZSBzaW1wbHkgY2hlY2sgaWYgaXQgaXMgYSBmdW5jdGlvbiwgdGhlbiBjYWxsXG5cdFx0XHQjIGJ1dCBpdCBzaG91bGQgYmUgc2FmZWNoYWluZWQgb3V0c2lkZSBhcyB3ZWxsP1xuXHRcdFx0IyBsZnQuY2FjaGUgaWYgbGZ0XG5cdFx0XHQjIHRoZSBvdXRlciBzYWZlY2hhaW4gc2hvdWxkIG5vdCBjYWNoZSB0aGUgd2hvbGUgY2FsbCAtIG9ubHkgYXNrIHRvIGNhY2hlXG5cdFx0XHQjIHRoZSByZXN1bHQ/IC0tIGNoYWluIG9udG9cblx0XHRcdCMgcCBcIkNhbGwgc2FmZWNoYWluIHtjYWxsZWV9IHtsZnR9LntyZ3R9XCJcblx0XHRcdHZhciBpc2ZuID0gVXRpbC5Jc0Z1bmN0aW9uLm5ldyhbY2FsbGVlXSlcblx0XHRcdHdyYXAgPSBbXCJ7aXNmbi5jfSAgJiYgIFwiLFwiXCJdXG5cdFx0XHRjYWxsZWUgPSBPUCgnLicsY2FsbGVlLmxlZnQsY2FsbGVlLnJpZ2h0KVxuXHRcdFx0IyBjYWxsZWUgc2hvdWxkIGFscmVhZHkgYmUgY2FjaGVkIG5vdyAtIFxuXG5cdFx0IyBzaG91bGQganVzdCBmb3JjZSBleHByZXNzaW9uIGZyb20gdGhlIHN0YXJ0LCBubz9cblx0XHRpZiBzcGxhdFxuXHRcdFx0IyBpbXBvcnRhbnQgdG8gd3JhcCB0aGUgc2luZ2xlIHZhbHVlIGluIGEgdmFsdWUsIHRvIGtlZXAgaW1wbGljaXQgY2FsbFxuXHRcdFx0IyB0aGlzIGlzIGR1ZSB0byB0aGUgd2F5IHdlIGNoZWNrIGZvciBhbiBvdXRlciBDYWxsIHdpdGhvdXQgY2hlY2tpbmcgaWZcblx0XHRcdCMgd2UgYXJlIHRoZSByZWNlaXZlciAoaW4gUHJvcGVydHlBY2Nlc3MpLiBTaG91bGQgcmF0aGVyIHdyYXAgaW4gQ2FsbEFyZ3VtZW50c1xuXHRcdFx0bGV0IHJlYyA9IHJlY2VpdmVyXG5cdFx0XHR2YXIgYXJ5ID0gKGFyZ3MuY291bnQgPT0gMSA/IFZhbHVlTm9kZS5uZXcoYXJncy5maXJzdC52YWx1ZSkgOiBBcnIubmV3KGFyZ3MubGlzdCkpXG5cblx0XHRcdHJlYy5jYWNoZSAjIG5lZWQgdG8gY2FjaGUgdGhlIGNvbnRleHQgYXMgaXQgd2lsbCBiZSByZWZlcmVuY2VkIGluIGFwcGx5XG5cdFx0XHRvdXQgPSBcIntjYWxsZWUuYyhleHByZXNzaW9uOiB5ZXMpfS5hcHBseSh7cmVjLmN9LHthcnkuYyhleHByZXNzaW9uOiB5ZXMpfSlcIlxuXG5cdFx0ZWxpZiBAcmVjZWl2ZXJcblx0XHRcdCMgcXVpY2sgd29ya2Fyb3VuZFxuXHRcdFx0QHJlY2VpdmVyLmNhY2hlIHVubGVzcyBAcmVjZWl2ZXIgaXNhIFNjb3BlQ29udGV4dFxuXHRcdFx0YXJncy51bnNoaWZ0KHJlY2VpdmVyKVxuXHRcdFx0IyBzaG91bGQgcmF0aGVyIHJld3JpdGUgdG8gYSBuZXcgY2FsbD9cblx0XHRcdG91dCA9IFwie2NhbGxlZS5jKGV4cHJlc3Npb246IHllcyl9LmNhbGwoe2FyZ3MuYyhleHByZXNzaW9uOiB5ZXMpfSlcIlxuXG5cdFx0ZWxzZVxuXHRcdFx0b3V0ID0gXCJ7Y2FsbGVlLmMoZXhwcmVzc2lvbjogeWVzKX0oe2FyZ3MuYyhleHByZXNzaW9uOiB5ZXMpfSlcIlxuXG5cdFx0aWYgd3JhcFxuXHRcdFx0IyB3ZSBzZXQgdGhlIGNhY2hldmFyIGluc2lkZVxuXHRcdFx0IyBwIFwic3BlY2lhbCBjYWNoaW5nIGZvciBjYWxsXCJcblx0XHRcdGlmIEBjYWNoZVxuXHRcdFx0XHRAY2FjaGU6bWFudWFsID0geWVzIFxuXHRcdFx0XHRvdXQgPSBcIih7Y2FjaGV2YXIuY309e291dH0pXCJcblxuXHRcdFx0b3V0ID0gW3dyYXBbMF0sb3V0LHdyYXBbMV1dLmpvaW4oXCJcIilcblxuXHRcdHJldHVybiBvdXRcblxuXG5cblx0XHRcbmV4cG9ydCBjbGFzcyBJbXBsaWNpdENhbGwgPCBDYWxsXG5cblx0ZGVmIGpzIG9cblx0XHRcIntjYWxsZWUuY30oKVwiXG5cbmV4cG9ydCBjbGFzcyBOZXcgPCBDYWxsXG5cblx0ZGVmIGpzIG9cblx0XHR2YXIgdGFyZ2V0ID0gY2FsbGVlXG5cblx0XHR3aGlsZSB0YXJnZXQgaXNhIEFjY2Vzc1xuXHRcdFx0bGV0IGxlZnQgPSB0YXJnZXQubGVmdFxuXG5cdFx0XHRpZiAobGVmdCBpc2EgUHJvcGVydHlBY2Nlc3MpIG9yIChsZWZ0IGlzYSBWYXJPckFjY2Vzcylcblx0XHRcdFx0Y2FsbGVlLkBwYXJlbnMgPSB5ZXNcblx0XHRcdFx0YnJlYWtcblxuXHRcdFx0dGFyZ2V0ID0gbGVmdFxuXG5cdFx0dmFyIG91dCA9IFwibmV3IHtjYWxsZWUuY31cIlxuXHRcdG91dCArPSAnKCknIHVubGVzcyBvLnBhcmVudCBpc2EgQ2FsbFxuXHRcdG91dFxuXG5leHBvcnQgY2xhc3MgU3VwZXJDYWxsIDwgQ2FsbFxuXG5cdGRlZiBqcyBvXG5cdFx0dmFyIG0gPSBvLm1ldGhvZFxuXHRcdHNlbGYucmVjZWl2ZXIgPSBTRUxGXG5cdFx0c2VsZi5jYWxsZWUgPSBcInttLnRhcmdldC5jfS5zdXBlciQucHJvdG90eXBlLnttLm5hbWUuY31cIlxuXHRcdHN1cGVyXG5cblxuXG5leHBvcnQgY2xhc3MgRXh0ZXJuRGVjbGFyYXRpb24gPCBMaXN0Tm9kZVxuXG5cdGRlZiB2aXNpdFxuXG5cdFx0IyBwIFwidmlzaXRpbmcgZXh0ZXJuZGVjbGFyYXRpb25cIlxuXHRcdG5vZGVzID0gbWFwIGRvIHxpdGVtfCBpdGVtLm5vZGUgIyBkcm9wIHZhciBvciBhY2Nlc3MgcmVhbGx5XG5cdFx0IyBvbmx5IGluIGdsb2JhbCBzY29wZT9cblx0XHR2YXIgcm9vdCA9IHNjb3BlX19cblx0XHRmb3IgaXRlbSBpbiBub2Rlc1xuXHRcdFx0dmFyIHZhcmlhYmxlID0gcm9vdC5yZWdpc3RlciBpdGVtLnN5bWJvbCwgaXRlbSwgdHlwZTogJ2dsb2JhbCdcblx0XHRcdHZhcmlhYmxlLmFkZFJlZmVyZW5jZShpdGVtKVxuXHRcdHNlbGZcblxuXHRkZWYgY1xuXHRcdFwiLy8gZXh0ZXJuc1wiXHRcdFxuXHRcdFxuXG4jIEZMT1dcblxuZXhwb3J0IGNsYXNzIENvbnRyb2xGbG93IDwgTm9kZVxuXG5cblxuZXhwb3J0IGNsYXNzIENvbnRyb2xGbG93U3RhdGVtZW50IDwgQ29udHJvbEZsb3dcblxuXHRkZWYgaXNFeHByZXNzYWJsZVxuXHRcdG5vXG5cblxuXG5leHBvcnQgY2xhc3MgSWYgPCBDb250cm9sRmxvd1xuXG5cblx0cHJvcCB0ZXN0XG5cdHByb3AgYm9keVxuXHRwcm9wIGFsdFxuXHRwcm9wIHNjb3BlXG5cblx0ZGVmIHNlbGYudGVybmFyeSBjb25kLCBib2R5LCBhbHRcblx0XHQjIHByZWZlciB0byBjb21waWxlIGl0IHRoaXMgd2F5IGFzIHdlbGxcblx0XHR2YXIgb2JqID0gSWYubmV3KGNvbmQsIEJsb2NrLm5ldyhbYm9keV0pLCB0eXBlOiAnPycpXG5cdFx0b2JqLmFkZEVsc2UgQmxvY2submV3KFthbHRdKVxuXHRcdHJldHVybiBvYmpcblxuXHRkZWYgYWRkRWxzZSBhZGRcblx0XHQjIHAgXCJhZGQgZWxzZSFcIixhZGRcblx0XHRpZiBhbHQgJiYgYWx0IGlzYSBJZlxuXHRcdFx0IyBwICdhZGQgdG8gdGhlIGlubmVyIGVsc2UoISknLGFkZFxuXHRcdFx0YWx0LmFkZEVsc2UoYWRkKVxuXHRcdGVsc2Vcblx0XHRcdHNlbGYuYWx0ID0gYWRkXG5cdFx0c2VsZlxuXG5cblx0ZGVmIGluaXRpYWxpemUgY29uZCwgYm9keSwgbyA9IHt9XG5cdFx0c2V0dXBcblx0XHRAdGVzdCA9IGNvbmQgIyAobzp0eXBlID09ICd1bmxlc3MnID8gVW5hcnlPcC5uZXcoJyEnLGNvbmQsbnVsbCkgOiBjb25kKVxuXHRcdEBib2R5ID0gYm9keVxuXHRcdEBhbHQgID0gbnVsbFxuXHRcdEB0eXBlID0gbzp0eXBlXG5cdFx0aW52ZXJ0IGlmIEB0eXBlID09ICd1bmxlc3MnXG5cdFx0QHNjb3BlID0gSWZTY29wZS5uZXcoc2VsZilcblx0XHRzZWxmXG5cblx0ZGVmIGludmVydFxuXHRcdGlmIEB0ZXN0IGlzYSBDb21wYXJpc29uT3Bcblx0XHRcdEB0ZXN0ID0gQHRlc3QuaW52ZXJ0XG5cdFx0ZWxzZVxuXHRcdFx0QHRlc3QgPSBVbmFyeU9wLm5ldygnIScsQHRlc3QsbnVsbClcblxuXHRkZWYgdmlzaXRcblx0XHR2YXIgYWx0ID0gYWx0XG5cblx0XHRAc2NvcGUudmlzaXQgaWYgQHNjb3BlXG5cdFx0dGVzdC50cmF2ZXJzZSBpZiB0ZXN0XG5cdFx0Ym9keS50cmF2ZXJzZSBpZiBib2R5XG5cblx0XHQjIHNob3VsZCBza2lwIHRoZSBzY29wZSBpbiBhbHQuXG5cdFx0aWYgYWx0XG5cdFx0XHQjIHAgXCJzY29waW5nIHtTVEFDSy5zY29wZXM6bGVuZ3RofVwiXG5cdFx0XHRTVEFDSy5wb3Aoc2VsZilcblx0XHRcdGFsdC5Ac2NvcGUgfHw9IEJsb2NrU2NvcGUubmV3KGFsdClcblx0XHRcdGFsdC50cmF2ZXJzZVxuXHRcdFx0U1RBQ0sucHVzaChzZWxmKVxuXG5cdFx0IyBmb3JjZSBpdCBhcyBleHByZXNzaW9uP1xuXHRcdHRvRXhwcmVzc2lvbiBpZiBAdHlwZSA9PSAnPycgYW5kIGlzRXhwcmVzc2FibGVcblx0XHRzZWxmXG5cblxuXHRkZWYganMgb1xuXHRcdHZhciBib2R5ID0gYm9keVxuXHRcdCMgd291bGQgcG9zc2libHkgd2FudCB0byBsb29rIHVwIC8gb3V0IFxuXHRcdHZhciBicmFjZSA9IGJyYWNlczogeWVzLCBpbmRlbnQ6IHllc1xuXG5cdFx0dmFyIGNvbmQgPSB0ZXN0LmMoZXhwcmVzc2lvbjogeWVzKSAjIHRoZSBjb25kaXRpb24gaXMgYWx3YXlzIGFuIGV4cHJlc3Npb25cblxuXHRcdGlmIG8uaXNFeHByZXNzaW9uXG5cdFx0XHR2YXIgY29kZSA9IGJvZHkuYyAjIChicmFjZXM6IHllcylcblx0XHRcdGNvZGUgPSAnKCcgKyBjb2RlICsgJyknICMgaWYgY29kZS5pbmRleE9mKCcsJykgPj0gMFxuXHRcdFx0IyBpcyBleHByZXNzaW9uIVxuXHRcdFx0aWYgYWx0XG5cdFx0XHRcdCMgY29uc29sZS5sb2cgXCJ0eXBlIG9mIHRlcm5hcnkge3Rlc3R9XCJcblx0XHRcdFx0IyBiZSBzYWZlIC0gd3JhcCBjb25kaXRpb24gYXMgd2VsbFxuXHRcdFx0XHQjIGFzayBmb3IgcGFyZW5zXG5cdFx0XHRcdHJldHVybiBcIntjb25kfSA/IHtjb2RlfSA6ICh7YWx0LmN9KVwiXG5cdFx0XHRlbHNlXG5cdFx0XHRcdCMgYWdhaW4gLSB3ZSBuZWVkIGEgYmV0dGVyIHdheSB0byBkZWNpZGUgd2hhdCBuZWVkcyBwYXJlbnNcblx0XHRcdFx0IyBtYXliZSBiZXR0ZXIgaWYgd2UgcmV3cml0ZSB0aGlzIHRvIGFuIE9QKCcmJicpLCBhbmQgcHV0XG5cdFx0XHRcdCMgdGhlIHBhcmVucyBsb2dpYyB0aGVyZVxuXHRcdFx0XHQjIGNvbmQgc2hvdWxkIHBvc3NpYmx5IGhhdmUgcGFyZW5zIC0gYnV0IHdoZXJlIGRvIHdlIGRlY2lkZT9cblx0XHRcdFx0aWYgQHRhZ3RyZWVcblx0XHRcdFx0XHRyZXR1cm4gXCIoe2NvbmR9KSA/IHtjb2RlfSA6IHZvaWQoMClcIlx0XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRyZXR1cm4gXCIoe2NvbmR9KSAmJiB7Y29kZX1cIlxuXHRcdGVsc2Vcblx0XHRcdCMgaWYgdGhlcmUgaXMgb25seSBhIHNpbmdsZSBpdGVtIC0gYW5kIGl0IGlzIGFuIGV4cHJlc3Npb24/XG5cdFx0XHR2YXIgY29kZSA9IG51bGxcblx0XHRcdCMgaWYgYm9keS5jb3VudCA9PSAxICMgZG9udCBpbmRlbnQgYnkgb3Vyc2VsdmVzP1xuXG5cdFx0XHRpZiBib2R5IGlzYSBCbG9jayBhbmQgYm9keS5jb3VudCA9PSAxIGFuZCAhKGJvZHkuZmlyc3QgaXNhIExvb3BGbG93U3RhdGVtZW50KVxuXHRcdFx0XHQjIHAgXCJib2R5IHRvIGJvZHkgZmlyc3Qge2JvZHkuZmlyc3R9XCJcblx0XHRcdFx0Ym9keSA9IGJvZHkuZmlyc3RcblxuXHRcdFx0IyBpZiBib2R5LmNvdW50ID09IDFcblx0XHRcdCNcdHAgXCJvbmUgaXRlbSBvbmx5IVwiXG5cdFx0XHQjXHRib2R5ID0gYm9keS5maXJzdFxuXG5cdFx0XHRjb2RlID0gYm9keS5jKGJyYWNlczogeWVzKSAjIChicmFjZXM6IHllcylcblxuXHRcdFx0IyBkb24ndCB3cmFwIGlmIGl0IGlzIG9ubHkgYSBzaW5nbGUgZXhwcmVzc2lvbj9cblx0XHRcdHZhciBvdXQgPSBcInttYXJrX18oQHR5cGUpfWlmICh7Y29uZH0pIFwiICsgY29kZSAjICcgeycgKyBjb2RlICsgJ30nICMgJ3snICsgY29kZSArICd9J1xuXHRcdFx0b3V0ICs9IFwiIGVsc2Uge2FsdC5jKGFsdCBpc2EgSWYgPyB7fSA6IGJyYWNlKX1cIiBpZiBhbHRcblx0XHRcdG91dFxuXG5cdGRlZiBzb3VyY2VNYXBNYXJrZXJcblx0XHRzZWxmXG5cblx0ZGVmIGNvbnN1bWUgbm9kZVxuXHRcdCMgcCAnYXNzaWduaWZ5IGlmPyEnXG5cdFx0IyBpZiBpdCBpcyBwb3NzaWJsZSwgY29udmVydCBpbnRvIGV4cHJlc3Npb25cblx0XHRpZiBub2RlIGlzYSBUYWdUcmVlXG5cdFx0XHRAYm9keSA9IEBib2R5LmNvbnN1bWUobm9kZSlcblx0XHRcdEBhbHQgPSBAYWx0LmNvbnN1bWUobm9kZSkgaWYgQGFsdFxuXHRcdFx0QHRhZ3RyZWUgPSBub2RlXG5cdFx0XHRyZXR1cm4gc2VsZlxuXG5cdFx0IyBzcGVjaWFsIGNhc2UgZm9yIElmIGNyZWF0ZWQgZnJvbSBjb25kaXRpb25hbCBhc3NpZ24gYXMgd2VsbD9cblx0XHQjIEB0eXBlID09ICc/JyBhbmQgXG5cdFx0IyBpZGVhbGx5IHdlIGRvbnQgcmVhbGx5IHdhbnQgdG8gbWFrZSBhbnkgZXhwcmVzc2lvbiBsaWtlIHRoaXMgYnkgZGVmYXVsdFxuXHRcdHZhciBpc1JldCA9IG5vZGUgaXNhIFJldHVyblxuXG5cdFx0IyBtaWdodCBoYXZlIGJlZW4gZm9yY2VkIHRvIGV4cHJlc3Npb24gYWxyZWFkeVxuXHRcdCMgaWYgaXQgd2FzIG9yaWdpbmFsbHkgYSB0ZXJuYXJ5IC0gd2h5IG5vdFxuXHRcdGlmIEBleHByZXNzaW9uIG9yICgoIWlzUmV0IG9yIEB0eXBlID09ICc/JykgYW5kIGlzRXhwcmVzc2FibGUpXG5cdFx0XHR0b0V4cHJlc3Npb24gIyBtYXJrIGFzIGV4cHJlc3Npb24oISkgLSBpcyB0aGlzIG5lZWRlZD9cblx0XHRcdHJldHVybiBzdXBlcihub2RlKVxuXHRcdGVsc2Vcblx0XHRcdEBib2R5ID0gQGJvZHkuY29uc3VtZShub2RlKVxuXHRcdFx0QGFsdCA9IEBhbHQuY29uc3VtZShub2RlKSBpZiBAYWx0XG5cdFx0c2VsZlxuXG5cblx0ZGVmIGlzRXhwcmVzc2FibGVcblx0XHQjIHByb2Nlc3M6c3Rkb3V0LndyaXRlICd4J1xuXHRcdHZhciBleHAgPSBib2R5LmlzRXhwcmVzc2FibGUgJiYgKCFhbHQgfHwgYWx0LmlzRXhwcmVzc2FibGUpXG5cdFx0cmV0dXJuIGV4cFxuXG5cblxuZXhwb3J0IGNsYXNzIExvb3AgPCBTdGF0ZW1lbnRcblxuXG5cdHByb3Agc2NvcGVcblx0cHJvcCBvcHRpb25zXG5cdHByb3AgYm9keVxuXHRwcm9wIGNhdGNoZXJcblxuXG5cdGRlZiBpbml0aWFsaXplIG9wdGlvbnMgPSB7fVxuXHRcdEB0cmF2ZXJzZWQgPSBub1xuXHRcdEBvcHRpb25zID0gb3B0aW9uc1xuXHRcdEBib2R5ID0gbnVsbFxuXHRcdHNlbGZcblxuXG5cdGRlZiBzZXQgb2JqXG5cdFx0IyBwIFwiY29uZmlndXJlIGZvciFcIlxuXHRcdEBvcHRpb25zIHx8PSB7fVxuXHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKVxuXHRcdGZvciBrIGluIGtleXNcblx0XHRcdEBvcHRpb25zW2tdID0gb2JqW2tdXG5cdFx0c2VsZlxuXG5cblx0ZGVmIGFkZEJvZHkgYm9keVxuXHRcdHNlbGYuYm9keSA9IGJsa19fKGJvZHkpXG5cdFx0c2VsZlxuXG5cblx0ZGVmIGMgb1xuXG5cdFx0dmFyIHMgPSBzdGFja1xuXHRcdHZhciBjdXJyID0gcy5jdXJyZW50XG5cdFx0IyBwIFwiTG9vcC5jIC0ge2lzRXhwcmVzc2FibGV9IHtzdGFja30ge3N0YWNrLmlzRXhwcmVzc2lvbn1cIlxuXHRcdCMgcCBcInN0YWNrIGlzIGV4cHJlc3Npb24/IHtvfSB7aXNFeHByZXNzaW9ufVwiXG5cblxuXG5cdFx0aWYgc3RhY2suaXNFeHByZXNzaW9uIG9yIGlzRXhwcmVzc2lvblxuXHRcdFx0IyBwIFwidGhlIHN0YWNrIGlzIGFuIGV4cHJlc3Npb24gZm9yIGxvb3Agbm93KCEpXCJcblx0XHRcdCMgd2hhdCB0aGUgaW5uZXIgb25lIHNob3VsZCBub3QgYmUgYW4gZXhwcmVzc2lvbiB0aG91Z2g/XG5cdFx0XHQjIHRoaXMgd2lsbCByZXN1dCBpbiBhbiBpbmZpbml0ZSBsb29wLCBubz8hP1xuXHRcdFx0dmFyIGFzdCA9IENBTEwoRk4oW10sW3NlbGZdKSxbXSlcblx0XHRcdHJldHVybiBhc3QuYyBvXG5cdFx0XG5cdFx0ZWxpZiBzdGFjay5jdXJyZW50IGlzYSBCbG9jayBvciAocy51cCBpc2EgQmxvY2sgYW5kIHMuY3VycmVudC5AY29uc3VtZXIgPT0gc2VsZilcblx0XHRcblx0XHRcdCMgcCBcIndoYXQgaXMgdGhlIGN1cnJlbnQgc3RhY2sgb2YgbG9vcD8ge3N0YWNrLmN1cnJlbnR9XCJcblx0XHRcdHN1cGVyLmMgb1xuXHRcdGVsc2Vcblx0XHRcdCMgcCBcIlNob3VsZCBuZXZlciBnZXQgaGVyZT8hP1wiXG5cdFx0XHR2YXIgYXN0ID0gQ0FMTChGTihbXSxbc2VsZl0pLFtdKVxuXHRcdFx0cmV0dXJuIGFzdC5jIG9cblx0XHRcdCMgbmVlZCB0byB3cmFwIGluIGZ1bmN0aW9uXG5cblxuXG5leHBvcnQgY2xhc3MgV2hpbGUgPCBMb29wXG5cblxuXHRwcm9wIHRlc3RcblxuXG5cdGRlZiBpbml0aWFsaXplIHRlc3QsIG9wdHNcblx0XHRAdHJhdmVyc2VkID0gbm9cblx0XHRAdGVzdCA9IHRlc3Rcblx0XHRAb3B0aW9ucyA9IG9wdHMgb3Ige31cblx0XHRAc2NvcGUgPSBXaGlsZVNjb3BlLm5ldyhzZWxmKVxuXHRcdCMgc2V0KG9wdHMpIGlmIG9wdHNcblx0XHQjIHAgXCJpbnZlcnQgdGVzdCBmb3Igd2hpbGU/IHtAdGVzdH1cIlxuXHRcdGlmIG9wdGlvbig6aW52ZXJ0KVxuXHRcdFx0IyBcImludmVydCB0ZXN0IGZvciB3aGlsZSB7QHRlc3R9XCJcblx0XHRcdEB0ZXN0ID0gdGVzdC5pbnZlcnQgXG5cdFx0IyBpbnZlcnQgdGhlIHRlc3RcblxuXG5cdGRlZiB2aXNpdFxuXHRcdHNjb3BlLnZpc2l0XG5cdFx0dGVzdC50cmF2ZXJzZSBpZiB0ZXN0XG5cdFx0Ym9keS50cmF2ZXJzZSBpZiBib2R5XG5cblxuXHQjIFRPRE8gQlVHIC0tIHdoZW4gd2UgZGVjbGFyZSBhIHZhciBsaWtlOiB3aGlsZSB2YXIgeSA9IC4uLlxuXHQjIHRoZSB2YXJpYWJsZSB3aWxsIGJlIGRlY2xhcmVkIGluIHRoZSBXaGlsZVNjb3BlIHdoaWNoIG5ldmVyXG5cdCMgZm9yY2UtZGVjbGFyZXMgdGhlIGlubmVyIHZhcmlhYmxlcyBpbiB0aGUgc2NvcGVcblxuXHRkZWYgY29uc3VtZSBub2RlXG5cdFx0IyBwIFwiV2hpbGUuY29uc3VtZSB7bm9kZX1cIi5jeWFuXG5cdFx0IyBUaGlzIGlzIG5ldmVyIGV4cHJlc3NhYmxlLCBidXQgYXQgc29tZSBwb2ludFxuXHRcdCMgd2UgbWlnaHQgd2FudCB0byB3cmFwIGl0IGluIGEgZnVuY3Rpb24gKGxpa2UgQ1MpXG5cdFx0cmV0dXJuIHN1cGVyIGlmIGlzRXhwcmVzc2FibGVcblxuXHRcdGlmIG5vZGUgaXNhIFRhZ1RyZWVcblx0XHRcdCMgV0FSTiB0aGlzIGlzIGEgaGFjayB0byBhbGxvdyByZWZlcmVuY2VzIGNvbWluZyB0aHJvdWdoIHRoZSB3cmFwcGluZyBzY29wZSBcblx0XHRcdCMgd2lsbCByZXN1bHQgaW4gdW5uZWVkZWQgc2VsZi1kZWNsYXJhdGlvbnMgYW5kIG90aGVyIG9kZGl0aWVzXG5cdFx0XHRzY29wZS5jb250ZXh0LnJlZmVyZW5jZVxuXHRcdFx0cmV0dXJuIENBTEwoRk4oW10sW3NlbGZdKSxbXSlcblxuXHRcdHZhciByZXVzZSA9IG5vXG5cdFx0IyBXQVJOIE9wdGltaXphdGlvbiAtIG1pZ2h0IGhhdmUgdW50ZW5kZWQgc2lkZS1lZmZlY3RzXG5cdFx0IyBpZiB3ZSBhcmUgYXNzaWduaW5nIGRpcmVjdGx5IHRvIGEgbG9jYWwgdmFyaWFibGUsIHdlIHNpbXBseVxuXHRcdCMgdXNlIHNhaWQgdmFyaWFibGUgZm9yIHRoZSBpbm5lciByZXNcblx0XHQjIGlmIHJldXNlXG5cdFx0IyBcdHJlc3ZhciA9IHNjb3BlLmRlY2xhcmUobm9kZS5sZWZ0Lm5vZGUudmFyaWFibGUsQXJyLm5ldyhbXSkscHJveHk6IHllcylcblx0XHQjIFx0bm9kZSA9IG51bGxcblx0XHQjIFx0cCBcImNvbnN1bWUgdmFyaWFibGUgZGVjbGFyYXRvciE/XCIuY3lhblxuXHRcdCMgZWxzZVxuXHRcdCMgZGVjbGFyZSB0aGUgdmFyaWFibGUgd2Ugd2lsbCB1c2UgdG8gc29hayB1cCByZXN1bHRzXG5cdFx0IyBwIFwiQ3JlYXRpbmcgdmFsdWUgdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiBsb29wXCIuY3lhblxuXHRcdCMgVE9ETyBVc2UgYSBzcGVjaWFsIHZhcnR5cGUgZm9yIHRoaXM/XG5cdFx0dmFyIHJlc3ZhciA9IHNjb3BlLmRlY2xhcmUoOnJlcyxBcnIubmV3KFtdKSxzeXN0ZW06IHllcylcblx0XHQjIFdIQVQgLS0gZml4IHRoaXMgLS1cblx0XHRAY2F0Y2hlciA9IFB1c2hBc3NpZ24ubmV3KFwicHVzaFwiLHJlc3ZhcixudWxsKSAjIHRoZSB2YWx1ZSBpcyBub3QgcHJlc2V0ICMgd2hhdFxuXHRcdGJvZHkuY29uc3VtZShAY2F0Y2hlcikgIyBzaG91bGQgc3RpbGwgcmV0dXJuIHRoZSBzYW1lIGJvZHlcblxuXHRcdCMgc2NvcGUgdmFycyBtdXN0IG5vdCBiZSBjb21waWxlZCBiZWZvcmUgdGhpcyAtLSB0aGlzIGlzIGltcG9ydGFudFxuXHRcdHZhciBhc3QgPSBCbG9jay5uZXcoW3NlbGYscmVzdmFyLmFjY2Vzc29yXSkgIyBzaG91bGQgYmUgdmFyYWNjZXNzIGluc3RlYWQ/XG5cdFx0YXN0LmNvbnN1bWUobm9kZSlcblx0XHQjIE5PVEUgSGVyZSB3ZSBjYW4gZmluZCBhIHdheSB0byBrbm93IHdoZXRlciBvciBub3Qgd2UgZXZlbiBuZWVkIHRvIFxuXHRcdCMgcmV0dXJuIHRoZSByZXN2YXIuIE9mdGVuIGl0IHdpbGwgbm90IGJlIG5lZWRlZFxuXHRcdCMgRklYTUUgd2hhdCBoYXBwZW5zIGlmIHRoZXJlIGlzIG5vIG5vZGU/IT9cblxuXG5cdGRlZiBqcyBvXG5cdFx0dmFyIG91dCA9IFwid2hpbGUgKHt0ZXN0LmMoZXhwcmVzc2lvbjogeWVzKX0pXCIgKyBib2R5LmMoYnJhY2VzOiB5ZXMsIGluZGVudDogeWVzKSAjIC53cmFwXG5cblx0XHRpZiBzY29wZS52YXJzLmNvdW50ID4gMFxuXHRcdFx0IyBwIFwid2hpbGUtYmxvY2sgaGFzIGRlY2xhcmVkIHZhcmlhYmxlcyghKVwiXG5cdFx0XHRyZXR1cm4gW3Njb3BlLnZhcnMuYyxvdXRdXG5cdFx0b3V0XG5cblxuXG4jIFRoaXMgc2hvdWxkIGRlZmluZSBhbiBvcGVuIHNjb3BlXG4jIHNob3VsZCByYXRoZXIgXG5leHBvcnQgY2xhc3MgRm9yIDwgTG9vcFxuXG5cblx0ZGVmIGluaXRpYWxpemUgbyA9IHt9XG5cdFx0QHRyYXZlcnNlZCA9IG5vXG5cdFx0QG9wdGlvbnMgPSBvXG5cdFx0QHNjb3BlID0gRm9yU2NvcGUubmV3KHNlbGYpXG5cdFx0QGNhdGNoZXIgPSBudWxsXG5cblx0ZGVmIHZpc2l0XG5cdFx0c2NvcGUudmlzaXRcblx0XHRvcHRpb25zWzpzb3VyY2VdLnRyYXZlcnNlICMgd2hhdCBhYm91dCBhd2FrZW5pbmcgdGhlIHZhcnMgaGVyZT9cblx0XHRkZWNsYXJlXG5cdFx0IyBzaG91bGQgYmUgYWJsZSB0byB0b2dnbGUgd2hldGhlciB0byBrZWVwIHRoZSByZXN1bHRzIGhlcmUgYWxyZWFkeSghKVxuXG5cdFx0IyBhZGQgZ3VhcmQgdG8gYm9keVxuXHRcdGlmIG9wdGlvbnM6Z3VhcmRcblx0XHRcdHZhciBvcCA9IElGKG9wdGlvbnM6Z3VhcmQuaW52ZXJ0LEJsb2NrLndyYXAoW0NvbnRpbnVlU3RhdGVtZW50Lm5ldyhcImNvbnRpbnVlXCIpXSkpXG5cdFx0XHRib2R5LnVuc2hpZnQob3AsQlIpXG5cblx0XHRib2R5LnRyYXZlcnNlXG5cdFx0XG5cdGRlZiBpc0JhcmUgc3JjXG5cdFx0c3JjIGFuZCBzcmMuQHZhcmlhYmxlIGFuZCBzcmMuQHZhcmlhYmxlLkBpc0FycmF5XG5cblx0ZGVmIGRlY2xhcmVcblx0XHR2YXIgbyA9IG9wdGlvbnNcblx0XHR2YXIgc2NvcGUgPSBzY29wZVxuXHRcdHZhciBzcmMgID0gbzpzb3VyY2Vcblx0XHR2YXIgdmFycyA9IG9bOnZhcnNdID0ge31cblx0XHR2YXIgb2kgICA9IG86aW5kZXhcblxuXHRcdHZhciBiYXJlID0gaXNCYXJlKHNyYylcblx0XHQjIHAgXCJzb3VyY2UgaXMgYSB7c3JjfSAtIHtiYXJlfVwiXG5cdFx0IyB2YXIgaSA9IHZhcnM6aW5kZXggPSBvaSA/IHNjb3BlLmRlY2xhcmUob2ksMCkgOiB1dGlsLmNvdW50ZXIoMCx5ZXMpLnByZWRlY2xhcmVcblxuXHRcdCMgd2hhdCBhYm91dCBhIHJhbmdlIHdoZXJlIHdlIGFsc28gaW5jbHVkZSBhbiBpbmRleD9cblx0XHRpZiBzcmMgaXNhIFJhbmdlXG5cdFx0XHQjIHAgXCJyYW5nZSBmb3ItbG9vcFwiXG5cblx0XHRcdCMgcmVhbGx5PyBkZWNsYXJlPyBcblx0XHRcdCMgYXJlIHdlIHN1cmU/IF9yZWFsbHlfP1xuXHRcdFx0dmFyczpsZW4gPSBzY29wZS5kZWNsYXJlKCdsZW4nLHNyYy5yaWdodCkgIyB1dGlsLmxlbihvLHllcykucHJlZGVjbGFyZVxuXHRcdFx0IyBtYWtlIHRoZSBzY29wZSBiZSB0aGUgZGVjbGFyYXRvclxuXHRcdFx0IyBUT0RPIHdvdWxkIGxpa2UgdG8gYmUgYWJsZSB0byBoYXZlIGNvdW50ZXIgaW4gcmFuZ2UgYXMgd2VsbFxuXHRcdFx0dmFyczppbmRleCA9IHNjb3BlLnJlZ2lzdGVyKG86bmFtZSxzY29wZSx0eXBlOiAnbGV0JywgZGVjbGFyZWQ6IHllcylcblx0XHRcdCMgcCBcInJlZ2lzdGVyZWQge3ZhcnM6aW5kZXg6Y29uc3RydWN0b3J9XCJcblx0XHRcdCMgcCBcImluZGV4LXZhciBpcyBkZWNsYXJlb2Q/IT8hIHt2YXJzOmluZGV4LkBkZWNsYXJlZH1cIlxuXHRcdFx0c2NvcGUudmFycy5wdXNoKHZhcnM6aW5kZXguYXNzaWdubWVudChzcmMubGVmdCkpXG5cdFx0XHQjIHNjb3BlLmRlY2xhcmUob3B0aW9uczpuYW1lLHNyYy5sZWZ0KVxuXHRcdFx0dmFyczp2YWx1ZSA9IHZhcnM6aW5kZXhcblx0XHRlbHNlXG5cdFx0XHQjIHZhcnM6dmFsdWUgPSBzY29wZS5kZWNsYXJlKG9wdGlvbnM6bmFtZSxudWxsLGxldDogeWVzKVxuXHRcdFx0IyB3ZSBhcmUgdXNpbmcgYXV0b21hdGljIGNhY2hpbmcgZmFyIHRvbyBtdWNoIGhlcmVcblxuXHRcdFx0IyB3ZSBzaG91bGQgc2ltcGx5IGNoYW5nZSBob3cgZGVjbGFyZSB3b3Jrc1xuXHRcdFx0dmFyIGkgPSB2YXJzOmluZGV4ID0gb2kgPyBzY29wZS5kZWNsYXJlKG9pLDAsdHlwZTogJ2xldCcpIDogdXRpbC5jb3VudGVyKDAseWVzLHNjb3BlKS5wcmVkZWNsYXJlXG5cblx0XHRcdHZhcnM6c291cmNlID0gYmFyZSA/IHNyYyA6IHV0aWwuaXRlcmFibGUoc3JjLHllcykucHJlZGVjbGFyZVxuXHRcdFx0dmFyczpsZW4gICAgPSB1dGlsLmxlbih2YXJzOnNvdXJjZSx5ZXMpLnByZWRlY2xhcmVcblxuXHRcdFx0dmFyczp2YWx1ZSA9IHNjb3BlLmRlY2xhcmUobzpuYW1lLG51bGwsdHlwZTogJ2xldCcpXG5cdFx0XHR2YXJzOnZhbHVlLmFkZFJlZmVyZW5jZShvOm5hbWUpICMgYWRkaW5nIHJlZmVyZW5jZSFcblx0XHRcdGkuYWRkUmVmZXJlbmNlKG9pKSBpZiBvaVxuXG5cdFx0cmV0dXJuIHNlbGZcblxuXG5cdGRlZiBjb25zdW1lIG5vZGVcblxuXHRcdGlmIGlzRXhwcmVzc2FibGVcblx0XHRcdHJldHVybiBzdXBlciBcblxuXHRcdCMgb3RoZXIgY2FzZXMgYXMgd2VsbCwgbm8/XG5cdFx0aWYgbm9kZSBpc2EgVGFnVHJlZVxuXHRcdFx0c2NvcGUuY29udGV4dC5yZWZlcmVuY2Vcblx0XHRcdHZhciByZWYgPSBub2RlLnJvb3QucmVmZXJlbmNlXG5cdFx0XHRub2RlLkBsb29wID0gc2VsZlxuXG5cdFx0XHQjIFNob3VsZCBub3QgYmUgY29uc3VtZWQgdGhlIHNhbWUgd2F5XG5cdFx0XHRib2R5LmNvbnN1bWUobm9kZSlcblx0XHRcdG5vZGUuQGxvb3AgPSBudWxsXG5cdFx0XHRsZXQgZm4gPSBMYW1iZGEubmV3KFtQYXJhbS5uZXcocmVmKV0sW3NlbGZdKVxuXHRcdFx0Zm4uc2NvcGUud3JhcChzY29wZSlcblx0XHRcdCMgVE9ETyBTY29wZSBvZiBnZW5lcmF0ZWQgbGFtYmRhIHNob3VsZCBiZSBhZGRlZCBpbnRvIHN0YWNrIGZvclxuXHRcdFx0IyB2YXJpYWJsZSBuYW1pbmcgLyByZXNvbHV0aW9uXG5cdFx0XHRyZXR1cm4gQ0FMTChmbixbcmVmXSlcblxuXG5cdFx0aWYgQHJlc3ZhclxuXHRcdFx0IyBwIFwiYWxyZWFkeSBoYXZlIGEgcmVzdmFyIC0tIGNoYW5nZSBjb25zdW1lPyB7bm9kZX1cIlxuXHRcdFx0dmFyIGFzdCA9IEJsb2NrLm5ldyhbc2VsZixCUixAcmVzdmFyLmFjY2Vzc29yXSlcblx0XHRcdGFzdC5jb25zdW1lKG5vZGUpXG5cdFx0XHRyZXR1cm4gYXN0XG5cdFx0XG5cdFx0IyBpZiBub2RlIGlzYSByZXR1cm4gLS0gZG8gc29tZXRoaW5nIGVsc2VcblxuXHRcdHZhciByZXN2YXIgPSBudWxsXG5cdFx0dmFyIHJldXNlYWJsZSA9IG5vICMgbm9kZSBpc2EgQXNzaWduICYmIG5vZGUubGVmdC5ub2RlIGlzYSBMb2NhbFZhckFjY2Vzc1xuXHRcdHZhciBhc3NpZ25lZSA9IG51bGxcblx0XHQjIG1pZ2h0IG9ubHkgd29yayBmb3IgbG9jYWxzP1xuXHRcdGlmIG5vZGUgaXNhIEFzc2lnblxuXHRcdFx0IyBwIFwibm9kZSBpc2EgYXNzaWduIHtub2RlfSB7bm9kZS5sZWZ0fVwiXG5cdFx0XHRpZiB2YXIgcmVjZWl2ZXIgPSBub2RlLmxlZnRcblx0XHRcdFx0aWYgYXNzaWduZWUgPSByZWNlaXZlci5AdmFyaWFibGVcblx0XHRcdFx0XHQjIHdlIGNhbiBvbmx5IHB1bGwgdGhlIHZhciByZWZlcmVuY2UgaW50byB0aGUgc2NvcGVcblx0XHRcdFx0XHQjIGlmIHdlIGtub3cgdGhhdCB0aGUgdmFyaWFibGUgaXMgZGVjbGFyZWQgaW4gdGhpcyBzY29wZVxuXHRcdFx0XHRcdHJldXNlYWJsZSA9IChyZWNlaXZlciBpc2EgVmFyUmVmZXJlbmNlKVxuXG5cdFx0IyBwIFwicmV1c2FibGU/IT8hIHtub2RlfSB7bm9kZX1cIlxuXG5cdFx0IyBXQVJOIE9wdGltaXphdGlvbiAtIG1pZ2h0IGhhdmUgdW50ZW5kZWQgc2lkZS1lZmZlY3RzXG5cdFx0IyBpZiB3ZSBhcmUgYXNzaWduaW5nIGRpcmVjdGx5IHRvIGEgbG9jYWwgdmFyaWFibGUsIHdlIHNpbXBseVxuXHRcdCMgdXNlIHNhaWQgdmFyaWFibGUgZm9yIHRoZSBpbm5lciByZXNcblx0XHRpZiByZXVzZWFibGUgYW5kIGFzc2lnbmVlXG5cdFx0XHQjIGluc3RlYWQgb2YgZGVjbGFyaW5nIGl0IGluIHRoZSBzY29wZSAtIHdoeSBub3QgZGVjbGFyZSBpdCBvdXRzaWRlP1xuXHRcdFx0IyBpdCBtaWdodCBhbHJlYWR5IGV4aXN0IGluIHRoZSBvdXRlciBzY29wZSBubz9cblx0XHRcdCMgcCBcInJldXNlYWJsZSB7YXNzaWduZWV9IHtzY29wZX0ge3Njb3BlLnBhcmVudC5sb29rdXAoYXNzaWduZWUpfVwiXG5cdFx0XHQjIGFzc2lnbmVlLnJlc29sdmVcblx0XHRcdCMgc2hvdWxkIHByb2JhYmx5IGluc3RlYWQgYWx0ZXIgdGhlIGFzc2lnbi1ub2RlIHRvIHNldCB2YWx1ZSB0byBhIGJsYW5rIGFycmF5XG5cdFx0XHQjIHJlc3ZhciA9IHNjb3BlLnBhcmVudC5kZWNsYXJlKGFzc2lnbmVlLEFyci5uZXcoW10pLHByb3h5OiB5ZXMscG9zOiAwKVxuXG5cdFx0XHQjIHRoaXMgdmFyaWFibGUgc2hvdWxkIHJlYWxseSBub3QgYmUgcmVkZWNsYXJlZCBpbnNpZGUgaGVyZSBhdCBhbGxcblx0XHRcdGFzc2lnbmVlLnJlc29sdmVcblx0XHRcdCMgcmVzdmFyID0gQHJlc3ZhciA9IHNjb3BlLmRlY2xhcmUoYXNzaWduZWUsQXJyLm5ldyhbXSkscHJveHk6IHllcylcblxuXHRcdFx0IyBkb250IGRlY2xhcmUgaXQgLSBzaW1wbHkgcHVzaCBhbiBhc3NpZ24gaW50byB0aGUgdmFyZGVjbCBvZiBzY29wZVxuXHRcdFx0c2NvcGUudmFycy51bnNoaWZ0KE9QKCc9Jyxhc3NpZ25lZSxBcnIubmV3KFtdKSkpXG5cdFx0XHRyZXN2YXIgPSBAcmVzdmFyID0gYXNzaWduZWVcblxuXHRcdFx0bm9kZS5AY29uc3VtZXIgPSBzZWxmXG5cdFx0XHRub2RlID0gbnVsbFxuXG5cdFx0XHQjIHAgXCJjb25zdW1lIHZhcmlhYmxlIGRlY2xhcmF0b3IhP1wiLmN5YW5cblx0XHRlbHNlXG5cdFx0XHQjIGRlY2xhcmUgdGhlIHZhcmlhYmxlIHdlIHdpbGwgdXNlIHRvIHNvYWsgdXAgcmVzdWx0c1xuXHRcdFx0IyBwIFwiQ3JlYXRpbmcgdmFsdWUgdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiBsb29wXCIuY3lhblxuXHRcdFx0IyB3aGF0IGFib3V0IGEgcG9vbCBoZXJlP1xuXHRcdFx0cmVzdmFyID0gQHJlc3ZhciA9IHNjb3BlLmRlY2xhcmUoOnJlcyxBcnIubmV3KFtdKSxzeXN0ZW06IHllcylcblxuXHRcdEBjYXRjaGVyID0gUHVzaEFzc2lnbi5uZXcoXCJwdXNoXCIscmVzdmFyLG51bGwpICMgdGhlIHZhbHVlIGlzIG5vdCBwcmVzZXRcblx0XHRib2R5LmNvbnN1bWUoQGNhdGNoZXIpICMgc2hvdWxkIHN0aWxsIHJldHVybiB0aGUgc2FtZSBib2R5XG5cblxuXG5cdFx0aWYgbm9kZVxuXHRcdFx0IyBwIFwicmV0dXJuaW5nIG5ldyBhc3Qgd2hlcmUgTG9vcCBpcyBmaXJzdFwiXG5cdFx0XHR2YXIgYXN0ID0gQmxvY2submV3KFtzZWxmLEJSLHJlc3Zhci5hY2Nlc3Nvci5jb25zdW1lKG5vZGUpXSlcblx0XHRcdHJldHVybiBhc3Rcblx0XHQjIHZhciBhc3QgPSBCbG9jay5uZXcoW3NlbGYsQlIscmVzdmFyLmFjY2Vzc29yXSlcblx0XHQjIGFzdC5jb25zdW1lKG5vZGUpIGlmIG5vZGVcblx0XHQjIHJldHVybiBhc3Rcblx0XHQjIHAgXCJMb29wIGRpZCBjb25zdW1lIHN1Y2Nlc3NmdWxseVwiXG5cdFx0cmV0dXJuIHNlbGZcblxuXHRcdCMgdGhpcyBpcyBuZXZlciBhbiBleHByZXNzaW9uIChmb3Igbm93IC0tIGJ1dCBzdGlsbClcblx0XHQjIHJldHVybiBhc3RcblxuXG5cdGRlZiBqcyBvXG5cdFx0dmFyIHZhcnMgPSBvcHRpb25zOnZhcnNcblx0XHR2YXIgaSA9IHZhcnM6aW5kZXhcblx0XHR2YXIgdmFsID0gdmFyczp2YWx1ZVxuXHRcdHZhciBjb25kID0gT1AoJzwnLGksdmFyczpsZW4pXG5cdFx0dmFyIHNyYyA9IG9wdGlvbnM6c291cmNlXG5cblx0XHQjIHAgXCJyZWZlcmVuY2VzIGZvciB2YWx1ZVwiLHZhbC5yZWZlcmVuY2VzOmxlbmd0aFxuXG5cdFx0dmFyIGZpbmFsID0gaWYgb3B0aW9uczpzdGVwXG5cdFx0XHRPUCgnPScsaSxPUCgnKycsaSxvcHRpb25zOnN0ZXApKVxuXHRcdGVsc2Vcblx0XHRcdE9QKCcrKycsaSlcblxuXHRcdCMgaWYgdGhlcmUgYXJlIGZldyByZWZlcmVuY2VzIHRvIHRoZSB2YWx1ZSAtIHdlIGNhbiBkcm9wXG5cdFx0IyB0aGUgYWN0dWFsIHZhcmlhYmxlIGFuZCBpbnN0ZWFkIG1ha2UgaXQgcHJveHkgdGhyb3VnaCB0aGUgaW5kZXhcblx0XHRpZiBzcmMgaXNhIFJhbmdlXG5cdFx0XHRjb25kLm9wID0gJzw9JyBpZiBzcmMuaW5jbHVzaXZlXG5cdFx0XG5cdFx0ZWxpZiB2YWwucmVmY291bnQgPCAzIGFuZCB2YWwuYXNzaWdubWVudHM6bGVuZ3RoID09IDBcblx0XHRcdCMgcCBcInByb3h5IHRoZSB2YWx1ZSB7dmFsLmFzc2lnbm1lbnRzOmxlbmd0aH1cIlxuXHRcdFx0IyBwIFwic2hvdWxkIHByb3h5IHZhbHVlLXZhcmlhYmxlIGluc3RlYWRcIlxuXHRcdFx0dmFsLnByb3h5KHZhcnM6c291cmNlLGkpXG5cdFx0ZWxzZVxuXHRcdFx0Ym9keS51bnNoaWZ0KE9QKCc9Jyx2YWwsT1AoJy4nLHZhcnM6c291cmNlLGkpKSwgQlIpXG5cdFx0XHQjIGJvZHkudW5zaGlmdChoZWFkKVxuXHRcdFx0IyBUT0RPIGNoZWNrIGxlbmd0aHMgLSBpbnRlbGxpZ2VudGx5IGRlY2lkZSB3aGV0aGVyIHRvIGJyYWNlIGFuZCBpbmRlbnRcblx0XHR2YXIgaGVhZCA9IFwie21hcmtfXyhvcHRpb25zOmtleXdvcmQpfWZvciAoe3Njb3BlLnZhcnMuY307IHtjb25kLmN9OyB7ZmluYWwuY30pIFwiXG5cdFx0aGVhZCArIGJvZHkuYyhicmFjZXM6IHllcywgaW5kZW50OiB5ZXMpICMgLndyYXBcblxuXG5cdGRlZiBoZWFkXG5cdFx0dmFyIHZhcnMgPSBvcHRpb25zOnZhcnNcblx0XHRPUCgnPScsdmFyczp2YWx1ZSxPUCgnLicsdmFyczpzb3VyY2UsdmFyczppbmRleCkpXG5cblxuXG5leHBvcnQgY2xhc3MgRm9ySW4gPCBGb3JcblxuXG5cdFx0XG5leHBvcnQgY2xhc3MgRm9yT2YgPCBGb3JcblxuXHRkZWYgZGVjbGFyZVxuXHRcdHZhciBvID0gb3B0aW9uc1xuXHRcdHZhciB2YXJzID0gbzp2YXJzID0ge31cblxuXHRcdCMgc2VlIGlmIFxuXG5cdFx0IyBwIFwiRm9yT2Ygc291cmNlIGlzYSB7bzpzb3VyY2V9XCJcblxuXHRcdCMgaWYgbzpzb3VyY2UgaXMgYSB2YXJpYWJsZSAtLSByZWZlciBkaXJlY3RseSAjIHZhcmlhYmxlPyBpcyB0aGlzIHRoZSBpc3N1ZT9cblx0XHQjIHAgc2NvcGUuQHZhcm1hcFsnbyddLCBzY29wZS5wYXJlbnQuQHZhcm1hcFsnbyddXG5cblx0XHR2YXIgc3JjID0gdmFyczpzb3VyY2UgPSBvOnNvdXJjZS5AdmFyaWFibGUgfHwgc2NvcGUuZGVjbGFyZSgnbycsbzpzb3VyY2UsIHN5c3RlbTogdHJ1ZSwgdHlwZTogJ2xldCcpXG5cdFx0dmFyIHYgPSB2YXJzOnZhbHVlID0gc2NvcGUuZGVjbGFyZShvOmluZGV4LG51bGwsbGV0OiB5ZXMpIGlmIG86aW5kZXhcblxuXHRcdCMgcCBcIkZvck9mIG86aW5kZXgge286aW5kZXh9IG86bmFtZSB7bzpuYW1lfVwiXG5cdFx0IyBpZiBvOmluZGV4XG5cdFx0XG5cdFx0IyBwb3NzaWJseSBwcm94eSB0aGUgaW5kZXgtdmFyaWFibGU/XG5cblx0XHRpZiBvOm93blxuXHRcdFx0IyB2YXIgaSA9IHZhcnM6aW5kZXggPSBzY29wZS5kZWNsYXJlKCdpJywwLHN5c3RlbTogdHJ1ZSwgdHlwZTogJ2xldCcpICMgbWFyayBhcyBhIGNvdW50ZXI/XG5cdFx0XHR2YXIgaSA9IHZhcnM6aW5kZXggPSB1dGlsLmNvdW50ZXIoMCx5ZXMsc2NvcGUpLnByZWRlY2xhcmVcblx0XHRcdCMgc3lzdGVtdmFyaWFibGUgLS0gc2hvdWxkIG5vdCByZWFsbHkgYmUgYWRkZWQgdG8gdGhlIG1hcFxuXHRcdFx0dmFyIGtleXMgPSB2YXJzOmtleXMgPSBzY29wZS5kZWNsYXJlKCdrZXlzJyxVdGlsLmtleXMoc3JjLmFjY2Vzc29yKSxzeXN0ZW06IHllcywgdHlwZTogJ2xldCcpICMgdGhlIG91dGVyIG9uZSBzaG91bGQgcmVzb2x2ZSBmaXJzdFxuXHRcdFx0dmFyIGwgPSB2YXJzOmxlbiA9IHNjb3BlLmRlY2xhcmUoJ2wnLFV0aWwubGVuKGtleXMuYWNjZXNzb3IpLHN5c3RlbTogeWVzLCB0eXBlOiAnbGV0Jylcblx0XHRcdHZhciBrID0gdmFyczprZXkgPSBzY29wZS5yZWdpc3RlcihvOm5hbWUsbzpuYW1lLHR5cGU6ICdsZXQnKSAjIHNjb3BlLmRlY2xhcmUobzpuYW1lLG51bGwsc3lzdGVtOiB5ZXMpXG5cdFx0ZWxzZVxuXHRcdFx0IyB3ZSBzZXQgdGhlIHZhciAtLSB3aHkgZXZlbiBkZWNsYXJlIGl0XG5cdFx0XHQjIG5vIG5lZWQgdG8gZGVjbGFyZSAtLSBpdCB3aWxsIGRlY2xhcmUgaXRzZWxmIGluIHRoZSBsb29wIC0gbm8/XG5cdFx0XHR2YXIgayA9IHZhcnM6a2V5ID0gc2NvcGUucmVnaXN0ZXIobzpuYW1lLG86bmFtZSx0eXBlOiAnbGV0Jylcblx0XHRcblx0XHQjIFRPRE8gdXNlIHV0aWwgLSB3aHkgYWRkIHJlZmVyZW5jZXMgYWxyZWFkeT8gQWggLS0gdGhpcyBpcyBmb3IgdGhlIGhpZ2hsaWdodGluZ1xuXHRcdHYuYWRkUmVmZXJlbmNlKG86aW5kZXgpIGlmIHYgYW5kIG86aW5kZXhcblx0XHRrLmFkZFJlZmVyZW5jZShvOm5hbWUpIGlmIGsgYW5kIG86bmFtZVxuXG5cdFx0c2VsZlxuXG5cdGRlZiBqcyBvXG5cdFx0dmFyIHZhcnMgPSBvcHRpb25zOnZhcnNcblxuXHRcdHZhciBvID0gdmFyczpzb3VyY2Vcblx0XHR2YXIgayA9IHZhcnM6a2V5XG5cdFx0dmFyIHYgPSB2YXJzOnZhbHVlXG5cdFx0dmFyIGkgPSB2YXJzOmluZGV4XG5cblxuXHRcdGlmIHYgXG5cdFx0XHQjIHNldCB2YWx1ZSBhcyBwcm94eSBvZiBvYmplY3Rba2V5XVxuXHRcdFx0IyBwb3NzaWJseSBtYWtlIGl0IGEgcmVmPyB3aGF0IGlzIGhhcHBlbmluZz9cblx0XHRcdHYucmVmY291bnQgPCAzID8gdi5wcm94eShvLGspIDogYm9keS51bnNoaWZ0KE9QKCc9Jyx2LE9QKCcuJyxvLGspKSlcblxuXHRcdGlmIG9wdGlvbnM6b3duXG5cblx0XHRcdGlmIGsucmVmY291bnQgPCAzICMgc2hvdWxkIHByb2JhYmx5IGFkanVzdCB0aGVzZVxuXHRcdFx0XHRrLnByb3h5KHZhcnM6a2V5cyxpKVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRib2R5LnVuc2hpZnQoT1AoJz0nLGssT1AoJy4nLHZhcnM6a2V5cyxpKSkpXG5cblx0XHRcdHZhciBoZWFkID0gXCJ7bWFya19fKG9wdGlvbnM6a2V5d29yZCl9Zm9yICh7c2NvcGUudmFycy5jfTsge09QKCc8JyxpLHZhcnM6bGVuKS5jfTsge09QKCcrKycsaSkuY30pXCJcblx0XHRcdHJldHVybiBoZWFkICsgYm9keS5jKGluZGVudDogeWVzLCBicmFjZXM6IHllcykgIyAud3JhcFxuXG5cdFx0dmFyIGNvZGUgPSBib2R5LmMoYnJhY2VzOiB5ZXMsIGluZGVudDogeWVzKVxuXHRcdCMgaXQgaXMgcmVhbGx5IGltcG9ydGFudCB0aGF0IHRoaXMgaXMgYSB0cmVhdGVkIGFzIGEgc3RhdGVtZW50XG5cdFx0c2NvcGUudmFycy5jICsgXCI7XFxue21hcmtfXyhvcHRpb25zOmtleXdvcmQpfWZvciAodmFyIHtrLmN9IGluIHtvLmN9KVwiICsgY29kZVxuXG5cdGRlZiBoZWFkXG5cdFx0dmFyIHYgPSBvcHRpb25zOnZhcnNcblxuXHRcdFtcblx0XHRcdE9QKCc9Jyx2OmtleSxPUCgnLicsdjprZXlzLHY6aW5kZXgpKVxuXHRcdFx0T1AoJz0nLHY6dmFsdWUsT1AoJy4nLHY6c291cmNlLHY6a2V5KSkgaWYgdjp2YWx1ZVxuXHRcdF1cblxuIyBOTyBORUVEP1xuZXhwb3J0IGNsYXNzIEJlZ2luIDwgQmxvY2tcblxuXG5cdGRlZiBpbml0aWFsaXplIGJvZHlcblx0XHRAbm9kZXMgPSBibGtfXyhib2R5KS5ub2Rlc1xuXG5cblx0ZGVmIHNob3VsZFBhcmVudGhlc2l6ZVxuXHRcdGlzRXhwcmVzc2lvblxuXG5cblxuZXhwb3J0IGNsYXNzIFN3aXRjaCA8IENvbnRyb2xGbG93U3RhdGVtZW50XG5cblxuXHRwcm9wIHNvdXJjZVxuXHRwcm9wIGNhc2VzXG5cdHByb3AgZmFsbGJhY2tcblxuXG5cdGRlZiBpbml0aWFsaXplIGEsYixjXG5cdFx0QHRyYXZlcnNlZCA9IG5vXG5cdFx0QHNvdXJjZSA9IGFcblx0XHRAY2FzZXMgPSBiXG5cdFx0QGZhbGxiYWNrID0gY1xuXG5cblx0ZGVmIHZpc2l0XG5cdFx0Yy50cmF2ZXJzZSBmb3IgYyBpbiBjYXNlc1xuXHRcdGZhbGxiYWNrLnZpc2l0IGlmIGZhbGxiYWNrXG5cdFx0c291cmNlLnZpc2l0IGlmIHNvdXJjZVxuXHRcdHJldHVyblxuXG5cblx0ZGVmIGNvbnN1bWUgbm9kZVxuXHRcdCMgVE9ETyB3b3JrIGluc2lkZSB0YWdzIChsaWtlIGxvb3BzKVxuXHRcdEBjYXNlcyA9IEBjYXNlcy5tYXAofGl0ZW18IGl0ZW0uY29uc3VtZShub2RlKSlcblx0XHRAZmFsbGJhY2sgPSBAZmFsbGJhY2suY29uc3VtZShub2RlKSBpZiBAZmFsbGJhY2tcblx0XHRzZWxmXG5cblx0ZGVmIGMgb1xuXHRcdGlmIHN0YWNrLmlzRXhwcmVzc2lvbiBvciBpc0V4cHJlc3Npb25cblx0XHRcdHZhciBhc3QgPSBDQUxMKEZOKFtdLFtzZWxmXSksW10pXG5cdFx0XHRyZXR1cm4gYXN0LmMgb1xuXG5cdFx0c3VwZXIuYyhvKVxuXG5cblx0ZGVmIGpzIG9cblx0XHR2YXIgYm9keSA9IFtdXG5cblx0XHRmb3IgcGFydCBpbiBjYXNlc1xuXHRcdFx0cGFydC5hdXRvYnJlYWtcblx0XHRcdGJvZHkucHVzaChwYXJ0KVxuXG5cdFx0aWYgZmFsbGJhY2tcblx0XHRcdGJvZHkucHVzaChcImRlZmF1bHQ6XFxuXCIgKyBmYWxsYmFjay5jKGluZGVudDogeWVzKSlcblxuXHRcdFwic3dpdGNoICh7c291cmNlLmN9KSBcIiArIGhlbHBlcnMuYnJhY2tldGl6ZShjYXJ5X18oYm9keSkuam9pbihcIlxcblwiKSx5ZXMpXG5cblxuXG5leHBvcnQgY2xhc3MgU3dpdGNoQ2FzZSA8IENvbnRyb2xGbG93U3RhdGVtZW50XG5cblxuXHRwcm9wIHRlc3Rcblx0cHJvcCBib2R5XG5cblxuXHRkZWYgaW5pdGlhbGl6ZSB0ZXN0LCBib2R5XG5cdFx0QHRyYXZlcnNlZCA9IG5vXG5cdFx0QHRlc3QgPSB0ZXN0XG5cdFx0QGJvZHkgPSBibGtfXyhib2R5KVxuXG5cdGRlZiB2aXNpdFxuXHRcdGJvZHkudHJhdmVyc2VcblxuXG5cdGRlZiBjb25zdW1lIG5vZGVcblx0XHRib2R5LmNvbnN1bWUobm9kZSlcblx0XHRzZWxmXG5cblxuXHRkZWYgYXV0b2JyZWFrXG5cdFx0Ym9keS5wdXNoKEJyZWFrU3RhdGVtZW50Lm5ldykgdW5sZXNzIGJvZHkubGFzdCBpc2EgQnJlYWtTdGF0ZW1lbnRcblx0XHRzZWxmXG5cblxuXHRkZWYganMgb1xuXHRcdEB0ZXN0ID0gW0B0ZXN0XSB1bmxlc3MgQHRlc3QgaXNhIEFycmF5IFxuXHRcdHZhciBjYXNlcyA9IEB0ZXN0Lm1hcCBkbyB8aXRlbXwgXCJjYXNlIHtpdGVtLmN9OlwiXG5cdFx0Y2FzZXMuam9pbihcIlxcblwiKSArIGJvZHkuYyhpbmRlbnQ6IHllcykgIyAuaW5kZW50XG5cblxuXG5leHBvcnQgY2xhc3MgVHJ5IDwgQ29udHJvbEZsb3dTdGF0ZW1lbnRcblxuXG5cdHByb3AgYm9keVxuXHQjIHByb3AgbmNhdGNoXG5cdCMgcHJvcCBuZmluYWxseVxuXG5cdGRlZiBpbml0aWFsaXplIGJvZHksIGMsIGZcblx0XHRAdHJhdmVyc2VkID0gbm9cblx0XHRAYm9keSA9IGJsa19fKGJvZHkpXG5cdFx0QGNhdGNoID0gY1xuXHRcdEBmaW5hbGx5ID0gZlxuXG5cblx0ZGVmIGNvbnN1bWUgbm9kZVxuXHRcdEBib2R5ID0gQGJvZHkuY29uc3VtZShub2RlKVxuXHRcdEBjYXRjaCA9IEBjYXRjaC5jb25zdW1lKG5vZGUpIGlmIEBjYXRjaFxuXHRcdEBmaW5hbGx5ID0gQGZpbmFsbHkuY29uc3VtZShub2RlKSBpZiBAZmluYWxseVxuXHRcdHNlbGZcblxuXG5cdGRlZiB2aXNpdFxuXHRcdEBib2R5LnRyYXZlcnNlXG5cdFx0QGNhdGNoLnRyYXZlcnNlIGlmIEBjYXRjaFxuXHRcdEBmaW5hbGx5LnRyYXZlcnNlIGlmIEBmaW5hbGx5XG5cdFx0IyBubyBibG9ja3MgLSBhZGQgYW4gZW1wdHkgY2F0Y2hcblxuXG5cdGRlZiBqcyBvXG5cdFx0dmFyIG91dCA9IFwidHJ5IFwiICsgYm9keS5jKGJyYWNlczogeWVzLCBpbmRlbnQ6IHllcylcblx0XHRvdXQgKz0gXCIgXCIgKyBAY2F0Y2guYyBpZiBAY2F0Y2hcblx0XHRvdXQgKz0gXCIgXCIgKyBAZmluYWxseS5jIGlmIEBmaW5hbGx5XG5cblx0XHR1bmxlc3MgQGNhdGNoIG9yIEBmaW5hbGx5XG5cdFx0XHRvdXQgKz0gXCIgY2F0Y2ggKGUpIFxceyBcXH1cIlxuXHRcdG91dCArPSBcIjtcIlxuXHRcdG91dFxuXG5cblxuZXhwb3J0IGNsYXNzIENhdGNoIDwgQ29udHJvbEZsb3dTdGF0ZW1lbnRcblx0XG5cdHByb3AgYm9keVxuXG5cdGRlZiBpbml0aWFsaXplIGJvZHksIHZhcm5hbWVcblx0XHRAdHJhdmVyc2VkID0gbm9cblx0XHRAYm9keSA9IGJsa19fKGJvZHkgb3IgW10pXG5cdFx0QHNjb3BlID0gQ2F0Y2hTY29wZS5uZXcoc2VsZilcblx0XHRAdmFybmFtZSA9IHZhcm5hbWVcblx0XHRzZWxmXG5cblx0ZGVmIGNvbnN1bWUgbm9kZVxuXHRcdEBib2R5ID0gQGJvZHkuY29uc3VtZShub2RlKVxuXHRcdHNlbGZcblxuXG5cdGRlZiB2aXNpdFxuXHRcdEBzY29wZS52aXNpdFxuXHRcdEB2YXJpYWJsZSA9IEBzY29wZS5yZWdpc3RlcihAdmFybmFtZSxzZWxmLHBvb2w6ICdjYXRjaHZhcicpXG5cdFx0QGJvZHkudHJhdmVyc2VcblxuXG5cdGRlZiBqcyBvXG5cdFx0IyBvbmx5IGluZGVudCBpZiBpbmRlbnRlZCBieSBkZWZhdWx0P1xuXHRcdFwiY2F0Y2ggKHtAdmFyaWFibGUuY30pIFwiICsgQGJvZHkuYyhicmFjZXM6IHllcywgaW5kZW50OiB5ZXMpXG5cblxuIyByZXBlYXRpbmcgbXlzZWxmLi4gZG9uJ3QgZGVhbCB3aXRoIGl0IHVudGlsIHdlIG1vdmUgdG8gY29tcGFjdCB0dXBsZS1hcmdzXG4jIGZvciBhbGwgYXN0bm9kZXNcblxuXG5leHBvcnQgY2xhc3MgRmluYWxseSA8IENvbnRyb2xGbG93U3RhdGVtZW50XG5cblx0ZGVmIGluaXRpYWxpemUgYm9keVxuXHRcdEB0cmF2ZXJzZWQgPSBub1xuXHRcdEBib2R5ID0gYmxrX18oYm9keSBvciBbXSlcblxuXG5cdGRlZiB2aXNpdFxuXHRcdEBib2R5LnRyYXZlcnNlXG5cblxuXHRkZWYgY29uc3VtZSBub2RlXG5cdFx0IyBzd2FsbG93IHNpbGVudGx5XG5cdFx0c2VsZlxuXG5cblx0ZGVmIGpzIG9cblx0XHRcImZpbmFsbHkgXCIgKyBAYm9keS5jKGJyYWNlczogeWVzLCBpbmRlbnQ6IHllcylcblxuXG4jIFJBTkdFXG5cbmV4cG9ydCBjbGFzcyBSYW5nZSA8IE9wXG5cblx0ZGVmIGluY2x1c2l2ZVxuXHRcdG9wID09ICcuLidcblx0XHRcblx0ZGVmIGNcblx0XHRcInJhbmdlXCJcblxuXG5leHBvcnQgY2xhc3MgU3BsYXQgPCBWYWx1ZU5vZGVcblxuXHRkZWYganMgb1xuXHRcdHZhciBwYXIgPSBzdGFjay5wYXJlbnRcblx0XHRpZiBwYXIgaXNhIEFyZ0xpc3Qgb3IgcGFyIGlzYSBBcnJcblx0XHRcdFwiW10uc2xpY2UuY2FsbCh7dmFsdWUuY30pXCJcblx0XHRlbHNlXG5cdFx0XHRwIFwid2hhdCBpcyB0aGUgcGFyZW50PyB7cGFyfVwiXG5cdFx0XHRcIlNQTEFUXCJcblxuXHRkZWYgbm9kZVxuXHRcdHZhbHVlXG5cblxuXG5cblxuIyBUQUdTXG5cblxuVEFHX1RZUEVTID0ge31cblRBR19BVFRSUyA9IHt9XG5cblxuVEFHX1RZUEVTLkhUTUwgPSBcImEgYWJiciBhZGRyZXNzIGFyZWEgYXJ0aWNsZSBhc2lkZSBhdWRpbyBiIGJhc2UgYmRpIGJkbyBiaWcgYmxvY2txdW90ZSBib2R5IGJyIFxuYnV0dG9uIGNhbnZhcyBjYXB0aW9uIGNpdGUgY29kZSBjb2wgY29sZ3JvdXAgZGF0YSBkYXRhbGlzdCBkZCBkZWwgZGV0YWlscyBkZm4gXG5kaXYgZGwgZHQgZW0gZW1iZWQgZmllbGRzZXQgZmlnY2FwdGlvbiBmaWd1cmUgZm9vdGVyIGZvcm0gaDEgaDIgaDMgaDQgaDUgaDYgXG5oZWFkIGhlYWRlciBociBodG1sIGkgaWZyYW1lIGltZyBpbnB1dCBpbnMga2JkIGtleWdlbiBsYWJlbCBsZWdlbmQgbGkgbGluayBcbm1haW4gbWFwIG1hcmsgbWVudSBtZW51aXRlbSBtZXRhIG1ldGVyIG5hdiBub3NjcmlwdCBvYmplY3Qgb2wgb3B0Z3JvdXAgb3B0aW9uIFxub3V0cHV0IHAgcGFyYW0gcHJlIHByb2dyZXNzIHEgcnAgcnQgcnVieSBzIHNhbXAgc2NyaXB0IHNlY3Rpb24gc2VsZWN0IHNtYWxsIFxuc291cmNlIHNwYW4gc3Ryb25nIHN0eWxlIHN1YiBzdW1tYXJ5IHN1cCB0YWJsZSB0Ym9keSB0ZCB0ZXh0YXJlYSB0Zm9vdCB0aCBcbnRoZWFkIHRpbWUgdGl0bGUgdHIgdHJhY2sgdSB1bCB2YXIgdmlkZW8gd2JyXCIuc3BsaXQoXCIgXCIpXG5cblRBR19UWVBFUy5TVkcgPSBcImNpcmNsZSBkZWZzIGVsbGlwc2UgZyBsaW5lIGxpbmVhckdyYWRpZW50IG1hc2sgcGF0aCBwYXR0ZXJuIHBvbHlnb24gcG9seWxpbmUgXG5yYWRpYWxHcmFkaWVudCByZWN0IHN0b3Agc3ZnIHRleHQgdHNwYW5cIi5zcGxpdChcIiBcIilcblxuVEFHX0FUVFJTLkhUTUwgPSBcImFjY2VwdCBhY2Nlc3NLZXkgYWN0aW9uIGFsbG93RnVsbFNjcmVlbiBhbGxvd1RyYW5zcGFyZW5jeSBhbHQgYXN5bmMgXG5hdXRvQ29tcGxldGUgYXV0b0ZvY3VzIGF1dG9QbGF5IGNlbGxQYWRkaW5nIGNlbGxTcGFjaW5nIGNoYXJTZXQgY2hlY2tlZCBcbmNsYXNzTmFtZSBjb2xzIGNvbFNwYW4gY29udGVudCBjb250ZW50RWRpdGFibGUgY29udGV4dE1lbnUgY29udHJvbHMgY29vcmRzIFxuY3Jvc3NPcmlnaW4gZGF0YSBkYXRlVGltZSBkZWZlciBkaXIgZGlzYWJsZWQgZG93bmxvYWQgZHJhZ2dhYmxlIGVuY1R5cGUgZm9ybSBcbmZvcm1Ob1ZhbGlkYXRlIGZyYW1lQm9yZGVyIGhlaWdodCBoaWRkZW4gaHJlZiBocmVmTGFuZyBodG1sRm9yIGh0dHBFcXVpdiBpY29uIFxuaWQgbGFiZWwgbGFuZyBsaXN0IGxvb3AgbWF4IG1heExlbmd0aCBtZWRpYUdyb3VwIG1ldGhvZCBtaW4gbXVsdGlwbGUgbXV0ZWQgXG5uYW1lIG5vVmFsaWRhdGUgcGF0dGVybiBwbGFjZWhvbGRlciBwb3N0ZXIgcHJlbG9hZCByYWRpb0dyb3VwIHJlYWRPbmx5IHJlbCBcbnJlcXVpcmVkIHJvbGUgcm93cyByb3dTcGFuIHNhbmRib3ggc2NvcGUgc2Nyb2xsTGVmdCBzY3JvbGxpbmcgc2Nyb2xsVG9wIFxuc2VhbWxlc3Mgc2VsZWN0ZWQgc2hhcGUgc2l6ZSBzcGFuIHNwZWxsQ2hlY2sgc3JjIHNyY0RvYyBzcmNTZXQgc3RhcnQgc3RlcCBcbnN0eWxlIHRhYkluZGV4IHRhcmdldCB0aXRsZSB0eXBlIHVzZU1hcCB2YWx1ZSB3aWR0aCB3bW9kZVwiXG5cblRBR19BVFRSUy5TVkcgPSBcImN4IGN5IGQgZHggZHkgZmlsbCBmaWxsT3BhY2l0eSBmb250RmFtaWx5IGZvbnRTaXplIGZ4IGZ5IGdyYWRpZW50VHJhbnNmb3JtIFxuZ3JhZGllbnRVbml0cyBtYXJrZXJFbmQgbWFya2VyTWlkIG1hcmtlclN0YXJ0IG9mZnNldCBvcGFjaXR5IFxucGF0dGVybkNvbnRlbnRVbml0cyBwYXR0ZXJuVW5pdHMgcG9pbnRzIHByZXNlcnZlQXNwZWN0UmF0aW8gciByeCByeSBcbnNwcmVhZE1ldGhvZCBzdG9wQ29sb3Igc3RvcE9wYWNpdHkgc3Ryb2tlIHN0cm9rZURhc2hhcnJheSBzdHJva2VMaW5lY2FwIFxuc3Ryb2tlT3BhY2l0eSBzdHJva2VXaWR0aCB0ZXh0QW5jaG9yIHRyYW5zZm9ybSB2ZXJzaW9uIHZpZXdCb3ggeDEgeDIgeCB5MSB5MiB5XCJcblxuXG5leHBvcnQgY2xhc3MgVGFnRGVzYyA8IE5vZGVcblxuXHRkZWYgaW5pdGlhbGl6ZVxuXHRcdHAgJ1RhZ0Rlc2MhISEnLCQwXG5cdFx0c2VsZlxuXG5cdGRlZiBjbGFzc2VzXG5cdFx0cCAnVGFnRGVzY0NsYXNzZXMnLCQwXG5cdFx0c2VsZlxuXG5leHBvcnQgY2xhc3MgVGFnIDwgTm9kZVxuXG5cdHByb3AgcGFydHNcblx0cHJvcCBvYmplY3Rcblx0cHJvcCByZWFjdGl2ZVxuXHRwcm9wIHBhcmVudFxuXHRwcm9wIHRyZWVcblxuXHRkZWYgaW5pdGlhbGl6ZSBvID0ge31cblx0XHRAdHJhdmVyc2VkID0gbm9cblx0XHRAcGFydHMgPSBbXVxuXHRcdG86Y2xhc3NlcyB8fD0gW11cblx0XHRvOmF0dHJpYnV0ZXMgfHw9IFtdXG5cdFx0bzpjbGFzc2VzIHx8PSBbXVxuXHRcdEBvcHRpb25zID0gb1xuXHRcdEByZWZlcmVuY2UgPSBudWxsXG5cdFx0QG9iamVjdCA9IG51bGxcblx0XHRAdHJlZSA9IG51bGxcblx0XHRzZWxmXG5cblx0ZGVmIHNldCBvYmpcblx0XHRmb3Igb3duIGssdiBvZiBvYmpcblx0XHRcdGlmIGsgPT0gJ2F0dHJpYnV0ZXMnXG5cdFx0XHRcdCMgcCBcImF0dHJpYnV0cyFcIlxuXHRcdFx0XHRhZGRBdHRyaWJ1dGUoYXRyKSBmb3IgYXRyIGluIHZcblx0XHRcdFx0Y29udGludWVcblxuXHRcdFx0QG9wdGlvbnNba10gPSB2XG5cdFx0c2VsZlxuXG5cdGRlZiBhZGRDbGFzcyBub2RlXG5cdFx0dW5sZXNzIG5vZGUgaXNhIFRhZ0ZsYWdcblx0XHRcdG5vZGUgPSBUYWdGbGFnLm5ldyhub2RlKVxuXHRcdEBvcHRpb25zOmNsYXNzZXMucHVzaChub2RlKVxuXHRcdEBwYXJ0cy5wdXNoKG5vZGUpXG5cblx0XHQjIHAgXCJhZGQgY2xhc3MhISFcIlxuXHRcdHNlbGZcblxuXHRkZWYgYWRkSW5kZXggbm9kZVxuXHRcdEBwYXJ0cy5wdXNoKG5vZGUpXG5cdFx0QG9iamVjdCA9IG5vZGVcblx0XHRzZWxmXG5cblx0ZGVmIGFkZFN5bWJvbCBub2RlXG5cdFx0IyBwIFwiYWRkU3ltYm9sIHRvIHRoZSB0YWdcIixub2RlXG5cdFx0aWYgQHBhcnRzOmxlbmd0aCA9PSAwXG5cdFx0XHRAcGFydHMucHVzaChub2RlKVxuXHRcdFx0QG9wdGlvbnM6bnMgPSBub2RlXG5cdFx0c2VsZlxuXHRcdFxuXG5cdGRlZiBhZGRBdHRyaWJ1dGUgYXRyXG5cdFx0IyBwIFwiYWRkIGF0dHJpYnV0ZSEhIVwiLCBrZXksIHZhbHVlXG5cdFx0QHBhcnRzLnB1c2goYXRyKSAjIHdoYXQ/XG5cdFx0QG9wdGlvbnM6YXR0cmlidXRlcy5wdXNoKGF0cilcblx0XHRzZWxmXG5cblx0ZGVmIGVuY2xvc2luZ1xuXHRcdChAb3B0aW9uczpjbG9zZSBhbmQgQG9wdGlvbnM6Y2xvc2UudmFsdWUpXG5cblx0ZGVmIHR5cGVcblx0XHRAb3B0aW9uczp0eXBlIHx8IDpkaXZcblxuXHRkZWYgY29uc3VtZSBub2RlXG5cdFx0dmFyIG8gPSBAb3B0aW9uc1xuXG5cblx0XHRpZiBub2RlIGlzYSBUYWdUcmVlXG5cdFx0XHQjIHAgXCJ0YWcgY29uc3VtZSB0YWd0cmVlPyB7bm9kZS5yZWFjdGl2ZX1cIlxuXHRcdFx0cGFyZW50ID0gbm9kZS5yb290XG5cdFx0XHQjIG86dHJlZVJlZiA9IG5vZGUubmV4dENhY2hlS2V5XG5cblx0XHRcdGlmIG5vZGUuQGxvb3Bcblx0XHRcdFx0IyBhbHdhdHlzIG1ha2UgaXRlbXMgaW4gbG9vcCByZWFjdGl2ZVxuXHRcdFx0XHRyZWFjdGl2ZSA9IG5vZGUucmVhY3RpdmUgb3Igb3B0aW9uKDprZXkpXG5cdFx0XHRcdG9wdGlvbig6bG9vcCxub2RlLkBsb29wKVxuXG5cdFx0XHRcdGlmIG9wdGlvbig6aXZhcilcblx0XHRcdFx0XHR3YXJuIFwiVGFnIGluc2lkZSBsb29wIGNhbiBub3QgaGF2ZSBhIHN0YXRpYyByZWZlcmVuY2Uge29wdGlvbig6aXZhcil9XCIsIHR5cGU6ICdlcnJvcicsIHRva2VuOiBvcHRpb24oOml2YXIpLnZhbHVlXG5cblx0XHRcdGVsc2Vcblx0XHRcdFx0cmVhY3RpdmUgPSBub2RlLnJlYWN0aXZlIG9yICEhb3B0aW9uKDppdmFyKVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gc2VsZlxuXG5cdFx0c3VwZXJcblxuXG5cdGRlZiB2aXNpdFxuXG5cdFx0dmFyIG8gPSBAb3B0aW9uc1xuXG5cdFx0aWYgbzppdmFyIG9yIG86a2V5XG5cdFx0XHRyZWFjdGl2ZSA9IHllc1xuXG5cdFx0dmFyIHR5cCA9IGVuY2xvc2luZ1xuXG5cdFx0IyBsb29rIGZvciBvdXRlciB0YWcgaGVyZT9cblxuXHRcdGlmIHR5cCA9PSAnLT4nIG9yIHR5cCA9PSAnPT4nXG5cdFx0XHQjIGNvbnNvbGUubG9nIFwidGFnIGlzIHRlbXBsYXRlPyE/IHt0eXB9XCJcblx0XHRcdEB0cmVlID0gVGFnVHJlZS5uZXcoc2VsZixvOmJvZHksIHJvb3Q6IHNlbGYsIHJlYWN0aXZlOiByZWFjdGl2ZSlcblx0XHRcdG86Ym9keSA9IFRhZ0ZyYWdtZW50RnVuYy5uZXcoW10sQmxvY2sud3JhcChbQHRyZWVdKSlcblx0XHRcdCMgY29uc29sZS5sb2cgXCJtYWRlIG8gYm9keSBhIGZ1bmN0aW9uP1wiXG5cblx0XHRvOmtleS50cmF2ZXJzZSBpZiBvOmtleVxuXG5cdFx0aWYgbzpib2R5XG5cdFx0XHRvOmJvZHkudHJhdmVyc2VcblxuXHRcdCMgaWQgc2hvdWxkIGFsc28gYmUgYSByZWd1bGFyIHBhcnRcblx0XG5cdFx0bzppZC50cmF2ZXJzZSBpZiBvOmlkXG5cdFx0XG5cblx0XHRmb3IgcGFydCBpbiBAcGFydHNcblx0XHRcdHBhcnQudHJhdmVyc2VcblxuXHRcdCMgZm9yIGF0ciBpbiBAb3B0aW9uczphdHRyaWJ1dGVzXG5cdFx0IyBcdGF0ci50cmF2ZXJzZVxuXG5cdFx0c2VsZlxuXG5cdGRlZiByZWZlcmVuY2Vcblx0XHRAcmVmZXJlbmNlIHx8PSBzY29wZV9fLmNsb3N1cmUudGVtcG9yYXJ5KHNlbGYscG9vbDogJ3RhZycpLnJlc29sdmVcblxuXHQjIHNob3VsZCB0aGlzIG5vdCBoYXBwZW4gaW4ganM/XG5cdCMgc2hvdWxkIHRoaXMgbm90IGhhcHBlbiBpbiBqcz9cblx0ZGVmIGpzIG9cblx0XHQjIHAgSlNPTi5zdHJpbmdpZnkoQG9wdGlvbnMpXG5cdFx0IyB2YXIgYXR0cnMgPSBUYWdBdHRyaWJ1dGVzLm5ldyhvOmF0dHJpYnV0ZXMpXG5cdFx0IyBwIFwiZ290IGhlcmU/XCJcblx0XHR2YXIgbyA9IEBvcHRpb25zXG5cdFx0dmFyIGEgPSB7fVxuXHRcdHZhciBlbmMgPSBlbmNsb3NpbmdcblxuXHRcdHZhciBzZXR1cCA9IFtdXG5cdFx0dmFyIGNhbGxzID0gW11cblx0XHR2YXIgc3RhdGljcyA9IFtdXG5cblx0XHR2YXIgc2NvcGUgPSBzY29wZV9fXG5cdFx0dmFyIGNvbW1pdCA9IFwiZW5kXCJcblx0XHR2YXIgY29udGVudCA9IG86Ym9keVxuXG5cdFx0dmFyIGlzU2VsZiA9IHR5cGUgaXNhIFNlbGZcblx0XHR2YXIgYm9keVNldHRlciA9IGlzU2VsZiA/IFwic2V0Q2hpbGRyZW5cIiA6IFwic2V0Q29udGVudFwiXG5cblx0XHQjIHNob3VsZCBub3QgY2FjaGUgc3RhdGljcyBpZiB0aGUgbm9kZSBpdHNlbGYgaXMgbm90IGNhY2hlZFxuXHRcdCMgdGhhdCB3b3VsZCBvbmx5IG1hbmdsZSB0aGUgb3JkZXIgaW4gd2hpY2ggd2Ugc2V0IHRoZSBwcm9wZXJ0aWVzXG5cdFx0dmFyIGNhY2hlU3RhdGljcyA9IHllc1xuXG5cdFx0Zm9yIGF0ciBpbiBvOmF0dHJpYnV0ZXNcblx0XHRcdGFbYXRyLmtleV0gPSBhdHIudmFsdWUgIyAucG9wdWxhdGUob2JqKVxuXG5cdFx0dmFyIHF1b3RlID0gZG8gfHN0cnwgaGVscGVycy5zaW5nbGVxdW90ZShzdHIpXG5cdFx0dmFyIGlkID0gbzppZCBpc2EgTm9kZSA/IG86aWQuYyA6IChvOmlkIGFuZCBxdW90ZShvOmlkLmMpKVxuXHRcdHZhciB0cmVlID0gQHRyZWUgb3IgbnVsbFxuXHRcdHZhciBwYXJlbnQgPSBzZWxmLnBhcmVudFxuXHRcdCMgdmFyIHBhclRyZWUgPSBwYXJlbnQgYW5kIHBhcmVudC50cmVlXG5cblxuXHRcdCMgIFwic2NvcGUgaXNcIiwgISFzY29wZVxuXHRcdCMgcCBcInR5cGUgaXMge3R5cGV9XCJcblx0XHR2YXIgb3V0ID0gaWYgaXNTZWxmXG5cdFx0XHRjb21taXQgPSBcInN5bmNlZFwiXG5cdFx0XHQjIHAgXCJnb3QgaGVyZVwiXG5cdFx0XHQjIHNldHRpbmcgY29ycmVjdCBjb250ZXh0IGRpcmVjdGx5XG5cdFx0XHRyZWFjdGl2ZSA9IHllc1xuXHRcdFx0QHJlZmVyZW5jZSA9IHNjb3BlLmNvbnRleHRcblx0XHRcdHNjb3BlLmNvbnRleHQuY1xuXHRcdGVsc2Vcblx0XHRcdFwie21hcmtfXyhvOm9wZW4pfXtzY29wZS50YWdDb250ZXh0UGF0aH0ue3R5cGUuc3Bhd25lcn0oKVwiXG5cblx0XHRpZiBvOmlkXG5cdFx0XHRzdGF0aWNzLnB1c2goXCIuc2V0SWQoe3F1b3RlKG86aWQpfSlcIilcblx0XHQjIHRoaXMgaXMgcmVhY3RpdmUgaWYgaXQgaGFzIGFuIGl2YXJcblx0XHRpZiBvOml2YXJcblx0XHRcdHJlYWN0aXZlID0geWVzXG5cdFx0XHRzdGF0aWNzLnB1c2goXCIuc2V0UmVmKHtxdW90ZShvOml2YXIubmFtZSl9LHtzY29wZS5jb250ZXh0LmN9KVwiKVxuXG5cdFx0aWYgbzpib2R5IGlzYSBGdW5jXG5cdFx0XHQjIGNvbnNvbGUubG9nIFwibzpib2R5IGlzYSBmdW5jdGlvbiFcIlxuXHRcdFx0Ym9keVNldHRlciA9IFwic2V0VGVtcGxhdGVcIlxuXG5cdFx0ZWxpZiBvOmJvZHlcblx0XHRcdGlmIG86Ym9keSBpc2EgQXJnTGlzdCBhbmQgbzpib2R5LmNvdW50ID09IDEgYW5kIG86Ym9keS5maXJzdC5pc1N0cmluZ1xuXHRcdFx0XHRib2R5U2V0dGVyID0gXCJzZXRUZXh0XCJcblxuXHRcdFx0ZWxzZVxuXHRcdFx0XHQjIHdvdWxkIHByb2JhYmx5IGJlIGJldHRlciB0byBjb252ZXJ0IHRvIGEgdGFndHJlZSBkdXJpbmcgdGhlIGluaXRpYWwgdmlzaXRcblx0XHRcdFx0dHJlZSA9IFRhZ1RyZWUubmV3KHNlbGYsIG86Ym9keSwgcm9vdDogc2VsZiwgcmVhY3RpdmU6IHJlYWN0aXZlKVxuXHRcdFx0XHRjb250ZW50ID0gdHJlZVxuXHRcdFx0XHRzZWxmLnRyZWUgPSB0cmVlXG5cblx0XHRpZiB0cmVlXG5cdFx0XHQjIHRoaXMgaXMgdGhlIHBvaW50IHdoZXJlIHdlIHRyYXZlcnNlIHRoZSBpbm5lciBub2RlcyB3aXRoIG91ciB0cmVlXG5cdFx0XHQjIHNob3VsZCByYXRoZXIgaGFwcGVuIGluIHZpc2l0IC0gbG9uZyBiZWZvcmUuXG5cdFx0XHR0cmVlLnJlc29sdmVcblxuXHRcdGZvciBwYXJ0IGluIEBwYXJ0c1xuXHRcdFx0dmFyIHBqc1xuXHRcdFx0dmFyIHBjYWNoZSA9IG5vXG5cblx0XHRcdGlmIHBhcnQgaXNhIFRhZ0F0dHJcblx0XHRcdFx0dmFyIGFrZXkgPSBTdHJpbmcocGFydC5rZXkpXG5cdFx0XHRcdHZhciBhdmFsID0gcGFydC52YWx1ZVxuXHRcdFx0XHQjIHAgXCJwYXJ0IHZhbHVlIHthdmFsfSB7YXZhbC5pc1ByaW1pdGl2ZSh5ZXMpfVwiXG5cblx0XHRcdFx0IyB0aGUgYXR0ciBzaG91bGQgY29tcGlsZSBpdHNlbGYgaW5zdGVhZCAtLSByZWFsbHlcblx0XHRcdFx0cGNhY2hlID0gYXZhbC5pc1ByaW1pdGl2ZVxuXG5cdFx0XHRcdGlmIGFrZXlbMF0gPT0gJy4nICMgc2hvdWxkIGNoZWNrIGluIGEgYmV0dGVyIHdheVxuXHRcdFx0XHRcdHBjYWNoZSA9IG5vXG5cdFx0XHRcdFx0cGpzID0gXCIuZmxhZyh7cXVvdGUoYWtleS5zdWJzdHIoMSkpfSx7YXZhbC5jfSlcIlxuXHRcdFx0XHRlbGlmIGFrZXlbMF0gPT0gJzonXG5cdFx0XHRcdFx0IyBuZWVkIHRvIGFuYWx5emUgd2hldGhlciB0aGlzIGlzIHN0YXRpYyBvciBub3Rcblx0XHRcdFx0XHRwanMgPSBcIi5zZXRIYW5kbGVyKHtxdW90ZShha2V5LnN1YnN0cigxKSl9LHthdmFsLmN9LHtzY29wZS5jb250ZXh0LmN9KVwiXG5cdFx0XHRcdGVsaWYgYWtleS5zdWJzdHIoMCw1KSA9PSAnZGF0YS0nXG5cdFx0XHRcdFx0cGpzID0gXCIuZGF0YXNldCgne2FrZXkuc2xpY2UoNSl9Jyx7YXZhbC5jfSlcIlxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0cGpzID0gXCIue21hcmtfXyhwYXJ0LmtleSl9e2hlbHBlcnMuc2V0dGVyU3ltKGFrZXkpfSh7YXZhbC5jfSlcIlxuXG5cdFx0XHRlbGlmIHBhcnQgaXNhIFRhZ0ZsYWdcblx0XHRcdFx0cGpzID0gcGFydC5jXG5cdFx0XHRcdHBjYWNoZSA9IHllc1xuXG5cdFx0XHRpZiBwanNcblx0XHRcdFx0Y2FjaGVTdGF0aWNzICYmIHBjYWNoZSA/IHN0YXRpY3MucHVzaChwanMpIDogY2FsbHMucHVzaChwanMpXG5cblxuXG5cdFx0aWYgb2JqZWN0XG5cdFx0XHRjYWxscy5wdXNoKFwiLnNldE9iamVjdCh7b2JqZWN0LmN9KVwiKVxuXG5cdFx0IyBwIFwidGFndHJlZSBpcyBzdGF0aWM/IHt0cmVlLnN0YXRpY31cIlxuXG5cdFx0IyB3ZSBuZWVkIHRvIHRyaWdnZXIgb3VyIG93biByZWZlcmVuY2UgYmVmb3JlIHRoZSBib2R5IGRvZXNcblx0XHQjIGJ1dCB3ZSBkbyBub3QgbmVlZCBhIHJlZmVyZW5jZSBpZiB3ZSBoYXZlIG5vIGJvZHkgKG5vIG5vZGVzIHdpbGwgcmVmZXIgaXQpXG5cdFx0aWYgcmVhY3RpdmUgYW5kIHRyZWUgIyBhbmQgdHJlZS5oYXNUYWdzXG5cdFx0XHRyZWZlcmVuY2VcblxuXHRcdGlmIHJlYWN0aXZlIGFuZCBwYXJlbnQgYW5kIHBhcmVudC50cmVlXG5cdFx0XHRvOnRyZWVSZWYgPSBwYXJlbnQudHJlZS5uZXh0Q2FjaGVLZXkoc2VsZilcblxuXHRcdGlmIHZhciBib2R5ID0gY29udGVudCBhbmQgY29udGVudC5jKGV4cHJlc3Npb246IHllcykgIyBmb3JjZSBpdCB0byBiZSBhbiBleHByZXNzaW9uLCBubz9cblx0XHRcdGxldCB0eXAgPSAwXG5cblx0XHRcdGlmIHRyZWUgXG5cdFx0XHRcdGlmIHRyZWUuc3RhdGljXG5cdFx0XHRcdFx0dHlwID0gMlxuXHRcdFx0XHRlbGlmIHJlYWN0aXZlIG9yIHRyZWUucmVhY3RpdmVcblx0XHRcdFx0XHRpZiAhdHJlZS5zaW5nbGUgb3IgdHJlZS5zaW5nbGUgaXNhIElmXG5cdFx0XHRcdFx0XHR0eXAgPSAxXG5cdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0dHlwID0gM1xuXHRcdFx0XHRcdFx0XG5cblx0XHRcdGlmIGJvZHlTZXR0ZXIgPT0gJ3NldENoaWxkcmVuJyBvciBib2R5U2V0dGVyID09ICdzZXRDb250ZW50J1xuXHRcdFx0XHRjYWxscy5wdXNoIFwiLntib2R5U2V0dGVyfSh7Ym9keX0se3R5cH0pXCJcblx0XHRcdGVsc2Vcblx0XHRcdFx0Y2FsbHMucHVzaCBcIi57Ym9keVNldHRlcn0oe2JvZHl9KVwiXG5cblx0XHRcdCMgb3V0ICs9IFwiLmJvZHkoe2JvZHl9KVwiXG5cblx0XHQjIGlmIG86YXR0cmlidXRlczpsZW5ndGggIyBvciAtLSBhbHdheXM/XG5cdFx0IyBhZGRzIGxvdHMgb2YgZXh0cmEgY2FsbHMgLSBidXQgb2theSBmb3Igbm93XG5cdFx0Y2FsbHMucHVzaCBcIi57Y29tbWl0fSgpXCJcblxuXHRcdGlmIHN0YXRpY3M6bGVuZ3RoXG5cdFx0XHRvdXQgPSBvdXQgKyBzdGF0aWNzLmpvaW4oXCJcIilcblxuXHRcblx0XHRpZiAobzppdmFyIG9yIG86a2V5IG9yIHJlYWN0aXZlKSBhbmQgISh0eXBlIGlzYSBTZWxmKVxuXHRcdFx0IyBpZiB0aGlzIGlzIGFuIGl2YXIsIHdlIHNob3VsZCBzZXQgdGhlIHJlZmVyZW5jZSByZWxhdGl2ZVxuXHRcdFx0IyB0byB0aGUgb3V0ZXIgcmVmZXJlbmNlLCBvciBwb3NzaWJseSByaWdodCBvbiBjb250ZXh0P1xuXHRcdFx0dmFyIGN0eCwga2V5XG5cdFx0XHR2YXIgcGFydHJlZSA9IHBhcmVudCBhbmQgcGFyZW50LnRyZWVcblx0XHRcdCMgY3R4ID0gIW86aXZhciBhbmQgcGFyIGFuZCBwYXIucmVmZXJlbmNlIG9yIHNjb3BlLmNvbnRleHRcblx0XHRcdCMga2V5ID0gbzppdmFyIG9yIHRyZWUgYW5kIHRyZWUubmV4dENhY2hlS2V5XG5cblx0XHRcdGlmIG86a2V5XG5cdFx0XHRcdCMgY2xvc2VzdCB0YWdcblx0XHRcdFx0IyBUT0RPIGlmIHRoZSBkeW5hbWljIGtleSBzdGFydHMgd2l0aCBhIHN0YXRpYyBzdHJpbmcgd2Ugc2hvdWxkXG5cdFx0XHRcdCMganVzdCBwcmVwZW5kIF8gdG8gdGhlIHN0cmluZyBpbnN0ZWFkIG9mIHdyYXBwaW5nIGluIE9QXG5cdFx0XHRcdGN0eCA9IHBhcmVudCBhbmQgcGFyZW50LnJlZmVyZW5jZVxuXHRcdFx0XHRrZXkgPSBPUCgnKycsU3RyLm5ldyhcIidfJ1wiKSxvOmtleSlcblxuXHRcdFx0ZWxpZiBvOml2YXJcblx0XHRcdFx0Y3R4ID0gc2NvcGUuY29udGV4dFxuXHRcdFx0XHRrZXkgPSBvOml2YXJcblxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRjdHggPSBwYXJlbnQgYW5kIHBhcmVudC5yZWZlcmVuY2Vcblx0XHRcdFx0IyBjdHggPSBwYXJ0cmVlLmNhY2hlclxuXHRcdFx0XHRrZXkgPSBvOnRyZWVSZWYgb3IgcGFydHJlZSBhbmQgcGFydHJlZS5uZXh0Q2FjaGVLZXlcblx0XHRcdFx0IyBrZXkgPSB0cmVlIGFuZCB0cmVlLm5leHRDYWNoZUtleVxuXHRcdFx0XHRpZiBvOmxvb3Bcblx0XHRcdFx0XHRsZXQgaWR4ID0gbzpsb29wLm9wdGlvbig6dmFycylbOmluZGV4XVxuXHRcdFx0XHRcdGtleSA9IE9QKCcrJyxcIidcIiArIGtleSArIFwiJ1wiLGlkeClcblxuXG5cblx0XHRcdCMgbmVlZCB0aGUgY29udGV4dCAtLSBtaWdodCBiZSBiZXR0ZXIgdG8gcmV3cml0ZSBpdCBmb3IgcmVhbD9cblx0XHRcdCMgcGFyc2UgdGhlIHdob2xlIHRoaW5nIGludG8gY2FsbHMgZXRjXG5cdFx0XHR2YXIgYWNjID0gT1AoJy4nLGN0eCxrZXkpLmNcblxuXHRcdFx0aWYgQHJlZmVyZW5jZVxuXHRcdFx0XHRvdXQgPSBcIih7cmVmZXJlbmNlLmN9ID0ge2FjY309e2FjY30gfHwge291dH0pXCJcblx0XHRcdGVsc2Vcblx0XHRcdFx0b3V0ID0gXCIoe2FjY30gPSB7YWNjfSB8fCB7b3V0fSlcIlxuXG5cdFx0cmV0dXJuIG91dCArIGNhbGxzLmpvaW4oXCJcIilcblxuIyBUaGlzIGlzIGEgaGVscGVyLW5vZGVcbiMgU2hvdWxkIHByb2JhYmx5IHVzZSB0aGUgc2FtZSB0eXBlIG9mIGxpc3Rub2RlIGV2ZXJ5d2hlcmUgLSBhbmQgc2ltcGx5IGZsYWcgdGhlIHR5cGUgYXMgVGFnVHJlZSBpbnN0ZWFkXG5leHBvcnQgY2xhc3MgVGFnVHJlZSA8IExpc3ROb2RlXG5cdFxuXHRwcm9wIGNvdW50ZXJcblx0cHJvcCBjb25kaXRpb25zXG5cdHByb3AgYmxvY2tzXG5cdHByb3AgY2FjaGVyXG5cblx0ZGVmIGluaXRpYWxpemUgb3duZXIsIGxpc3QsIG9wdGlvbnMgPSB7fVxuXHRcdEBvd25lciA9IG93bmVyXG5cdFx0QG5vZGVzID0gbG9hZChsaXN0KVxuXHRcdEBvcHRpb25zID0gb3B0aW9uc1xuXHRcdEBjb25kaXRpb25zID0gW11cblx0XHRAYmxvY2tzID0gW3NlbGZdXG5cdFx0QGNvdW50ZXIgPSAwXG5cdFx0c2VsZlxuXG5cdGRlZiBwYXJlbnRcblx0XHRAcGFyZW50IHx8PSBAb3duZXIucGFyZW50XG5cblx0ZGVmIG5leHRDYWNoZUtleVxuXHRcdHZhciByb290ID0gQG93bmVyXG5cblx0XHQjIGlmIHdlIHdhbnQgdG8gY2FjaGUgZXZlcnl0aGluZyBvbiByb290XG5cdFx0dmFyIG51bSA9ICsrQGNvdW50ZXJcblx0XHR2YXIgYmFzZSA9IFwiQVwiLmNoYXJDb2RlQXQoMClcblx0XHR2YXIgc3RyID0gXCJcIlxuXG5cdFx0d2hpbGUgdHJ1ZVxuXHRcdFx0bnVtIC09IDFcblx0XHRcdHN0ciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoYmFzZSArIChudW0gJSAyNikpICsgc3RyXG5cdFx0XHRudW0gPSBNYXRoLmZsb29yKG51bSAvIDI2KVxuXHRcdFx0YnJlYWsgdW5sZXNzIG51bSA+IDBcblxuXHRcdHN0ciA9IChAb3duZXIudHlwZSBpc2EgU2VsZiA/IFwiJFwiIDogXCIkJFwiKSArIHN0ci50b0xvd2VyQ2FzZVxuXHRcdHJldHVybiBzdHJcblx0XHRyZXR1cm4gbnVtXG5cblx0ZGVmIGxvYWQgbGlzdFxuXHRcdGlmIGxpc3QgaXNhIExpc3ROb2RlXG5cdFx0XHQjIHAgXCJpcyBhIGxpc3Qgbm9kZSEhIHtsaXN0LmNvdW50fVwiXG5cdFx0XHQjIHdlIHN0aWxsIHdhbnQgdGhlIGluZGVudGF0aW9uIGlmIHdlIGFyZSBub3QgaW4gYSB0ZW1wbGF0ZVxuXHRcdFx0IyBvciwgcmF0aGVyIC0gd2Ugd2FudCB0aGUgYmxvY2sgdG8gZ2V0IHRoZSBpbmRlbnRhdGlvbiAtIG5vdCB0aGUgdHJlZVxuXHRcdFx0QGluZGVudGF0aW9uIHx8PSBsaXN0LkBpbmRlbnRhdGlvbiAjIGlmIGxpc3QuY291bnQgPiAxXG5cdFx0XHRsaXN0Lm5vZGVzXG5cdFx0ZWxzZVxuXHRcdFx0Y29tcGFjdF9fKGxpc3QgaXNhIEFycmF5ID8gbGlzdCA6IFtsaXN0XSlcblxuXHRkZWYgcm9vdFxuXHRcdG9wdGlvbig6cm9vdClcblxuXHRkZWYgcmVhY3RpdmVcblx0XHRvcHRpb24oOnJlYWN0aXZlKVxuXG5cdGRlZiByZXNvbHZlXG5cdFx0cmVtYXAgZG8gfGN8IGMuY29uc3VtZShzZWxmKVxuXHRcdHNlbGZcblxuXHRkZWYgc3RhdGljXG5cdFx0IyBldmVyeSByZWFsIG5vZGVcblx0XHRAc3RhdGljID89IGV2ZXJ5IGRvIHxjfCAoYyBpc2EgVGFnIG9yIGMgaXNhIFN0ciBvciBjIGlzYSBNZXRhKVxuXG5cdGRlZiBzaW5nbGVcblx0XHRAc2luZ2xlID89IChyZWFsQ291bnQgPT0gMSA/IGxhc3QgOiBubylcblxuXHRkZWYgaGFzVGFnc1xuXHRcdHNvbWUgZG8gfGN8IGMgaXNhIFRhZ1xuXG5cdGRlZiBjIG9cblx0XHQjIEZJWE1FIFRFU1Qgd2hhdCBhYm91dCBjb21tZW50cz8/P1xuXHRcdHZhciBzaW5nbGUgPSBzaW5nbGVcblxuXHRcdCMgbm8gaW5kZW50YXRpb24gaWYgdGhpcyBzaG91bGQgcmV0dXJuXG5cdFx0aWYgc2luZ2xlIGFuZCBTVEFDSy5jdXJyZW50IGlzYSBSZXR1cm5cblx0XHRcdEBpbmRlbnRhdGlvbiA9IG51bGxcblxuXHRcdHZhciBvdXQgPSBzdXBlcihvKVxuXG5cdFx0aWYgIXNpbmdsZSBvciBzaW5nbGUgaXNhIElmXG5cdFx0XHRcIlt7b3V0fV1cIlxuXHRcdGVsc2Vcblx0XHRcdG91dFxuXG5leHBvcnQgY2xhc3MgVGFnV3JhcHBlciA8IFZhbHVlTm9kZVxuXG5cdGRlZiB2aXNpdFxuXHRcdGlmIHZhbHVlIGlzYSBBcnJheVxuXHRcdFx0dmFsdWUubWFwKHx2fCB2LnRyYXZlcnNlKVxuXHRcdGVsc2Vcblx0XHRcdHZhbHVlLnRyYXZlcnNlXG5cdFx0c2VsZlxuXHRcdFxuXHRkZWYgY1xuXHRcdFwidGFnJHdyYXAoe3ZhbHVlLmMoZXhwcmVzc2lvbjogeWVzKX0pXCJcblxuXG5leHBvcnQgY2xhc3MgVGFnQXR0cmlidXRlcyA8IExpc3ROb2RlXG5cblx0ZGVmIGdldCBuYW1lXG5cdFx0Zm9yIG5vZGUgaW4gbm9kZXNcblx0XHRcdHJldHVybiBub2RlIGlmIG5vZGUua2V5ID09IG5hbWVcblx0XHRcblx0XHRcbmV4cG9ydCBjbGFzcyBUYWdBdHRyIDwgTm9kZVxuXG5cdHByb3Aga2V5XG5cdHByb3AgdmFsdWVcblxuXHRkZWYgdmlzaXRcblx0XHR2YWx1ZS50cmF2ZXJzZSBpZiB2YWx1ZVxuXHRcdHNlbGZcblxuXHRkZWYgaW5pdGlhbGl6ZSBrLCB2XG5cdFx0IyBwIFwiaW5pdCBUYWdBdHRyaWJ1dGVcIiwgJDBcblx0XHRAdHJhdmVyc2VkID0gbm9cblx0XHRAa2V5ID0ga1xuXHRcdEB2YWx1ZSA9IHZcblxuXHRkZWYgcG9wdWxhdGUgb2JqXG5cdFx0b2JqLmFkZChrZXksIHZhbHVlKVxuXHRcdHNlbGZcblxuXHRkZWYgY1xuXHRcdFwiYXR0cmlidXRlXCJcblxuXG5leHBvcnQgY2xhc3MgVGFnRmxhZyA8IE5vZGVcblxuXHRwcm9wIHZhbHVlXG5cdHByb3AgdG9nZ2xlclxuXG5cdGRlZiBpbml0aWFsaXplIHZhbHVlXG5cdFx0QHRyYXZlcnNlZCA9IG5vXG5cdFx0QHZhbHVlID0gdmFsdWVcblx0XHRzZWxmXG5cblx0ZGVmIHZpc2l0XG5cdFx0dW5sZXNzIEB2YWx1ZSBpc2EgU3RyaW5nXG5cdFx0XHRAdmFsdWUudHJhdmVyc2Vcblx0XHRzZWxmXG5cblx0ZGVmIGNcblx0XHRpZiB2YWx1ZSBpc2EgTm9kZVxuXHRcdFx0XCIuZmxhZyh7dmFsdWUuY30pXCJcblx0XHRlbHNlXG5cdFx0XHRcIi5mbGFnKHtoZWxwZXJzLnNpbmdsZXF1b3RlKHZhbHVlKX0pXCJcblx0XHRcblx0XHRcblxuXG5cblxuIyBTRUxFQ1RPUlNcblxuXG5leHBvcnQgY2xhc3MgU2VsZWN0b3IgPCBMaXN0Tm9kZVxuXHRcblx0ZGVmIGluaXRpYWxpemUgbGlzdCwgb3B0aW9uc1xuXHRcdEBub2RlcyA9IGxpc3Qgb3IgW11cblx0XHRAb3B0aW9ucyA9IG9wdGlvbnNcblx0XHRcblx0ZGVmIGFkZCBwYXJ0LCB0eXBcblx0XHQjIHAgXCJzZWxlY3QgYWRkIVwiLHBhcnQsdHlwXG5cdFx0IyBtYXJrIGlmIHNwZWNpYWw/XG5cdFx0cHVzaChwYXJ0KVxuXHRcdHNlbGZcblxuXHRkZWYgZ3JvdXBcblx0XHQjIGNvbnNvbGUubG9nIFwiZ3JvdXBlZCFcIlxuXHRcdCMgZm9yIG5vdyB3ZSBzaW1wbHkgYWRkIGEgY29tbWFcblx0XHQjIGhvdyB3b3VsZCB0aGlzIHdvcmsgZm9yIGRzdD9cblx0XHRAbm9kZXMucHVzaChTZWxlY3Rvckdyb3VwLm5ldyhcIixcIikpXG5cdFx0c2VsZlxuXG5cdGRlZiBxdWVyeVxuXHRcdHZhciBzdHIgPSBcIlwiXG5cdFx0dmFyIGFyeSA9IFtdXG5cblx0XHRmb3IgaXRlbSBpbiBub2Rlc1xuXHRcdFx0dmFyIHZhbCA9IGl0ZW0uY1xuXHRcdFx0aWYgdmFsIGlzYSBTdHJpbmdcblx0XHRcdFx0c3RyID0gXCJ7c3RyfXt2YWx9XCJcblxuXHRcdFwiJ3tzdHJ9J1wiXG5cblxuXHRkZWYganMgb1xuXHRcdHZhciB0eXAgPSBvcHRpb24oOnR5cGUpXG5cdFx0dmFyIHEgPSBjX18ocXVlcnkpXG5cblx0XHRpZiB0eXAgPT0gJyUnXG5cdFx0XHRcInEkKHtxfSx7by5zY29wZS5jb250ZXh0LmMoZXhwbGljaXQ6IHllcyl9KVwiICMgZXhwbGljaXQgY29udGV4dFxuXHRcdGVsaWYgdHlwID09ICclJSdcblx0XHRcdFwicSQkKHtxfSx7by5zY29wZS5jb250ZXh0LmMoZXhwbGljaXQ6IHllcyl9KVwiXG5cdFx0ZWxzZSBcblx0XHRcdFwicXt0eXB9KHtxfSlcIlxuXG5cdFx0IyByZXR1cm4gXCJ7dHlwfSB7c2NvcGVkfSAtIHthbGx9XCJcblx0XHRcblxuZXhwb3J0IGNsYXNzIFNlbGVjdG9yUGFydCA8IFZhbHVlTm9kZVxuXG5cdGRlZiBjXG5cdFx0Y19fKEB2YWx1ZSlcblx0XHQjIFwie3ZhbHVlLmN9XCJcblxuZXhwb3J0IGNsYXNzIFNlbGVjdG9yR3JvdXAgPCBTZWxlY3RvclBhcnRcblxuXHRkZWYgY1xuXHRcdFwiLFwiXG5cbmV4cG9ydCBjbGFzcyBTZWxlY3RvclR5cGUgPCBTZWxlY3RvclBhcnRcblxuXHRkZWYgY1xuXHRcdCMgc3VwcG9ydFxuXHRcdCMgcCBcInNlbGVjdG9ydHlwZSB7dmFsdWV9XCJcblx0XHQjIHZhciBvdXQgPSB2YWx1ZS5jXG5cdFx0dmFyIG5hbWUgPSB2YWx1ZS5uYW1lXG5cdFxuXHRcdCMgYXQgbGVhc3QgYmUgdmVyeSBjb25zZXJ2YXRpdmUgYWJvdXQgd2hpY2ggdGFncyB3ZVxuXHRcdCMgY2FuIGRyb3AgdGhlIHRhZyBmb3I/XG5cdFx0IyBvdXQgaW4gVEFHX1RZUEVTLkhUTUwgPyBcblx0XHRuYW1lIGluIFRBR19UWVBFUy5IVE1MID8gbmFtZSA6IHZhbHVlLnNlbFxuXG5cbmV4cG9ydCBjbGFzcyBTZWxlY3RvclVuaXZlcnNhbCA8IFNlbGVjdG9yUGFydFxuXG5leHBvcnQgY2xhc3MgU2VsZWN0b3JOYW1lc3BhY2UgPCBTZWxlY3RvclBhcnRcblxuZXhwb3J0IGNsYXNzIFNlbGVjdG9yQ2xhc3MgPCBTZWxlY3RvclBhcnRcblxuXHRkZWYgY1xuXHRcdGlmIEB2YWx1ZSBpc2EgTm9kZVxuXHRcdFx0XCIuJyt7QHZhbHVlLmN9KydcIlxuXHRcdGVsc2Vcblx0XHRcdFwiLntjX18oQHZhbHVlKX1cIlxuXG5leHBvcnQgY2xhc3MgU2VsZWN0b3JJZCA8IFNlbGVjdG9yUGFydFxuXG5cdGRlZiBjXG5cdFx0aWYgQHZhbHVlIGlzYSBOb2RlXG5cdFx0XHRcIiMnK3tAdmFsdWUuY30rJ1wiXG5cdFx0ZWxzZVxuXHRcdFx0XCIje2NfXyhAdmFsdWUpfVwiXG5cbmV4cG9ydCBjbGFzcyBTZWxlY3RvckNvbWJpbmF0b3IgPCBTZWxlY3RvclBhcnRcblxuXHRkZWYgY1xuXHRcdFwie2NfXyhAdmFsdWUpfVwiXG5cbmV4cG9ydCBjbGFzcyBTZWxlY3RvclBzZXVkb0NsYXNzIDwgU2VsZWN0b3JQYXJ0XG5cbmV4cG9ydCBjbGFzcyBTZWxlY3RvckF0dHJpYnV0ZSA8IFNlbGVjdG9yUGFydFxuXG5cdCMgcmVtZW1iZXIgdG8gdmlzaXQgbm9kZXMgaW5zaWRlIGhlcmU/XG5cdGRlZiBpbml0aWFsaXplIGxlZnQsb3AscmlnaHRcblx0XHRAbGVmdCA9IGxlZnRcblx0XHRAb3AgPSBvcFxuXHRcdEByaWdodCA9IEB2YWx1ZSA9IHJpZ2h0XG5cblx0ZGVmIGNcblx0XHQjIFRPRE8gcG9zc2libHkgc3VwcG9ydCAudG9TZWwgb3Igc2VsJCh2KSBmb3IgaXRlbXMgaW5zaWRlIHF1ZXJ5XG5cdFx0IyBjb3VsZCBlYXNpbHkgZG8gaXQgd2l0aCBhIGhlbHBlci1mdW5jdGlvbiB0aGF0IGlzIGFkZGVkIHRvIHRoZSB0b3Agb2YgdGhlIGZpbGVzY29wZVxuXHRcdGlmIEByaWdodCBpc2EgU3RyXG5cdFx0XHRcIlt7QGxlZnQuY317QG9wfXtAcmlnaHQuY31dXCJcblx0XHRlbGlmIEByaWdodFxuXHRcdFx0IyB0aGlzIGlzIG5vdCBhdCBhbGwgZ29vZFxuXHRcdFx0XCJbe0BsZWZ0LmN9e0BvcH1cXFwiJyt7Y19fKEByaWdodCl9KydcXFwiXVwiXG5cdFx0ZWxzZVxuXHRcdFx0XCJbe0BsZWZ0LmN9XVwiXG5cdFx0XG5cdFx0XHQjIC4uLlxuXHRcdFxuXG5cblxuIyBERUZFUlxuXG5leHBvcnQgY2xhc3MgQXdhaXQgPCBWYWx1ZU5vZGVcblxuXHRwcm9wIGZ1bmNcblxuXHRkZWYganMgb1xuXHRcdCMgaW50cm9kdWNlIGEgdXRpbCBoZXJlLCBubz9cblx0XHRDQUxMKE9QKCcuJyxVdGlsLlByb21pc2lmeS5uZXcoW3ZhbHVlXSksJ3RoZW4nKSxbZnVuY10pLmNcblx0XHQjIHZhbHVlLmNcblx0XG5cdGRlZiB2aXNpdCBvXG5cdFx0IyB0aGluZ3MgYXJlIG5vdyB0cmF2ZXJzZWQgaW4gYSBzb21ld2hhdCBjaGFvdGljIG9yZGVyLiBOZWVkIHRvIHRpZ2h0ZW5cblx0XHQjIENyZWF0ZSBhd2FpdCBmdW5jdGlvbiAtIHB1c2ggdGhpcyB2YWx1ZSB1cCB0byBibG9jaywgdGFrZSB0aGUgb3V0ZXJcblx0XHR2YWx1ZS50cmF2ZXJzZVxuXG5cdFx0dmFyIGJsb2NrID0gby51cChCbG9jaykgIyBvciB1cCB0byB0aGUgY2xvc2VzdCBGVU5DVElPTj9cblx0XHR2YXIgb3V0ZXIgPSBvLnJlbGF0aXZlKGJsb2NrLDEpXG5cdFx0dmFyIHBhciA9IG8ucmVsYXRpdmUoc2VsZiwtMSlcblxuXHRcdCMgcCBcIkJsb2NrIHtibG9ja30ge291dGVyfSB7cGFyfVwiXG5cblx0XHRmdW5jID0gQXN5bmNGdW5jLm5ldyhbXSxbXSlcblx0XHQjIG5vdyB3ZSBtb3ZlIHRoaXMgbm9kZSB1cCB0byB0aGUgYmxvY2tcblx0XHRmdW5jLmJvZHkubm9kZXMgPSBibG9jay5kZWZlcnMob3V0ZXIsc2VsZilcblxuXHRcdCMgaWYgdGhlIG91dGVyIGlzIGEgdmFyLWFzc2lnbm1lbnQsIHdlIGNhbiBzaW1wbHkgc2V0IHRoZSBwYXJhbXNcblx0XHRpZiBwYXIgaXNhIEFzc2lnblxuXHRcdFx0cGFyLmxlZnQudHJhdmVyc2Vcblx0XHRcdHZhciBsZnQgPSBwYXIubGVmdC5ub2RlXG5cdFx0XHQjIHAgXCJBc3luYyBhc3NpZ25tZW50IHtwYXJ9IHtsZnR9XCJcblx0XHRcdCMgQ2FuIGJlIGEgdHVwbGUgYXMgd2VsbCwgbm8/XG5cdFx0XHRpZiBsZnQgaXNhIFZhclJlZmVyZW5jZVxuXHRcdFx0XHQjIHRoZSBwYXJhbSBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQ/XG5cdFx0XHRcdCMgc2hvdWxkIG5vdCBmb3JjZSB0aGUgbmFtZSBhbHJlYWR5Pz9cblx0XHRcdFx0IyBiZXdhcmUgb2YgYnVnc1xuXHRcdFx0XHRmdW5jLnBhcmFtcy5hdCgwLHllcyxsZnQudmFyaWFibGUubmFtZSlcblx0XHRcdGVsaWYgbGZ0IGlzYSBUdXBsZVxuXHRcdFx0XHQjIGlmIHRoaXMgYW4gdW5mYW5jeSB0dXBsZSwgd2l0aCBvbmx5IHZhcnNcblx0XHRcdFx0IyB3ZSBjYW4ganVzdCB1c2UgYXJndW1lbnRzXG5cblx0XHRcdFx0aWYgcGFyLnR5cGUgPT0gJ3ZhcicgJiYgIWxmdC5oYXNTcGxhdFxuXHRcdFx0XHRcdCMgcCBcIlNJTVBMSUZZISB7bGZ0Lm5vZGVzWzBdfVwiXG5cdFx0XHRcdFx0bGZ0Lm1hcCBkbyB8ZWwsaXxcblx0XHRcdFx0XHRcdGZ1bmMucGFyYW1zLmF0KGkseWVzLGVsLnZhbHVlKVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0IyBvdGhlcndpc2UsIGRvIHRoZSB3aG9sZSB0dXBsZVxuXHRcdFx0XHRcdCMgbWFrZSBzdXJlIGl0IGlzIGEgdmFyIGFzc2lnbm1lbnQ/XG5cdFx0XHRcdFx0cGFyLnJpZ2h0ID0gQVJHVU1FTlRTXG5cdFx0XHRcdFx0ZnVuYy5ib2R5LnVuc2hpZnQocGFyKVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHQjIHJlZ3VsYXIgc2V0dGVyc1xuXHRcdFx0XHRwYXIucmlnaHQgPSBmdW5jLnBhcmFtcy5hdCgwLHllcylcblx0XHRcdFx0ZnVuYy5ib2R5LnVuc2hpZnQocGFyKVxuXHRcdFx0XHRcblx0XHRcdFxuXG5cdFx0IyBJZiBpdCBpcyBhbiBhZHZhbmNlIHR1cGxlIG9yIHNvbWV0aGluZywgaXQgc2hvdWxkIGJlIHBvc3NpYmxlIHRvXG5cdFx0IyBmZWVkIGluIHRoZSBwYXJhbWxpc3QsIGFuZCBsZXQgdGhlIHR1cGxlIGhhbmRsZSBpdCBhcyBpZiBpdCB3YXMgYW55XG5cdFx0IyBvdGhlciB2YWx1ZVxuXG5cdFx0IyBDQVNFIElmIHRoaXMgaXMgYSB0dXBsZSAvIG11bHRpc2V0IHdpdGggbW9yZSB0aGFuIG9uZSBhc3luYyB2YWx1ZVxuXHRcdCMgd2UgbmVlZCB0byB0aGluayBkaWZmZXJlbnRseS5cblxuXHRcdCMgbm93IHdlIG5lZWQgdG8gdmlzaXQgdGhlIGZ1bmN0aW9uIGFzIHdlbGxcblx0XHRmdW5jLnRyYXZlcnNlXG5cdFx0IyBwdWxsIHRoZSBvdXRlciBpblxuXHRcdHNlbGZcblxuZXhwb3J0IGNsYXNzIEFzeW5jRnVuYyA8IEZ1bmNcblxuXHRkZWYgaW5pdGlhbGl6ZSBwYXJhbXMsIGJvZHksIG5hbWUsIHRhcmdldCwgb3B0aW9uc1xuXHRcdHN1cGVyKHBhcmFtcyxib2R5LG5hbWUsdGFyZ2V0LG9wdGlvbnMpXG5cblx0ZGVmIHNjb3BldHlwZSBkbyBMYW1iZGFTY29wZVxuXG5cdCMgbmVlZCB0byBvdmVycmlkZSwgc2luY2Ugd2Ugd29udCBkbyBpbXBsaWNpdCByZXR1cm5zXG5cdCMgZGVmIGpzXG5cdCMgXHR2YXIgY29kZSA9IHNjb3BlLmNcblx0IyBcdHJldHVybiBcImZ1bmN0aW9uICh7cGFyYW1zLmN9KVwiICsgY29kZS53cmFwXG5cblxuXG4jIElNUE9SVFNcblxuZXhwb3J0IGNsYXNzIEltcG9ydFN0YXRlbWVudCA8IFN0YXRlbWVudFxuXG5cblx0cHJvcCBuc1xuXHRwcm9wIGltcG9ydHNcblx0cHJvcCBzb3VyY2VcblxuXG5cdGRlZiBpbml0aWFsaXplIGltcG9ydHMsIHNvdXJjZSwgbnNcblx0XHRAdHJhdmVyc2VkID0gbm9cblx0XHRAaW1wb3J0cyA9IGltcG9ydHNcblx0XHRAc291cmNlID0gc291cmNlXG5cdFx0QG5zID0gbnNcblx0XHRzZWxmXG5cblx0ZGVmIHZpc2l0XG5cdFx0aWYgQG5zXG5cdFx0XHRAbnN2YXIgfHw9IHNjb3BlX18ucmVnaXN0ZXIoQG5zLHNlbGYpXG5cdFx0ZWxzZVxuXHRcdFx0dmFyIHNyYyA9IHNvdXJjZS5jXG5cdFx0XHR2YXIgbSA9IHNyYy5tYXRjaCgvKFxcdyspKFxcLmpzfGltYmEpP1tcXFwiXFwnXSQvKVxuXHRcdFx0QGFsaWFzID0gbSA/IG1bMV0gKyAnJCcgOiAnbW9kJCdcblx0XHRcblx0XHQjIHNob3VsZCBhbHNvIHJlZ2lzdGVyIHRoZSBpbXBvcnRlZCBpdGVtcywgbm8/XG5cdFx0aWYgQGltcG9ydHNcblx0XHRcdHZhciBkZWMgPSBAZGVjbGFyYXRpb25zID0gVmFyaWFibGVEZWNsYXJhdGlvbi5uZXcoW10pXG5cblx0XHRcdGlmIEBpbXBvcnRzOmxlbmd0aCA9PSAxXG5cdFx0XHRcdEBhbGlhcyA9IEBpbXBvcnRzWzBdXG5cdFx0XHRcdGRlYy5hZGQoQGFsaWFzLE9QKCcuJyxDQUxMKElkZW50aWZpZXIubmV3KFwicmVxdWlyZVwiKSxbc291cmNlXSksQGFsaWFzKSlcblx0XHRcdFx0ZGVjLnRyYXZlcnNlXG5cdFx0XHRcdHJldHVybiBzZWxmXG5cdFx0XHRcdFxuXHRcdFx0XHQjIGRlYy5hZGQoQGFsaWFzLENBTEwoSWRlbnRpZmllci5uZXcoXCJyZXF1aXJlXCIpLFtzb3VyY2VdKSlcblxuXHRcdFx0IyBwIFwiSW1wb3J0U3RhdGVtZW50IGhhcyBpbXBvcnRzIHtAaW1wb3J0czpsZW5ndGh9XCJcblx0XHRcdCMgQGRlY2xhcmF0aW9ucyA9IFZhcmlhYmxlRGVjbGFyYXRpb24ubmV3KFtdKVxuXHRcdFx0QG1vZHVsZWRlY2wgPSBkZWMuYWRkKEBhbGlhcyxDQUxMKElkZW50aWZpZXIubmV3KFwicmVxdWlyZVwiKSxbc291cmNlXSkpXG5cdFx0XHRAbW9kdWxlZGVjbC50cmF2ZXJzZVxuXG5cblx0XHRcdGlmIEBpbXBvcnRzOmxlbmd0aCA+IDFcblx0XHRcdFx0Zm9yIGltcCBpbiBAaW1wb3J0c1xuXHRcdFx0XHRcdEBkZWNsYXJhdGlvbnMuYWRkKGltcCxPUCgnLicsQG1vZHVsZWRlY2wudmFyaWFibGUsaW1wKSlcblxuXHRcdFx0ZGVjLnRyYXZlcnNlXG5cdFx0c2VsZlxuXG5cblx0ZGVmIGpzIG9cblxuXHRcdGlmIEBkZWNsYXJhdGlvbnNcblx0XHRcdHJldHVybiBAZGVjbGFyYXRpb25zLmNcblxuXHRcdHZhciByZXEgPSBDQUxMKElkZW50aWZpZXIubmV3KFwicmVxdWlyZVwiKSxbc291cmNlXSlcblxuXHRcdGlmIEBuc1xuXHRcdFx0IyBtdXN0IHJlZ2lzdGVyIG5zIGFzIGEgcmVhbCB2YXJpYWJsZVxuXHRcdFx0cmV0dXJuIFwidmFyIHtAbnN2YXIuY30gPSB7cmVxLmN9XCJcblxuXHRcdGlmIEBpbXBvcnRzXG5cblx0XHRcdHZhciBzcmMgPSBzb3VyY2UuY1xuXHRcdFx0dmFyIGFsaWFzID0gW11cblx0XHRcdHZhciB2YXJzID0gVmFyQmxvY2submV3KFtdKVxuXG5cdFx0XHRpZiB2YXIgZm5hbWUgPSBzcmMubWF0Y2goLyhcXHcrKShcXC5qc3xpbWJhKT9bXFxcIlxcJ10kLylcblx0XHRcdFx0YWxpYXMucHVzaChmbmFtZVsxXSlcblxuXHRcdFx0IyB2YXIgYWxpYXMgPSBzcmMubWF0Y2goLyhcXHcrKShcXC5qc3xpbWJhKT9bXFxcIlxcJ10kLylcblx0XHRcdCMgcCBcInNvdXJjZSB0eXBlIHtzb3VyY2V9XCJcblx0XHRcdCMgY3JlYXRlIGEgcmVxdWlyZSBmb3IgdGhlIHNvdXJjZSwgd2l0aCBhIHRlbXBvcmFyeSBuYW1lP1xuXHRcdFx0dmFyIG91dCA9IFtyZXEuY2FjaGUobmFtZXM6IGFsaWFzKS5jXVxuXG5cdFx0XHRmb3IgaW1wIGluIEBpbXBvcnRzXG5cdFx0XHRcdCMgd2UgYWxzbyBuZWVkIHRvIHJlZ2lzdGVyIHRoZXNlIGltcG9ydHMgYXMgdmFyaWFibGVzLCBubz9cblx0XHRcdFx0dmFyIG8gPSBPUCgnPScsaW1wLE9QKCcuJyxyZXEsaW1wKSlcblx0XHRcdFx0b3V0LnB1c2goXCJ2YXIge28uY31cIilcblxuXHRcdFx0cmV0dXJuIG91dFxuXHRcdGVsc2Vcblx0XHRcdHJldHVybiByZXEuY1xuXG5cdGRlZiBjb25zdW1lIG5vZGVcblx0XHRyZXR1cm4gc2VsZlxuXG5cbiMgRVhQT1JUIFxuXG5leHBvcnQgY2xhc3MgRXhwb3J0U3RhdGVtZW50IDwgVmFsdWVOb2RlXG5cblx0ZGVmIGpzIG9cblx0XHR2YXIgbm9kZXMgPSBAdmFsdWUubWFwIGRvIHxhcmd8IFwibW9kdWxlLmV4cG9ydHMue2FyZy5jfSA9IHthcmcuY31cIlxuXG5cdFx0aWYgbm9kZXM6bGVuZ3RoID4gMSBhbmQgdXAgaXNhIFJldHVyblxuXHRcdFx0cmV0dXJuICdbJyArIG5vZGVzLmpvaW4oJywnKSArICddJ1xuXG5cdFx0ZWxzZVxuXHRcdFx0cmV0dXJuIG5vZGVzLmpvaW4oJztcXG4nKSArICc7J1xuXG5cbiMgVVRJTFNcblxuZXhwb3J0IGNsYXNzIFV0aWwgPCBOb2RlXG5cblx0cHJvcCBhcmdzXG5cblx0ZGVmIGluaXRpYWxpemUgYXJnc1xuXHRcdEBhcmdzID0gYXJnc1xuXHRcdFxuXHQjIHRoaXMgaXMgaG93IHdlIGRlYWwgd2l0aCBpdCBub3dcblx0ZGVmIHNlbGYuZXh0ZW5kIGEsYlxuXHRcdFV0aWwuRXh0ZW5kLm5ldyhbYSxiXSlcblxuXHRkZWYgc2VsZi5jYWxsSW1iYSBtZXRoLCBhcmdzXG5cdFx0Q0FMTChPUCgnLicsQ29uc3QubmV3KFwiSW1iYVwiKSxJZGVudGlmaWVyLm5ldyhtZXRoKSksYXJncylcblxuXHRkZWYgc2VsZi5yZXBlYXQgc3RyLCB0aW1lc1xuXHRcdHZhciByZXMgPSAnJ1xuXHRcdHdoaWxlIHRpbWVzID4gMFxuXHRcdFx0aWYgdGltZXMgJSAyID09IDFcblx0XHRcdFx0cmVzICs9IHN0clxuXHRcdFx0c3RyICs9IHN0clxuXHRcdFx0dGltZXMgPj49IDFcblx0XHRyZXR1cm4gcmVzXG5cdFx0XG5cdFx0XG5cblx0ZGVmIHNlbGYua2V5cyBvYmpcblx0XHR2YXIgbCA9IENvbnN0Lm5ldyhcIk9iamVjdFwiKVxuXHRcdHZhciByID0gSWRlbnRpZmllci5uZXcoXCJrZXlzXCIpXG5cdFx0Q0FMTChPUCgnLicsbCxyKSxbb2JqXSlcblxuXHRkZWYgc2VsZi5sZW4gb2JqLCBjYWNoZVxuXHRcdCMgcCBcIkxFTiBIRUxQRVJcIi5ncmVlblxuXHRcdHZhciByID0gSWRlbnRpZmllci5uZXcoXCJsZW5ndGhcIilcblx0XHR2YXIgbm9kZSA9IE9QKCcuJywgb2JqLCByKVxuXHRcdG5vZGUuY2FjaGUoZm9yY2U6IHllcywgcG9vbDogJ2xlbicpIGlmIGNhY2hlXG5cdFx0cmV0dXJuIG5vZGVcblxuXHRkZWYgc2VsZi5pbmRleE9mIGxmdCwgcmd0XG5cdFx0dmFyIG5vZGUgPSBVdGlsLkluZGV4T2YubmV3KFtsZnQscmd0XSlcblx0XHQjIG5vZGUuY2FjaGUoZm9yY2U6IHllcywgdHlwZTogJ2l0ZXInKSBpZiBjYWNoZVxuXHRcdHJldHVybiBub2RlXG5cblx0ZGVmIHNlbGYuc2xpY2Ugb2JqLCBhLCBiXG5cdFx0dmFyIHNsaWNlID0gSWRlbnRpZmllci5uZXcoXCJzbGljZVwiKVxuXHRcdGNvbnNvbGUubG9nIFwic2xpY2Uge2F9IHtifVwiXG5cdFx0cmV0dXJuIENBTEwoT1AoJy4nLG9iaixzbGljZSksY29tcGFjdF9fKFthLGJdKSlcblx0XG5cdGRlZiBzZWxmLml0ZXJhYmxlIG9iaiwgY2FjaGVcblx0XHR2YXIgbm9kZSA9IFV0aWwuSXRlcmFibGUubmV3KFtvYmpdKVxuXHRcdG5vZGUuY2FjaGUoZm9yY2U6IHllcywgcG9vbDogJ2l0ZXInKSBpZiBjYWNoZVxuXHRcdHJldHVybiBub2RlXG5cblxuXG5cdGRlZiBzZWxmLnVuaW9uIGEsYlxuXHRcdFV0aWwuVW5pb24ubmV3KFthLGJdKVxuXHRcdCMgQ0FMTChVTklPTixbYSxiXSlcblxuXHRkZWYgc2VsZi5pbnRlcnNlY3QgYSxiXG5cdFx0VXRpbC5JbnRlcnNlY3QubmV3KFthLGJdKVxuXHRcdCMgQ0FMTChJTlRFUlNFQ1QsW2EsYl0pXG5cblx0ZGVmIHNlbGYuY291bnRlciBzdGFydCwgY2FjaGVcblx0XHQjIHNob3VsZCBpdCBub3QgcmF0aGVyIGJlIGEgdmFyaWFibGU/IT9cblx0XHR2YXIgbm9kZSA9IE51bS5uZXcoc3RhcnQpICMgbWFrZSBzdXJlIGl0IHJlYWxseSBpcyBhIG51bWJlclxuXHRcdG5vZGUuY2FjaGUoZm9yY2U6IHllcywgcG9vbDogJ2NvdW50ZXInKSBpZiBjYWNoZVxuXHRcdHJldHVybiBub2RlXG5cblx0ZGVmIHNlbGYuYXJyYXkgc2l6ZSwgY2FjaGVcblx0XHR2YXIgbm9kZSA9IFV0aWwuQXJyYXkubmV3KFtzaXplXSlcblx0XHRub2RlLmNhY2hlKGZvcmNlOiB5ZXMsIHBvb2w6ICdsaXN0JykgaWYgY2FjaGVcblx0XHRyZXR1cm4gbm9kZVxuXG5cdGRlZiBzZWxmLmRlZmluZVRhZyB0eXBlLCBjdG9yLCBzdXByXG5cdFx0Q0FMTChUQUdERUYsW3R5cGUsY3RvcixzdXByXSlcblxuXG5cdGRlZiBzZWxmLmRlZmluZUNsYXNzIG5hbWUsIHN1cHIsIGluaXRvclxuXHRcdENBTEwoQ0xBU1NERUYsW25hbWUgb3IgaW5pdG9yLHN1cF0pXG5cblx0ZGVmIGlzU3RhbmRhbG9uZVxuXHRcdE9QVFM6c3RhbmRhbG9uZSAhPT0gbm9cblxuXHRkZWYganMgb1xuXHRcdFwiaGVscGVyXCJcblxuIyBUT0RPIERlcHJlY2F0ZSBhbmQgcmVtb3ZlXG5leHBvcnQgY2xhc3MgVXRpbC5VbmlvbiA8IFV0aWxcblxuXHRkZWYgaGVscGVyXG5cdFx0JycnXG5cdFx0ZnVuY3Rpb24gdW5pb24kKGEsYil7XG5cdFx0XHRpZihhICYmIGEuX191bmlvbikgcmV0dXJuIGEuX191bmlvbihiKTtcblxuXHRcdFx0dmFyIHUgPSBhLnNsaWNlKDApO1xuXHRcdFx0Zm9yKHZhciBpPTAsbD1iLmxlbmd0aDtpPGw7aSsrKSBpZih1LmluZGV4T2YoYltpXSkgPT0gLTEpIHUucHVzaChiW2ldKTtcblx0XHRcdHJldHVybiB1O1xuXHRcdH07XG5cblx0XHQnJydcblxuXHRkZWYganMgb1xuXHRcdHNjb3BlX18ucm9vdC5oZWxwZXIoc2VsZixoZWxwZXIpXG5cdFx0IyBXaGVuIHRoaXMgaXMgdHJpZ2dlcmVkLCB3ZSBuZWVkIHRvIGFkZCBpdCB0byB0aGUgdG9wIG9mIGZpbGU/XG5cdFx0XCJ1bmlvbiQoe2FyZ3MubWFwKHx2fCB2LmMgKS5qb2luKCcsJyl9KVwiXG5cbiMgVE9ETyBEZXByZWNhdGUgYW5kIHJlbW92ZVxuZXhwb3J0IGNsYXNzIFV0aWwuSW50ZXJzZWN0IDwgVXRpbFxuXG5cdGRlZiBoZWxwZXJcblx0XHQnJydcblx0XHRmdW5jdGlvbiBpbnRlcnNlY3QkKGEsYil7XG5cdFx0XHRpZihhICYmIGEuX19pbnRlcnNlY3QpIHJldHVybiBhLl9faW50ZXJzZWN0KGIpO1xuXHRcdFx0dmFyIHJlcyA9IFtdO1xuXHRcdFx0Zm9yKHZhciBpPTAsIGw9YS5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHRcdHZhciB2ID0gYVtpXTtcblx0XHRcdFx0aWYoYi5pbmRleE9mKHYpICE9IC0xKSByZXMucHVzaCh2KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXM7XG5cdFx0fTtcblxuXHRcdCcnJ1xuXG5cdGRlZiBqcyBvXG5cdFx0IyBXaGVuIHRoaXMgaXMgdHJpZ2dlcmVkLCB3ZSBuZWVkIHRvIGFkZCBpdCB0byB0aGUgdG9wIG9mIGZpbGU/XG5cdFx0c2NvcGVfXy5yb290LmhlbHBlcihzZWxmLGhlbHBlcilcblx0XHRcImludGVyc2VjdCQoe2FyZ3MubWFwKHx2fCB2LmMgKS5qb2luKCcsJyl9KVwiXG5cbmV4cG9ydCBjbGFzcyBVdGlsLkV4dGVuZCA8IFV0aWxcblxuXHRkZWYganMgb1xuXHRcdCMgV2hlbiB0aGlzIGlzIHRyaWdnZXJlZCwgd2UgbmVlZCB0byBhZGQgaXQgdG8gdGhlIHRvcCBvZiBmaWxlP1xuXHRcdFwiZXh0ZW5kJCh7Y29tcGFjdF9fKGNhcnlfXyhhcmdzKSkuam9pbignLCcpfSlcIlxuXG5leHBvcnQgY2xhc3MgVXRpbC5JbmRleE9mIDwgVXRpbFxuXG5cdGRlZiBoZWxwZXJcblx0XHQnJydcblx0XHRmdW5jdGlvbiBpZHgkKGEsYil7XG5cdFx0XHRyZXR1cm4gKGIgJiYgYi5pbmRleE9mKSA/IGIuaW5kZXhPZihhKSA6IFtdLmluZGV4T2YuY2FsbChhLGIpO1xuXHRcdH07XG5cblx0XHQnJydcblxuXHRkZWYganMgb1xuXHRcdGlmIGlzU3RhbmRhbG9uZVxuXHRcdFx0c2NvcGVfXy5yb290LmhlbHBlcihzZWxmLGhlbHBlcilcblx0XHRcdCMgV2hlbiB0aGlzIGlzIHRyaWdnZXJlZCwgd2UgbmVlZCB0byBhZGQgaXQgdG8gdGhlIHRvcCBvZiBmaWxlP1xuXHRcdFx0XCJpZHgkKHthcmdzLm1hcCh8dnwgdi5jICkuam9pbignLCcpfSlcIlxuXHRcdGVsc2Vcblx0XHRcdFwiSW1iYS5pbmRleE9mKHthcmdzLm1hcCh8dnwgdi5jICkuam9pbignLCcpfSlcIlxuXHRcdFxuXG5leHBvcnQgY2xhc3MgVXRpbC5TdWJjbGFzcyA8IFV0aWxcblxuXHRkZWYgaGVscGVyXG5cdFx0IyBzaG91bGQgYWxzbyBjaGVjayBpZiBpdCBpcyBhIHJlYWwgcHJvbWlzZVxuXHRcdCcnJ1xuXHRcdC8vIGhlbHBlciBmb3Igc3ViY2xhc3Npbmdcblx0XHRmdW5jdGlvbiBzdWJjbGFzcyQob2JqLHN1cCkge1xuXHRcdFx0Zm9yICh2YXIgayBpbiBzdXApIHtcblx0XHRcdFx0aWYgKHN1cC5oYXNPd25Qcm9wZXJ0eShrKSkgb2JqW2tdID0gc3VwW2tdO1xuXHRcdFx0fTtcblx0XHRcdC8vIG9iai5fX3N1cGVyX18gPSBzdXA7XG5cdFx0XHRvYmoucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXAucHJvdG90eXBlKTtcblx0XHRcdG9iai5fX3N1cGVyX18gPSBvYmoucHJvdG90eXBlLl9fc3VwZXJfXyA9IHN1cC5wcm90b3R5cGU7XG5cdFx0XHRvYmoucHJvdG90eXBlLmluaXRpYWxpemUgPSBvYmoucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gb2JqO1xuXHRcdH07XG5cblx0XHQnJydcblxuXHRkZWYganMgb1xuXHRcdGlmIGlzU3RhbmRhbG9uZVxuXHRcdFx0IyBXaGVuIHRoaXMgaXMgdHJpZ2dlcmVkLCB3ZSBuZWVkIHRvIGFkZCBpdCB0byB0aGUgdG9wIG9mIGZpbGU/XG5cdFx0XHRzY29wZV9fLnJvb3QuaGVscGVyKHNlbGYsaGVscGVyKVxuXHRcdFx0XCJzdWJjbGFzcyQoe2FyZ3MubWFwKHx2fCB2LmMpLmpvaW4oJywnKX0pO1xcblwiXG5cdFx0ZWxzZVxuXHRcdFx0XCJJbWJhLnN1YmNsYXNzKHthcmdzLm1hcCh8dnwgdi5jKS5qb2luKCcsJyl9KTtcXG5cIlxuXG5leHBvcnQgY2xhc3MgVXRpbC5Qcm9taXNpZnkgPCBVdGlsXG5cblx0ZGVmIGhlbHBlclxuXHRcdCMgc2hvdWxkIGFsc28gY2hlY2sgaWYgaXQgaXMgYSByZWFsIHByb21pc2Vcblx0XHRcImZ1bmN0aW9uIHByb21pc2UkKGEpXFx7IHJldHVybiBhIGluc3RhbmNlb2YgQXJyYXkgPyBQcm9taXNlLmFsbChhKSA6IChhICYmIGEudGhlbiA/IGEgOiBQcm9taXNlLnJlc29sdmUoYSkpOyBcXH1cIlxuXHRcdFxuXHRkZWYganMgb1xuXHRcdGlmIGlzU3RhbmRhbG9uZVxuXHRcdFx0IyBXaGVuIHRoaXMgaXMgdHJpZ2dlcmVkLCB3ZSBuZWVkIHRvIGFkZCBpdCB0byB0aGUgdG9wIG9mIGZpbGU/XG5cdFx0XHRzY29wZV9fLnJvb3QuaGVscGVyKHNlbGYsaGVscGVyKVxuXHRcdFx0XCJwcm9taXNlJCh7YXJncy5tYXAofHZ8IHYuYykuam9pbignLCcpfSlcIlxuXHRcdGVsc2Vcblx0XHRcdFwiSW1iYS5hd2FpdCh7YXJncy5tYXAofHZ8IHYuYykuam9pbignLCcpfSlcIlxuXHRcdFxuIyBUT0RPIGRlcHJlY2F0ZWQ6IGNhbiByZW1vdmVcbmV4cG9ydCBjbGFzcyBVdGlsLkNsYXNzIDwgVXRpbFxuXG5cdGRlZiBqcyBvXG5cdFx0IyBXaGVuIHRoaXMgaXMgdHJpZ2dlcmVkLCB3ZSBuZWVkIHRvIGFkZCBpdCB0byB0aGUgdG9wIG9mIGZpbGU/XG5cdFx0XCJjbGFzcyQoe2FyZ3MubWFwKHx2fCB2LmMpLmpvaW4oJywnKX0pXCJcblxuZXhwb3J0IGNsYXNzIFV0aWwuSXRlcmFibGUgPCBVdGlsXG5cblx0ZGVmIGhlbHBlclxuXHRcdCMgbm93IHdlIHdhbnQgdG8gYWxsb3cgbnVsbCB2YWx1ZXMgYXMgd2VsbCAtIGp1c3QgcmV0dXJuIGFzIGVtcHR5IGNvbGxlY3Rpb25cblx0XHQjIHNob3VsZCBiZSB0aGUgc2FtZSBmb3IgZm9yIG93biBvZiBJIGd1ZXNzXG5cdFx0XCJmdW5jdGlvbiBpdGVyJChhKVxceyByZXR1cm4gYSA/IChhLnRvQXJyYXkgPyBhLnRvQXJyYXkoKSA6IGEpIDogW107IFxcfTtcIlxuXHRcdFxuXHRkZWYganMgb1xuXHRcdHJldHVybiBhcmdzWzBdLmMgaWYgYXJnc1swXSBpc2EgQXJyICMgb3IgaWYgd2Uga25vdyBmb3Igc3VyZSB0aGF0IGl0IGlzIGFuIGFycmF5XG5cblx0XHRpZiBpc1N0YW5kYWxvbmVcblx0XHRcdHNjb3BlX18ucm9vdC5oZWxwZXIoc2VsZixoZWxwZXIpXG5cdFx0XHRyZXR1cm4gXCJpdGVyJCh7YXJnc1swXS5jfSlcIlxuXHRcdGVsc2Vcblx0XHRcdHJldHVybiBcIkltYmEuaXRlcmFibGUoe2FyZ3NbMF0uY30pXCJcblx0XHRcbmV4cG9ydCBjbGFzcyBVdGlsLklzRnVuY3Rpb24gPCBVdGlsXG5cblx0ZGVmIGpzIG9cblx0XHRcInthcmdzWzBdLmN9XCJcblxuZXhwb3J0IGNsYXNzIFV0aWwuQXJyYXkgPCBVdGlsXG5cblx0ZGVmIGpzIG9cblx0XHQjIFdoZW4gdGhpcyBpcyB0cmlnZ2VyZWQsIHdlIG5lZWQgdG8gYWRkIGl0IHRvIHRoZSB0b3Agb2YgZmlsZT9cblx0XHRcIm5ldyBBcnJheSh7YXJncy5tYXAofHZ8IHYuYyl9KVwiXG5cblxuXG5cbmNsYXNzIEVudGl0aWVzXG5cblx0ZGVmIGluaXRpYWxpemUgcm9vdFxuXHRcdEByb290ID0gcm9vdFxuXHRcdEBtYXAgPSB7fVxuXHRcdHJldHVybiBzZWxmXG5cblx0ZGVmIGFkZCBwYXRoLCBvYmplY3Rcblx0XHRAbWFwW3BhdGhdID0gb2JqZWN0XG5cdFx0c2VsZlxuXG5cdGRlZiByZWdpc3RlciBlbnRpdHlcblx0XHR2YXIgcGF0aCA9IGVudGl0eS5uYW1lcGF0aFxuXHRcdEBtYXBbcGF0aF0gfHw9IGVudGl0eVxuXHRcdHNlbGZcblxuXHRkZWYgcGxhaW5cblx0XHRKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KEBtYXApKVxuXG5cdGRlZiB0b0pTT05cblx0XHRAbWFwXG5cbiMgU0NPUEVTXG5cbiMgaGFuZGxlcyBsb2NhbCB2YXJpYWJsZXMsIHNlbGYgZXRjLiBTaG91bGQgY3JlYXRlIHJlZmVyZW5jZXMgdG8gb3V0ZXIgc2NvcGVzXG4jIHdoZW4gbmVlZGVkIGV0Yy5cblxuIyBhZGQgY2xhc3MgZm9yIGFubm90YXRpb25zIC8gcmVnaXN0ZXJpbmcgbWV0aG9kcywgZXRjP1xuIyBjbGFzcyBJbnRlcmZhY2VcblxuIyBzaG91bGQgbW92ZSB0aGUgd2hvbGUgY29udGV4dC10aGluZ2llIHJpZ2h0IGludG8gc2NvcGVcbmV4cG9ydCBjbGFzcyBTY29wZVxuXG5cdHByb3AgbGV2ZWxcblx0cHJvcCBjb250ZXh0XG5cdHByb3Agbm9kZVxuXHRwcm9wIHBhcmVudFxuXHRwcm9wIHZhcm1hcFxuXHRwcm9wIHZhcnBvb2xcblx0cHJvcCBwYXJhbXNcblx0cHJvcCBoZWFkXG5cdHByb3AgdmFyc1xuXHRwcm9wIGNvdW50ZXJcblxuXHRkZWYgcFxuXHRcdGlmIFNUQUNLLmxvZ2xldmVsID4gMFxuXHRcdFx0Y29uc29sZS5sb2coKmFyZ3VtZW50cylcblx0XHRzZWxmXG5cblx0ZGVmIHN0YWNrXG5cdFx0U1RBQ0tcblxuXHRkZWYgaW5pdGlhbGl6ZSBub2RlLCBwYXJlbnRcblx0XHRAbnIgPSBTVEFDSy5pbmNyKCdzY29wZXMnKVxuXHRcdEBoZWFkID0gW11cblx0XHRAbm9kZSA9IG5vZGVcblx0XHRAcGFyZW50ID0gcGFyZW50XG5cdFx0QHZhcnMgPSBWYXJpYWJsZURlY2xhcmF0aW9uLm5ldyhbXSlcblx0XHRAbWV0YSA9IHt9XG5cdFx0QGFubm90YXRpb25zID0gW11cblx0XHRAY2xvc3VyZSA9IHNlbGZcblx0XHRAdmlydHVhbCA9IG5vXG5cdFx0QGNvdW50ZXIgPSAwXG5cdFx0QHZhcm1hcCAgPSB7fVxuXHRcdEB2YXJwb29sID0gW11cblxuXHRkZWYgbWV0YSBrZXksIHZhbHVlXG5cdFx0aWYgdmFsdWUgIT0gdW5kZWZpbmVkXG5cdFx0XHRAbWV0YVtrZXldID0gdmFsdWVcblx0XHRcdHJldHVybiBzZWxmXG5cdFx0QG1ldGFba2V5XVxuXG5cdGRlZiBuYW1lcGF0aFxuXHRcdCc/J1xuXG5cdGRlZiB0YWdDb250ZXh0UGF0aFxuXHRcdCMgYnlwYXNzaW5nIGZvciBub3dcblx0XHRAdGFnQ29udGV4dFBhdGggfHw9IFwidGFnJFwiICMgcGFyZW50LnRhZ0NvbnRleHRQYXRoXG5cblx0ZGVmIGNvbnRleHRcblx0XHRAY29udGV4dCB8fD0gU2NvcGVDb250ZXh0Lm5ldyhzZWxmKVxuXG5cdGRlZiB0cmF2ZXJzZVxuXHRcdHNlbGZcblxuXHRkZWYgdmlzaXRcblx0XHRyZXR1cm4gc2VsZiBpZiBAcGFyZW50XG5cdFx0IyBwIFwidmlzaXRlZCBzY29wZSFcIlxuXHRcdEBwYXJlbnQgPSBTVEFDSy5zY29wZSgxKSAjIHRoZSBwYXJlbnQgc2NvcGVcblx0XHRAbGV2ZWwgPSBTVEFDSy5zY29wZXM6bGVuZ3RoIC0gMVxuXG5cdFx0IyBwIFwicGFyZW50IGlzXCIsQHBhcmVudFxuXHRcdFNUQUNLLmFkZFNjb3BlKHNlbGYpXG5cdFx0cm9vdC5zY29wZXMucHVzaChzZWxmKVxuXHRcdHNlbGZcblxuXHRkZWYgd3JhcCBzY29wZVxuXHRcdEBwYXJlbnQgPSBzY29wZS5AcGFyZW50XG5cdFx0c2NvcGUuQHBhcmVudCA9IHNlbGZcblx0XHRzZWxmXG5cblx0IyBjYWxsZWQgZm9yIHNjb3BlcyB0aGF0IGFyZSBub3QgcmVhbCBzY29wZXMgaW4ganNcblx0IyBtdXN0IGVuc3VyZSB0aGF0IHRoZSBsb2NhbCB2YXJpYWJsZXMgaW5zaWRlIG9mIHRoZSBzY29wZXMgZG8gbm90XG5cdCMgY29sbGlkZSB3aXRoIHZhcmlhYmxlcyBpbiBvdXRlciBzY29wZXMgLS0gcmVuYW1lIGlmIG5lZWRlZFxuXHRkZWYgdmlydHVhbGl6ZVxuXHRcdHNlbGZcblxuXHRkZWYgcm9vdFxuXHRcdHZhciBzY29wZSA9IHNlbGZcblx0XHR3aGlsZSBzY29wZVxuXHRcdFx0cmV0dXJuIHNjb3BlIGlmIHNjb3BlIGlzYSBSb290U2NvcGVcblx0XHRcdHNjb3BlID0gc2NvcGUucGFyZW50XG5cdFx0cmV0dXJuIG51bGxcblxuXHRkZWYgcmVnaXN0ZXIgbmFtZSwgZGVjbCA9IG51bGwsIG8gPSB7fVxuXHRcdCMgRklYTUUgcmUtcmVnaXN0ZXJpbmcgYSB2YXJpYWJsZSBzaG91bGQgcmVhbGx5IHJldHVybiB0aGUgZXhpc3Rpbmcgb25lXG5cdFx0IyBBZ2FpbiwgaGVyZSB3ZSBzaG91bGQgbm90IHJlYWxseSBoYXZlIHRvIGRlYWwgd2l0aCBzeXN0ZW0tZ2VuZXJhdGVkIHZhcnNcblx0XHQjIEJ1dCBhZ2FpbiwgaXQgaXMgaW1wb3J0YW50XG5cblx0XHQjIHAgXCJyZWdpc3RlcmluZyB7bmFtZX1cIlxuXHRcdG5hbWUgPSBoZWxwZXJzLnN5bWJvbGl6ZShuYW1lKVxuXG5cdFx0IyBhbHNvIGxvb2sgYXQgb3V0ZXIgc2NvcGVzIGlmIHRoaXMgaXMgbm90IGNsb3NlZD9cblx0XHR2YXIgZXhpc3RpbmcgPSBAdmFybWFwLmhhc093blByb3BlcnR5KG5hbWUpICYmIEB2YXJtYXBbbmFtZV1cblx0XHRyZXR1cm4gZXhpc3RpbmcgaWYgZXhpc3RpbmdcblxuXHRcdHZhciBpdGVtID0gVmFyaWFibGUubmV3KHNlbGYsbmFtZSxkZWNsLG8pXG5cdFx0IyBuZWVkIHRvIGNoZWNrIGZvciBkdXBsaWNhdGVzLCBhbmQgaGFuZGxlIHRoaXMgZ3JhY2VmdWxseSAtXG5cdFx0IyBnb2luZyB0byByZWZhY3RvciBsYXRlclxuXHRcdEB2YXJtYXBbbmFtZV0gPSBpdGVtIHVubGVzcyBvOnN5c3RlbSAjIGRvbnQgZXZlbiBhZGQgdG8gdGhlIHZhcm1hcCBpZiBpdCBpcyBhIHN5c3ZhclxuXHRcdHJldHVybiBpdGVtXG5cblx0ZGVmIGFubm90YXRlIG9ialxuXHRcdEBhbm5vdGF0aW9ucy5wdXNoKG9iailcblx0XHRzZWxmXG5cblx0IyBqdXN0IGxpa2UgcmVnaXN0ZXIsIGJ1dCB3ZSBhdXRvbWF0aWNhbGx5IFxuXHRkZWYgZGVjbGFyZSBuYW1lLCBpbml0ID0gbnVsbCwgbyA9IHt9XG5cdFx0dmFyIHZhcmlhYmxlID0gcmVnaXN0ZXIobmFtZSxudWxsLG8pXG5cdFx0IyBUT0RPIGNyZWF0ZSB0aGUgdmFyaWFibGVkZWNsYXJhdGlvbiBoZXJlIGluc3RlYWQ/XG5cdFx0IyBpZiB0aGlzIGlzIGEgc3lzdmFyIHdlIG5lZWQgaXQgdG8gYmUgcmVuYW1lYWJsZVxuXHRcdHZhciBkZWMgPSBAdmFycy5hZGQodmFyaWFibGUsaW5pdClcblx0XHR2YXJpYWJsZS5kZWNsYXJhdG9yIHx8PSBkZWNcblx0XHRyZXR1cm4gdmFyaWFibGVcblxuXHRcdCMgcCBcImRlY2xhcmUgdmFyaWFibGUge25hbWV9IHtvfVwiXG5cdFx0IyBpZiBuYW1lIGlzYSBWYXJpYWJsZVxuXHRcdCMgcCBcIlNDT1BFIGRlY2xhcmUgdmFyXCIuZ3JlZW5cblx0XHRuYW1lID0gaGVscGVycy5zeW1ib2xpemUobmFtZSlcblx0XHQjIHdlIHdpbGwgc2VlIGhlcmVcblx0XHRAdmFycy5hZGQobmFtZSxpbml0KSAjIC5sYXN0IC0tIFxuXHRcdHZhciBkZWNsID0gQHZhcnMubGFzdCAjIGJ1ZyghKVxuXHRcdHZhciBpdGVtXG5cdFx0IyBpdGVtID0gVmFyaWFibGUubmV3KHNlbGYsbmFtZSxkZWNsKVxuXG5cdFx0IyBpZiBvOnN5c3RlbVxuXHRcdCMgXHRpdGVtID0gU3lzdGVtVmFyaWFibGUubmV3KHNlbGYsbmFtZSxkZWNsLG8pXG5cdFx0IyBcdGRlY2wudmFyaWFibGUgPSBpdGVtXG5cdFx0IyBlbHNlXG5cdFx0aXRlbSA9IFZhcmlhYmxlLm5ldyhzZWxmLG5hbWUsZGVjbCxvKVxuXHRcdGRlY2wudmFyaWFibGUgPSBpdGVtXG5cdFx0aXRlbS5yZXNvbHZlICMgd2h5IG9uIGVhcnRoIHNob3VsZCBpdCByZXNvbHZlIGltbWVkaWF0ZWx5P1xuXHRcdFxuXHRcdCMgZGVjbC52YXJpYWJsZSA9IGl0ZW1cblx0XHQjIGl0ZW0ucmVzb2x2ZSAjIHdoeSBvbiBlYXJ0aCBzaG91bGQgaXQgcmVzb2x2ZSBpbW1lZGlhdGVseT9cblx0XHRyZXR1cm4gaXRlbVxuXG5cdFx0IyBzaG91bGQgYmUgcG9zc2libGUgdG8gZm9yY2UtZGVjbGFyZSBmb3IgdGhpcyBzY29wZSwgbm8/XG5cdFx0IyBpZiB0aGlzIGlzIGEgc3lzdGVtLXZhcmlhYmxlIFxuXG5cdCMgZGVjbGFyZXMgYSB2YXJpYWJsZSAoaGFzIG5vIHJlYWwgZGVjbGFyYXRpb24gYmVmb3JlaGFuZClcblxuXG5cdCMgd2hhdCBhcmUgdGhlIGRpZmZlcmVuY2VzIGhlcmU/IG9talxuXHQjIHdlIG9ubHkgbmVlZCBhIHRlbXBvcmFyeSB0aGluZyB3aXRoIGRlZmF1bHRzIC0tIHRoYXQgaXMgYWxsXG5cdCMgY2hhbmdlIHRoZXNlIHZhbHVlcywgbm8/XG5cdGRlZiB0ZW1wb3JhcnkgcmVmbm9kZSwgbyA9IHt9LCBuYW1lID0gbnVsbFxuXG5cdFx0IyBwIFwicmVnaXN0ZXJpbmcgdGVtcG9yYXJ5IHtyZWZub2RlfSB7bmFtZX1cIlxuXHRcdCMgcmV1c2UgdmFyaWFibGVzIC0tIGhtbVxuXHRcdGlmIG86cG9vbFxuXHRcdFx0Zm9yIHYgaW4gQHZhcnBvb2xcblx0XHRcdFx0aWYgdi5wb29sID09IG86cG9vbCAmJiB2LmRlY2xhcmF0b3IgPT0gbnVsbFxuXHRcdFx0XHRcdHJldHVybiB2LnJldXNlKHJlZm5vZGUpXG5cblx0XHQjIHNob3VsZCBvbmx5ICdyZWdpc3RlcicgYXMgYWhpZGRlbiB2YXJpYWJsZSwgbm8/XG5cdFx0IyBpZiB0aGVyZSBhcmUgcmVhbCBub2RlcyBpbnNpZGUgdGhhdCB0cmllcyB0byByZWZlciB0byB2YXJzXG5cdFx0IyBkZWZpbmVkIGluIG91dGVyIHNjb3Blcywgd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhleSBhcmUgbm90IG5hbWVkIGFmdGVyIHRoaXNcblx0XHR2YXIgaXRlbSA9IFN5c3RlbVZhcmlhYmxlLm5ldyhzZWxmLG5hbWUscmVmbm9kZSxvKVxuXHRcdEB2YXJwb29sLnB1c2goaXRlbSkgIyBXSEFUPyBJdCBzaG91bGQgbm90IGJlIGluIHRoZSBwb29sIHVubGVzcyBleHBsaWNpdGx5IHB1dCB0aGVyZT9cblx0XHRAdmFycy5wdXNoKGl0ZW0pICMgV0FSTiB2YXJpYWJsZXMgc2hvdWxkIG5vdCBnbyBkaXJlY3RseSBpbnRvIGEgZGVjbGFyYXRpb24tbGlzdFxuXHRcdHJldHVybiBpdGVtXG5cdFx0IyByZXR1cm4gcmVnaXN0ZXIobmFtZSB8fCBcIl9fXCIsbnVsbCxzeXN0ZW06IHllcywgdGVtcG9yYXJ5OiB5ZXMpXG5cblx0XG5cblx0ZGVmIGxvb2t1cCBuYW1lXG5cdFx0dmFyIHJldCA9IG51bGxcblx0XHRuYW1lID0gaGVscGVycy5zeW1ib2xpemUobmFtZSlcblx0XHRpZiBAdmFybWFwLmhhc093blByb3BlcnR5KG5hbWUpXG5cdFx0XHRyZXQgPSBAdmFybWFwW25hbWVdIFxuXHRcdGVsc2Vcblx0XHRcdCMgbG9vayB1cCBhbnkgcGFyZW50IHNjb3BlID8/IHNlZW1zIG9rYXlcblx0XHRcdCMgIWlzQ2xvc2VkICYmIFxuXHRcdFx0cmV0ID0gcGFyZW50ICYmIHBhcmVudC5sb29rdXAobmFtZSlcblx0XHRcdCMgb3IgLS0gbm90IGFsbCBzY29wZXMgaGF2ZSBhIHBhcmVudD9cblx0XHRcblx0XHQjIHNob3VsZCB0aGlzIG5vdCBoYXBwZW4gYnkgaXRzZWxmP1xuXHRcdCMgaWYgIXJldCBhbmQgXG5cdFx0I1x0cmV0ID0gXG5cdFx0IyByZXQgfHw9IChnLmxvb2t1cChuYW1lKSBpZiB2YXIgZyA9IHJvb3QpXG5cdFx0IyBnID0gcm9vdFxuXHRcdHJldFxuXG5cdGRlZiBhdXRvZGVjbGFyZSB2YXJpYWJsZVxuXHRcdHZhcnMucHVzaCh2YXJpYWJsZSkgIyBvbmx5IGlmIGl0IGRvZXMgbm90IGV4aXN0IGhlcmUhISFcblxuXHRkZWYgZnJlZSB2YXJpYWJsZVxuXHRcdCMgcCBcImZyZWUgdmFyaWFibGVcIlxuXHRcdHZhcmlhYmxlLmZyZWUgIyA6b3duZXIgPSBudWxsXG5cdFx0IyBAdmFycG9vbC5wdXNoKHZhcmlhYmxlKVxuXHRcdHNlbGZcblx0XG5cdGRlZiBpc0Nsb3NlZFxuXHRcdG5vXG5cblx0ZGVmIGNsb3N1cmVcblx0XHRAY2xvc3VyZVxuXG5cdGRlZiBmaW5hbGl6ZVxuXHRcdHNlbGZcblxuXHRkZWYga2xhc3Ncblx0XHR2YXIgc2NvcGUgPSBzZWxmXG5cdFx0d2hpbGUgc2NvcGVcblx0XHRcdHNjb3BlID0gc2NvcGUucGFyZW50XG5cdFx0XHRyZXR1cm4gc2NvcGUgaWYgc2NvcGUgaXNhIENsYXNzU2NvcGVcblx0XHRyZXR1cm4gbnVsbFxuXG5cdGRlZiBoZWFkXG5cdFx0W0B2YXJzLEBwYXJhbXNdXG5cblx0ZGVmIGMgbyA9IHt9XG5cdFx0bzpleHByZXNzaW9uID0gbm9cblx0XHQjIG5lZWQgdG8gZml4IHRoaXNcblx0XHRub2RlLmJvZHkuaGVhZCA9IGhlYWRcblx0XHR2YXIgYm9keSA9IG5vZGUuYm9keS5jKG8pXG5cblx0XHQjIHZhciBoZWFkID0gW0B2YXJzLEBwYXJhbXNdLmJsb2NrLmMoZXhwcmVzc2lvbjogbm8pXG5cdFx0IyBwIFwiaGVhZCBmcm9tIHNjb3BlIGlzICh7aGVhZH0pXCJcblx0XHQjIHZhciBvdXQgPSBbaGVhZCBvciBudWxsLGJvZHldLmZsYXR0ZW5fXy5jb21wYWN0LmpvaW4oXCJcXG5cIilcblx0XHQjIG91dFxuXHRcdCMgb3V0ID0gJ3snICsgb3V0ICsgXG5cblx0ZGVmIHJlZ2lvblxuXHRcdG5vZGUuYm9keS5yZWdpb25cblxuXHRkZWYgbG9jXG5cdFx0bm9kZS5sb2NcblxuXHRkZWYgZHVtcFxuXHRcdHZhciB2YXJzID0gT2JqZWN0LmtleXMoQHZhcm1hcCkubWFwIGRvIHxrfCBcblx0XHRcdHZhciB2ID0gQHZhcm1hcFtrXVxuXHRcdFx0di5yZWZlcmVuY2VzOmxlbmd0aCA/IGR1bXBfXyh2KSA6IG51bGxcblxuXHRcdHZhciBkZXNjID0gXG5cdFx0XHRucjogQG5yXG5cdFx0XHR0eXBlOiBzZWxmOmNvbnN0cnVjdG9yOm5hbWVcblx0XHRcdGxldmVsOiAobGV2ZWwgb3IgMClcblx0XHRcdHZhcnM6IGNvbXBhY3RfXyh2YXJzKVxuXHRcdFx0bG9jOiBsb2NcblxuXHRcdHJldHVybiBkZXNjXG5cblx0ZGVmIHRvSlNPTlxuXHRcdGR1bXBcblxuXHRkZWYgdG9TdHJpbmdcblx0XHRcIntzZWxmOmNvbnN0cnVjdG9yOm5hbWV9XCJcblx0XG5cbiMgUm9vdFNjb3BlIGlzIHdyb25nPyBSYXRoZXIgVG9wU2NvcGUgb3IgUHJvZ3JhbVNjb3BlXG5leHBvcnQgY2xhc3MgUm9vdFNjb3BlIDwgU2NvcGVcblxuXHRwcm9wIHdhcm5pbmdzXG5cdHByb3Agc2NvcGVzXG5cdHByb3AgZW50aXRpZXNcblxuXHRkZWYgaW5pdGlhbGl6ZVxuXHRcdHN1cGVyXG5cblx0XHRyZWdpc3RlciAnZ2xvYmFsJywgc2VsZiwgdHlwZTogJ2dsb2JhbCdcblx0XHRyZWdpc3RlciAnbW9kdWxlJywgc2VsZiwgdHlwZTogJ2dsb2JhbCdcblx0XHRyZWdpc3RlciAnd2luZG93Jywgc2VsZiwgdHlwZTogJ2dsb2JhbCdcblx0XHRyZWdpc3RlciAnZG9jdW1lbnQnLCBzZWxmLCB0eXBlOiAnZ2xvYmFsJ1xuXHRcdHJlZ2lzdGVyICdleHBvcnRzJywgc2VsZiwgdHlwZTogJ2dsb2JhbCdcblx0XHRyZWdpc3RlciAnY29uc29sZScsIHNlbGYsIHR5cGU6ICdnbG9iYWwnXG5cdFx0cmVnaXN0ZXIgJ3Byb2Nlc3MnLCBzZWxmLCB0eXBlOiAnZ2xvYmFsJ1xuXHRcdHJlZ2lzdGVyICdwYXJzZUludCcsIHNlbGYsIHR5cGU6ICdnbG9iYWwnXG5cdFx0cmVnaXN0ZXIgJ3BhcnNlRmxvYXQnLCBzZWxmLCB0eXBlOiAnZ2xvYmFsJ1xuXHRcdHJlZ2lzdGVyICdzZXRUaW1lb3V0Jywgc2VsZiwgdHlwZTogJ2dsb2JhbCdcblx0XHRyZWdpc3RlciAnc2V0SW50ZXJ2YWwnLCBzZWxmLCB0eXBlOiAnZ2xvYmFsJ1xuXHRcdHJlZ2lzdGVyICdjbGVhclRpbWVvdXQnLCBzZWxmLCB0eXBlOiAnZ2xvYmFsJ1xuXHRcdHJlZ2lzdGVyICdjbGVhckludGVydmFsJywgc2VsZiwgdHlwZTogJ2dsb2JhbCdcblx0XHRyZWdpc3RlciAnX19kaXJuYW1lJywgc2VsZiwgdHlwZTogJ2dsb2JhbCdcblxuXHRcdCMgcHJlcmVnaXN0ZXIgZ2xvYmFsIHNwZWNpYWwgdmFyaWFibGVzIGhlcmVcblx0XHRAd2FybmluZ3MgPSBbXVxuXHRcdEBzY29wZXMgICA9IFtdXG5cdFx0QGhlbHBlcnMgID0gW11cblx0XHRAZW50aXRpZXMgPSBFbnRpdGllcy5uZXcoc2VsZilcblx0XHRAaGVhZCA9IFtAdmFyc11cblxuXHRkZWYgY29udGV4dFxuXHRcdEBjb250ZXh0IHx8PSBSb290U2NvcGVDb250ZXh0Lm5ldyhzZWxmKVxuXG5cdGRlZiB0YWdDb250ZXh0UGF0aFxuXHRcdEB0YWdDb250ZXh0UGF0aCB8fD0gXCJ0YWckXCJcblxuXHRkZWYgbG9va3VwIG5hbWVcblx0XHQjIHAgXCJsb29rdXAgZmlsZXNjb3BlXCJcblx0XHRuYW1lID0gaGVscGVycy5zeW1ib2xpemUobmFtZSlcblx0XHRAdmFybWFwW25hbWVdIGlmIEB2YXJtYXAuaGFzT3duUHJvcGVydHkobmFtZSlcblxuXHRkZWYgdmlzaXRcblx0XHRTVEFDSy5hZGRTY29wZShzZWxmKVxuXHRcdHNlbGZcblxuXHRkZWYgaGVscGVyIHR5cCwgdmFsdWVcblx0XHQjIGxvZyBcImFkZCBoZWxwZXJcIix0eXAsdmFsdWVcblx0XHRpZiBAaGVscGVycy5pbmRleE9mKHZhbHVlKSA9PSAtMVxuXHRcdFx0QGhlbHBlcnMucHVzaCh2YWx1ZSlcblx0XHRcdEBoZWFkLnVuc2hpZnQodmFsdWUpXG5cblx0XHRyZXR1cm4gc2VsZlxuXG5cdGRlZiBoZWFkXG5cdFx0QGhlYWRcblxuXHRkZWYgd2FybiBkYXRhXG5cdFx0IyBoYWNreVxuXHRcdGRhdGE6bm9kZSA9IG51bGxcblx0XHQjIHAgXCJ3YXJuaW5nXCIsSlNPTi5zdHJpbmdpZnkoZGF0YSlcblx0XHRAd2FybmluZ3MucHVzaChkYXRhKVxuXHRcdHNlbGZcblxuXHRkZWYgZHVtcFxuXHRcdHZhciBvYmogPSB7d2FybmluZ3M6IGR1bXBfXyhAd2FybmluZ3MpfVxuXG5cdFx0aWYgT1BUUzphbmFseXNpczpzY29wZXNcblx0XHRcdHZhciBzY29wZXMgPSBAc2NvcGVzLm1hcCh8c3wgcy5kdW1wKVxuXHRcdFx0c2NvcGVzLnVuc2hpZnQoc3VwZXIuZHVtcClcblx0XHRcdG9iajpzY29wZXMgPSBzY29wZXMgXG5cblx0XHRpZiBPUFRTOmFuYWx5c2lzOmVudGl0aWVzXG5cdFx0XHRvYmo6ZW50aXRpZXMgPSBAZW50aXRpZXNcblxuXHRcdHJldHVybiBvYmpcblx0XHRcblxuZXhwb3J0IGNsYXNzIENsYXNzU2NvcGUgPCBTY29wZVxuXG5cdGRlZiBuYW1lcGF0aFxuXHRcdEBub2RlLm5hbWVwYXRoXG5cdFxuXG5cdCMgY2FsbGVkIGZvciBzY29wZXMgdGhhdCBhcmUgbm90IHJlYWwgc2NvcGVzIGluIGpzXG5cdCMgbXVzdCBlbnN1cmUgdGhhdCB0aGUgbG9jYWwgdmFyaWFibGVzIGluc2lkZSBvZiB0aGUgc2NvcGVzIGRvIG5vdFxuXHQjIGNvbGxpZGUgd2l0aCB2YXJpYWJsZXMgaW4gb3V0ZXIgc2NvcGVzIC0tIHJlbmFtZSBpZiBuZWVkZWRcblx0ZGVmIHZpcnR1YWxpemVcblx0XHQjIGNvbnNvbGUubG9nIFwidmlydHVhbGl6aW5nIENsYXNzU2NvcGVcIlxuXHRcdHZhciB1cCA9IHBhcmVudFxuXHRcdGZvciBvd24gayx2IG9mIEB2YXJtYXBcblx0XHRcdHRydWVcblx0XHRcdHYucmVzb2x2ZSh1cCx5ZXMpICMgZm9yY2UgbmV3IHJlc29sdmVcblx0XHRzZWxmXG5cblx0ZGVmIGlzQ2xvc2VkXG5cdFx0eWVzXG5cbmV4cG9ydCBjbGFzcyBUYWdTY29wZSA8IENsYXNzU2NvcGVcblxuZXhwb3J0IGNsYXNzIENsb3N1cmVTY29wZSA8IFNjb3BlXG5cbmV4cG9ydCBjbGFzcyBGdW5jdGlvblNjb3BlIDwgU2NvcGVcblxuZXhwb3J0IGNsYXNzIE1ldGhvZFNjb3BlIDwgU2NvcGVcblx0XG5cblx0ZGVmIGlzQ2xvc2VkXG5cdFx0eWVzXG5cbmV4cG9ydCBjbGFzcyBMYW1iZGFTY29wZSA8IFNjb3BlXG5cblx0ZGVmIGNvbnRleHRcblxuXHRcdCMgd2hlbiBhY2Nlc3NpbmcgdGhlIG91dGVyIGNvbnRleHQgd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhhdCBpdCBpcyBjYWNoZWRcblx0XHQjIHNvIHRoaXMgaXMgd3JvbmcgLSBidXQgdGVtcCBva2F5XG5cdFx0QGNvbnRleHQgfHw9IHBhcmVudC5jb250ZXh0LnJlZmVyZW5jZShzZWxmKVxuXG5leHBvcnQgY2xhc3MgRmxvd1Njb3BlIDwgU2NvcGVcblxuXHQjIHRoZXNlIGhhdmUgbm8gcGFyYW1zIHRoZW1zZWx2ZXMsIHJlZmVyIHRvIG91dGVyIHNjb3BlcyAtLSBoam1tXG5cdGRlZiBwYXJhbXNcblx0XHRAcGFyZW50LnBhcmFtcyBpZiBAcGFyZW50XG5cblx0ZGVmIHJlZ2lzdGVyIG5hbWUsIGRlY2wgPSBudWxsLCBvID0ge31cblx0XHRpZiBvOnR5cGUgIT0gJ2xldCcgYW5kIChjbG9zdXJlICE9IHNlbGYpXG5cdFx0XHRpZiB2YXIgZm91bmQgPSBsb29rdXAobmFtZSlcblx0XHRcdFx0IyBwIFwiYWxyZWFkeSBmb3VuZCB2YXJpYWJsZSB7Zm91bmQudHlwZX1cIlxuXHRcdFx0XHRpZiBmb3VuZC50eXBlID09ICdsZXQnXG5cdFx0XHRcdFx0cCBcIntuYW1lfSBhbHJlYWR5IGV4aXN0cyBhcyBhIGJsb2NrLXZhcmlhYmxlIHtkZWNsfVwiXG5cdFx0XHRcdFx0IyBUT0RPIHNob3VsZCB0aHJvdyBlcnJvciBpbnN0ZWFkXG5cdFx0XHRcdFx0ZGVjbC53YXJuIFwiVmFyaWFibGUgYWxyZWFkeSBleGlzdHMgaW4gYmxvY2tcIiBpZiBkZWNsXG5cdFx0XHRcdFx0IyByb290Lndhcm4gbWVzc2FnZTogXCJIb2x5IHNoaXRcIlxuXHRcdFx0XHQjIGlmIGZvdW5kLlxuXHRcdFx0IyBwIFwiRmxvd1Njb3BlIHJlZ2lzdGVyIHZhciAtLSBkbyBpdCByaWdodCBpbiB0aGUgb3V0ZXIgc2NvcGVcIlxuXHRcdFx0Y2xvc3VyZS5yZWdpc3RlcihuYW1lLGRlY2wsbylcblx0XHRlbHNlXG5cdFx0XHQjIHAgXCJSZWdpc3RlciBsb2NhbCB2YXJpYWJsZSBmb3IgRmxvd1Njb3BlIHtuYW1lfVwiXG5cdFx0XHQjIG86Y2xvc3VyZSA9IHBhcmVudFxuXHRcdFx0IyBwIFwiRmxvd1Njb3BlIHJlZ2lzdGVyXCIsIGFyZ3VtZW50c1xuXHRcdFx0c3VwZXIobmFtZSxkZWNsLG8pXG5cblx0IyBGSVhNRSBzaG91bGQgb3ZlcnJpZGUgdGVtcG9yYXJ5IGFzIHdlbGxcblxuXHRkZWYgYXV0b2RlY2xhcmUgdmFyaWFibGVcblx0XHRwYXJlbnQuYXV0b2RlY2xhcmUodmFyaWFibGUpXG5cblx0ZGVmIGNsb3N1cmVcblx0XHQjIHJhdGhlciBhbGwgdGhlIHdheT9cblx0XHRAcGFyZW50LmNsb3N1cmUgIyB0aGlzIGlzIGltcG9ydGFudD9cblxuXHRkZWYgY29udGV4dFxuXHRcdCMgaWYgd2UgYXJlIHdyYXBwaW5nIGluIGFuIGV4cHJlc3Npb24gLSB3ZSBkbyBuZWVkIHRvIGFkZCBhIHJlZmVyZW5jZVxuXHRcdCMgQHJlZmVyZW5jZWQgPSB5ZXNcblx0XHRwYXJlbnQuY29udGV4dFxuXHRcdCMgdXN1YWxseSAtIGlmIHRoZSBwYXJlbnQgc2NvcGUgaXMgYSBjbG9zZWQgc2NvcGUgd2UgZG9udCByZWFsbHkgbmVlZFxuXHRcdCMgdG8gZm9yY2UgYSByZWZlcmVuY2Vcblx0XHQjIEBjb250ZXh0IHx8PSBwYXJlbnQuY29udGV4dC5yZWZlcmVuY2Uoc2VsZilcblxuZXhwb3J0IGNsYXNzIENhdGNoU2NvcGUgPCBGbG93U2NvcGVcblxuZXhwb3J0IGNsYXNzIFdoaWxlU2NvcGUgPCBGbG93U2NvcGVcblxuXHRkZWYgYXV0b2RlY2xhcmUgdmFyaWFibGVcblx0XHR2YXJzLnB1c2godmFyaWFibGUpXG5cbmV4cG9ydCBjbGFzcyBGb3JTY29wZSA8IEZsb3dTY29wZVxuXHRcblx0ZGVmIGF1dG9kZWNsYXJlIHZhcmlhYmxlXG5cdFx0dmFycy5wdXNoKHZhcmlhYmxlKVxuXHRcdCMgcGFyZW50LmF1dG9kZWNsYXJlKHZhcmlhYmxlKVxuXG5cdCMgZGVmIGNsb3N1cmVcblx0IyBcdHNlbGZcblxuZXhwb3J0IGNsYXNzIElmU2NvcGUgPCBGbG93U2NvcGVcblxuXHRkZWYgdGVtcG9yYXJ5IHJlZm5vZGUsIG8gPSB7fSwgbmFtZSA9IG51bGxcblx0XHRwYXJlbnQudGVtcG9yYXJ5KHJlZm5vZGUsbyxuYW1lKVxuXG5leHBvcnQgY2xhc3MgQmxvY2tTY29wZSA8IEZsb3dTY29wZVxuXG5cdGRlZiB0ZW1wb3JhcnkgcmVmbm9kZSwgbyA9IHt9LCBuYW1lID0gbnVsbFxuXHRcdHBhcmVudC50ZW1wb3JhcnkocmVmbm9kZSxvLG5hbWUpXG5cblx0ZGVmIHJlZ2lvblxuXHRcdG5vZGUucmVnaW9uXG5cbiMgbGl2ZXMgaW4gc2NvcGUgLS0gcmVhbGx5IGEgbm9kZT8/P1xuZXhwb3J0IGNsYXNzIFZhcmlhYmxlIDwgTm9kZVxuXG5cdHByb3Agc2NvcGVcblx0cHJvcCBuYW1lXG5cdHByb3AgYWxpYXNcblx0cHJvcCB0eXBlXG5cdHByb3Agb3B0aW9uc1xuXHRwcm9wIGluaXRpYWxpemVkXG5cdHByb3AgZGVjbGFyZWRcblx0cHJvcCBkZWNsYXJhdG9yXG5cdHByb3AgYXV0b2RlY2xhcmVcblx0cHJvcCByZWZlcmVuY2VzXG5cdHByb3AgZXhwb3J0XG5cblx0ZGVmIHBvb2xcblx0XHRudWxsXG5cblx0ZGVmIGluaXRpYWxpemUgc2NvcGUsIG5hbWUsIGRlY2wsIG9cblx0XHRAcmVmID0gU1RBQ0suQGNvdW50ZXIrK1xuXHRcdEBjID0gbnVsbFxuXHRcdEBzY29wZSA9IHNjb3BlXG5cdFx0QG5hbWUgID0gbmFtZVxuXHRcdEBhbGlhcyA9IG51bGxcblx0XHRAaW5pdGlhbGl6ZWQgICAgPSB5ZXNcblx0XHRAZGVjbGFyYXRvciAgXHQ9IGRlY2xcblx0XHRAYXV0b2RlY2xhcmUgXHQ9IG5vXG5cdFx0QGRlY2xhcmVkXHRcdD0gbyBhbmQgbzpkZWNsYXJlZCB8fCBub1xuXHRcdEByZXNvbHZlZFx0XHQ9IG5vXG5cdFx0QG9wdGlvbnMgXHRcdD0gbyB8fCB7fVxuXHRcdEB0eXBlXHRcdFx0PSBvIGFuZCBvOnR5cGUgfHwgJ3ZhcicgIyB3aGF0IGFib3V0IGxldCBoZXJlPVxuXHRcdEBleHBvcnRcdFx0XHQ9IG5vXG5cdFx0QHJlZmVyZW5jZXMgXHQ9IFtdICMgb25seSBuZWVkZWQgd2hlbiBwcm9maWxpbmdcblx0XHRAYXNzaWdubWVudHMgXHQ9IFtdXG5cdFx0c2VsZlxuXG5cdGRlZiBjbG9zdXJlXG5cdFx0QHNjb3BlLmNsb3N1cmVcblxuXHRkZWYgYXNzaWdubWVudHNcblx0XHRAYXNzaWdubWVudHNcblxuXHQjIEhlcmUgd2UgY2FuIGNvbGxlY3QgbG90cyBvZiB0eXBlLWluZm8gYWJvdXQgdmFyaWFibGVzXG5cdCMgYW5kIHNob3cgd2FybmluZ3MgLyBnaXZlIGFkdmljZSBpZiB2YXJpYWJsZXMgYXJlIGFtYmlndW91cyBldGNcblx0ZGVmIGFzc2lnbmVkIHZhbCwgc291cmNlXG5cdFx0QGFzc2lnbm1lbnRzLnB1c2godmFsKVxuXHRcdCMgcCBcIlZhcmlhYmxlIHdhcyBhc3NpZ25lZCB7dmFsfVwiXG5cdFx0aWYgdmFsIGlzYSBBcnJcblx0XHRcdCMganVzdCBmb3IgdGVzdGluZyByZWFsbHlcblx0XHRcdEBpc0FycmF5ID0geWVzXG5cdFx0ZWxzZVxuXHRcdFx0QGlzQXJyYXkgPSBub1xuXHRcdHNlbGZcblxuXHRkZWYgcmVzb2x2ZSBzY29wZSA9IHNjb3BlLCBmb3JjZSA9IG5vXG5cdFx0cmV0dXJuIHNlbGYgaWYgQHJlc29sdmVkIGFuZCAhZm9yY2VcblxuXHRcdEByZXNvbHZlZCA9IHllc1xuXHRcdHZhciBjbG9zdXJlID0gQHNjb3BlLmNsb3N1cmVcblx0XHR2YXIgaXRlbSA9IHNjb3BlLmxvb2t1cChAbmFtZSlcblxuXHRcdCMgaWYgdGhpcyBpcyBhIGxldC1kZWZpbml0aW9uIGluc2lkZSBhIHZpcnR1YWwgc2NvcGUgd2UgZG8gbmVlZFxuXHRcdCMgXG5cdFx0aWYgQHNjb3BlICE9IGNsb3N1cmUgYW5kIEB0eXBlID09ICdsZXQnICMgb3IgaWYgaXQgaXMgYSBzeXN0ZW0tdmFyaWFibGVcblx0XHRcdCMgcCBcInNjb3BlIGlzIG5vdCB0aGUgY2xvc3VyZSAtLSBuZWVkIHRvIHJlc29sdmUge0BuYW1lfVwiXG5cdFx0XHRpdGVtID0gY2xvc3VyZS5sb29rdXAoQG5hbWUpXG5cblx0XHRcdCMgd2Ugbm93IG5lZWQgdG8gZW5zdXJlIHRoYXQgdGhpcyB2YXJpYWJsZSBpcyB1bmlxdWUgaW5zaWRlXG5cdFx0XHQjIHRoZSB3aG9sZSBjbG9zdXJlLlxuXHRcdFx0c2NvcGUgPSBjbG9zdXJlXG5cblx0XHQjIHAgXCJzY29wZSBpcyBub3QgdGhlIGNsb3N1cmUgLS0gbmVlZCB0byByZXNvbHZlIHtAbmFtZX0ge0B0eXBlfVwiXG5cblx0XHRpZiBpdGVtID09IHNlbGZcblx0XHRcdHNjb3BlLnZhcm1hcFtAbmFtZV0gPSBzZWxmXG5cdFx0XHRyZXR1cm4gc2VsZlxuXG5cdFx0IyBwIFwibmVlZCB0byByZXNvbHZlIVwiLmN5YW5cblx0XHRlbGlmIGl0ZW1cblx0XHRcdCMgcCBcInZhcmlhYmxlIGFscmVhZHkgZXhpc3RzIHtAbmFtZX1cIlxuXG5cdFx0XHQjIHBvc3NpYmx5IHJlZGVmaW5lIHRoaXMgaW5zaWRlLCB1c2UgaXQgb25seSBpbiB0aGlzIHNjb3BlXG5cdFx0XHQjIGlmIHRoZSBpdGVtIGlzIGRlZmluZWQgaW4gYW4gb3V0ZXIgc2NvcGUgLSB3ZSByZXNlcnZlIHRoZVxuXHRcdFx0aWYgaXRlbS5zY29wZSAhPSBzY29wZSAmJiAob3B0aW9uczpsZXQgb3IgQHR5cGUgPT0gJ2xldCcpXG5cdFx0XHRcdCMgcCBcIm92ZXJyaWRlIHZhcmlhYmxlIGluc2lkZSB0aGlzIHNjb3BlIHtAbmFtZX1cIlxuXHRcdFx0XHRzY29wZS52YXJtYXBbQG5hbWVdID0gc2VsZlxuXG5cdFx0XHQjIGRpZmZlcmVudCBydWxlcyBmb3IgZGlmZmVyZW50IHZhcmlhYmxlcz9cblx0XHRcdGlmIEBvcHRpb25zOnByb3h5XG5cdFx0XHRcdCMgcCBcImlzIHByb3h5IC0tIG5vIG5lZWQgdG8gY2hhbmdlIG5hbWUhISEge25hbWV9XCIuY3lhblxuXHRcdFx0XHR5ZXNcblx0XHRcdGVsc2Vcblx0XHRcdFx0dmFyIGkgPSAwXG5cdFx0XHRcdHZhciBvcmlnID0gQG5hbWVcblx0XHRcdFx0IyBpdCBpcyB0aGUgY2xvc3VyZSB0aGF0IHdlIHNob3VsZCB1c2Vcblx0XHRcdFx0d2hpbGUgc2NvcGUubG9va3VwKEBuYW1lKVxuXHRcdFx0XHRcdEBuYW1lID0gXCJ7b3JpZ317aSArPSAxfVwiXG5cblx0XHQjIGluZWZmaWNpZW50IGRvdWJsZSBzZXR0aW5nXG5cdFx0c2NvcGUudmFybWFwW0BuYW1lXSA9IHNlbGZcblx0XHRjbG9zdXJlLnZhcm1hcFtAbmFtZV0gPSBzZWxmXG5cdFx0cmV0dXJuIHNlbGZcblx0XHQjIHAgXCJyZXNvbHZlIHZhcmlhYmxlXCIuY3lhblxuXG5cdGRlZiByZWZlcmVuY2Vcblx0XHRzZWxmXG5cblx0ZGVmIG5vZGVcblx0XHRzZWxmXG5cblx0ZGVmIHRyYXZlcnNlXG5cdFx0IyBOT0RFUy5wdXNoKHNlbGYpXG5cdFx0c2VsZlxuXG5cdGRlZiBmcmVlIHJlZlxuXHRcdCMgcCBcImZyZWUgdmFyaWFibGUhXCJcblx0XHRAZGVjbGFyYXRvciA9IG51bGxcblx0XHRzZWxmXG5cblx0ZGVmIHJldXNlIHJlZlxuXHRcdEBkZWNsYXJhdG9yID0gcmVmXG5cdFx0c2VsZlxuXG5cdGRlZiBwcm94eSBwYXIsIGluZGV4XG5cdFx0QHByb3h5ID0gW3BhcixpbmRleF1cblx0XHRzZWxmXG5cblx0ZGVmIHJlZmNvdW50XG5cdFx0QHJlZmVyZW5jZXM6bGVuZ3RoXG5cblx0ZGVmIGNcblx0XHRyZXR1cm4gQGMgaWYgQGNcblx0XHQjIG9wdGlvbnMgLSBwcm94eT8/XG5cdFx0aWYgQHByb3h5XG5cdFx0XHQjIHAgXCJ2YXIgaXMgcHJveGllZCFcIixAcHJveHlcblx0XHRcdEBjID0gQHByb3h5WzBdLmMgKyAnWycgKyBAcHJveHlbMV0uYyArICddJ1xuXHRcdGVsc2Vcblx0XHRcdHJlc29sdmUgdW5sZXNzIEByZXNvbHZlZFxuXHRcdFx0dmFyIHYgPSAoYWxpYXMgb3IgbmFtZSlcblx0XHRcdEBjID0gdHlwZW9mIHYgPT0gJ3N0cmluZycgPyB2IDogdi5jXG5cdFx0XHQjIGFsbG93IGNlcnRhaW4gcmVzZXJ2ZWQgd29yZHNcblx0XHRcdCMgc2hvdWxkIHdhcm4gb24gb3RoZXJzIHRob3VnaCAoISEhKVxuXHRcdFx0IyBpZiBAYyA9PSAnbmV3J1xuXHRcdFx0IyBcdEBjID0gJ19uZXcnXG5cdFx0XHQjIFx0IyBzaG91bGQgaGFwcGVuIGF0IGVhcmxpZXIgc3RhZ2UgdG9cblx0XHRcdCMgXHQjIGdldCBhcm91bmQgbmFtaW5nIGNvbnZlbnRpb25zXG5cdFx0XHRAYyA9IFwie2N9JFwiIGlmIFJFU0VSVkVEX1JFR0VYLnRlc3QoQGMpICMgQGMubWF0Y2goL14oZGVmYXVsdCkkLylcblx0XHRyZXR1cm4gQGNcblxuXHQjIHZhcmlhYmxlcyBzaG91bGQgcHJvYmFibHkgaW5oZXJpdCBmcm9tIG5vZGUoISlcblx0ZGVmIGNvbnN1bWUgbm9kZVxuXHRcdCMgcCBcInZhcmlhYmxlIGFzc2lnbmlmeSEhIVwiXG5cdFx0cmV0dXJuIHNlbGZcblxuXHQjIHRoaXMgc2hvdWxkIG9ubHkgZ2VuZXJhdGUgdGhlIGFjY2Vzc29ycyAtIG5vdCBkYWVsIHdpdGggcmVmZXJlbmNlc1xuXHRkZWYgYWNjZXNzb3IgcmVmXG5cdFx0dmFyIG5vZGUgPSBMb2NhbFZhckFjY2Vzcy5uZXcoXCIuXCIsbnVsbCxzZWxmKSAjIHRoaXMgaXMganVzdCB3cm9uZyAuLiBzaG91bGQgbm90IGJlIGEgcmVndWxhciBhY2Nlc3NvclxuXHRcdCMgQHJlZmVyZW5jZXMucHVzaChbcmVmLGVsXSkgaWYgcmVmICMgd2VpcmQgdGVtcCBmb3JtYXRcblx0XHRyZXR1cm4gbm9kZVxuXG5cdGRlZiBhc3NpZ25tZW50IHZhbFxuXHRcdEFzc2lnbi5uZXcoJz0nLHNlbGYsdmFsKVxuXG5cdGRlZiBhZGRSZWZlcmVuY2UgcmVmXG5cdFx0aWYgcmVmIGlzYSBJZGVudGlmaWVyXG5cdFx0XHRyZWYucmVmZXJlbmNlcyhzZWxmKVxuXG5cdFx0aWYgcmVmOnJlZ2lvbiBhbmQgcmVmLnJlZ2lvblxuXHRcdFx0QHJlZmVyZW5jZXMucHVzaChyZWYpXG5cblx0XHQjIHAgXCJyZWZlcmVuY2UgaXMge3JlZjpyZWdpb24gYW5kIHJlZi5yZWdpb259XCJcblx0XHRzZWxmXG5cblx0ZGVmIGF1dG9kZWNsYXJlXG5cdFx0cmV0dXJuIHNlbGYgaWYgQGRlY2xhcmVkXG5cdFx0IyBwIFwidmFyaWFibGUgc2hvdWxkIGF1dG9kZWNsYXJlKCEpIHtuYW1lfVwiXG5cdFx0QGF1dG9kZWNsYXJlID0geWVzXG5cdFx0c2NvcGUuYXV0b2RlY2xhcmUoc2VsZilcblx0XHRAZGVjbGFyZWQgPSB5ZXNcblx0XHRzZWxmXG5cblx0ZGVmIHByZWRlY2xhcmVkXG5cdFx0QGRlY2xhcmVkID0geWVzXG5cdFx0c2VsZlxuXHRcdFxuXG5cdGRlZiB0b1N0cmluZ1xuXHRcdFN0cmluZyhuYW1lKVxuXG5cdGRlZiBkdW1wIHR5cFxuXHRcdHZhciBuYW1lID0gbmFtZVxuXHRcdHJldHVybiBudWxsIGlmIG5hbWVbMF0ubWF0Y2goL1tBLVpdLylcblx0XHQjIGNvbnNvbGUubG9nIFwiZHVtcCB2YXJpYWJsZSBvZiB0eXBlIHt0eXBlfSAtIHtuYW1lfVwiXG5cdFx0cmV0dXJuIHtcblx0XHRcdHR5cGU6IHR5cGVcblx0XHRcdG5hbWU6IG5hbWVcblx0XHRcdHJlZnM6IGR1bXBfXyhAcmVmZXJlbmNlcywgdHlwKVxuXHRcdH1cblxuXG5leHBvcnQgY2xhc3MgU3lzdGVtVmFyaWFibGUgPCBWYXJpYWJsZVxuXHRcblx0ZGVmIHBvb2xcblx0XHRAb3B0aW9uczpwb29sXG5cdFx0XG5cdCMgd2VpcmQgbmFtZSBmb3IgdGhpc1xuXHRkZWYgcHJlZGVjbGFyZWRcblx0XHQjIHAgXCJyZW1vdmUgdmFyIGZyb20gc2NvcGUoISlcIlxuXHRcdHNjb3BlLnZhcnMucmVtb3ZlKHNlbGYpXG5cdFx0c2VsZlxuXHRcblx0ZGVmIHJlc29sdmVcblx0XHRyZXR1cm4gc2VsZiBpZiBAcmVzb2x2ZWQgfHwgQG5hbWVcblx0XHQjIHAgXCJSRVNPTFZFIFNZU1RFTSBWQVJJQUJMRVwiLnJlZFxuXHRcdEByZXNvbHZlZCA9IHllc1xuXHRcdCMgdW5sZXNzIEBuYW1lXG5cdFx0IyBhZGRzIGEgdmVyeSByYW5kb20gaW5pdGlhbCBuYW1lXG5cdFx0IyB0aGUgYXV0by1tYWdpY2FsIGdvZXMgbGFzdCwgb3IgYXQgbGVhc3QsIHBvc3NpYmx5IHJldXNlIG90aGVyIG5hbWVzXG5cdFx0IyBcIiR7TWF0aC5mbG9vcihNYXRoLnJhbmRvbSAqIDEwMDApfVwiXG5cblx0XHR2YXIgdHlwID0gQG9wdGlvbnM6cG9vbFxuXHRcdHZhciBuYW1lcyA9IFtdLmNvbmNhdChAb3B0aW9uczpuYW1lcylcblx0XHR2YXIgYWx0ID0gbnVsbFxuXHRcdHZhciBub2RlID0gbnVsbFxuXG5cdFx0dmFyIHNjb3BlID0gc2VsZi5zY29wZVxuXG5cdFx0aWYgdHlwID09ICd0YWcnXG5cdFx0XHR2YXIgaSA9IDBcblx0XHRcdHdoaWxlICFAbmFtZVxuXHRcdFx0XHR2YXIgYWx0ID0gXCJ0e2krK31cIlxuXHRcdFx0XHRAbmFtZSA9IGFsdCB1bmxlc3Mgc2NvcGUubG9va3VwKGFsdClcblxuXHRcdGVsaWYgdHlwID09ICdpdGVyJ1xuXHRcdFx0bmFtZXMgPSBbJ2FyeV9fJywnYXJ5XycsJ2NvbGwnLCdhcnJheScsJ2l0ZW1zJywnYXJ5J11cblxuXHRcdGVsaWYgdHlwID09ICd2YWwnXG5cdFx0XHRuYW1lcyA9IFsndl8nXVxuXG5cdFx0ZWxpZiB0eXAgPT0gJ2FyZ3VtZW50cydcblx0XHRcdG5hbWVzID0gWyckXycsJyQwJ11cblxuXHRcdGVsaWYgdHlwID09ICdrZXlwYXJzJ1xuXHRcdFx0bmFtZXMgPSBbJ29wdHMnLCdvcHRpb25zJywncGFycyddXG5cblx0XHRlbGlmIHR5cCA9PSAnY291bnRlcidcblx0XHRcdG5hbWVzID0gWydpX18nLCdpXycsJ2snLCdqJywnaSddXG5cblx0XHRlbGlmIHR5cCA9PSAnbGVuJ1xuXHRcdFx0bmFtZXMgPSBbJ2xlbl9fJywnbGVuXycsJ2xlbiddXG5cblx0XHRlbGlmIHR5cCA9PSAnbGlzdCdcblx0XHRcdG5hbWVzID0gWyd0bXBsaXN0XycsJ3RtcGxpc3QnLCd0bXAnXVxuXHRcdCMgb3IgaWYgdHlwZSBwbGFjZWhvbGRlciAvIGNhY2hlciAoYWRkIDApXG5cblx0XHR3aGlsZSAhQG5hbWUgJiYgYWx0ID0gbmFtZXMucG9wXG5cdFx0XHRAbmFtZSA9IGFsdCB1bmxlc3Mgc2NvcGUubG9va3VwKGFsdClcblxuXHRcdGlmICFAbmFtZSBhbmQgQGRlY2xhcmF0b3Jcblx0XHRcdGlmIG5vZGUgPSBkZWNsYXJhdG9yLm5vZGVcblx0XHRcdFx0bmFtZXMucHVzaChhbGlhcyArIFwiX1wiKSBpZiB2YXIgYWxpYXMgPSBub2RlLmFsaWFzXG5cblx0XHR3aGlsZSAhQG5hbWUgJiYgYWx0ID0gbmFtZXMucG9wXG5cdFx0XHRAbmFtZSA9IGFsdCB1bmxlc3Mgc2NvcGUubG9va3VwKGFsdClcblxuXHRcdCMgcCBcInN1Z2dlc3RlZCBuYW1lcyB7bmFtZXMuam9pbihcIiAsIFwiKX0ge25vZGV9XCIuY3lhblxuXHRcdCMgIE1hdGguZmxvb3IoTWF0aC5yYW5kb20gKiAxMDAwKVxuXHRcdEBuYW1lIHx8PSBcIiR7c2NvcGUuY291bnRlciArPSAxfVwiXG5cdFx0IyBwIFwibmFtZSBmb3IgdmFyaWFibGUgaXMge0BuYW1lfVwiXG5cdFx0c2NvcGUudmFybWFwW0BuYW1lXSA9IHNlbGZcblx0XHRzZWxmXG5cblx0ZGVmIG5hbWVcblx0XHRyZXNvbHZlXG5cdFx0QG5hbWVcblxuXG5leHBvcnQgY2xhc3MgU2NvcGVDb250ZXh0IDwgTm9kZVxuXG5cdHByb3Agc2NvcGVcblx0cHJvcCB2YWx1ZVxuXG5cdGRlZiBpbml0aWFsaXplIHNjb3BlLCB2YWx1ZVxuXHRcdEBzY29wZSA9IHNjb3BlXG5cdFx0QHZhbHVlID0gdmFsdWVcblx0XHRAcmVmZXJlbmNlID0gbnVsbFxuXHRcdHNlbGZcblxuXHRkZWYgbmFtZXBhdGhcblx0XHRAc2NvcGUubmFtZXBhdGhcblxuXHQjIGluc3RlYWQgb2YgYWxsIHRoZXNlIHJlZmVyZW5jZXMgd2Ugc2hvdWxkIHByb2JhYmx5XG5cdCMganVzdCByZWdpc3RlciB3aGVuIGl0IGlzIGFjY2Vzc2VkIC8gbG9va2VkIHVwIGZyb21cblx0IyBhIGRlZXBlciBmdW5jdGlvbi1zY29wZSwgYW5kIHdoZW4gaXQgaXMsIHdlIHNob3VsZFxuXHQjIHJlZ2lzdGVyIHRoZSB2YXJpYWJsZSBpbiBzY29wZSwgYW5kIHRoZW4gc3RhcnQgdG9cblx0IyB1c2UgdGhhdCBmb3IgZnVydGhlciByZWZlcmVuY2VzLiBNaWdodCBjbGVhbiB0aGluZ3Ncblx0IyB1cCBmb3IgdGhlIGNhc2VzIHdoZXJlIHdlIGhhdmUgeWV0IHRvIGRlY2lkZSB0aGVcblx0IyBuYW1lIG9mIHRoZSB2YXJpYWJsZSBldGM/XG5cblx0ZGVmIHJlZmVyZW5jZVxuXHRcdCMgcCBcInAgcmVmZXJlbmNlIHtTVEFDSy5zY29waW5nfVwiXG5cdFx0IyBzaG91bGQgYmUgYSBzcGVjaWFsIGNvbnRleHQtdmFyaWFibGUhISFcblx0XHRAcmVmZXJlbmNlIHx8PSBzY29wZS5kZWNsYXJlKFwic2VsZlwiLFRoaXMubmV3KVxuXG5cdGRlZiBjXG5cdFx0dmFyIHZhbCA9IEB2YWx1ZSB8fCBAcmVmZXJlbmNlXG5cdFx0KHZhbCA/IHZhbC5jIDogXCJ0aGlzXCIpXG5cblx0ZGVmIGNhY2hlXG5cdFx0c2VsZlxuXG5leHBvcnQgY2xhc3MgUm9vdFNjb3BlQ29udGV4dCA8IFNjb3BlQ29udGV4dFxuXG5cdCMgZGVmIHJlZmVyZW5jZSBzY29wZVxuXHQjIFx0c2VsZlxuXG5cdGRlZiBjIG9cblx0XHQjIHJldHVybiBcIlwiIGlmIG8gYW5kIG86ZXhwbGljaXRcblx0XHR2YXIgdmFsID0gQHZhbHVlIHx8IEByZWZlcmVuY2Vcblx0XHRyZXR1cm4gKHZhbCBhbmQgdmFsICE9IHRoaXMpID8gdmFsLmMgOiBcInRoaXNcIlxuXHRcdCMgc2hvdWxkIGJlIHRoZSBvdGhlciB3YXkgYXJvdW5kLCBubz9cblx0XHQjIG8gYW5kIG86ZXhwbGljaXQgPyBzdXBlciA6IFwiXCJcblx0XHRcbmV4cG9ydCBjbGFzcyBTdXBlciA8IE5vZGVcblxuXHRkZWYgY1xuXHRcdCMgbmVlZCB0byBmaW5kIHRoZSBzdHVmZiBoZXJlXG5cdFx0IyB0aGlzIGlzIHJlYWxseSBub3QgdGhhdCBnb29kOFxuXHRcdHZhciBtID0gU1RBQ0subWV0aG9kXG5cdFx0dmFyIG91dCA9IG51bGxcblx0XHR2YXIgdXAgPSBTVEFDSy5jdXJyZW50XG5cdFx0dmFyIGRlZXAgPSB1cCBpc2EgQWNjZXNzXG5cblx0XHQjIFRPRE8gb3B0aW1pemF0aW9uIGZvciBsYXRlciAtIHByb2JsZW1hdGljIGlmIHRoZXJlIGlzIGEgZGlmZmVyZW50IHJlZmVyZW5jZSBpbiB0aGUgZW5kXG5cdFx0aWYgZmFsc2UgJiYgbSAmJiBtLnR5cGUgPT0gOmNvbnN0cnVjdG9yXG5cdFx0XHRvdXQgPSBcInttLnRhcmdldC5jfS5zdXBlcmNsYXNzXCJcblx0XHRcdG91dCArPSBcIi5hcHBseSh7bS5zY29wZS5jb250ZXh0LmN9LGFyZ3VtZW50cylcIiB1bmxlc3MgZGVlcFxuXHRcdGVsc2Vcblx0XHRcdG91dCA9IFwie20udGFyZ2V0LmN9Ll9fc3VwZXJfX1wiXG5cdFx0XHR1bmxlc3MgdXAgaXNhIEFjY2Vzc1xuXHRcdFx0XHRvdXQgKz0gXCIue2NfXyhtLnN1cGVybmFtZSl9XCIgXG5cdFx0XHRcdHVubGVzcyB1cCBpc2EgQ2FsbCAjIGF1dG9jYWxsP1xuXHRcdFx0XHRcdG91dCArPSBcIi5hcHBseSh7bS5zY29wZS5jb250ZXh0LmN9LGFyZ3VtZW50cylcIiBcblx0XHRvdXRcblxuIyBjb25zdGFudHNcblxuZXhwb3J0IHZhciBCUiA9IE5ld2xpbmUubmV3KCdcXG4nKVxuZXhwb3J0IHZhciBCUjIgPSBOZXdsaW5lLm5ldygnXFxuXFxuJylcbmV4cG9ydCB2YXIgU0VMRiA9IFNlbGYubmV3XG5leHBvcnQgdmFyIFNVUEVSID0gU3VwZXIubmV3XG5cbmV4cG9ydCB2YXIgVFJVRSA9IFRydWUubmV3KCd0cnVlJylcbmV4cG9ydCB2YXIgRkFMU0UgPSBGYWxzZS5uZXcoJ2ZhbHNlJylcbmV4cG9ydCB2YXIgVU5ERUZJTkVEID0gVW5kZWZpbmVkLm5ld1xuZXhwb3J0IHZhciBOSUwgPSBOaWwubmV3XG5cbmV4cG9ydCB2YXIgQVJHVU1FTlRTID0gQXJnc1JlZmVyZW5jZS5uZXcoJ2FyZ3VtZW50cycpXG5leHBvcnQgdmFyIEVNUFRZID0gJydcbmV4cG9ydCB2YXIgTlVMTCA9ICdudWxsJ1xuXG5leHBvcnQgdmFyIFJFU0VSVkVEID0gWydkZWZhdWx0JywnbmF0aXZlJywnZW51bScsJ3dpdGgnXVxuZXhwb3J0IHZhciBSRVNFUlZFRF9SRUdFWCA9IC9eKGRlZmF1bHR8bmF0aXZlfGVudW18d2l0aHxuZXd8Y2hhcikkL1xuXG5leHBvcnQgdmFyIFVOSU9OID0gQ29uc3QubmV3KCd1bmlvbiQnKVxuZXhwb3J0IHZhciBJTlRFUlNFQ1QgPSBDb25zdC5uZXcoJ2ludGVyc2VjdCQnKVxuZXhwb3J0IHZhciBDTEFTU0RFRiA9IENvbnN0Lm5ldygnaW1iYSRjbGFzcycpXG5leHBvcnQgdmFyIFRBR0RFRiA9IENvbnN0Lm5ldygnSW1iYS5UQUdTLmRlZmluZScpXG5leHBvcnQgdmFyIE5FV1RBRyA9IElkZW50aWZpZXIubmV3KFwidGFnJFwiKVxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBzcmMvY29tcGlsZXIvbm9kZXMuaW1iYVxuICoqLyIsIlxuaW1wb3J0ICdwYXRoJyBhcyBwYXRoXG5pbXBvcnQgJy4vaGVscGVycycgYXMgdXRpbFxuXG5leHBvcnQgY2xhc3MgU291cmNlTWFwXG5cblx0ZGVmIHNvdXJjZVxuXHRcdEBzb3VyY2VcblxuXHRkZWYgb3B0aW9uc1xuXHRcdEBzb3VyY2VcblxuXHRkZWYgaW5pdGlhbGl6ZSBzb3VyY2Vcblx0XHRAc291cmNlID0gc291cmNlXG5cdFx0QG1hcHMgPSBbXVxuXHRcdEBtYXAgPSBcIlwiXG5cdFx0QGpzID0gXCJcIlxuXG5cdGRlZiBmaWxlbmFtZVxuXHRcdG9wdGlvbnM6b3B0aW9uczpmaWxlbmFtZVxuXG5cdGRlZiBzb3VyY2VDb2RlXG5cdFx0b3B0aW9uczpvcHRpb25zLkBzb3VyY2VcblxuXHRkZWYgdGFyZ2V0UGF0aFxuXHRcdG9wdGlvbnM6b3B0aW9uczp0YXJnZXRQYXRoXG5cblx0ZGVmIHNvdXJjZVBhdGhcblx0XHRvcHRpb25zOm9wdGlvbnM6c291cmNlUGF0aFxuXG5cdGRlZiBzb3VyY2VOYW1lXG5cdFx0cGF0aC5iYXNlbmFtZShzb3VyY2VQYXRoKVxuXG5cdGRlZiB0YXJnZXROYW1lXG5cdFx0cGF0aC5iYXNlbmFtZSh0YXJnZXRQYXRoKVxuXHRcdFxuXG5cdGRlZiBzb3VyY2VGaWxlc1xuXHRcdFtzb3VyY2VOYW1lXVxuXG5cdGRlZiBwYXJzZVxuXHRcdHZhciBtYXRjaGVyID0gL1xcJVxcJChcXGQqKVxcJFxcJS9cblx0XHR2YXIgcmVwbGFjZXIgPSAvXiguKj8pXFwlXFwkKFxcZCopXFwkXFwlL1xuXHRcdHZhciBsaW5lcyA9IG9wdGlvbnM6anMuc3BsaXQoL1xcbi9nKSAjIHdoYXQgYWJvdXQganM/XG5cdFx0IyByZXR1cm4gc2VsZlxuXHRcdHZhciBsb2NtYXAgPSB1dGlsLmxvY2F0aW9uVG9MaW5lQ29sTWFwKHNvdXJjZUNvZGUpXG5cdFx0QG1hcHMgPSBbXVxuXG5cdFx0IyBjb25zb2xlLmxvZyBvcHRpb25zOmpzXG5cdFx0XG5cdFx0dmFyIG1hdGNoXG5cdFx0IyBzcGxpdCB0aGUgY29kZSBpbiBsaW5lcy4gZ28gdGhyb3VnaCBlYWNoIGxpbmUgXG5cdFx0IyBnbyB0aHJvdWdoIHRoZSBjb2RlIGxvb2tpbmcgZm9yIExPQyBtYXJrZXJzXG5cdFx0IyByZW1vdmUgbWFya2VycyBhbG9uZyB0aGUgd2F5IGFuZCBrZWVwIHRyYWNrIG9mXG5cdFx0IyBjb25zb2xlLmxvZyBzb3VyY2U6anNcblxuXHRcdGZvciBsaW5lLGkgaW4gbGluZXNcblx0XHRcdCMgY291bGQgc3BsaXQgb24gdGhlc2U/XG5cdFx0XHR2YXIgY29sID0gMFxuXHRcdFx0dmFyIGNhcmV0ID0gMFxuXG5cdFx0XHRAbWFwc1tpXSA9IFtdXG5cdFx0XHR3aGlsZSBsaW5lLm1hdGNoKG1hdGNoZXIpXG5cdFx0XHRcdGxpbmUgPSBsaW5lLnJlcGxhY2UocmVwbGFjZXIpIGRvIHxtLHByZSxsb2N8XG5cdFx0XHRcdFx0dmFyIGxjID0gbG9jbWFwW3BhcnNlSW50KGxvYyldXG5cdFx0XHRcdFx0Y2FyZXQgPSBwcmU6bGVuZ3RoXG5cdFx0XHRcdFx0dmFyIG1hcHBpbmcgPSBbIFtsY1swXSxsY1sxXV0sIFtpLGNhcmV0XSBdICMgc291cmNlIGFuZCBvdXRwdXRcblx0XHRcdFx0XHRAbWFwc1tpXS5wdXNoKG1hcHBpbmcpXG5cdFx0XHRcdFx0cmV0dXJuIHByZVxuXHRcdFx0bGluZXNbaV0gPSBsaW5lXG5cblx0XHRcblx0XHRzb3VyY2U6anMgPSBsaW5lcy5qb2luKCdcXG4nKVxuXHRcdHNlbGZcblxuXHRkZWYgZ2VuZXJhdGVcblx0XHRwYXJzZVxuXG5cdFx0dmFyIGxhc3RDb2x1bW4gICAgICAgID0gMFxuXHRcdHZhciBsYXN0U291cmNlTGluZSAgICA9IDBcblx0XHR2YXIgbGFzdFNvdXJjZUNvbHVtbiAgPSAwXG5cdFx0dmFyIGJ1ZmZlciAgICAgICAgICAgID0gXCJcIlxuXG5cdFx0Zm9yIGxpbmUsbGluZU51bWJlciBpbiBAbWFwc1xuXHRcdFx0bGFzdENvbHVtbiA9IDBcblxuXHRcdFx0Zm9yIG1hcCxuciBpbiBsaW5lXG5cdFx0XHRcdGJ1ZmZlciArPSAnLCcgdW5sZXNzIG5yID09IDBcblx0XHRcdFx0dmFyIHNyYyA9IG1hcFswXVxuXHRcdFx0XHR2YXIgZGVzdCA9IG1hcFsxXVxuXHRcdFx0XHRcblx0XHRcdFx0YnVmZmVyICs9IGVuY29kZVZscShkZXN0WzFdIC0gbGFzdENvbHVtbilcblx0XHRcdFx0bGFzdENvbHVtbiA9IGRlc3RbMV1cblx0XHRcdFx0IyBhZGQgaW5kZXhcblx0XHRcdFx0YnVmZmVyICs9IGVuY29kZVZscSgwKVxuXG5cdFx0XHRcdCMgVGhlIHN0YXJ0aW5nIGxpbmUgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgcmVsYXRpdmUgdG8gdGhlIHByZXZpb3VzIHNvdXJjZSBsaW5lLlxuXHRcdFx0XHRidWZmZXIgKz0gZW5jb2RlVmxxKHNyY1swXSAtIGxhc3RTb3VyY2VMaW5lKVxuXHRcdFx0XHRsYXN0U291cmNlTGluZSA9IHNyY1swXVxuXHRcdFx0XHQjIFRoZSBzdGFydGluZyBjb2x1bW4gaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgcmVsYXRpdmUgdG8gdGhlIHByZXZpb3VzIGNvbHVtbi5cblx0XHRcdFx0YnVmZmVyICs9IGVuY29kZVZscShzcmNbMV0gLSBsYXN0U291cmNlQ29sdW1uKVxuXHRcdFx0XHRsYXN0U291cmNlQ29sdW1uID0gc3JjWzFdXG5cblx0XHRcdGJ1ZmZlciArPSBcIjtcIlxuXG5cblx0XHR2YXIgcmVsID0gcGF0aC5yZWxhdGl2ZShwYXRoLmRpcm5hbWUodGFyZ2V0UGF0aCksc291cmNlUGF0aClcblxuXHRcdHZhciBtYXAgPVxuXHRcdFx0dmVyc2lvbjogM1xuXHRcdFx0ZmlsZTogc291cmNlTmFtZS5yZXBsYWNlKC9cXC5pbWJhLywnLmpzJykgb3IgJydcblx0XHRcdHNvdXJjZVJvb3Q6IG9wdGlvbnM6c291cmNlUm9vdCBvciAnJ1xuXHRcdFx0c291cmNlczogICAgW3JlbF1cblx0XHRcdHNvdXJjZXNDb250ZW50OiBbc291cmNlQ29kZV1cblx0XHRcdG5hbWVzOiAgICAgIFtdXG5cdFx0XHRtYXBwaW5nczogICBidWZmZXJcblxuXHRcdCMgc291cmNlOnNvdXJjZW1hcCA9IHNvdXJjZW1hcFxuXHRcdCMgdmFyIGJhc2U2NCA9IEJ1ZmZlci5uZXcoSlNPTi5zdHJpbmdpZnkobWFwKSkudG9TdHJpbmcoXCJiYXNlNjRcIilcblx0XHQjIHNvdXJjZTpqcyArPSBcIlxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQse2Jhc2U2NH1cIlxuXHRcdHJldHVybiBtYXBcblxuXHRWTFFfU0hJRlQgPSA1XG5cdFZMUV9DT05USU5VQVRJT05fQklUID0gMSA8PCBWTFFfU0hJRlRcblx0VkxRX1ZBTFVFX01BU0sgPSBWTFFfQ09OVElOVUFUSU9OX0JJVCAtIDFcblx0QkFTRTY0X0NIQVJTID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5cblx0IyBib3Jyb3dlZCBmcm9tIENvZmZlZVNjcmlwdFxuXHRkZWYgZW5jb2RlVmxxIHZhbHVlXG5cdFx0dmFyIGFuc3dlciA9ICcnXG5cdFx0IyBMZWFzdCBzaWduaWZpY2FudCBiaXQgcmVwcmVzZW50cyB0aGUgc2lnbi5cblx0XHR2YXIgc2lnbkJpdCA9IHZhbHVlIDwgMCA/IDEgOiAwXG5cdFx0dmFyIG5leHRDaHVua1xuXHRcdCMgVGhlIG5leHQgYml0cyBhcmUgdGhlIGFjdHVhbCB2YWx1ZS5cblx0XHR2YXIgdmFsdWVUb0VuY29kZSA9IChNYXRoLmFicyh2YWx1ZSkgPDwgMSkgKyBzaWduQml0XG5cdFx0IyBNYWtlIHN1cmUgd2UgZW5jb2RlIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIsIGV2ZW4gaWYgdmFsdWVUb0VuY29kZSBpcyAwLlxuXHRcdHdoaWxlIHZhbHVlVG9FbmNvZGUgb3IgIWFuc3dlclxuXHRcdFx0dmFyIG5leHRDaHVuayA9IHZhbHVlVG9FbmNvZGUgJiBWTFFfVkFMVUVfTUFTS1xuXHRcdFx0dmFsdWVUb0VuY29kZSA9IHZhbHVlVG9FbmNvZGUgPj4gVkxRX1NISUZUXG5cdFx0XHRpZiB2YWx1ZVRvRW5jb2RlXG5cdFx0XHRcdG5leHRDaHVuayB8PSBWTFFfQ09OVElOVUFUSU9OX0JJVFxuXG5cdFx0XHRhbnN3ZXIgKz0gZW5jb2RlQmFzZTY0KG5leHRDaHVuaylcblxuXHRcdGFuc3dlclxuXG5cdGRlZiBlbmNvZGVCYXNlNjQgdmFsdWVcblx0XHRCQVNFNjRfQ0hBUlNbdmFsdWVdICMgb3IgdGhyb3cgRXJyb3IubmV3KFwiQ2Fubm90IEJhc2U2NCBlbmNvZGUgdmFsdWU6IHt2YWx1ZX1cIilcblxuXHRcdFxuXHRcdFxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHNyYy9jb21waWxlci9zb3VyY2VtYXAuaW1iYVxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=