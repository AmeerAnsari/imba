var Imbac =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		var parser, lex, Rewriter;
		
		// var imba = require '../imba'
		var T = __webpack_require__(1);
		var ERR = __webpack_require__(2);
		var util = __webpack_require__(3);
		var lexer = __webpack_require__(4);
		var rewriter = __webpack_require__(5);
		module.exports.parser = parser = __webpack_require__(6).parser;
		var ast = __webpack_require__(9);
		
		var ImbaParseError = __webpack_require__(2).ImbaParseError;
		
		// Instantiate a Lexer for our use here.
		module.exports.lex = lex = new (lexer.Lexer)();
		module.exports.Rewriter = Rewriter = rewriter.Rewriter;
		
		parser.lexer = lex.jisonBridge();
		parser.yy = ast; // everything is exported right here now
		
		
		function tokenize(code,o){
			if(o === undefined) o = {};
			try {
				o._source = code;
				lex.reset();
				return lex.tokenize(code,o);
			} catch (err) {
				throw err;
			};
		}; exports.tokenize = tokenize;
		
		function rewrite(tokens,o){
			if(o === undefined) o = {};
			var rewriter = new Rewriter();
			try {
				return rewriter.rewrite(tokens,o);
			} catch (err) {
				throw err;
			};
		}; exports.rewrite = rewrite;
		
		
		function parse(code,o){
			if(o === undefined) o = {};
			var tokens = code instanceof Array ? (code) : (tokenize(code,o));
			try {
				// console.log("Tokens",tokens)
				if (tokens != code) o._source || (o._source = code);
				o._tokens = tokens;
				return parser.parse(tokens);
			} catch (err) {
				if (o.filename) { err._filename = o.filename };
				throw err;
			};
		}; exports.parse = parse;
		
		
		function compile(code,o){
			if(o === undefined) o = {};
			try {
				var tokens = tokenize(code,o);
				var ast = parse(tokens,o);
				return ast.compile(o);
			} catch (err) {
				if (o.filename) { err._filename = o.filename };
				tokens || (tokens = o._tokens);
				
				if (tokens && (err instanceof ImbaParseError)) {
					try {
						var tok = err.start();
					} catch (e) {
						throw err;
					};
					
					var locmap = util.locationToLineColMap(code);
					var lines = code.split(/\n/g);
					
					var lc = locmap[tok._loc] || [0,0];
					var ln = lc[0];
					var col = lc[1];
					var line = lines[ln];
					
					var message = err.message + ("\n\n" + ln) + ("\n" + (ln + 1) + " " + line) + ("\n" + (ln + 2));
					var reducer = function(s,c,i) {
						return s += i == col ? ("^") : ((c == "\t" ? (c) : (" ")));
					};
					message += line.split('').reduce(reducer,"");
					
					err.message = message;
				};
				throw err;
			};
		}; exports.compile = compile;
		
		function analyze(code,o){
			if(o === undefined) o = {};
			var meta;
			try {
				var ast = parse(code,o);
				meta = ast.analyze(o);
			} catch (e) {
				// console.log "something wrong {e:message}"
				if (!((e instanceof ImbaParseError))) {
					if (e.lexer) {
						e = new ImbaParseError(e,{tokens: e.lexer.tokens,pos: e.lexer.pos});
					} else {
						throw e;
					};
				};
				meta = {warnings: [e]};
			};
			return meta;
		}; exports.analyze = analyze;; return analyze;

	})()

/***/ },
/* 1 */
/***/ function(module, exports) {

	(function(){
		var TOK, LBRACKET, RBRACKET, LPAREN, RPAREN, INDENT, OUTDENT;
		
		
		module.exports.TOK = TOK = {};
		var TTERMINATOR = TOK.TERMINATOR = 1;
		var TIDENTIFIER = TOK.IDENTIFIER = 2;
		var TIDENTIFIER = TOK.IVAR = 2;
		var CONST = TOK.CONST = 3;
		var VAR = TOK.VAR = 4;
		var IF = TOK.IF = 5;
		var ELSE = TOK.ELSE = 6;
		var DEF = TOK.DEF = 7;
		
		
		
		function Token(type,value,loc,len){
			this._type = type;
			this._value = value;
			this._loc = loc != null ? (loc) : (-1);
			this._len = len || 0;
			this._meta = null;
			this.generated = false;
			this.newLine = false;
			this.spaced = false;
			return this;
		};
		
		exports.Token = Token; // export class 
		Token.prototype.type = function (){
			return this._type;
		};
		
		Token.prototype.value = function (){
			return this._value;
		};
		
		Token.prototype.traverse = function (){
			return;
		};
		
		Token.prototype.c = function (){
			return "" + this._value;
		};
		
		Token.prototype.toString = function (){
			return this._value;
		};
		
		Token.prototype.charAt = function (i){
			return this._value.charAt(i);
		};
		
		Token.prototype.slice = function (i){
			return this._value.slice(i);
		};
		
		Token.prototype.region = function (){
			return [this._loc,this._loc + (this._len || this._value.length)];
		};
		
		Token.prototype.sourceMapMarker = function (){
			return this._loc == -1 ? (':') : (("%$" + (this._loc) + "$%"));
			// @col == -1 ? '' : "%%{@line}${@col}%%"
		};
		
		
		function lex(){
			var token = this.tokens[this.pos++];
			var ttag;
			
			if (token) {
				ttag = token._type;
				this.yytext = token;
			} else {
				ttag = '';
			};
			
			return ttag;
		}; exports.lex = lex;
		
		
		// export def token typ, val, line, col, len do Token.new(typ,val,line, col or 0, len or 0) # [null,typ,val,loc]
		function token(typ,val){
			return new Token(typ,val,-1,0);
		}; exports.token = token;
		
		function typ(tok){
			return tok._type;
		}; exports.typ = typ;
		function val(tok){
			return tok._value;
		}; exports.val = val; // tok[offset + 1]
		function line(tok){
			return tok._line;
		}; exports.line = line; // tok[offset + 2]
		function loc(tok){
			return tok._loc;
		}; exports.loc = loc; // tok[offset + 2]
		
		function setTyp(tok,v){
			return tok._type = v;
		}; exports.setTyp = setTyp;
		function setVal(tok,v){
			return tok._value = v;
		}; exports.setVal = setVal;
		function setLine(tok,v){
			return tok._line = v;
		}; exports.setLine = setLine;
		function setLoc(tok,v){
			return tok._loc = v;
		}; exports.setLoc = setLoc;
		
		
		module.exports.LBRACKET = LBRACKET = new Token('{','{',0,0,0);
		module.exports.RBRACKET = RBRACKET = new Token('}','}',0,0,0);
		
		module.exports.LPAREN = LPAREN = new Token('(','(',0,0,0);
		module.exports.RPAREN = RPAREN = new Token(')',')',0,0,0);
		
		LBRACKET.generated = true;
		RBRACKET.generated = true;
		LPAREN.generated = true;
		RPAREN.generated = true;
		
		module.exports.INDENT = INDENT = new Token('INDENT','2',0,0,0);
		return module.exports.OUTDENT = OUTDENT = new Token('OUTDENT','2',0,0,0);
	
	})()

/***/ },
/* 2 */
/***/ function(module, exports) {

	(function(){
		// helper for subclassing
		function subclass$(obj,sup) {
			for (var k in sup) {
				if (sup.hasOwnProperty(k)) obj[k] = sup[k];
			};
			// obj.__super__ = sup;
			obj.prototype = Object.create(sup.prototype);
			obj.__super__ = obj.prototype.__super__ = sup.prototype;
			obj.prototype.initialize = obj.prototype.constructor = obj;
		};
		
		// create separate error-types with all the logic
		
		function ImbaParseError(e,o){
			this.error = e;
			this.message = e.message;
			this.filename = e.filename;
			this.line = e.line;
			this._options = o || {};
			this;
		};
		
		subclass$(ImbaParseError,Error);
		exports.ImbaParseError = ImbaParseError; // export class 
		ImbaParseError.wrap = function (err){
			// what about the stacktrace?
			return new ImbaParseError(err);
		};
		
		ImbaParseError.prototype.set = function (opts){
			this._options || (this._options = {});
			for (var i = 0, keys = Object.keys(opts), l = keys.length; i < l; i++){
				this._options[keys[i]] = opts[keys[i]];
			};
			return this;
		};
		
		ImbaParseError.prototype.start = function (){
			var o = this._options;
			var idx = o.pos - 1;
			var tok = o.tokens && o.tokens[idx];
			while (tok && tok._loc == -1){
				tok = o.tokens[--idx];
			};
			return tok;
		};
		
		ImbaParseError.prototype.desc = function (){
			var o = this._options;
			var msg = this.message;
			if (o.token && o.token._loc == -1) {
				return 'Syntax Error';
			} else {
				return msg;
			};
		};
		
		ImbaParseError.prototype.loc = function (){
			var start_;
			return (start_ = this.start()) && start_.region  &&  start_.region();
		};
		
		ImbaParseError.prototype.toJSON = function (){
			var o = this._options;
			var tok = this.start();
			// var tok = o:tokens and o:tokens[o:pos - 1]
			// var loc = tok and [tok.@loc,tok.@loc + (tok.@len or tok.@value:length)] or [0,0]
			// , col: tok.@col, line: tok.@line
			// get the token itself?
			return {warn: true,message: this.desc(),loc: this.loc()};
		};
		return ImbaParseError;
	
	})()

/***/ },
/* 3 */
/***/ function(module, exports) {

	(function(){
		
		function brace(str){
			var lines = str.match(/\n/);
			// what about indentation?
			
			if (lines) {
				return '{' + str + '\n}';
			} else {
				return '{\n' + str + '\n}';
			};
		}; exports.brace = brace;
		
		function normalizeIndentation(str){
			var m;
			var reg = /\n+([^\n\S]*)/g;
			var ind = null;
			
			var length_;while (m = reg.exec(str)){
				var attempt = m[1];
				if (ind == null || 0 < (length_ = attempt.length) && length_ < ind.length) {
					ind = attempt;
				};
			};
			
			if (ind) { str = str.replace(RegExp(("\\n" + ind),"g"),'\n') };
			return str;
		}; exports.normalizeIndentation = normalizeIndentation;
		
		
		function flatten(arr){
			var out = [];
			arr.forEach(function(v) { return v instanceof Array ? (out.push.apply(out,flatten(v))) : (out.push(v)); });
			return out;
		}; exports.flatten = flatten;
		
		
		function pascalCase(str){
			return str.replace(/(^|[\-\_\s])(\w)/g,function(m,v,l) { return l.toUpperCase(); });
		}; exports.pascalCase = pascalCase;
		
		function camelCase(str){
			str = String(str);
			// should add shortcut out
			return str.replace(/([\-\_\s])(\w)/g,function(m,v,l) { return l.toUpperCase(); });
		}; exports.camelCase = camelCase;
		
		function snakeCase(str){
			var str = str.replace(/([\-\s])(\w)/g,'_');
			return str.replace(/()([A-Z])/g,"_$1",function(m,v,l) { return l.toUpperCase(); });
		}; exports.snakeCase = snakeCase;
		
		function setterSym(sym){
			return camelCase(("set-" + sym));
		}; exports.setterSym = setterSym;
		
		function quote(str){
			return '"' + str + '"';
		}; exports.quote = quote;
		
		function singlequote(str){
			return "'" + str + "'";
		}; exports.singlequote = singlequote;
		
		function symbolize(str){
			str = String(str);
			var end = str.charAt(str.length - 1);
			
			if (end == '=') {
				str = 'set' + str[0].toUpperCase() + str.slice(1,-1);
			};
			
			if (str.indexOf("-") >= 0) {
				str = str.replace(/([\-\s])(\w)/g,function(m,v,l) { return l.toUpperCase(); });
			};
			
			return str;
		}; exports.symbolize = symbolize;
		
		
		function indent(str){
			return String(str).replace(/^/g,"\t").replace(/\n/g,"\n\t").replace(/\n\t$/g,"\n");
		}; exports.indent = indent;
		
		function bracketize(str,ind){
			if(ind === undefined) ind = true;
			if (ind) { str = "\n" + indent(str) + "\n" };
			return '{' + str + '}';
		}; exports.bracketize = bracketize;
		
		function parenthesize(str){
			return '(' + String(str) + ')';
		}; exports.parenthesize = parenthesize;
		
		function locationToLineColMap(code){
			var lines = code.split(/\n/g);
			var map = [];
			
			var chr;
			var loc = 0;
			var col = 0;
			var line = 0;
			
			while (chr = code[loc]){
				map[loc] = [line,col];
				
				if (chr == '\n') {
					line++;
					col = 0;
				} else {
					col++;
				};
				
				loc++;
			};
			
			return map;
		}; exports.locationToLineColMap = locationToLineColMap;
		
		function markLineColForTokens(tokens,code){
			return this;
		}; exports.markLineColForTokens = markLineColForTokens;; return markLineColForTokens;

	})()

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function idx$(a,b){
			return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
		};
		
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		// helper for subclassing
		function subclass$(obj,sup) {
			for (var k in sup) {
				if (sup.hasOwnProperty(k)) obj[k] = sup[k];
			};
			// obj.__super__ = sup;
			obj.prototype = Object.create(sup.prototype);
			obj.__super__ = obj.prototype.__super__ = sup.prototype;
			obj.prototype.initialize = obj.prototype.constructor = obj;
		};
		
		var ALL_KEYWORDS;
		
		var T = __webpack_require__(1);
		var Token = T.Token;
		
		var rw = __webpack_require__(5);
		var Rewriter = rw.Rewriter;
		var INVERSES = rw.INVERSES;
		
		var K = 0;
		
		var ERR = __webpack_require__(2);
		
		// Constants
		// ---------
		
		// Keywords that Imba shares in common with JavaScript.
		var JS_KEYWORDS = [
			'true','false','null','this',
			'delete','typeof','in','instanceof',
			'throw','break','continue','debugger',
			'if','else','switch','for','while','do','try','catch','finally',
			'class','extends','super','return'
		];
		
		// new can be used as a keyword in imba, since object initing is done through
		// MyObject.new. new is a very useful varname.
		
		// We want to treat return like any regular call for now
		// Must be careful to throw the exceptions in AST, since the parser
		// wont
		
		// Imba-only keywords. var should move to JS_Keywords
		// some words (like tokid) should be context-specific
		var IMBA_KEYWORDS = [
			'undefined','then','unless','until','loop','of','by',
			'when','def','tag','do','elif','begin','var','let','self','await','import'
		];
		
		var IMBA_CONTEXTUAL_KEYWORDS = ['extend','static','local','export','global','prop'];
		
		var IMBA_ALIAS_MAP = {
			'and': '&&',
			'or': '||',
			'is': '==',
			'isnt': '!=',
			'not': '!',
			'yes': 'true',
			'no': 'false',
			'isa': 'instanceof',
			'case': 'switch',
			'nil': 'null'
		};
		
		var IMBA_ALIASES = Object.keys(IMBA_ALIAS_MAP);
		var IMBA_KEYWORDS = IMBA_KEYWORDS.concat(IMBA_ALIASES);
		
		// FixedArray for performance
		// var ALL_KEYWORDS = JS_KEYWORDS.concat(IMBA_KEYWORDS)
		module.exports.ALL_KEYWORDS = ALL_KEYWORDS = [
			'true','false','null','this',
			'delete','typeof','in','instanceof',
			'throw','break','continue','debugger',
			'if','else','switch','for','while','do','try','catch','finally',
			'class','extends','super','return',
			'undefined','then','unless','until','loop','of','by',
			'when','def','tag','do','elif','begin','var','let','self','await','import',
			'and','or','is','isnt','not','yes','no','isa','case','nil'
		];
		
		// The list of keywords that are reserved by JavaScript, but not used, or are
		// used by Imba internally. We throw an error when these are encountered,
		// to avoid having a JavaScript error at runtime.  # 'var', 'let', - not inside here
		var RESERVED = ['case','default','function','void','with','const','enum','native'];
		var STRICT_RESERVED = ['case','function','void','const'];
		
		// The superset of both JavaScript keywords and reserved words, none of which may
		// be used as identifiers or properties.
		var JS_FORBIDDEN = JS_KEYWORDS.concat(RESERVED);
		
		var METHOD_IDENTIFIER = /^((([\x23]?[\$A-Za-z_\x7f-\uffff][$\-\w\x7f-\uffff]*)([\=]?))|(<=>|\|(?![\|=])))/;
		// removed ~=|~| |&(?![&=])
		
		// Token matching regexes.
		// added hyphens to identifiers now - to test
		var IDENTIFIER = /^((\$|@@|@|\#)[\wA-Za-z_\-\x7f-\uffff][$\w\x7f-\uffff]*(\-[$\w\x7f-\uffff]+)*|[$A-Za-z_][$\w\x7f-\uffff]*(\-[$\w\x7f-\uffff]+)*)([^\n\S]*:(?![\*\=:$\w\x7f-\uffff]))?/;
		
		var OBJECT_KEY = /^((\$|@@|@|)[$A-Za-z_\x7f-\uffff\-][$\w\x7f-\uffff\-]*)([^\n\S\s]*:(?![\*\=:$\w\x7f-\uffff]))/;
		
		var TAG = /^(\<|%)(?=[A-Za-z\#\.\{\@\>])/;
		
		var TAG_TYPE = /^(\w[\w\d]*:)?(\w[\w\d]*)(-[\w\d]+)*/;
		var TAG_ID = /^#((\w[\w\d]*)(-[\w\d]+)*)/;
		
		var TAG_ATTR = /^([\.\:]?[\w\_]+([\-\:][\w]+)*)(\s)*\=/;
		
		var SELECTOR = /^([%\$]{1,2})([\(\w\#\.\[])/;
		var SELECTOR_PART = /^(\#|\.|:|::)?([\w]+(\-[\w]+)*)/;
		var SELECTOR_COMBINATOR = /^ (\+|\>|\~)*\s*(?=[\w\.\#\:\{\*\[])/;
		
		var SELECTOR_PSEUDO_CLASS = /^(::?)([\w]+(\-[\w]+)*)/;
		var SELECTOR_ATTR_OP = /^(\$=|\~=|\^=|\*=|\|=|=|\!=)/;
		var SELECTOR_ATTR = /^\[([\w\_\-]+)(\$=|\~=|\^=|\*=|\|=|=|\!=)/;
		
		var SYMBOL = /^\:((([\*\@$\w\x7f-\uffff]+)+([\-\\/\\\:][\w\x7f-\uffff]+)*)|==|\<=\>|\[\]|\[\]\=|\*|[\\/,\\])/;
		
		
		var NUMBER = /^0x[\da-f]+|^0b[01]+|^\d*\.?\d+(?:e[+-]?\d+)?/i;
		
		var HEREDOC = /^("""|''')([\s\S]*?)(?:\n[^\n\S]*)?\1/;
		
		var OPERATOR = /^(?:[-=]=>|===|->|!==|[-+*\/%<>&|^!?=]=|=<|>>>=?|([-+:])\1|([&|<>])\2=?|\?\.|\?\:|\.{2,3}|\*(?=[a-zA-Z\_]))/;
		
		// FIXME splat should only be allowed when the previous thing is spaced or inside call?
		
		var WHITESPACE = /^[^\n\S]+/;
		
		var COMMENT = /^###([^#][\s\S]*?)(?:###[^\n\S]*|(?:###)?$)/;
		// COMMENT    = /^###([^#][\s\S]*?)(?:###[^\n\S]*|(?:###)?$)|^(?:\s*(#\s.*|#\s*$))+/
		var INLINE_COMMENT = /^(\s*)(#[ \t\!](.*)|#[ \t]?(?=\n|$))+/;
		
		var CODE = /^[-=]=>/;
		
		var MULTI_DENT = /^(?:\n[^\n\S]*)+/;
		
		var SIMPLESTR = /^'[^\\']*(?:\\.[^\\']*)*'/;
		
		var JSTOKEN = /^`[^\\`]*(?:\\.[^\\`]*)*`/;
		
		// Regex-matching-regexes.
		var REGEX = /^(\/(?![\s=])[^[\/\n\\]*(?:(?:\\[\s\S]|\[[^\]\n\\]*(?:\\[\s\S][^\]\n\\]*)*])[^[\/\n\\]*)*\/)([imgy]{0,4})(?!\w)/;
		
		var HEREGEX = /^\/{3}([\s\S]+?)\/{3}([imgy]{0,4})(?!\w)/;
		
		var HEREGEX_OMIT = /\s+(?:#.*)?/g;
		
		// Token cleaning regexes.
		var MULTILINER = /\n/g;
		
		var HEREDOC_INDENT = /\n+([^\n\S]*)/g;
		
		var HEREDOC_ILLEGAL = /\*\//;
		
		// expensive?
		var LINE_CONTINUER = /^\s*(?:,|\??\.(?![.\d])|::)/;
		
		var TRAILING_SPACES = /\s+$/;
		
		var CONST_IDENTIFIER = /^[A-Z]/;
		
		var ARGVAR = /^\$\d$/;
		
		// Compound assignment tokens.
		var COMPOUND_ASSIGN = ['-=','+=','/=','*=','%=','||=','&&=','?=','<<=','>>=','>>>=','&=','^=','|=','=<'];
		
		// Unary tokens.
		var UNARY = ['!','~','NEW','TYPEOF','DELETE'];
		
		// Logical tokens.
		var LOGIC = ['&&','||','&','|','^'];
		
		// Bit-shifting tokens.
		var SHIFT = ['<<','>>','>>>'];
		
		// Comparison tokens.
		var COMPARE = ['===','!==','==','!=','<','>','<=','>=','===','!=='];
		
		// Overideable methods
		var OP_METHODS = ['<=>','<<','..'];
		
		// Mathematical tokens.
		var MATH = ['*','/','%','∪','∩','√'];
		
		// Relational tokens that are negatable with `not` prefix.
		var RELATION = ['IN','OF','INSTANCEOF','ISA'];
		
		// Boolean tokens.
		var BOOL = ['TRUE','FALSE','NULL','UNDEFINED'];
		
		// Our list is shorter, due to sans-parentheses method calls.
		var NOT_REGEX = ['NUMBER','REGEX','BOOL','TRUE','FALSE','++','--',']'];
		
		// If the previous token is not spaced, there are more preceding tokens that
		// force a division parse:
		var NOT_SPACED_REGEX = ['NUMBER','REGEX','BOOL','TRUE','FALSE','++','--',']',')','}','THIS','SELF','IDENTIFIER','STRING'];
		
		// Tokens which could legitimately be invoked or indexed. An opening
		// parentheses or bracket following these tokens will be recorded as the start
		// of a function invocation or indexing operation.
		// really?!
		
		var UNFINISHED = ['\\','.','?.','?:','UNARY','MATH','+','-','SHIFT','RELATION','COMPARE','LOGIC','COMPOUND_ASSIGN','THROW','EXTENDS'];
		
		// } should not be callable anymore!!! '}', '::',
		var CALLABLE = ['IDENTIFIER','STRING','REGEX',')',']','THIS','SUPER','TAG_END','IVAR','GVAR','SELF','CONST','NEW','ARGVAR','SYMBOL','RETURN'];
		// var INDEXABLE = CALLABLE.concat 'NUMBER', 'BOOL', 'TAG_SELECTOR', 'IDREF', 'ARGUMENTS','}' # are booleans indexable? really?
		// optimize for FixedArray
		var INDEXABLE = [
			'IDENTIFIER','STRING','REGEX',')',']','THIS','SUPER','TAG_END','IVAR','GVAR','SELF','CONST','NEW','ARGVAR','SYMBOL','RETURN',
			'NUMBER','BOOL','TAG_SELECTOR','IDREF','ARGUMENTS','}','TAG_TYPE'
		];
		
		var GLOBAL_IDENTIFIERS = ['global','exports','require'];
		
		// Tokens that, when immediately preceding a `WHEN`, indicate that the `WHEN`
		// occurs at the start of a line. We disambiguate these from trailing whens to
		// avoid an ambiguity in the grammar.
		var LINE_BREAK = ['INDENT','OUTDENT','TERMINATOR'];
		
		
		function LexerError(message,file,line){
			this.message = message;
			this.file = file;
			this.line = line;
			return this;
		};
		subclass$(LexerError,SyntaxError);
		exports.LexerError = LexerError; // export class 
		
		
		
		function last(array,back){
			if(back === undefined) back = 0;
			return array[array.length - back - 1];
		};
		
		function count(str,substr){
			return str.split(substr).length - 1;
		};
		
		function repeatString(str,times){
			var res = '';
			while (times > 0){
				if (times % 2 == 1) {
					res += str;
				};
				str += str;
				times >>= 1;
			};
			return res;
		};
		
		var tT = T.typ;
		var tV = T.val;
		var tTs = T.setTyp;
		var tVs = T.setVal;
		
		// The Lexer class reads a stream of Imba and divvies it up into tokidged
		// tokens. Some potential ambiguity in the grammar has been avoided by
		// pushing some extra smarts into the Lexer.
		
		// Based on the original lexer.coffee from CoffeeScript
		function Lexer(){
			this.reset();
			this;
		};
		
		exports.Lexer = Lexer; // export class 
		Lexer.prototype.reset = function (){
			this._code = null;
			this._chunk = null; // The remainder of the source code.
			this._opts = null;
			
			this._indent = 0; // The current indentation level.
			this._indebt = 0; // The over-indentation at the current level.
			this._outdebt = 0; // The under-outdentation at the current level.
			
			this._indents = []; // The stack of all current indentation levels.
			this._ends = []; // The stack for pairing up tokens.
			this._contexts = []; // suplements @ends
			this._scopes = [];
			this._nextScope = null; // the scope to add on the next indent
			// should rather make it like a statemachine that moves from CLASS_DEF to CLASS_BODY etc
			// Things should compile differently when you are in a CLASS_BODY than when in a DEF_BODY++
			
			this._indentStyle = null;
			
			this._tokens = []; // Stream of parsed tokens in the form `['TYPE', value, line]`.
			this._seenFor = false;
			this._loc = 0;
			this._locOffset = 0;
			
			this._end = null;
			this._char = null;
			this._bridge = null;
			this._last = null;
			this._lastTyp = '';
			this._lastVal = null;
			return this;
		};
		
		Lexer.prototype.jisonBridge = function (jison){
			return this._bridge = {
				lex: T.lex,
				setInput: function(tokens) {
					this.tokens = tokens;
					return this.pos = 0;
				},
				
				upcomingInput: function() { return ""; }
			};
		};
		
		
		Lexer.prototype.tokenize = function (code,o){
			
			if(o === undefined) o = {};
			if (code.length == 0) {
				return [];
			};
			
			if (!o.inline) {
				if (WHITESPACE.test(code)) {
					code = ("\n" + code);
					if (code.match(/^\s*$/g)) { return [] };
				};
				
				code = code.replace(/\r/g,'').replace(/[\t ]+$/g,'');
			};
			
			this._last = null;
			this._lastTyp = null;
			this._lastVal = null;
			
			this._code = code;
			this._opts = o;
			this._locOffset = o.loc || 0;
			
			o.indent || (o.indent = {style: null,size: null});
			// add a reference to the options object
			o._tokens = this._tokens;
			// what about col here?
			
			// @indent  = 0 # The current indentation level.
			// @indebt  = 0 # The over-indentation at the current level.
			// @outdebt = 0 # The under-outdentation at the current level.
			// @indents = [] # The stack of all current indentation levels.
			// @ends    = [] # The stack for pairing up tokens.
			// @tokens  = [] # Stream of parsed tokens in the form `['TYPE', value, line]`.
			// @char = nil
			
			if (o.profile) { console.time("tokenize:lexer") };
			this.parse(code);
			if (!o.inline) this.closeIndentation();
			if (!o.silent && this._ends.length) {
				this.error(("missing " + (this._ends.pop())));
			};
			
			if (o.profile) { console.timeEnd("tokenize:lexer") };
			if (o.rewrite == false || o.norewrite) { return this._tokens };
			return new Rewriter().rewrite(this._tokens,o);
		};
		
		Lexer.prototype.parse = function (code){
			var i = 0;
			var pi = 0;
			
			while (this._chunk = code.slice(i)){
				this._loc = this._locOffset + i;
				pi = (this._end == 'TAG' && this.tagDefContextToken()) || (this._inTag && this.tagContextToken()) || this.basicContext();
				i += pi;
			};
			
			return;
		};
		
		Lexer.prototype.basicContext = function (){
			return this.selectorToken() || this.symbolToken() || this.methodNameToken() || this.identifierToken() || this.whitespaceToken() || this.lineToken() || this.commentToken() || this.heredocToken() || this.tagToken() || this.stringToken() || this.numberToken() || this.regexToken() || this.jsToken() || this.literalToken() || 0;
		};
		
		Lexer.prototype.moveCaret = function (i){
			return this._loc += i;
		};
		
		Lexer.prototype.context = function (){
			return this._ends[this._ends.length - 1];
		};
		
		Lexer.prototype.inContext = function (key){
			var o = this._contexts[this._contexts.length - 1];
			return o && o[key];
		};
		
		Lexer.prototype.pushEnd = function (val){
			// console.log "pushing end",val
			this._ends.push(val);
			this._contexts.push(null);
			this._end = val;
			this.refreshScope();
			return this;
		};
		
		Lexer.prototype.popEnd = function (val){
			this._ends.pop();
			this._contexts.pop();
			this._end = this._ends[this._ends.length - 1];
			this.refreshScope();
			return this;
		};
		
		Lexer.prototype.refreshScope = function (){
			var ctx0 = this._ends[this._ends.length - 1];
			var ctx1 = this._ends[this._ends.length - 2];
			return this._inTag = ctx0 == 'TAG_END' || (ctx1 == 'TAG_END' && ctx0 == 'OUTDENT');
		};
		
		
		
		Lexer.prototype.queueScope = function (val){
			// console.log("pushing scope {val} - {@indents} {@indents:length}")
			// @scopes.push(val) # no no
			this._scopes[this._indents.length] = val;
			return this;
		};
		
		Lexer.prototype.popScope = function (val){
			this._scopes.pop();
			return this;
		};
		
		Lexer.prototype.getScope = function (){
			return this._scopes[this._indents.length - 1];
		};
		
		Lexer.prototype.scope = function (sym,opts){
			var len = this._ends.push(this._end = sym);
			this._contexts.push(opts || null);
			return sym;
		};
		
		
		Lexer.prototype.closeSelector = function (){
			if (this._end == '%') {
				this.token('SELECTOR_END','%',0);
				return this.pair('%');
			};
		};
		
		
		Lexer.prototype.openDef = function (){
			return this.pushEnd('DEF');
		};
		
		
		Lexer.prototype.closeDef = function (){
			if (this.context() == 'DEF') {
				var prev = last(this._tokens);
				// console.log "close def {prev}"
				// console.log('closeDef with last>',prev)
				if (tT(prev) == 'DEF_FRAGMENT') {
					true;
				} else if (tT(prev) == 'TERMINATOR') {
					// console.log "here?!??"
					var n = this._tokens.pop();
					// console.log n
					this.token('DEF_BODY','DEF_BODY',0);
					// token('TERMINATOR', '',0) unless n.@value.indexOf('//') >= 0
					this._tokens.push(n);
				} else {
					this.token('DEF_BODY','DEF_BODY',0);
				};
				
				this.pair('DEF');
			};
			return;
		};
		
		Lexer.prototype.tagContextToken = function (){
			var match;
			if (this._chunk[0] == '#') {
				// console.log('found id # in tagContextToken')
				this.token('#','#',1);
				return 1;
			};
			
			if (match = TAG_ATTR.exec(this._chunk)) {
				// console.log 'TAG_SDDSATTR IN tokid',match
				// var prev = last @tokens
				// if the prev is a terminator, we dont really need to care?
				if (this._lastTyp != 'TAG_NAME') {
					if (this._lastTyp == 'TERMINATOR') {
						// console.log('prev was terminator -- drop it?')
						true;
					} else {
						this.token(",",",");
					};
				};
				
				var l = match[0].length;
				
				this.token('TAG_ATTR',match[1],l - 1); // add to loc?
				this._loc += l - 1;
				this.token('=','=',1);
				return l;
			};
			return 0;
		};
		
		Lexer.prototype.tagDefContextToken = function (){
			// console.log "tagContextToken"
			var match;
			if (match = TAG_TYPE.exec(this._chunk)) {
				this.token('TAG_TYPE',match[0],match[0].length);
				return match[0].length;
			};
			
			if (match = TAG_ID.exec(this._chunk)) {
				var input = match[0];
				this.token('TAG_ID',input,input.length);
				return input.length;
			};
			
			return 0;
		};
		
		
		Lexer.prototype.tagToken = function (){
			var match, ary;
			if (!(match = TAG.exec(this._chunk))) { return 0 };
			var ary = iter$(match);var input = ary[0],type = ary[1],identifier = ary[2];
			
			if (type == '<') {
				this.token('TAG_START','<',1);
				this.pushEnd(INVERSES.TAG_START);
				
				if (match = TAG_TYPE.exec(this._chunk.substr(1,40))) {
					// special case should probably be handled in AST
					if (match[0] != 'self') {
						this.token('TAG_TYPE',match[0],match[0].length,1);
						return input.length + match[0].length;
					};
				};
				
				if (identifier) {
					if (identifier.substr(0,1) == '{') {
						return type.length;
					} else {
						this.token('TAG_NAME',input.substr(1),0);
					};
				};
			};
			
			return input.length;
		};
		
		
		Lexer.prototype.selectorToken = function (){
			var ary;
			var match;
			
			// special handling if we are in this context
			if (this._end == '%') {
				var chr = this._chunk.charAt(0);
				var open = this.inContext('open');
				
				// should add for +, ~ etc
				// should maybe rather look for the correct type of character?
				
				if (open && (chr == ' ' || chr == '\n' || chr == ',' || chr == '+' || chr == '~' || chr == ')' || chr == ']')) {
					// console.log "close this selector directly"
					this.token('SELECTOR_END','%',0);
					this.pair('%');
					return 0;
				};
				
				if (match = SELECTOR_COMBINATOR.exec(this._chunk)) {
					// spaces between? -- include the whole
					this.token('SELECTOR_COMBINATOR',match[1] || " ",match[0].length);
					return match[0].length;
				} else if (match = SELECTOR_PART.exec(this._chunk)) {
					var type = match[1];
					var id = match[2];
					
					switch (type) {
						case '.':
							tokid = 'SELECTOR_CLASS';break;
						
						case '#':
							tokid = 'SELECTOR_ID';break;
						
						case ':':
							tokid = 'SELECTOR_PSEUDO_CLASS';break;
						
						case '::':
							tokid = 'SELECTOR_PSEUDO_CLASS';break;
						
						default:
						
							var tokid = 'SELECTOR_TAG';
					
					};
					
					this.token(tokid,match[2],match[0].length);
					return match[0].length;
				} else if (chr == '[') {
					this.token('[','[',1);
					this.pushEnd(']');
					if (match = SELECTOR_ATTR.exec(this._chunk)) {
						// fuck this length shit
						var idoffset = match[0].indexOf(match[1]);
						var opoffset = match[0].indexOf(match[2]);
						this.token('IDENTIFIER',match[1],match[1].length,idoffset);
						this.token('SELECTOR_ATTR_OP',match[2],match[2].length,opoffset);
						return match[0].length;
					};
					return 1;
				} else if (chr == '|') {
					var tok = this._tokens[this._tokens.length - 1];
					tTs(tok,'SELECTOR_NS');
					// tok[0] = 'SELECTOR_NS' # FIX
					return 1;
				} else if (chr == ',') {
					this.token('SELECTOR_GROUP',',',1);
					return 1;
				} else if (chr == '*') {
					this.token('UNIVERSAL_SELECTOR','*',1);
					return 1;
				} else if (chr == ')') {
					this.pair('%');
					this.token('SELECTOR_END',')',1);
					return 1;
				} else if (idx$(chr,[')','}',']','']) >= 0) {
					this.pair('%');
					return 0;
				};
			};
			
			if (!(match = SELECTOR.exec(this._chunk))) { return 0 };
			var ary = iter$(match);var input = ary[0],id = ary[1],kind = ary[2];
			
			// this is a closed selector
			if (kind == '(') {
				// token '(','('
				this.token('SELECTOR_START',id,id.length + 1);
				// self.pushEnd(')') # are we so sure about this?
				this.pushEnd('%');
				
				// @ends.push ')'
				// @ends.push '%'
				return id.length + 1;
			} else if (id == '%') {
				// we are already scoped in on a selector
				if (this.context() == '%') { return 1 };
				this.token('SELECTOR_START',id,id.length);
				// this is a separate - scope. Full selector should rather be $, and keep the single selector as %
				
				this.scope('%',{open: true});
				// @ends.push '%'
				// make sure a terminator breaks out
				return id.length;
			} else {
				return 0;
			};
		};
		
		// is this really needed? Should be possible to
		// parse the identifiers and = etc i jison?
		// what is special about methodNameToken? really?
		Lexer.prototype.methodNameToken = function (){
			// we can optimize this by after a def simply
			// fetching all the way after the def until a space or (
			// and then add this to the def-token itself (as with fragment)
			if (this._chunk.charAt(0) == ' ') { return 0 };
			
			var match;
			
			if (this._end == ')') {
				var outerctx = this._ends[this._ends.length - 2];
				// weird assumption, no?
				// console.log 'context is inside!!!'
				if (outerctx == '%' && (match = TAG_ATTR.exec(this._chunk))) {
					this.token('TAG_ATTR_SET',match[1]);
					return match[0].length;
				};
			};
			
			if (!(match = METHOD_IDENTIFIER.exec(this._chunk))) {
				return 0;
			};
			// var prev = last @tokens
			var length = match[0].length;
			
			var id = match[0];
			var ltyp = this._lastTyp;
			var typ = 'IDENTIFIER';
			var pre = id.charAt(0);
			var space = false;
			
			var m4 = match[4]; // might be out of bounds? should rather check charAt
			// drop match 4??
			
			// should this not quit here in practically all cases?
			if (!((ltyp == '.' || ltyp == 'DEF') || (m4 == '!' || m4 == '?') || match[5])) {
				return 0;
			};
			
			// again, why?
			if (id == 'self' || id == 'this' || id == 'super') { // in ['SELF','THIS']
				return 0;
			};
			
			if (id == 'new') {
				typ = 'NEW';
			};
			
			if (id == '...' && [',','(','CALL_START','BLOCK_PARAM_START','PARAM_START'].indexOf(ltyp) >= 0) {
				return 0;
			};
			
			if (id == '|') {
				// hacky way to implement this
				// with new lexer we'll use { ... } instead, and assume object-context,
				// then go back and correct when we see the context is invalid
				if (ltyp == '(' || ltyp == 'CALL_START') {
					this.token('DO','DO',0);
					this.pushEnd('|');
					// @ends.push '|'
					this.token('BLOCK_PARAM_START',id,1);
					return length;
				} else if (ltyp == 'DO' || ltyp == '{') {
					// @ends.push '|'
					this.pushEnd('|');
					this.token('BLOCK_PARAM_START',id,1);
					return length;
				} else if (this._ends[this._ends.length - 1] == '|') {
					this.token('BLOCK_PARAM_END','|',1);
					this.pair('|');
					return length;
				} else {
					return 0;
				};
			};
			
			// whaat?
			// console.log("method identifier",id)
			if ((['&','^','<<','<<<','>>'].indexOf(id) >= 0 || (id == '|' && this.context() != '|'))) {
				return 0;
			};
			
			if (OP_METHODS.indexOf(id) >= 0) {
				space = true;
			};
			
			// not even anything we should use?!?
			if (pre == '@') {
				typ = 'IVAR';
			} else if (pre == '$') {
				true;
				// typ = 'GVAR'
			} else if (pre == '#') {
				typ = 'TAGID';
			} else if (CONST_IDENTIFIER.test(pre) || id == 'require' || id == 'global' || id == 'exports') {
				// really? seems very strange
				// console.log('global!!',typ,id)
				typ = 'CONST';
			};
			
			// what is this really for?
			if (match[5] && ['IDENTIFIER','CONST','GVAR','CVAR','IVAR','SELF','THIS',']','}',')','NUMBER','STRING','IDREF'].indexOf(ltyp) >= 0) {
				this.token('.','.',0);
			};
			
			this.token(typ,id,length);
			
			if (space) {
				this._last.spaced = true;
			};
			
			return length;
		};
		
		
		Lexer.prototype.inTag = function (){
			var len = this._ends.length;
			if (len > 0) {
				var ctx0 = this._ends[len - 1];
				var ctx1 = len > 1 ? (this._ends[len - 2]) : (ctx0);
				return ctx0 == 'TAG_END' || (ctx1 == 'TAG_END' && ctx0 == 'OUTDENT');
			};
			return false;
		};
		
		Lexer.prototype.isKeyword = function (id){
			if ((id == 'attr' || id == 'prop')) {
				var scop = this.getScope();
				var incls = scop == 'CLASS' || scop == 'TAG';
				// var scopes = @indents.map(|ind,i| @scopes[i] or 'NONE')
				// console.log "id is prop: {scopes.join(" -> ")} | {@indents.join(" -> ")}"
				if (incls) { return true };
			};
			
			return ALL_KEYWORDS.indexOf(id) >= 0;
		};
		
		// Matches identifying literals: variables, keywords, method names, etc.
		// Check to ensure that JavaScript reserved words aren't being used as
		// identifiers. Because Imba reserves a handful of keywords that are
		// allowed in JavaScript, we're careful not to tokid them as keywords when
		// referenced as property names here, so you can still do `jQuery.is()` even
		// though `is` means `===` otherwise.
		Lexer.prototype.identifierToken = function (){
			var ary;
			var match;
			
			var ctx0 = this._ends[this._ends.length - 1];
			var ctx1 = this._ends[this._ends.length - 2];
			var innerctx = ctx0;
			var typ;
			var reserved = false;
			
			var addLoc = false;
			var inTag = ctx0 == 'TAG_END' || (ctx1 == 'TAG_END' && ctx0 == 'OUTDENT');
			
			// console.log ctx1,ctx0
			
			if (inTag && (match = TAG_ATTR.exec(this._chunk))) {
				// console.log 'TAG_ATTR IN tokid',match
				// var prev = last @tokens
				// if the prev is a terminator, we dont really need to care?
				if (this._lastTyp != 'TAG_NAME') {
					if (this._lastTyp == 'TERMINATOR') {
						// console.log('prev was terminator -- drop it?')
						true;
					} else {
						this.token(",",",");
					};
				};
				
				var l = match[0].length;
				
				this.token('TAG_ATTR',match[1],l - 1); // add to loc?
				this._loc += l - 1;
				this.token('=','=',1);
				return l;
			};
			
			// see if this is a plain object-key
			// way too much logic going on here?
			// the ast should normalize whether keys
			// are accessable as keys or strings etc
			if (match = OBJECT_KEY.exec(this._chunk)) {
				var id = match[1];
				typ = 'IDENTIFIER';
				
				// FIXME loc of key includes colon
				// moveCaret(id:length)
				// console.log "ok"
				if (true) {
					// console.log "got here? {match}"
					this.token(typ,id,id.length);
					this.moveCaret(id.length);
					this.token(':',':',match[3].length);
					this.moveCaret(-id.length);
					// moveCaret(match[3]:length)
					return match[0].length;
				};
				
				// moveCaret(match[2]:length)
				// return 0
				// console.log match[3]:length
				this.token(typ,id,match[0].length);
				this.token(':',':',1);
				return match[0].length;
			};
			
			if (!(match = IDENTIFIER.exec(this._chunk))) {
				return 0;
			};
			
			var ary = iter$(match);var input = ary[0],id = ary[1],typ = ary[2],m3 = ary[3],m4 = ary[4],colon = ary[5];
			var idlen = id.length;
			
			// What is the logic here?
			if (id == 'own' && this.lastTokenType() == 'FOR') {
				this.token('OWN',id,id.length);
				return id.length;
			};
			
			var prev = last(this._tokens);
			var lastTyp = this._lastTyp;
			
			// should we force this to be an identifier even if it is a reserved word?
			// this should only happen for when part of object etc
			// will prev ever be @???
			var forcedIdentifier;
			
			// again
			forcedIdentifier = colon || lastTyp == '.' || lastTyp == '?.'; // in ['.', '?.'
			
			
			// temp hack! need to solve for other keywords etc as well
			// problem appears with ternary conditions.
			
			// well -- it should still be an indentifier if in object?
			// forcedIdentifier = no if id in ['undefined','break']
			
			if (colon && lastTyp == '?') { forcedIdentifier = false }; // for ternary
			
			// if we are not at the top level? -- hacky
			if (id == 'tag' && this._chunk.indexOf("tag(") == 0) { // @chunk.match(/^tokid\(/)
				forcedIdentifier = true;
			};
			
			var isKeyword = false;
			
			// console.log "match",match
			// console.log "typ is {typ}"
			// little reason to check for this right here? but I guess it is only a simple check
			if (typ == '$' && ARGVAR.test(id)) { // id.match(/^\$\d$/)
				// console.log "TYP $"
				if (id == '$0') {
					typ = 'ARGUMENTS';
				} else {
					typ = 'ARGVAR';
					id = id.substr(1);
				};
			} else if (typ == '@') {
				typ = 'IVAR';
				
				// id:reserved = yes if colon
			} else if (typ == '#') {
				// we are trying to move to generic tokens,
				// so we are starting to splitting up the symbols and the items
				// we'll see if that works
				typ = 'IDENTIFIER';
				this.token('#','#');
				id = id.substr(1);
			} else if (typ == '@@') {
				typ = 'CVAR';
			} else if (typ == '$' && !(colon)) {
				typ = 'IDENTIFIER';
				// typ = 'GVAR'
			} else if (CONST_IDENTIFIER.test(id) || id == 'require' || id == 'global' || id == 'exports') {
				// thous should really be handled by the ast instead
				typ = 'CONST';
			} else if (id == 'elif') {
				this.token('ELSE','elif',id.length);
				this.token('IF','if');
				return id.length;
			} else {
				typ = 'IDENTIFIER';
			};
			
			
			
			// this catches all 
			if (!(forcedIdentifier) && (isKeyword = this.isKeyword(id))) {
				// (id in JS_KEYWORDS or id in IMBA_KEYWORDS)
				typ = id.toUpperCase();
				addLoc = true;
				
				// clumsy - but testing performance
				if (typ == 'YES') {
					typ = 'TRUE';
				} else if (typ == 'NO') {
					typ = 'FALSE';
				} else if (typ == 'NIL') {
					typ = 'NULL';
				} else if (typ == 'VAR') {
					if (this._lastVal == 'export') {
						tTs(prev,'EXPORT');
					};
				} else if (typ == 'IF' || typ == 'ELSE' || typ == 'TRUE' || typ == 'FALSE' || typ == 'NULL') {
					true;
				} else if (typ == 'TAG') {
					this.pushEnd('TAG');
					// @ends.push('TAG')
				} else if (typ == 'DEF') {
					// should probably shift context and optimize this
					this.openDef();
				} else if (typ == 'DO') {
					if (this.context() == 'DEF') this.closeDef();
				} else if (typ == 'WHEN' && LINE_BREAK.indexOf(this.lastTokenType()) >= 0) {
					typ = 'LEADING_WHEN';
				} else if (typ == 'FOR') {
					this._seenFor = true;
				} else if (typ == 'UNLESS') {
					typ = 'IF'; // WARN
				} else if (UNARY.indexOf(typ) >= 0) {
					typ = 'UNARY';
				} else if (RELATION.indexOf(typ) >= 0) {
					if (typ != 'INSTANCEOF' && typ != 'ISA' && this._seenFor) {
						typ = 'FOR' + typ; // ?
						this._seenFor = false;
					} else {
						typ = 'RELATION';
						if (String(this.value()) == '!') {
							this._tokens.pop(); // is fucked up??!
							// WARN we need to keep the loc, no?
							id = '!' + id;
						};
					};
				};
			};
			
			if (id == 'super') {
				typ = 'SUPER';
			};
			
			// do we really want to check this here
			if (!(forcedIdentifier)) {
				// should already have dealt with this
				
				if (isKeyword && IMBA_ALIASES.indexOf(id) >= 0) { id = IMBA_ALIAS_MAP[id] };
				// these really should not go here?!?
				switch (id) {
					case '!':
						typ = 'UNARY';break;
					
					case '==':
					case '!=':
					case '===':
					case '!==':
						typ = 'COMPARE';break;
					
					case '&&':
					case '||':
						typ = 'LOGIC';break;
					
					case 'break':
					case 'continue':
					case 'debugger':
					case 'arguments':
						typ = id.toUpperCase();break;
				
				};
			};
			
			// prev = last @tokens
			var len = input.length;
			
			// should be strict about the order, check this manually instead
			if (typ == 'CLASS' || typ == 'DEF' || typ == 'TAG') {
				this.queueScope(typ);
				
				var i = this._tokens.length;
				
				while (i){
					prev = this._tokens[--i];
					var ctrl = "" + tV(prev);
					// console.log("ctrl is {ctrl}")
					// need to coerce to string because of stupid CS ===
					// console.log("prev is",prev[0],prev[1])
					if (idx$(ctrl,IMBA_CONTEXTUAL_KEYWORDS) >= 0) {
						tTs(prev,ctrl.toUpperCase());
						// prev[0] = ctrl.toUpperCase # FIX
					} else {
						break;
					};
				};
			} else if (typ == 'IF') {
				this.queueScope(typ);
			} else if (typ == 'IMPORT') {
				// could manually parse the whole ting here?
				this.pushEnd('IMPORT');
				// @ends.push 'IMPORT'
			} else if (id == 'from' && ctx0 == 'IMPORT') {
				typ = 'FROM';
				this.pair('IMPORT');
			} else if (id == 'as' && ctx0 == 'IMPORT') {
				typ = 'AS';
				this.pair('IMPORT');
			};
			
			if (typ == 'IDENTIFIER') {
				// see if previous was catch -- belongs in rewriter?
				if (lastTyp == 'CATCH') {
					typ = 'CATCH_VAR';
				};
			};
			
			if (colon) {
				this.token(typ,id,idlen);
				this.moveCaret(idlen);
				// console.log "add colon?"
				this.token(':',':',colon.length);
				this.moveCaret(-idlen);
			} else {
				this.token(typ,id,idlen);
			};
			
			return len;
		};
		
		// Matches numbers, including decimals, hex, and exponential notation.
		// Be careful not to interfere with ranges-in-progress.
		Lexer.prototype.numberToken = function (){
			var binaryLiteral;
			var match,number,lexedLength;
			
			if (!(match = NUMBER.exec(this._chunk))) { return 0 };
			
			number = match[0];
			lexedLength = number.length;
			
			if (binaryLiteral = /0b([01]+)/.exec(number)) {
				
				number = "" + parseInt(binaryLiteral[1],2);
			};
			
			var prev = last(this._tokens);
			
			if (match[0][0] == '.' && prev && !prev.spaced && ['IDENTIFIER',')','}',']','NUMBER'].indexOf(tT(prev)) >= 0) {
				// console.log "got here"
				this.token(".",".");
				number = number.substr(1);
			};
			
			
			this.token('NUMBER',number,lexedLength);
			return lexedLength;
		};
		
		Lexer.prototype.symbolToken = function (){
			var match,symbol,prev;
			
			if (!(match = SYMBOL.exec(this._chunk))) { return 0 };
			symbol = match[0].substr(1);
			prev = last(this._tokens);
			
			// is this a property-access?
			// should invert this -- only allow when prev IS .. 
			
			// : should be a token itself, with a specification of spacing (LR,R,L,NONE)
			
			// FIX
			if (prev && !prev.spaced && idx$(tT(prev),['(','{','[','.','CALL_START','INDEX_START',',','=','INDENT','TERMINATOR']) == -1) {
				this.token('.:',':',1);
				var sym = symbol.split(/[\:\\\/]/)[0]; // really?
				// token 'SYMBOL', "'#{symbol}'"
				this.token('IDENTIFIER',sym,sym.length,1);
				return (sym.length + 1);
			} else {
				// token 'SYMBOL', "'#{symbol}'"
				this.token('SYMBOL',symbol,match[0].length);
				return match[0].length;
			};
		};
		
		Lexer.prototype.escapeStr = function (str,heredoc,q){
			str = str.replace(MULTILINER,(heredoc ? ('\\n') : ('')));
			if (q) {
				var r = RegExp(("\\\\[" + q + "]"),"g");
				str = str.replace(r,q);
				str = str.replace(RegExp(("" + q),"g"),'\\$&');
			};
			return str;
			
			// str = str.replace(MULTILINER, '\\n')
			// str = str.replace(/\t/g, '\\t')
		};
		// Matches strings, including multi-line strings. Ensures that quotation marks
		// are balanced within the string's contents, and within nested interpolations.
		Lexer.prototype.stringToken = function (){
			var match,string;
			
			switch (this._chunk.charAt(0)) {
				case "'":
					if (!(match = SIMPLESTR.exec(this._chunk))) { return 0 };
					string = match[0];
					this.token('STRING',this.escapeStr(string),string.length);
					// token 'STRING', (string = match[0]).replace(MULTILINER, '\\\n'), string:length
					break;
				
				case '"':
					if (!(string = this.balancedString(this._chunk,'"'))) { return 0 };
					// what about tripe quoted strings?
					
					if (string.indexOf('{') >= 0) {
						var len = string.length;
						// if this has no interpolation?
						// we are now messing with locations - beware
						this.token('STRING_START',string.charAt(0),1);
						this.interpolateString(string.slice(1,-1));
						this.token('STRING_END',string.charAt(len - 1),1,string.length - 1);
					} else {
						len = string.length;
						// string = string.replace(MULTILINER, '\\\n')
						this.token('STRING',this.escapeStr(string),len);
					};
					break;
				
				default:
				
					return 0;
			
			};
			
			this.moveHead(string);
			return string.length;
		};
		
		// Matches heredocs, adjusting indentation to the correct level, as heredocs
		// preserve whitespace, but ignore indentation to the left.
		Lexer.prototype.heredocToken = function (){
			var match,heredoc,quote,doc;
			
			if (!(match = HEREDOC.exec(this._chunk))) { return 0 };
			
			heredoc = match[0];
			quote = heredoc.charAt(0);
			doc = this.sanitizeHeredoc(match[2],{quote: quote,indent: null});
			// console.log "found heredoc {match[0]:length} {doc:length}"
			
			if (quote == '"' && doc.indexOf('{') >= 0) {
				var open = match[1];
				// console.log doc.substr(0,3),match[1]
				this.token('STRING_START',open,open.length);
				this.interpolateString(doc,{heredoc: true,offset: open.length,quote: quote});
				this.token('STRING_END',open,open.length,heredoc.length - open.length);
			} else {
				this.token('STRING',this.makeString(doc,quote,true),0);
			};
			
			this.moveHead(heredoc);
			return heredoc.length;
		};
		
		// Matches and consumes comments.
		Lexer.prototype.commentToken = function (){
			var match,length,comment,indent,prev;
			
			var typ = 'HERECOMMENT';
			
			if (match = INLINE_COMMENT.exec(this._chunk)) { // .match(INLINE_COMMENT)
				// console.log "match inline comment"
				length = match[0].length;
				indent = match[1];
				comment = match[2];
				
				prev = last(this._tokens);
				var pt = prev && tT(prev);
				var note = '//' + comment.substr(1);
				
				if (this._last && this._last.spaced) {
					note = ' ' + note;
					// console.log "the previous node was SPACED"
				};
				// console.log "comment {note} - indent({indent}) - {length} {comment:length}"
				
				if ((pt && pt != 'INDENT' && pt != 'TERMINATOR') || !(pt)) {
					// console.log "skip comment"
					// token 'INLINECOMMENT', comment.substr(2)
					// console.log "adding as terminator"
					this.token('TERMINATOR',note,length); // + '\n'
				} else {
					// console.log "add comment ({note})"
					if (pt == 'TERMINATOR') {
						tVs(prev,tV(prev) + note);
						// prev[1] += note
					} else if (pt == 'INDENT') {
						// console.log "adding comment to INDENT: {note}" # why not add directly here?
						this.addLinebreaks(1,note);
					} else {
						// console.log "comment here"
						// should we ever get here?
						this.token(typ,comment.substr(2),length); // are we sure?
					};
				};
				
				return length; // disable now while compiling
			};
			
			// should use exec?
			if (!(match = COMMENT.exec(this._chunk))) { return 0 };
			
			comment = match[0];
			var here = match[1];
			
			if (here) {
				this.token('HERECOMMENT',this.sanitizeHeredoc(here,{herecomment: true,indent: Array(this._indent + 1).join(' ')}),comment.length);
				this.token('TERMINATOR','\n');
			} else {
				this.token('HERECOMMENT',comment,comment.length);
				this.token('TERMINATOR','\n'); // auto? really?
			};
			
			this.moveHead(comment);
			return comment.length;
		};
		
		// Matches JavaScript interpolated directly into the source via backticks.
		Lexer.prototype.jsToken = function (){
			var match,script;
			
			if (!(this._chunk.charAt(0) == '`' && (match = JSTOKEN.exec(this._chunk)))) { return 0 };
			this.token('JS',(script = match[0]).slice(1,-1));
			return script.length;
		};
		
		// Matches regular expression literals. Lexing regular expressions is difficult
		// to distinguish from division, so we borrow some basic heuristics from
		// JavaScript and Ruby.
		Lexer.prototype.regexToken = function (){
			var ary;
			var match,length,prev;
			
			if (this._chunk.charAt(0) != '/') { return 0 };
			if (match = HEREGEX.exec(this._chunk)) {
				length = this.heregexToken(match);
				this.moveHead(match[0]);
				return length;
			};
			
			prev = last(this._tokens);
			// FIX
			if (prev && (idx$(tT(prev),(prev.spaced ? (
				NOT_REGEX
			) : (
				NOT_SPACED_REGEX
			))) >= 0)) { return 0 };
			if (!(match = REGEX.exec(this._chunk))) { return 0 };
			var ary = iter$(match);var m = ary[0],regex = ary[1],flags = ary[2];
			
			// FIXME
			// if regex[..1] is '/*'
			//	error 'regular expressions cannot begin with `*`'
			
			if (regex == '//') {
				regex = '/(?:)/';
			};
			
			this.token('REGEX',("" + regex + flags),m.length);
			return m.length;
		};
		
		// Matches multiline extended regular expressions.
		// The escaping should rather happen in AST - possibly as an additional flag?
		Lexer.prototype.heregexToken = function (match){
			var ary;
			var ary = iter$(match);var heregex = ary[0],body = ary[1],flags = ary[2];
			
			if (0 > body.indexOf('#{')) {
				
				var re = body.replace(HEREGEX_OMIT,'').replace(/\//g,'\\/');
				
				if (re.match(/^\*/)) {
					this.error('regular expressions cannot begin with `*`');
				};
				
				this.token('REGEX',("/" + (re || '(?:)') + "/" + flags),heregex.length);
				return heregex.length;
			};
			
			// use more basic regex type
			
			this.token('CONST','RegExp');
			this._tokens.push(T.token('CALL_START','(',0));
			var tokens = [];
			
			for (var i = 0, items = iter$(this.interpolateString(body,{regex: true})), len = items.length, pair; i < len; i++) {
				
				pair = items[i];
				var tok = tT(pair); // FIX
				var value = tV(pair); // FIX
				
				if (tok == 'TOKENS') {
					// FIXME what is this?
					tokens.push.apply(tokens,value);
				} else {
					if (!(value)) {
						console.log("what??");
					};
					
					if (!(value = value.replace(HEREGEX_OMIT,''))) { continue; };
					
					value = value.replace(/\\/g,'\\\\');
					tokens.push(T.token('STRING',this.makeString(value,'"',true),0)); // FIX
				};
				
				tokens.push(T.token('+','+',0)); // FIX
			};
			
			tokens.pop();
			
			// FIX
			if (!(tokens[0] && tT(tokens[0]) == 'STRING')) {
				// FIX
				this._tokens.push(T.token('STRING','""'),T.token('+','+'));
			};
			
			this._tokens.push.apply(this._tokens,tokens); // what is this?
			// FIX
			
			if (flags) {
				this._tokens.push(T.token(',',',',0));
				this._tokens.push(T.token('STRING','"' + flags + '"',0));
			};
			
			this.token(')',')',0);
			
			return heregex.length;
		};
		
		// Matches newlines, indents, and outdents, and determines which is which.
		// If we can detect that the current line is continued onto the the next line,
		// then the newline is suppressed:
		//
		//     elements
		//       .each( ... )
		//       .map( ... )
		//
		// Keeps track of the level of indentation, because a single outdent token
		// can close multiple indents, so we need to know how far in we happen to be.
		Lexer.prototype.lineToken = function (){
			var match;
			
			if (!(match = MULTI_DENT.exec(this._chunk))) { return 0 };
			
			var indent = match[0];
			var brCount = this.moveHead(indent);
			
			this._seenFor = false;
			// reset column as well?
			
			var prev = last(this._tokens,1);
			var whitespace = indent.substr(indent.lastIndexOf('\n') + 1);
			var size = whitespace.length;
			var noNewlines = this.unfinished();
			
			if ((/^\n#\s/).test(this._chunk)) {
				this.addLinebreaks(1);
				return 0;
			};
			
			if (size > 0) {
				if (!this._indentStyle) {
					this._opts.indent = this._indentStyle = whitespace;
				};
				
				var indentSize = 0;
				var offset = 0;
				
				while (true){
					var idx = whitespace.indexOf(this._indentStyle,offset);
					if (idx == offset) {
						indentSize++;
						offset += this._indentStyle.length;
					} else if (offset == whitespace.length) {
						break;
					} else {
						// workaround to report correct location
						this._loc += indent.length - whitespace.length;
						this.token('INDENT',whitespace,whitespace.length);
						return this.error('inconsistent indentation');
					};
				};
				
				size = indentSize;
			};
			
			
			if (size - this._indebt == this._indent) {
				if (noNewlines) {
					this.suppressNewlines();
				} else {
					this.newlineToken(brCount);
				};
				return indent.length;
			};
			
			if (size > this._indent) {
				if (noNewlines) {
					this._indebt = size - this._indent;
					this.suppressNewlines();
					return indent.length;
				};
				
				if (this.inTag()) {
					// console.log "indent inside tokid?!?"
					// @indebt = size - @indent
					// suppressNewlines()
					return indent.length;
				};
				
				
				var diff = size - this._indent + this._outdebt;
				this.closeDef();
				
				var immediate = last(this._tokens);
				
				if (immediate && tT(immediate) == 'TERMINATOR') {
					tTs(immediate,'INDENT');
					immediate._meta || (immediate._meta = {pre: tV(immediate),post: ''});
					
					// should rather add to meta somehow?!?
					// tVs(immediate,tV(immediate) + '%|%') # crazy
				} else {
					this.token('INDENT',"" + diff,0);
				};
				
				// console.log "indenting", prev, last(@tokens,1)
				// if prev and prev[0] == 'TERMINATOR'
				//   console.log "terminator before indent??"
				
				// check for comments as well ?
				
				this._indents.push(diff);
				this.pushEnd('OUTDENT');
				// @ends.push 'OUTDENT'
				this._outdebt = this._indebt = 0;
				this.addLinebreaks(brCount);
			} else {
				this._indebt = 0;
				this.outdentToken(this._indent - size,noNewlines,brCount);
				this.addLinebreaks(brCount - 1);
				// console.log "outdent",noNewlines,tokid()
			};
			
			this._indent = size;
			return indent.length;
		};
		
		// Record an outdent token or multiple tokens, if we happen to be moving back
		// inwards past several recorded indents.
		Lexer.prototype.outdentToken = function (moveOut,noNewlines,newlineCount){
			// here we should also take care to pop / reset the scope-body
			// or context-type for indentation 
			var dent = 0;
			while (moveOut > 0){
				var len = this._indents.length - 1;
				if (this._indents[len] == undefined) {
					moveOut = 0;
				} else if (this._indents[len] == this._outdebt) {
					moveOut -= this._outdebt;
					this._outdebt = 0;
				} else if (this._indents[len] < this._outdebt) {
					this._outdebt -= this._indents[len];
					moveOut -= this._indents[len];
				} else {
					dent = this._indents.pop() - this._outdebt;
					moveOut -= dent;
					this._outdebt = 0;
					
					if (!(noNewlines)) { this.addLinebreaks(1) };
					
					this.pair('OUTDENT');
					this.token('OUTDENT',"" + dent,0);
				};
			};
			
			if (dent) { this._outdebt -= moveOut };
			
			while (this.lastTokenValue() == ';'){
				this._tokens.pop();
			};
			
			if (!(this.lastTokenType() == 'TERMINATOR' || noNewlines)) { this.token('TERMINATOR','\n',0) };
			
			// capping scopes so they dont hang around 
			this._scopes.length = this._indents.length;
			
			var ctx = this.context();
			if (ctx == '%' || ctx == 'TAG') { this.pair(ctx) }; // really?
			this.closeDef();
			return this;
		};
		
		// Matches and consumes non-meaningful whitespace. tokid the previous token
		// as being "spaced", because there are some cases where it makes a difference.
		Lexer.prototype.whitespaceToken = function (){
			var match,nline,prev;
			if (!((match = WHITESPACE.exec(this._chunk)) || (nline = this._chunk.charAt(0) == '\n'))) { return 0 };
			prev = last(this._tokens);
			
			// FIX - why oh why?
			if (prev) {
				if (match) {
					prev.spaced = true;
					return match[0].length;
				} else {
					prev.newLine = true;
					return 0;
				};
			};
		};
		
		Lexer.prototype.addNewline = function (){
			return this.token('TERMINATOR','\n');
		};
		
		Lexer.prototype.moveHead = function (str){
			var br = count(str,'\n');
			return br;
		};
		
		
		Lexer.prototype.addLinebreaks = function (count,raw){
			var br;
			
			if (!(raw) && count == 0) { return this }; // no terminators?
			
			var prev = this._last;
			
			if (!(raw)) {
				if (count == 1) {
					br = '\n';
				} else if (count == 2) {
					br = '\n\n';
				} else if (count == 3) {
					br = '\n\n\n';
				} else {
					br = repeatString('\n',count);
				};
			};
			// FIX
			if (prev) {
				var t = prev._type; // @lastTyp
				var v = tV(prev);
				
				// we really want to add this
				if (t == 'INDENT') {
					// TODO we want to add to the indent
					// console.log "add the comment to the indent -- pre? {raw} {br}"
					
					var meta = prev._meta || (prev._meta = {pre: '',post: ''});
					meta.post += (raw || br);
					// tVs(v + (raw or br))
					return this;
				} else if (t == 'TERMINATOR') {
					// console.log "already exists terminator {br} {raw}"
					tVs(prev,v + (raw || br));
					return this;
				};
			};
			
			this.token('TERMINATOR',br,0);
			return;
		};
		
		// Generate a newline token. Consecutive newlines get merged together.
		Lexer.prototype.newlineToken = function (lines){
			// console.log "newlineToken"
			while (this.lastTokenValue() == ';'){
				console.log("pop token",this._tokens[this._tokens.length - 1]);
				this._tokens.pop();
			};
			
			this.addLinebreaks(lines);
			
			var ctx = this.context();
			// WARN now import cannot go over multiple lines
			if (ctx == 'TAG' || ctx == 'IMPORT') { this.pair(ctx) };
			this.closeDef(); // close def -- really?
			return this;
		};
		
		// Use a `\` at a line-ending to suppress the newline.
		// The slash is removed here once its job is done.
		Lexer.prototype.suppressNewlines = function (){
			if (this.value() == '\\') { this._tokens.pop() };
			return this;
		};
		
		// We treat all other single characters as a token. E.g.: `( ) , . !`
		// Multi-character operators are also literal tokens, so that Jison can assign
		// the proper order of operations. There are some symbols that we tokid specially
		// here. `;` and newlines are both treated as a `TERMINATOR`, we distinguish
		// parentheses that indicate a method call from regular parentheses, and so on.
		Lexer.prototype.literalToken = function (){
			var match,value;
			if (match = OPERATOR.exec(this._chunk)) {
				value = match[0];
				if (CODE.test(value)) this.tagParameters();
			} else {
				value = this._chunk.charAt(0);
			};
			
			var end1 = this._ends[this._ends.length - 1];
			var end2 = this._ends[this._ends.length - 2];
			
			var inTag = end1 == 'TAG_END' || end1 == 'OUTDENT' && end2 == 'TAG_END';
			
			var tokid = value;
			var prev = last(this._tokens);
			var pt = prev && tT(prev);
			var pv = prev && tV(prev);
			var length = value.length;
			
			// is this needed?
			if (value == '=' && prev) {
				
				if (pv == '||' || pv == '&&') { // in ['||', '&&']
					tTs(prev,'COMPOUND_ASSIGN');
					tVs(prev,pv + '=');
					// prev[0] = 'COMPOUND_ASSIGN'
					// prev[1] += '='
					return value.length;
				};
			};
			
			if (value == ';') {
				this._seenFor = false;
				tokid = 'TERMINATOR';
			} else if (value == '(' && inTag && pt != '=' && prev.spaced) { // FIXed
				// console.log 'spaced before ( in tokid'
				// FIXME - should rather add a special token like TAG_PARAMS_START
				this.token(',',',');
			} else if (value == '->' && inTag) {
				tokid = 'TAG_END';
				this.pair('TAG_END');
			} else if (value == '/>' && inTag) {
				tokid = 'TAG_END';
				this.pair('TAG_END');
			} else if (value == '>' && inTag) {
				tokid = 'TAG_END';
				this.pair('TAG_END');
			} else if (value == '>' && this.context() == 'DEF') {
				// console.log('picked up >!!')
				tokid = 'DEF_FRAGMENT';
				
				// elif value is 'TERMINATOR' and end1 is '%' 
				// 	closeSelector()
			} else if (value == 'TERMINATOR' && end1 == 'DEF') {
				this.closeDef();
			} else if (value == '&' && this.context() == 'DEF') {
				// console.log("okay!")
				tokid = 'BLOCK_ARG';
				// change the next identifier instead?
			} else if (value == '*' && this._chunk.charAt(1).match(/[A-Za-z\_\@\[]/) && (prev.spaced || [',','(','[','{','|','\n','\t'].indexOf(pv) >= 0)) {
				tokid = "SPLAT";
			} else if (value == '√') {
				tokid = 'SQRT';
			} else if (value == 'ƒ') {
				tokid = 'FUNC';
			} else if (idx$(value,MATH) >= 0) {
				tokid = 'MATH';
			} else if (idx$(value,COMPARE) >= 0) {
				tokid = 'COMPARE';
			} else if (idx$(value,COMPOUND_ASSIGN) >= 0) {
				tokid = 'COMPOUND_ASSIGN';
			} else if (idx$(value,UNARY) >= 0) {
				tokid = 'UNARY';
			} else if (idx$(value,SHIFT) >= 0) {
				tokid = 'SHIFT';
			} else if (idx$(value,LOGIC) >= 0) {
				tokid = 'LOGIC'; // or value is '?' and prev?:spaced 
			} else if (prev && !prev.spaced) {
				// need a better way to do these
				if (value == '(' && end1 == '%') {
					tokid = 'TAG_ATTRS_START';
				} else if (value == '(' && idx$(pt,CALLABLE) >= 0) {
					// not using this ???
					// prev[0] = 'FUNC_EXIST' if prev[0] is '?'
					tokid = 'CALL_START';
				} else if (value == '[' && idx$(pt,INDEXABLE) >= 0) {
					tokid = 'INDEX_START';
					if (pt == '?') { tTs(prev,'INDEX_SOAK') };
					// prev[0] = 'INDEX_SOAK' if prev[0] == '?'
				};
			};
			
			switch (value) {
				case '(':
				case '{':
				case '[':
					this.pushEnd(INVERSES[value]);break;
				
				case ')':
				case '}':
				case ']':
					this.pair(value);break;
			
			};
			
			// hacky rule to try to allow for tuple-assignments in blocks
			// if value is ',' and prev[0] is 'IDENTIFIER' and @tokens[@tokens:length - 2][0] in ['TERMINATOR','INDENT']
			//   # token "TUPLE", "tuple" # should rather insert it somewhere else, no?
			//   console.log("found comma")
			
			this.token(tokid,value,value.length);
			return value.length;
		};
		
		// Token Manipulators
		// ------------------
		
		// Sanitize a heredoc or herecomment by
		// erasing all external indentation on the left-hand side.
		Lexer.prototype.sanitizeHeredoc = function (doc,options){
			var match;
			var indent = options.indent;
			var herecomment = options.herecomment;
			
			if (herecomment) {
				if (HEREDOC_ILLEGAL.test(doc)) {
					this.error("block comment cannot contain '*/' starting");
				};
				if (doc.indexOf('\n') <= 0) { return doc };
			} else {
				var length_;while (match = HEREDOC_INDENT.exec(doc)){
					var attempt = match[1];
					if (indent == null || 0 < (length_ = attempt.length) && length_ < indent.length) {
						indent = attempt;
					};
				};
			};
			
			if (indent) { doc = doc.replace(RegExp(("\\n" + indent),"g"),'\n') };
			if (!(herecomment)) { doc = doc.replace(/^\n/,'') };
			return doc;
		};
		
		// A source of ambiguity in our grammar used to be parameter lists in function
		// definitions versus argument lists in function calls. Walk backwards, tokidging
		// parameters specially in order to make things easier for the parser.
		Lexer.prototype.tagParameters = function (){
			var tok;
			if (this.lastTokenType() != ')') { return this };
			var stack = [];
			var tokens = this._tokens;
			var i = tokens.length;
			
			tTs(tokens[--i],'PARAM_END');
			
			while (tok = tokens[--i]){
				var t = tT(tok);
				switch (t) {
					case ')':
						stack.push(tok);
						break;
					
					case '(':
					case 'CALL_START':
						if (stack.length) {
							stack.pop();
						} else if (t == '(') {
							tTs(tok,'PARAM_START');
							return this;
						} else {
							return this;
						};
						break;
				
				};
			};
			
			return this;
		};
		
		// Close up all remaining open blocks at the end of the file.
		Lexer.prototype.closeIndentation = function (){
			// ctx = context
			// pair(ctx) if ctx in ['%','DEF']
			this.closeDef();
			this.closeSelector();
			return this.outdentToken(this._indent,false,0);
		};
		
		// Matches a balanced group such as a single or double-quoted string. Pass in
		// a series of delimiters, all of which must be nested correctly within the
		// contents of the string. This method allows us to have strings within
		// interpolations within strings, ad infinitum.
		Lexer.prototype.balancedString = function (str,end){
			var match,letter,prev;
			
			// console.log 'balancing string!', str, end
			var stack = [end];
			var i = 0;
			
			// could it not happen here?
			while (i < (str.length - 1)){
				i++;
				letter = str.charAt(i);
				switch (letter) {
					case '\\':
						i++;
						continue;
						break;
					
					case end:
						stack.pop();
						if (!stack.length) {
							var v = str.slice(0,i + 1);
							return v;
						};
						end = stack[stack.length - 1];
						continue;
						break;
				
				};
				
				if (end == '}' && (letter == '"' || letter == "'")) {
					stack.push(end = letter);
				} else if (end == '}' && letter == '/' && (match = (HEREGEX.exec(str.slice(i)) || REGEX.exec(str.slice(i))))) {
					i += match[0].length - 1;
				} else if (end == '}' && letter == '{') {
					stack.push(end = '}');
				} else if (end == '"' && letter == '{') {
					stack.push(end = '}');
				};
				prev = letter;
			};
			
			if (!this._opts.silent) { return this.error(("missing " + (stack.pop()) + ", starting")) };
		};
		
		// Expand variables and expressions inside double-quoted strings using
		// Ruby-like notation for substitution of arbitrary expressions.
		//
		//     "Hello #{name.capitalize()}."
		//
		// If it encounters an interpolation, this method will recursively create a
		// new Lexer, tokenize the interpolated contents, and merge them into the
		// token stream.
		Lexer.prototype.interpolateString = function (str,options){
			// console.log "interpolate string"
			if(options === undefined) options = {};
			var heredoc = options.heredoc;
			var quote = options.quote;
			var regex = options.regex;
			var prefix = options.prefix;
			
			var startLoc = this._loc;
			var tokens = [];
			var pi = 0;
			var i = -1;
			var locOffset = options.offset || 1;
			var strlen = str.length;
			var letter;
			var expr;
			
			var isInterpolated = false;
			// out of bounds
			while (letter = str.charAt(i += 1)){
				if (letter == '\\') {
					i += 1;
					continue;
				};
				
				if (!(str.charAt(i) == '{' && (expr = this.balancedString(str.slice(i),'}')))) {
					continue;
				};
				
				isInterpolated = true;
				
				// these have no real sense of location or anything?
				if (pi < i) {
					// this is the prefix-string - before any item
					var tok = new Token('NEOSTRING',this.escapeStr(str.slice(pi,i),heredoc,quote),this._loc + pi + locOffset,i - pi);
					// tok.@loc = @loc + pi
					// tok.@len = i - pi + 2
					tokens.push(tok);
				};
				
				tokens.push(new Token('{{','{',this._loc + i + locOffset,1));
				
				var inner = expr.slice(1,-1);
				// console.log 'inner is',inner
				// remove leading spaces 
				// need to keep track of how much whitespace we dropped from the start
				inner = inner.replace(/^[^\n\S]+/,'');
				
				if (inner.length) {
					// we need to remember the loc we start at
					// console.log('interpolate from loc',@loc,i)
					// really? why not just add to the stack??
					// what about the added 
					// should share with the selector no?
					// console.log "tokenize inner parts of string",inner
					var spaces = 0;
					var offset = this._loc + i + (expr.length - inner.length) - 1;
					// why create a whole new lexer? Should rather reuse one
					// much better to simply move into interpolation mode where
					// we continue parsing until we meet unpaired }
					var nested = new Lexer().tokenize(inner,{inline: true,rewrite: false,loc: offset + locOffset});
					// console.log nested.pop
					
					if (nested[0] && tT(nested[0]) == 'TERMINATOR') {
						nested.shift();
					};
					
					if (nested.length) {
						tokens.push.apply(tokens,nested); // T.token('TOKENS',nested,0)
					};
				};
				
				// should rather add the amount by which our lexer has moved?
				i += expr.length - 1;
				tokens.push(new Token('}}','}',this._loc + i + locOffset,1));
				pi = i + 1;
			};
			
			// adding the last part of the string here
			if (i >= pi && pi < str.length) {
				// set the length as well - or?
				// the string after?
				// console.log 'push neostring'
				tokens.push(new Token('NEOSTRING',this.escapeStr(str.slice(pi),heredoc,quote),this._loc + pi + locOffset,str.length - pi));
			};
			
			// console.log tokens:length
			if (regex) { return tokens };
			
			if (!tokens.length) { return this.token('NEOSTRING','""') };
			
			for (var j = 0, len = tokens.length; j < len; j++) {
				this._tokens.push(tokens[j]);
			};
			
			return tokens;
		};
		
		// Matches a balanced group such as a single or double-quoted string. Pass in
		// a series of delimiters, all of which must be nested correctly within the
		// contents of the string. This method allows us to have strings within
		// interpolations within strings, ad infinitum.
		Lexer.prototype.balancedSelector = function (str,end){
			var prev;
			var letter;
			var stack = [end];
			// FIXME
			for (var len = str.length, i = 1; i < len; i++) {
				switch (letter = str.charAt(i)) {
					case '\\':
						i++;
						continue;
						break;
					
					case end:
						stack.pop();
						if (!stack.length) {
							return str.slice(0,i + 1);
						};
						
						end = stack[stack.length - 1];
						continue;
						break;
				
				};
				if (end == '}' && letter == [')']) {
					stack.push(end = letter);
				} else if (end == '}' && letter == '{') {
					stack.push(end = '}');
				} else if (end == ')' && letter == '{') {
					stack.push(end = '}');
				};
				prev = letter; // what, why?
			};
			
			return this.error(("missing " + (stack.pop()) + ", starting"));
		};
		
		// Pairs up a closing token, ensuring that all listed pairs of tokens are
		// correctly balanced throughout the course of the token stream.
		Lexer.prototype.pair = function (tok){
			var wanted = last(this._ends);
			if (tok != wanted) {
				if ('OUTDENT' != wanted) { this.error(("unmatched " + tok)) };
				var size = last(this._indents);
				this._indent -= size;
				this.outdentToken(size,true,0);
				return this.pair(tok);
			};
			return this.popEnd();
		};
		
		
		// Helpers
		// -------
		
		// Add a token to the results, taking note of the line number.
		Lexer.prototype.token = function (id,value,len,offset){
			this._lastTyp = id;
			this._lastVal = value;
			var tok = this._last = new Token(id,value,this._loc + (offset || 0),len || 0);
			this._tokens.push(tok);
			return;
		};
		
		Lexer.prototype.lastTokenType = function (){
			var token = this._tokens[this._tokens.length - 1];
			return token ? (tT(token)) : ('NONE');
		};
		
		Lexer.prototype.lastTokenValue = function (){
			var token = this._tokens[this._tokens.length - 1];
			return token ? (token._value) : ('');
		};
		
		// Peek at a tokid in the current token stream.
		Lexer.prototype.tokid = function (index,val){
			var tok;
			if (tok = last(this._tokens,index)) {
				if (val) { tTs(tok,val) };
				return tT(tok);
				// tok.@type = tokid if tokid # why?
				// tok.@type
			} else {
				return null;
			};
		};
		
		// Peek at a value in the current token stream.
		Lexer.prototype.value = function (index,val){
			var tok;
			if (tok = last(this._tokens,index)) {
				if (val) { tVs(tok,val) };
				return tV(tok);
				// tok.@value = val if val # why?
				// tok.@value
			} else {
				return null;
			};
		};
		
		
		// Are we in the midst of an unfinished expression?
		Lexer.prototype.unfinished = function (){
			if (LINE_CONTINUER.test(this._chunk)) { return true };
			return UNFINISHED.indexOf(this._lastTyp) >= 0;
		};
		
		// var tokens = ['\\','.', '?.', 'UNARY', 'MATH', '+', '-', 'SHIFT', 'RELATION', 'COMPARE', 'LOGIC', 'COMPOUND_ASSIGN', 'THROW', 'EXTENDS']
		
		// Converts newlines for string literals.
		Lexer.prototype.escapeLines = function (str,heredoc){
			return str.replace(MULTILINER,(heredoc ? ('\\n') : ('')));
		};
		
		// Constructs a string token by escaping quotes and newlines.
		Lexer.prototype.makeString = function (body,quote,heredoc){
			if (!(body)) { return quote + quote };
			body = body.replace(/\\([\s\S])/g,function(match,contents) {
				return (contents == '\n' || contents == quote) ? (contents) : (match);
			});
			// Does not work now
			body = body.replace(RegExp(("" + quote),"g"),'\\$&');
			return quote + this.escapeLines(body,heredoc) + quote;
		};
		
		// Throws a syntax error on the current `@line`.
		Lexer.prototype.error = function (message,len){
			if ((typeof this._line=='number'||this._line instanceof Number)) { message = ("" + message + " on line " + (this._line)) };
			
			if (len) {
				message += (" [" + (this._loc) + ":" + (this._loc + len) + "]");
			};
			
			var err = new SyntaxError(message);
			err.line = this._line;
			// err:columnNumber
			err = new ERR.ImbaParseError(err,{tokens: this._tokens,pos: this._tokens.length});
			err.region = [this._loc,this._loc + (len || 0)];
			throw err;
		};
		return Lexer;
	
	})()

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function idx$(a,b){
			return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
		};
		
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		var INVERSES, LINEBREAKS;
		
		// The Imba language has a good deal of optional syntax, implicit syntax,
		// and shorthand syntax. This can greatly complicate a grammar and bloat
		// the resulting parse table. Instead of making the parser handle it all, we take
		// a series of passes over the token stream, using this **Rewriter** to convert
		// shorthand into the unambiguous long form, add implicit indentation and
		// parentheses, and generally clean things up.
		
		var T = __webpack_require__(1);
		var Token = T.Token;
		
		// Based on the original rewriter.coffee from CoffeeScript
		function Rewriter(){ };
		
		exports.Rewriter = Rewriter; // export class 
		Rewriter.prototype.tokens = function (){
			return this._tokens;
		};
		
		// Helpful snippet for debugging:
		//     console.log (t[0] + '/' + t[1] for t in @tokens).join ' '
		// Rewrite the token stream in multiple passes, one logical filter at
		// a time. This could certainly be changed into a single pass through the
		// stream, with a big ol' efficient switch, but it's much nicer to work with
		// like this. The order of these passes matters -- indentation must be
		// corrected before implicit parentheses can be wrapped around blocks of code.
		Rewriter.prototype.rewrite = function (tokens,opts){
			var token;
			if(opts === undefined) opts = {};
			this._tokens = tokens;
			this._options = opts;
			
			// console.log "tokens in: " + tokens:length
			if (opts.profile) { console.time("tokenize:rewrite") };
			
			var i = 0;
			// flag empty methods
			while (token = tokens[i]){
				var next = tokens[i + 1];
				if (token._type == 'DEF_BODY' && next && next._type == 'TERMINATOR') {
					token._type = 'DEF_EMPTY';
				};
				i++;
			};
			
			this.step("ensureFirstLine");
			this.step("removeLeadingNewlines");
			this.step("removeMidExpressionNewlines");
			this.step("tagDefArguments");
			this.step("closeOpenCalls");
			this.step("closeOpenIndexes");
			this.step("closeOpenTags");
			this.step("closeOpenTagAttrLists");
			this.step("addImplicitIndentation");
			this.step("tagPostfixConditionals");
			this.step("addImplicitBraces");
			this.step("addImplicitParentheses");
			
			if (opts.profile) { console.timeEnd("tokenize:rewrite") };
			// console.log "tokens out: " + @tokens:length
			return this._tokens;
		};
		
		Rewriter.prototype.step = function (fn){
			if (this._options.profile) {
				console.log(("---- starting " + fn + " ---- "));
				console.time(fn);
			};
			
			this[fn]();
			
			if (this._options.profile) {
				console.timeEnd(fn);
				console.log("\n\n");
			};
			return;
		};
		
		// Rewrite the token stream, looking one token ahead and behind.
		// Allow the return value of the block to tell us how many tokens to move
		// forwards (or backwards) in the stream, to make sure we don't miss anything
		// as tokens are inserted and removed, and the stream changes length under
		// our feet.
		Rewriter.prototype.scanTokens = function (block){
			var token;
			var tokens = this._tokens;
			
			var i = 0;
			while (token = tokens[i]){
				i += block.call(this,token,i,tokens);
			};
			
			return true;
		};
		
		Rewriter.prototype.detectEnd = function (i,condition,action){
			var tokens = this._tokens;
			var levels = 0;
			var starts = [];
			var token;
			var t,v;
			
			while (token = tokens[i]){
				if (levels == 0 && condition.call(this,token,i,starts)) {
					return action.call(this,token,i);
				};
				if (!(token) || levels < 0) {
					return action.call(this,token,i - 1);
				};
				
				t = T.typ(token);
				
				if (EXPRESSION_START.indexOf(t) >= 0) {
					if (levels == 0) { starts.push(i) };
					levels += 1;
				} else if (EXPRESSION_END.indexOf(t) >= 0) {
					levels -= 1;
				};
				i += 1;
			};
			return i - 1;
		};
		
		Rewriter.prototype.ensureFirstLine = function (){
			var tok = this._tokens[0];
			
			if (T.typ(tok) == 'TERMINATOR') {
				// console.log "adding bodystart"
				this._tokens = [T.token('BODYSTART','BODYSTART')].concat(this._tokens);
				// T.setTyp(tok,'HEADER')
			};
			return;
		};
		
		// Leading newlines would introduce an ambiguity in the grammar, so we
		// dispatch them here.
		Rewriter.prototype.removeLeadingNewlines = function (){
			var at = 0;
			
			for (var i = 0, ary = iter$(this._tokens), len = ary.length; i < len; i++) {
				if (T.typ(ary[i]) != 'TERMINATOR') {
					at = i;break;
				};
			};
			
			if (at) { this._tokens.splice(0,at) };
			
			return;
		};
		
		// Some blocks occur in the middle of expressions -- when we're expecting
		// this, remove their trailing newlines.
		Rewriter.prototype.removeMidExpressionNewlines = function (){
			var self = this;
			return self.scanTokens(function(token,i,tokens) { // do |token,i,tokens|
				var next = self.tokenType(i + 1);
				
				if (!(T.typ(token) == 'TERMINATOR' && EXPRESSION_CLOSE.indexOf(next) >= 0)) { return 1 };
				if (next == 'OUTDENT') { return 1 };
				tokens.splice(i,1);
				return 0;
			});
		};
		
		
		Rewriter.prototype.tagDefArguments = function (){
			return true;
		};
		
		// The lexer has tagged the opening parenthesis of a method call. Match it with
		// its paired close. We have the mis-nested outdent case included here for
		// calls that close on the same line, just before their outdent.
		Rewriter.prototype.closeOpenCalls = function (){
			var self = this;
			var condition = function(token,i) {
				var t = T.typ(token);
				return (t == ')' || t == 'CALL_END') || t == 'OUTDENT' && self.tokenType(i - 1) == ')';
			};
			
			var action = function(token,i) {
				var t = T.typ(token);
				var tok = self._tokens[t == 'OUTDENT' ? (i - 1) : (i)];
				return T.setTyp(tok,'CALL_END');
			};
			
			return self.scanTokens(function(token,i) {
				if (T.typ(token) == 'CALL_START') { self.detectEnd(i + 1,condition,action) };
				return 1;
			});
		};
		
		// The lexer has tagged the opening parenthesis of an indexing operation call.
		// Match it with its paired close.
		Rewriter.prototype.closeOpenIndexes = function (){
			var self = this;
			var condition = function(token,i) { return idx$(T.typ(token),[']','INDEX_END']) >= 0; };
			var action = function(token,i) { return T.setTyp(token,'INDEX_END'); };
			
			return self.scanTokens(function(token,i) {
				if (T.typ(token) == 'INDEX_START') { self.detectEnd(i + 1,condition,action) };
				return 1;
			});
		};
		
		
		Rewriter.prototype.closeOpenTagAttrLists = function (){
			var self = this;
			var condition = function(token,i) { return idx$(T.typ(token),[')','TAG_ATTRS_END']) >= 0; };
			var action = function(token,i) { return T.setTyp(token,'TAG_ATTRS_END'); }; // 'TAG_ATTRS_END'
			
			return self.scanTokens(function(token,i) {
				if (T.typ(token) == 'TAG_ATTRS_START') { self.detectEnd(i + 1,condition,action) };
				return 1;
			});
		};
		
		// The lexer has tagged the opening parenthesis of an indexing operation call.
		// Match it with its paired close. Should be done in lexer directly
		Rewriter.prototype.closeOpenTags = function (){
			var self = this;
			var condition = function(token,i) { return idx$(T.typ(token),['>','TAG_END']) >= 0; };
			var action = function(token,i) { return T.setTyp(token,'TAG_END'); }; // token[0] = 'TAG_END'
			
			return self.scanTokens(function(token,i) {
				if (T.typ(token) == 'TAG_START') { self.detectEnd(i + 1,condition,action) };
				return 1;
			});
		};
		
		Rewriter.prototype.addImplicitCommas = function (){
			return;
		};
		
		Rewriter.prototype.addImplicitBlockCalls = function (){
			var token;
			var i = 1;
			var tokens = this._tokens;
			
			while (token = tokens[i]){
				var t = token._type;
				var v = token._value;
				// hmm
				if (t == 'DO' && (v == 'INDEX_END' || v == 'IDENTIFIER' || v == 'NEW')) {
					tokens.splice(i + 1,0,T.token('CALL_END',')'));
					tokens.splice(i + 1,0,T.token('CALL_START','('));
					i++;
				};
				i++;
			};
			
			return;
		};
		
		// Object literals may be written with implicit braces, for simple cases.
		// Insert the missing braces here, so that the parser doesn't have to.
		Rewriter.prototype.addImplicitBraces = function (){
			var self = this;
			var stack = [];
			var start = null;
			var startIndent = 0;
			var startIdx = null;
			
			var noBraceTag = ['CLASS','IF','UNLESS','TAG','WHILE','FOR','UNTIL','CATCH','FINALLY','MODULE','LEADING_WHEN'];
			var noBraceContext = ['IF','TERNARY','FOR'];
			
			var noBrace = false;
			
			var scope = function() {
				return stack[stack.length - 1] || [];
			};
			
			var action = function(token,i) {
				return self._tokens.splice(i,0,T.RBRACKET);
			};
			
			var open = function(token,i) {
				return self._tokens.splice(i,0,T.LBRACKET);
			};
			
			var close = function(token,i) {
				return self._tokens.splice(i,0,T.RBRACKET);
			};
			
			var stackToken = function(a,b) {
				return [a,b];
			};
			
			return self.scanTokens(function(token,i,tokens) {
				var type = T.typ(token);
				var v = T.val(token);
				var ctx = stack[stack.length - 1] || [];
				var idx;
				
				if (noBraceContext.indexOf(type) >= 0) {
					// console.log "found noBraceTag {type}"
					stack.push(stackToken(type,i));
					return 1;
				};
				
				if (v == '?') {
					// console.log('TERNARY OPERATOR!')
					stack.push(stackToken('TERNARY',i));
					return 1;
				};
				
				// no need to test for this here as well as in
				if (EXPRESSION_START.indexOf(type) >= 0) {
					if (type == 'INDENT' && noBraceContext.indexOf(ctx[0]) >= 0) {
						stack.pop();
					};
					
					// console.log('expression start',type,ctx[0])
					if (type == 'INDENT' && self.tokenType(i - 1) == '{') {
						// stack ?!? no token
						stack.push(stackToken('{',i)); // should not autogenerate another?
					} else {
						stack.push(stackToken(type,i));
					};
					return 1;
				};
				
				if (EXPRESSION_END.indexOf(type) >= 0) {
					// console.log "EXPRESSION_END at {type} - stack is {ctx[0]}"
					if (ctx[0] == 'TERNARY') { // FIX?
						stack.pop();
					};
					
					start = stack.pop();
					if (!(start)) {
						console.log("NO STACK!!");
					};
					start[2] = i;
					
					// seems like the stack should use tokens, no?)
					if (start[0] == '{' && start.generated) { //  # type != '}' # and start:generated
						close(token,i);
						return 1;
					};
					
					return 1;
				};
				
				// is this correct? same for if/class etc?
				if (ctx[0] == 'TERNARY' && (type == 'TERMINATOR' || type == 'OUTDENT')) {
					stack.pop();
					return 1;
				};
				
				if (noBraceContext.indexOf(ctx[0]) >= 0 && type == 'INDENT') {
					console.log("popping noBraceContext");
					stack.pop();
					return 1;
				};
				
				
				if (type == ',') {
					// automatically add an ending here if inside:generated scope?
					// it is important that this is:generated(!)
					if (ctx[0] == '{' && ctx.generated) {
						tokens.splice(i,0,T.RBRACKET);
						stack.pop();
						return 2;
					} else {
						return 1;
					};
					true;
				};
				
				// found a type
				if (type == ':' && ctx[0] != '{' && ctx[0] != 'TERNARY' && (noBraceContext.indexOf(ctx[0]) == -1)) {
					// could just check if the end was right before this?
					
					if (start && start[2] == i - 1) {
						// console.log('this expression was just ending before colon!')
						idx = start[1] - 1; // these are the stackTokens
					} else {
						// console.log "rewrite here? #{i}"
						idx = i - 2; // if start then start[1] - 1 else i - 2
						// idx = idx - 1 if tokenType(idx) is 'TERMINATOR'
					};
					
					while (self.tokenType(idx - 1) == 'HERECOMMENT'){
						idx -= 2;
					};
					
					var t0 = tokens[idx - 1];
					
					if (t0 && T.typ(t0) == '}' && t0.generated) {
						tokens.splice(idx - 1,1);
						var s = stackToken('{');
						s.generated = true;
						stack.push(s);
						return 0;
					} else if (t0 && T.typ(t0) == ',' && self.tokenType(idx - 2) == '}') {
						tokens.splice(idx - 2,1);
						s = stackToken('{');
						s.generated = true;
						stack.push(s);
						return 0;
					} else {
						s = stackToken('{');
						s.generated = true;
						stack.push(s);
						open(token,idx + 1);
						return 2;
					};
				};
				
				// we probably need to run through autocall first?!
				
				if (type == 'DO') { // and ctx:generated
					var prev = T.typ(tokens[i - 1]); // [0]
					if (['NUMBER','STRING','REGEX','SYMBOL',']','}',')','STRING_END'].indexOf(prev) >= 0) {
						
						var tok = T.token(',',',');
						tok.generated = true;
						tokens.splice(i,0,tok);
						
						if (ctx.generated) {
							close(token,i);
							stack.pop();
							return 2;
						};
					};
				};
				
				if ((type == 'TERMINATOR' || type == 'OUTDENT' || type == 'DEF_BODY') && ctx.generated) {
					close(token,i);
					stack.pop();
					return 2;
				};
				
				return 1;
			});
		};
		
		// Methods may be optionally called without parentheses, for simple cases.
		// Insert the implicit parentheses here, so that the parser doesn't have to
		// deal with them.
		// Practically everything will now be callable this way (every identifier)
		Rewriter.prototype.addImplicitParentheses = function (){
			
			var self = this, token;
			var noCallTag = ['CLASS','IF','UNLESS','TAG','WHILE','FOR','UNTIL','CATCH','FINALLY','MODULE','LEADING_WHEN'];
			
			var action = function(token,i) {
				return self._tokens.splice(i,0,T.token('CALL_END',')'));
			};
			
			// console.log "adding implicit parenthesis" # ,self:scanTokens
			var tokens = self._tokens;
			
			var noCall = false;
			var seenFor = false;
			var endCallAtTerminator = false;
			
			var i = 0;
			while (token = tokens[i]){
				
				// to handle cases like:
				// if a(do yes).test
				// 	yes
				// we need to keep a stack for balanced pairs
				// until then you must explicitly end the call like
				// if a(do yes).test()
				// 	yes
				
				var type = token._type;
				
				var prev = tokens[i - 1];
				var current = tokens[i];
				var next = tokens[i + 1];
				
				var pt = prev && prev._type;
				var nt = next && next._type;
				
				// if pt == 'WHEN'
				// Never make these tags implicitly call
				// should we not just remove these from IMPLICIT_FUNC?
				if ((pt == ')' || pt == ']') && type == 'INDENT') {
					noCall = true;
				};
				
				if (noCallTag.indexOf(pt) >= 0) {
					// console.log("seen nocall tag {pt} ({pt} {type} {nt})")
					endCallAtTerminator = true;
					noCall = true;
					if (pt == 'FOR') { seenFor = true };
				};
				
				
				var callObject = false;
				var callIndent = false;
				
				// [prev, current, next] = tokens[i - 1 .. i + 1]
				
				// check for comments
				// console.log "detect end??"
				if (!(noCall) && type == 'INDENT' && next) {
					var prevImpFunc = pt && IMPLICIT_FUNC.indexOf(pt) >= 0;
					var nextImpCall = nt && IMPLICIT_CALL.indexOf(nt) >= 0;
					callObject = ((next.generated && nt == '{') || nextImpCall) && prevImpFunc;
					callIndent = nextImpCall && prevImpFunc;
				};
				
				var seenSingle = false;
				var seenControl = false;
				// Hmm ?
				
				// this is not correct if this is inside a block,no?
				if ((type == 'TERMINATOR' || type == 'OUTDENT' || type == 'INDENT')) {
					endCallAtTerminator = false;
					noCall = false;
				};
				
				if (type == '?' && prev && !prev.spaced) { token.call = true };
				
				// where does fromThem come from?
				if (token.fromThen) {
					i += 1;continue;
				};
				// here we deal with :spaced and :newLine
				if (!(callObject || callIndent || (prev && prev.spaced) && (prev.call || IMPLICIT_FUNC.indexOf(pt) >= 0) && (IMPLICIT_CALL.indexOf(type) >= 0 || !(token.spaced || token.newLine) && IMPLICIT_UNSPACED_CALL.indexOf(type) >= 0))) {
					i += 1;continue;
				};
				
				
				tokens.splice(i,0,T.token('CALL_START','('));
				// console.log "added ( {prev}"
				var cond = function(token,i) {
					var type = T.typ(token);
					if (!(seenSingle) && token.fromThen) { return true };
					var ifelse = type == 'IF' || type == 'UNLESS' || type == 'ELSE';
					if (ifelse || type == 'CATCH') { seenSingle = true };
					if (ifelse || type == 'SWITCH' || type == 'TRY') { seenControl = true };
					var prev = self.tokenType(i - 1);
					
					if ((type == '.' || type == '?.' || type == '::') && prev == 'OUTDENT') { return true };
					if (endCallAtTerminator && (type == 'INDENT' || type == 'TERMINATOR')) { return true };
					if ((type == 'WHEN' || type == 'BY') && !(seenFor)) {
						// console.log "dont close implicit call outside for"
						return false;
					};
					
					var post = tokens[i + 1];
					var postTyp = post && T.typ(post);
					// WTF
					return !token.generated && prev != ',' && (IMPLICIT_END.indexOf(type) >= 0 || (type == 'INDENT' && !(seenControl)) || (type == 'DOS' && prev != '=')) && (type != 'INDENT' || (self.tokenType(i - 2) != 'CLASS' && IMPLICIT_BLOCK.indexOf(prev) == -1 && !(post && ((post.generated && postTyp == '{') || IMPLICIT_CALL.indexOf(postTyp) >= 0))));
				};
				
				// The action for detecting when the call should end
				// console.log "detect end??"
				self.detectEnd(i + 1,cond,action);
				if (T.typ(prev) == '?') { T.setTyp(prev,'FUNC_EXIST') };
				i += 2;
				// need to reset after a match
				endCallAtTerminator = false;
				noCall = false;
				seenFor = false;
			};
			
			
			return;
		};
		
		// Because our grammar is LALR(1), it can't handle some single-line
		// expressions that lack ending delimiters. The **Rewriter** adds the implicit
		// blocks, so it doesn't need to. ')' can close a single-line block,
		// but we need to make sure it's balanced.
		Rewriter.prototype.addImplicitIndentation = function (){
			
			
			var self = this, token;
			var i = 0;
			var tokens = self._tokens;
			while (token = tokens[i]){
				var type = T.typ(token);
				var next = self.tokenType(i + 1);
				
				// why are we removing terminators after then? should be able to handle
				if (type == 'TERMINATOR' && next == 'THEN') {
					tokens.splice(i,1);
					continue;
				};
				
				if (type == 'CATCH' && idx$(self.tokenType(i + 2),['OUTDENT','TERMINATOR','FINALLY']) >= 0) {
					tokens.splice.apply(tokens,[].concat([i + 2,0], [].slice.call(self.indentation(token))));
					i += 4;continue;
				};
				
				if (SINGLE_LINERS.indexOf(type) >= 0 && (next != 'INDENT' && next != 'BLOCK_PARAM_START') && !(type == 'ELSE' && next == 'IF') && type != 'ELIF') {
					
					var starter = type;
					
					var indent = T.token('INDENT','2');
					var outdent = T.OUTDENT;
					// var indent, outdent = indentation(token)
					if (starter == 'THEN') { indent.fromThen = true }; // setting special values for these -- cannot really reuse?
					indent.generated = true;
					// outdent:generated = true
					tokens.splice(i + 1,0,indent);
					
					var condition = function(token,i) {
						var t = T.typ(token);
						return T.val(token) != ';' && SINGLE_CLOSERS.indexOf(t) >= 0 && !(t == 'ELSE' && starter != 'IF' && starter != 'THEN');
					};
					
					var action = function(token,i) {
						var idx = self.tokenType(i - 1) == ',' ? (i - 1) : (i);
						return tokens.splice(idx,0,outdent);
					};
					
					self.detectEnd(i + 2,condition,action);
					if (type == 'THEN') { tokens.splice(i,1) };
				};
				
				i++;
			};
			
			return;
		};
		
		// Tag postfix conditionals as such, so that we can parse them with a
		// different precedence.
		Rewriter.prototype.tagPostfixConditionals = function (){
			var self = this;
			var condition = function(token,i) { return idx$(T.typ(token),['TERMINATOR','INDENT']) >= 0; };
			
			return self.scanTokens(function(token,i) {
				var typ = T.typ(token);
				if (!(typ == 'IF' || typ == 'FOR')) { return 1 };
				var original = token;
				self.detectEnd(i + 1,condition,function(token,i) {
					if (T.typ(token) != 'INDENT') { return T.setTyp(original,'POST_' + T.typ(original)) };
				});
				return 1;
			});
		};
		
		// Generate the indentation tokens, based on another token on the same line.
		Rewriter.prototype.indentation = function (token){
			return [T.token('INDENT','2'),T.token('OUTDENT','2')];
		};
		
		// Look up a type by token index.
		Rewriter.prototype.type = function (i){
			// if i < 0 then return null
			var tok = this._tokens[i];
			return tok && T.typ(tok);
			// if tok then tok[0] else null
		};
		
		Rewriter.prototype.tokenType = function (i){
			var tok = this._tokens[i];
			return tok && T.typ(tok);
			// return tok and tok[0]
		};
		
		// Constants
		// ---------
		
		// List of the token pairs that must be balanced.
		var BALANCED_PAIRS = [
			['(',')'],
			['[',']'],
			['{','}'],
			['{{','}}'],
			['INDENT','OUTDENT'],
			['CALL_START','CALL_END'],
			['PARAM_START','PARAM_END'],
			['INDEX_START','INDEX_END'],
			['TAG_START','TAG_END'],
			['TAG_PARAM_START','TAG_PARAM_END'],
			['TAG_ATTRS_START','TAG_ATTRS_END'],
			['BLOCK_PARAM_START','BLOCK_PARAM_END']
		];
		
		// The inverse mappings of `BALANCED_PAIRS` we're trying to fix up, so we can
		// look things up from either end.
		module.exports.INVERSES = INVERSES = {};
		
		// The tokens that signal the start/end of a balanced pair.
		// var EXPRESSION_START = []
		// var EXPRESSION_END   = []
		
		for (var i = 0, ary = iter$(BALANCED_PAIRS), len = ary.length, pair; i < len; i++) {
			pair = ary[i];
			var left = pair[0];
			var rite = pair[1];
			INVERSES[rite] = left;
			INVERSES[left] = rite;
		};
		
		var EXPRESSION_START = ['(','[','{','INDENT','CALL_START','PARAM_START','INDEX_START','TAG_PARAM_START','BLOCK_PARAM_START','STRING_START','{{','TAG_START'];
		var EXPRESSION_END = [')',']','}','OUTDENT','CALL_END','PARAM_END','INDEX_END','TAG_PARAM_END','BLOCK_PARAM_END','STRING_END','}}','TAG_END'];
		
		var IDENTIFIERS = ['IDENTIFIER','GVAR','IVAR','CVAR','CONST','ARGVAR'];
		
		// Tokens that indicate the close of a clause of an expression.
		var EXPRESSION_CLOSE = ['CATCH','WHEN','ELSE','FINALLY'].concat(EXPRESSION_END);
		
		// Tokens that, if followed by an `IMPLICIT_CALL`, indicate a function invocation.
		var IMPLICIT_FUNC = ['IDENTIFIER','SUPER','@','THIS','SELF','EVENT','TRIGGER','TAG_END','IVAR',
		'GVAR','CONST','ARGVAR','NEW','BREAK','CONTINUE','RETURN'];
		
		// If preceded by an `IMPLICIT_FUNC`, indicates a function invocation.
		var IMPLICIT_CALL = [
			'SELECTOR','IDENTIFIER','NUMBER','STRING','SYMBOL','JS','REGEX','NEW','PARAM_START','CLASS',
			'IF','UNLESS','TRY','SWITCH','THIS','BOOL','TRUE','FALSE','NULL','UNDEFINED','UNARY','SUPER','IVAR','GVAR','CONST','ARGVAR','SELF',
			'@','[','(','{','--','++','SELECTOR','TAG_START','TAGID','#','SELECTOR_START','IDREF','SPLAT','DO','BLOCK_ARG',
			'FOR','STRING_START','CONTINUE','BREAK'
		]; // '->', '=>', why does it not work with symbol?
		
		var IMPLICIT_INDENT_CALL = [
			'FOR'
		];
		// is not do an implicit call??
		
		var IMPLICIT_UNSPACED_CALL = ['+','-'];
		
		// Tokens indicating that the implicit call must enclose a block of expressions.
		var IMPLICIT_BLOCK = ['{','[',',','BLOCK_PARAM_END','DO']; // '->', '=>', 
		
		var CONDITIONAL_ASSIGN = ['||=','&&=','?=','&=','|='];
		var COMPOUND_ASSIGN = ['-=','+=','/=','*=','%=','||=','&&=','?=','<<=','>>=','>>>=','&=','^=','|='];
		var UNARY = ['!','~','NEW','TYPEOF','DELETE'];
		var LOGIC = ['&&','||','&','|','^'];
		
		// optimize for fixed arrays
		var NO_IMPLICIT_BLOCK_CALL = [
			'CALL_END','=','DEF_BODY','(','CALL_START',',',':','RETURN',
			'-=','+=','/=','*=','%=','||=','&&=','?=','<<=','>>=','>>>=','&=','^=','|='
		]; // .concat(COMPOUND_ASSIGN)
		
		
		// console.log NO_IMPLICIT_BLOCK_CALL:length
		// NO_IMPLICIT_BLOCK_CALL
		// IMPLICIT_COMMA = ['->', '=>', '{', '[', 'NUMBER', 'STRING', 'SYMBOL', 'IDENTIFIER','DO']
		
		var IMPLICIT_COMMA = ['DO'];
		
		// Tokens that always mark the end of an implicit call for single-liners.
		var IMPLICIT_END = ['POST_IF','POST_UNLESS','POST_FOR','WHILE','UNTIL','WHEN','BY','LOOP','TERMINATOR','DEF_BODY','DEF_FRAGMENT'];
		
		// Single-line flavors of block expressions that have unclosed endings.
		// The grammar can't disambiguate them, so we insert the implicit indentation.
		var SINGLE_LINERS = ['ELSE','TRY','FINALLY','THEN','BLOCK_PARAM_END','DO','BEGIN','CATCH_VAR']; // '->', '=>', really?
		var SINGLE_CLOSERS = ['TERMINATOR','CATCH','FINALLY','ELSE','OUTDENT','LEADING_WHEN'];
		
		// Tokens that end a line.
		return LINEBREAKS = ['TERMINATOR','INDENT','OUTDENT'];
	
	})()

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module, process) {/* parser generated by jison-fork */
	var parser = (function(){
	var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,4],$V1=[1,6],$V2=[1,32],$V3=[1,33],$V4=[1,34],$V5=[1,35],$V6=[1,75],$V7=[1,115],$V8=[1,128],$V9=[1,121],$Va=[1,122],$Vb=[1,123],$Vc=[1,120],$Vd=[1,124],$Ve=[1,131],$Vf=[1,114],$Vg=[1,132],$Vh=[1,80],$Vi=[1,81],$Vj=[1,82],$Vk=[1,83],$Vl=[1,84],$Vm=[1,85],$Vn=[1,86],$Vo=[1,73],$Vp=[1,118],$Vq=[1,95],$Vr=[1,91],$Vs=[1,88],$Vt=[1,71],$Vu=[1,65],$Vv=[1,66],$Vw=[1,111],$Vx=[1,90],$Vy=[1,87],$Vz=[1,28],$VA=[1,29],$VB=[1,96],$VC=[1,94],$VD=[1,112],$VE=[1,113],$VF=[1,126],$VG=[1,67],$VH=[1,68],$VI=[1,119],$VJ=[1,11],$VK=[1,127],$VL=[1,78],$VM=[1,37],$VN=[1,43],$VO=[1,110],$VP=[1,69],$VQ=[1,89],$VR=[1,125],$VS=[1,59],$VT=[1,74],$VU=[1,105],$VV=[1,106],$VW=[1,107],$VX=[1,129],$VY=[1,130],$VZ=[1,63],$V_=[1,104],$V$=[1,51],$V01=[1,52],$V11=[1,53],$V21=[1,54],$V31=[1,55],$V41=[1,56],$V51=[1,134],$V61=[1,6,11,137],$V71=[1,136],$V81=[1,6,11,14,137],$V91=[1,144],$Va1=[1,145],$Vb1=[1,147],$Vc1=[1,148],$Vd1=[1,141],$Ve1=[1,140],$Vf1=[1,142],$Vg1=[1,143],$Vh1=[1,146],$Vi1=[1,151],$Vj1=[1,6,10,11,14,22,71,90,97,106,112,126,135,137,147,171,200,201,212,213,214,219,220,229,238,239,242,243,246,247,248],$Vk1=[2,263],$Vl1=[1,158],$Vm1=[1,164],$Vn1=[1,162],$Vo1=[1,160],$Vp1=[1,161],$Vq1=[1,165],$Vr1=[1,163],$Vs1=[1,6,10,11,14,22,90,97,137],$Vt1=[1,6,11,14,137,212,214,219,220,238],$Vu1=[1,6,10,11,14,21,22,71,88,89,90,97,106,111,112,126,135,137,144,147,171,180,181,183,196,200,201,212,213,214,219,220,229,238,239,242,243,246,247,248],$Vv1=[2,231],$Vw1=[1,178],$Vx1=[1,176],$Vy1=[1,6,10,11,14,21,22,71,88,89,90,97,106,111,112,117,126,135,137,144,147,171,180,181,183,196,200,201,212,213,214,219,220,229,238,239,242,243,246,247,248],$Vz1=[2,227],$VA1=[6,14,53,54,88,91,106,111,113,116],$VB1=[1,212],$VC1=[1,217],$VD1=[1,6,10,11,14,21,22,71,88,89,90,97,106,111,112,117,126,135,137,144,147,171,180,181,183,196,200,201,212,213,214,219,220,229,238,239,242,243,244,245,246,247,248,249],$VE1=[1,227],$VF1=[1,224],$VG1=[1,229],$VH1=[6,10,14,90],$VI1=[2,244],$VJ1=[1,257],$VK1=[1,247],$VL1=[1,276],$VM1=[1,277],$VN1=[51,89],$VO1=[85,86,87,88,91,92,93,94,95,96,100,102],$VP1=[1,289],$VQ1=[1,6,10,11,14,21,22,53,54,71,88,89,90,91,97,106,111,112,113,116,117,126,135,137,144,147,171,180,181,183,196,200,201,212,213,214,219,220,229,238,239,242,243,244,245,246,247,248,249],$VR1=[1,295],$VS1=[51,89,96,225],$VT1=[1,6,10,11,14,21,22,67,69,70,71,88,89,90,97,106,111,112,126,135,137,144,147,171,180,181,183,196,200,201,212,213,214,219,220,229,238,239,242,243,246,247,248],$VU1=[1,6,10,11,14,21,22,71,88,89,90,97,106,111,112,126,135,137,144,147,171,180,181,183,196,200,201,207,208,212,213,214,219,220,229,232,234,237,238,239,242,243,246,247,248],$VV1=[51,53,54,58],$VW1=[1,326],$VX1=[1,327],$VY1=[1,6,10,11,14,22,71,90,97,106,112,135,137,147,200,201,212,213,214,219,220,229,238],$VZ1=[1,340],$V_1=[1,344],$V$1=[1,6,11,14,22,71,90,97,106,112,126,135,137,147,171,200,201,212,213,214,219,220,229,238,239,242,243,246,247,248],$V02=[6,14,106],$V12=[1,354],$V22=[1,6,10,11,14,21,22,71,89,90,97,106,112,126,135,137,147,171,200,201,212,213,214,219,220,229,238,239,242,243,246,247,248],$V32=[14,28],$V42=[1,6,11,14,28,137,212,214,219,220,238],$V52=[2,284],$V62=[1,6,10,11,14,21,22,71,88,89,90,97,106,111,112,117,126,135,137,144,147,171,180,181,183,196,200,201,212,213,214,219,220,227,228,229,238,239,242,243,244,245,246,247,248,249],$V72=[2,184],$V82=[1,369],$V92=[6,10,11,14,22,97],$Va2=[14,147],$Vb2=[2,186],$Vc2=[1,379],$Vd2=[1,380],$Ve2=[1,381],$Vf2=[1,385],$Vg2=[6,10,11,14,90],$Vh2=[6,10,11,14,90,135],$Vi2=[1,6,10,11,14,22,71,90,97,106,112,135,137,147,200,201,220,229,238],$Vj2=[1,6,10,11,14,22,71,90,97,106,112,135,137,147,200,201,213,220,229,238],$Vk2=[227,228],$Vl2=[14,227,228],$Vm2=[1,6,11,14,22,71,90,97,106,112,135,137,147,171,200,201,212,213,214,219,220,229,238,239,242,243,246,247,248],$Vn2=[88,91],$Vo2=[1,406],$Vp2=[1,407],$Vq2=[21,88,91,164,165],$Vr2=[1,6,10,11,14,22,71,90,97,106,112,126,135,137,147,171,200,201,212,213,214,219,220,229,238,239,242,243,247,248],$Vs2=[1,6,10,11,14,22,71,90,97,106,112,135,137,147,200,201,213,229],$Vt2=[19,20,23,24,26,32,51,53,54,56,58,60,62,64,66,73,74,75,76,77,78,79,80,83,89,91,96,103,112,122,123,124,130,136,143,144,151,152,154,156,157,158,175,184,185,188,193,194,197,198,204,210,212,214,216,219,220,230,236,240,241,242,243,244,245],$Vu2=[1,6,10,11,14,22,71,90,97,106,112,126,135,137,147,171,200,201,212,213,214,219,220,229,232,237,238,239,242,243,246,247,248],$Vv2=[11,232,234],$Vw2=[1,453],$Vx2=[2,185],$Vy2=[6,10,11],$Vz2=[1,461],$VA2=[14,22,147],$VB2=[1,469],$VC2=[1,6,10,11,14,22,71,90,97,106,112,135,137,147,200,201,212,214,219,220,229,238],$VD2=[51,58,89],$VE2=[14,22],$VF2=[1,492],$VG2=[10,14],$VH2=[1,542],$VI2=[6,10];
	var parser = {trace: function trace() { },
	yy: {},
	symbols_: {"error":2,"Root":3,"Body":4,"Block":5,"TERMINATOR":6,"BODYSTART":7,"Line":8,"Terminator":9,"INDENT":10,"OUTDENT":11,"Splat":12,"Expression":13,",":14,"Comment":15,"Statement":16,"Return":17,"Throw":18,"STATEMENT":19,"BREAK":20,"CALL_START":21,"CALL_END":22,"CONTINUE":23,"DEBUGGER":24,"ImportStatement":25,"IMPORT":26,"ImportArgList":27,"FROM":28,"ImportFrom":29,"AS":30,"ImportArg":31,"STRING":32,"VarIdentifier":33,"Await":34,"Value":35,"Code":36,"Operation":37,"Assign":38,"If":39,"Ternary":40,"Try":41,"While":42,"For":43,"Switch":44,"Class":45,"Module":46,"TagDeclaration":47,"Tag":48,"Property":49,"Identifier":50,"IDENTIFIER":51,"Ivar":52,"IVAR":53,"CVAR":54,"Gvar":55,"GVAR":56,"Const":57,"CONST":58,"Argvar":59,"ARGVAR":60,"Symbol":61,"SYMBOL":62,"AlphaNumeric":63,"NUMBER":64,"InterpolatedString":65,"STRING_START":66,"NEOSTRING":67,"Interpolation":68,"STRING_END":69,"{{":70,"}}":71,"Literal":72,"JS":73,"REGEX":74,"BOOL":75,"TRUE":76,"FALSE":77,"NULL":78,"UNDEFINED":79,"RETURN":80,"Arguments":81,"TagSelector":82,"SELECTOR_START":83,"TagSelectorType":84,"SELECTOR_NS":85,"SELECTOR_ID":86,"SELECTOR_CLASS":87,".":88,"{":89,"}":90,"#":91,"SELECTOR_COMBINATOR":92,"SELECTOR_PSEUDO_CLASS":93,"SELECTOR_GROUP":94,"UNIVERSAL_SELECTOR":95,"[":96,"]":97,"SELECTOR_ATTR_OP":98,"TagSelectorAttrValue":99,"SELECTOR_TAG":100,"Selector":101,"SELECTOR_END":102,"TAG_START":103,"TagOptions":104,"TagAttributes":105,"TAG_END":106,"TagBody":107,"TagTypeName":108,"Self":109,"TAG_TYPE":110,"INDEX_START":111,"INDEX_END":112,"@":113,"TagAttr":114,"OptComma":115,"TAG_ATTR":116,"=":117,"TagAttrValue":118,"ArgList":119,"TagTypeDef":120,"TagDeclarationBlock":121,"EXTEND":122,"LOCAL":123,"TAG":124,"TagType":125,"COMPARE":126,"TagDeclKeywords":127,"TAG_ID":128,"TagId":129,"IDREF":130,"Assignable":131,"Outdent":132,"AssignObj":133,"ObjAssignable":134,":":135,"(":136,")":137,"HERECOMMENT":138,"COMMENT":139,"Method":140,"Do":141,"Begin":142,"BEGIN":143,"DO":144,"BLOCK_PARAM_START":145,"ParamList":146,"BLOCK_PARAM_END":147,"PropType":148,"PropertyIdentifier":149,"Object":150,"PROP":151,"ATTR":152,"TupleAssign":153,"VAR":154,"MethodDeclaration":155,"GLOBAL":156,"EXPORT":157,"DEF":158,"MethodScope":159,"MethodScopeType":160,"MethodIdentifier":161,"MethodBody":162,"MethodReceiver":163,"DEF_BODY":164,"DEF_EMPTY":165,"This":166,"Param":167,"Array":168,"ParamVar":169,"SPLAT":170,"LOGIC":171,"BLOCK_ARG":172,"VarReference":173,"VarAssignable":174,"LET":175,"SimpleAssignable":176,"NEW":177,"Super":178,"SoakableOp":179,"?:":180,".:":181,"IndexValue":182,"?.":183,"SUPER":184,"AWAIT":185,"Parenthetical":186,"Range":187,"ARGUMENTS":188,"Invocation":189,"Slice":190,"AssignList":191,"ClassStart":192,"CLASS":193,"MODULE":194,"OptFuncExist":195,"FUNC_EXIST":196,"THIS":197,"SELF":198,"RangeDots":199,"..":200,"...":201,"Arg":202,"SimpleArgs":203,"TRY":204,"Catch":205,"Finally":206,"FINALLY":207,"CATCH":208,"CATCH_VAR":209,"THROW":210,"WhileSource":211,"WHILE":212,"WHEN":213,"UNTIL":214,"Loop":215,"LOOP":216,"ForBody":217,"ForKeyword":218,"FOR":219,"POST_FOR":220,"ForBlock":221,"ForStart":222,"ForSource":223,"ForVariables":224,"OWN":225,"ForValue":226,"FORIN":227,"FOROF":228,"BY":229,"SWITCH":230,"Whens":231,"ELSE":232,"When":233,"LEADING_WHEN":234,"IfBlock":235,"IF":236,"ELIF":237,"POST_IF":238,"?":239,"UNARY":240,"SQRT":241,"-":242,"+":243,"--":244,"++":245,"MATH":246,"SHIFT":247,"RELATION":248,"COMPOUND_ASSIGN":249,"$accept":0,"$end":1},
	terminals_: {2:"error",6:"TERMINATOR",7:"BODYSTART",10:"INDENT",11:"OUTDENT",14:",",19:"STATEMENT",20:"BREAK",21:"CALL_START",22:"CALL_END",23:"CONTINUE",24:"DEBUGGER",26:"IMPORT",28:"FROM",30:"AS",32:"STRING",51:"IDENTIFIER",53:"IVAR",54:"CVAR",56:"GVAR",58:"CONST",60:"ARGVAR",62:"SYMBOL",64:"NUMBER",66:"STRING_START",67:"NEOSTRING",69:"STRING_END",70:"{{",71:"}}",73:"JS",74:"REGEX",75:"BOOL",76:"TRUE",77:"FALSE",78:"NULL",79:"UNDEFINED",80:"RETURN",83:"SELECTOR_START",85:"SELECTOR_NS",86:"SELECTOR_ID",87:"SELECTOR_CLASS",88:".",89:"{",90:"}",91:"#",92:"SELECTOR_COMBINATOR",93:"SELECTOR_PSEUDO_CLASS",94:"SELECTOR_GROUP",95:"UNIVERSAL_SELECTOR",96:"[",97:"]",98:"SELECTOR_ATTR_OP",100:"SELECTOR_TAG",102:"SELECTOR_END",103:"TAG_START",106:"TAG_END",110:"TAG_TYPE",111:"INDEX_START",112:"INDEX_END",113:"@",116:"TAG_ATTR",117:"=",122:"EXTEND",123:"LOCAL",124:"TAG",126:"COMPARE",128:"TAG_ID",130:"IDREF",135:":",136:"(",137:")",138:"HERECOMMENT",139:"COMMENT",143:"BEGIN",144:"DO",145:"BLOCK_PARAM_START",147:"BLOCK_PARAM_END",151:"PROP",152:"ATTR",154:"VAR",156:"GLOBAL",157:"EXPORT",158:"DEF",164:"DEF_BODY",165:"DEF_EMPTY",170:"SPLAT",171:"LOGIC",172:"BLOCK_ARG",175:"LET",177:"NEW",180:"?:",181:".:",183:"?.",184:"SUPER",185:"AWAIT",188:"ARGUMENTS",193:"CLASS",194:"MODULE",196:"FUNC_EXIST",197:"THIS",198:"SELF",200:"..",201:"...",204:"TRY",207:"FINALLY",208:"CATCH",209:"CATCH_VAR",210:"THROW",212:"WHILE",213:"WHEN",214:"UNTIL",216:"LOOP",219:"FOR",220:"POST_FOR",225:"OWN",227:"FORIN",228:"FOROF",229:"BY",230:"SWITCH",232:"ELSE",234:"LEADING_WHEN",236:"IF",237:"ELIF",238:"POST_IF",239:"?",240:"UNARY",241:"SQRT",242:"-",243:"+",244:"--",245:"++",246:"MATH",247:"SHIFT",248:"RELATION",249:"COMPOUND_ASSIGN"},
	productions_: [0,[3,0],[3,1],[3,2],[4,1],[4,1],[4,3],[4,2],[9,1],[5,2],[5,3],[5,4],[8,1],[8,1],[8,3],[8,3],[8,1],[8,1],[16,1],[16,1],[16,1],[16,1],[16,4],[16,1],[16,4],[16,1],[16,1],[25,4],[25,4],[25,2],[29,1],[27,1],[27,3],[31,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[50,1],[52,1],[52,1],[55,1],[57,1],[59,1],[61,1],[63,1],[63,1],[63,1],[63,1],[65,1],[65,2],[65,2],[65,2],[68,2],[68,3],[72,1],[72,1],[72,1],[72,1],[72,1],[72,1],[72,1],[72,1],[17,2],[17,2],[17,1],[82,1],[82,2],[82,2],[82,2],[82,2],[82,5],[82,5],[82,2],[82,2],[82,2],[82,2],[82,4],[82,6],[84,1],[101,2],[99,1],[99,1],[99,3],[48,4],[48,5],[48,5],[108,1],[108,1],[108,1],[108,0],[104,1],[104,3],[104,4],[104,3],[104,5],[104,5],[104,3],[104,2],[104,5],[105,0],[105,1],[105,3],[105,4],[114,1],[114,3],[118,1],[107,3],[107,3],[120,1],[120,3],[47,1],[47,2],[47,2],[121,2],[121,3],[121,4],[121,5],[127,0],[127,1],[125,1],[125,1],[129,1],[129,2],[38,3],[38,5],[133,1],[133,3],[133,5],[133,1],[134,1],[134,1],[134,1],[134,1],[134,1],[134,3],[15,1],[15,1],[36,1],[36,1],[36,1],[142,2],[141,2],[141,5],[141,6],[49,3],[49,5],[49,2],[148,1],[148,1],[149,1],[149,3],[153,4],[140,1],[140,2],[140,2],[155,8],[155,5],[155,6],[155,3],[160,1],[160,1],[161,1],[161,1],[161,3],[162,2],[162,2],[162,1],[159,1],[159,1],[159,1],[159,1],[115,0],[115,1],[146,0],[146,1],[146,3],[167,1],[167,1],[167,1],[167,2],[167,2],[167,2],[167,3],[169,1],[12,2],[173,3],[173,2],[173,2],[173,3],[173,2],[33,1],[33,1],[174,1],[174,1],[174,1],[176,1],[176,1],[176,1],[176,1],[176,1],[176,1],[176,1],[176,3],[176,3],[176,3],[176,3],[176,3],[176,3],[176,3],[176,3],[176,4],[179,1],[179,1],[178,1],[131,1],[131,1],[131,1],[34,2],[35,1],[35,1],[35,1],[35,1],[35,1],[35,1],[35,1],[35,1],[35,1],[35,1],[182,1],[182,1],[150,4],[191,0],[191,1],[191,3],[191,4],[191,6],[45,1],[45,2],[45,2],[45,2],[45,2],[45,3],[192,2],[192,3],[192,4],[192,5],[46,2],[46,3],[189,3],[189,2],[195,0],[195,1],[81,2],[81,4],[166,1],[109,1],[168,2],[168,4],[199,1],[199,1],[187,5],[190,3],[190,2],[190,2],[119,1],[119,3],[119,4],[119,4],[119,6],[132,2],[132,1],[202,1],[202,1],[202,1],[202,1],[203,1],[203,3],[41,2],[41,3],[41,3],[41,4],[206,2],[205,3],[18,2],[186,3],[186,5],[211,2],[211,4],[211,2],[211,4],[42,2],[42,2],[42,2],[42,1],[215,2],[215,2],[43,2],[43,2],[43,2],[218,1],[218,1],[221,2],[217,2],[217,2],[222,2],[222,3],[226,1],[226,1],[226,1],[224,1],[224,3],[223,2],[223,2],[223,4],[223,4],[223,4],[223,6],[223,6],[44,5],[44,7],[44,4],[44,6],[231,1],[231,2],[233,3],[233,4],[235,3],[235,5],[235,4],[235,3],[39,1],[39,3],[39,3],[40,5],[37,2],[37,2],[37,2],[37,2],[37,2],[37,2],[37,2],[37,2],[37,3],[37,3],[37,3],[37,3],[37,3],[37,3],[37,3],[37,3],[37,5]],
	performAction: function performAction(self, yytext, yy, yystate /* action[1] */, $$ /* vstack */) {
	/* self == yyval */
	
	var $0 = $$.length - 1;
	switch (yystate) {
	case 1:
	return self.$ = new yy.Root([]);
	break;
	case 2:
	return self.$ = new yy.Root($$[$0]);
	break;
	case 3:
	return self.$ = $$[$0-1];
	break;
	case 4:
	self.$ = new yy.Block([]);
	break;
	case 5:
	self.$ = new yy.Block([$$[$0]]);
	break;
	case 6:
	self.$ = $$[$0-2].break($$[$0-1]).add($$[$0]);
	break;
	case 7:
	self.$ = $$[$0-1].break($$[$0]);
	break;
	case 8:
	self.$ = new yy.Terminator($$[$0]);
	break;
	case 9:
	self.$ = new yy.Block([]).indented($$[$0-1],$$[$0]);
	break;
	case 10: case 119:
	self.$ = $$[$0-1].indented($$[$0-2],$$[$0]);
	break;
	case 11:
	self.$ = $$[$0-1].prebreak($$[$0-2]).indented($$[$0-3],$$[$0]);
	break;
	case 12: case 13: case 16: case 17: case 18: case 19: case 26: case 30: case 33: case 34: case 35: case 36: case 37: case 38: case 39: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 48: case 49: case 59: case 60: case 67: case 93: case 94: case 99: case 118: case 123: case 130: case 141: case 142: case 143: case 144: case 145: case 146: case 150: case 151: case 152: case 160: case 161: case 162: case 165: case 174: case 175: case 177: case 180: case 181: case 182: case 183: case 184: case 185: case 196: case 203: case 204: case 205: case 206: case 207: case 208: case 210: case 211: case 212: case 213: case 227: case 228: case 229: case 231: case 232: case 233: case 234: case 235: case 237: case 238: case 239: case 240: case 249: case 283: case 284: case 285: case 286: case 287: case 288: case 306: case 312: case 313: case 319: case 335: case 343:
	self.$ = $$[$0];
	break;
	case 14: case 15:
	self.$ = $$[$0-2].addExpression($$[$0]);
	break;
	case 20: case 68:
	self.$ = new yy.Literal($$[$0]);
	break;
	case 21:
	self.$ = new yy.BreakStatement($$[$0]);
	break;
	case 22:
	self.$ = new yy.BreakStatement($$[$0-3],$$[$0-1]);
	break;
	case 23:
	self.$ = new yy.ContinueStatement($$[$0]);
	break;
	case 24:
	self.$ = new yy.ContinueStatement($$[$0-3],$$[$0-1]);
	break;
	case 25:
	self.$ = new yy.DebuggerStatement($$[$0]);
	break;
	case 27:
	self.$ = new yy.ImportStatement($$[$0-2],$$[$0]);
	break;
	case 28:
	self.$ = new yy.ImportStatement(null,$$[$0-2],$$[$0]);
	break;
	case 29:
	self.$ = new yy.ImportStatement(null,$$[$0]);
	break;
	case 31: case 113: case 187: case 322:
	self.$ = [$$[$0]];
	break;
	case 32: case 114: case 188:
	self.$ = $$[$0-2].concat($$[$0]);
	break;
	case 50:
	self.$ = new yy.Identifier($$[$0]);
	break;
	case 51: case 52:
	self.$ = new yy.Ivar($$[$0]);
	break;
	case 53:
	self.$ = new yy.Gvar($$[$0]);
	break;
	case 54:
	self.$ = new yy.Const($$[$0]);
	break;
	case 55:
	self.$ = new yy.Argvar($$[$0]);
	break;
	case 56:
	self.$ = new yy.Symbol($$[$0]);
	break;
	case 57:
	self.$ = new yy.Num($$[$0]);
	break;
	case 58:
	self.$ = new yy.Str($$[$0]);
	break;
	case 61:
	self.$ = new yy.InterpolatedString([],{open: $$[$0]});
	break;
	case 62:
	self.$ = $$[$0-1].add($$[$0]);
	break;
	case 63:
	self.$ = $$[$0] ? ($$[$0-1].add($$[$0])) : ($$[$0-1]);
	break;
	case 64:
	self.$ = $$[$0-1].option('close',$$[$0]);
	break;
	case 65:
	self.$ = null;
	break;
	case 66: case 92: case 95: case 120: case 147: case 163: case 176: case 282:
	self.$ = $$[$0-1];
	break;
	case 69:
	self.$ = new yy.RegExp($$[$0]);
	break;
	case 70:
	self.$ = new yy.Bool($$[$0]);
	break;
	case 71:
	self.$ = yy.TRUE;
	break;
	case 72:
	self.$ = yy.FALSE;
	break;
	case 73:
	self.$ = yy.NIL;
	break;
	case 74:
	self.$ = yy.UNDEFINED;
	break;
	case 75: case 76:
	self.$ = new yy.Return($$[$0]);
	break;
	case 77:
	self.$ = new yy.Return();
	break;
	case 78:
	self.$ = new yy.Selector([],{type: $$[$0]});
	break;
	case 79:
	self.$ = $$[$0-1].add(new yy.SelectorType($$[$0]),'tag');
	break;
	case 80:
	self.$ = $$[$0-1].add(new yy.SelectorNamespace($$[$0]),'ns');
	break;
	case 81:
	self.$ = $$[$0-1].add(new yy.SelectorId($$[$0]),'id');
	break;
	case 82:
	self.$ = $$[$0-1].add(new yy.SelectorClass($$[$0]),'class');
	break;
	case 83:
	self.$ = $$[$0-4].add(new yy.SelectorClass($$[$0-1]),'class');
	break;
	case 84:
	self.$ = $$[$0-4].add(new yy.SelectorId($$[$0-1]),'id');
	break;
	case 85:
	self.$ = $$[$0-1].add(new yy.SelectorCombinator($$[$0]),'sep');
	break;
	case 86:
	self.$ = $$[$0-1].add(new yy.SelectorPseudoClass($$[$0]),'pseudoclass');
	break;
	case 87:
	self.$ = $$[$0-1].group();
	break;
	case 88:
	self.$ = $$[$0-1].add(new yy.SelectorUniversal($$[$0]),'universal');
	break;
	case 89:
	self.$ = $$[$0-3].add(new yy.SelectorAttribute($$[$0-1]),'attr');
	break;
	case 90:
	self.$ = $$[$0-5].add(new yy.SelectorAttribute($$[$0-3],$$[$0-2],$$[$0-1]),'attr');
	break;
	case 91: case 100: case 101: case 132: case 133:
	self.$ = new yy.TagTypeIdentifier($$[$0]);
	break;
	case 96:
	self.$ = $$[$0-2].set({attributes: $$[$0-1],open: $$[$0-3],close: $$[$0]});
	break;
	case 97:
	self.$ = $$[$0-3].set({attributes: $$[$0-2],body: $$[$0],open: $$[$0-4],close: $$[$0-1]});
	break;
	case 98:
	self.$ = new yy.TagWrapper($$[$0-2],$$[$0-4],$$[$0]);
	break;
	case 102:
	self.$ = new yy.TagTypeIdentifier('div');
	break;
	case 103:
	self.$ = new yy.Tag({type: $$[$0]});
	break;
	case 104:
	self.$ = $$[$0-2].addSymbol($$[$0]);
	break;
	case 105:
	self.$ = $$[$0-3].addIndex($$[$0-1]);
	break;
	case 106:
	self.$ = $$[$0-2].addClass($$[$0]);
	break;
	case 107:
	self.$ = $$[$0-4].addClass($$[$0-1]);
	break;
	case 108:
	self.$ = $$[$0-4].set({key: $$[$0-1]});
	break;
	case 109:
	self.$ = $$[$0-2].set({id: $$[$0]});
	break;
	case 110:
	self.$ = $$[$0-1].set({ivar: $$[$0]});
	break;
	case 111:
	self.$ = $$[$0-4].set({id: $$[$0-1]});
	break;
	case 112: case 179: case 186:
	self.$ = [];
	break;
	case 115:
	self.$ = $$[$0-3].concat($$[$0]);
	break;
	case 116:
	self.$ = new yy.TagAttr($$[$0],$$[$0]);
	break;
	case 117:
	self.$ = new yy.TagAttr($$[$0-2],$$[$0],$$[$0-1]);
	break;
	case 121:
	self.$ = new yy.TagDesc($$[$0]);
	break;
	case 122:
	self.$ = $$[$0-2].classes($$[$0]);
	break;
	case 124:
	self.$ = $$[$0].set({extension: true});
	break;
	case 125:
	self.$ = $$[$0].set({local: true});
	break;
	case 126:
	self.$ = new yy.TagDeclaration($$[$0]).set({keyword: $$[$0-1]});
	break;
	case 127:
	self.$ = new yy.TagDeclaration($$[$0-1],null,$$[$0]).set({keyword: $$[$0-2]});
	break;
	case 128:
	self.$ = new yy.TagDeclaration($$[$0-2],$$[$0]).set({keyword: $$[$0-3]});
	break;
	case 129:
	self.$ = new yy.TagDeclaration($$[$0-3],$$[$0-1],$$[$0]).set({keyword: $$[$0-4]});
	break;
	case 131:
	self.$ = ['yy.extend'];
	break;
	case 134: case 135:
	self.$ = new yy.TagId($$[$0]);
	break;
	case 136:
	self.$ = new yy.Assign($$[$0-1],$$[$0-2],$$[$0]);
	break;
	case 137:
	self.$ = new yy.Assign($$[$0-3],$$[$0-4],$$[$0-1].indented($$[$0-2],$$[$0]));
	break;
	case 138:
	self.$ = new yy.ObjAttr($$[$0]);
	break;
	case 139:
	self.$ = new yy.ObjAttr($$[$0-2],$$[$0],'object');
	break;
	case 140:
	self.$ = new yy.ObjAttr($$[$0-4],$$[$0-1].indented($$[$0-2],$$[$0]),'object');
	break;
	case 148:
	self.$ = new yy.Comment($$[$0],true);
	break;
	case 149:
	self.$ = new yy.Comment($$[$0],false);
	break;
	case 153:
	self.$ = new yy.Begin($$[$0]);
	break;
	case 154:
	self.$ = new yy.Lambda([],$$[$0],null,null,{bound: true});
	break;
	case 155:
	self.$ = new yy.Lambda($$[$0-2],$$[$0],null,null,{bound: true});
	break;
	case 156:
	self.$ = new yy.Lambda($$[$0-3],$$[$0-1],null,null,{bound: true});
	break;
	case 157:
	self.$ = new yy.PropertyDeclaration($$[$0-1],$$[$0],$$[$0-2]);
	break;
	case 158:
	self.$ = new yy.PropertyDeclaration($$[$0-3],$$[$0-1],$$[$0-4]);
	break;
	case 159:
	self.$ = new yy.PropertyDeclaration($$[$0],null,$$[$0-1]);
	break;
	case 164:
	self.$ = $$[$0-3];
	break;
	case 166: case 252:
	self.$ = $$[$0].set({global: $$[$0-1]});
	break;
	case 167: case 202: case 253:
	self.$ = $$[$0].set({export: $$[$0-1]});
	break;
	case 168:
	self.$ = new yy.MethodDeclaration($$[$0-2],$$[$0],$$[$0-4],$$[$0-6],$$[$0-5]).set({def: $$[$0-7]});
	break;
	case 169:
	self.$ = new yy.MethodDeclaration([],$$[$0],$$[$0-1],$$[$0-3],$$[$0-2]).set({def: $$[$0-4]});
	break;
	case 170:
	self.$ = new yy.MethodDeclaration($$[$0-2],$$[$0],$$[$0-4],null).set({def: $$[$0-5]});
	break;
	case 171:
	self.$ = new yy.MethodDeclaration([],$$[$0],$$[$0-1],null).set({def: $$[$0-2]});
	break;
	case 172:
	self.$ = {static: true};
	break;
	case 173:
	self.$ = {};
	break;
	case 178:
	self.$ = $$[$0].body();
	break;
	case 189:
	self.$ = new yy.NamedParams($$[$0]);
	break;
	case 190:
	self.$ = new yy.ArrayParams($$[$0]);
	break;
	case 191:
	self.$ = new yy.RequiredParam($$[$0]);
	break;
	case 192:
	self.$ = new yy.SplatParam($$[$0],null,$$[$0-1]);
	break;
	case 193: case 194:
	self.$ = new yy.BlockParam($$[$0],null,$$[$0-1]);
	break;
	case 195:
	self.$ = new yy.OptionalParam($$[$0-2],$$[$0],$$[$0-1]);
	break;
	case 197:
	self.$ = yy.SPLAT($$[$0]);
	break;
	case 198: case 201:
	self.$ = yy.SPLAT(new yy.VarReference($$[$0],$$[$0-2]),$$[$0-1]);
	break;
	case 199: case 200:
	self.$ = new yy.VarReference($$[$0],$$[$0-1]);
	break;
	case 209:
	self.$ = new yy.IvarAccess('.',null,$$[$0]);
	break;
	case 214:
	self.$ = new yy.VarOrAccess($$[$0]);
	break;
	case 215:
	self.$ = new yy.New($$[$0-2]);
	break;
	case 216:
	self.$ = new yy.SuperAccess('.',$$[$0-2],$$[$0]);
	break;
	case 217:
	self.$ = new yy.PropertyAccess($$[$0-1],$$[$0-2],$$[$0]);
	break;
	case 218: case 219: case 220: case 222:
	self.$ = new yy.Access($$[$0-1],$$[$0-2],$$[$0]);
	break;
	case 221:
	self.$ = new yy.Access('.',$$[$0-2],new yy.Identifier($$[$0].value()));
	break;
	case 223:
	self.$ = new yy.IndexAccess('.',$$[$0-3],$$[$0-1]);
	break;
	case 226:
	self.$ = yy.SUPER;
	break;
	case 230:
	self.$ = new yy.Await($$[$0]).set({keyword: $$[$0-1]});
	break;
	case 236:
	self.$ = yy.ARGUMENTS;
	break;
	case 241:
	self.$ = new yy.Index($$[$0]);
	break;
	case 242:
	self.$ = new yy.Slice($$[$0]);
	break;
	case 243:
	self.$ = new yy.Obj($$[$0-2],$$[$0-3].generated);
	break;
	case 244:
	self.$ = new yy.AssignList([]);
	break;
	case 245:
	self.$ = new yy.AssignList([$$[$0]]);
	break;
	case 246: case 278:
	self.$ = $$[$0-2].add($$[$0]);
	break;
	case 247: case 279:
	self.$ = $$[$0-3].add($$[$0-1]).add($$[$0]);
	break;
	case 248:
	self.$ = $$[$0-5].concat($$[$0-2].indented($$[$0-3],$$[$0]));
	break;
	case 250:
	self.$ = $$[$0].set({extension: $$[$0-1]});
	break;
	case 251:
	self.$ = $$[$0].set({local: $$[$0-1]});
	break;
	case 254:
	self.$ = $$[$0].set({export: $$[$0-2],local: $$[$0-1]});
	break;
	case 255:
	self.$ = new yy.ClassDeclaration($$[$0],null,[]).set({keyword: $$[$0-1]});
	break;
	case 256:
	self.$ = new yy.ClassDeclaration($$[$0-1],null,$$[$0]).set({keyword: $$[$0-2]});
	break;
	case 257:
	self.$ = new yy.ClassDeclaration($$[$0-2],$$[$0],[]).set({keyword: $$[$0-3]});
	break;
	case 258:
	self.$ = new yy.ClassDeclaration($$[$0-3],$$[$0-1],$$[$0]).set({keyword: $$[$0-4]});
	break;
	case 259:
	self.$ = new yy.Module($$[$0]);
	break;
	case 260:
	self.$ = new yy.Module($$[$0-1],null,$$[$0]);
	break;
	case 261:
	self.$ = new yy.Call($$[$0-2],$$[$0],$$[$0-1]);
	break;
	case 262:
	self.$ = $$[$0-1].addBlock($$[$0]);
	break;
	case 263:
	self.$ = false;
	break;
	case 264:
	self.$ = true;
	break;
	case 265:
	self.$ = new yy.ArgList([]);
	break;
	case 266:
	self.$ = $$[$0-2];
	break;
	case 267:
	self.$ = new yy.This($$[$0]);
	break;
	case 268:
	self.$ = new yy.Self($$[$0]);
	break;
	case 269:
	self.$ = new yy.Arr(new yy.ArgList([]));
	break;
	case 270:
	self.$ = new yy.Arr($$[$0-2]);
	break;
	case 271:
	self.$ = '..';
	break;
	case 272:
	self.$ = '...';
	break;
	case 273:
	self.$ = yy.OP($$[$0-2],$$[$0-3],$$[$0-1]);
	break;
	case 274:
	self.$ = new yy.Range($$[$0-2],$$[$0],$$[$0-1]);
	break;
	case 275:
	self.$ = new yy.Range($$[$0-1],null,$$[$0]);
	break;
	case 276:
	self.$ = new yy.Range(null,$$[$0],$$[$0-1]);
	break;
	case 277:
	self.$ = new yy.ArgList([$$[$0]]);
	break;
	case 280:
	self.$ = $$[$0-2].indented($$[$0-3],$$[$0]);
	break;
	case 281:
	self.$ = $$[$0-5].concat($$[$0-2]);
	break;
	case 289:
	self.$ = [].concat($$[$0-2],$$[$0]);
	break;
	case 290:
	self.$ = new yy.Try($$[$0]);
	break;
	case 291:
	self.$ = new yy.Try($$[$0-1],$$[$0]);
	break;
	case 292:
	self.$ = new yy.Try($$[$0-1],null,$$[$0]);
	break;
	case 293:
	self.$ = new yy.Try($$[$0-2],$$[$0-1],$$[$0]);
	break;
	case 294:
	self.$ = new yy.Finally($$[$0]);
	break;
	case 295:
	self.$ = new yy.Catch($$[$0],$$[$0-1]);
	break;
	case 296:
	self.$ = new yy.Throw($$[$0]);
	break;
	case 297:
	self.$ = new yy.Parens($$[$0-1],$$[$0-2],$$[$0]);
	break;
	case 298:
	self.$ = new yy.Parens($$[$0-2],$$[$0-4],$$[$0]);
	break;
	case 299:
	self.$ = new yy.While($$[$0]);
	break;
	case 300:
	self.$ = new yy.While($$[$0-2],{guard: $$[$0]});
	break;
	case 301:
	self.$ = new yy.While($$[$0],{invert: true});
	break;
	case 302:
	self.$ = new yy.While($$[$0-2],{invert: true,guard: $$[$0]});
	break;
	case 303: case 311: case 314:
	self.$ = $$[$0-1].addBody($$[$0]);
	break;
	case 304: case 305:
	self.$ = $$[$0].addBody(yy.Block.wrap([$$[$0-1]]));
	break;
	case 307:
	self.$ = new yy.While(new yy.Literal('true')).addBody($$[$0]);
	break;
	case 308:
	self.$ = new yy.While(new yy.Literal('true')).addBody(yy.Block.wrap([$$[$0]]));
	break;
	case 309: case 310:
	self.$ = $$[$0].addBody([$$[$0-1]]);
	break;
	case 315:
	self.$ = {source: new yy.ValueNode($$[$0])};
	break;
	case 316:
	self.$ = $$[$0].configure({own: $$[$0-1].own,name: $$[$0-1][0],index: $$[$0-1][1],keyword: $$[$0-1].keyword});
	break;
	case 317:
	self.$ = ($$[$0].keyword = $$[$0-1]) && $$[$0];
	break;
	case 318:
	self.$ = ($$[$0].own = true) && ($$[$0].keyword = $$[$0-2]) && $$[$0];
	break;
	case 320: case 321:
	self.$ = new yy.ValueNode($$[$0]);
	break;
	case 323:
	self.$ = [$$[$0-2],$$[$0]];
	break;
	case 324:
	self.$ = new yy.ForIn({source: $$[$0]});
	break;
	case 325:
	self.$ = new yy.ForOf({source: $$[$0],object: true});
	break;
	case 326:
	self.$ = new yy.ForIn({source: $$[$0-2],guard: $$[$0]});
	break;
	case 327:
	self.$ = new yy.ForOf({source: $$[$0-2],guard: $$[$0],object: true});
	break;
	case 328:
	self.$ = new yy.ForIn({source: $$[$0-2],step: $$[$0]});
	break;
	case 329:
	self.$ = new yy.ForIn({source: $$[$0-4],guard: $$[$0-2],step: $$[$0]});
	break;
	case 330:
	self.$ = new yy.ForIn({source: $$[$0-4],step: $$[$0-2],guard: $$[$0]});
	break;
	case 331:
	self.$ = new yy.Switch($$[$0-3],$$[$0-1]);
	break;
	case 332:
	self.$ = new yy.Switch($$[$0-5],$$[$0-3],$$[$0-1]);
	break;
	case 333:
	self.$ = new yy.Switch(null,$$[$0-1]);
	break;
	case 334:
	self.$ = new yy.Switch(null,$$[$0-3],$$[$0-1]);
	break;
	case 336:
	self.$ = $$[$0-1].concat($$[$0]);
	break;
	case 337:
	self.$ = [new yy.SwitchCase($$[$0-1],$$[$0])];
	break;
	case 338:
	self.$ = [new yy.SwitchCase($$[$0-2],$$[$0-1])];
	break;
	case 339:
	self.$ = new yy.If($$[$0-1],$$[$0],{type: $$[$0-2]});
	break;
	case 340:
	self.$ = $$[$0-4].addElse(new yy.If($$[$0-1],$$[$0],{type: $$[$0-2]}));
	break;
	case 341:
	self.$ = $$[$0-3].addElse(new yy.If($$[$0-1],$$[$0],{type: $$[$0-2]}));
	break;
	case 342:
	self.$ = $$[$0-2].addElse($$[$0]);
	break;
	case 344:
	self.$ = new yy.If($$[$0],new yy.Block([$$[$0-2]]),{type: $$[$0-1],statement: true});
	break;
	case 345:
	self.$ = new yy.If($$[$0],new yy.Block([$$[$0-2]]),{type: $$[$0-1]});
	break;
	case 346:
	self.$ = yy.If.ternary($$[$0-4],$$[$0-2],$$[$0]);
	break;
	case 347: case 348:
	self.$ = yy.OP($$[$0-1],$$[$0]);
	break;
	case 349:
	self.$ = new yy.Op('-',$$[$0]);
	break;
	case 350:
	self.$ = new yy.Op('+',$$[$0]);
	break;
	case 351:
	self.$ = new yy.UnaryOp('--',null,$$[$0]);
	break;
	case 352:
	self.$ = new yy.UnaryOp('++',null,$$[$0]);
	break;
	case 353:
	self.$ = new yy.UnaryOp('--',$$[$0-1],null,true);
	break;
	case 354:
	self.$ = new yy.UnaryOp('++',$$[$0-1],null,true);
	break;
	case 355: case 356:
	self.$ = new yy.Op($$[$0-1],$$[$0-2],$$[$0]);
	break;
	case 357: case 358: case 359: case 360:
	self.$ = yy.OP($$[$0-1],$$[$0-2],$$[$0]);
	break;
	case 361:
	self.$ = (function () {
					if ($$[$0-1].charAt(0) == '!') {
						return yy.OP($$[$0-1].slice(1),$$[$0-2],$$[$0]).invert();
					} else {
						return yy.OP($$[$0-1],$$[$0-2],$$[$0]);
					};
				}());
	break;
	case 362:
	self.$ = yy.OP_COMPOUND($$[$0-1]._value,$$[$0-1],$$[$0-2],$$[$0]);
	break;
	case 363:
	self.$ = yy.OP_COMPOUND($$[$0-3]._value,$$[$0-4],$$[$0-1].indented($$[$0-2],$$[$0]));
	break;
	}
	},
	table: [{1:[2,1],3:1,4:2,5:3,7:$V0,8:5,10:$V1,12:7,13:8,15:9,16:10,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{1:[3]},{1:[2,2],6:$V51,9:133},{6:[1,135]},o($V61,[2,4]),o($V61,[2,5],{14:$V71}),{4:138,6:[1,139],7:$V0,8:5,11:[1,137],12:7,13:8,15:9,16:10,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($V81,[2,12]),o($V81,[2,13],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($V81,[2,16]),o($V81,[2,17],{218:108,222:109,211:152,217:153,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vi1}),{13:154,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vj1,[2,34]),o($Vj1,[2,35],{195:156,141:157,179:159,21:$Vk1,88:$Vl1,89:$Vm1,111:$Vn1,144:$VC,180:$Vo1,181:$Vp1,183:$Vq1,196:$Vr1}),o($Vj1,[2,36]),o($Vj1,[2,37]),o($Vj1,[2,38]),o($Vj1,[2,39]),o($Vj1,[2,40]),o($Vj1,[2,41]),o($Vj1,[2,42]),o($Vj1,[2,43]),o($Vj1,[2,44]),o($Vj1,[2,45]),o($Vj1,[2,46]),o($Vj1,[2,47]),o($Vj1,[2,48]),o($Vj1,[2,49]),o($Vs1,[2,148]),o($Vs1,[2,149]),o($Vt1,[2,18]),o($Vt1,[2,19]),o($Vt1,[2,20]),o($Vt1,[2,21],{21:[1,166]}),o($Vt1,[2,23],{21:[1,167]}),o($Vt1,[2,25]),o($Vt1,[2,26]),{13:168,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vu1,$Vv1,{117:[1,169]}),o($Vu1,[2,232]),o($Vu1,[2,233]),o($Vu1,[2,234]),o($Vu1,[2,235]),o($Vu1,[2,236]),o($Vu1,[2,237]),o($Vu1,[2,238]),o($Vu1,[2,239]),o($Vu1,[2,240]),o($Vj1,[2,150]),o($Vj1,[2,151]),o($Vj1,[2,152]),{13:170,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:171,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:172,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:173,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{32:$V7,35:175,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,82:92,83:$Vp,89:$Vw1,91:$Vr,96:$Vs,101:46,109:101,129:45,130:$Vx,131:177,136:$Vy,150:77,154:$VF,157:$Vx1,166:44,168:76,173:102,175:$VK,176:174,178:39,184:$VL,186:41,187:42,188:$VN,189:47,197:$VQ,198:$VR},{32:$V7,35:175,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,82:92,83:$Vp,89:$Vw1,91:$Vr,96:$Vs,101:46,109:101,129:45,130:$Vx,131:177,136:$Vy,150:77,154:$VF,157:$Vx1,166:44,168:76,173:102,175:$VK,176:179,178:39,184:$VL,186:41,187:42,188:$VN,189:47,197:$VQ,198:$VR},o($Vy1,$Vz1,{244:[1,180],245:[1,181],249:[1,182]}),o($Vj1,[2,343],{232:[1,183],237:[1,184]}),{5:185,10:$V1},{5:186,10:$V1},o($Vj1,[2,306]),{5:187,10:$V1},{10:[1,189],13:188,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vj1,[2,249]),{121:191,124:$Vw,192:190,193:$VO},{121:193,124:$Vw,192:192,193:$VO},{155:195,158:$VI,192:194,193:$VO},{123:[1,197],154:$VF,155:198,157:$Vx1,158:$VI,173:199,175:$VK,192:196,193:$VO},{32:$V7,35:175,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,82:92,83:$Vp,89:$Vw1,91:$Vr,96:$Vs,101:46,109:101,129:45,130:$Vx,131:177,136:$Vy,150:77,154:$VF,157:$Vx1,166:44,168:76,173:102,175:$VK,176:200,178:39,184:$VL,186:41,187:42,188:$VN,189:47,197:$VQ,198:$VR},o($Vj1,[2,123]),o($VA1,[2,102],{104:201,108:203,109:204,51:[1,205],89:[1,202],110:[1,206],198:$VR}),{50:208,51:$V8,89:[1,209],149:207},o($Vt1,[2,77],{34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,17:30,18:31,25:36,131:38,178:39,72:40,186:41,187:42,166:44,129:45,101:46,189:47,140:48,141:49,142:50,176:57,235:58,211:60,215:61,217:62,192:64,121:70,148:72,168:76,150:77,63:79,82:92,155:93,57:97,52:98,55:99,59:100,109:101,173:102,50:103,218:108,222:109,61:116,65:117,16:155,13:210,81:211,19:$V2,20:$V3,21:$VB1,23:$V4,24:$V5,26:$V6,32:$V7,51:$V8,53:$V9,54:$Va,56:$Vb,58:$Vc,60:$Vd,62:$Ve,64:$Vf,66:$Vg,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,83:$Vp,89:$Vq,91:$Vr,96:$Vs,103:$Vt,122:$Vu,123:$Vv,124:$Vw,130:$Vx,136:$Vy,143:$VB,144:$VC,151:$VD,152:$VE,154:$VF,156:$VG,157:$VH,158:$VI,175:$VK,184:$VL,185:$VM,188:$VN,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,216:$VW,230:$VZ,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41}),{13:213,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{27:214,29:215,31:216,32:$VC1,33:218,50:220,51:$V8,57:219,58:$Vc},o($Vy1,[2,228]),o($Vy1,[2,229]),o($VD1,[2,226]),o($Vu1,[2,67]),o($Vu1,[2,68]),o($Vu1,[2,69]),o($Vu1,[2,70]),o($Vu1,[2,71]),o($Vu1,[2,72]),o($Vu1,[2,73]),o($Vu1,[2,74]),{4:221,7:$V0,8:5,10:[1,222],12:7,13:8,15:9,16:10,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{10:$VE1,12:228,13:223,15:230,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,97:$VF1,101:46,103:$Vt,109:101,119:225,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,171:$VG1,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,202:226,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o([1,6,10,11,14,21,22,71,88,89,90,91,97,106,111,112,126,135,137,144,147,171,180,181,183,196,200,201,212,213,214,219,220,229,238,239,242,243,246,247,248],[2,267]),o($Vu1,[2,134]),{50:231,51:$V8},{84:233,85:[1,234],86:[1,235],87:[1,236],88:[1,237],91:[1,238],92:[1,239],93:[1,240],94:[1,241],95:[1,242],96:[1,243],100:[1,244],102:[1,232]},o($Vj1,[2,165]),{5:245,10:$V1,145:[1,246]},o($VH1,$VI1,{61:116,65:117,191:248,133:249,134:250,15:251,50:252,57:253,63:254,52:255,55:256,32:$V7,51:$V8,53:$V9,54:$Va,56:$Vb,58:$Vc,62:$Ve,64:$Vf,66:$Vg,136:$VJ1,138:$Vz,139:$VA,145:$VK1}),{5:258,10:$V1},o($VD1,[2,208]),o($VD1,[2,209]),o($VD1,[2,210]),o($VD1,[2,211]),o($VD1,[2,212]),o($VD1,[2,213]),o($VD1,[2,214]),{13:259,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:260,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:261,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{5:262,10:$V1,13:263,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{50:268,51:$V8,89:$Vw1,96:$Vs,150:270,168:269,187:264,224:265,225:[1,266],226:267},{223:271,227:[1,272],228:[1,273]},{32:$V7,35:175,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,82:92,83:$Vp,89:$Vw1,91:$Vr,96:$Vs,101:46,109:101,129:45,130:$Vx,131:177,136:$Vy,150:77,154:$VF,157:$Vx1,166:44,168:76,173:102,175:$VK,176:274,178:39,184:$VL,186:41,187:42,188:$VN,189:47,197:$VQ,198:$VR},{110:$VL1,125:275,128:$VM1},o($VN1,[2,160]),o($VN1,[2,161]),o($Vu1,[2,57]),o($Vu1,[2,58]),o($Vu1,[2,59]),o($Vu1,[2,60],{68:279,67:[1,278],69:[1,280],70:[1,281]}),o($VO1,[2,78]),{50:287,51:$V8,55:286,56:$Vb,57:288,58:$Vc,89:$VP1,109:285,159:282,161:283,166:284,197:$VQ,198:$VR},o([1,6,10,11,14,21,22,28,71,88,89,90,91,97,106,111,112,117,126,135,137,144,147,164,165,171,180,181,183,196,200,201,212,213,214,219,220,229,238,239,242,243,244,245,246,247,248,249],[2,54]),o($VQ1,[2,51]),o($VQ1,[2,52]),o([1,6,10,11,14,21,22,71,88,89,90,91,97,106,111,112,117,126,135,137,144,147,171,180,181,183,196,200,201,212,213,214,219,220,229,238,239,242,243,244,245,246,247,248,249],[2,53]),o($VD1,[2,55]),o($VQ1,[2,268]),{50:293,51:$V8,57:292,58:$Vc,96:$VR1,168:294,170:[1,290],174:291},{50:293,51:$V8,57:292,58:$Vc,96:$VR1,168:294,170:[1,297],174:296},o([1,6,10,11,14,21,22,28,71,88,89,90,91,97,98,106,111,112,117,126,135,137,144,147,164,165,171,180,181,183,196,200,201,212,213,214,219,220,227,228,229,238,239,242,243,244,245,246,247,248,249],[2,50]),o($VS1,[2,312]),o($VS1,[2,313]),o($VD1,[2,56]),o($VT1,[2,61]),o($V61,[2,7],{12:7,13:8,15:9,16:10,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,17:30,18:31,25:36,131:38,178:39,72:40,186:41,187:42,166:44,129:45,101:46,189:47,140:48,141:49,142:50,176:57,235:58,211:60,215:61,217:62,192:64,121:70,148:72,168:76,150:77,63:79,82:92,155:93,57:97,52:98,55:99,59:100,109:101,173:102,50:103,218:108,222:109,61:116,65:117,8:298,19:$V2,20:$V3,23:$V4,24:$V5,26:$V6,32:$V7,51:$V8,53:$V9,54:$Va,56:$Vb,58:$Vc,60:$Vd,62:$Ve,64:$Vf,66:$Vg,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,83:$Vp,89:$Vq,91:$Vr,96:$Vs,103:$Vt,122:$Vu,123:$Vv,124:$Vw,130:$Vx,136:$Vy,138:$Vz,139:$VA,143:$VB,144:$VC,151:$VD,152:$VE,154:$VF,156:$VG,157:$VH,158:$VI,170:$VJ,175:$VK,184:$VL,185:$VM,188:$VN,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,212:$VU,214:$VV,216:$VW,219:$VX,220:$VY,230:$VZ,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41}),o([1,6,11,19,20,23,24,26,32,51,53,54,56,58,60,62,64,66,73,74,75,76,77,78,79,80,83,89,91,96,103,122,123,124,130,136,137,138,139,143,144,151,152,154,156,157,158,170,171,175,184,185,188,193,194,197,198,204,210,212,214,216,219,220,230,236,240,241,242,243,244,245],[2,8]),{1:[2,3]},{12:300,13:299,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($VU1,[2,9]),{6:$V51,9:133,11:[1,301]},{4:302,7:$V0,8:5,12:7,13:8,15:9,16:10,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:303,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:304,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:305,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:306,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:307,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:308,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:309,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:310,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:311,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vj1,[2,305]),o($Vj1,[2,310]),{13:312,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vj1,[2,304]),o($Vj1,[2,309]),o([1,6,10,11,14,22,97,137],[2,197],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),{211:152,212:$VU,214:$VV,217:153,218:108,219:$VX,220:$VY,222:109,238:$Vi1},{21:$VB1,81:313},o($Vu1,[2,262]),o($VV1,[2,224],{178:315,61:316,62:$Ve,177:[1,314],184:$VL}),{50:317,51:$V8,52:318,53:$V9,54:$Va,57:319,58:$Vc},{50:320,51:$V8},{50:321,51:$V8},{13:323,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,182:322,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,190:324,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,199:325,200:$VW1,201:$VX1,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{21:[2,264]},{145:$VK1},o($VV1,[2,225]),{13:328,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:329,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($VY1,[2,230],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),{10:[1,331],13:330,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vj1,[2,347],{218:108,222:109,211:149,217:150}),o($Vj1,[2,348],{218:108,222:109,211:149,217:150}),o($Vj1,[2,349],{218:108,222:109,211:149,217:150}),o($Vj1,[2,350],{218:108,222:109,211:149,217:150}),o($Vj1,[2,351],{21:$Vz1,88:$Vz1,89:$Vz1,111:$Vz1,144:$Vz1,180:$Vz1,181:$Vz1,183:$Vz1,196:$Vz1}),{21:$Vk1,88:$Vl1,89:$Vm1,111:$Vn1,141:157,144:$VC,179:159,180:$Vo1,181:$Vp1,183:$Vq1,195:156,196:$Vr1},{154:$VF,157:$Vx1,173:199,175:$VK},o([21,88,89,111,144,180,181,183,196],$Vv1),o($VH1,$VI1,{61:116,65:117,191:248,133:249,134:250,15:251,50:252,57:253,63:254,52:255,55:256,32:$V7,51:$V8,53:$V9,54:$Va,56:$Vb,58:$Vc,62:$Ve,64:$Vf,66:$Vg,136:$VJ1,138:$Vz,139:$VA}),o($Vj1,[2,352],{21:$Vz1,88:$Vz1,89:$Vz1,111:$Vz1,144:$Vz1,180:$Vz1,181:$Vz1,183:$Vz1,196:$Vz1}),o($Vj1,[2,353]),o($Vj1,[2,354]),{10:[1,333],13:332,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{5:335,10:$V1,236:[1,334]},{13:336,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vj1,[2,290],{205:337,206:338,207:$VZ1,208:[1,339]}),o($Vj1,[2,303]),o($Vj1,[2,311]),{10:[1,341],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},{231:342,233:343,234:$V_1},o($Vj1,[2,250]),o($Vj1,[2,124]),o($Vj1,[2,251]),o($Vj1,[2,125]),o($Vj1,[2,252]),o($Vj1,[2,166]),o($Vj1,[2,253]),{192:345,193:$VO},o($Vj1,[2,167]),o($VD1,[2,202]),o($V$1,[2,259],{5:346,10:$V1,21:$Vz1,88:$Vz1,89:$Vz1,111:$Vz1,144:$Vz1,180:$Vz1,181:$Vz1,183:$Vz1,196:$Vz1}),o($V02,[2,112],{105:347,52:352,114:353,53:$V9,54:$Va,88:[1,348],91:[1,351],111:[1,349],113:[1,350],116:$V12}),{13:355,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($VA1,[2,103]),o($VA1,[2,99]),o($VA1,[2,100]),o($VA1,[2,101]),o($Vj1,[2,159],{150:356,21:[1,357],89:$Vw1}),o($V22,[2,162]),{13:358,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vt1,[2,75],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($Vt1,[2,76]),{10:$VE1,12:228,13:361,15:230,16:155,17:30,18:31,19:$V2,20:$V3,22:[1,359],23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,119:360,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,171:$VG1,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,202:226,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vt1,[2,296],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),{14:[1,363],28:[1,362]},o($Vt1,[2,29],{30:[1,364]}),o($V32,[2,31]),o([1,6,11,14,30,137,212,214,219,220,238],[2,30]),o($V42,[2,33]),o($V42,[2,203]),o($V42,[2,204]),{6:$V51,9:133,137:[1,365]},{4:366,7:$V0,8:5,12:7,13:8,15:9,16:10,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o([6,10,14,97],$V52,{218:108,222:109,211:149,217:150,199:367,126:$V91,171:$Va1,200:$VW1,201:$VX1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($V62,[2,269]),o([6,10,97],$V72,{115:368,14:$V82}),o($V92,[2,277]),{10:$VE1,12:228,13:361,15:230,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,119:370,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,171:$VG1,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,202:226,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($V92,[2,285]),o($V92,[2,286]),o($V92,[2,287]),o($Vu1,[2,135]),o($Vu1,[2,92]),o($VO1,[2,79]),o($VO1,[2,80]),o($VO1,[2,81]),o($VO1,[2,82]),{89:[1,371]},{89:[1,372]},o($VO1,[2,85]),o($VO1,[2,86]),o($VO1,[2,87]),o($VO1,[2,88]),{50:373,51:$V8},o($VO1,[2,91]),o($Vu1,[2,154]),o($Va2,$Vb2,{146:374,167:375,150:376,168:377,169:378,50:382,51:$V8,89:$Vw1,96:$VR1,170:$Vc2,171:$Vd2,172:$Ve2}),o($Va2,$Vb2,{167:375,150:376,168:377,169:378,50:382,146:383,51:$V8,89:$Vw1,96:$VR1,170:$Vc2,171:$Vd2,172:$Ve2}),o([6,10,90],$V72,{115:384,14:$Vf2}),o($Vg2,[2,245]),o($Vg2,[2,138],{135:[1,386]}),o($Vg2,[2,141]),o($Vh2,[2,142]),o($Vh2,[2,143]),o($Vh2,[2,144]),o($Vh2,[2,145]),o($Vh2,[2,146]),{13:387,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vj1,[2,153]),{5:388,10:$V1,126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($Vi2,[2,299],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,213:[1,389],214:$VV,219:$VX,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($Vi2,[2,301],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,213:[1,390],214:$VV,219:$VX,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($Vj1,[2,307]),o($Vj2,[2,308],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($Vj1,[2,315]),o($Vk2,[2,317]),{50:268,51:$V8,89:$Vw1,96:$VR1,150:270,168:269,224:391,226:267},o($Vk2,[2,322],{14:[1,392]}),o($Vl2,[2,319]),o($Vl2,[2,320]),o($Vl2,[2,321]),o($Vj1,[2,316]),{13:393,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:394,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vm2,[2,255],{5:395,10:$V1,21:$Vz1,88:$Vz1,89:$Vz1,111:$Vz1,144:$Vz1,180:$Vz1,181:$Vz1,183:$Vz1,196:$Vz1,126:[1,396]}),o($Vm2,[2,126],{5:397,10:$V1,126:[1,398]}),o($Vj1,[2,132]),o($Vj1,[2,133]),o($VT1,[2,62]),o($VT1,[2,63]),o($VT1,[2,64]),{13:400,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,71:[1,399],72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{88:[1,402],91:[1,403],160:401},o($Vn2,[2,180],{162:405,21:[1,404],164:$Vo2,165:$Vp2}),o($Vn2,[2,181]),o($Vn2,[2,182]),o($Vn2,[2,183]),o($Vq2,[2,174]),o($Vq2,[2,175]),{13:408,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{50:293,51:$V8,57:292,58:$Vc,96:$VR1,168:294,174:409},o($VD1,[2,199]),o($VD1,[2,205]),o($VD1,[2,206]),o($VD1,[2,207]),{10:$VE1,12:228,13:361,15:230,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,97:$VF1,101:46,103:$Vt,109:101,119:225,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,171:$VG1,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,202:226,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($VD1,[2,200]),{50:293,51:$V8,57:292,58:$Vc,96:$VR1,168:294,174:410},o($V61,[2,6],{14:$V71}),o($V81,[2,14],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($V81,[2,15]),o($VU1,[2,10]),{6:$V51,9:133,11:[1,411]},o($Vr2,[2,355],{218:108,222:109,211:149,217:150,246:$Vf1}),o($Vr2,[2,356],{218:108,222:109,211:149,217:150,246:$Vf1}),o($Vj1,[2,357],{218:108,222:109,211:149,217:150}),o([1,6,10,11,14,22,71,90,97,106,112,126,135,137,147,171,200,201,212,213,214,219,220,229,238,239,247,248],[2,358],{218:108,222:109,211:149,217:150,242:$Vd1,243:$Ve1,246:$Vf1}),o([1,6,10,11,14,22,71,90,97,106,112,126,135,137,147,171,200,201,212,213,214,219,220,229,238,239],[2,359],{218:108,222:109,211:149,217:150,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o([1,6,10,11,14,22,71,90,97,106,112,135,137,147,171,200,201,212,213,214,219,220,229,238,239],[2,360],{218:108,222:109,211:149,217:150,126:$V91,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o([1,6,10,11,14,22,71,90,97,106,112,126,135,137,147,171,200,201,212,213,214,219,220,229,238,239,248],[2,361],{218:108,222:109,211:149,217:150,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1}),o($Vs2,[2,345],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),{126:$V91,135:[1,412],171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($Vs2,[2,344],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($Vu1,[2,261]),o($VD1,[2,215]),o($VD1,[2,216]),o($VD1,[2,221]),o($VD1,[2,217]),o($VD1,[2,220]),o($VD1,[2,222]),o($VD1,[2,218]),o($VD1,[2,219]),{112:[1,413]},{112:[2,241],126:$V91,171:$Va1,199:414,200:$VW1,201:$VX1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},{112:[2,242]},{13:415,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vt2,[2,271]),o($Vt2,[2,272]),{22:[1,416],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},{22:[1,417],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($VY1,[2,136],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),{13:418,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($VY1,[2,362],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),{13:419,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:420,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vu2,[2,342]),{5:421,10:$V1,126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($Vj1,[2,291],{206:422,207:$VZ1}),o($Vj1,[2,292]),{209:[1,423]},{5:424,10:$V1},{231:425,233:343,234:$V_1},{11:[1,426],232:[1,427],233:428,234:$V_1},o($Vv2,[2,335]),{13:430,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,203:429,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vj1,[2,254]),o($Vj1,[2,260]),{6:$V72,14:[1,432],106:[1,431],115:433},{51:[1,435],62:[1,434],89:[1,436]},{13:437,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{89:[1,438]},{51:[1,439],89:[1,440]},o($VA1,[2,110]),o($V02,[2,113]),o($V02,[2,116],{117:[1,441]}),{90:[1,442],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($Vj1,[2,157]),{89:$Vw1,150:443},{90:[1,444],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($Vu1,[2,265]),o([6,10,22],$V72,{115:445,14:$V82}),o($V92,$V52,{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),{29:446,32:$VC1},{31:447,33:218,50:220,51:$V8,57:219,58:$Vc},{31:448,33:218,50:220,51:$V8,57:219,58:$Vc},o($Vu1,[2,297]),{6:$V51,9:133,11:[1,449]},{13:450,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{6:$V51,9:452,10:$Vw2,97:[1,451]},o([6,10,11,22,97],$Vx2,{34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,17:30,18:31,25:36,131:38,178:39,72:40,186:41,187:42,166:44,129:45,101:46,189:47,140:48,141:49,142:50,176:57,235:58,211:60,215:61,217:62,192:64,121:70,148:72,168:76,150:77,63:79,82:92,155:93,57:97,52:98,55:99,59:100,109:101,173:102,50:103,218:108,222:109,61:116,65:117,16:155,12:228,15:230,13:361,202:454,19:$V2,20:$V3,23:$V4,24:$V5,26:$V6,32:$V7,51:$V8,53:$V9,54:$Va,56:$Vb,58:$Vc,60:$Vd,62:$Ve,64:$Vf,66:$Vg,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,83:$Vp,89:$Vq,91:$Vr,96:$Vs,103:$Vt,122:$Vu,123:$Vv,124:$Vw,130:$Vx,136:$Vy,138:$Vz,139:$VA,143:$VB,144:$VC,151:$VD,152:$VE,154:$VF,156:$VG,157:$VH,158:$VI,170:$VJ,171:$VG1,175:$VK,184:$VL,185:$VM,188:$VN,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,212:$VU,214:$VV,216:$VW,219:$VX,220:$VY,230:$VZ,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41}),o($Vy2,$V72,{115:455,14:$V82}),{13:456,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:457,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{97:[1,458],98:[1,459]},{14:$Vz2,147:[1,460]},o($VA2,[2,187]),o($VA2,[2,189]),o($VA2,[2,190]),o($VA2,[2,191],{117:[1,462]}),{50:382,51:$V8,169:463},{50:382,51:$V8,169:464},{50:382,51:$V8,169:465},o([14,22,117,147],[2,196]),{14:$Vz2,147:[1,466]},{6:$V51,9:468,10:$VB2,90:[1,467]},o([6,10,11,90],$Vx2,{61:116,65:117,134:250,15:251,50:252,57:253,63:254,52:255,55:256,133:470,32:$V7,51:$V8,53:$V9,54:$Va,56:$Vb,58:$Vc,62:$Ve,64:$Vf,66:$Vg,136:$VJ1,138:$Vz,139:$VA}),{10:[1,472],13:471,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{126:$V91,137:[1,473],171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($Vu2,[2,339]),{13:474,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:475,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vk2,[2,318]),{50:268,51:$V8,89:$Vw1,96:$VR1,150:270,168:269,226:476},o([1,6,10,11,14,22,71,90,97,106,112,135,137,147,200,201,212,214,219,220,238],[2,324],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,213:[1,477],229:[1,478],239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($VC2,[2,325],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,213:[1,479],239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($Vj1,[2,256]),{13:480,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vj1,[2,127]),{110:$VL1,125:481,128:$VM1},o($VT1,[2,65]),{71:[1,482],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},{50:287,51:$V8,57:288,58:$Vc,89:$VP1,161:483},o($VD2,[2,172]),o($VD2,[2,173]),o($VE2,$Vb2,{167:375,150:376,168:377,169:378,50:382,146:484,51:$V8,89:$Vw1,96:$VR1,170:$Vc2,171:$Vd2,172:$Ve2}),o($Vj1,[2,171]),{5:485,10:$V1,89:$Vm1,141:486,144:$VC},o($Vj1,[2,179]),{90:[1,487],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($VD1,[2,198]),o($VD1,[2,201]),o($VU1,[2,11]),{13:488,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($VD1,[2,223]),{13:489,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,112:[2,275],121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{112:[2,276],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($Vt1,[2,22]),o($Vt1,[2,24]),{6:$V51,9:491,11:$VF2,126:$V91,132:490,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},{6:$V51,9:491,11:$VF2,126:$V91,132:493,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},{5:494,10:$V1,126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($Vu2,[2,341]),o($Vj1,[2,293]),{5:495,10:$V1},o($Vj1,[2,294]),{11:[1,496],232:[1,497],233:428,234:$V_1},o($Vj1,[2,333]),{5:498,10:$V1},o($Vv2,[2,336]),{5:499,10:$V1,14:[1,500]},o($VG2,[2,288],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($V$1,[2,96],{107:501,10:[1,502],21:[1,503]}),{6:$Vx2,114:504,116:$V12},{6:[1,505]},o($VA1,[2,104]),o($VA1,[2,106]),{13:506,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{112:[1,507],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},{13:508,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($VA1,[2,109]),{13:509,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:511,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,118:510,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{106:[1,512]},{22:[1,513]},o($V22,[2,163]),{6:$V51,9:452,10:$Vw2,22:[1,514]},o($Vt1,[2,27]),o($V32,[2,32]),o($Vt1,[2,28]),{137:[1,515]},{97:[1,516],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($V62,[2,270]),{12:228,13:361,15:230,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,171:$VG1,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,202:517,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{10:$VE1,12:228,13:361,15:230,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,119:518,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,171:$VG1,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,202:226,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($V92,[2,278]),{6:$V51,9:520,10:$Vw2,11:$VF2,132:519},{90:[1,521],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},{90:[1,522],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($VO1,[2,89]),{32:$V7,51:[1,524],61:116,62:$Ve,63:525,64:$Vf,65:117,66:$Vg,89:[1,526],99:523},{5:527,10:$V1},{50:382,51:$V8,89:$Vw1,96:$VR1,150:376,167:528,168:377,169:378,170:$Vc2,171:$Vd2,172:$Ve2},{13:529,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($VA2,[2,192]),o($VA2,[2,193]),o($VA2,[2,194]),{5:530,10:$V1},o([1,6,10,11,14,21,22,71,88,89,90,97,106,111,112,117,126,135,137,144,147,171,180,181,183,196,200,201,212,213,214,219,220,227,228,229,238,239,242,243,246,247,248],[2,243]),{15:251,32:$V7,50:252,51:$V8,52:255,53:$V9,54:$Va,55:256,56:$Vb,57:253,58:$Vc,61:116,62:$Ve,63:254,64:$Vf,65:117,66:$Vg,133:531,134:250,136:$VJ1,138:$Vz,139:$VA},o([6,10,11,14],$VI1,{61:116,65:117,133:249,134:250,15:251,50:252,57:253,63:254,52:255,55:256,191:532,32:$V7,51:$V8,53:$V9,54:$Va,56:$Vb,58:$Vc,62:$Ve,64:$Vf,66:$Vg,136:$VJ1,138:$Vz,139:$VA}),o($Vg2,[2,246]),o($Vg2,[2,139],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),{13:533,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vh2,[2,147]),o($Vj2,[2,300],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($Vj2,[2,302],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($Vk2,[2,323]),{13:534,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:535,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:536,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o([1,6,11,14,22,71,90,97,106,112,135,137,147,200,201,213,220,229,238],[2,257],{218:108,222:109,211:149,217:150,5:537,10:$V1,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($V$1,[2,128],{5:538,10:$V1}),o($VT1,[2,66]),{21:[1,539],162:540,164:$Vo2,165:$Vp2},{14:$Vz2,22:[1,541]},o($Vj1,[2,177]),o($Vj1,[2,178]),o($Vq2,[2,176]),o([1,6,10,11,14,22,71,90,97,106,112,135,137,147,200,201,212,213,214,219,220,229,238,239],[2,346],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),{112:[2,274],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($Vj1,[2,137]),{11:$VH2},o($Vj1,[2,283]),o($Vj1,[2,363]),o($Vu2,[2,340]),o([1,6,10,11,14,22,71,90,97,106,112,126,135,137,147,171,200,201,207,212,213,214,219,220,229,238,239,242,243,246,247,248],[2,295]),o($Vj1,[2,331]),{5:543,10:$V1},{11:[1,544]},o($Vv2,[2,337],{6:[1,545]}),{13:546,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vj1,[2,97]),{10:$VE1,12:228,13:361,15:230,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,119:547,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,171:$VG1,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,202:226,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{10:$VE1,12:228,13:361,15:230,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,119:548,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,171:$VG1,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,202:226,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($V02,[2,114]),{114:549,116:$V12},{90:[1,550],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($VA1,[2,105]),{90:[1,551],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},{90:[1,552],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($V02,[2,117]),o($V02,[2,118],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($Vj1,[2,98]),o($Vj1,[2,158]),o($Vu1,[2,266]),o($Vu1,[2,298]),o($Vu1,[2,273]),o($V92,[2,279]),o($Vy2,$V72,{115:553,14:$V82}),o($V92,[2,280]),{11:$VH2,12:228,13:361,15:230,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,171:$VG1,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,202:517,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($VO1,[2,83]),o($VO1,[2,84]),{97:[1,554]},{97:[2,93]},{97:[2,94]},{13:555,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vu1,[2,155]),o($VA2,[2,188]),o($VA2,[2,195],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),{90:[1,556]},o($Vg2,[2,247]),o($Vy2,$V72,{115:557,14:$Vf2}),{6:$V51,9:491,11:$VF2,126:$V91,132:558,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o([1,6,10,11,14,22,71,90,97,106,112,135,137,147,200,201,212,213,214,219,220,238],[2,326],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,229:[1,559],239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($VC2,[2,328],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,213:[1,560],239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($VY1,[2,327],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($Vj1,[2,258]),o($Vj1,[2,129]),o($VE2,$Vb2,{167:375,150:376,168:377,169:378,50:382,146:561,51:$V8,89:$Vw1,96:$VR1,170:$Vc2,171:$Vd2,172:$Ve2}),o($Vj1,[2,169]),{162:562,164:$Vo2,165:$Vp2},o($Vj1,[2,282]),{6:$V51,9:491,11:$VF2,132:563},o($Vj1,[2,334]),o($Vv2,[2,338]),o($VG2,[2,289],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($VI2,$V72,{115:565,11:[1,564],14:$V82}),o($VI2,$V72,{115:565,14:$V82,22:[1,566]}),o($V02,[2,115]),o($VA1,[2,107]),o($VA1,[2,108]),o($VA1,[2,111]),{6:$V51,9:520,10:$Vw2,11:$VF2,132:567},o($VO1,[2,90]),{90:[1,568],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($Vu1,[2,156]),{6:$V51,9:570,10:$VB2,11:$VF2,132:569},o($Vg2,[2,140]),{13:571,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:572,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{14:$Vz2,22:[1,573]},o($Vj1,[2,170]),o($Vj1,[2,332]),o($Vj1,[2,119]),{6:$V51,9:452,10:$Vw2},o($Vj1,[2,120]),o($V92,[2,281]),{97:[2,95]},o($Vg2,[2,248]),{11:$VH2,15:251,32:$V7,50:252,51:$V8,52:255,53:$V9,54:$Va,55:256,56:$Vb,57:253,58:$Vc,61:116,62:$Ve,63:254,64:$Vf,65:117,66:$Vg,133:531,134:250,136:$VJ1,138:$Vz,139:$VA},o($VY1,[2,329],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($VY1,[2,330],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),{162:574,164:$Vo2,165:$Vp2},o($Vj1,[2,168])],
	defaultActions: {135:[2,3],163:[2,264],324:[2,242],524:[2,93],525:[2,94],568:[2,95]},
	parseError: function parseError(str, hash) {
	    if (hash.recoverable) {
	        this.trace(str);
	    } else {
	        throw new Error(str);
	    }
	},
	parse: function parse(input) {
	
	    // For Imba we are going to drop most of the features that are not used
	    // Locations are provided by the tokens from the lexer directly - so drop yylloc
	    // We dont really need the shared state (it seems)
	
	    var self = this,
	        stack = [0],
	        tstack = [], // token stack
	        vstack = [null], // semantic value stack
	        table = this.table,
	        yytext = '',
	        yylineno = 0,
	        yyleng = 0,
	        recovering = 0,
	        TERROR = 2,
	        EOF = 1;
	
	    // var args = lstack.slice.call(arguments, 1);
	    //this.reductionCount = this.shiftCount = 0;
	
	    var lexer = Object.create(this.lexer);
	    var yy = this.yy;
	
	    lexer.setInput(input,yy);
	
	    if (typeof yy.parseError === 'function') {
	        this.parseError = yy.parseError;
	    } else {
	        this.parseError = Object.getPrototypeOf(this).parseError; // what?
	    }
	
	    function popStack (n) {
	        stack.length = stack.length - 2 * n;
	        vstack.length = vstack.length - n;
	    }
	
	    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
	
	    function handleError(){
	        var error_rule_depth;
	        var errStr = '';
	
	        // Return the rule stack depth where the nearest error rule can be found.
	        // Return FALSE when no error recovery rule was found.
	        // we have no rules now
	        function locateNearestErrorRecoveryRule(state) {
	            var stack_probe = stack.length - 1;
	            var depth = 0;
	
	            // try to recover from error
	            for(;;) {
	                // check for error recovery rule in this state
	                if ((TERROR.toString()) in table[state]) {
	                    return depth;
	                }
	                if (state === 0 || stack_probe < 2) {
	                    return false; // No suitable error recovery rule available.
	                }
	                stack_probe -= 2; // popStack(1): [symbol, action]
	                state = stack[stack_probe];
	                ++depth;
	            }
	        }
	
	        if (!recovering) {
	            // first see if there's any chance at hitting an error recovery rule:
	            error_rule_depth = locateNearestErrorRecoveryRule(state);
	
	            // Report error
	            expected = [];
	
	            var tsym = lexer.yytext;
	            var tok = self.terminals_[symbol] || symbol;
	            var tloc = tsym ? tsym._loc : -1;
	            var tpos = tloc != -1 ? "[" + tsym._loc + ":" + tsym._len + "]" : '[0:0]';
	
	            if (lexer.showPosition) {
	                errStr = 'Parse error at '+(tpos)+":\n"+lexer.showPosition()+"\nExpecting "+expected.join(', ') + ", got '" + (self.terminals_[symbol] || symbol)+ "'";
	            } else {
	                errStr = 'Parse error at '+(tpos)+": Unexpected " + (symbol == EOF ? "end of input" : ("'"+(tok)+"'"));
	            }
	
	            self.parseError(errStr, {
	                lexer: lexer,
	                text: lexer.match,
	                token: tok,
	                line: lexer.yylineno,
	                expected: expected,
	                recoverable: (error_rule_depth !== false)
	            });
	        } else if (preErrorSymbol !== EOF) {
	            error_rule_depth = locateNearestErrorRecoveryRule(state);
	        }
	
	        // just recovered from another error
	        if (recovering == 3) {
	            if (symbol === EOF || preErrorSymbol === EOF) {
	                throw new Error(errStr || 'Parsing halted while starting to recover from another error.');
	            }
	
	            // discard current lookahead and grab another
	            yytext = lexer.yytext;
	        }
	
	        // try to recover from error
	        if (error_rule_depth === false) {
	            throw new Error(errStr || 'Parsing halted. No suitable error recovery rule available.');
	        }
	        popStack(error_rule_depth);
	        preErrorSymbol = (symbol == TERROR ? null : symbol); // save the lookahead token
	        symbol = TERROR;         // insert generic error symbol as new lookahead
	        state = stack[stack.length-1];
	        action = table[state] && table[state][TERROR];
	        recovering = 3; // allow 3 real symbols to be shifted before reporting a new error
	    }
	
	
	    var __sym = this.symbols_;
	    var __prod = this.productions_;
	
	    while (true) {
	        // retreive state number from top of stack
	        state = stack[stack.length - 1];
	
	        if (symbol === null || typeof symbol == 'undefined') {
	            symbol = __sym[lexer.lex()] || EOF;
	        }
	        action = table[state] && table[state][symbol];
	
	_handle_error:
	        if (typeof action === 'undefined' || !action.length || !action[0]) {
	            handleError();
	        }
	
	        switch (action[0]) {
	            case 1: // shift
	                stack.push(symbol);
	                stack.push(action[1]); // push state
	                vstack.push(lexer.yytext);
	                
	                symbol = null;
	                if (!preErrorSymbol) { // normal execution/no error
	                    yytext = lexer.yytext;
	                    if (recovering > 0) {
	                        recovering--;
	                    }
	                } else {
	                    // error just occurred, resume old lookahead f/ before error
	                    symbol = preErrorSymbol;
	                    preErrorSymbol = null;
	                }
	                break;
	
	            case 2:
	                len = __prod[action[1]][1];
	                // perform semantic action
	                yyval.$ = vstack[vstack.length-len];
	                r = this.performAction(yyval, yytext, yy, action[1], vstack);
	                if (typeof r !== 'undefined') {
	                    return r;
	                }
	
	                while(len > 0) {
	                    stack.pop();
	                    stack.pop();
	                    vstack.pop();
	                    len--;
	                }
	
	                stack.push(__prod[action[1]][0]);
	                newState = table[stack[stack.length-2]][stack[stack.length-1]];
	                stack.push(newState);
	                vstack.push(yyval.$);
	                break;
	
	            case 3:
	                return true;
	        }
	    }
	
	    return true;
	}};
	
	function Parser () {
	  this.yy = {};
	}
	Parser.prototype = parser;parser.Parser = Parser;
	return new Parser;
	})();
	
	
	if (true) {
	exports.parser = parser;
	exports.Parser = parser.Parser;
	exports.parse = function () { return parser.parse.apply(parser, arguments); };
	// exports.main = function commonjsMain(args) {
	//     if (!args[1]) {
	//         console.log('Usage: '+args[0]+' FILE');
	//         process.exit(1);
	//     }
	//     var source = require('fs').readFileSync(require('path').normalize(args[1]), "utf8");
	//     return exports.parser.parse(source);
	// };
	if (typeof module !== 'undefined' && __webpack_require__.c[0] === module) {
	  exports.main(process.argv.slice(1));
	}
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)(module), __webpack_require__(8)))

/***/ },
/* 7 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 8 */
/***/ function(module, exports) {

	// shim for using process in browser
	
	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function idx$(a,b){
			return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
		};
		
		// helper for subclassing
		function subclass$(obj,sup) {
			for (var k in sup) {
				if (sup.hasOwnProperty(k)) obj[k] = sup[k];
			};
			// obj.__super__ = sup;
			obj.prototype = Object.create(sup.prototype);
			obj.__super__ = obj.prototype.__super__ = sup.prototype;
			obj.prototype.initialize = obj.prototype.constructor = obj;
		};
		
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		var AST, OP, OP_COMPOUND, NODES, SPLAT, STACK, K_IVAR, K_SYM, K_STR, K_PROP, BR, BR2, SELF, SUPER, TRUE, FALSE, UNDEFINED, NIL, ARGUMENTS, EMPTY, NULL, RESERVED, RESERVED_REGEX, UNION, INTERSECT, CLASSDEF, TAGDEF, NEWTAG;
		// TODO Create Expression - make all expressions inherit from these?
		
		// externs;
		
		var helpers = __webpack_require__(3);
		var ERR = __webpack_require__(2);
		var v8 = null; // require 'v8-natives'
		
		var T = __webpack_require__(1);
		var Token = T.Token;
		
		var SourceMap = __webpack_require__(10).SourceMap;
		
		module.exports.AST = AST = {};
		
		// Helpers for operators
		module.exports.OP = OP = function(op,l,r) {
			var o = String(op);
			// console.log "operator",o
			switch (o) {
				case '.':
					if ((typeof r=='string'||r instanceof String)) { r = new Identifier(r) };
					// r = r.value if r isa VarOrAccess
					return new Access(op,l,r);
					break;
				
				case '=':
					if (l instanceof Tuple) { return new TupleAssign(op,l,r) };
					return new Assign(op,l,r);
					break;
				
				case '?=':
				case '||=':
				case '&&=':
					return new ConditionalAssign(op,l,r);
					break;
				
				case '+=':
				case '-=':
				case '*=':
				case '/=':
				case '^=':
				case '%=':
					return new CompoundAssign(op,l,r);
					break;
				
				case '?.':
					if (r instanceof VarOrAccess) {
						// console.log "is var or access"
						r = r.value();
					};
					// depends on the right side - this is wrong
					return new PropertyAccess(op,l,r);
					break;
				
				case 'instanceof':
					return new InstanceOf(op,l,r);
					break;
				
				case 'in':
					return new In(op,l,r);
					break;
				
				case 'typeof':
					return new TypeOf(op,l,r);
					break;
				
				case 'delete':
					return new Delete(op,l,r);
					break;
				
				case '--':
				case '++':
				case '!':
				case '√':
					return new UnaryOp(op,l,r);
					break;
				
				case '>':
				case '<':
				case '>=':
				case '<=':
				case '==':
				case '===':
				case '!=':
				case '!==':
					return new ComparisonOp(op,l,r);
					break;
				
				case '∩':
				case '∪':
					return new MathOp(op,l,r);
					break;
				
				case '..':
				case '...':
					return new Range(op,l,r);
					break;
				
				default:
				
					return new Op(op,l,r);
			
			};
		};
		
		module.exports.OP_COMPOUND = OP_COMPOUND = function(sym,op,l,r) {
			// console.log "?. soak operator",sym
			if (sym == '?.') {
				console.log("?. soak operator");
				return null;
			};
			if (sym == '?=' || sym == '||=' || sym == '&&=') {
				return new ConditionalAssign(op,l,r);
			} else {
				return new CompoundAssign(op,l,r);
			};
		};
		
		var OPTS = {};
		var ROOT = null;
		
		module.exports.NODES = NODES = [];
		
		var LIT = function(val) {
			return new Literal(val);
		};
		
		var SYM = function(val) {
			return new Symbol(val);
		};
		
		var IF = function(cond,body,alt) {
			var node = new If(cond,body);
			if (alt) { node.addElse(alt) };
			return node;
		};
		
		var FN = function(pars,body) {
			return new Func(pars,body);
		};
		
		var CALL = function(callee,pars) {
			// possibly return instead(!)
			if(pars === undefined) pars = [];
			return new Call(callee,pars);
		};
		
		var CALLSELF = function(name,pars) {
			if(pars === undefined) pars = [];
			var ref = new Identifier(name);
			return new Call(OP('.',SELF,ref),pars);
		};
		
		var BLOCK = function() {
			return Block.wrap([].slice.call(arguments));
		};
		
		var WHILE = function(test,code) {
			return new While(test).addBody(code);
		};
		
		module.exports.SPLAT = SPLAT = function(value) {
			if (value instanceof Assign) {
				// p "WARN"
				value.setLeft(new Splat(value.left()));
				return value;
			} else {
				return new Splat(value);
				// not sure about this
			};
		};
		
		// OP.ASSIGNMENT = [ "=" , "+=" , "-=" , "*=" , "/=" , "%=", "<<=" , ">>=" , ">>>=", "|=" , "^=" , "&=" ]
		// OP.LOGICAL = [ "||" , "&&" ]
		// OP.UNARY = [ "++" , "--" ]
		
		var SEMICOLON_TEST = /;(\s*\/\/.*)?[\n\s\t]*$/;
		var RESERVED_TEST = /^(default|char)$/;
		
		// captures error from parser
		function parseError(str,o){
			// console.log 'parseError',o:token
			
			// find nearest token
			var err;
			
			if (o.lexer) {
				var token = o.lexer.yytext;
				// console.log o:lexer:pos,token.@loc
				err = new ERR.ImbaParseError({message: str},{
					pos: o.lexer.pos,
					tokens: o.lexer.tokens,
					token: o.lexer.yytext,
					meta: o
				});
				
				throw err;
				
				// should find the closest token with actual position
				// str = "[{token.@loc}:{token.@len || String(token):length}] {str}"
			};
			var e = new Error(str);
			e.lexer = o.lexer;
			e.options = o;
			throw e;
		}; exports.parseError = parseError;
		
		function c__(obj){
			return typeof obj == 'string' ? (obj) : (obj.c());
		};
		
		function mark__(tok){
			if (tok && (OPTS.sourceMapInline || OPTS.sourceMap) && tok.sourceMapMarker) {
				return tok.sourceMapMarker();
			} else {
				return '';
			};
		};
		
		function num__(num){
			return new Num(num);
		};
		
		function str__(str){
			// should pack in token?!?
			return new Str(str);
		};
		
		function blk__(obj){
			return obj instanceof Array ? (Block.wrap(obj)) : (obj);
		};
		
		function sym__(obj){
			// console.log "sym {obj}"
			return helpers.symbolize(String(obj));
		};
		
		function cary__(ary){
			return ary.map(function(v) { return typeof v == 'string' ? (v) : (v.c()); });
		};
		
		function dump__(obj,key){
			if (obj instanceof Array) {
				return obj.map(function(v) { return v && v.dump ? (v.dump(key)) : (v); });
			} else if (obj && obj.dump) {
				return obj.dump();
			};
		};
		
		function compact__(ary){
			if (ary instanceof ListNode) {
				return ary.compact();
			};
			
			return ary.filter(function(v) { return v != undefined && v != null; });
		};
		
		function reduce__(res,ary){
			for (var i = 0, items = iter$(ary), len = items.length, v; i < len; i++) {
				v = items[i];
				v instanceof Array ? (reduce__(res,v)) : (res.push(v));
			};
			return;
		};
		
		function flatten__(ary,compact){
			if(compact === undefined) compact = false;
			var out = [];
			for (var i = 0, items = iter$(ary), len = items.length, v; i < len; i++) {
				v = items[i];
				v instanceof Array ? (reduce__(out,v)) : (out.push(v));
			};
			return out;
		};
		
		AST.parse = function (str,opts){
			if(opts === undefined) opts = {};
			var indent = str.match(/\t+/)[0];
			// really? Require the compiler, not this
			return Imbac.parse(str,opts);
		};
		
		AST.inline = function (str,opts){
			if(opts === undefined) opts = {};
			return this.parse(str,opts).body();
		};
		
		AST.node = function (typ,pars){
			if (typ == 'call') {
				if (pars[0].c() == 'return') {
					pars[0] = 'tata';
				};
				return new Call(pars[0],pars[1],pars[2]);
			};
		};
		
		
		AST.escapeComments = function (str){
			if (!(str)) { return '' };
			return str;
		};
		
		function Indentation(a,b){
			this._open = a;
			this._close = b;
			this;
		};
		
		exports.Indentation = Indentation; // export class 
		Indentation.prototype.open = function(v){ return this._open; }
		Indentation.prototype.setOpen = function(v){ this._open = v; return this; };
		Indentation.prototype.close = function(v){ return this._close; }
		Indentation.prototype.setClose = function(v){ this._close = v; return this; };
		
		Indentation.prototype.isGenerated = function (){
			return this._open && this._open.generated;
		};
		
		Indentation.prototype.aloc = function (){
			return this._open && this._open._loc || 0;
		};
		
		Indentation.prototype.bloc = function (){
			return this._close && this._close._loc || 0;
		};
		
		// should rather parse and extract the comments, no?
		Indentation.prototype.wrap = function (str){
			// var pre, post
			
			// console.log "INDENT {@open and JSON.stringify(@open.@meta)}"
			// console.log "OUTDENT {@close}"
			// var ov = @open and @open.@value
			// if ov and ov:length > 1
			// 	console.log "value for indent",ov
			// 	if ov.indexOf('%|%')
			// 		pre = ov.substr
			var om = this._open && this._open._meta;
			var pre = om && om.pre || '';
			var post = om && om.post || '';
			var esc = AST.escapeComments;
			var out = this._close;
			
			// the first newline should not be indented?
			str = post.replace(/^\n/,'') + str;
			str = str.replace(/^/g,"\t").replace(/\n/g,"\n\t").replace(/\n\t$/g,"\n");
			
			str = pre + '\n' + str;
			if (out instanceof Terminator) { str += out.c() };
			if (str[str.length - 1] != '\n') { str = str + '\n' };
			return str;
		};
		
		var INDENT = new Indentation({},{});
		
		function Stash(){
			this._entities = [];
		};
		
		Stash.prototype.add = function (item){
			this._entities.unshift(item);
			return this;
		};
		
		Stash.prototype.pluck = function (item){
			var match = null;
			for (var i = 0, ary = iter$(this._entities), len = ary.length, entity; i < len; i++) {
				entity = ary[i];
				if (entity == item || (entity instanceof item)) {
					match = entity;
					this._entities.splice(i,1);
					return match;
				};
			};
			return null;
		};
		
		
		function Stack(){
			this.reset();
		};
		
		exports.Stack = Stack; // export class 
		Stack.prototype.loglevel = function(v){ return this._loglevel; }
		Stack.prototype.setLoglevel = function(v){ this._loglevel = v; return this; };
		Stack.prototype.nodes = function(v){ return this._nodes; }
		Stack.prototype.setNodes = function(v){ this._nodes = v; return this; };
		Stack.prototype.scopes = function(v){ return this._scopes; }
		Stack.prototype.setScopes = function(v){ this._scopes = v; return this; };
		
		Stack.prototype.reset = function (){
			this._nodes = [];
			this._scoping = [];
			this._scopes = []; // for analysis - should rename
			this._stash = new Stash(this);
			this._loglevel = 3;
			this._counter = 0;
			this._counters = {};
			return this;
		};
		
		Stack.prototype.incr = function (name){
			var $1;
			this._counters[($1 = name)] || (this._counters[$1] = 0);
			return this._counters[name] += 1;
		};
		
		Stack.prototype.stash = function (){
			return this._stash;
		};
		
		Stack.prototype.option = function (key){
			return this._options && this._options[key];
		};
		
		Stack.prototype.addScope = function (scope){
			this._scopes.push(scope);
			return this;
		};
		
		Stack.prototype.traverse = function (node){
			return this;
		};
		
		Stack.prototype.push = function (node){
			this._nodes.push(node);
			// not sure if we have already defined a scope?
			return this;
		};
		
		Stack.prototype.pop = function (node){
			this._nodes.pop(); // (node)
			return this;
		};
		
		Stack.prototype.parent = function (){
			return this._nodes[this._nodes.length - 2];
		};
		
		Stack.prototype.current = function (){
			return this._nodes[this._nodes.length - 1];
		};
		
		Stack.prototype.up = function (test){
			test || (test = function(v) { return !(v instanceof VarOrAccess); });
			
			if (test.prototype instanceof Node) {
				var typ = test;
				test = function(v) { return v instanceof typ; };
			};
			
			var i = this._nodes.length - 2; // key
			while (i >= 0){
				var node = this._nodes[i];
				if (test(node)) { return node };
				i -= 1;
			};
			return null;
		};
		
		Stack.prototype.relative = function (node,offset){
			if(offset === undefined) offset = 0;
			var idx = this._nodes.indexOf(node);
			return idx >= 0 ? (this._nodes[idx + offset]) : (null);
		};
		
		Stack.prototype.scope = function (lvl){
			if(lvl === undefined) lvl = 0;
			var i = this._nodes.length - 1 - lvl;
			while (i >= 0){
				var node = this._nodes[i];
				if (node._scope) { return node._scope };
				i -= 1;
			};
			return null;
		};
		
		Stack.prototype.scopes = function (){
			// include deeper scopes as well?
			var scopes = [];
			var i = this._nodes.length - 1;
			while (i >= 0){
				var node = this._nodes[i];
				if (node._scope) { scopes.push(node._scope) };
				i -= 1;
			};
			return scopes;
		};
		
		Stack.prototype.method = function (){
			return this.up(MethodDeclaration);
		};
		
		Stack.prototype.block = function (){
			return this.up(Block);
		};
		
		Stack.prototype.isExpression = function (){
			var i = this._nodes.length - 1;
			while (i >= 0){
				var node = this._nodes[i];
				// why are we not using isExpression here as well?
				if ((node instanceof Code) || (node instanceof Loop)) {
					return false;
				};
				if (node.isExpression()) {
					return true;
				};
				// probably not the right test - need to be more explicit
				i -= 1;
			};
			return false;
		};
		
		Stack.prototype.toString = function (){
			return ("Stack(" + this._nodes.join(" -> ") + ")");
		};
		
		Stack.prototype.scoping = function (){
			return this._nodes.filter(function(n) { return n._scope; }).map(function(n) { return n._scope; });
		};
		
		// Lots of globals -- really need to deal with one stack per file / context
		module.exports.STACK = STACK = new Stack();
		
		GLOBSTACK = STACK;
		
		// use a bitmask for these
		
		function Node(){
			this.setup();
			this;
		};
		
		exports.Node = Node; // export class 
		Node.prototype.o = function(v){ return this._o; }
		Node.prototype.setO = function(v){ this._o = v; return this; };
		Node.prototype.options = function(v){ return this._options; }
		Node.prototype.setOptions = function(v){ this._options = v; return this; };
		Node.prototype.traversed = function(v){ return this._traversed; }
		Node.prototype.setTraversed = function(v){ this._traversed = v; return this; };
		
		Node.prototype.safechain = function (){
			return false;
		};
		
		// def dom
		// 	var name = "ast_" + self:constructor:name.replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase
		// 	# p "try to get the dom-node for this ast-node",name
		// 	if Imba.TAGS[name]
		// 		var node = Imba.tag(name)
		// 		node.bind(self).build
		// 		return node
		// 	else
		// 		return "[{name}]"
		
		Node.prototype.p = function (){
			
			// allow controlling this from commandline
			if (STACK.loglevel() > 0) {
				console.log.apply(console,arguments);
			};
			return this;
		};
		
		Node.prototype.typeName = function (){
			return this.constructor.name;
		};
		
		Node.prototype.namepath = function (){
			return this.typeName();
		};
		
		Node.prototype.setup = function (){
			this._expression = false;
			this._traversed = false;
			this._parens = false;
			this._cache = null;
			this._value = null;
			return this;
		};
		
		Node.prototype.set = function (obj){
			// console.log "setting options {JSON.stringify(obj)}"
			this._options || (this._options = {});
			for (var i = 0, keys = Object.keys(obj), l = keys.length; i < l; i++){
				this._options[keys[i]] = obj[keys[i]];
			};
			return this;
		};
		
		// get and set
		Node.prototype.option = function (key,val){
			if (val != undefined) {
				// console.log "setting option {key} {val}"
				this._options || (this._options = {});
				this._options[key] = val;
				return this;
			};
			
			return this._options && this._options[key];
		};
		
		Node.prototype.configure = function (obj){
			return this.set(obj);
		};
		
		Node.prototype.region = function (){
			return [0,0];
		};
		
		Node.prototype.loc = function (){
			return [0,0];
		};
		
		Node.prototype.token = function (){
			return null;
		};
		
		Node.prototype.compile = function (){
			return this;
		};
		
		Node.prototype.visit = function (){
			return this;
		};
		
		Node.prototype.stack = function (){
			return STACK;
		};
		
		Node.prototype.isString = function (){
			return false;
		};
		
		Node.prototype.isPrimitive = function (deep){
			return false;
		};
		
		Node.prototype.isReserved = function (){
			return false;
		};
		
		// should rather do traversals
		// o = {}, up, key, index
		Node.prototype.traverse = function (){
			if (this._traversed) {
				return this;
			};
			// NODES.push(self)
			this._traversed = true;
			STACK.push(this);
			this.visit(STACK);
			STACK.pop(this);
			return this;
		};
		
		Node.prototype.inspect = function (){
			return {type: this.constructor.toString()};
		};
		
		Node.prototype.js = function (o){
			return "NODE";
		};
		
		Node.prototype.toString = function (){
			return ("" + (this.constructor.name));
		};
		
		// swallow might be better name
		Node.prototype.consume = function (node){
			if (node instanceof PushAssign) {
				return new PushAssign(node.op(),node.left(),this);
			};
			
			if (node instanceof Assign) {
				// p "consume assignment".cyan
				// node.right = self
				return OP(node.op(),node.left(),this);
			} else if (node instanceof Op) {
				return OP(node.op(),node.left(),this);
			} else if (node instanceof Return) {
				// p "consume return".cyan
				return new Return(this);
			};
			return this;
		};
		
		Node.prototype.toExpression = function (){
			this._expression = true;
			return this;
		};
		
		Node.prototype.forceExpression = function (){
			this._expression = true;
			return this;
		};
		
		Node.prototype.isExpressable = function (){
			return true;
		};
		
		Node.prototype.isExpression = function (){
			return this._expression || false;
		};
		
		Node.prototype.hasSideEffects = function (){
			return true;
		};
		
		Node.prototype.isUsed = function (){
			return true;
		};
		
		Node.prototype.shouldParenthesize = function (){
			return false;
		};
		
		Node.prototype.block = function (){
			return Block.wrap([this]);
		};
		
		Node.prototype.node = function (){
			return this;
		};
		
		Node.prototype.scope__ = function (){
			return STACK.scope();
		};
		
		Node.prototype.up = function (){
			return STACK.parent();
		};
		
		Node.prototype.util = function (){
			return Util;
		};
		
		Node.prototype.receiver = function (){
			return this;
		};
		
		Node.prototype.addExpression = function (expr){
			// might be better to nest this up after parsing is done?
			// p "addExpression {self} <- {expr}"
			var node = new ExpressionBlock([this]);
			return node.addExpression(expr);
		};
		
		
		Node.prototype.indented = function (a,b){
			
			if (a instanceof Indentation) {
				this._indentation = a;
				return this;
			};
			
			// this is a _BIG_ hack
			if (b instanceof Array) {
				this.add(b[0]);
				b = b[1];
			};
			
			// if indent and indent.match(/\:/)
			this._indentation || (this._indentation = a && b ? (new Indentation(a,b)) : (INDENT));
			return this;
		};
		
		Node.prototype.prebreak = function (term){
			// in options instead?
			// console.log "prebreak!!!!"
			// @prebreak = @prebreak or term
			if(term === undefined) term = '\n';
			return this;
		};
		
		Node.prototype.invert = function (){
			return OP('!',this);
		};
		
		Node.prototype.cache = function (o){
			if(o === undefined) o = {};
			this._cache = o;
			o.var = this.scope__().temporary(this,o);
			o.lookups = 0;
			return this;
		};
		
		Node.prototype.cachevar = function (){
			return this._cache && this._cache.var;
		};
		
		Node.prototype.decache = function (){
			if (this._cache) {
				this.cachevar().free();
				this._cache = null;
			};
			return this;
		};
		
		// is this without side-effects? hmm - what does it even do?
		Node.prototype.predeclare = function (){
			if (this._cache) {
				this.scope__().vars().swap(this._cache.var,this);
			};
			return this;
		};
		
		// the "name-suggestion" for nodes if they need to be cached
		Node.prototype.alias = function (){
			return null;
		};
		
		Node.prototype.warn = function (text,opts){
			if(opts === undefined) opts = {};
			opts.message = text;
			opts.loc || (opts.loc = this.loc());
			this.scope__().root().warn(opts);
			return this;
		};
		
		Node.prototype.c = function (o){
			var indent;
			var s = STACK;
			var ch = this._cache;
			if (ch && ch.cached) { return this.c_cached(ch) };
			
			s.push(this);
			if (o && o.expression) this.forceExpression();
			
			v8 && console.log(v8.hasFastObjectElements(this));
			
			if (o && o.indent) {
				this._indentation || (this._indentation = INDENT);
			};
			
			var out = this.js(s,o);
			
			// really? why not call this somewhere else?
			var paren = this.shouldParenthesize();
			
			if (indent = this._indentation) {
				out = indent.wrap(out,o);
			};
			
			// should move this somewhere else really
			if (paren) { out = ("(" + out + ")") };
			if (o && o.braces) {
				if (indent) {
					out = '{' + out + '}';
				} else {
					out = '{ ' + out + ' }';
				};
			};
			
			s.pop(this);
			
			if (ch = this._cache) {
				if (!ch.manual) { out = ("" + (ch.var.c()) + " = " + out) };
				var par = s.current();
				if ((par instanceof Access) || (par instanceof Op)) { out = '(' + out + ')' }; // others? # 
				ch.cached = true;
			};
			return out;
		};
		
		Node.prototype.c_cached = function (cache){
			cache.lookups++;
			if (cache.uses == cache.lookups) { cache.var.free() };
			return cache.var.c(); // recompile every time??
		};
		
		function ValueNode(value){
			this.setup();
			this._value = this.load(value);
		};
		
		subclass$(ValueNode,Node);
		exports.ValueNode = ValueNode; // export class 
		ValueNode.prototype.value = function(v){ return this._value; }
		ValueNode.prototype.setValue = function(v){ this._value = v; return this; };
		
		ValueNode.prototype.load = function (value){
			return value;
		};
		
		ValueNode.prototype.js = function (o){
			return typeof this._value == 'string' ? (this._value) : (this._value.c());
		};
		
		ValueNode.prototype.visit = function (){
			
			if (this._value instanceof Node) { this._value.traverse() }; //  && @value:traverse
			return this;
		};
		
		ValueNode.prototype.region = function (){
			return [this._value._loc,this._value._loc + this._value._len];
		};
		
		
		function Statement(){ return ValueNode.apply(this,arguments) };
		
		subclass$(Statement,ValueNode);
		exports.Statement = Statement; // export class 
		Statement.prototype.isExpressable = function (){
			return false;
		};
		
		
		function Meta(){ return ValueNode.apply(this,arguments) };
		
		subclass$(Meta,ValueNode);
		exports.Meta = Meta; // export class 
		Meta.prototype.isPrimitive = function (deep){
			return true;
		};
		
		function Comment(){ return Meta.apply(this,arguments) };
		
		subclass$(Comment,Meta);
		exports.Comment = Comment; // export class 
		Comment.prototype.visit = function (){
			// stack.stash.add(self)
			
			var block, next;
			if (block = this.up()) {
				var idx = block.indexOf(this) + 1;
				if (block.index(idx) instanceof Terminator) { idx += 1 };
				if (next = block.index(idx)) {
					next._desc = this;
				};
				
				// console.log "Next item after comment is {block.index(idx)}"
			};
			
			return this;
		};
		
		Comment.prototype.toDoc = function (){
			return helpers.normalizeIndentation("" + this._value._value);
		};
		
		Comment.prototype.toJSON = function (){
			return helpers.normalizeIndentation("" + this._value._value);
		};
		
		Comment.prototype.c = function (o){
			var v = this._value._value;
			// p @value.type
			if (o && o.expression || v.match(/\n/) || this._value.type() == 'HERECOMMENT') { // multiline?
				return ("/*" + v + "*/");
			} else {
				return ("// " + v);
			};
		};
		
		function Terminator(v){
			this._value = v;
			this;
		};
		
		subclass$(Terminator,Meta);
		exports.Terminator = Terminator; // export class 
		Terminator.prototype.traverse = function (){
			return this;
		};
		
		Terminator.prototype.c = function (){
			// TODO this can contain several newlines
			// for sourcemaps it would be nice to parse this
			// and fix it up mark__(@value) + 
			return this._value.c();
			// var v = value.replace(/\\n/g,'\n')
			// v # .split()
			// v.split("\n").map(|v| v ? " // {v}" : v).join("\n")
		};
		
		function Newline(v){
			this._traversed = false;
			this._value = v || '\n';
		};
		
		subclass$(Newline,Terminator);
		exports.Newline = Newline; // export class 
		Newline.prototype.c = function (){
			return c__(this._value);
		};
		
		
		// weird place?
		function Index(){ return ValueNode.apply(this,arguments) };
		
		subclass$(Index,ValueNode);
		exports.Index = Index; // export class 
		Index.prototype.js = function (o){
			return this._value.c();
		};
		
		function ListNode(list){
			this.setup();
			this._nodes = this.load(list || []);
			this._indentation = null;
		};
		
		// PERF acces @nodes directly?
		subclass$(ListNode,Node);
		exports.ListNode = ListNode; // export class 
		ListNode.prototype.nodes = function(v){ return this._nodes; }
		ListNode.prototype.setNodes = function(v){ this._nodes = v; return this; };
		
		ListNode.prototype.list = function (){
			return this._nodes;
		};
		
		ListNode.prototype.compact = function (){
			this._nodes = compact__(this._nodes);
			return this;
		};
		
		ListNode.prototype.load = function (list){
			return list;
		};
		
		ListNode.prototype.concat = function (other){
			// need to store indented content as well?
			this._nodes = this.nodes().concat(other instanceof Array ? (other) : (other.nodes()));
			return this;
		};
		
		ListNode.prototype.swap = function (item,other){
			var idx = this.indexOf(item);
			if (idx >= 0) { this.nodes()[idx] = other };
			return this;
		};
		
		ListNode.prototype.push = function (item){
			this._nodes.push(item);
			return this;
		};
		
		ListNode.prototype.pop = function (){
			var end = this._nodes.pop();
			return end;
		};
		
		ListNode.prototype.add = function (item){
			this._nodes.push(item);
			return this;
		};
		
		ListNode.prototype.unshift = function (item,br){
			if (br) { this._nodes.unshift(BR) };
			this._nodes.unshift(item);
			return this;
		};
		
		// test
		ListNode.prototype.slice = function (a,b){
			return new this.constructor(this._nodes.slice(a,b));
		};
		
		
		
		ListNode.prototype.break = function (br,pre){
			if(pre === undefined) pre = false;
			if (typeof br == 'string') { br = new Terminator(br) };
			pre ? (this.unshift(br)) : (this.push(br));
			return this;
		};
		
		ListNode.prototype.some = function (cb){
			for (var i = 0, ary = iter$(this._nodes), len = ary.length; i < len; i++) {
				if (cb(ary[i])) { return true };
			};
			return false;
		};
		
		ListNode.prototype.every = function (cb){
			for (var i = 0, ary = iter$(this._nodes), len = ary.length; i < len; i++) {
				if (!cb(ary[i])) { return false };
			};
			return true;
		};
		
		ListNode.prototype.filter = function (cb){
			return this._nodes.filter(cb);
		};
		
		ListNode.prototype.pluck = function (cb){
			var item = this.filter(cb)[0];
			if (item) { this.remove(item) };
			return item;
		};
		
		ListNode.prototype.indexOf = function (item){
			return this._nodes.indexOf(item);
		};
		
		ListNode.prototype.index = function (i){
			return this._nodes[i];
		};
		
		ListNode.prototype.remove = function (item){
			var idx = this._nodes.indexOf(item);
			if (idx >= 0) { this._nodes.splice(idx,1) };
			return this;
		};
		
		ListNode.prototype.removeAt = function (idx){
			var item = this._nodes[idx];
			if (idx >= 0) { this._nodes.splice(idx,1) };
			return item;
		};
		
		
		ListNode.prototype.replace = function (original,replacement){
			var idx = this._nodes.indexOf(original);
			if (idx >= 0) {
				if (replacement instanceof Array) {
					// p "replaceing with array of items"
					this._nodes.splice.apply(this._nodes,[].concat([idx,1], [].slice.call(replacement)));
				} else {
					this._nodes[idx] = replacement;
				};
			};
			return this;
		};
		
		ListNode.prototype.first = function (){
			return this._nodes[0];
		};
		
		ListNode.prototype.last = function (){
			var i = this._nodes.length;
			while (i){
				i = i - 1;
				var v = this._nodes[i];
				if (!((v instanceof Meta))) { return v };
			};
			return null;
		};
		
		ListNode.prototype.map = function (fn){
			return this._nodes.map(fn);
		};
		
		ListNode.prototype.forEach = function (fn){
			return this._nodes.forEach(fn);
		};
		
		ListNode.prototype.remap = function (fn){
			this._nodes = this.map(fn);
			return this;
		};
		
		ListNode.prototype.count = function (){
			return this._nodes.length;
		};
		
		ListNode.prototype.realCount = function (){
			var k = 0;
			for (var i = 0, ary = iter$(this._nodes), len = ary.length, node; i < len; i++) {
				node = ary[i];
				if (node && !(node instanceof Meta)) { k++ };
			};
			return k;
		};
		
		ListNode.prototype.visit = function (){
			for (var i = 0, ary = iter$(this._nodes), len = ary.length, node; i < len; i++) {
				node = ary[i];
				node && node.traverse();
			};
			return this;
		};
		
		ListNode.prototype.isExpressable = function (){
			for (var i = 0, ary = iter$(this.nodes()), len = ary.length, node; i < len; i++) {
				node = ary[i];
				if (node && !node.isExpressable()) { return false };
			};
			// return no unless nodes.every(|v| v.isExpressable )
			return true;
		};
		
		ListNode.prototype.toArray = function (){
			return this._nodes;
		};
		
		ListNode.prototype.delimiter = function (){
			return this._delimiter || ",";
		};
		
		ListNode.prototype.js = function (o,pars){
			if(!pars||pars.constructor !== Object) pars = {};
			var nodes = pars.nodes !== undefined ? pars.nodes : this._nodes;
			var delim = ',';
			var express = delim != ';';
			var last = this.last();
			
			var i = 0;
			var l = nodes.length;
			var str = "";
			
			for (var j = 0, ary = iter$(nodes), len = ary.length, arg; j < len; j++) {
				arg = ary[j];
				var part = typeof arg == 'string' ? (arg) : ((arg ? (arg.c({expression: express})) : ('')));
				str += part;
				if (part && (!(express) || arg != last) && !(arg instanceof Meta)) { str += delim };
			};
			
			return str;
		};
		
		ListNode.prototype.indented = function (a,b){
			if (a instanceof Indentation) {
				this._indentation = a;
				return this;
			};
			
			this._indentation || (this._indentation = a && b ? (new Indentation(a,b)) : (INDENT));
			return this;
		};
		
		
		function ArgList(){ return ListNode.apply(this,arguments) };
		
		subclass$(ArgList,ListNode);
		exports.ArgList = ArgList; // export class 
		
		
		//	def indented a,b
		//		if a isa Indentation
		//			@indentation = a
		//			return self
		//
		//		@indentation ||= a and b ? Indentation.new(a,b) : INDENT
		//		self
		
		// def hasSplat
		// 	@nodes.some do |v| v isa Splat
		// def delimiter
		// 	","
		
		
		function AssignList(){ return ArgList.apply(this,arguments) };
		
		subclass$(AssignList,ArgList);
		exports.AssignList = AssignList; // export class 
		AssignList.prototype.concat = function (other){
			if (this._nodes.length == 0 && (other instanceof AssignList)) {
				return other;
			} else {
				AssignList.__super__.concat.call(this,other);
			};
			// need to store indented content as well?
			// @nodes = nodes.concat(other isa Array ? other : other.nodes)
			return this;
		};
		
		
		function Block(list){
			this.setup();
			// @nodes = compact__(flatten__(list)) or []
			this._nodes = list || [];
			this._head = null;
			this._indentation = null;
		};
		
		subclass$(Block,ListNode);
		exports.Block = Block; // export class 
		Block.prototype.head = function(v){ return this._head; }
		Block.prototype.setHead = function(v){ this._head = v; return this; };
		
		Block.wrap = function (ary){
			if (!((ary instanceof Array))) {
				throw new SyntaxError("what");
			};
			return ary.length == 1 && (ary[0] instanceof Block) ? (ary[0]) : (new Block(ary));
		};
		
		Block.prototype.visit = function (){
			if (this._scope) { this._scope.visit() };
			
			for (var i = 0, ary = iter$(this._nodes), len = ary.length, node; i < len; i++) {
				node = ary[i];
				node && node.traverse();
			};
			return this;
		};
		
		Block.prototype.block = function (){
			return this;
		};
		
		// def indented a,b
		// 	@indentation ||= a and b ? Indentation.new(a,b) : INDENT
		// 	self
		
		Block.prototype.loc = function (){
			// rather indents, no?
			var opt, ind;
			if (opt = this.option('ends')) {
				// p "location is",opt
				var a = opt[0].loc();
				var b = opt[1].loc();
				
				if (!(a)) { this.p(("no loc for " + (opt[0]))) };
				if (!(b)) { this.p(("no loc for " + (opt[1]))) };
				
				return [a[0],b[1]];
			} else if (ind = this._indentation) {
				return [ind.aloc(),ind.bloc()];
			} else {
				return [0,0];
			};
		};
		
		// go through children and unwrap inner nodes
		Block.prototype.unwrap = function (){
			var ary = [];
			for (var i = 0, items = iter$(this.nodes()), len = items.length, node; i < len; i++) {
				node = items[i];
				if (node instanceof Block) {
					// p "unwrapping inner block"
					ary.push.apply(ary,node.unwrap());
				} else {
					ary.push(node);
				};
			};
			return ary;
		};
		
		Block.prototype.push = function (item){
			this._nodes.push(item);
			return this;
		};
		
		Block.prototype.add = function (item){
			this._nodes.push(item);
			return this;
		};
		
		// This is just to work as an inplace replacement of nodes.coffee
		// After things are working okay we'll do bigger refactorings
		Block.prototype.compile = function (o){
			if(o === undefined) o = {};
			var root = new Root(this,o);
			return root.compile(o);
		};
		
		
		// Not sure if we should create a separate block?
		Block.prototype.analyze = function (o){
			// p "analyzing block!!!",o
			if(o === undefined) o = {};
			return this;
		};
		
		Block.prototype.cpart = function (node){
			var out = typeof node == 'string' ? (node) : ((node ? (node.c()) : ("")));
			if (out == null || out == undefined || out == "") { return "" };
			
			if (out instanceof Array) {
				var str = "";
				var l = out.length;
				var i = 0;
				while (i < l){
					str += this.cpart(out[i++]);
				};
				return str;
			};
			
			var hasSemiColon = SEMICOLON_TEST.test(out);
			if (!(hasSemiColon || (node instanceof Meta))) { out += ";" };
			return out;
		};
		
		Block.prototype.js = function (o,opts){
			var ast = this._nodes;
			var l = ast.length;
			// really?
			var express = this.isExpression() || o.isExpression() || (this.option('express') && this.isExpressable());
			if (ast.length == 0) { return '' };
			
			if (express) {
				return Block.__super__.js.call(this,o,{nodes: ast});
			};
			
			var str = "";
			for (var i = 0, ary = iter$(ast), len = ary.length; i < len; i++) {
				str += this.cpart(ary[i]);
			};
			
			// now add the head items as well
			if (this._head && this._head.length > 0) {
				var prefix = "";
				for (var i = 0, ary = iter$(this._head), len = ary.length; i < len; i++) {
					var hv = this.cpart(ary[i]);
					if (hv) { prefix += hv + '\n' };
				};
				str = prefix + str;
			};
			return str;
		};
		
		
		// Should this create the function as well?
		Block.prototype.defers = function (original,replacement){
			var idx = this._nodes.indexOf(original);
			if (idx >= 0) { this._nodes[idx] = replacement };
			var rest = this._nodes.splice(idx + 1);
			return rest;
		};
		
		Block.prototype.expressions = function (){
			var expressions = [];
			for (var i = 0, ary = iter$(this.nodes()), len = ary.length, node; i < len; i++) {
				node = ary[i];
				if (!((node instanceof Terminator))) { expressions.push(node) };
			};
			return expressions;
		};
		
		
		Block.prototype.consume = function (node){
			var before;
			if (node instanceof TagTree) { // special case?!?
				this._nodes = this._nodes.map(function(child) {
					return child.consume(node);
				});
				
				var real = this.expressions();
				// FIXME should not include terminators and comments when counting
				// should only wrap the content in array (returning all parts)
				// for if/else blocks -- not loops
				
				// we need to compare the real length
				if (!node._loop && real.length > 1) {
					// p "lengths",@nodes:length,expressions:length
					var nr = node.blocks().push(this);
					var arr = new Arr(new ArgList(this._nodes));
					arr.indented(this._indentation);
					this._indentation = null;
					
					if (node.reactive()) {
						this._nodes = [Util.callImba("static",[arr,new Num(nr)])];
					} else {
						this._nodes = [arr];
					};
				};
				
				
				
				return this;
			};
			
			// can also return super if it is expressable, but should we really?
			if (before = this.last()) {
				var after = before.consume(node);
				if (after != before) {
					// p "replace node in block {before} -> {after}"
					if (after instanceof Block) {
						// p "replaced with block -- should basically add it instead?"
						after = after.nodes();
					};
					
					this.replace(before,after);
				};
			};
			// really?
			return this;
		};
		
		
		Block.prototype.isExpressable = function (){
			if (!this._nodes.every(function(v) { return v.isExpressable(); })) { return false };
			return true;
		};
		
		Block.prototype.isExpression = function (){
			
			return this.option('express') || this._expression;
		};
		
		
		// this is almost like the old VarDeclarations but without the values
		function VarBlock(){ return ListNode.apply(this,arguments) };
		
		subclass$(VarBlock,ListNode);
		exports.VarBlock = VarBlock; // export class 
		VarBlock.prototype.load = function (list){
			var first = list[0];
			
			if (first instanceof Assign) {
				this._type = first.left()._type;
			} else if (first instanceof VarReference) {
				this._type = first._type;
			};
			// p "here {list[0]} - {@type}"
			// @type = list[0] and list[0].type
			return list;
		};
		
		// TODO All these inner items should rather be straight up literals
		// or basic localvars - without any care whatsoever about adding var to the
		// beginning etc. 
		VarBlock.prototype.addExpression = function (expr){
			// p "VarBlock.addExpression {self} <- {expr}"
			
			if (expr instanceof Assign) {
				// make sure the left-side is a var-reference
				// this should be a different type of assign, no?
				if (expr.left() instanceof VarOrAccess) {
					expr.setLeft(new VarReference(expr.left().value(),this._type));
				};
				
				this.push(expr);
			} else if (expr instanceof Assign) {
				this.addExpression(expr.left()); // make sure this is a valid thing?
				// make this into a tuple instead
				// does not need to be a tuple?
				return new TupleAssign('=',new Tuple(this.nodes()),expr.right());
			} else if (expr instanceof VarOrAccess) {
				// this is really a VarReference
				this.push(new VarReference(expr.value(),this._type));
			} else if ((expr instanceof Splat) && (expr.node() instanceof VarOrAccess)) {
				// p "is a splat - only allowed in tuple-assignment"
				// what?
				expr.setValue(new VarReference(expr.node().value(),this._type));
				this.push(expr);
			} else {
				this.p(("VarBlock.addExpression " + this + " <- " + expr));
				throw "VarBlock does not allow non-variable expressions";
			};
			return this;
		};
		
		
		VarBlock.prototype.isExpressable = function (){
			// we would need to force-drop the variables, makes little sense
			// but, it could be, could just push the variables out?
			return false;
		};
		
		VarBlock.prototype.js = function (o){
			// p "VarBlock"
			// for n in @nodes
			// 	p "VarBlock child {n}"
			var code = compact__(flatten__(cary__(this.nodes())));
			code = code.filter(function(n) { return n != null && n != undefined && n != EMPTY; });
			var out = code.join(",");
			// we just need to trust that the variables have been autodeclared beforehand
			// if we are inside an expression
			if (!o.isExpression()) { out = "var " + out };
			return out;
		};
		
		
		VarBlock.prototype.consume = function (node){
			// It doesnt make much sense for a VarBlock to consume anything
			// it should probably return void for methods
			return this;
		};
		
		
		// Could inherit from valueNode
		function Parens(value,open,close){
			this.setup();
			this._open = open;
			this._close = close;
			this._value = this.load(value);
		};
		
		subclass$(Parens,ValueNode);
		exports.Parens = Parens; // export class 
		Parens.prototype.load = function (value){
			this._noparen = false;
			return (value instanceof Block) && value.count() == 1 ? (value.first()) : (value);
		};
		
		Parens.prototype.isString = function (){
			// checking if this is an interpolated string
			return this._open && String(this._open) == '("' || this.value().isString();
		};
		
		Parens.prototype.js = function (o){
			
			var par = this.up();
			var v = this._value;
			var str = null;
			
			if (v instanceof Func) { this._noparen = true };
			// p "compile parens {v} {v isa Block and v.count}"
			// p "Parens up {par} {o.isExpression}"
			if (par instanceof Block) {
				// is it worth it?
				if (!o.isExpression()) { this._noparen = true };
				str = v instanceof Array ? (cary__(v)) : (v.c({expression: o.isExpression()}));
			} else {
				str = v instanceof Array ? (cary__(v)) : (v.c({expression: true}));
			};
			
			// check if we really need parens here?
			return str;
		};
		
		Parens.prototype.set = function (obj){
			console.log(("Parens set " + JSON.stringify(obj)));
			return Parens.__super__.set.call(this,obj);
		};
		
		
		Parens.prototype.shouldParenthesize = function (){
			// no need to parenthesize if this is a line in a block
			if (this._noparen) { return false }; //  or par isa ArgList
			return true;
		};
		
		
		Parens.prototype.prebreak = function (br){
			Parens.__super__.prebreak.call(this,br);
			console.log("PREBREAK");
			if (this._value) { this._value.prebreak(br) };
			return this;
		};
		
		
		Parens.prototype.isExpressable = function (){
			return this._value.isExpressable();
		};
		
		Parens.prototype.consume = function (node){
			return this._value.consume(node);
		};
		
		
		// Could inherit from valueNode
		// an explicit expression-block (with parens) is somewhat different
		// can be used to return after an expression
		function ExpressionBlock(){ return ListNode.apply(this,arguments) };
		
		subclass$(ExpressionBlock,ListNode);
		exports.ExpressionBlock = ExpressionBlock; // export class 
		ExpressionBlock.prototype.c = function (){
			return this.map(function(item) { return item.c(); }).join(",");
		};
		
		ExpressionBlock.prototype.consume = function (node){
			return this.value().consume(node);
		};
		
		ExpressionBlock.prototype.addExpression = function (expr){
			// Need to take care of the splat here to.. hazzle
			if (expr.node() instanceof Assign) {
				// p "is assignment!"
				this.push(expr.left());
				// make this into a tuple instead
				// possibly fix this as well?!?
				return new TupleAssign('=',new Tuple(this.nodes()),expr.right());
			} else {
				this.push(expr);
			};
			return this;
		};
		
		
		
		// STATEMENTS
		
		function Return(v){
			this._traversed = false;
			this._value = (v instanceof ArgList) && v.count() == 1 ? (v.last()) : (v);
			// @prebreak = v and v.@prebreak
			// console.log "return?!? {v}",@prebreak
			// if v isa ArgList and v.count == 1
			return this;
		};
		
		subclass$(Return,Statement);
		exports.Return = Return; // export class 
		Return.prototype.value = function(v){ return this._value; }
		Return.prototype.setValue = function(v){ this._value = v; return this; };
		
		Return.prototype.visit = function (){
			if (this._value && this._value.traverse) { return this._value.traverse() };
		};
		
		Return.prototype.js = function (o){
			var v = this._value;
			
			if (v instanceof ArgList) {
				return ("return [" + v.c({expression: true}) + "]");
			} else if (v) {
				return ("return " + v.c({expression: true}));
			} else {
				return "return";
			};
		};
		
		Return.prototype.c = function (){
			if (!(this.value()) || this.value().isExpressable()) { return Return.__super__.c.apply(this,arguments) };
			// p "return must cascade into value".red
			return this.value().consume(this).c();
		};
		
		Return.prototype.consume = function (node){
			return this;
		};
		
		function ImplicitReturn(){ return Return.apply(this,arguments) };
		
		subclass$(ImplicitReturn,Return);
		exports.ImplicitReturn = ImplicitReturn; // export class 
		
		
		function GreedyReturn(){ return ImplicitReturn.apply(this,arguments) };
		
		subclass$(GreedyReturn,ImplicitReturn);
		exports.GreedyReturn = GreedyReturn; // export class 
		
		
		// cannot live inside an expression(!)
		function Throw(){ return Statement.apply(this,arguments) };
		
		subclass$(Throw,Statement);
		exports.Throw = Throw; // export class 
		Throw.prototype.js = function (o){
			return ("throw " + (this.value().c()));
		};
		
		Throw.prototype.consume = function (node){
			// ROADMAP should possibly consume to the value of throw and then throw?
			return this;
		};
		
		
		function LoopFlowStatement(lit,expr){
			this.setLiteral(lit);
			this.setExpression(expr); // && ArgList.new(expr) # really?
		};
		
		subclass$(LoopFlowStatement,Statement);
		exports.LoopFlowStatement = LoopFlowStatement; // export class 
		LoopFlowStatement.prototype.literal = function(v){ return this._literal; }
		LoopFlowStatement.prototype.setLiteral = function(v){ this._literal = v; return this; };
		LoopFlowStatement.prototype.expression = function(v){ return this._expression; }
		LoopFlowStatement.prototype.setExpression = function(v){ this._expression = v; return this; };
		
		LoopFlowStatement.prototype.visit = function (){
			if (this.expression()) { return this.expression().traverse() };
		};
		
		LoopFlowStatement.prototype.consume = function (node){
			// p "break/continue should consume?!"
			return this;
		};
		
		LoopFlowStatement.prototype.c = function (){
			if (!(this.expression())) { return LoopFlowStatement.__super__.c.apply(this,arguments) };
			// get up to the outer loop
			var _loop = STACK.up(Loop);
			// p "found loop?",_loop
			
			// need to fix the grammar for this. Right now it 
			// is like a fake call, but should only care about the first argument
			var expr = this.expression();
			
			if (_loop.catcher()) {
				expr = expr.consume(_loop.catcher());
				var copy = new this.constructor(this.literal());
				return new Block([expr,copy]).c();
			} else if (expr) {
				copy = new this.constructor(this.literal());
				return new Block([expr,copy]).c();
			} else {
				return LoopFlowStatement.__super__.c.apply(this,arguments);
			};
			// return "loopflow"
		};
		
		
		function BreakStatement(){ return LoopFlowStatement.apply(this,arguments) };
		
		subclass$(BreakStatement,LoopFlowStatement);
		exports.BreakStatement = BreakStatement; // export class 
		BreakStatement.prototype.js = function (o){
			return "break";
		};
		
		function ContinueStatement(){ return LoopFlowStatement.apply(this,arguments) };
		
		subclass$(ContinueStatement,LoopFlowStatement);
		exports.ContinueStatement = ContinueStatement; // export class 
		ContinueStatement.prototype.js = function (o){
			return "continue";
		};
		
		function DebuggerStatement(){ return Statement.apply(this,arguments) };
		
		subclass$(DebuggerStatement,Statement);
		exports.DebuggerStatement = DebuggerStatement; // export class 
		
		
		
		// PARAMS
		
		function Param(name,defaults,typ){
			// could have introduced bugs by moving back to identifier here
			this._traversed = false;
			this._name = name; // .value # this is an identifier(!)
			this._defaults = defaults;
			this._typ = typ;
			this._variable = null;
		};
		
		subclass$(Param,Node);
		exports.Param = Param; // export class 
		Param.prototype.name = function(v){ return this._name; }
		Param.prototype.setName = function(v){ this._name = v; return this; };
		Param.prototype.index = function(v){ return this._index; }
		Param.prototype.setIndex = function(v){ this._index = v; return this; };
		Param.prototype.defaults = function(v){ return this._defaults; }
		Param.prototype.setDefaults = function(v){ this._defaults = v; return this; };
		Param.prototype.splat = function(v){ return this._splat; }
		Param.prototype.setSplat = function(v){ this._splat = v; return this; };
		Param.prototype.variable = function(v){ return this._variable; }
		Param.prototype.setVariable = function(v){ this._variable = v; return this; };
		
		// what about object-params?
		
		Param.prototype.varname = function (){
			return this._variable ? (this._variable.c()) : (this.name());
		};
		
		Param.prototype.js = function (o){
			if (this._variable) { return this._variable.c() };
			
			if (this.defaults()) {
				// should not include any source-mapping here?
				return ("if(" + (this.name().c()) + " == null) " + (this.name().c()) + " = " + (this.defaults().c()));
			};
			// see if this is the initial declarator?
		};
		
		Param.prototype.visit = function (){
			var variable_, v_;
			if (this._defaults) { this._defaults.traverse() };
			(variable_ = this.variable()) || ((this.setVariable(v_ = this.scope__().register(this.name(),this)),v_));
			
			if (this._name instanceof Identifier) {
				// change type here?
				if (this._name._value) { this._name._value._type = "PARAMVAR" };
				this._name.references(this._variable);
				// console.log "got here!! {@name:constructor}"
				// @name.@token.@variable = @variable if @name.@token
			};
			
			return this;
		};
		
		Param.prototype.assignment = function (){
			return OP('=',this.variable().accessor(),this.defaults());
		};
		
		Param.prototype.isExpressable = function (){
			return !(this.defaults()) || this.defaults().isExpressable();
			// p "visiting param!!!"
		};
		
		Param.prototype.dump = function (){
			return {loc: this.loc()};
		};
		
		Param.prototype.loc = function (){
			return this._name && this._name.region();
		};
		
		Param.prototype.toJSON = function (){
			return {
				type: this.typeName(),
				name: this.name(),
				defaults: this.defaults()
			};
		};
		
		
		function SplatParam(){ return Param.apply(this,arguments) };
		
		subclass$(SplatParam,Param);
		exports.SplatParam = SplatParam; // export class 
		SplatParam.prototype.loc = function (){
			// hacky.. cannot know for sure that this is right?
			var r = this.name().region();
			return [r[0] - 1,r[1]];
		};
		
		function BlockParam(){ return Param.apply(this,arguments) };
		
		subclass$(BlockParam,Param);
		exports.BlockParam = BlockParam; // export class 
		BlockParam.prototype.c = function (){
			return "blockparam";
		};
		
		BlockParam.prototype.loc = function (){
			// hacky.. cannot know for sure that this is right?
			var r = this.name().region();
			return [r[0] - 1,r[1]];
		};
		
		
		function OptionalParam(){ return Param.apply(this,arguments) };
		
		subclass$(OptionalParam,Param);
		exports.OptionalParam = OptionalParam; // export class 
		
		
		function NamedParam(){ return Param.apply(this,arguments) };
		
		subclass$(NamedParam,Param);
		exports.NamedParam = NamedParam; // export class 
		
		
		function RequiredParam(){ return Param.apply(this,arguments) };
		
		subclass$(RequiredParam,Param);
		exports.RequiredParam = RequiredParam; // export class 
		
		
		function NamedParams(){ return ListNode.apply(this,arguments) };
		
		subclass$(NamedParams,ListNode);
		exports.NamedParams = NamedParams; // export class 
		NamedParams.prototype.index = function(v){ return this._index; }
		NamedParams.prototype.setIndex = function(v){ this._index = v; return this; };
		NamedParams.prototype.variable = function(v){ return this._variable; }
		NamedParams.prototype.setVariable = function(v){ this._variable = v; return this; };
		
		NamedParams.prototype.load = function (list){
			var load = function(k) { return new NamedParam(k.key(),k.value()); };
			return list instanceof Obj ? (list.value().map(load)) : (list);
		};
		
		NamedParams.prototype.visit = function (){
			var s = this.scope__();
			this._variable || (this._variable = s.temporary(this,{pool: 'keypars'}));
			this._variable.predeclared();
			
			// this is a listnode, which will automatically traverse
			// and visit all children
			NamedParams.__super__.visit.apply(this,arguments);
			// register the inner variables as well(!)
			return this;
		};
		
		
		NamedParams.prototype.varname = function (){
			return this.variable().c();
		};
		
		NamedParams.prototype.name = function (){
			return this.varname();
		};
		
		NamedParams.prototype.js = function (o){
			return "namedpar";
		};
		
		NamedParams.prototype.toJSON = function (){
			return {
				type: this.typeName(),
				nodes: this.filter(function(v) { return v instanceof NamedParam; })
			};
		};
		
		
		function IndexedParam(){ return Param.apply(this,arguments) };
		
		subclass$(IndexedParam,Param);
		exports.IndexedParam = IndexedParam; // export class 
		IndexedParam.prototype.parent = function(v){ return this._parent; }
		IndexedParam.prototype.setParent = function(v){ this._parent = v; return this; };
		IndexedParam.prototype.subindex = function(v){ return this._subindex; }
		IndexedParam.prototype.setSubindex = function(v){ this._subindex = v; return this; };
		
		IndexedParam.prototype.visit = function (){
			// p "VISIT PARAM {name}!"
			// ary.[-1] # possible
			// ary.(-1) # possible
			// str(/ok/,-1)
			// scope.register(@name,self)
			// BUG The defaults should probably be looked up like vars
			var variable_, v_;
			(variable_ = this.variable()) || ((this.setVariable(v_ = this.scope__().register(this.name(),this)),v_));
			this.variable().proxy(this.parent().variable(),this.subindex());
			return this;
		};
		
		
		function ArrayParams(){ return ListNode.apply(this,arguments) };
		
		subclass$(ArrayParams,ListNode);
		exports.ArrayParams = ArrayParams; // export class 
		ArrayParams.prototype.index = function(v){ return this._index; }
		ArrayParams.prototype.setIndex = function(v){ this._index = v; return this; };
		ArrayParams.prototype.variable = function(v){ return this._variable; }
		ArrayParams.prototype.setVariable = function(v){ this._variable = v; return this; };
		
		ArrayParams.prototype.visit = function (){
			var s = this.scope__();
			this._variable || (this._variable = s.temporary(this,{pool: 'keypars'}));
			this._variable.predeclared();
			
			// now when we loop through these inner params - we create the pars
			// with the correct name, but bind them to the parent
			return ArrayParams.__super__.visit.apply(this,arguments);
		};
		
		ArrayParams.prototype.name = function (){
			return this.variable().c();
		};
		
		ArrayParams.prototype.load = function (list){
			var self = this;
			if (!((list instanceof Arr))) { return null };
			// p "loading arrayparams"
			// try the basic first
			if (!list.splat()) {
				return list.value().map(function(v,i) {
					// must make sure the params are supported here
					// should really not parse any array at all(!)
					var name = v;
					if (v instanceof VarOrAccess) {
						// p "varoraccess {v.value}"
						// FIX?
						name = v.value().value();
						// this is accepted
					};
					return self.parse(name,v,i);
				});
			};
		};
		
		ArrayParams.prototype.parse = function (name,child,i){
			var param = new IndexedParam(name,null);
			
			param.setParent(this);
			param.setSubindex(i);
			return param;
		};
		
		ArrayParams.prototype.head = function (ast){
			// "arrayparams"
			return this;
		};
		
		function ParamList(){ return ListNode.apply(this,arguments) };
		
		subclass$(ParamList,ListNode);
		exports.ParamList = ParamList; // export class 
		ParamList.prototype.splat = function(v){ return this._splat; }
		ParamList.prototype.setSplat = function(v){ this._splat = v; return this; };
		ParamList.prototype.block = function(v){ return this._block; }
		ParamList.prototype.setBlock = function(v){ this._block = v; return this; };
		
		ParamList.prototype.at = function (index,force,name){
			if(force === undefined) force = false;
			if(name === undefined) name = null;
			if (force) {
				while (this.count() <= index){
					this.add(new Param(this.count() == index && name || ("_" + this.count())));
				};
				// need to visit at the same time, no?
			};
			return this.list()[index];
		};
		
		ParamList.prototype.metadata = function (){
			return this.filter(function(par) { return !(par instanceof Meta); });
		};
		
		ParamList.prototype.toJSON = function (){
			return this.metadata();
		};
		
		ParamList.prototype.visit = function (){
			this._splat = this.filter(function(par) { return par instanceof SplatParam; })[0];
			var blk = this.filter(function(par) { return par instanceof BlockParam; });
			
			if (blk.length > 1) {
				blk[1].warn("a method can only have one &block parameter");
			} else if (blk[0] && blk[0] != this.last()) {
				blk[0].warn("&block must be the last parameter of a method");
				// warn "&block must be the last parameter of a method", blk[0]
			};
			
			// add more warnings later(!)
			// should probably throw error as well to stop compilation
			
			// need to register the required-pars as variables
			return ParamList.__super__.visit.apply(this,arguments);
		};
		
		ParamList.prototype.js = function (o){
			if (this.count() == 0) { return EMPTY };
			if (o.parent() instanceof Block) { return this.head(o) };
			
			// items = map(|arg| arg.name.c ).compact
			// return null unless items[0]
			
			if (o.parent() instanceof Code) {
				// remove the splat, for sure.. need to handle the other items as well
				// this is messy with references to argvars etc etc. Fix
				var pars = this.nodes();
				// pars = filter(|arg| arg != @splat && !(arg isa BlockParam)) if @splat
				if (this._splat) { pars = this.filter(function(arg) { return (arg instanceof RequiredParam) || (arg instanceof OptionalParam); }) };
				return compact__(pars.map(function(arg) { return c__(arg.varname()); })).join(",");
			} else {
				throw "not implemented paramlist js";
				return "ta" + compact__(this.map(function(arg) { return arg.c(); })).join(",");
			};
		};
		
		ParamList.prototype.head = function (o){
			var reg = [];
			var opt = [];
			var blk = null;
			var splat = null;
			var named = null;
			var arys = [];
			var signature = [];
			var idx = 0;
			
			this.nodes().forEach(function(par,i) {
				par.setIndex(idx);
				if (par instanceof NamedParams) {
					signature.push('named');
					named = par;
				} else if (par instanceof OptionalParam) {
					signature.push('opt');
					opt.push(par);
				} else if (par instanceof BlockParam) {
					signature.push('blk');
					blk = par;
				} else if (par instanceof SplatParam) {
					signature.push('splat');
					splat = par;
					idx -= 1; // this should really be removed from the list, no?
				} else if (par instanceof ArrayParams) {
					arys.push(par);
					signature.push('ary');
				} else {
					signature.push('reg');
					reg.push(par);
				};
				return idx++;
			});
			
			if (named) {
				var namedvar = named.variable();
			};
			
			// var opt = nodes.filter(|n| n isa OptionalParam)
			// var blk = nodes.filter(|n| n isa BlockParam)[0]
			// var splat = nodes.filter(|n| n isa SplatParam)[0]
			
			// simple situation where we simply switch
			// can probably optimize by not looking at arguments at all
			var ast = [];
			var isFunc = function(js) { return ("typeof " + js + " == 'function'"); };
			
			// This is broken when dealing with iframes anc XSS scripting
			// but for now it is the best test for actual arguments
			// can also do constructor.name == 'Object'
			var isObj = function(js) { return ("" + js + ".constructor === Object"); };
			var isntObj = function(js) { return ("" + js + ".constructor !== Object"); };
			// should handle some common cases in a cleaner (less verbose) manner
			// does this work with default params after optional ones? Is that even worth anything?
			// this only works in one direction now, unlike TupleAssign
			
			// we dont really check the length etc now -- so it is buggy for lots of arguments
			
			// if we have optional params in the regular order etc we can go the easy route
			// slightly hacky now. Should refactor all of these to use the signature?
			if (!(named) && !(splat) && !(blk) && opt.length > 0 && signature.join(" ").match(/opt$/)) {
				for (var i = 0, len_ = opt.length, par; i < len_; i++) {
					par = opt[i];
					ast.push(("if(" + (par.name().c()) + " === undefined) " + (par.name().c()) + " = " + (par.defaults().c())));
				};
			} else if (named && !(splat) && !(blk) && opt.length == 0) { // and no block?!
				// different shorthands
				// if named
				ast.push(("if(!" + (namedvar.c()) + "||" + isntObj(namedvar.c()) + ") " + (namedvar.c()) + " = \{\}"));
			} else if (blk && opt.length == 1 && !(splat) && !(named)) {
				var op = opt[0];
				var opn = op.name().c();
				var bn = blk.name().c();
				ast.push(("if(" + bn + "==undefined && " + isFunc(opn) + ") " + bn + " = " + opn + "," + opn + " = " + (op.defaults().c())));
				ast.push(("if(" + opn + "==undefined) " + opn + " = " + (op.defaults().c())));
			} else if (blk && named && opt.length == 0 && !(splat)) {
				bn = blk.name().c();
				ast.push(("if(" + bn + "==undefined && " + isFunc(namedvar.c()) + ") " + bn + " = " + (namedvar.c()) + "," + (namedvar.c()) + " = \{\}"));
				ast.push(("else if(!" + (namedvar.c()) + "||" + isntObj(namedvar.c()) + ") " + (namedvar.c()) + " = \{\}"));
			} else if (opt.length > 0 || splat) { // && blk  # && !splat
				
				var argvar = this.scope__().temporary(this,{pool: 'arguments'}).predeclared().c();
				var len = this.scope__().temporary(this,{pool: 'counter'}).predeclared().c();
				
				var last = ("" + argvar + "[" + len + "-1]");
				var pop = ("" + argvar + "[--" + len + "]");
				ast.push(("var " + argvar + " = arguments, " + len + " = " + argvar + ".length"));
				
				if (blk) {
					bn = blk.name().c();
					if (splat) {
						ast.push(("var " + bn + " = " + isFunc(last) + " ? " + pop + " : null"));
					} else if (reg.length > 0) {
						// ast.push "// several regs really?"
						ast.push(("var " + bn + " = " + len + " > " + (reg.length) + " && " + isFunc(last) + " ? " + pop + " : null"));
					} else {
						ast.push(("var " + bn + " = " + isFunc(last) + " ? " + pop + " : null"));
					};
				};
				
				// if we have named params - look for them before splat
				// should probably loop through pars in the same order they were added
				// should it be prioritized above optional objects??
				if (named) {
					// should not include it when there is a splat?
					ast.push(("var " + (namedvar.c()) + " = " + last + "&&" + isObj(last) + " ? " + pop + " : \{\}"));
				};
				
				for (var i1 = 0, len_ = opt.length, par1; i1 < len_; i1++) {
					par1 = opt[i1];
					ast.push(("if(" + len + " < " + (par1.index() + 1) + ") " + (par1.name().c()) + " = " + (par1.defaults().c())));
				};
				
				// add the splat
				if (splat) {
					var sn = splat.name().c();
					var si = splat.index();
					
					if (si == 0) {
						ast.push(("var " + sn + " = new Array(" + len + ">" + si + " ? " + len + " : 0)"));
						ast.push(("while(" + len + ">" + si + ") " + sn + "[" + len + "-1] = " + pop));
					} else {
						ast.push(("var " + sn + " = new Array(" + len + ">" + si + " ? " + len + "-" + si + " : 0)"));
						ast.push(("while(" + len + ">" + si + ") " + sn + "[--" + len + " - " + si + "] = " + argvar + "[" + len + "]"));
					};
				};
				
				// if named
				// 	for k,i in named.nodes
				// 		# OP('.',namedvar) <- this is the right way, with invalid names etc
				// 		var op = OP('.',namedvar,k.key).c
				// 		ast.push "var {k.key.c} = {op} !== undefined ? {op} : {k.value.c}"
				
				// if named
				
				// return ast.join(";\n") + ";"
				// return "if({opt[0].name.c} instanceof Function) {blk.c} = {opt[0].c};"
			} else if (opt.length > 0) {
				for (var i2 = 0, len_ = opt.length, par2; i2 < len_; i2++) {
					par2 = opt[i2];
					ast.push(("if(" + (par2.name().c()) + " === undefined) " + (par2.name().c()) + " = " + (par2.defaults().c())));
				};
			};
			
			// now set stuff if named params(!)
			
			if (named) {
				for (var i3 = 0, ary = iter$(named.nodes()), len_ = ary.length, k; i3 < len_; i3++) {
					// console.log "named var {k.c}"
					k = ary[i3];
					op = OP('.',namedvar,k.c()).c();
					ast.push(("var " + (k.c()) + " = " + op + " !== undefined ? " + op + " : " + (k.defaults().c())));
				};
			};
			
			if (arys.length) {
				for (var i4 = 0, len_ = arys.length; i4 < len_; i4++) {
					// create tuples
					// p "adding arrayparams"
					arys[i4].head(o,ast,this);
					// ast.push v.c
				};
			};
			
			
			
			// if opt:length == 0
			return ast.length > 0 ? ((ast.join(";\n") + ";")) : (EMPTY);
		};
		
		
		// Legacy. Should move away from this?
		function VariableDeclaration(){ return ListNode.apply(this,arguments) };
		
		subclass$(VariableDeclaration,ListNode);
		exports.VariableDeclaration = VariableDeclaration; // export class 
		VariableDeclaration.prototype.kind = function(v){ return this._kind; }
		VariableDeclaration.prototype.setKind = function(v){ this._kind = v; return this; };
		
		// we want to register these variables in
		VariableDeclaration.prototype.add = function (name,init,pos){
			if(pos === undefined) pos = -1;
			var vardec = new VariableDeclarator(name,init);
			if (name instanceof Variable) { (vardec.setVariable(name),name) };
			pos == 0 ? (this.unshift(vardec)) : (this.push(vardec));
			return vardec;
			
			// TODO (target) << (node) rewrites to a caching push which returns node
		};
		
		// def remove item
		// 	if item isa Variable
		// 		map do |v,i|
		// 			if v.variable == item
		// 				p "found variable to remove"
		// 				super.remove(v)
		// 	else
		// 		super.remove(item)
		// 	self
		
		VariableDeclaration.prototype.load = function (list){
			// temporary solution!!!
			return list.map(function(par) { return new VariableDeclarator(par.name(),par.defaults(),par.splat()); });
		};
		
		VariableDeclaration.prototype.isExpressable = function (){
			return this.nodes().every(function(item) { return item.isExpressable(); });
		};
		
		VariableDeclaration.prototype.js = function (o){
			if (this.count() == 0) { return EMPTY };
			
			if (this.count() == 1 && !(this.isExpressable())) {
				// p "SHOULD ALTER VARDEC!!!".cyan
				this.first().variable().autodeclare();
				var node = this.first().assignment();
				return node.c();
			};
			
			// FIX PERFORMANCE
			var out = compact__(cary__(this.nodes())).join(", ");
			return out ? (("var " + out)) : ("");
			// "var " + compact__(cary__(nodes)).join(", ") + ""
		};
		
		function VariableDeclarator(){ return Param.apply(this,arguments) };
		
		subclass$(VariableDeclarator,Param);
		exports.VariableDeclarator = VariableDeclarator; // export class 
		VariableDeclarator.prototype.visit = function (){
			// even if we should traverse the defaults as if this variable does not exist
			// we need to preregister it and then activate it later
			var variable_, v_;
			(variable_ = this.variable()) || ((this.setVariable(v_ = this.scope__().register(this.name(),null)),v_));
			if (this.defaults()) { this.defaults().traverse() };
			// WARN what if it is already declared?
			this.variable().setDeclarator(this);
			this.variable().addReference(this.name());
			return this;
		};
		
		// needs to be linked up to the actual scoped variables, no?
		VariableDeclarator.prototype.js = function (o){
			if (this.variable()._proxy) { return null };
			
			var defs = this.defaults();
			// FIXME need to deal with var-defines within other statements etc
			// FIXME need better syntax for this
			if (defs != null && defs != undefined) {
				// console.log "defaults is {defaults}"
				if (defs instanceof Node) { defs = defs.c({expression: true}) };
				
				return ("" + (this.variable().c()) + " = " + defs);
			} else {
				return ("" + (this.variable().c()));
			};
		};
		
		VariableDeclarator.prototype.accessor = function (){
			return this;
		};
		
		
		// TODO clean up and refactor all the different representations of vars
		// VarName, VarReference, LocalVarAccess?
		function VarName(a,b){
			VarName.__super__.constructor.apply(this,arguments);
			this._splat = b;
		};
		
		subclass$(VarName,ValueNode);
		exports.VarName = VarName; // export class 
		VarName.prototype.variable = function(v){ return this._variable; }
		VarName.prototype.setVariable = function(v){ this._variable = v; return this; };
		VarName.prototype.splat = function(v){ return this._splat; }
		VarName.prototype.setSplat = function(v){ this._splat = v; return this; };
		
		VarName.prototype.visit = function (){
			// p "visiting varname(!)", value.c
			// should we not lookup instead?
			// FIXME p "register value {value.c}"
			var variable_, v_;
			(variable_ = this.variable()) || ((this.setVariable(v_ = this.scope__().register(this.value().c(),null)),v_));
			this.variable().setDeclarator(this);
			this.variable().addReference(this.value());
			return this;
		};
		
		VarName.prototype.js = function (o){
			return this.variable().c();
		};
		
		VarName.prototype.c = function (){
			return this.variable().c();
		};
		
		
		function VarList(t,l,r){
			this._traversed = false;
			this._type = this.type();
			this._left = l;
			this._right = r;
		};
		
		subclass$(VarList,Node);
		exports.VarList = VarList; // export class 
		VarList.prototype.type = function(v){ return this._type; }
		VarList.prototype.setType = function(v){ this._type = v; return this; }; // let / var / const
		VarList.prototype.left = function(v){ return this._left; }
		VarList.prototype.setLeft = function(v){ this._left = v; return this; };
		VarList.prototype.right = function(v){ return this._right; }
		VarList.prototype.setRight = function(v){ this._right = v; return this; };
		
		// format :type, :left, :right
		
		// should throw error if there are more values on right than left
		
		VarList.prototype.visit = function (){
			
			// we need to carefully traverse children in the right order
			// since we should be able to reference
			var r;
			for (var i = 0, ary = iter$(this.left()), len = ary.length; i < len; i++) {
				ary[i].traverse(); // this should really be a var-declaration
				if (r = this.right()[i]) { r.traverse() };
			};
			return this;
		};
		
		VarList.prototype.js = function (o){
			// for the regular items 
			var pairs = [];
			var ll = this.left().length;
			var rl = this.right().length;
			var v = null;
			
			// splatting here we come
			if (ll > 1 && rl == 1) {
				this.p("multiassign!");
				var r = this.right()[0];
				r.cache();
				for (var i = 0, ary = iter$(this.left()), len = ary.length, l; i < len; i++) {
					l = ary[i];
					if (l.splat()) {
						throw "not supported?";
						this.p("splat"); // FIX reimplement slice?
						if (i == ll - 1) {
							v = this.util().slice(r,i);
							this.p("last");
						} else {
							v = this.util().slice(r,i,-(ll - i) + 1);
						};
					} else {
						v = OP('.',r,num__(i));
					};
					
					pairs.push(OP('=',l,v));
				};
			} else {
				for (var i1 = 0, ary = iter$(this.left()), len = ary.length, l1; i1 < len; i1++) {
					l1 = ary[i1];
					r = this.right()[i1];
					pairs.push(r ? (OP('=',l1.variable().accessor(),r)) : (l1));
				};
			};
			
			return ("var " + (pairs.c()));
		};
		
		
		// CODE
		
		function Code(){ return Node.apply(this,arguments) };
		
		subclass$(Code,Node);
		exports.Code = Code; // export class 
		Code.prototype.head = function(v){ return this._head; }
		Code.prototype.setHead = function(v){ this._head = v; return this; };
		Code.prototype.body = function(v){ return this._body; }
		Code.prototype.setBody = function(v){ this._body = v; return this; };
		Code.prototype.scope = function(v){ return this._scope; }
		Code.prototype.setScope = function(v){ this._scope = v; return this; };
		Code.prototype.params = function(v){ return this._params; }
		Code.prototype.setParams = function(v){ this._params = v; return this; };
		
		Code.prototype.scopetype = function (){
			return Scope;
		};
		
		Code.prototype.visit = function (){
			if (this._scope) { this._scope.visit() };
			// @scope.parent = STACK.scope(1) if @scope
			return this;
		};
		
		
		// Rename to Program?
		function Root(body,opts){
			// p "create root!"
			this._traversed = false;
			this._body = blk__(body);
			this._scope = new RootScope(this,null);
			this._options = {};
		};
		
		subclass$(Root,Code);
		exports.Root = Root; // export class 
		Root.prototype.visit = function (){
			ROOT = STACK.ROOT = this._scope;
			this.scope().visit();
			return this.body().traverse();
		};
		
		Root.prototype.compile = function (o){
			STACK.reset(); // -- nested compilation does not work now
			OPTS = STACK._options = this._options = o || {};
			
			this.traverse();
			
			var out = this.c();
			var result = {
				js: out,
				ast: this,
				warnings: this.scope().warnings(),
				options: o,
				toString: function() { return this.js; }
			};
			if (o.sourceMapInline || o.sourceMap) {
				result.sourcemap = new SourceMap(result).generate();
			};
			
			return result;
		};
		
		Root.prototype.js = function (o){
			var out;
			if (this._options.bare) {
				out = this.scope().c();
			} else {
				this.body().consume(new ImplicitReturn());
				out = this.scope().c({indent: true});
				out = out.replace(/^\n?/,'\n');
				out = out.replace(/\n?$/,'\n\n');
				out = '(function(){' + out + '})()';
			};
			
			// find and replace shebangs
			var shebangs = [];
			out = out.replace(/^[ \t]*\/\/(\!.+)$/mg,function(m,shebang) {
				// p "found shebang {shebang}"
				shebang = shebang.replace(/\bimba\b/g,'node');
				shebangs.push(("#" + shebang + "\n"));
				return "";
			});
			
			out = shebangs.join('') + out;
			
			return out;
		};
		
		
		Root.prototype.analyze = function (pars){
			if(!pars||pars.constructor !== Object) pars = {};
			var loglevel = pars.loglevel !== undefined ? pars.loglevel : 0;
			var entities = pars.entities !== undefined ? pars.entities : false;
			var scopes = pars.scopes !== undefined ? pars.scopes : true;
			STACK.setLoglevel(loglevel);
			STACK._analyzing = true;
			ROOT = STACK.ROOT = this._scope;
			
			OPTS = {
				analysis: {
					entities: entities,
					scopes: scopes
				}
			};
			
			this.traverse();
			STACK._analyzing = false;
			
			return this.scope().dump();
		};
		
		Root.prototype.inspect = function (){
			return true;
		};
		
		function ClassDeclaration(name,superclass,body){
			// what about the namespace?
			this._traversed = false;
			this._name = name;
			this._superclass = superclass;
			this._scope = new ClassScope(this);
			this._body = blk__(body);
			this;
		};
		
		subclass$(ClassDeclaration,Code);
		exports.ClassDeclaration = ClassDeclaration; // export class 
		ClassDeclaration.prototype.name = function(v){ return this._name; }
		ClassDeclaration.prototype.setName = function(v){ this._name = v; return this; };
		ClassDeclaration.prototype.superclass = function(v){ return this._superclass; }
		ClassDeclaration.prototype.setSuperclass = function(v){ this._superclass = v; return this; };
		ClassDeclaration.prototype.initor = function(v){ return this._initor; }
		ClassDeclaration.prototype.setInitor = function(v){ this._initor = v; return this; };
		
		ClassDeclaration.prototype.consume = function (node){
			if (node instanceof Return) {
				this.option('return',true);
				return this;
			};
			return ClassDeclaration.__super__.consume.apply(this,arguments);
		};
		
		ClassDeclaration.prototype.namepath = function (){
			return this._namepath || (this._namepath = ("" + (this.name().c())));
		};
		
		ClassDeclaration.prototype.metadata = function (){
			var superclass_;
			return {
				type: 'class',
				namepath: this.namepath(),
				inherits: (superclass_ = this.superclass()) && superclass_.namepath  &&  superclass_.namepath(),
				path: this.name().c().toString(),
				desc: this._desc,
				loc: this.loc()
			};
		};
		
		ClassDeclaration.prototype.toJSON = function (){
			return this.metadata();
		};
		
		ClassDeclaration.prototype.visit = function (){
			// replace with some advanced lookup?
			ROOT.entities().add(this.namepath(),this);
			this.scope().visit();
			this.body().traverse();
			return this;
		};
		
		ClassDeclaration.prototype.js = function (o){
			this.scope().virtualize(); // is this always needed?
			this.scope().context().setValue(this.name());
			
			// should probably also warn about stuff etc
			if (this.option('extension')) {
				return this.body().c();
			};
			
			var head = [];
			var o = this._options || {};
			var cname = this.name() instanceof Access ? (this.name().right()) : (this.name());
			var namespaced = this.name() != cname;
			var initor = null;
			var sup = this.superclass();
			
			var bodyindex = -1;
			var spaces = this.body().filter(function(item) { return item instanceof Terminator; });
			var mark = mark__(this.option('keyword'));
			
			this.body().map(function(c,i) {
				if ((c instanceof MethodDeclaration) && c.type() == 'constructor') {
					return bodyindex = i;
				};
			});
			
			if (bodyindex >= 0) {
				initor = this.body().removeAt(bodyindex);
			};
			
			// var initor = body.pluck do |c| c isa MethodDeclaration && c.type == :constructor
			// compile the cname
			if (typeof cname != 'string') { cname = cname.c() };
			
			var cpath = typeof this.name() == 'string' ? (this.name()) : (this.name().c());
			
			if (!(initor)) {
				if (sup) {
					initor = ("" + mark + "function " + cname + "()\{ return " + (sup.c()) + ".apply(this,arguments) \};\n\n");
				} else {
					initor = ("" + mark + "function " + cname + "()") + '{ };\n\n';
				};
			} else {
				initor.setName(cname);
				initor = initor.c() + ';';
			};
			
			// if we are defining a class inside a namespace etc -- how should we set up the class?
			
			if (namespaced) {
				// should use Nodes to build this instead
				initor = ("" + cpath + " = " + initor); // OP('=',name,initor)
			};
			
			head.push(initor); // // @class {cname}\n
			
			if (bodyindex >= 0) {
				// add the space after initor?
				if (this.body().index(bodyindex) instanceof Terminator) {
					head.push(this.body().removeAt(bodyindex));
				};
			} else {
				// head.push(Terminator.new('\n\n'))
				true;
			};
			
			
			
			if (sup) {
				// console.log "deal with superclass!"
				// head.push("// extending the superclass\nimba$class({name.c},{sup.c});\n\n")
				head.push(new Util.Subclass([this.name(),sup]));
			};
			
			// only if it is not namespaced
			if (o.global && !(namespaced)) { // option(:global)
				head.push(("global." + cname + " = " + cpath + "; // global class \n"))
			};
			
			if (o.export && !(namespaced)) {
				head.push(("exports." + cname + " = " + cpath + "; // export class \n"))
			};
			
			// FIXME
			// if namespaced and (o:local or o:export)
			// 	console.log "namespaced classes are implicitly local/global depending on the namespace"
			
			if (this.option('return')) {
				this.body().push(("return " + cpath + ";"));
			};
			
			for (var i = 0, ary = iter$(head.reverse()), len = ary.length; i < len; i++) {
				this.body().unshift(ary[i]);
			};
			this.body()._indentation = null;
			var end = this.body().index(this.body().count() - 1);
			if ((end instanceof Terminator) && end.c().length == 1) { this.body().pop() };
			
			var out = this.body().c();
			
			return out;
		};
		
		
		function TagDeclaration(name,superclass,body){
			// what about the namespace?
			// @name = TagTypeRef.new(name)
			this._traversed = false;
			this._name = name;
			this._superclass = superclass;
			this._scope = new TagScope(this);
			this._body = blk__(body || []);
		};
		
		subclass$(TagDeclaration,Code);
		exports.TagDeclaration = TagDeclaration; // export class 
		TagDeclaration.prototype.name = function(v){ return this._name; }
		TagDeclaration.prototype.setName = function(v){ this._name = v; return this; };
		TagDeclaration.prototype.superclass = function(v){ return this._superclass; }
		TagDeclaration.prototype.setSuperclass = function(v){ this._superclass = v; return this; };
		TagDeclaration.prototype.initor = function(v){ return this._initor; }
		TagDeclaration.prototype.setInitor = function(v){ this._initor = v; return this; };
		
		TagDeclaration.prototype.namepath = function (){
			return ("<" + this.name() + ">");
		};
		
		TagDeclaration.prototype.toJSON = function (){
			return {
				type: 'tag',
				namepath: this.namepath(),
				inherits: this.superclass() ? (("<" + (this.superclass().name()) + ">")) : (null),
				loc: this.loc(),
				desc: this._desc
			};
		};
		
		TagDeclaration.prototype.visit = function (){
			ROOT.entities().register(this); // what if this is not local?
			
			for (var i = 0, ary = iter$(STACK.scopes()), len = ary.length, scope; i < len; i++) {
				scope = ary[i];
				if (i > 0 && (scope instanceof TagScope)) {
					// register inside here?
					scope.node().option('hasLocalTags',true);
					this.option('parent',scope.node());
					break;
					// console.log "tag is local!!!"
				};
			};
			// replace with some advanced lookup?
			this.scope().visit();
			return this.body().traverse();
		};
		
		TagDeclaration.prototype.id = function (){
			return this.name().id();
		};
		
		TagDeclaration.prototype.tagspace = function (){
			var ctx = this.scope().closure().tagContextPath();
			return this.name().ns() ? (("" + ctx + "." + (this.name().ns().toUpperCase()))) : (ctx);
		};
		
		TagDeclaration.prototype.js = function (o){
			this.scope().context().setValue(this._ctx = this.scope().declare('tag',null,{system: true}));
			
			var ns = this.name().ns();
			var mark = mark__(this.option('keyword'));
			
			var params = [helpers.singlequote(this.name().name())];
			var cbody = this.body().c();
			// var outbody = body.count ? ", function({@ctx.c})\{{cbody}\}" : ''
			
			if (this.superclass()) {
				// WARN what if the superclass has a namespace?
				params.push(helpers.singlequote(this.superclass().name()));
			};
			
			if (this.body().count()) {
				if (this.option('hasLocalTags')) {
					params.push(("function(" + (this._ctx.c()) + "," + (this.scope().closure().tagContextPath()) + ")\{" + cbody + "\}"));
				} else {
					params.push(("function(" + (this._ctx.c()) + ")\{" + cbody + "\}"));
				};
			};
			
			var meth = this.option('extension') ? ('extendTag') : ('defineTag');
			// return "{mark}{tagspace}.extendTag('{name.name}'{outbody})"
			
			// var sup = superclass and "," + helpers.singlequote(superclass.func) or ""
			
			// var out = if name.id
			//	"{mark}{tagspace}.defineSingleton('{name.name}'{sup}{outbody})"
			// else
			
			return ("" + mark + this.tagspace() + "." + meth + "(" + params.join(', ') + ")");
			
			// return out
		};
		
		function Func(params,body,name,target,o){
			// p "INIT Function!!",params,body,name
			var typ = this.scopetype();
			this._traversed = false;
			this._body = blk__(body);
			this._scope || (this._scope = (o && o.scope) || new typ(this));
			this._scope.setParams(this._params = new ParamList(params));
			this._name = name || '';
			this._target = target;
			this._options = o;
			this._type = 'function';
			this._variable = null;
			this;
		};
		
		subclass$(Func,Code);
		exports.Func = Func; // export class 
		Func.prototype.name = function(v){ return this._name; }
		Func.prototype.setName = function(v){ this._name = v; return this; };
		Func.prototype.params = function(v){ return this._params; }
		Func.prototype.setParams = function(v){ this._params = v; return this; };
		Func.prototype.target = function(v){ return this._target; }
		Func.prototype.setTarget = function(v){ this._target = v; return this; };
		Func.prototype.options = function(v){ return this._options; }
		Func.prototype.setOptions = function(v){ this._options = v; return this; };
		Func.prototype.type = function(v){ return this._type; }
		Func.prototype.setType = function(v){ this._type = v; return this; };
		Func.prototype.context = function(v){ return this._context; }
		Func.prototype.setContext = function(v){ this._context = v; return this; };
		
		Func.prototype.scopetype = function (){
			return FunctionScope;
		};
		
		Func.prototype.visit = function (){
			this.scope().visit();
			this._context = this.scope().parent();
			this._params.traverse();
			return this._body.traverse(); // so soon?
		};
		
		
		Func.prototype.js = function (o){
			if (!this.option('noreturn')) { this.body().consume(new ImplicitReturn()) };
			var ind = this.body()._indentation;
			// var s = ind and ind.@open
			// p "indent function? {body.@indentation} {s} {s:generated} {body.count}"
			if (ind && ind.isGenerated()) { this.body()._indentation = null };
			var code = this.scope().c({indent: (!(ind) || !ind.isGenerated()),braces: true});
			
			// args = params.map do |par| par.name
			// head = params.map do |par| par.c
			// code = [head,body.c(expression: no)].flatten__.compact.join("\n").wrap
			// FIXME creating the function-name this way is prone to create naming-collisions
			// will need to wrap the value in a FunctionName which takes care of looking up scope
			// and possibly dealing with it
			var name = typeof this._name == 'string' ? (this._name) : (this._name.c());
			name = name ? (' ' + name.replace(/\./g,'_')) : ('');
			var out = ("function" + name + "(" + (this.params().c()) + ") ") + code;
			if (this.option('eval')) { out = ("(" + out + ")()") };
			return out;
		};
		
		Func.prototype.shouldParenthesize = function (par){
			if(par === undefined) par = this.up();
			return (par instanceof Call) && par.callee() == this;
			// if up as a call? Only if we are 
		};
		
		function Lambda(){ return Func.apply(this,arguments) };
		
		subclass$(Lambda,Func);
		exports.Lambda = Lambda; // export class 
		Lambda.prototype.scopetype = function (){
			return LambdaScope;
		};
		
		function TagFragmentFunc(){ return Func.apply(this,arguments) };
		
		subclass$(TagFragmentFunc,Func);
		exports.TagFragmentFunc = TagFragmentFunc; // export class 
		
		
		// MethodDeclaration
		// Create a shared body?
		
		function MethodDeclaration(){ return Func.apply(this,arguments) };
		
		subclass$(MethodDeclaration,Func);
		exports.MethodDeclaration = MethodDeclaration; // export class 
		MethodDeclaration.prototype.variable = function(v){ return this._variable; }
		MethodDeclaration.prototype.setVariable = function(v){ this._variable = v; return this; };
		
		MethodDeclaration.prototype.scopetype = function (){
			return MethodScope;
		};
		
		MethodDeclaration.prototype.consume = function (node){
			if (node instanceof Return) {
				this.option('return',true);
				return this;
			};
			return MethodDeclaration.__super__.consume.apply(this,arguments);
		};
		
		MethodDeclaration.prototype.metadata = function (){
			return {
				type: "method",
				name: "" + this.name(),
				namepath: this.namepath(),
				params: this._params.metadata(),
				desc: this._desc,
				scopenr: this.scope()._nr,
				loc: this.loc()
			};
		};
		
		MethodDeclaration.prototype.loc = function (){
			var d;
			if (d = this.option('def')) {
				return [d._loc,this.body().loc()[1]];
			} else {
				return [0,0];
			};
		};
		
		
		MethodDeclaration.prototype.toJSON = function (){
			return this.metadata();
		};
		
		MethodDeclaration.prototype.namepath = function (){
			if (this._namepath) { return this._namepath };
			
			var name = String(this.name());
			var sep = (this.option('static') ? ('.') : ('#'));
			if (this.target()) {
				return this._namepath = this._target.namepath() + sep + name;
			} else {
				return this._namepath = '&' + name;
			};
		};
		
		MethodDeclaration.prototype.visit = function (){
			// @desc = stack.stash.pluck(Comment)
			// @desc = stack.stash.pluck(Comment)
			// prebreak # make sure this has a break?
			this.scope().visit();
			
			if (String(this.name()) == 'initialize') {
				this.setType('constructor');
			};
			
			if (this.option('greedy')) {
				this.warn("deprecated");
				// set(greedy: true)
				// p "BODY EXPRESSIONS!! This is a fragment"
				var tree = new TagTree();
				this._body = this.body().consume(tree);
				// body.nodes = [Arr.new(body.nodes)]
			};
			
			this._context = this.scope().parent().closure();
			this._params.traverse();
			
			if (this.target() instanceof Self) {
				this._target = this._context.context();
				this.set({static: true});
			};
			
			if (this.context() instanceof ClassScope) {
				this.context().annotate(this);
				this._target || (this._target = this.context().context());
				// register as class-method?
				// should register for this
				// console.log "context is classscope {@name}"
			};
			
			if (!this._target) {
				// should not be registered on the outermost closure?
				this._variable = this.context().register(this.name(),this,{type: 'meth'});
			};
			
			ROOT.entities().add(this.namepath(),this);
			this._body.traverse(); // so soon?
			return this;
		};
		
		MethodDeclaration.prototype.supername = function (){
			return this.type() == 'constructor' ? (this.type()) : (this.name());
		};
		
		
		// FIXME export global etc are NOT valid for methods inside any other scope than
		// the outermost scope (root)
		
		MethodDeclaration.prototype.js = function (o){
			// FIXME Do this in the grammar - remnants of old implementation
			if (!(this.type() == 'constructor' || this.option('noreturn'))) {
				if (this.option('greedy')) {
					// haaack
					this.body().consume(new GreedyReturn());
				} else {
					this.body().consume(new ImplicitReturn());
				};
			};
			
			var code = this.scope().c({indent: true,braces: true});
			
			// same for Func -- should generalize
			var name = typeof this._name == 'string' ? (this._name) : (this._name.c());
			name = name.replace(/\./g,'_');
			
			// var name = self.name.c.replace(/\./g,'_') # WHAT?
			var foot = [];
			
			var left = "";
			var func = ("(" + (this.params().c()) + ")") + code; // .wrap
			var target = this.target();
			var decl = !this.option('global') && !this.option('export');
			
			if (target instanceof ScopeContext) {
				// the target is a scope context
				target = null;
			};
			
			var ctx = this.context();
			var out = "";
			var mark = mark__(this.option('def'));
			// if ctx 
			
			var fname = sym__(this.name());
			// console.log "symbolize {self.name} -- {fname}"
			var fdecl = fname; // decl ? fname : ''
			
			if ((ctx instanceof ClassScope) && !(target)) {
				if (this.type() == 'constructor') {
					out = ("" + mark + "function " + fname + func);
				} else if (this.option('static')) {
					out = ("" + mark + (ctx.context().c()) + "." + fname + " = function " + func);
				} else {
					out = ("" + mark + (ctx.context().c()) + ".prototype." + fname + " = function " + func);
				};
			} else if ((ctx instanceof RootScope) && !(target)) {
				// register method as a root-function, but with auto-call? hmm
				// should probably set using variable directly instead, no?
				out = ("" + mark + "function " + fdecl + func);
			} else if (target && this.option('static')) {
				out = ("" + mark + (target.c()) + "." + fname + " = function " + func);
			} else if (target) {
				out = ("" + mark + (target.c()) + ".prototype." + fname + " = function " + func);
			} else {
				out = ("" + mark + "function " + fdecl + func);
			};
			
			if (this.option('global')) {
				out = ("" + fname + " = " + out);
			};
			
			if (this.option('export')) {
				out = ("" + out + "; exports." + fname + " = " + fname + ";");
				if (this.option('return')) { out = ("" + out + "; return " + fname + ";") };
			} else if (this.option('return')) {
				out = ("return " + out);
			};
			
			return out;
		};
		
		
		function TagFragmentDeclaration(){ return MethodDeclaration.apply(this,arguments) };
		
		subclass$(TagFragmentDeclaration,MethodDeclaration);
		exports.TagFragmentDeclaration = TagFragmentDeclaration; // export class 
		
		
		
		function PropertyDeclaration(name,options,token){
			this._token = token;
			this._traversed = false;
			this._name = name;
			this._options = options || new Obj(new AssignList());
		};
		
		subclass$(PropertyDeclaration,Node);
		exports.PropertyDeclaration = PropertyDeclaration; // export class 
		var propTemplate = '${headers}\n${path}.${getter} = function(v){ return ${get}; }\n${path}.${setter} = function(v){ ${set}; return this; }\n${init}';
		
		var propWatchTemplate = '${headers}\n${path}.${getter} = function(v){ return ${get}; }\n${path}.${setter} = function(v){\n	var a = this.${getter}();\n	if(v != a) { ${set}; }\n	if(v != a) { ${ondirty} }\n	return this;\n}\n${init}';
		
		PropertyDeclaration.prototype.name = function(v){ return this._name; }
		PropertyDeclaration.prototype.setName = function(v){ this._name = v; return this; };
		PropertyDeclaration.prototype.options = function(v){ return this._options; }
		PropertyDeclaration.prototype.setOptions = function(v){ this._options = v; return this; };
		
		PropertyDeclaration.prototype.visit = function (){
			this._options.traverse();
			return this;
		};
		
		// This will soon support bindings / listeners etc, much more
		// advanced generated code based on options passed in.
		PropertyDeclaration.prototype.c = function (){
			var o = this.options();
			var ast = "";
			var key = this.name().js();
			var scope = STACK.scope();
			
			var addDesc = o.keys().length;
			
			var pars = o.hash();
			
			var isAttr = (this._token && String(this._token) == 'attr') || o.key('attr');
			
			var js = {
				key: key,
				getter: key,
				setter: sym__(("set-" + key)),
				scope: ("" + (scope.context().c())),
				path: '${scope}.prototype',
				set: ("this._" + key + " = v"),
				get: ("this._" + key),
				init: "",
				headers: "",
				ondirty: ""
			};
			
			
			if (pars.inline) {
				if ((pars.inline instanceof Bool) && !pars.inline.truthy()) {
					o.remove('inline');
					// p "dont make attr inline(!)"
					return ("Imba." + (this._token) + "(" + (js.scope) + ",'" + (this.name().value()) + "'," + (o.c()) + ")").replace(',{})',')');
				};
				
				// p "pars inline?!? {pars:inline}", typeof pars:inline
			};
			
			var tpl = propTemplate;
			
			o.add('name',new Symbol(key));
			
			if (pars.watch) {
				// p "watch is a property {pars:watch}"
				if (!((pars.watch instanceof Bool) && !pars.watch.truthy())) { tpl = propWatchTemplate };
				var wfn = ("" + key + "DidSet");
				
				if (pars.watch instanceof Symbol) {
					wfn = pars.watch;
				} else if (pars.watch instanceof Bool) {
					o.key('watch').setValue(new Symbol(("" + key + "DidSet")));
				};
				
				var fn = OP('.',new This(),wfn);
				js.ondirty = OP('&&',fn,CALL(fn,['v','a',("this.__" + key)])).c();
			};
			
			if (pars.observe) {
				if (pars.observe instanceof Bool) {
					o.key('observe').setValue(new Symbol(("" + key + "DidEmit")));
				};
				
				tpl = propWatchTemplate;
				js.ondirty = ("Imba.observeProperty(this,'" + key + "'," + (o.key('observe').value().c()) + ",v,a);") + (js.ondirty || '');
				// OP('&&',fn,CALL(fn,['v','a',"this.__{key}"])).c
			};
			
			if ((this._token && String(this._token) == 'attr') || o.key('dom') || o.key('attr')) {
				var attrKey = o.key('dom') instanceof Str ? (o.key('dom')) : (this.name().value());
				// need to make sure o has a key for attr then - so that the delegate can know?
				js.set = ("this.setAttribute('" + attrKey + "',v)");
				js.get = ("this.getAttribute('" + attrKey + "')");
			} else if (o.key('delegate')) {
				// if we have a delegate
				js.set = ("v = this.__" + key + ".delegate.set(this,'" + key + "',v,this.__" + key + ")");
				js.get = ("this.__" + key + ".delegate.get(this,'" + key + "',this.__" + key + ")");
			};
			
			
			
			if (pars.default) {
				if (o.key('dom')) {
					// FIXME go through class-method setAttribute instead
					js.init = ("" + (js.scope) + ".dom().setAttribute('" + key + "'," + (pars.default.c()) + ");");
				} else {
					// if this is not a primitive - it MUST be included in the
					// getter / setter instead
					js.init = ("" + (js.scope) + ".prototype._" + key + " = " + (pars.default.c()) + ";");
				};
			};
			
			if (o.key('chainable')) {
				js.get = ("v !== undefined ? (this." + (js.setter) + "(v),this) : " + (js.get));
			};
			
			
			js.options = o.c();
			
			if (addDesc) {
				js.headers = ("" + (js.path) + ".__" + (js.getter) + " = " + (js.options) + ";");
			};
			
			var reg = /\$\{(\w+)\}/gm;
			// var tpl = o.key(:watch) ? propWatchTemplate : propTemplate
			var out = tpl.replace(reg,function(m,a) { return js[a]; });
			// run another time for nesting. hacky
			out = out.replace(reg,function(m,a) { return js[a]; });
			// out = out.replace(/\n\s*$/,'')
			out = out.replace(/^\s+|\s+$/g,'');
			
			// if o.key(:v)
			return out;
		};
		
		
		
		// Literals should probably not inherit from the same parent
		// as arrays, tuples, objects would be better off inheriting
		// from listnode.
		
		function Literal(v){
			this._traversed = false;
			this._expression = true;
			this._cache = null;
			this._raw = null;
			this._value = v;
		};
		
		subclass$(Literal,ValueNode);
		exports.Literal = Literal; // export class 
		Literal.prototype.toString = function (){
			return "" + this.value();
		};
		
		Literal.prototype.hasSideEffects = function (){
			return false;
		};
		
		
		function Bool(v){
			this._value = v;
			this._raw = String(v) == "true" ? (true) : (false);
		};
		
		subclass$(Bool,Literal);
		exports.Bool = Bool; // export class 
		Bool.prototype.cache = function (){
			return this;
		};
		
		Bool.prototype.isPrimitive = function (){
			return true;
		};
		
		Bool.prototype.truthy = function (){
			// p "bool is truthy? {value}"
			return String(this.value()) == "true";
			// yes
		};
		
		Bool.prototype.js = function (o){
			return String(this._value);
		};
		
		Bool.prototype.c = function (){
			STACK._counter += 1;
			// undefined should not be a bool
			return String(this._value);
			// @raw ? "true" : "false"
		};
		
		Bool.prototype.toJSON = function (){
			return {type: 'Bool',value: this._value};
		};
		
		function Undefined(){ return Literal.apply(this,arguments) };
		
		subclass$(Undefined,Literal);
		exports.Undefined = Undefined; // export class 
		Undefined.prototype.isPrimitive = function (){
			return true;
		};
		
		Undefined.prototype.c = function (){
			return mark__(this._value) + "undefined";
		};
		
		function Nil(){ return Literal.apply(this,arguments) };
		
		subclass$(Nil,Literal);
		exports.Nil = Nil; // export class 
		Nil.prototype.isPrimitive = function (){
			return true;
		};
		
		Nil.prototype.c = function (){
			return mark__(this._value) + "null";
		};
		
		function True(){ return Bool.apply(this,arguments) };
		
		subclass$(True,Bool);
		exports.True = True; // export class 
		True.prototype.raw = function (){
			return true;
		};
		
		True.prototype.c = function (){
			return mark__(this._value) + "true";
		};
		
		function False(){ return Bool.apply(this,arguments) };
		
		subclass$(False,Bool);
		exports.False = False; // export class 
		False.prototype.raw = function (){
			return false;
		};
		
		False.prototype.c = function (){
			return mark__(this._value) + "false";
		};
		
		function Num(v){
			this._traversed = false;
			this._value = v;
		};
		
		subclass$(Num,Literal);
		exports.Num = Num; // export class 
		Num.prototype.toString = function (){
			return String(this._value);
		};
		
		Num.prototype.isPrimitive = function (deep){
			return true;
		};
		
		Num.prototype.shouldParenthesize = function (par){
			if(par === undefined) par = this.up();
			return (par instanceof Access) && par.left() == this;
		};
		
		Num.prototype.js = function (o){
			var num = String(this._value);
			// console.log "compiled num to {num}"
			return num;
		};
		
		Num.prototype.c = function (o){
			if (this._cache) { return Num.__super__.c.call(this,o) };
			var js = String(this._value);
			var par = STACK.current();
			var paren = (par instanceof Access) && par.left() == this;
			// only if this is the right part of teh acces
			// console.log "should paren?? {shouldParenthesize}"
			return paren ? (("(" + mark__(this._value)) + js + ")") : ((mark__(this._value) + js));
			// @cache ? super(o) : String(@value)
		};
		
		Num.prototype.cache = function (o){
			// p "cache num",o
			if (!(o && (o.cache || o.pool))) { return this };
			return Num.__super__.cache.call(this,o);
		};
		
		Num.prototype.raw = function (){
			// really?
			return JSON.parse(String(this.value()));
		};
		
		Num.prototype.toJSON = function (){
			return {type: this.typeName(),value: this.raw()};
		};
		
		// should be quoted no?
		// what about strings in object-literals?
		// we want to be able to see if the values are allowed
		function Str(v){
			this._traversed = false;
			this._expression = true;
			this._cache = null;
			this._value = v;
			// should grab the actual value immediately?
		};
		
		subclass$(Str,Literal);
		exports.Str = Str; // export class 
		Str.prototype.isString = function (){
			return true;
		};
		
		Str.prototype.isPrimitive = function (deep){
			return true;
		};
		
		Str.prototype.raw = function (){
			// JSON.parse requires double-quoted strings,
			// while eval also allows single quotes. 
			// NEXT eval is not accessible like this
			// WARNING TODO be careful! - should clean up
			
			return this._raw || (this._raw = String(this.value()).slice(1,-1)); // incredibly stupid solution
		};
		
		Str.prototype.isValidIdentifier = function (){
			// there are also some values we cannot use
			return this.raw().match(/^[a-zA-Z\$\_]+[\d\w\$\_]*$/) ? (true) : (false);
		};
		
		Str.prototype.js = function (o){
			return String(this._value);
		};
		
		Str.prototype.c = function (o){
			return this._cache ? (Str.__super__.c.call(this,o)) : (String(this._value));
		};
		
		
		function Interpolation(){ return ValueNode.apply(this,arguments) };
		
		subclass$(Interpolation,ValueNode);
		exports.Interpolation = Interpolation; // export class 
		
		
		// Currently not used - it would be better to use this
		// for real interpolated strings though, than to break
		// them up into their parts before parsing
		function InterpolatedString(nodes,o){
			if(o === undefined) o = {};
			this._nodes = nodes;
			this._options = o;
			this;
		};
		
		subclass$(InterpolatedString,Node);
		exports.InterpolatedString = InterpolatedString; // export class 
		InterpolatedString.prototype.add = function (part){
			if (part) { this._nodes.push(part) };
			return this;
		};
		
		InterpolatedString.prototype.visit = function (){
			for (var i = 0, ary = iter$(this._nodes), len = ary.length; i < len; i++) {
				ary[i].traverse();
			};
			return this;
		};
		
		InterpolatedString.prototype.escapeString = function (str){
			// var idx = 0
			// var len = str:length
			// var chr
			// while chr = str[idx++]
			return str = str.replace(/\n/g,'\\\n');
		};
		
		InterpolatedString.prototype.js = function (o){
			// creating the string
			var self = this;
			var parts = [];
			var str = '(';
			
			self._nodes.map(function(part,i) {
				if ((part instanceof Token) && part._type == 'NEOSTRING') {
					// esca
					return parts.push('"' + self.escapeString(part._value) + '"');
				} else if (part) {
					if (i == 0) {
						// force first part to be string
						parts.push('""');
					};
					part._parens = true;
					return parts.push(part.c({expression: true}));
				};
			});
			
			str += parts.join(" + ");
			str += ')';
			return str;
		};
		
		
		function Tuple(){ return ListNode.apply(this,arguments) };
		
		subclass$(Tuple,ListNode);
		exports.Tuple = Tuple; // export class 
		Tuple.prototype.c = function (){
			// compiles as an array
			return new Arr(this.nodes()).c();
		};
		
		Tuple.prototype.hasSplat = function (){
			return this.filter(function(v) { return v instanceof Splat; })[0];
		};
		
		Tuple.prototype.consume = function (node){
			if (this.count() == 1) {
				return this.first().consume(node);
			} else {
				throw "multituple cannot consume";
			};
		};
		
		
		// Because we've dropped the Str-wrapper it is kinda difficult
		function Symbol(){ return Literal.apply(this,arguments) };
		
		subclass$(Symbol,Literal);
		exports.Symbol = Symbol; // export class 
		Symbol.prototype.isValidIdentifier = function (){
			return this.raw().match(/^[a-zA-Z\$\_]+[\d\w\$\_]*$/) ? (true) : (false);
		};
		
		Symbol.prototype.isPrimitive = function (deep){
			return true;
		};
		
		Symbol.prototype.raw = function (){
			return this._raw || (this._raw = sym__(this.value()));
		};
		
		Symbol.prototype.js = function (o){
			return ("'" + sym__(this.value()) + "'");
		};
		
		function RegExp(){ return Literal.apply(this,arguments) };
		
		subclass$(RegExp,Literal);
		exports.RegExp = RegExp; // export class 
		RegExp.prototype.isPrimitive = function (){
			return true;
		};
		
		// def toString
		// 	"" + value
		;
		
		// Should inherit from ListNode - would simplify
		function Arr(){ return Literal.apply(this,arguments) };
		
		subclass$(Arr,Literal);
		exports.Arr = Arr; // export class 
		Arr.prototype.load = function (value){
			return value instanceof Array ? (new ArgList(value)) : (value);
		};
		
		Arr.prototype.push = function (item){
			this.value().push(item);
			return this;
		};
		
		Arr.prototype.count = function (){
			return this.value().length;
		};
		
		Arr.prototype.nodes = function (){
			var val = this.value();
			return val instanceof Array ? (val) : (val.nodes());
		};
		
		Arr.prototype.splat = function (){
			return this.value().some(function(v) { return v instanceof Splat; });
		};
		
		Arr.prototype.visit = function (){
			if (this._value && this._value.traverse) { this._value.traverse() };
			return this;
		};
		
		Arr.prototype.isPrimitive = function (deep){
			return !this.value().some(function(v) { return !v.isPrimitive(true); });
		};
		
		Arr.prototype.js = function (o){
			
			var val = this._value;
			if (!(val)) { return "[]" };
			
			var splat = this.splat();
			var nodes = val instanceof Array ? (val) : (val.nodes());
			// p "value of array isa {@value}"
			
			// for v in @value
			// 	break splat = yes if v isa Splat
			// var splat = value.some(|v| v isa Splat)
			
			if (splat) {
				// "SPLATTED ARRAY!"
				// if we know for certain that the splats are arrays we can drop the slice?
				// p "array is splat?!?"
				var slices = [];
				var group = null;
				
				for (var i = 0, ary = iter$(nodes), len = ary.length, v; i < len; i++) {
					v = ary[i];
					if (v instanceof Splat) {
						slices.push(v);
						group = null;
					} else {
						if (!(group)) { slices.push(group = new Arr([])) };
						group.push(v);
					};
				};
				
				return ("[].concat(" + cary__(slices).join(", ") + ")");
			} else {
				// very temporary. need a more generic way to prettify code
				// should depend on the length of the inner items etc
				// if @indented or option(:indent) or value.@indented
				//	"[\n{value.c.join(",\n").indent}\n]"
				var out = val instanceof Array ? (cary__(val)) : (val.c());
				return ("[" + out + "]");
			};
		};
		
		Arr.prototype.hasSideEffects = function (){
			return this.value().some(function(v) { return v.hasSideEffects(); });
		};
		
		Arr.prototype.toString = function (){
			return "Arr";
		};
		
		Arr.prototype.indented = function (a,b){
			this._value.indented(a,b);
			return this;
		};
		
		Arr.wrap = function (val){
			return new Arr(val);
		};
		
		// should not be cklassified as a literal?
		function Obj(){ return Literal.apply(this,arguments) };
		
		subclass$(Obj,Literal);
		exports.Obj = Obj; // export class 
		Obj.prototype.load = function (value){
			return value instanceof Array ? (new AssignList(value)) : (value);
		};
		
		Obj.prototype.visit = function (){
			if (this._value) { this._value.traverse() };
			// for v in value
			// 	v.traverse
			return this;
		};
		
		Obj.prototype.js = function (o){
			var dyn = this.value().filter(function(v) { return (v instanceof ObjAttr) && ((v.key() instanceof Op) || (v.key() instanceof InterpolatedString)); });
			
			if (dyn.length > 0) {
				var idx = this.value().indexOf(dyn[0]);
				// p "dynamic keys! {dyn}"
				// create a temp variable
				
				var tmp = this.scope__().temporary(this);
				// set the temporary object to the same
				var first = this.value().slice(0,idx);
				var obj = new Obj(first);
				var ast = [OP('=',tmp,obj)];
				
				this.value().slice(idx).forEach(function(atr) {
					return ast.push(OP('=',OP('.',tmp,atr.key()),atr.value()));
				});
				ast.push(tmp); // access the tmp at in the last part
				return new Parens(ast).c();
			};
			
			// for objects with expression-keys we need to think differently
			return '{' + this.value().c() + '}';
		};
		
		Obj.prototype.add = function (k,v){
			if ((typeof k=='string'||k instanceof String)) { k = new Identifier(k) };
			var kv = new ObjAttr(k,v);
			this.value().push(kv);
			return kv;
		};
		
		Obj.prototype.remove = function (key){
			for (var i = 0, ary = iter$(this.value()), len = ary.length, k; i < len; i++) {
				k = ary[i];
				if (k.key().symbol() == key) { this.value().remove(k) };
			};
			return this;
		};
		
		Obj.prototype.keys = function (){
			return Object.keys(this.hash());
		};
		
		Obj.prototype.hash = function (){
			var hash = {};
			for (var i = 0, ary = iter$(this.value()), len = ary.length, k; i < len; i++) {
				k = ary[i];
				if (k instanceof ObjAttr) { hash[k.key().symbol()] = k.value() };
			};
			return hash;
			// return k if k.key.symbol == key
		};
		
		// add method for finding properties etc?
		Obj.prototype.key = function (key){
			for (var i = 0, ary = iter$(this.value()), len = ary.length, k; i < len; i++) {
				k = ary[i];
				if ((k instanceof ObjAttr) && k.key().symbol() == key) { return k };
			};
			return null;
		};
		
		Obj.prototype.indented = function (a,b){
			this._value.indented(a,b);
			return this;
		};
		
		Obj.prototype.hasSideEffects = function (){
			return this.value().some(function(v) { return v.hasSideEffects(); });
		};
		
		// for converting a real object into an ast-representation
		Obj.wrap = function (obj){
			var attrs = [];
			for (var v, i = 0, keys = Object.keys(obj), l = keys.length; i < l; i++){
				v = obj[keys[i]];if (v instanceof Array) {
					v = Arr.wrap(v);
				} else if (v.constructor == Object) {
					v = Obj.wrap(v);
				};
				attrs.push(new ObjAttr(keys[i],v));
			};
			return new Obj(attrs);
		};
		
		Obj.prototype.toString = function (){
			return "Obj";
		};
		
		function ObjAttr(key,value){
			this._traversed = false;
			this._key = key;
			this._value = value;
			this._dynamic = (key instanceof Op);
			this;
		};
		
		subclass$(ObjAttr,Node);
		exports.ObjAttr = ObjAttr; // export class 
		ObjAttr.prototype.key = function(v){ return this._key; }
		ObjAttr.prototype.setKey = function(v){ this._key = v; return this; };
		ObjAttr.prototype.value = function(v){ return this._value; }
		ObjAttr.prototype.setValue = function(v){ this._value = v; return this; };
		ObjAttr.prototype.options = function(v){ return this._options; }
		ObjAttr.prototype.setOptions = function(v){ this._options = v; return this; };
		
		ObjAttr.prototype.visit = function (){
			// should probably traverse key as well, unless it is a dead simple identifier
			this.key().traverse();
			return this.value().traverse();
		};
		
		ObjAttr.prototype.js = function (o){
			var k = this.key().isReserved() ? (("'" + (this.key().c()) + "'")) : (this.key().c());
			return ("" + k + ": " + (this.value().c()));
		};
		
		ObjAttr.prototype.hasSideEffects = function (){
			return true;
		};
		
		
		
		function ArgsReference(){ return Node.apply(this,arguments) };
		
		subclass$(ArgsReference,Node);
		exports.ArgsReference = ArgsReference; // export class 
		ArgsReference.prototype.c = function (){
			return "arguments";
		};
		
		// should be a separate Context or something
		function Self(scope){
			this._scope = scope;
		};
		
		subclass$(Self,Literal);
		exports.Self = Self; // export class 
		Self.prototype.scope = function(v){ return this._scope; }
		Self.prototype.setScope = function(v){ this._scope = v; return this; };
		
		Self.prototype.cache = function (){
			return this;
		};
		
		Self.prototype.reference = function (){
			return this;
		};
		
		Self.prototype.c = function (){
			var s = this.scope__();
			return s ? (s.context().c()) : ("this");
		};
		
		function ImplicitSelf(){ return Self.apply(this,arguments) };
		
		subclass$(ImplicitSelf,Self);
		exports.ImplicitSelf = ImplicitSelf; // export class 
		
		
		function This(){ return Self.apply(this,arguments) };
		
		subclass$(This,Self);
		exports.This = This; // export class 
		This.prototype.cache = function (){
			return this;
		};
		
		This.prototype.reference = function (){
			// p "referencing this"
			return this;
		};
		
		This.prototype.c = function (){
			return "this";
		};
		
		
		
		
		// OPERATORS
		
		function Op(o,l,r){
			// set expression yes, no?
			this._expression = false;
			this._traversed = false;
			this._parens = false;
			this._cache = null;
			this._invert = false;
			this._opToken = o;
			this._op = o && o._value || o;
			this._left = l;
			this._right = r;
			return this;
		};
		
		subclass$(Op,Node);
		exports.Op = Op; // export class 
		Op.prototype.op = function(v){ return this._op; }
		Op.prototype.setOp = function(v){ this._op = v; return this; };
		Op.prototype.left = function(v){ return this._left; }
		Op.prototype.setLeft = function(v){ this._left = v; return this; };
		Op.prototype.right = function(v){ return this._right; }
		Op.prototype.setRight = function(v){ this._right = v; return this; };
		
		Op.prototype.visit = function (){
			if (this._right) { this._right.traverse() };
			if (this._left) { this._left.traverse() };
			return this;
		};
		
		Op.prototype.isExpressable = function (){
			// what if right is a string?!?
			return !(this.right()) || this.right().isExpressable();
		};
		
		Op.prototype.js = function (o){
			var out = null;
			var op = this._op;
			
			var l = this._left;
			var r = this._right;
			
			if (l instanceof Node) { l = l.c() };
			if (r instanceof Node) { r = r.c() };
			
			if (l && r) {
				out = ("" + l + " " + mark__(this._opToken) + op + " " + r);
			} else if (l) {
				out = ("" + mark__(this._opToken) + op + l);
			};
			// out = out.parenthesize if up isa Op # really?
			return out;
		};
		
		Op.prototype.shouldParenthesize = function (){
			return this._parens;
			// option(:parens)
		};
		
		Op.prototype.precedence = function (){
			return 10;
		};
		
		Op.prototype.consume = function (node){
			// p 'assignify if?!'
			// if it is possible, convert into expression
			if (node instanceof TagTree) {
				if (this._left) { this._left.consume(node) };
				if (this._right) { this._right.consume(node) };
				// @body = @body.consume(node)
				// @alt = @alt.consume(node) if @alt
				return this;
			};
			// p "Op.consume {node}".cyan
			if (this.isExpressable()) { return Op.__super__.consume.apply(this,arguments) };
			
			// TODO can rather use global caching?
			var tmpvar = this.scope__().declare('tmp',null,{system: true});
			var clone = OP(this.op(),this.left(),null);
			var ast = this.right().consume(clone);
			if (node) { ast.consume(node) };
			return ast;
		};
		
		function ComparisonOp(){ return Op.apply(this,arguments) };
		
		subclass$(ComparisonOp,Op);
		exports.ComparisonOp = ComparisonOp; // export class 
		ComparisonOp.prototype.invert = function (){
			// are there other comparison ops?
			// what about a chain?
			var op = this._op;
			var pairs = ["==","!=","===","!==",">","<=","<",">="];
			var idx = pairs.indexOf(op);
			idx += (idx % 2 ? (-1) : (1));
			
			// p "invert {@op}"
			// p "inverted comparison(!) {idx} {op} -> {pairs[idx]}"
			this.setOp(pairs[idx]);
			this._invert = !this._invert;
			return this;
		};
		
		ComparisonOp.prototype.c = function (){
			if (this.left() instanceof ComparisonOp) {
				this.left().right().cache();
				return OP('&&',this.left(),OP(this.op(),this.left().right(),this.right())).c();
			} else {
				return ComparisonOp.__super__.c.apply(this,arguments);
			};
		};
		
		ComparisonOp.prototype.js = function (o){
			var op = this._op;
			var l = this._left;
			var r = this._right;
			
			if (l instanceof Node) { l = l.c() };
			if (r instanceof Node) { r = r.c() };
			return ("" + l + " " + mark__(this._opToken) + op + " " + r);
		};
		
		
		function MathOp(){ return Op.apply(this,arguments) };
		
		subclass$(MathOp,Op);
		exports.MathOp = MathOp; // export class 
		MathOp.prototype.c = function (){
			if (this.op() == '∪') {
				return this.util().union(this.left(),this.right()).c();
			} else if (this.op() == '∩') {
				return this.util().intersect(this.left(),this.right()).c();
			};
		};
		
		
		function UnaryOp(){ return Op.apply(this,arguments) };
		
		subclass$(UnaryOp,Op);
		exports.UnaryOp = UnaryOp; // export class 
		UnaryOp.prototype.invert = function (){
			if (this.op() == '!') {
				return this.left();
			} else {
				return UnaryOp.__super__.invert.apply(this,arguments); // regular invert
			};
		};
		
		UnaryOp.prototype.js = function (o){
			var l = this._left;
			var r = this._right;
			// all of this could really be done i a much
			// cleaner way.
			// l.set(parens: yes) if l # are we really sure about this?
			// r.set(parens: yes) if r
			
			if (this.op() == '!') {
				// l.@parens = yes
				var str = l.c();
				var paren = l.shouldParenthesize(this);
				// p "check for parens in !: {str} {l} {l.@parens} {l.shouldParenthesize(self)}"
				// FIXME this is a very hacky workaround. Need to handle all this
				// in the child instead, problems arise due to automatic caching
				if (!(str.match(/^\!?([\w\.]+)$/) || (l instanceof Parens) || paren || (l instanceof Access) || (l instanceof Call))) { str = '(' + str + ')' };
				// l.set(parens: yes) # sure?
				return ("" + this.op() + str);
			} else if (this.op() == '√') {
				return ("Math.sqrt(" + (l.c()) + ")");
			} else if (this.left()) {
				return ("" + (l.c()) + this.op());
			} else {
				return ("" + this.op() + (r.c()));
			};
		};
		
		UnaryOp.prototype.normalize = function (){
			if (this.op() == '!' || this.op() == '√') { return this };
			var node = (this.left() || this.right()).node();
			// for property-accessors we need to rewrite the ast
			if (!((node instanceof PropertyAccess))) { return this };
			
			// ask to cache the path
			if ((node instanceof Access) && node.left()) { node.left().cache() };
			
			var num = new Num(1);
			var ast = OP('=',node,OP(this.op()[0],node,num));
			if (this.left()) { ast = OP(this.op()[0] == '-' ? ('+') : ('-'),ast,num) };
			
			return ast;
		};
		
		UnaryOp.prototype.consume = function (node){
			var norm = this.normalize();
			return norm == this ? (UnaryOp.__super__.consume.apply(this,arguments)) : (norm.consume(node));
		};
		
		UnaryOp.prototype.c = function (){
			var norm = this.normalize();
			return norm == this ? (UnaryOp.__super__.c.apply(this,arguments)) : (norm.c());
		};
		
		function InstanceOf(){ return Op.apply(this,arguments) };
		
		subclass$(InstanceOf,Op);
		exports.InstanceOf = InstanceOf; // export class 
		InstanceOf.prototype.js = function (o){
			// fix checks for String and Number
			// p right.inspect
			
			if (this.right() instanceof Const) {
				// WARN otherwise - what do we do? does not work with dynamic
				// classes etc? Should probably send to utility function isa$
				var name = c__(this.right().value());
				var obj = this.left().node();
				// TODO also check for primitive-constructor
				if (idx$(name,['String','Number','Boolean']) >= 0) {
					if (!((obj instanceof LocalVarAccess))) {
						obj.cache();
					};
					// need a double check for these (cache left) - possibly
					return ("(typeof " + (obj.c()) + "=='" + (name.toLowerCase()) + "'||" + (obj.c()) + " instanceof " + name + ")");
					
					// convert
				};
			};
			var out = ("" + (this.left().c()) + " " + this.op() + " " + (this.right().c()));
			
			// should this not happen in #c?
			if (o.parent() instanceof Op) { out = helpers.parenthesize(out) };
			return out;
		};
		
		function TypeOf(){ return Op.apply(this,arguments) };
		
		subclass$(TypeOf,Op);
		exports.TypeOf = TypeOf; // export class 
		TypeOf.prototype.js = function (o){
			return ("typeof " + (this.left().c()));
		};
		
		function Delete(){ return Op.apply(this,arguments) };
		
		subclass$(Delete,Op);
		exports.Delete = Delete; // export class 
		Delete.prototype.js = function (o){
			// TODO this will execute calls several times if the path is not directly to an object
			// need to cache the receiver
			var l = this.left();
			var tmp = this.scope__().temporary(this,{pool: 'val'});
			var o = OP('=',tmp,l);
			// FIXME
			return ("(" + (o.c()) + ",delete " + (l.c()) + ", " + (tmp.c()) + ")"); // oh well
			// var ast = [OP('=',tmp,left),"delete {left.c}",tmp]
			// should parenthesize directly no?
			// ast.c
		};
		
		Delete.prototype.shouldParenthesize = function (){
			return true;
		};
		
		function In(){ return Op.apply(this,arguments) };
		
		subclass$(In,Op);
		exports.In = In; // export class 
		In.prototype.invert = function (){
			this._invert = !this._invert;
			return this;
		};
		
		In.prototype.js = function (o){
			var cond = this._invert ? ("== -1") : (">= 0");
			var idx = Util.indexOf(this.left(),this.right());
			return ("" + (idx.c()) + " " + cond);
		};
		
		
		
		
		
		
		
		// ACCESS
		
		module.exports.K_IVAR = K_IVAR = 1;
		module.exports.K_SYM = K_SYM = 2;
		module.exports.K_STR = K_STR = 3;
		module.exports.K_PROP = K_PROP = 4;
		
		function Access(o,l,r){
			// set expression yes, no?
			this._expression = false;
			this._traversed = false;
			this._parens = false;
			this._cache = null;
			this._invert = false;
			this._op = o && o._value || o;
			this._left = l;
			this._right = r;
			return this;
		};
		
		subclass$(Access,Op);
		exports.Access = Access; // export class 
		Access.prototype.clone = function (left,right){
			var ctor = this.constructor;
			return new ctor(this.op(),left,right);
		};
		
		Access.prototype.js = function (o){
			var r;
			var raw = null;
			var rgt = this.right();
			var ctx = (this.left() || this.scope__().context());
			var pre = "";
			var mark = '';
			
			// if safechain
			//	p "Access is safechained {rgt.c}"
			
			
			if (rgt instanceof Num) {
				return ctx.c() + "[" + rgt.c() + "]";
			};
			
			// is this right? Should not the index compile the brackets
			// or value is a symbol -- should be the same, no?
			if ((rgt instanceof Index) && ((rgt.value() instanceof Str) || (rgt.value() instanceof Symbol))) {
				rgt = rgt.value();
			};
			
			// TODO do the identifier-validation in a central place instead
			if ((rgt instanceof Str) && rgt.isValidIdentifier()) {
				raw = rgt.raw();
			} else if ((rgt instanceof Symbol) && rgt.isValidIdentifier()) {
				raw = rgt.raw();
			} else if ((rgt instanceof Identifier) && rgt.isValidIdentifier()) {
				mark = mark__(rgt._value);
				raw = rgt.c();
			};
			
			if (this.safechain() && ctx) {
				ctx.cache({force: true});
				pre = ctx.c() + " && ";
			};
			
			// really?
			// var ctx = (left || scope__.context)
			var out = raw ? (
				// see if it needs quoting
				// need to check to see if it is legal
				ctx ? (("" + (ctx.c()) + "." + mark + raw)) : (raw)
			) : (
				r = rgt instanceof Node ? (rgt.c({expression: true})) : (rgt),
				("" + (ctx.c()) + "[" + r + "]")
			);
			
			// if safechain and ctx
			// 	out = "{ctx.c} && {out}"
			
			return pre + out;
		};
		
		Access.prototype.visit = function (){
			if (this.left()) { this.left().traverse() };
			if (this.right()) { this.right().traverse() };
			return;
		};
		
		Access.prototype.isExpressable = function (){
			return true;
		};
		
		Access.prototype.alias = function (){
			return this.right() instanceof Identifier ? (this.right().alias()) : (Access.__super__.alias.call(this));
		};
		
		Access.prototype.safechain = function (){
			// right.safechain
			return String(this._op) == '?.' || String(this._op) == '?:';
		};
		
		Access.prototype.cache = function (o){
			return ((this.right() instanceof Ivar) && !(this.left())) ? (this) : (Access.__super__.cache.call(this,o));
		};
		
		
		
		// Should change this to just refer directly to the variable? Or VarReference
		function LocalVarAccess(){ return Access.apply(this,arguments) };
		
		subclass$(LocalVarAccess,Access);
		exports.LocalVarAccess = LocalVarAccess; // export class 
		LocalVarAccess.prototype.safechain = function(v){ return this._safechain; }
		LocalVarAccess.prototype.setSafechain = function(v){ this._safechain = v; return this; };
		
		LocalVarAccess.prototype.js = function (o){
			if ((this.right() instanceof Variable) && this.right().type() == 'meth') {
				if (!((this.up() instanceof Call))) { return ("" + (this.right().c()) + "()") };
			};
			
			return this.right().c();
		};
		
		LocalVarAccess.prototype.variable = function (){
			return this.right();
		};
		
		LocalVarAccess.prototype.cache = function (o){
			if(o === undefined) o = {};
			if (o.force) { LocalVarAccess.__super__.cache.call(this,o) };
			return this;
		};
		
		LocalVarAccess.prototype.alias = function (){
			return this.variable()._alias || LocalVarAccess.__super__.alias.call(this);
		};
		
		
		function GlobalVarAccess(){ return ValueNode.apply(this,arguments) };
		
		subclass$(GlobalVarAccess,ValueNode);
		exports.GlobalVarAccess = GlobalVarAccess; // export class 
		GlobalVarAccess.prototype.js = function (o){
			return this.value().c();
		};
		
		
		function ObjectAccess(){ return Access.apply(this,arguments) };
		
		subclass$(ObjectAccess,Access);
		exports.ObjectAccess = ObjectAccess; // export class 
		
		
		
		function PropertyAccess(o,l,r){
			this._traversed = false;
			this._invert = false;
			this._parens = false;
			this._expression = false; // yes?
			this._cache = null;
			this._op = o;
			this._left = l;
			this._right = r;
			return this;
		};
		
		subclass$(PropertyAccess,Access);
		exports.PropertyAccess = PropertyAccess; // export class 
		PropertyAccess.prototype.visit = function (){
			if (this._right) { this._right.traverse() };
			if (this._left) { this._left.traverse() };
			return this;
		};
		
		// right in c we should possibly override
		// to create a call and regular access instead
		
		PropertyAccess.prototype.js = function (o){
			
			var rec;
			if (rec = this.receiver()) {
				// p "converting to call"
				var ast = CALL(OP('.',this.left(),this.right()),[]); // convert to ArgList or null
				ast.setReceiver(rec);
				return ast.c();
			};
			
			var up = this.up();
			
			if (!((up instanceof Call))) {
				// p "convert to call instead"
				ast = CALL(new Access(this.op(),this.left(),this.right()),[]);
				return ast.c();
			};
			
			// really need to fix this - for sure
			// should be possible for the function to remove this this instead?
			var js = ("" + PropertyAccess.__super__.js.call(this,o));
			
			if (!((up instanceof Call) || (up instanceof Util.IsFunction))) {
				// p "Called"
				js += "()";
			};
			
			return js;
		};
		
		
		PropertyAccess.prototype.receiver = function (){
			if ((this.left() instanceof SuperAccess) || (this.left() instanceof Super)) {
				return SELF;
			} else {
				return null;
			};
		};
		
		
		function IvarAccess(){ return Access.apply(this,arguments) };
		
		subclass$(IvarAccess,Access);
		exports.IvarAccess = IvarAccess; // export class 
		IvarAccess.prototype.cache = function (){
			// WARN hmm, this is not right... when accessing on another object it will need to be cached
			return this;
		};
		
		
		function ConstAccess(){ return Access.apply(this,arguments) };
		
		subclass$(ConstAccess,Access);
		exports.ConstAccess = ConstAccess; // export class 
		
		
		
		function IndexAccess(){ return Access.apply(this,arguments) };
		
		subclass$(IndexAccess,Access);
		exports.IndexAccess = IndexAccess; // export class 
		IndexAccess.prototype.cache = function (o){
			if(o === undefined) o = {};
			if (o.force) { return IndexAccess.__super__.cache.apply(this,arguments) };
			this.right().cache();
			return this;
		};
		
		
		function SuperAccess(){ return Access.apply(this,arguments) };
		
		subclass$(SuperAccess,Access);
		exports.SuperAccess = SuperAccess; // export class 
		SuperAccess.prototype.js = function (o){
			var m = o.method();
			var up = o.parent();
			var deep = (o.parent() instanceof Access);
			
			var out = ("" + (this.left().c()) + ".__super__");
			
			if (!((up instanceof Access))) {
				out += ("." + (m.supername().c()));
				if (!((up instanceof Call))) { // autocall?
					out += (".apply(" + (m.scope().context().c()) + ",arguments)");
				};
			};
			
			return out;
		};
		
		SuperAccess.prototype.receiver = function (){
			return SELF;
		};
		
		
		function VarOrAccess(value){
			// should rather call up to valuenode?
			this._traversed = false;
			this._parens = false;
			this._value = value;
			this._identifier = value;
			this._token = value._value;
			this._variable = null;
			this;
		};
		
		// Shortcircuit traverse so that it is not added to the stack?!
		subclass$(VarOrAccess,ValueNode);
		exports.VarOrAccess = VarOrAccess; // export class 
		VarOrAccess.prototype.visit = function (){
			// @identifier = value # this is not a real identifier?
			// console.log "VarOrAccess {@identifier}"
			// p "visit {self}"
			
			
			var scope = this.scope__();
			
			var variable = scope.lookup(this.value());
			
			// does not really need to have a declarator already? -- tricky
			if (variable && variable.declarator()) {
				// var decl = variable.declarator
				
				// if the variable is not initialized just yet and we are
				// in the same scope - we should not treat this as a var-lookup
				// ie.  var x = x would resolve to var x = this.x() if x
				// was not previously defined
				
				// should do this even if we are not in the same scope?
				// we only need to be in the same closure(!)
				
				if (variable._initialized || (scope.closure() != variable.scope().closure())) {
					this._variable = variable;
					variable.addReference(this);
					this._value = variable; // variable.accessor(self)
					this._token._variable = variable;
					return this;
				};
				
				// p "var is not yet initialized!"
				// p "declarator for var {decl.@declared}"
				// FIX
				// @value.safechain = safechain
			};
			
			// TODO deprecate and remove
			if (this.value().symbol().indexOf('$') >= 0) {
				// big hack - should disable
				// major hack here, no?
				// console.log "GlobalVarAccess"
				this._value = new GlobalVarAccess(this.value());
				return this;
			};
			
			// really? what about just mimicking the two diffrent instead?
			// Should we not return a call directly instead?
			this._value = new PropertyAccess(".",scope.context(),this.value());
			// mark the scope / context -- so we can show correct implicit
			this._token._meta = {type: 'ACCESS'};
			// @value.traverse # nah
			return this;
		};
		
		VarOrAccess.prototype.c = function (){
			return mark__(this._token) + (this._variable ? (VarOrAccess.__super__.c.call(this)) : (this.value().c()));
		};
		
		VarOrAccess.prototype.js = function (o){
			
			var v;
			if (v = this._variable) {
				var out = v.c();
				if (v._type == 'meth' && !(o.up() instanceof Call)) { out += "()" };
				return out;
			};
			return "NONO";
		};
		
		VarOrAccess.prototype.node = function (){
			return this._variable ? (this) : (this.value());
		};
		
		VarOrAccess.prototype.symbol = function (){
			return this._identifier.symbol();
			// value and value.symbol
		};
		
		VarOrAccess.prototype.cache = function (o){
			if(o === undefined) o = {};
			return this._variable ? ((o.force && VarOrAccess.__super__.cache.call(this,o))) : (this.value().cache(o));
			// should we really cache this?
			// value.cache(o)
		};
		
		VarOrAccess.prototype.decache = function (){
			this._variable ? (VarOrAccess.__super__.decache.call(this)) : (this.value().decache());
			return this;
		};
		
		VarOrAccess.prototype.dom = function (){
			return this.value().dom();
		};
		
		VarOrAccess.prototype.safechain = function (){
			return this._identifier.safechain();
		};
		
		VarOrAccess.prototype.dump = function (){
			return {loc: this.loc()};
		};
		
		VarOrAccess.prototype.loc = function (){
			var loc = this._identifier.region();
			return loc || [0,0];
		};
		
		VarOrAccess.prototype.region = function (){
			return this._identifier.region();
		};
		
		VarOrAccess.prototype.toString = function (){
			return ("VarOrAccess(" + this.value() + ")");
		};
		
		VarOrAccess.prototype.toJSON = function (){
			return {type: this.typeName(),value: this._identifier.toString()};
		};
		
		//	def js
		//		if right isa Variable and right.type == 'meth'
		//			return "{right.c}()" unless up isa Call
		//
		//		right.c
		//
		//	def variable
		//		right
		//
		//	def cache o = {}
		//		super if o:force
		//		self
		//
		//	def alias
		//		variable.@alias or super # if resolved?
		//
		
		function VarReference(value,type){
			if (value instanceof VarOrAccess) {
				value = value.value();
			};
			// for now - this can happen
			VarReference.__super__.constructor.call(this,value);
			this._export = false;
			this._type = type && String(type);
			this._variable = null;
			this._declared = true; // just testing now
		};
		
		
		subclass$(VarReference,ValueNode);
		exports.VarReference = VarReference; // export class 
		VarReference.prototype.variable = function(v){ return this._variable; }
		VarReference.prototype.setVariable = function(v){ this._variable = v; return this; };
		VarReference.prototype.declared = function(v){ return this._declared; }
		VarReference.prototype.setDeclared = function(v){ this._declared = v; return this; };
		VarReference.prototype.type = function(v){ return this._type; }
		VarReference.prototype.setType = function(v){ this._type = v; return this; };
		
		VarReference.prototype.loc = function (){
			// p "loc for VarReference {@value:constructor} {@value.@value:constructor} {@value.region}"
			return this._value.region();
		};
		
		VarReference.prototype.set = function (o){
			// hack - workaround for hidden classes perf
			if (o.export) { this._export = true };
			return this;
		};
		
		VarReference.prototype.js = function (o){
			// experimental fix
			
			// what about resolving?
			var ref = this._variable;
			var out = ("" + mark__(this._value) + (ref.c()));
			
			// p "VarReference {out} - {o.up} {o.up == self}\n{o}"
			
			if (ref && !ref._declared) { // .option(:declared)
				if (o.up(VarBlock)) { // up varblock??
					ref._declared = true;
					
					// ref.set(declared: yes)
				} else if (o.isExpression() || this._export) { // why?
					// p "autodeclare"
					ref.autodeclare();
				} else {
					out = ("var " + out);
					ref._declared = true;
					// ref.set(declared: yes)
				};
			};
			
			// need to think the export through -- like registering somehow
			// should register in scope - export on analysis++
			if (this._export) {
				out = ("module.exports." + (ref.c()) + " = " + (ref.c()));
			};
			
			return out;
		};
		
		VarReference.prototype.declare = function (){
			return this;
		};
		
		VarReference.prototype.consume = function (node){
			// really? the consumed node dissappear?
			this._variable && this._variable.autodeclare();
			return this;
		};
		
		VarReference.prototype.visit = function (){
			
			// console.log "value type for VarReference {@value} {@value.@loc} {@value:constructor}"
			
			// should be possible to have a VarReference without a name as well? for a system-variable
			// name should not set this way.
			// p "varname {value} {value:constructor}"
			var name = this.value().c();
			// p "visit vardecl {name} {value}"
			
			// what about looking up? - on register we want to mark
			var v = this._variable || (this._variable = this.scope__().register(name,this,{type: this._type}));
			// FIXME -- should not simply override the declarator here(!)
			
			if (!v.declarator()) {
				v.setDeclarator(this);
			};
			
			if (this._value) { v.addReference(this._value) }; // is this the first reference?
			
			// only needed when analyzing?
			this._value._value._variable = v;
			return this;
		};
		
		VarReference.prototype.refnr = function (){
			return this.variable().references().indexOf(this.value());
		};
		
		// convert this into a list of references
		VarReference.prototype.addExpression = function (expr){
			
			return new VarBlock([this]).addExpression(expr);
		};
		
		
		// ASSIGN
		
		function Assign(o,l,r){
			
			// workaround until we complete transition from lua-style assignments
			// to always use explicit tuples - then we can move assignments out etc
			// this will not be needed after we remove support for var a,b,c = 1,2,3
			if ((l instanceof VarReference) && (l.value() instanceof Arr)) {
				// converting all nodes to var-references ?
				// do we need to keep it in a varblock at all?
				var vars = l.value().nodes().map(function(v) {
					// what about inner tuples etc?
					// keep the splats -- clumsy but true
					var v_;
					if (v instanceof Splat) {
						// p "value is a splat!!"
						if (!((v.value() instanceof VarReference))) { (v.setValue(v_ = new VarReference(v.value(),l.type())),v_) };
					} else if (v instanceof VarReference) {
						true;
					} else {
						// what about retaining location?
						// v = v.value if v isa VarOrAccess
						v = new VarReference(v,l.type());
					};
					
					return v;
					
					// v isa VarReference ? v : VarReference.new(v)
				});
				return new TupleAssign(o,new Tuple(vars),r);
			};
			
			if (l instanceof Arr) {
				return new TupleAssign(o,new Tuple(l.nodes()),r);
				// p "left is array in assign - in init"
			};
			
			
			// set expression yes, no?
			this._expression = false;
			this._traversed = false;
			this._parens = false;
			this._cache = null;
			this._invert = false;
			this._opToken = o;
			this._op = o && o._value || o;
			this._left = l;
			this._right = r;
			return this;
		};
		
		subclass$(Assign,Op);
		exports.Assign = Assign; // export class 
		Assign.prototype.isExpressable = function (){
			return !(this.right()) || this.right().isExpressable();
		};
		
		Assign.prototype.isUsed = function (){
			// really?
			// if up is a block in general this should not be used -- since it should already have received implicit self?
			if (this.up() instanceof Block) { // && up.last != self
				return false;
			};
			return true;
		};
		
		// FIXME optimize
		Assign.prototype.visit = function (){
			var l = this._left;
			var r = this._right;
			
			// WARNING - slightly undefined
			// MARK THE STACK
			if (l) { l.traverse() };
			
			var lvar = (l instanceof VarReference) && l.variable();
			
			// how does this work with constants that are really var references?
			// should work when things are not described as well - but this is for testing
			// but if it refers to something else 
			if (!(lvar) && this._desc) {
				// entities should be able to extract the needed info instead
				ROOT.entities().add(l.namepath(),{namepath: l.namepath(),type: r.typeName(),desc: this._desc});
			};
			
			// this should probably be done in a different manner
			if (lvar && lvar.declarator() == l) {
				lvar._initialized = false;
				if (r) { r.traverse() };
				lvar._initialized = true;
			} else {
				if (r) { r.traverse() };
			};
			
			if ((l instanceof VarReference) || l._variable) {
				l._variable.assigned(r,this);
			};
			
			return this;
		};
		
		Assign.prototype.c = function (o){
			if (!this.right().isExpressable()) {
				// p "Assign#c right is not expressable "
				return this.right().consume(this).c(o);
			};
			// testing this
			return Assign.__super__.c.call(this,o);
		};
		
		Assign.prototype.js = function (o){
			if (!this.right().isExpressable()) {
				this.p("Assign#js right is not expressable ");
				// here this should be go out of the stack(!)
				// it should already be consumed?
				return this.right().consume(this).c();
			};
			
			// p "assign left {left:contrstru}"
			var l = this.left().node();
			var r = this.right();
			
			// We are setting self(!)
			// TODO document functionality
			if (l instanceof Self) {
				var ctx = this.scope__().context();
				l = ctx.reference();
			};
			
			
			if (l instanceof PropertyAccess) {
				var ast = CALL(OP('.',l.left(),l.right().setter()),[this.right()]);
				ast.setReceiver(l.receiver());
				
				if (this.isUsed()) {
					// p "Assign is used {stack}"
					// dont cache it again if it is already cached(!)
					if (!this.right().cachevar()) { this.right().cache({pool: 'val',uses: 1}) }; // 
					// this is only when used.. should be more clever about it
					ast = new Parens(blk__([ast,this.right()]));
				};
				
				// should check the up-value no?
				return ast.c({expression: true});
			};
			
			// if l isa VarReference
			// 	p "assign var-ref"
			// 	l.@variable.assigned(r)
			
			// FIXME -- does not always need to be an expression?
			// p "typeof op {@opToken and @opToken:constructor}"
			var out = ("" + (l.c()) + " " + mark__(this._opToken) + this.op() + " " + this.right().c({expression: true}));
			
			return out;
		};
		
		// FIXME op is a token? _FIX_
		// this (and similar cases) is broken when called from
		// another position in the stack, since 'up' is dynamic
		// should maybe freeze up?
		Assign.prototype.shouldParenthesize = function (par){
			if(par === undefined) par = this.up();
			return this._parens || (par instanceof Op) && par.op() != '=';
		};
		
		Assign.prototype.consume = function (node){
			if (this.isExpressable()) {
				this.forceExpression();
				return Assign.__super__.consume.call(this,node);
			};
			
			var ast = this.right().consume(this);
			return ast.consume(node);
		};
		
		// more workaround during transition away from a,b,c = 1,2,3 style assign
		Assign.prototype.addExpression = function (expr){
			var typ = ExpressionBlock;
			if (this._left && (this._left instanceof VarReference)) {
				typ = VarBlock;
			};
			// might be better to nest this up after parsing is done?
			// p "Assign.addExpression {self} <- {expr}"
			var node = new typ([this]);
			return node.addExpression(expr);
		};
		
		
		function PushAssign(){ return Assign.apply(this,arguments) };
		
		subclass$(PushAssign,Assign);
		exports.PushAssign = PushAssign; // export class 
		PushAssign.prototype.js = function (o){
			return ("" + (this.left().c()) + ".push(" + (this.right().c()) + ")");
		};
		
		PushAssign.prototype.consume = function (node){
			return this;
		};
		
		
		function ConditionalAssign(){ return Assign.apply(this,arguments) };
		
		subclass$(ConditionalAssign,Assign);
		exports.ConditionalAssign = ConditionalAssign; // export class 
		ConditionalAssign.prototype.consume = function (node){
			return this.normalize().consume(node);
		};
		
		ConditionalAssign.prototype.normalize = function (){
			var l = this.left().node();
			var ls = l;
			
			if (l instanceof Access) {
				// p "conditional-assign {l} {l.left} {l.right}"
				if (l.left()) {
					// p "cache l.left {l.left:constructor}̋"
					l.left().cache();
				};
				ls = l.clone(l.left(),l.right()); // this should still be cached?
				if (l instanceof PropertyAccess) { l.cache() }; // correct now, to a certain degree
				if (l instanceof IndexAccess) {
					// p "cache the right side of indexAccess!!! {l.right}"
					l.right().cache();
				};
				
				// we should only cache the value itself if it is dynamic?
				// l.cache # cache the value as well -- we cannot use this in assigns them
			};
			
			// some ops are less messy
			// need op to support consume then?
			var expr = this.right().isExpressable();
			var ast = null;
			// here we should use ast = if ...
			if (expr && this.op() == '||=') {
				ast = OP('||',l,OP('=',ls,this.right()));
			} else if (expr && this.op() == '&&=') {
				ast = OP('&&',l,OP('=',ls,this.right()));
			} else {
				ast = IF(this.condition(),OP('=',ls,this.right()),l); // do we need a scope for these?
				ast.setScope(null);
				// drop the scope
				// touch scope -- should probably visit the whole thing?
				// ast.scope.visit
			};
			if (ast.isExpressable()) { ast.toExpression() };
			return ast;
		};
		
		
		ConditionalAssign.prototype.c = function (){
			// WARN what if we return the same?
			return this.normalize().c();
		};
		
		ConditionalAssign.prototype.condition = function (){
			
			// use switch instead to cache op access
			if (this.op() == '?=') {
				return OP('==',this.left(),NULL);
			} else if (this.op() == '||=') {
				return OP('!',this.left());
			} else if (this.op() == '&&=') {
				return this.left();
			} else if (this.op() == '!?=') {
				return OP('!=',this.left(),NULL);
			} else {
				return this.left();
			};
		};
		
		ConditionalAssign.prototype.js = function (o){
			// p "ConditionalAssign.js".red
			var ast = IF(this.condition(),OP('=',this.left(),this.right()),this.left());
			ast.setScope(null); // not sure about this
			if (ast.isExpressable()) { ast.toExpression() }; // forced expression already
			return ast.c();
		};
		
		function CompoundAssign(){ return Assign.apply(this,arguments) };
		
		subclass$(CompoundAssign,Assign);
		exports.CompoundAssign = CompoundAssign; // export class 
		CompoundAssign.prototype.consume = function (node){
			if (this.isExpressable()) { return CompoundAssign.__super__.consume.apply(this,arguments) };
			
			var ast = this.normalize();
			if (ast != this) { return ast.consume(node) };
			
			ast = this.right().consume(this);
			return ast.consume(node);
		};
		
		CompoundAssign.prototype.normalize = function (){
			var ln = this.left().node();
			// we dont need to change this at all
			if (!((ln instanceof PropertyAccess))) {
				return this;
			};
			
			if (ln instanceof Access) {
				// left might be zero?!?!
				if (ln.left()) { ln.left().cache() };
			};
			// TODO FIXME we want to cache the context of the assignment
			// p "normalize compound assign {left}"
			var ast = OP('=',this.left(),OP(this.op()[0],this.left(),this.right()));
			if (ast.isExpressable()) { ast.toExpression() };
			
			return ast;
		};
		
		CompoundAssign.prototype.c = function (){
			var ast = this.normalize();
			if (ast == this) { return CompoundAssign.__super__.c.apply(this,arguments) };
			
			// otherwise it is important that we actually replace this node in the outer block
			// whenever we normalize and override c it is important that we can pass on caching
			// etc -- otherwise there WILL be issues.
			var up = STACK.current();
			if (up instanceof Block) {
				// p "parent is block, should replace!"
				// an alternative would be to just pass
				up.replace(this,ast);
			};
			return ast.c();
		};
		
		
		function AsyncAssign(){ return Assign.apply(this,arguments) };
		
		subclass$(AsyncAssign,Assign);
		exports.AsyncAssign = AsyncAssign; // export class 
		
		
		
		function TupleAssign(a,b,c){
			this._traversed = false;
			this._op = a;
			this._left = b;
			this._right = c;
			this._temporary = [];
		};
		
		subclass$(TupleAssign,Assign);
		exports.TupleAssign = TupleAssign; // export class 
		TupleAssign.prototype.op = function(v){ return this._op; }
		TupleAssign.prototype.setOp = function(v){ this._op = v; return this; };
		TupleAssign.prototype.left = function(v){ return this._left; }
		TupleAssign.prototype.setLeft = function(v){ this._left = v; return this; };
		TupleAssign.prototype.right = function(v){ return this._right; }
		TupleAssign.prototype.setRight = function(v){ this._right = v; return this; };
		TupleAssign.prototype.type = function(v){ return this._type; }
		TupleAssign.prototype.setType = function(v){ this._type = v; return this; };
		
		TupleAssign.prototype.isExpressable = function (){
			return this.right().isExpressable();
		};
		
		TupleAssign.prototype.addExpression = function (expr){
			if (this.right() instanceof Tuple) {
				this.right().push(expr);
			} else {
				// p "making child become a tuple?"
				this.setRight(new Tuple([this.right(),expr]));
			};
			
			return this;
		};
		
		TupleAssign.prototype.visit = function (){
			// if the first left-value is a var-reference, then
			// all the variables should be declared as variables.
			// but if we have complex items in the other list - it does become much harder
			
			// if the first is a var-reference, they should all be(!) .. or splats?
			// this is really a hacky wao to do it though
			if (this.left().first().node() instanceof VarReference) {
				this.setType('var');
				// should possibly allow real vars as well, no?
				this._vars = this.left().nodes().filter(function(n) { return n instanceof VarReference; });
				// collect the vars for tuple for easy access
				
				// NOTE can improve.. should rather make the whole left be a VarBlock or TupleVarBlock
				// p "type is var -- skip the rest"
			};
			
			this.right().traverse();
			this.left().traverse();
			return this;
		};
		
		TupleAssign.prototype.js = function (o){
			// only for actual inner expressions, otherwise cache the whole array, no?
			var self = this;
			if (!self.right().isExpressable()) {
				// p "TupleAssign.consume! {right}".blue
				
				return self.right().consume(self).c();
			};
			
			// p "TUPLE {type}"
			
			/* a,b,c = arguments */
			
			// - direct. no matter if lvalues are variables or not. Make fake arguments up to the same count as tuple
			
			/* a,*b,b = arguments */
			
			// Need to convert arguments to an array. IF arguments is not referenced anywhere else in scope, 
			// we can do the assignment directly while rolling through arguments
			
			/* a,b = b,a */
			
			// ideally we only need to cache the first value (or n - 1), assign directly when possible.
			
			/* a,b,c = (method | expression) */
			
			// convert res into array, assign from array. Can cache the variable when assigning first value
			
			// First we need to find out whether we are required to store the result in an array before assigning
			// If this needs to be an expression (returns?, we need to fall back to the CS-wa)
			
			var ast = new Block([]);
			var lft = self.left();
			var rgt = self.right();
			var typ = self.type();
			var via = null;
			
			var li = 0;
			var ri = lft.count();
			var llen = ri;
			
			
			// if @vars
			// 	p "tuple has {@vars:length} vars"
			
			// if we have a splat on the left it is much more likely that we need to store right
			// in a temporary array, but if the right side has a known length, it should still not be needed
			var lsplat = lft.filter(function(v) { return v instanceof Splat; })[0];
			
			// if right is an array without any splats (or inner tuples?), normalize it to tuple
			if ((rgt instanceof Arr) && !rgt.splat()) { rgt = new Tuple(rgt.nodes()) };
			var rlen = rgt instanceof Tuple ? (rgt.count()) : (null);
			
			// if any values are statements we need to handle this before continuing
			
			/* a,b,c = 10,20,ary */
			
			// ideally we only need to cache the first value (or n - 1), assign directly when possible.
			// only if the variables are not predefined or predeclared can be we certain that we can do it without caching
			// if rlen && typ == 'var' && !lsplat
			// 	# this can be dangerous in edgecases that are very hard to detect
			// 	# if it becomes an issue, fall back to simpler versions
			// 	# does not even matter if there is a splat?
			
			// special case for arguments(!)
			if (!(lsplat) && rgt == ARGUMENTS) {
				
				var pars = self.scope__().params();
				// p "special case with arguments {pars}"
				// forcing the arguments to be named
				// p "got here??? {pars}"
				lft.map(function(l,i) { return ast.push(OP('=',l.node(),pars.at(i,true).visit().variable())); }); // s.params.at(value - 1,yes)
			} else if (rlen) {
				// we have several items in the right part. what about splats here?
				
				// pre-evaluate rvalues that might be reference from other assignments
				// we need to check if the rightside values has no side-effects. Cause if
				// they dont, we really do not need temporary variables.
				
				// some of these optimizations are quite petty - makes things more complicated
				// in the compiler only to get around adding a few temp-variables here and there
				
				// var firstUnsafe = 0
				// lft.map do |v,i|
				// 	if v isa VarReference
				// 		p "left side {i} {v} {v.refnr}"
				
				// rgt.map do |v,i|
				// 	if v.hasSideEffects
				// 		# return if i == 0 or !v.hasSideEffects
				// 		# return if v isa Num || v isa Str || i == 0
				// 		# we could explicitly create a temporary variable and adding nodes for accessing etc
				// 		# but the builtin caching should really take care of this for us
				// 		# we need to really force the caching though -- since we need a copy of it even if it is a local
				// 		# we need to predeclare the variables at the top of scope if this does not take care of it
				// 		
				// 		# these are the declarations -- we need to add them somewhere smart
				// 		@temporary.push(v) # need a generalized way to do this type of thing
				// 		ast.push(v.cache(force: yes, type: 'swap', declared: typ == 'var'))
				// 		# they do need to be declared, no?
				
				// now we can free the cached variables
				// ast.map do |n| n.decache
				
				var pre = [];
				var rest = [];
				
				var pairs = lft.map(function(l,i) {
					var v = null;
					// determine if this needs to be precached?
					// if l isa VarReference
					// 	# this is the first time the variable is referenced
					// 	# should also count even if it is predeclared at the top
					// 	if l.refnr == 0
					
					if (l == lsplat) {
						v = new ArgList([]);
						var to = (rlen - (ri - i));
						// p "assing splat at index {i} to slice {li} - {to}".cyan
						while (li <= to){
							v.push(rgt.index(li++));
						};
						v = new Arr(v);
						// ast.push OP('=',l.node,Arr.new(v))
					} else {
						v = rgt.index(li++);
					};
					return [l.node(),v];
					
					// if l isa VarReference && l.refnr 
				});
				var clean = true;
				
				pairs.map(function(v,i) {
					var l = v[0];
					var r = v[1];
					
					if (clean) {
						if ((l instanceof VarReference) && l.refnr() == 0) {
							// still clean
							clean = true;
						} else {
							clean = false;
							// p "now cache"
							pairs.slice(i).map(function(part) {
								if (part[1].hasSideEffects()) {
									self._temporary.push(part[1]); // need a generalized way to do this type of thing
									return ast.push(part[1].cache({force: true,pool: 'swap',declared: typ == 'var'}));
								};
							});
							// p "from {i} - cache all remaining with side-effects"
						};
					};
					
					// if the previous value in ast is a reference to our value - the caching was not needed
					if (ast.last() == r) {
						r.decache();
						// p "was cached - not needed"
						// simple assign
						return ast.replace(r,OP('=',l,r));
					} else {
						return ast.push(OP('=',l,r));
					};
				});
				
				// WARN FIXME Is there not an issue with VarBlock vs not here?
			} else {
				// this is where we need to cache the right side before assigning
				// if the right side is a for loop, we COULD try to be extra clever, but
				// for now it is not worth the added compiler complexity
				
				// iter.cache(force: yes, type: 'iter')
				var top = new VarBlock();
				var iter = self.util().iterable(rgt,true);
				// could set the vars inside -- most likely
				ast.push(top);
				top.push(iter);
				
				if (lsplat) {
					var len = self.util().len(iter,true);
					var idx = self.util().counter(0,true);
					// cache the length of the array
					top.push(len); // preassign the length
					// cache counter to loop through
					top.push(idx);
				};
				
				// only if the block is variable based, no?
				// ast.push(blk = VarBlock.new)
				// blk = null
				
				var blktype = typ == 'var' ? (VarBlock) : (Block);
				var blk = new blktype([]);
				// blk = top if typ == 'var'
				ast.push(blk);
				
				// if the lvals are not variables - we need to preassign
				// can also use slice here for simplicity, but try with while now			
				lft.map(function(l,i) {
					if (l == lsplat) {
						var lvar = l.node();
						var rem = llen - i - 1; // remaining after splat
						
						if (typ != 'var') {
							var arr = self.util().array(OP('-',len,num__(i + rem)),true);
							top.push(arr);
							lvar = arr.cachevar();
						} else {
							if (!(blk)) { ast.push(blk = new blktype()) };
							arr = self.util().array(OP('-',len,num__(i + rem)));
							blk.push(OP('=',lvar,arr));
						};
						
						// if !lvar:variable || !lvar.variable # lvar = 
						// 	top.push()
						//	p "has variable - no need to create a temp"
						// blk.push(OP('=',lvar,Arr.new([]))) # dont precalculate size now
						// max = to = (rlen - (llen - i))
						
						
						var test = rem ? (OP('-',len,rem)) : (len);
						
						var set = OP('=',OP('.',lvar,OP('-',idx,num__(i))),
						OP('.',iter,OP('++',idx)));
						
						ast.push(WHILE(OP('<',idx,test),set));
						
						if (typ != 'var') {
							ast.push(blk = new Block());
							return blk.push(OP('=',l.node(),lvar));
						} else {
							return blk = null;
						};
						
						// not if splat was last?
						// ast.push(blk = VarBlock.new)
					} else if (lsplat) {
						if (!(blk)) { ast.push(blk = new blktype()) };
						// we could cache the raw code of this node for better performance
						return blk.push(OP('=',l,OP('.',iter,OP('++',idx))));
					} else {
						if (!(blk)) { ast.push(blk = new blktype()) };
						return blk.push(OP('=',l,OP('.',iter,num__(i))));
					};
				});
			};
			
			// if we are in an expression we really need to 
			if (o.isExpression() && self._vars) {
				// p "tuple is expression" # variables MUST be autodeclared outside of the expression
				for (var i = 0, ary = iter$(self._vars), len_ = ary.length; i < len_; i++) {
					ary[i].variable().autodeclare();
				};
			} else if (self._vars) {
				for (var i = 0, ary = iter$(self._vars), len_ = ary.length; i < len_; i++) {
					// p "predeclare variable before compilation"
					ary[i].variable().predeclared();
				};
			};
			
			// is there any reason to make it into an expression?
			if (ast.isExpressable()) { // NO!
				// p "express"
				// if this is an expression
				var out = ast.c({expression: true});
				if (typ && !o.isExpression()) { out = ("" + typ + " " + out) }; // not in expression
				return out;
			} else {
				out = ast.c();
				// if this is a varblock 
				return out;
			};
		};
		
		
		TupleAssign.prototype.c = function (o){
			var out = TupleAssign.__super__.c.call(this,o);
			// this is only used in tuple -- better to let the tuple hav a separate #c
			if (this._temporary && this._temporary.length) {
				this._temporary.map(function(temp) { return temp.decache(); });
			};
			return out;
		};
		
		
		
		// IDENTIFIERS
		
		// really need to clean this up
		// Drop the token?
		function Identifier(value){
			this._value = this.load(value);
			this._symbol = null;
			this._setter = null;
			
			if (("" + value).indexOf("?") >= 0) {
				this._safechain = true;
			};
			// @safechain = ("" + value).indexOf("?") >= 0
			this;
		};
		
		subclass$(Identifier,Node);
		exports.Identifier = Identifier; // export class 
		Identifier.prototype.safechain = function(v){ return this._safechain; }
		Identifier.prototype.setSafechain = function(v){ this._safechain = v; return this; };
		Identifier.prototype.value = function(v){ return this._value; }
		Identifier.prototype.setValue = function(v){ this._value = v; return this; };
		
		Identifier.prototype.references = function (variable){
			if (this._value) { this._value._variable = variable };
			return this;
		};
		
		Identifier.prototype.sourceMapMarker = function (){
			return this._value.sourceMapMarker();
		};
		
		Identifier.prototype.load = function (v){
			return (v instanceof Identifier ? (v.value()) : (v));
		};
		
		Identifier.prototype.traverse = function (){
			// NODES.push(self)
			return this;
		};
		
		Identifier.prototype.visit = function (){
			
			if (this._value instanceof Node) {
				// console.log "IDENTIFIER VALUE IS NODE"
				this._value.traverse();
			};
			return this;
		};
		
		Identifier.prototype.region = function (){
			return [this._value._loc,this._value._loc + this._value._len];
		};
		
		Identifier.prototype.isValidIdentifier = function (){
			return true;
		};
		
		Identifier.prototype.isReserved = function (){
			return this._value.reserved || RESERVED_TEST.test(String(this._value));
		};
		
		Identifier.prototype.symbol = function (){
			// console.log "Identifier#symbol {value}"
			return this._symbol || (this._symbol = sym__(this.value()));
		};
		
		Identifier.prototype.setter = function (){
			// console.log "Identifier#setter"
			var tok;
			return this._setter || (this._setter = (true) && (
				tok = new Token('IDENTIFIER',sym__('set-' + this._value),this._value._loc || -1),
				new Identifier(tok)
				// Identifier.new("set-{symbol}")
			));
		};
		
		Identifier.prototype.toString = function (){
			return String(this._value);
		};
		
		Identifier.prototype.toJSON = function (){
			return this.toString();
		};
		
		Identifier.prototype.alias = function (){
			return sym__(this._value);
		};
		
		Identifier.prototype.js = function (o){
			return this.symbol();
		};
		
		Identifier.prototype.c = function (){
			return '' + this.symbol(); // mark__(@value) + 
		};
		
		Identifier.prototype.dump = function (){
			return {loc: this.region()};
		};
		
		Identifier.prototype.namepath = function (){
			return this.toString();
		};
		
		function TagId(v){
			this._value = v instanceof Identifier ? (v.value()) : (v);
			this;
		};
		
		subclass$(TagId,Identifier);
		exports.TagId = TagId; // export class 
		TagId.prototype.c = function (){
			return ("id$('" + (this.value().c()) + "')");
		};
		
		// This is not an identifier - it is really a string
		// Is this not a literal?
		
		// FIXME Rename to IvarLiteral? or simply Literal with type Ivar
		function Ivar(v){
			this._value = v instanceof Identifier ? (v.value()) : (v);
			this;
		};
		
		subclass$(Ivar,Identifier);
		exports.Ivar = Ivar; // export class 
		Ivar.prototype.name = function (){
			return helpers.camelCase(this._value).replace(/^@/,'');
			// value.c.camelCase.replace(/^@/,'')
		};
		
		Ivar.prototype.alias = function (){
			return '_' + this.name();
		};
		
		// the @ should possibly be gone from the start?
		Ivar.prototype.js = function (o){
			return '_' + this.name();
		};
		
		Ivar.prototype.c = function (){
			return '_' + helpers.camelCase(this._value).slice(1); // .replace(/^@/,'') # mark__(@value) + 
		};
		
		
		
		// Ambiguous - We need to be consistent about Const vs ConstAccess
		// Becomes more important when we implement typeinference and code-analysis
		function Const(){ return Identifier.apply(this,arguments) };
		
		subclass$(Const,Identifier);
		exports.Const = Const; // export class 
		Const.prototype.symbol = function (){
			// console.log "Identifier#symbol {value}"
			return this._symbol || (this._symbol = sym__(this.value()));
		};
		
		Const.prototype.js = function (o){
			return this.symbol();
		};
		
		Const.prototype.c = function (){
			return mark__(this._value) + this.symbol();
		};
		
		function TagTypeIdentifier(value){
			this._value = this.load(value);
			this;
		};
		
		subclass$(TagTypeIdentifier,Identifier);
		exports.TagTypeIdentifier = TagTypeIdentifier; // export class 
		TagTypeIdentifier.prototype.name = function(v){ return this._name; }
		TagTypeIdentifier.prototype.setName = function(v){ this._name = v; return this; };
		TagTypeIdentifier.prototype.ns = function(v){ return this._ns; }
		TagTypeIdentifier.prototype.setNs = function(v){ this._ns = v; return this; };
		
		TagTypeIdentifier.prototype.load = function (val){
			this._str = ("" + val);
			var parts = this._str.split(":");
			this._raw = val;
			this._name = parts.pop();
			this._ns = parts.shift(); // if any?
			return this._str;
		};
		
		TagTypeIdentifier.prototype.js = function (o){
			return ("Imba.TAGS." + this._str.replace(":","$"));
		};
		
		TagTypeIdentifier.prototype.c = function (){
			return this.js();
		};
		
		TagTypeIdentifier.prototype.func = function (){
			var name = this._name.replace(/-/g,'_').replace(/\#/,'');
			if (this._ns) { name += ("$" + (this._ns.toLowerCase())) };
			return name;
		};
		
		TagTypeIdentifier.prototype.spawner = function (){
			if (this._ns) {
				return ("" + (this._ns.toUpperCase()) + ".$" + this._name.replace(/-/g,'_'));
			} else {
				return ("$" + this._name.replace(/-/g,'_'));
			};
		};
		
		TagTypeIdentifier.prototype.id = function (){
			var m = this._str.match(/\#([\w\-\d\_]+)\b/);
			return m ? (m[1]) : (null);
		};
		
		
		TagTypeIdentifier.prototype.flag = function (){
			return "_" + this.name().replace(/--/g,'_').toLowerCase();
		};
		
		TagTypeIdentifier.prototype.sel = function (){
			return ("." + this.flag()); // + name.replace(/-/g,'_').toLowerCase
		};
		
		TagTypeIdentifier.prototype.string = function (){
			return this.value();
		};
		
		
		function Argvar(){ return ValueNode.apply(this,arguments) };
		
		subclass$(Argvar,ValueNode);
		exports.Argvar = Argvar; // export class 
		Argvar.prototype.c = function (){
			// NEXT -- global.parseInt or Number.parseInt (better)
			var v = parseInt(String(this.value()));
			// FIXME Not needed anymore? I think the lexer handles this
			if (v == 0) { return "arguments" };
			
			var s = this.scope__();
			// params need to go up to the closeste method-scope
			var par = s.params().at(v - 1,true);
			return ("" + c__(par.name())); // c
		};
		
		
		// CALL
		
		function Call(callee,args,opexists){
			this._traversed = false;
			this._expression = false;
			this._parens = false;
			this._cache = null;
			this._receiver = null;
			this._opexists = opexists;
			// some axioms that share the same syntax as calls will be redirected from here
			
			if (callee instanceof VarOrAccess) {
				var str = callee.value().symbol();
				// p "Call callee {callee} - {str}"
				if (str == 'extern') {
					// p "returning extern instead!"
					callee.value().value()._type = 'EXTERN';
					return new ExternDeclaration(args);
				};
				if (str == 'tag') {
					// console.log "ERROR - access args by some method"
					return new TagWrapper(args && args.index ? (args.index(0)) : (args[0]));
				};
				if (str == 'export') {
					return new ExportStatement(args);
				};
			};
			
			this._callee = callee;
			this._args = args || new ArgList([]);
			
			if (args instanceof Array) {
				this._args = new ArgList(args);
				// console.log "ARGUMENTS IS ARRAY - error {args}"
			};
			// p "call opexists {opexists}"
			this;
		};
		
		subclass$(Call,Node);
		exports.Call = Call; // export class 
		Call.prototype.callee = function(v){ return this._callee; }
		Call.prototype.setCallee = function(v){ this._callee = v; return this; };
		Call.prototype.receiver = function(v){ return this._receiver; }
		Call.prototype.setReceiver = function(v){ this._receiver = v; return this; };
		Call.prototype.args = function(v){ return this._args; }
		Call.prototype.setArgs = function(v){ this._args = v; return this; };
		Call.prototype.block = function(v){ return this._block; }
		Call.prototype.setBlock = function(v){ this._block = v; return this; };
		
		Call.prototype.visit = function (){
			// console.log "visit args {args}"
			this.args().traverse();
			this.callee().traverse();
			
			// if the callee is a PropertyAccess - better to immediately change it
			
			return this._block && this._block.traverse();
		};
		
		Call.prototype.addBlock = function (block){
			var pos = this._args.filter(function(n,i) { return n == '&'; })[0]; // WOULD BE TOKEN - CAREFUL
			pos ? (this.args().replace(pos,block)) : (this.args().push(block));
			return this;
		};
		
		Call.prototype.receiver = function (){
			return this._receiver || (this._receiver = ((this.callee() instanceof Access) && this.callee().left() || NULL));
		};
		
		// check if all arguments are expressions - otherwise we have an issue
		
		Call.prototype.safechain = function (){
			return this.callee().safechain(); // really?
		};
		
		Call.prototype.js = function (o){
			var opt = {expression: true};
			var rec = null;
			// var args = compact__(args) # really?
			var args = this.args();
			
			// drop this?
			
			var splat = args.some(function(v) { return v instanceof Splat; });
			
			var out = null;
			var lft = null;
			var rgt = null;
			var wrap = null;
			
			var callee = this._callee = this._callee.node(); // drop the var or access?
			
			// if callee isa Call && callee.safechain
			//	yes
			
			if (callee instanceof Access) {
				lft = callee.left();
				rgt = callee.right();
			};
			
			if ((callee instanceof Super) || (callee instanceof SuperAccess)) {
				this._receiver = this.scope__().context();
				// return "supercall"
			};
			
			// never call the property-access directly?
			if (callee instanceof PropertyAccess) { // && rec = callee.receiver
				// p "unwrapping property-access in call"
				this._receiver = callee.receiver();
				callee = this._callee = new Access(callee.op(),callee.left(),callee.right());
				// p "got here? {callee}"
				// console.log "unwrapping the propertyAccess"
			};
			
			if (callee.safechain()) {
				// p "callee is safechained?!?"
				// if lft isa Call
				// if lft isa Call # could be a property access as well - it is the same?
				// if it is a local var access we simply check if it is a function, then call
				// but it should be safechained outside as well?
				// lft.cache if lft
				// the outer safechain should not cache the whole call - only ask to cache
				// the result? -- chain onto
				// p "Call safechain {callee} {lft}.{rgt}"
				var isfn = new Util.IsFunction([callee]);
				wrap = [("" + (isfn.c()) + "  &&  "),""];
				callee = OP('.',callee.left(),callee.right());
				// callee should already be cached now - 
			};
			
			// should just force expression from the start, no?
			if (splat) {
				// important to wrap the single value in a value, to keep implicit call
				// this is due to the way we check for an outer Call without checking if
				// we are the receiver (in PropertyAccess). Should rather wrap in CallArguments
				var rec1 = this.receiver();
				var ary = (args.count() == 1 ? (new ValueNode(args.first().value())) : (new Arr(args.list())));
				
				rec1.cache(); // need to cache the context as it will be referenced in apply
				out = ("" + callee.c({expression: true}) + ".apply(" + (rec1.c()) + "," + ary.c({expression: true}) + ")");
			} else if (this._receiver) {
				// quick workaround
				if (!((this._receiver instanceof ScopeContext))) { this._receiver.cache() };
				args.unshift(this.receiver());
				// should rather rewrite to a new call?
				out = ("" + callee.c({expression: true}) + ".call(" + args.c({expression: true}) + ")");
			} else {
				out = ("" + callee.c({expression: true}) + "(" + args.c({expression: true}) + ")");
			};
			
			if (wrap) {
				// we set the cachevar inside
				// p "special caching for call"
				if (this._cache) {
					this._cache.manual = true;
					out = ("(" + (this.cachevar().c()) + "=" + out + ")");
				};
				
				out = [wrap[0],out,wrap[1]].join("");
			};
			
			return out;
		};
		
		
		
		
		function ImplicitCall(){ return Call.apply(this,arguments) };
		
		subclass$(ImplicitCall,Call);
		exports.ImplicitCall = ImplicitCall; // export class 
		ImplicitCall.prototype.js = function (o){
			return ("" + (this.callee().c()) + "()");
		};
		
		function New(){ return Call.apply(this,arguments) };
		
		subclass$(New,Call);
		exports.New = New; // export class 
		New.prototype.js = function (o){
			var target = this.callee();
			
			while (target instanceof Access){
				var left = target.left();
				
				if ((left instanceof PropertyAccess) || (left instanceof VarOrAccess)) {
					this.callee()._parens = true;
					break;
				};
				
				target = left;
			};
			
			var out = ("new " + (this.callee().c()));
			if (!((o.parent() instanceof Call))) { out += '()' };
			return out;
		};
		
		function SuperCall(){ return Call.apply(this,arguments) };
		
		subclass$(SuperCall,Call);
		exports.SuperCall = SuperCall; // export class 
		SuperCall.prototype.js = function (o){
			var m = o.method();
			this.setReceiver(SELF);
			this.setCallee(("" + (m.target().c()) + ".super$.prototype." + (m.name().c())));
			return SuperCall.__super__.js.apply(this,arguments);
		};
		
		
		
		function ExternDeclaration(){ return ListNode.apply(this,arguments) };
		
		subclass$(ExternDeclaration,ListNode);
		exports.ExternDeclaration = ExternDeclaration; // export class 
		ExternDeclaration.prototype.visit = function (){
			
			// p "visiting externdeclaration"
			this.setNodes(this.map(function(item) { return item.node(); })); // drop var or access really
			// only in global scope?
			var root = this.scope__();
			for (var i = 0, ary = iter$(this.nodes()), len = ary.length, item; i < len; i++) {
				item = ary[i];
				var variable = root.register(item.symbol(),item,{type: 'global'});
				variable.addReference(item);
			};
			return this;
		};
		
		ExternDeclaration.prototype.c = function (){
			return "// externs";
		};
		
		
		// FLOW
		
		function ControlFlow(){ return Node.apply(this,arguments) };
		
		subclass$(ControlFlow,Node);
		exports.ControlFlow = ControlFlow; // export class 
		
		
		
		
		function ControlFlowStatement(){ return ControlFlow.apply(this,arguments) };
		
		subclass$(ControlFlowStatement,ControlFlow);
		exports.ControlFlowStatement = ControlFlowStatement; // export class 
		ControlFlowStatement.prototype.isExpressable = function (){
			return false;
		};
		
		
		
		function If(cond,body,o){
			if(o === undefined) o = {};
			this.setup();
			this._test = cond; // (o:type == 'unless' ? UnaryOp.new('!',cond,null) : cond)
			this._body = body;
			this._alt = null;
			this._type = o.type;
			if (this._type == 'unless') this.invert();
			this._scope = new IfScope(this);
			this;
		};
		
		subclass$(If,ControlFlow);
		exports.If = If; // export class 
		If.prototype.test = function(v){ return this._test; }
		If.prototype.setTest = function(v){ this._test = v; return this; };
		If.prototype.body = function(v){ return this._body; }
		If.prototype.setBody = function(v){ this._body = v; return this; };
		If.prototype.alt = function(v){ return this._alt; }
		If.prototype.setAlt = function(v){ this._alt = v; return this; };
		If.prototype.scope = function(v){ return this._scope; }
		If.prototype.setScope = function(v){ this._scope = v; return this; };
		
		If.ternary = function (cond,body,alt){
			// prefer to compile it this way as well
			var obj = new If(cond,new Block([body]),{type: '?'});
			obj.addElse(new Block([alt]));
			return obj;
		};
		
		If.prototype.addElse = function (add){
			// p "add else!",add
			if (this.alt() && (this.alt() instanceof If)) {
				// p 'add to the inner else(!)',add
				this.alt().addElse(add);
			} else {
				this.setAlt(add);
			};
			return this;
		};
		
		
		If.prototype.invert = function (){
			if (this._test instanceof ComparisonOp) {
				return this._test = this._test.invert();
			} else {
				return this._test = new UnaryOp('!',this._test,null);
			};
		};
		
		If.prototype.visit = function (){
			var alt = this.alt();
			
			if (this._scope) { this._scope.visit() };
			if (this.test()) { this.test().traverse() };
			if (this.body()) { this.body().traverse() };
			
			// should skip the scope in alt.
			if (alt) {
				// p "scoping {STACK.scopes:length}"
				STACK.pop(this);
				alt._scope || (alt._scope = new BlockScope(alt));
				alt.traverse();
				STACK.push(this);
			};
			
			// force it as expression?
			if (this._type == '?' && this.isExpressable()) this.toExpression();
			return this;
		};
		
		
		If.prototype.js = function (o){
			var body = this.body();
			// would possibly want to look up / out 
			var brace = {braces: true,indent: true};
			
			var cond = this.test().c({expression: true}); // the condition is always an expression
			
			if (o.isExpression()) {
				var code = body.c(); // (braces: yes)
				code = '(' + code + ')'; // if code.indexOf(',') >= 0
				// is expression!
				if (this.alt()) {
					// console.log "type of ternary {test}"
					// be safe - wrap condition as well
					// ask for parens
					return ("" + cond + " ? " + code + " : (" + (this.alt().c()) + ")");
				} else {
					// again - we need a better way to decide what needs parens
					// maybe better if we rewrite this to an OP('&&'), and put
					// the parens logic there
					// cond should possibly have parens - but where do we decide?
					if (this._tagtree) {
						return ("(" + cond + ") ? " + code + " : void(0)");
					} else {
						return ("(" + cond + ") && " + code);
					};
				};
			} else {
				// if there is only a single item - and it is an expression?
				code = null;
				// if body.count == 1 # dont indent by ourselves?
				
				if ((body instanceof Block) && body.count() == 1 && !(body.first() instanceof LoopFlowStatement)) {
					// p "body to body first {body.first}"
					body = body.first();
				};
				
				// if body.count == 1
				//	p "one item only!"
				//	body = body.first
				
				code = body.c({braces: true}); // (braces: yes)
				
				// don't wrap if it is only a single expression?
				var out = ("" + mark__(this._type) + "if (" + cond + ") ") + code; // ' {' + code + '}' # '{' + code + '}'
				if (this.alt()) { out += (" else " + this.alt().c(this.alt() instanceof If ? ({}) : (brace))) };
				return out;
			};
		};
		
		If.prototype.sourceMapMarker = function (){
			return this;
		};
		
		If.prototype.consume = function (node){
			// p 'assignify if?!'
			// if it is possible, convert into expression
			if (node instanceof TagTree) {
				this._body = this._body.consume(node);
				if (this._alt) { this._alt = this._alt.consume(node) };
				this._tagtree = node;
				return this;
			};
			
			// special case for If created from conditional assign as well?
			// @type == '?' and 
			// ideally we dont really want to make any expression like this by default
			var isRet = (node instanceof Return);
			
			// might have been forced to expression already
			// if it was originally a ternary - why not
			if (this._expression || ((!(isRet) || this._type == '?') && this.isExpressable())) {
				this.toExpression(); // mark as expression(!) - is this needed?
				return If.__super__.consume.call(this,node);
			} else {
				this._body = this._body.consume(node);
				if (this._alt) { this._alt = this._alt.consume(node) };
			};
			return this;
		};
		
		
		If.prototype.isExpressable = function (){
			// process:stdout.write 'x'
			var exp = this.body().isExpressable() && (!(this.alt()) || this.alt().isExpressable());
			return exp;
		};
		
		
		
		function Loop(options){
			if(options === undefined) options = {};
			this._traversed = false;
			this._options = options;
			this._body = null;
			this;
		};
		
		
		subclass$(Loop,Statement);
		exports.Loop = Loop; // export class 
		Loop.prototype.scope = function(v){ return this._scope; }
		Loop.prototype.setScope = function(v){ this._scope = v; return this; };
		Loop.prototype.options = function(v){ return this._options; }
		Loop.prototype.setOptions = function(v){ this._options = v; return this; };
		Loop.prototype.body = function(v){ return this._body; }
		Loop.prototype.setBody = function(v){ this._body = v; return this; };
		Loop.prototype.catcher = function(v){ return this._catcher; }
		Loop.prototype.setCatcher = function(v){ this._catcher = v; return this; };
		
		
		Loop.prototype.set = function (obj){
			// p "configure for!"
			this._options || (this._options = {});
			var keys = Object.keys(obj);
			for (var i = 0, ary = iter$(keys), len = ary.length, k; i < len; i++) {
				k = ary[i];
				this._options[k] = obj[k];
			};
			return this;
		};
		
		
		Loop.prototype.addBody = function (body){
			this.setBody(blk__(body));
			return this;
		};
		
		
		Loop.prototype.c = function (o){
			
			var s = this.stack();
			var curr = s.current();
			// p "Loop.c - {isExpressable} {stack} {stack.isExpression}"
			// p "stack is expression? {o} {isExpression}"
			
			
			
			if (this.stack().isExpression() || this.isExpression()) {
				// p "the stack is an expression for loop now(!)"
				// what the inner one should not be an expression though?
				// this will resut in an infinite loop, no?!?
				var ast = CALL(FN([],[this]),[]);
				return ast.c(o);
			} else if ((this.stack().current() instanceof Block) || ((s.up() instanceof Block) && s.current()._consumer == this)) {
				
				// p "what is the current stack of loop? {stack.current}"
				return Loop.__super__.c.call(this,o);
			} else {
				// p "Should never get here?!?"
				ast = CALL(FN([],[this]),[]);
				return ast.c(o);
				// need to wrap in function
			};
		};
		
		
		
		function While(test,opts){
			this._traversed = false;
			this._test = test;
			this._options = opts || {};
			this._scope = new WhileScope(this);
			// set(opts) if opts
			// p "invert test for while? {@test}"
			if (this.option('invert')) {
				// "invert test for while {@test}"
				this._test = test.invert();
			};
			// invert the test
		};
		
		
		subclass$(While,Loop);
		exports.While = While; // export class 
		While.prototype.test = function(v){ return this._test; }
		While.prototype.setTest = function(v){ this._test = v; return this; };
		
		
		While.prototype.visit = function (){
			this.scope().visit();
			if (this.test()) { this.test().traverse() };
			if (this.body()) { return this.body().traverse() };
		};
		
		
		// TODO BUG -- when we declare a var like: while var y = ...
		// the variable will be declared in the WhileScope which never
		// force-declares the inner variables in the scope
		
		While.prototype.consume = function (node){
			// p "While.consume {node}".cyan
			// This is never expressable, but at some point
			// we might want to wrap it in a function (like CS)
			if (this.isExpressable()) { return While.__super__.consume.apply(this,arguments) };
			
			if (node instanceof TagTree) {
				// WARN this is a hack to allow references coming through the wrapping scope 
				// will result in unneeded self-declarations and other oddities
				this.scope().context().reference();
				return CALL(FN([],[this]),[]);
			};
			
			var reuse = false;
			// WARN Optimization - might have untended side-effects
			// if we are assigning directly to a local variable, we simply
			// use said variable for the inner res
			// if reuse
			// 	resvar = scope.declare(node.left.node.variable,Arr.new([]),proxy: yes)
			// 	node = null
			// 	p "consume variable declarator!?".cyan
			// else
			// declare the variable we will use to soak up results
			// p "Creating value to store the result of loop".cyan
			// TODO Use a special vartype for this?
			var resvar = this.scope().declare('res',new Arr([]),{system: true});
			// WHAT -- fix this --
			this._catcher = new PushAssign("push",resvar,null); // the value is not preset # what
			this.body().consume(this._catcher); // should still return the same body
			
			// scope vars must not be compiled before this -- this is important
			var ast = new Block([this,resvar.accessor()]); // should be varaccess instead?
			return ast.consume(node);
			// NOTE Here we can find a way to know wheter or not we even need to 
			// return the resvar. Often it will not be needed
			// FIXME what happens if there is no node?!?
		};
		
		
		While.prototype.js = function (o){
			var out = ("while (" + this.test().c({expression: true}) + ")") + this.body().c({braces: true,indent: true}); // .wrap
			
			if (this.scope().vars().count() > 0) {
				// p "while-block has declared variables(!)"
				return [this.scope().vars().c(),out];
			};
			return out;
		};
		
		
		
		// This should define an open scope
		// should rather 
		function For(o){
			if(o === undefined) o = {};
			this._traversed = false;
			this._options = o;
			this._scope = new ForScope(this);
			this._catcher = null;
		};
		
		subclass$(For,Loop);
		exports.For = For; // export class 
		For.prototype.visit = function (){
			this.scope().visit();
			this.options().source.traverse(); // what about awakening the vars here?
			this.declare();
			// should be able to toggle whether to keep the results here already(!)
			
			// add guard to body
			if (this.options().guard) {
				var op = IF(this.options().guard.invert(),Block.wrap([new ContinueStatement("continue")]));
				this.body().unshift(op,BR);
			};
			
			return this.body().traverse();
		};
		
		For.prototype.isBare = function (src){
			return src && src._variable && src._variable._isArray;
		};
		
		For.prototype.declare = function (){
			var o = this.options();
			var scope = this.scope();
			var src = o.source;
			var vars = o.vars = {};
			var oi = o.index;
			
			var bare = this.isBare(src);
			// p "source is a {src} - {bare}"
			// var i = vars:index = oi ? scope.declare(oi,0) : util.counter(0,yes).predeclare
			
			// what about a range where we also include an index?
			if (src instanceof Range) {
				// p "range for-loop"
				
				// really? declare? 
				// are we sure? _really_?
				vars.len = scope.declare('len',src.right()); // util.len(o,yes).predeclare
				// make the scope be the declarator
				// TODO would like to be able to have counter in range as well
				vars.index = scope.register(o.name,scope,{type: 'let',declared: true});
				// p "registered {vars:index:constructor}"
				// p "index-var is declareod?!?! {vars:index.@declared}"
				scope.vars().push(vars.index.assignment(src.left()));
				// scope.declare(options:name,src.left)
				vars.value = vars.index;
			} else {
				// vars:value = scope.declare(options:name,null,let: yes)
				// we are using automatic caching far too much here
				
				// we should simply change how declare works
				var i = vars.index = oi ? (scope.declare(oi,0,{type: 'let'})) : (this.util().counter(0,true,scope).predeclare());
				
				vars.source = bare ? (src) : (this.util().iterable(src,true).predeclare());
				vars.len = this.util().len(vars.source,true).predeclare();
				
				vars.value = scope.declare(o.name,null,{type: 'let'});
				vars.value.addReference(o.name); // adding reference!
				if (oi) { i.addReference(oi) };
			};
			
			return this;
		};
		
		
		For.prototype.consume = function (node){
			
			var receiver;
			if (this.isExpressable()) {
				return For.__super__.consume.apply(this,arguments);
			};
			
			// other cases as well, no?
			if (node instanceof TagTree) {
				this.scope().context().reference();
				var ref = node.root().reference();
				node._loop = this;
				
				// Should not be consumed the same way
				this.body().consume(node);
				node._loop = null;
				var fn = new Lambda([new Param(ref)],[this]);
				fn.scope().wrap(this.scope());
				// TODO Scope of generated lambda should be added into stack for
				// variable naming / resolution
				return CALL(fn,[ref]);
			};
			
			
			if (this._resvar) {
				// p "already have a resvar -- change consume? {node}"
				var ast = new Block([this,BR,this._resvar.accessor()]);
				ast.consume(node);
				return ast;
			};
			
			// if node isa return -- do something else
			
			var resvar = null;
			var reuseable = false; // node isa Assign && node.left.node isa LocalVarAccess
			var assignee = null;
			// might only work for locals?
			if (node instanceof Assign) {
				// p "node isa assign {node} {node.left}"
				if (receiver = node.left()) {
					if (assignee = receiver._variable) {
						// we can only pull the var reference into the scope
						// if we know that the variable is declared in this scope
						reuseable = (receiver instanceof VarReference);
					};
				};
			};
			
			// p "reusable?!?! {node} {node}"
			
			// WARN Optimization - might have untended side-effects
			// if we are assigning directly to a local variable, we simply
			// use said variable for the inner res
			if (reuseable && assignee) {
				// instead of declaring it in the scope - why not declare it outside?
				// it might already exist in the outer scope no?
				// p "reuseable {assignee} {scope} {scope.parent.lookup(assignee)}"
				// assignee.resolve
				// should probably instead alter the assign-node to set value to a blank array
				// resvar = scope.parent.declare(assignee,Arr.new([]),proxy: yes,pos: 0)
				
				// this variable should really not be redeclared inside here at all
				assignee.resolve();
				// resvar = @resvar = scope.declare(assignee,Arr.new([]),proxy: yes)
				
				// dont declare it - simply push an assign into the vardecl of scope
				this.scope().vars().unshift(OP('=',assignee,new Arr([])));
				resvar = this._resvar = assignee;
				
				node._consumer = this;
				node = null;
				
				// p "consume variable declarator!?".cyan
			} else {
				// declare the variable we will use to soak up results
				// p "Creating value to store the result of loop".cyan
				// what about a pool here?
				resvar = this._resvar = this.scope().declare('res',new Arr([]),{system: true});
			};
			
			this._catcher = new PushAssign("push",resvar,null); // the value is not preset
			this.body().consume(this._catcher); // should still return the same body
			
			
			
			if (node) {
				// p "returning new ast where Loop is first"
				ast = new Block([this,BR,resvar.accessor().consume(node)]);
				return ast;
			};
			// var ast = Block.new([self,BR,resvar.accessor])
			// ast.consume(node) if node
			// return ast
			// p "Loop did consume successfully"
			return this;
			
			// this is never an expression (for now -- but still)
			// return ast
		};
		
		
		For.prototype.js = function (o){
			var v_;
			var vars = this.options().vars;
			var i = vars.index;
			var val = vars.value;
			var cond = OP('<',i,vars.len);
			var src = this.options().source;
			
			// p "references for value",val.references:length
			
			var final = this.options().step ? (
				OP('=',i,OP('+',i,this.options().step))
			) : (
				OP('++',i)
			);
			
			// if there are few references to the value - we can drop
			// the actual variable and instead make it proxy through the index
			if (src instanceof Range) {
				if (src.inclusive()) { (cond.setOp(v_ = '<='),v_) };
			} else if (val.refcount() < 3 && val.assignments().length == 0) {
				// p "proxy the value {val.assignments:length}"
				// p "should proxy value-variable instead"
				val.proxy(vars.source,i);
			} else {
				this.body().unshift(OP('=',val,OP('.',vars.source,i)),BR);
				// body.unshift(head)
				// TODO check lengths - intelligently decide whether to brace and indent
			};
			var head = ("" + mark__(this.options().keyword) + "for (" + (this.scope().vars().c()) + "; " + (cond.c()) + "; " + (final.c()) + ") ");
			return head + this.body().c({braces: true,indent: true}); // .wrap
		};
		
		
		For.prototype.head = function (){
			var vars = this.options().vars;
			return OP('=',vars.value,OP('.',vars.source,vars.index));
		};
		
		
		
		function ForIn(){ return For.apply(this,arguments) };
		
		subclass$(ForIn,For);
		exports.ForIn = ForIn; // export class 
		
		
		
		
		function ForOf(){ return For.apply(this,arguments) };
		
		subclass$(ForOf,For);
		exports.ForOf = ForOf; // export class 
		ForOf.prototype.declare = function (){
			var o = this.options();
			var vars = o.vars = {};
			
			// see if 
			
			// p "ForOf source isa {o:source}"
			
			// if o:source is a variable -- refer directly # variable? is this the issue?
			// p scope.@varmap['o'], scope.parent.@varmap['o']
			
			var src = vars.source = o.source._variable || this.scope().declare('o',o.source,{system: true,type: 'let'});
			if (o.index) { var v = vars.value = this.scope().declare(o.index,null,{let: true}) };
			
			// p "ForOf o:index {o:index} o:name {o:name}"
			// if o:index
			
			// possibly proxy the index-variable?
			
			if (o.own) {
				// var i = vars:index = scope.declare('i',0,system: true, type: 'let') # mark as a counter?
				var i = vars.index = this.util().counter(0,true,this.scope()).predeclare();
				// systemvariable -- should not really be added to the map
				var keys = vars.keys = this.scope().declare('keys',Util.keys(src.accessor()),{system: true,type: 'let'}); // the outer one should resolve first
				var l = vars.len = this.scope().declare('l',Util.len(keys.accessor()),{system: true,type: 'let'});
				var k = vars.key = this.scope().register(o.name,o.name,{type: 'let'}); // scope.declare(o:name,null,system: yes)
			} else {
				// we set the var -- why even declare it
				// no need to declare -- it will declare itself in the loop - no?
				k = vars.key = this.scope().register(o.name,o.name,{type: 'let'});
			};
			
			// TODO use util - why add references already? Ah -- this is for the highlighting
			if (v && o.index) { v.addReference(o.index) };
			if (k && o.name) { k.addReference(o.name) };
			
			return this;
		};
		
		ForOf.prototype.js = function (o){
			var vars = this.options().vars;
			
			var o = vars.source;
			var k = vars.key;
			var v = vars.value;
			var i = vars.index;
			
			
			if (v) {
				// set value as proxy of object[key]
				// possibly make it a ref? what is happening?
				v.refcount() < 3 ? (v.proxy(o,k)) : (this.body().unshift(OP('=',v,OP('.',o,k))));
			};
			
			if (this.options().own) {
				
				if (k.refcount() < 3) { // should probably adjust these
					k.proxy(vars.keys,i);
				} else {
					this.body().unshift(OP('=',k,OP('.',vars.keys,i)));
				};
				
				var head = ("" + mark__(this.options().keyword) + "for (" + (this.scope().vars().c()) + "; " + (OP('<',i,vars.len).c()) + "; " + (OP('++',i).c()) + ")");
				return head + this.body().c({indent: true,braces: true}); // .wrap
			};
			
			var code = this.body().c({braces: true,indent: true});
			// it is really important that this is a treated as a statement
			return this.scope().vars().c() + (";\n" + mark__(this.options().keyword) + "for (var " + (k.c()) + " in " + (o.c()) + ")") + code;
		};
		
		ForOf.prototype.head = function (){
			var v = this.options().vars;
			
			return [
				OP('=',v.key,OP('.',v.keys,v.index)),
				(v.value) && (OP('=',v.value,OP('.',v.source,v.key)))
			];
		};
		
		// NO NEED?
		function Begin(body){
			this._nodes = blk__(body).nodes();
		};
		
		
		subclass$(Begin,Block);
		exports.Begin = Begin; // export class 
		Begin.prototype.shouldParenthesize = function (){
			return this.isExpression();
		};
		
		
		
		function Switch(a,b,c){
			this._traversed = false;
			this._source = a;
			this._cases = b;
			this._fallback = c;
		};
		
		
		subclass$(Switch,ControlFlowStatement);
		exports.Switch = Switch; // export class 
		Switch.prototype.source = function(v){ return this._source; }
		Switch.prototype.setSource = function(v){ this._source = v; return this; };
		Switch.prototype.cases = function(v){ return this._cases; }
		Switch.prototype.setCases = function(v){ this._cases = v; return this; };
		Switch.prototype.fallback = function(v){ return this._fallback; }
		Switch.prototype.setFallback = function(v){ this._fallback = v; return this; };
		
		
		Switch.prototype.visit = function (){
			for (var i = 0, ary = iter$(this.cases()), len = ary.length; i < len; i++) {
				ary[i].traverse();
			};
			if (this.fallback()) { this.fallback().visit() };
			if (this.source()) { this.source().visit() };
			return;
		};
		
		
		Switch.prototype.consume = function (node){
			// TODO work inside tags (like loops)
			this._cases = this._cases.map(function(item) { return item.consume(node); });
			if (this._fallback) { this._fallback = this._fallback.consume(node) };
			return this;
		};
		
		Switch.prototype.c = function (o){
			if (this.stack().isExpression() || this.isExpression()) {
				var ast = CALL(FN([],[this]),[]);
				return ast.c(o);
			};
			
			return Switch.__super__.c.call(this,o);
		};
		
		
		Switch.prototype.js = function (o){
			var body = [];
			
			for (var i = 0, ary = iter$(this.cases()), len = ary.length, part; i < len; i++) {
				part = ary[i];
				part.autobreak();
				body.push(part);
			};
			
			if (this.fallback()) {
				body.push("default:\n" + this.fallback().c({indent: true}));
			};
			
			return ("switch (" + (this.source().c()) + ") ") + helpers.bracketize(cary__(body).join("\n"),true);
		};
		
		
		
		function SwitchCase(test,body){
			this._traversed = false;
			this._test = test;
			this._body = blk__(body);
		};
		
		subclass$(SwitchCase,ControlFlowStatement);
		exports.SwitchCase = SwitchCase; // export class 
		SwitchCase.prototype.test = function(v){ return this._test; }
		SwitchCase.prototype.setTest = function(v){ this._test = v; return this; };
		SwitchCase.prototype.body = function(v){ return this._body; }
		SwitchCase.prototype.setBody = function(v){ this._body = v; return this; };
		
		
		SwitchCase.prototype.visit = function (){
			return this.body().traverse();
		};
		
		
		SwitchCase.prototype.consume = function (node){
			this.body().consume(node);
			return this;
		};
		
		
		SwitchCase.prototype.autobreak = function (){
			if (!((this.body().last() instanceof BreakStatement))) { this.body().push(new BreakStatement()) };
			return this;
		};
		
		
		SwitchCase.prototype.js = function (o){
			if (!((this._test instanceof Array))) { this._test = [this._test] };
			var cases = this._test.map(function(item) { return ("case " + (item.c()) + ":"); });
			return cases.join("\n") + this.body().c({indent: true}); // .indent
		};
		
		
		
		function Try(body,c,f){
			this._traversed = false;
			this._body = blk__(body);
			this._catch = c;
			this._finally = f;
		};
		
		
		subclass$(Try,ControlFlowStatement);
		exports.Try = Try; // export class 
		Try.prototype.body = function(v){ return this._body; }
		Try.prototype.setBody = function(v){ this._body = v; return this; };
		// prop ncatch
		// prop nfinally
		
		Try.prototype.consume = function (node){
			this._body = this._body.consume(node);
			if (this._catch) { this._catch = this._catch.consume(node) };
			if (this._finally) { this._finally = this._finally.consume(node) };
			return this;
		};
		
		
		Try.prototype.visit = function (){
			this._body.traverse();
			if (this._catch) { this._catch.traverse() };
			if (this._finally) { return this._finally.traverse() };
			// no blocks - add an empty catch
		};
		
		
		Try.prototype.js = function (o){
			var out = "try " + this.body().c({braces: true,indent: true});
			if (this._catch) { out += " " + this._catch.c() };
			if (this._finally) { out += " " + this._finally.c() };
			
			if (!(this._catch || this._finally)) {
				out += (" catch (e) \{ \}");
			};
			out += ";";
			return out;
		};
		
		
		
		function Catch(body,varname){
			this._traversed = false;
			this._body = blk__(body || []);
			this._scope = new CatchScope(this);
			this._varname = varname;
			this;
		};
		
		subclass$(Catch,ControlFlowStatement);
		exports.Catch = Catch; // export class 
		Catch.prototype.body = function(v){ return this._body; }
		Catch.prototype.setBody = function(v){ this._body = v; return this; };
		
		Catch.prototype.consume = function (node){
			this._body = this._body.consume(node);
			return this;
		};
		
		
		Catch.prototype.visit = function (){
			this._scope.visit();
			this._variable = this._scope.register(this._varname,this,{pool: 'catchvar'});
			return this._body.traverse();
		};
		
		
		Catch.prototype.js = function (o){
			// only indent if indented by default?
			return ("catch (" + (this._variable.c()) + ") ") + this._body.c({braces: true,indent: true});
		};
		
		
		// repeating myself.. don't deal with it until we move to compact tuple-args
		// for all astnodes
		
		
		function Finally(body){
			this._traversed = false;
			this._body = blk__(body || []);
		};
		
		
		subclass$(Finally,ControlFlowStatement);
		exports.Finally = Finally; // export class 
		Finally.prototype.visit = function (){
			return this._body.traverse();
		};
		
		
		Finally.prototype.consume = function (node){
			// swallow silently
			return this;
		};
		
		
		Finally.prototype.js = function (o){
			return "finally " + this._body.c({braces: true,indent: true});
		};
		
		
		// RANGE
		
		function Range(){ return Op.apply(this,arguments) };
		
		subclass$(Range,Op);
		exports.Range = Range; // export class 
		Range.prototype.inclusive = function (){
			return this.op() == '..';
		};
		
		Range.prototype.c = function (){
			return "range";
		};
		
		
		function Splat(){ return ValueNode.apply(this,arguments) };
		
		subclass$(Splat,ValueNode);
		exports.Splat = Splat; // export class 
		Splat.prototype.js = function (o){
			var par = this.stack().parent();
			if ((par instanceof ArgList) || (par instanceof Arr)) {
				return ("[].slice.call(" + (this.value().c()) + ")");
			} else {
				this.p(("what is the parent? " + par));
				return "SPLAT";
			};
		};
		
		Splat.prototype.node = function (){
			return this.value();
		};
		
		
		
		
		
		// TAGS
		
		
		TAG_TYPES = {};
		TAG_ATTRS = {};
		
		
		TAG_TYPES.HTML = "a abbr address area article aside audio b base bdi bdo big blockquote body br button canvas caption cite code col colgroup data datalist dd del details dfn div dl dt em embed fieldset figcaption figure footer form h1 h2 h3 h4 h5 h6 head header hr html i iframe img input ins kbd keygen label legend li link main map mark menu menuitem meta meter nav noscript object ol optgroup option output p param pre progress q rp rt ruby s samp script section select small source span strong style sub summary sup table tbody td textarea tfoot th thead time title tr track u ul var video wbr".split(" ");
		
		TAG_TYPES.SVG = "circle defs ellipse g line linearGradient mask path pattern polygon polyline radialGradient rect stop svg text tspan".split(" ");
		
		TAG_ATTRS.HTML = "accept accessKey action allowFullScreen allowTransparency alt async autoComplete autoFocus autoPlay cellPadding cellSpacing charSet checked className cols colSpan content contentEditable contextMenu controls coords crossOrigin data dateTime defer dir disabled download draggable encType form formNoValidate frameBorder height hidden href hrefLang htmlFor httpEquiv icon id label lang list loop max maxLength mediaGroup method min multiple muted name noValidate pattern placeholder poster preload radioGroup readOnly rel required role rows rowSpan sandbox scope scrollLeft scrolling scrollTop seamless selected shape size span spellCheck src srcDoc srcSet start step style tabIndex target title type useMap value width wmode";
		
		TAG_ATTRS.SVG = "cx cy d dx dy fill fillOpacity fontFamily fontSize fx fy gradientTransform gradientUnits markerEnd markerMid markerStart offset opacity patternContentUnits patternUnits points preserveAspectRatio r rx ry spreadMethod stopColor stopOpacity stroke strokeDasharray strokeLinecap strokeOpacity strokeWidth textAnchor transform version viewBox x1 x2 x y1 y2 y";
		
		
		function TagDesc(){
			this.p('TagDesc!!!',arguments);
			this;
		};
		
		subclass$(TagDesc,Node);
		exports.TagDesc = TagDesc; // export class 
		TagDesc.prototype.classes = function (){
			this.p('TagDescClasses',arguments);
			return this;
		};
		
		function Tag(o){
			if(o === undefined) o = {};
			this._traversed = false;
			this._parts = [];
			o.classes || (o.classes = []);
			o.attributes || (o.attributes = []);
			o.classes || (o.classes = []);
			this._options = o;
			this._reference = null;
			this._object = null;
			this._tree = null;
			this;
		};
		
		subclass$(Tag,Node);
		exports.Tag = Tag; // export class 
		Tag.prototype.parts = function(v){ return this._parts; }
		Tag.prototype.setParts = function(v){ this._parts = v; return this; };
		Tag.prototype.object = function(v){ return this._object; }
		Tag.prototype.setObject = function(v){ this._object = v; return this; };
		Tag.prototype.reactive = function(v){ return this._reactive; }
		Tag.prototype.setReactive = function(v){ this._reactive = v; return this; };
		Tag.prototype.parent = function(v){ return this._parent; }
		Tag.prototype.setParent = function(v){ this._parent = v; return this; };
		Tag.prototype.tree = function(v){ return this._tree; }
		Tag.prototype.setTree = function(v){ this._tree = v; return this; };
		
		Tag.prototype.set = function (obj){
			for (var v, i = 0, keys = Object.keys(obj), l = keys.length; i < l; i++){
				k = keys[i];v = obj[k];if (k == 'attributes') {
					// p "attributs!"
					for (var j = 0, ary = iter$(v), len = ary.length; j < len; j++) {
						this.addAttribute(ary[j]);
					};
					continue;
				};
				
				this._options[k] = v;
			};
			return this;
		};
		
		Tag.prototype.addClass = function (node){
			if (!((node instanceof TagFlag))) {
				node = new TagFlag(node);
			};
			this._options.classes.push(node);
			this._parts.push(node);
			
			// p "add class!!!"
			return this;
		};
		
		Tag.prototype.addIndex = function (node){
			this._parts.push(node);
			this._object = node;
			return this;
		};
		
		Tag.prototype.addSymbol = function (node){
			// p "addSymbol to the tag",node
			if (this._parts.length == 0) {
				this._parts.push(node);
				this._options.ns = node;
			};
			return this;
		};
		
		
		Tag.prototype.addAttribute = function (atr){
			// p "add attribute!!!", key, value
			this._parts.push(atr); // what?
			this._options.attributes.push(atr);
			return this;
		};
		
		Tag.prototype.enclosing = function (){
			return this._options.close && this._options.close.value();
		};
		
		Tag.prototype.type = function (){
			return this._options.type || 'div';
		};
		
		Tag.prototype.consume = function (node){
			var o = this._options;
			
			
			if (node instanceof TagTree) {
				// p "tag consume tagtree? {node.reactive}"
				this.setParent(node.root());
				// o:treeRef = node.nextCacheKey
				
				if (node._loop) {
					// alwatys make items in loop reactive
					this.setReactive(node.reactive() || this.option('key'));
					this.option('loop',node._loop);
					
					if (this.option('ivar')) {
						this.warn(("Tag inside loop can not have a static reference " + this.option('ivar')),{type: 'error',token: this.option('ivar').value()});
					};
				} else {
					this.setReactive(node.reactive() || !(!this.option('ivar')));
				};
				
				return this;
			};
			
			return Tag.__super__.consume.apply(this,arguments);
		};
		
		
		Tag.prototype.visit = function (){
			
			var o = this._options;
			
			if (o.ivar || o.key) {
				this.setReactive(true);
			};
			
			var typ = this.enclosing();
			
			// look for outer tag here?
			
			if (typ == '->' || typ == '=>') {
				// console.log "tag is template?!? {typ}"
				this._tree = new TagTree(this,o.body,{root: this,reactive: this.reactive()});
				o.body = new TagFragmentFunc([],Block.wrap([this._tree]));
				// console.log "made o body a function?"
			};
			
			if (o.key) { o.key.traverse() };
			
			if (o.body) {
				o.body.traverse();
			};
			
			// id should also be a regular part
			
			if (o.id) { o.id.traverse() };
			
			
			for (var i = 0, ary = iter$(this._parts), len = ary.length; i < len; i++) {
				ary[i].traverse();
			};
			
			// for atr in @options:attributes
			// 	atr.traverse
			
			return this;
		};
		
		Tag.prototype.reference = function (){
			return this._reference || (this._reference = this.scope__().closure().temporary(this,{pool: 'tag'}).resolve());
		};
		
		// should this not happen in js?
		// should this not happen in js?
		Tag.prototype.js = function (o){
			// p JSON.stringify(@options)
			// var attrs = TagAttributes.new(o:attributes)
			// p "got here?"
			var body;
			var o = this._options;
			var a = {};
			var enc = this.enclosing();
			
			var setup = [];
			var calls = [];
			var statics = [];
			
			var scope = this.scope__();
			var commit = "end";
			var content = o.body;
			
			var isSelf = (this.type() instanceof Self);
			var bodySetter = isSelf ? ("setChildren") : ("setContent");
			
			// should not cache statics if the node itself is not cached
			// that would only mangle the order in which we set the properties
			var cacheStatics = true;
			
			for (var i = 0, ary = iter$(o.attributes), len = ary.length, atr; i < len; i++) {
				atr = ary[i];
				a[atr.key()] = atr.value(); // .populate(obj)
			};
			
			var quote = function(str) { return helpers.singlequote(str); };
			var id = o.id instanceof Node ? (o.id.c()) : ((o.id && quote(o.id.c())));
			var tree = this._tree || null;
			var parent = this.parent();
			// var parTree = parent and parent.tree
			
			
			//  "scope is", !!scope
			// p "type is {type}"
			var out = isSelf ? (
				commit = "synced",
				// p "got here"
				// setting correct context directly
				this.setReactive(true),
				this._reference = scope.context(),
				scope.context().c()
			) : (
				("" + mark__(o.open) + (scope.tagContextPath()) + "." + (this.type().spawner()) + "()")
			);
			
			if (o.id) {
				statics.push((".setId(" + quote(o.id) + ")"));
			};
			// this is reactive if it has an ivar
			if (o.ivar) {
				this.setReactive(true);
				statics.push((".setRef(" + quote(o.ivar.name()) + "," + (scope.context().c()) + ")"));
			};
			
			if (o.body instanceof Func) {
				// console.log "o:body isa function!"
				bodySetter = "setTemplate";
			} else if (o.body) {
				if ((o.body instanceof ArgList) && o.body.count() == 1 && o.body.first().isString()) {
					bodySetter = "setText";
				} else {
					// would probably be better to convert to a tagtree during the initial visit
					tree = new TagTree(this,o.body,{root: this,reactive: this.reactive()});
					content = tree;
					this.setTree(tree);
				};
			};
			
			if (tree) {
				// this is the point where we traverse the inner nodes with our tree
				// should rather happen in visit - long before.
				tree.resolve();
			};
			
			for (var i = 0, ary = iter$(this._parts), len = ary.length, part; i < len; i++) {
				part = ary[i];
				var pjs;
				var pcache = false;
				
				if (part instanceof TagAttr) {
					var akey = String(part.key());
					var aval = part.value();
					// p "part value {aval} {aval.isPrimitive(yes)}"
					
					// the attr should compile itself instead -- really
					pcache = aval.isPrimitive();
					
					if (akey[0] == '.') { // should check in a better way
						pcache = false;
						pjs = (".flag(" + quote(akey.substr(1)) + "," + (aval.c()) + ")");
					} else if (akey[0] == ':') {
						// need to analyze whether this is static or not
						pjs = (".setHandler(" + quote(akey.substr(1)) + "," + (aval.c()) + "," + (scope.context().c()) + ")");
					} else if (akey.substr(0,5) == 'data-') {
						pjs = (".dataset('" + akey.slice(5) + "'," + (aval.c()) + ")");
					} else {
						pjs = ("." + mark__(part.key()) + helpers.setterSym(akey) + "(" + (aval.c()) + ")");
					};
				} else if (part instanceof TagFlag) {
					pjs = part.c();
					pcache = true;
				};
				
				if (pjs) {
					cacheStatics && pcache ? (statics.push(pjs)) : (calls.push(pjs));
				};
			};
			
			
			
			if (this.object()) {
				calls.push((".setObject(" + (this.object().c()) + ")"));
			};
			
			// p "tagtree is static? {tree.static}"
			
			// we need to trigger our own reference before the body does
			// but we do not need a reference if we have no body (no nodes will refer it)
			if (this.reactive() && tree) { // and tree.hasTags
				this.reference();
			};
			
			if (this.reactive() && parent && parent.tree()) {
				o.treeRef = parent.tree().nextCacheKey(this);
			};
			
			if (body = content && content.c({expression: true})) { // force it to be an expression, no?
				var typ = 0;
				
				if (tree) {
					if (tree.static()) {
						typ = 2;
					} else if (this.reactive() || tree.reactive()) {
						if (!tree.single() || (tree.single() instanceof If)) {
							typ = 1;
						} else {
							typ = 3;
						};
					};
				};
				
				
				if (bodySetter == 'setChildren' || bodySetter == 'setContent') {
					calls.push(("." + bodySetter + "(" + body + "," + typ + ")"));
				} else {
					calls.push(("." + bodySetter + "(" + body + ")"));
				};
				
				// out += ".body({body})"
			};
			
			// if o:attributes:length # or -- always?
			// adds lots of extra calls - but okay for now
			calls.push(("." + commit + "()"));
			
			if (statics.length) {
				out = out + statics.join("");
			};
			
			
			if ((o.ivar || o.key || this.reactive()) && !(this.type() instanceof Self)) {
				// if this is an ivar, we should set the reference relative
				// to the outer reference, or possibly right on context?
				var ctx,key;
				var partree = parent && parent.tree();
				// ctx = !o:ivar and par and par.reference or scope.context
				// key = o:ivar or tree and tree.nextCacheKey
				
				if (o.key) {
					// closest tag
					// TODO if the dynamic key starts with a static string we should
					// just prepend _ to the string instead of wrapping in OP
					ctx = parent && parent.reference();
					key = OP('+',new Str("'_'"),o.key);
				} else if (o.ivar) {
					ctx = scope.context();
					key = o.ivar;
				} else {
					ctx = parent && parent.reference();
					// ctx = partree.cacher
					key = o.treeRef || partree && partree.nextCacheKey();
					// key = tree and tree.nextCacheKey
					if (o.loop) {
						var idx = o.loop.option('vars').index;
						key = OP('+',"'" + key + "'",idx);
					};
				};
				
				
				
				// need the context -- might be better to rewrite it for real?
				// parse the whole thing into calls etc
				var acc = OP('.',ctx,key).c();
				
				if (this._reference) {
					out = ("(" + (this.reference().c()) + " = " + acc + "=" + acc + " || " + out + ")");
				} else {
					out = ("(" + acc + " = " + acc + " || " + out + ")");
				};
			};
			
			return out + calls.join("");
		};
		
		// This is a helper-node
		// Should probably use the same type of listnode everywhere - and simply flag the type as TagTree instead
		function TagTree(owner,list,options){
			if(options === undefined) options = {};
			this._owner = owner;
			this._nodes = this.load(list);
			this._options = options;
			this._conditions = [];
			this._blocks = [this];
			this._counter = 0;
			this;
		};
		
		subclass$(TagTree,ListNode);
		exports.TagTree = TagTree; // export class 
		TagTree.prototype.counter = function(v){ return this._counter; }
		TagTree.prototype.setCounter = function(v){ this._counter = v; return this; };
		TagTree.prototype.conditions = function(v){ return this._conditions; }
		TagTree.prototype.setConditions = function(v){ this._conditions = v; return this; };
		TagTree.prototype.blocks = function(v){ return this._blocks; }
		TagTree.prototype.setBlocks = function(v){ this._blocks = v; return this; };
		TagTree.prototype.cacher = function(v){ return this._cacher; }
		TagTree.prototype.setCacher = function(v){ this._cacher = v; return this; };
		
		TagTree.prototype.parent = function (){
			return this._parent || (this._parent = this._owner.parent());
		};
		
		TagTree.prototype.nextCacheKey = function (){
			var root = this._owner;
			
			// if we want to cache everything on root
			var num = ++this._counter;
			var base = "A".charCodeAt(0);
			var str = "";
			
			while (true){
				num -= 1;
				str = String.fromCharCode(base + (num % 26)) + str;
				num = Math.floor(num / 26);
				if (num <= 0) { break; };
			};
			
			str = (this._owner.type() instanceof Self ? ("$") : ("$$")) + str.toLowerCase();
			return str;
			return num;
		};
		
		TagTree.prototype.load = function (list){
			if (list instanceof ListNode) {
				// p "is a list node!! {list.count}"
				// we still want the indentation if we are not in a template
				// or, rather - we want the block to get the indentation - not the tree
				this._indentation || (this._indentation = list._indentation); // if list.count > 1
				return list.nodes();
			} else {
				return compact__(list instanceof Array ? (list) : ([list]));
			};
		};
		
		TagTree.prototype.root = function (){
			return this.option('root');
		};
		
		TagTree.prototype.reactive = function (){
			return this.option('reactive');
		};
		
		TagTree.prototype.resolve = function (){
			var self = this;
			this.remap(function(c) { return c.consume(self); });
			return self;
		};
		
		TagTree.prototype.static = function (){
			// every real node
			return this._static == null ? (this._static = this.every(function(c) { return (c instanceof Tag) || (c instanceof Str) || (c instanceof Meta); })) : (this._static);
		};
		
		TagTree.prototype.single = function (){
			return this._single == null ? (this._single = (this.realCount() == 1 ? (this.last()) : (false))) : (this._single);
		};
		
		TagTree.prototype.hasTags = function (){
			return this.some(function(c) { return c instanceof Tag; });
		};
		
		TagTree.prototype.c = function (o){
			// FIXME TEST what about comments???
			var single = this.single();
			
			// no indentation if this should return
			if (single && (STACK.current() instanceof Return)) {
				this._indentation = null;
			};
			
			var out = TagTree.__super__.c.call(this,o);
			
			if (!(single) || (single instanceof If)) {
				return ("[" + out + "]");
			} else {
				return out;
			};
		};
		
		function TagWrapper(){ return ValueNode.apply(this,arguments) };
		
		subclass$(TagWrapper,ValueNode);
		exports.TagWrapper = TagWrapper; // export class 
		TagWrapper.prototype.visit = function (){
			if (this.value() instanceof Array) {
				this.value().map(function(v) { return v.traverse(); });
			} else {
				this.value().traverse();
			};
			return this;
		};
		
		TagWrapper.prototype.c = function (){
			return ("tag$wrap(" + this.value().c({expression: true}) + ")");
		};
		
		
		function TagAttributes(){ return ListNode.apply(this,arguments) };
		
		subclass$(TagAttributes,ListNode);
		exports.TagAttributes = TagAttributes; // export class 
		TagAttributes.prototype.get = function (name){
			for (var i = 0, ary = iter$(this.nodes()), len = ary.length, node, res = []; i < len; i++) {
				node = ary[i];
				if (node.key() == name) { return node };
			};
			return res;
		};
		
		
		function TagAttr(k,v){
			// p "init TagAttribute", $0
			this._traversed = false;
			this._key = k;
			this._value = v;
		};
		
		subclass$(TagAttr,Node);
		exports.TagAttr = TagAttr; // export class 
		TagAttr.prototype.key = function(v){ return this._key; }
		TagAttr.prototype.setKey = function(v){ this._key = v; return this; };
		TagAttr.prototype.value = function(v){ return this._value; }
		TagAttr.prototype.setValue = function(v){ this._value = v; return this; };
		
		TagAttr.prototype.visit = function (){
			if (this.value()) { this.value().traverse() };
			return this;
		};
		
		TagAttr.prototype.populate = function (obj){
			obj.add(this.key(),this.value());
			return this;
		};
		
		TagAttr.prototype.c = function (){
			return "attribute";
		};
		
		
		function TagFlag(value){
			this._traversed = false;
			this._value = value;
			this;
		};
		
		subclass$(TagFlag,Node);
		exports.TagFlag = TagFlag; // export class 
		TagFlag.prototype.value = function(v){ return this._value; }
		TagFlag.prototype.setValue = function(v){ this._value = v; return this; };
		TagFlag.prototype.toggler = function(v){ return this._toggler; }
		TagFlag.prototype.setToggler = function(v){ this._toggler = v; return this; };
		
		TagFlag.prototype.visit = function (){
			if (!((typeof this._value=='string'||this._value instanceof String))) {
				this._value.traverse();
			};
			return this;
		};
		
		TagFlag.prototype.c = function (){
			if (this.value() instanceof Node) {
				return (".flag(" + (this.value().c()) + ")");
			} else {
				return (".flag(" + helpers.singlequote(this.value()) + ")");
			};
		};
		
		
		
		
		
		
		// SELECTORS
		
		
		function Selector(list,options){
			this._nodes = list || [];
			this._options = options;
		};
		
		subclass$(Selector,ListNode);
		exports.Selector = Selector; // export class 
		Selector.prototype.add = function (part,typ){
			// p "select add!",part,typ
			// mark if special?
			this.push(part);
			return this;
		};
		
		Selector.prototype.group = function (){
			// console.log "grouped!"
			// for now we simply add a comma
			// how would this work for dst?
			this._nodes.push(new SelectorGroup(","));
			return this;
		};
		
		Selector.prototype.query = function (){
			var str = "";
			var ary = [];
			
			for (var i = 0, items = iter$(this.nodes()), len = items.length; i < len; i++) {
				var val = items[i].c();
				if ((typeof val=='string'||val instanceof String)) {
					str = ("" + str + val);
				};
			};
			
			return ("'" + str + "'");
		};
		
		
		Selector.prototype.js = function (o){
			var typ = this.option('type');
			var q = c__(this.query());
			
			if (typ == '%') {
				return ("q$(" + q + "," + o.scope().context().c({explicit: true}) + ")"); // explicit context
			} else if (typ == '%%') {
				return ("q$$(" + q + "," + o.scope().context().c({explicit: true}) + ")");
			} else {
				return ("q" + typ + "(" + q + ")");
			};
			
			// return "{typ} {scoped} - {all}"
		};
		
		
		function SelectorPart(){ return ValueNode.apply(this,arguments) };
		
		subclass$(SelectorPart,ValueNode);
		exports.SelectorPart = SelectorPart; // export class 
		SelectorPart.prototype.c = function (){
			return c__(this._value);
			// "{value.c}"
		};
		
		function SelectorGroup(){ return SelectorPart.apply(this,arguments) };
		
		subclass$(SelectorGroup,SelectorPart);
		exports.SelectorGroup = SelectorGroup; // export class 
		SelectorGroup.prototype.c = function (){
			return ",";
		};
		
		function SelectorType(){ return SelectorPart.apply(this,arguments) };
		
		subclass$(SelectorType,SelectorPart);
		exports.SelectorType = SelectorType; // export class 
		SelectorType.prototype.c = function (){
			// support
			// p "selectortype {value}"
			// var out = value.c
			var name = this.value().name();
			
			// at least be very conservative about which tags we
			// can drop the tag for?
			// out in TAG_TYPES.HTML ? 
			return idx$(name,TAG_TYPES.HTML) >= 0 ? (name) : (this.value().sel());
		};
		
		
		function SelectorUniversal(){ return SelectorPart.apply(this,arguments) };
		
		subclass$(SelectorUniversal,SelectorPart);
		exports.SelectorUniversal = SelectorUniversal; // export class 
		
		
		function SelectorNamespace(){ return SelectorPart.apply(this,arguments) };
		
		subclass$(SelectorNamespace,SelectorPart);
		exports.SelectorNamespace = SelectorNamespace; // export class 
		
		
		function SelectorClass(){ return SelectorPart.apply(this,arguments) };
		
		subclass$(SelectorClass,SelectorPart);
		exports.SelectorClass = SelectorClass; // export class 
		SelectorClass.prototype.c = function (){
			if (this._value instanceof Node) {
				return (".'+" + (this._value.c()) + "+'");
			} else {
				return ("." + c__(this._value));
			};
		};
		
		function SelectorId(){ return SelectorPart.apply(this,arguments) };
		
		subclass$(SelectorId,SelectorPart);
		exports.SelectorId = SelectorId; // export class 
		SelectorId.prototype.c = function (){
			if (this._value instanceof Node) {
				return ("#'+" + (this._value.c()) + "+'");
			} else {
				return ("#" + c__(this._value));
			};
		};
		
		function SelectorCombinator(){ return SelectorPart.apply(this,arguments) };
		
		subclass$(SelectorCombinator,SelectorPart);
		exports.SelectorCombinator = SelectorCombinator; // export class 
		SelectorCombinator.prototype.c = function (){
			return ("" + c__(this._value));
		};
		
		function SelectorPseudoClass(){ return SelectorPart.apply(this,arguments) };
		
		subclass$(SelectorPseudoClass,SelectorPart);
		exports.SelectorPseudoClass = SelectorPseudoClass; // export class 
		
		
		function SelectorAttribute(left,op,right){
			this._left = left;
			this._op = op;
			this._right = this._value = right;
		};
		
		subclass$(SelectorAttribute,SelectorPart);
		exports.SelectorAttribute = SelectorAttribute; // export class 
		SelectorAttribute.prototype.c = function (){
			// TODO possibly support .toSel or sel$(v) for items inside query
			// could easily do it with a helper-function that is added to the top of the filescope
			if (this._right instanceof Str) {
				return ("[" + (this._left.c()) + (this._op) + (this._right.c()) + "]");
			} else if (this._right) {
				// this is not at all good
				return ("[" + (this._left.c()) + (this._op) + "\"'+" + c__(this._right) + "+'\"]");
			} else {
				return ("[" + (this._left.c()) + "]");
				
				// ...
			};
		};
		
		
		
		
		// DEFER
		
		function Await(){ return ValueNode.apply(this,arguments) };
		
		subclass$(Await,ValueNode);
		exports.Await = Await; // export class 
		Await.prototype.func = function(v){ return this._func; }
		Await.prototype.setFunc = function(v){ this._func = v; return this; };
		
		Await.prototype.js = function (o){
			// introduce a util here, no?
			return CALL(OP('.',new Util.Promisify([this.value()]),'then'),[this.func()]).c();
			// value.c
		};
		
		Await.prototype.visit = function (o){
			// things are now traversed in a somewhat chaotic order. Need to tighten
			// Create await function - push this value up to block, take the outer
			var self = this;
			self.value().traverse();
			
			var block = o.up(Block); // or up to the closest FUNCTION?
			var outer = o.relative(block,1);
			var par = o.relative(self,-1);
			
			// p "Block {block} {outer} {par}"
			
			self.setFunc(new AsyncFunc([],[]));
			// now we move this node up to the block
			self.func().body().setNodes(block.defers(outer,self));
			
			// if the outer is a var-assignment, we can simply set the params
			if (par instanceof Assign) {
				par.left().traverse();
				var lft = par.left().node();
				// p "Async assignment {par} {lft}"
				// Can be a tuple as well, no?
				if (lft instanceof VarReference) {
					// the param is already registered?
					// should not force the name already??
					// beware of bugs
					self.func().params().at(0,true,lft.variable().name());
				} else if (lft instanceof Tuple) {
					// if this an unfancy tuple, with only vars
					// we can just use arguments
					
					if (par.type() == 'var' && !lft.hasSplat()) {
						// p "SIMPLIFY! {lft.nodes[0]}"
						lft.map(function(el,i) {
							return self.func().params().at(i,true,el.value());
						});
					} else {
						// otherwise, do the whole tuple
						// make sure it is a var assignment?
						par.setRight(ARGUMENTS);
						self.func().body().unshift(par);
					};
				} else {
					// regular setters
					par.setRight(self.func().params().at(0,true));
					self.func().body().unshift(par);
				};
			};
			
			
			
			// If it is an advance tuple or something, it should be possible to
			// feed in the paramlist, and let the tuple handle it as if it was any
			// other value
			
			// CASE If this is a tuple / multiset with more than one async value
			// we need to think differently.
			
			// now we need to visit the function as well
			self.func().traverse();
			// pull the outer in
			return self;
		};
		
		function AsyncFunc(params,body,name,target,options){
			AsyncFunc.__super__.constructor.call(this,params,body,name,target,options);
		};
		
		subclass$(AsyncFunc,Func);
		exports.AsyncFunc = AsyncFunc; // export class 
		AsyncFunc.prototype.scopetype = function (){
			return LambdaScope;
		};
		
		// need to override, since we wont do implicit returns
		// def js
		// 	var code = scope.c
		// 	return "function ({params.c})" + code.wrap
		;
		
		
		
		// IMPORTS
		
		function ImportStatement(imports,source,ns){
			this._traversed = false;
			this._imports = imports;
			this._source = source;
			this._ns = ns;
			this;
		};
		
		subclass$(ImportStatement,Statement);
		exports.ImportStatement = ImportStatement; // export class 
		ImportStatement.prototype.ns = function(v){ return this._ns; }
		ImportStatement.prototype.setNs = function(v){ this._ns = v; return this; };
		ImportStatement.prototype.imports = function(v){ return this._imports; }
		ImportStatement.prototype.setImports = function(v){ this._imports = v; return this; };
		ImportStatement.prototype.source = function(v){ return this._source; }
		ImportStatement.prototype.setSource = function(v){ this._source = v; return this; };
		
		
		ImportStatement.prototype.visit = function (){
			if (this._ns) {
				this._nsvar || (this._nsvar = this.scope__().register(this._ns,this));
			} else {
				var src = this.source().c();
				var m = src.match(/(\w+)(\.js|imba)?[\"\']$/);
				this._alias = m ? (m[1] + '$') : ('mod$');
			};
			
			// should also register the imported items, no?
			if (this._imports) {
				var dec = this._declarations = new VariableDeclaration([]);
				
				if (this._imports.length == 1) {
					this._alias = this._imports[0];
					dec.add(this._alias,OP('.',CALL(new Identifier("require"),[this.source()]),this._alias));
					dec.traverse();
					return this;
					
					// dec.add(@alias,CALL(Identifier.new("require"),[source]))
				};
				
				// p "ImportStatement has imports {@imports:length}"
				// @declarations = VariableDeclaration.new([])
				this._moduledecl = dec.add(this._alias,CALL(new Identifier("require"),[this.source()]));
				this._moduledecl.traverse();
				
				
				if (this._imports.length > 1) {
					for (var i = 0, ary = iter$(this._imports), len = ary.length, imp; i < len; i++) {
						imp = ary[i];
						this._declarations.add(imp,OP('.',this._moduledecl.variable(),imp));
					};
				};
				
				dec.traverse();
			};
			return this;
		};
		
		
		ImportStatement.prototype.js = function (o){
			
			var fname;
			if (this._declarations) {
				return this._declarations.c();
			};
			
			var req = CALL(new Identifier("require"),[this.source()]);
			
			if (this._ns) {
				// must register ns as a real variable
				return ("var " + (this._nsvar.c()) + " = " + (req.c()));
			};
			
			if (this._imports) {
				
				var src = this.source().c();
				var alias = [];
				var vars = new VarBlock([]);
				
				if (fname = src.match(/(\w+)(\.js|imba)?[\"\']$/)) {
					alias.push(fname[1]);
				};
				
				// var alias = src.match(/(\w+)(\.js|imba)?[\"\']$/)
				// p "source type {source}"
				// create a require for the source, with a temporary name?
				var out = [req.cache({names: alias}).c()];
				
				for (var i = 0, ary = iter$(this._imports), len = ary.length, imp; i < len; i++) {
					// we also need to register these imports as variables, no?
					imp = ary[i];
					var o = OP('=',imp,OP('.',req,imp));
					out.push(("var " + (o.c())));
				};
				
				return out;
			} else {
				return req.c();
			};
		};
		
		ImportStatement.prototype.consume = function (node){
			return this;
		};
		
		
		// EXPORT 
		
		function ExportStatement(){ return ValueNode.apply(this,arguments) };
		
		subclass$(ExportStatement,ValueNode);
		exports.ExportStatement = ExportStatement; // export class 
		ExportStatement.prototype.js = function (o){
			var nodes = this._value.map(function(arg) { return ("module.exports." + (arg.c()) + " = " + (arg.c())); });
			
			if (nodes.length > 1 && (this.up() instanceof Return)) {
				return '[' + nodes.join(',') + ']';
			} else {
				return nodes.join(';\n') + ';';
			};
		};
		
		
		// UTILS
		
		function Util(args){
			this._args = args;
		};
		
		// this is how we deal with it now
		subclass$(Util,Node);
		exports.Util = Util; // export class 
		Util.prototype.args = function(v){ return this._args; }
		Util.prototype.setArgs = function(v){ this._args = v; return this; };
		
		Util.extend = function (a,b){
			return new Util.Extend([a,b]);
		};
		
		Util.callImba = function (meth,args){
			return CALL(OP('.',new Const("Imba"),new Identifier(meth)),args);
		};
		
		Util.repeat = function (str,times){
			var res = '';
			while (times > 0){
				if (times % 2 == 1) {
					res += str;
				};
				str += str;
				times >>= 1;
			};
			return res;
		};
		
		
		
		Util.keys = function (obj){
			var l = new Const("Object");
			var r = new Identifier("keys");
			return CALL(OP('.',l,r),[obj]);
		};
		
		Util.len = function (obj,cache){
			// p "LEN HELPER".green
			var r = new Identifier("length");
			var node = OP('.',obj,r);
			if (cache) { node.cache({force: true,pool: 'len'}) };
			return node;
		};
		
		Util.indexOf = function (lft,rgt){
			var node = new Util.IndexOf([lft,rgt]);
			// node.cache(force: yes, type: 'iter') if cache
			return node;
		};
		
		Util.slice = function (obj,a,b){
			var slice = new Identifier("slice");
			console.log(("slice " + a + " " + b));
			return CALL(OP('.',obj,slice),compact__([a,b]));
		};
		
		Util.iterable = function (obj,cache){
			var node = new Util.Iterable([obj]);
			if (cache) { node.cache({force: true,pool: 'iter'}) };
			return node;
		};
		
		
		
		Util.union = function (a,b){
			return new Util.Union([a,b]);
			// CALL(UNION,[a,b])
		};
		
		Util.intersect = function (a,b){
			return new Util.Intersect([a,b]);
			// CALL(INTERSECT,[a,b])
		};
		
		Util.counter = function (start,cache){
			// should it not rather be a variable?!?
			var node = new Num(start); // make sure it really is a number
			if (cache) { node.cache({force: true,pool: 'counter'}) };
			return node;
		};
		
		Util.array = function (size,cache){
			var node = new Util.Array([size]);
			if (cache) { node.cache({force: true,pool: 'list'}) };
			return node;
		};
		
		Util.defineTag = function (type,ctor,supr){
			return CALL(TAGDEF,[type,ctor,supr]);
		};
		
		
		Util.defineClass = function (name,supr,initor){
			return CALL(CLASSDEF,[name || initor,this.sup()]);
		};
		
		Util.prototype.isStandalone = function (){
			return OPTS.standalone !== false;
		};
		
		Util.prototype.js = function (o){
			return "helper";
		};
		
		// TODO Deprecate and remove
		Util.Union = function Union(){ return Util.apply(this,arguments) };
		
		subclass$(Util.Union,Util);
		Util.Union.prototype.helper = function (){
			return 'function union$(a,b){\n	if(a && a.__union) return a.__union(b);\n\n	var u = a.slice(0);\n	for(var i=0,l=b.length;i<l;i++) if(u.indexOf(b[i]) == -1) u.push(b[i]);\n	return u;\n};\n';
		};
		
		Util.Union.prototype.js = function (o){
			this.scope__().root().helper(this,this.helper());
			// When this is triggered, we need to add it to the top of file?
			return ("union$(" + this.args().map(function(v) { return v.c(); }).join(',') + ")");
		};
		
		// TODO Deprecate and remove
		Util.Intersect = function Intersect(){ return Util.apply(this,arguments) };
		
		subclass$(Util.Intersect,Util);
		Util.Intersect.prototype.helper = function (){
			return 'function intersect$(a,b){\n	if(a && a.__intersect) return a.__intersect(b);\n	var res = [];\n	for(var i=0, l=a.length; i<l; i++) {\n		var v = a[i];\n		if(b.indexOf(v) != -1) res.push(v);\n	}\n	return res;\n};\n';
		};
		
		Util.Intersect.prototype.js = function (o){
			// When this is triggered, we need to add it to the top of file?
			this.scope__().root().helper(this,this.helper());
			return ("intersect$(" + this.args().map(function(v) { return v.c(); }).join(',') + ")");
		};
		
		Util.Extend = function Extend(){ return Util.apply(this,arguments) };
		
		subclass$(Util.Extend,Util);
		Util.Extend.prototype.js = function (o){
			// When this is triggered, we need to add it to the top of file?
			return ("extend$(" + compact__(cary__(this.args())).join(',') + ")");
		};
		
		Util.IndexOf = function IndexOf(){ return Util.apply(this,arguments) };
		
		subclass$(Util.IndexOf,Util);
		Util.IndexOf.prototype.helper = function (){
			return 'function idx$(a,b){\n	return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);\n};\n';
		};
		
		Util.IndexOf.prototype.js = function (o){
			if (this.isStandalone()) {
				this.scope__().root().helper(this,this.helper());
				// When this is triggered, we need to add it to the top of file?
				return ("idx$(" + this.args().map(function(v) { return v.c(); }).join(',') + ")");
			} else {
				return ("Imba.indexOf(" + this.args().map(function(v) { return v.c(); }).join(',') + ")");
			};
		};
		
		
		Util.Subclass = function Subclass(){ return Util.apply(this,arguments) };
		
		subclass$(Util.Subclass,Util);
		Util.Subclass.prototype.helper = function (){
			// should also check if it is a real promise
			return '// helper for subclassing\nfunction subclass$(obj,sup) {\n	for (var k in sup) {\n		if (sup.hasOwnProperty(k)) obj[k] = sup[k];\n	};\n	// obj.__super__ = sup;\n	obj.prototype = Object.create(sup.prototype);\n	obj.__super__ = obj.prototype.__super__ = sup.prototype;\n	obj.prototype.initialize = obj.prototype.constructor = obj;\n};\n';
		};
		
		Util.Subclass.prototype.js = function (o){
			if (this.isStandalone()) {
				// When this is triggered, we need to add it to the top of file?
				this.scope__().root().helper(this,this.helper());
				return ("subclass$(" + this.args().map(function(v) { return v.c(); }).join(',') + ");\n");
			} else {
				return ("Imba.subclass(" + this.args().map(function(v) { return v.c(); }).join(',') + ");\n");
			};
		};
		
		Util.Promisify = function Promisify(){ return Util.apply(this,arguments) };
		
		subclass$(Util.Promisify,Util);
		Util.Promisify.prototype.helper = function (){
			// should also check if it is a real promise
			return ("function promise$(a)\{ return a instanceof Array ? Promise.all(a) : (a && a.then ? a : Promise.resolve(a)); \}");
		};
		
		Util.Promisify.prototype.js = function (o){
			if (this.isStandalone()) {
				// When this is triggered, we need to add it to the top of file?
				this.scope__().root().helper(this,this.helper());
				return ("promise$(" + this.args().map(function(v) { return v.c(); }).join(',') + ")");
			} else {
				return ("Imba.await(" + this.args().map(function(v) { return v.c(); }).join(',') + ")");
			};
		};
		
		// TODO deprecated: can remove
		Util.Class = function Class(){ return Util.apply(this,arguments) };
		
		subclass$(Util.Class,Util);
		Util.Class.prototype.js = function (o){
			// When this is triggered, we need to add it to the top of file?
			return ("class$(" + this.args().map(function(v) { return v.c(); }).join(',') + ")");
		};
		
		Util.Iterable = function Iterable(){ return Util.apply(this,arguments) };
		
		subclass$(Util.Iterable,Util);
		Util.Iterable.prototype.helper = function (){
			// now we want to allow null values as well - just return as empty collection
			// should be the same for for own of I guess
			return ("function iter$(a)\{ return a ? (a.toArray ? a.toArray() : a) : []; \};");
		};
		
		Util.Iterable.prototype.js = function (o){
			if (this.args()[0] instanceof Arr) { return this.args()[0].c() }; // or if we know for sure that it is an array
			
			if (this.isStandalone()) {
				this.scope__().root().helper(this,this.helper());
				return ("iter$(" + (this.args()[0].c()) + ")");
			} else {
				return ("Imba.iterable(" + (this.args()[0].c()) + ")");
			};
		};
		
		Util.IsFunction = function IsFunction(){ return Util.apply(this,arguments) };
		
		subclass$(Util.IsFunction,Util);
		Util.IsFunction.prototype.js = function (o){
			return ("" + (this.args()[0].c()));
		};
		
		Util.Array = function Array(){ return Util.apply(this,arguments) };
		
		subclass$(Util.Array,Util);
		Util.Array.prototype.js = function (o){
			// When this is triggered, we need to add it to the top of file?
			return ("new Array(" + this.args().map(function(v) { return v.c(); }) + ")");
		};
		
		
		
		
		function Entities(root){
			this._root = root;
			this._map = {};
			return this;
		};
		
		Entities.prototype.add = function (path,object){
			this._map[path] = object;
			return this;
		};
		
		Entities.prototype.register = function (entity){
			var $1;
			var path = entity.namepath();
			this._map[($1 = path)] || (this._map[$1] = entity);
			return this;
		};
		
		Entities.prototype.plain = function (){
			return JSON.parse(JSON.stringify(this._map));
		};
		
		Entities.prototype.toJSON = function (){
			return this._map;
		};
		
		// SCOPES
		
		// handles local variables, self etc. Should create references to outer scopes
		// when needed etc.
		
		// add class for annotations / registering methods, etc?
		// class Interface
		
		// should move the whole context-thingie right into scope
		function Scope(node,parent){
			this._nr = STACK.incr('scopes');
			this._head = [];
			this._node = node;
			this._parent = parent;
			this._vars = new VariableDeclaration([]);
			this._meta = {};
			this._annotations = [];
			this._closure = this;
			this._virtual = false;
			this._counter = 0;
			this._varmap = {};
			this._varpool = [];
		};
		
		exports.Scope = Scope; // export class 
		Scope.prototype.level = function(v){ return this._level; }
		Scope.prototype.setLevel = function(v){ this._level = v; return this; };
		Scope.prototype.context = function(v){ return this._context; }
		Scope.prototype.setContext = function(v){ this._context = v; return this; };
		Scope.prototype.node = function(v){ return this._node; }
		Scope.prototype.setNode = function(v){ this._node = v; return this; };
		Scope.prototype.parent = function(v){ return this._parent; }
		Scope.prototype.setParent = function(v){ this._parent = v; return this; };
		Scope.prototype.varmap = function(v){ return this._varmap; }
		Scope.prototype.setVarmap = function(v){ this._varmap = v; return this; };
		Scope.prototype.varpool = function(v){ return this._varpool; }
		Scope.prototype.setVarpool = function(v){ this._varpool = v; return this; };
		Scope.prototype.params = function(v){ return this._params; }
		Scope.prototype.setParams = function(v){ this._params = v; return this; };
		Scope.prototype.head = function(v){ return this._head; }
		Scope.prototype.setHead = function(v){ this._head = v; return this; };
		Scope.prototype.vars = function(v){ return this._vars; }
		Scope.prototype.setVars = function(v){ this._vars = v; return this; };
		Scope.prototype.counter = function(v){ return this._counter; }
		Scope.prototype.setCounter = function(v){ this._counter = v; return this; };
		
		Scope.prototype.p = function (){
			if (STACK.loglevel() > 0) {
				console.log.apply(console,arguments);
			};
			return this;
		};
		
		Scope.prototype.stack = function (){
			return STACK;
		};
		
		Scope.prototype.meta = function (key,value){
			if (value != undefined) {
				this._meta[key] = value;
				return this;
			};
			return this._meta[key];
		};
		
		Scope.prototype.namepath = function (){
			return '?';
		};
		
		Scope.prototype.tagContextPath = function (){
			// bypassing for now
			return this._tagContextPath || (this._tagContextPath = "tag$"); // parent.tagContextPath
		};
		
		Scope.prototype.context = function (){
			return this._context || (this._context = new ScopeContext(this));
		};
		
		Scope.prototype.traverse = function (){
			return this;
		};
		
		Scope.prototype.visit = function (){
			if (this._parent) { return this };
			// p "visited scope!"
			this._parent = STACK.scope(1); // the parent scope
			this._level = STACK.scopes().length - 1;
			
			// p "parent is",@parent
			STACK.addScope(this);
			this.root().scopes().push(this);
			return this;
		};
		
		Scope.prototype.wrap = function (scope){
			this._parent = scope._parent;
			scope._parent = this;
			return this;
		};
		
		// called for scopes that are not real scopes in js
		// must ensure that the local variables inside of the scopes do not
		// collide with variables in outer scopes -- rename if needed
		Scope.prototype.virtualize = function (){
			return this;
		};
		
		Scope.prototype.root = function (){
			var scope = this;
			while (scope){
				if (scope instanceof RootScope) { return scope };
				scope = scope.parent();
			};
			return null;
		};
		
		Scope.prototype.register = function (name,decl,o){
			// FIXME re-registering a variable should really return the existing one
			// Again, here we should not really have to deal with system-generated vars
			// But again, it is important
			
			// p "registering {name}"
			if(decl === undefined) decl = null;
			if(o === undefined) o = {};
			name = helpers.symbolize(name);
			
			// also look at outer scopes if this is not closed?
			var existing = this._varmap.hasOwnProperty(name) && this._varmap[name];
			if (existing) { return existing };
			
			var item = new Variable(this,name,decl,o);
			// need to check for duplicates, and handle this gracefully -
			// going to refactor later
			if (!o.system) { this._varmap[name] = item }; // dont even add to the varmap if it is a sysvar
			return item;
		};
		
		Scope.prototype.annotate = function (obj){
			this._annotations.push(obj);
			return this;
		};
		
		// just like register, but we automatically 
		Scope.prototype.declare = function (name,init,o){
			var declarator_;
			if(init === undefined) init = null;
			if(o === undefined) o = {};
			var variable = this.register(name,null,o);
			// TODO create the variabledeclaration here instead?
			// if this is a sysvar we need it to be renameable
			var dec = this._vars.add(variable,init);
			(declarator_ = variable.declarator()) || ((variable.setDeclarator(dec),dec));
			return variable;
			
			// p "declare variable {name} {o}"
			// if name isa Variable
			// p "SCOPE declare var".green
			name = helpers.symbolize(name);
			// we will see here
			this._vars.add(name,init); // .last -- 
			var decl = this._vars.last(); // bug(!)
			var item;
			// item = Variable.new(self,name,decl)
			
			// if o:system
			// 	item = SystemVariable.new(self,name,decl,o)
			// 	decl.variable = item
			// else
			item = new Variable(this,name,decl,o);
			decl.setVariable(item);
			item.resolve(); // why on earth should it resolve immediately?
			
			// decl.variable = item
			// item.resolve # why on earth should it resolve immediately?
			return item;
			
			// should be possible to force-declare for this scope, no?
			// if this is a system-variable 
		};
		
		// declares a variable (has no real declaration beforehand)
		
		
		// what are the differences here? omj
		// we only need a temporary thing with defaults -- that is all
		// change these values, no?
		Scope.prototype.temporary = function (refnode,o,name){
			
			// p "registering temporary {refnode} {name}"
			// reuse variables -- hmm
			if(o === undefined) o = {};
			if(name === undefined) name = null;
			if (o.pool) {
				for (var i = 0, ary = iter$(this._varpool), len = ary.length, v; i < len; i++) {
					v = ary[i];
					if (v.pool() == o.pool && v.declarator() == null) {
						return v.reuse(refnode);
					};
				};
			};
			
			// should only 'register' as ahidden variable, no?
			// if there are real nodes inside that tries to refer to vars
			// defined in outer scopes, we need to make sure they are not named after this
			var item = new SystemVariable(this,name,refnode,o);
			this._varpool.push(item); // WHAT? It should not be in the pool unless explicitly put there?
			this._vars.push(item); // WARN variables should not go directly into a declaration-list
			return item;
			// return register(name || "__",null,system: yes, temporary: yes)
		};
		
		
		
		Scope.prototype.lookup = function (name){
			var ret = null;
			name = helpers.symbolize(name);
			if (this._varmap.hasOwnProperty(name)) {
				ret = this._varmap[name];
			} else {
				// look up any parent scope ?? seems okay
				// !isClosed && 
				ret = this.parent() && this.parent().lookup(name);
				// or -- not all scopes have a parent?
			};
			
			// should this not happen by itself?
			// if !ret and 
			//	ret = 
			// ret ||= (g.lookup(name) if var g = root)
			// g = root
			return ret;
		};
		
		Scope.prototype.autodeclare = function (variable){
			return this.vars().push(variable); // only if it does not exist here!!!
		};
		
		Scope.prototype.free = function (variable){
			// p "free variable"
			variable.free(); // :owner = null
			// @varpool.push(variable)
			return this;
		};
		
		Scope.prototype.isClosed = function (){
			return false;
		};
		
		Scope.prototype.closure = function (){
			return this._closure;
		};
		
		Scope.prototype.finalize = function (){
			return this;
		};
		
		Scope.prototype.klass = function (){
			var scope = this;
			while (scope){
				scope = scope.parent();
				if (scope instanceof ClassScope) { return scope };
			};
			return null;
		};
		
		Scope.prototype.head = function (){
			return [this._vars,this._params];
		};
		
		Scope.prototype.c = function (o){
			var body;
			if(o === undefined) o = {};
			o.expression = false;
			// need to fix this
			this.node().body().setHead(this.head());
			return body = this.node().body().c(o);
			
			// var head = [@vars,@params].block.c(expression: no)
			// p "head from scope is ({head})"
			// var out = [head or null,body].flatten__.compact.join("\n")
			// out
			// out = '{' + out + 
		};
		
		Scope.prototype.region = function (){
			return this.node().body().region();
		};
		
		Scope.prototype.loc = function (){
			return this.node().loc();
		};
		
		Scope.prototype.dump = function (){
			var self = this;
			var vars = Object.keys(this._varmap).map(function(k) {
				var v = self._varmap[k];
				return v.references().length ? (dump__(v)) : (null);
			});
			
			var desc = {
				nr: self._nr,
				type: self.constructor.name,
				level: (self.level() || 0),
				vars: compact__(vars),
				loc: self.loc()
			};
			
			return desc;
		};
		
		Scope.prototype.toJSON = function (){
			return this.dump();
		};
		
		Scope.prototype.toString = function (){
			return ("" + (this.constructor.name));
		};
		
		
		// RootScope is wrong? Rather TopScope or ProgramScope
		function RootScope(){
			RootScope.__super__.constructor.apply(this,arguments);
			
			this.register('global',this,{type: 'global'});
			this.register('module',this,{type: 'global'});
			this.register('window',this,{type: 'global'});
			this.register('document',this,{type: 'global'});
			this.register('exports',this,{type: 'global'});
			this.register('console',this,{type: 'global'});
			this.register('process',this,{type: 'global'});
			this.register('parseInt',this,{type: 'global'});
			this.register('parseFloat',this,{type: 'global'});
			this.register('setTimeout',this,{type: 'global'});
			this.register('setInterval',this,{type: 'global'});
			this.register('clearTimeout',this,{type: 'global'});
			this.register('clearInterval',this,{type: 'global'});
			this.register('__dirname',this,{type: 'global'});
			
			// preregister global special variables here
			this._warnings = [];
			this._scopes = [];
			this._helpers = [];
			this._entities = new Entities(this);
			this._head = [this._vars];
		};
		
		subclass$(RootScope,Scope);
		exports.RootScope = RootScope; // export class 
		RootScope.prototype.warnings = function(v){ return this._warnings; }
		RootScope.prototype.setWarnings = function(v){ this._warnings = v; return this; };
		RootScope.prototype.scopes = function(v){ return this._scopes; }
		RootScope.prototype.setScopes = function(v){ this._scopes = v; return this; };
		RootScope.prototype.entities = function(v){ return this._entities; }
		RootScope.prototype.setEntities = function(v){ this._entities = v; return this; };
		
		RootScope.prototype.context = function (){
			return this._context || (this._context = new RootScopeContext(this));
		};
		
		RootScope.prototype.tagContextPath = function (){
			return this._tagContextPath || (this._tagContextPath = "tag$");
		};
		
		RootScope.prototype.lookup = function (name){
			// p "lookup filescope"
			name = helpers.symbolize(name);
			if (this._varmap.hasOwnProperty(name)) { return this._varmap[name] };
		};
		
		RootScope.prototype.visit = function (){
			STACK.addScope(this);
			return this;
		};
		
		RootScope.prototype.helper = function (typ,value){
			// log "add helper",typ,value
			if (this._helpers.indexOf(value) == -1) {
				this._helpers.push(value);
				this._head.unshift(value);
			};
			
			return this;
		};
		
		RootScope.prototype.head = function (){
			return this._head;
		};
		
		RootScope.prototype.warn = function (data){
			// hacky
			data.node = null;
			// p "warning",JSON.stringify(data)
			this._warnings.push(data);
			return this;
		};
		
		RootScope.prototype.dump = function (){
			var obj = {warnings: dump__(this._warnings)};
			
			if (OPTS.analysis.scopes) {
				var scopes = this._scopes.map(function(s) { return s.dump(); });
				scopes.unshift(RootScope.__super__.dump.call(this));
				obj.scopes = scopes;
			};
			
			if (OPTS.analysis.entities) {
				obj.entities = this._entities;
			};
			
			return obj;
		};
		
		
		function ClassScope(){ return Scope.apply(this,arguments) };
		
		subclass$(ClassScope,Scope);
		exports.ClassScope = ClassScope; // export class 
		ClassScope.prototype.namepath = function (){
			return this._node.namepath();
		};
		
		
		// called for scopes that are not real scopes in js
		// must ensure that the local variables inside of the scopes do not
		// collide with variables in outer scopes -- rename if needed
		ClassScope.prototype.virtualize = function (){
			// console.log "virtualizing ClassScope"
			var up = this.parent();
			for (var o = this._varmap, i = 0, keys = Object.keys(o), l = keys.length; i < l; i++){
				true;
				o[keys[i]].resolve(up,true); // force new resolve
			};
			return this;
		};
		
		ClassScope.prototype.isClosed = function (){
			return true;
		};
		
		function TagScope(){ return ClassScope.apply(this,arguments) };
		
		subclass$(TagScope,ClassScope);
		exports.TagScope = TagScope; // export class 
		
		
		function ClosureScope(){ return Scope.apply(this,arguments) };
		
		subclass$(ClosureScope,Scope);
		exports.ClosureScope = ClosureScope; // export class 
		
		
		function FunctionScope(){ return Scope.apply(this,arguments) };
		
		subclass$(FunctionScope,Scope);
		exports.FunctionScope = FunctionScope; // export class 
		
		
		function MethodScope(){ return Scope.apply(this,arguments) };
		
		subclass$(MethodScope,Scope);
		exports.MethodScope = MethodScope; // export class 
		MethodScope.prototype.isClosed = function (){
			return true;
		};
		
		function LambdaScope(){ return Scope.apply(this,arguments) };
		
		subclass$(LambdaScope,Scope);
		exports.LambdaScope = LambdaScope; // export class 
		LambdaScope.prototype.context = function (){
			
			// when accessing the outer context we need to make sure that it is cached
			// so this is wrong - but temp okay
			return this._context || (this._context = this.parent().context().reference(this));
		};
		
		function FlowScope(){ return Scope.apply(this,arguments) };
		
		subclass$(FlowScope,Scope);
		exports.FlowScope = FlowScope; // export class 
		FlowScope.prototype.params = function (){
			if (this._parent) { return this._parent.params() };
		};
		
		FlowScope.prototype.register = function (name,decl,o){
			var found;
			if(decl === undefined) decl = null;
			if(o === undefined) o = {};
			if (o.type != 'let' && (this.closure() != this)) {
				if (found = this.lookup(name)) {
					// p "already found variable {found.type}"
					if (found.type() == 'let') {
						this.p(("" + name + " already exists as a block-variable " + decl));
						// TODO should throw error instead
						if (decl) { decl.warn("Variable already exists in block") };
						// root.warn message: "Holy shit"
					};
					// if found.
				};
				// p "FlowScope register var -- do it right in the outer scope"
				return this.closure().register(name,decl,o);
			} else {
				// p "Register local variable for FlowScope {name}"
				// o:closure = parent
				// p "FlowScope register", arguments
				return FlowScope.__super__.register.call(this,name,decl,o);
			};
		};
		
		// FIXME should override temporary as well
		
		FlowScope.prototype.autodeclare = function (variable){
			return this.parent().autodeclare(variable);
		};
		
		FlowScope.prototype.closure = function (){
			// rather all the way?
			return this._parent.closure(); // this is important?
		};
		
		FlowScope.prototype.context = function (){
			// if we are wrapping in an expression - we do need to add a reference
			// @referenced = yes
			return this.parent().context();
			// usually - if the parent scope is a closed scope we dont really need
			// to force a reference
			// @context ||= parent.context.reference(self)
		};
		
		function CatchScope(){ return FlowScope.apply(this,arguments) };
		
		subclass$(CatchScope,FlowScope);
		exports.CatchScope = CatchScope; // export class 
		
		
		function WhileScope(){ return FlowScope.apply(this,arguments) };
		
		subclass$(WhileScope,FlowScope);
		exports.WhileScope = WhileScope; // export class 
		WhileScope.prototype.autodeclare = function (variable){
			return this.vars().push(variable);
		};
		
		function ForScope(){ return FlowScope.apply(this,arguments) };
		
		subclass$(ForScope,FlowScope);
		exports.ForScope = ForScope; // export class 
		ForScope.prototype.autodeclare = function (variable){
			return this.vars().push(variable);
			// parent.autodeclare(variable)
		};
		
		// def closure
		// 	self
		;
		
		function IfScope(){ return FlowScope.apply(this,arguments) };
		
		subclass$(IfScope,FlowScope);
		exports.IfScope = IfScope; // export class 
		IfScope.prototype.temporary = function (refnode,o,name){
			if(o === undefined) o = {};
			if(name === undefined) name = null;
			return this.parent().temporary(refnode,o,name);
		};
		
		function BlockScope(){ return FlowScope.apply(this,arguments) };
		
		subclass$(BlockScope,FlowScope);
		exports.BlockScope = BlockScope; // export class 
		BlockScope.prototype.temporary = function (refnode,o,name){
			if(o === undefined) o = {};
			if(name === undefined) name = null;
			return this.parent().temporary(refnode,o,name);
		};
		
		BlockScope.prototype.region = function (){
			return this.node().region();
		};
		
		// lives in scope -- really a node???
		function Variable(scope,name,decl,o){
			this._ref = STACK._counter++;
			this._c = null;
			this._scope = scope;
			this._name = name;
			this._alias = null;
			this._initialized = true;
			this._declarator = decl;
			this._autodeclare = false;
			this._declared = o && o.declared || false;
			this._resolved = false;
			this._options = o || {};
			this._type = o && o.type || 'var'; // what about let here=
			this._export = false;
			this._references = []; // only needed when profiling
			this._assignments = [];
			this;
		};
		
		subclass$(Variable,Node);
		exports.Variable = Variable; // export class 
		Variable.prototype.scope = function(v){ return this._scope; }
		Variable.prototype.setScope = function(v){ this._scope = v; return this; };
		Variable.prototype.name = function(v){ return this._name; }
		Variable.prototype.setName = function(v){ this._name = v; return this; };
		Variable.prototype.alias = function(v){ return this._alias; }
		Variable.prototype.setAlias = function(v){ this._alias = v; return this; };
		Variable.prototype.type = function(v){ return this._type; }
		Variable.prototype.setType = function(v){ this._type = v; return this; };
		Variable.prototype.options = function(v){ return this._options; }
		Variable.prototype.setOptions = function(v){ this._options = v; return this; };
		Variable.prototype.initialized = function(v){ return this._initialized; }
		Variable.prototype.setInitialized = function(v){ this._initialized = v; return this; };
		Variable.prototype.declared = function(v){ return this._declared; }
		Variable.prototype.setDeclared = function(v){ this._declared = v; return this; };
		Variable.prototype.declarator = function(v){ return this._declarator; }
		Variable.prototype.setDeclarator = function(v){ this._declarator = v; return this; };
		Variable.prototype.autodeclare = function(v){ return this._autodeclare; }
		Variable.prototype.setAutodeclare = function(v){ this._autodeclare = v; return this; };
		Variable.prototype.references = function(v){ return this._references; }
		Variable.prototype.setReferences = function(v){ this._references = v; return this; };
		Variable.prototype.export = function(v){ return this._export; }
		Variable.prototype.setExport = function(v){ this._export = v; return this; };
		
		Variable.prototype.pool = function (){
			return null;
		};
		
		Variable.prototype.closure = function (){
			return this._scope.closure();
		};
		
		Variable.prototype.assignments = function (){
			return this._assignments;
		};
		
		// Here we can collect lots of type-info about variables
		// and show warnings / give advice if variables are ambiguous etc
		Variable.prototype.assigned = function (val,source){
			this._assignments.push(val);
			// p "Variable was assigned {val}"
			if (val instanceof Arr) {
				// just for testing really
				this._isArray = true;
			} else {
				this._isArray = false;
			};
			return this;
		};
		
		Variable.prototype.resolve = function (scope,force){
			if(scope === undefined) scope = this.scope();
			if(force === undefined) force = false;
			if (this._resolved && !(force)) { return this };
			
			this._resolved = true;
			var closure = this._scope.closure();
			var item = scope.lookup(this._name);
			
			// if this is a let-definition inside a virtual scope we do need
			// 
			if (this._scope != closure && this._type == 'let') { // or if it is a system-variable
				// p "scope is not the closure -- need to resolve {@name}"
				item = closure.lookup(this._name);
				
				// we now need to ensure that this variable is unique inside
				// the whole closure.
				scope = closure;
			};
			
			// p "scope is not the closure -- need to resolve {@name} {@type}"
			
			if (item == this) {
				scope.varmap()[this._name] = this;
				return this;
			} else if (item) {
				// p "variable already exists {@name}"
				
				// possibly redefine this inside, use it only in this scope
				// if the item is defined in an outer scope - we reserve the
				if (item.scope() != scope && (this.options().let || this._type == 'let')) {
					// p "override variable inside this scope {@name}"
					scope.varmap()[this._name] = this;
				};
				
				// different rules for different variables?
				if (this._options.proxy) {
					// p "is proxy -- no need to change name!!! {name}".cyan
					true;
				} else {
					var i = 0;
					var orig = this._name;
					// it is the closure that we should use
					while (scope.lookup(this._name)){
						this._name = ("" + orig + (i += 1));
					};
				};
			};
			
			// inefficient double setting
			scope.varmap()[this._name] = this;
			closure.varmap()[this._name] = this;
			return this;
			// p "resolve variable".cyan
		};
		
		Variable.prototype.reference = function (){
			return this;
		};
		
		Variable.prototype.node = function (){
			return this;
		};
		
		Variable.prototype.traverse = function (){
			// NODES.push(self)
			return this;
		};
		
		Variable.prototype.free = function (ref){
			// p "free variable!"
			this._declarator = null;
			return this;
		};
		
		Variable.prototype.reuse = function (ref){
			this._declarator = ref;
			return this;
		};
		
		Variable.prototype.proxy = function (par,index){
			this._proxy = [par,index];
			return this;
		};
		
		Variable.prototype.refcount = function (){
			return this._references.length;
		};
		
		Variable.prototype.c = function (){
			if (this._c) { return this._c };
			// options - proxy??
			if (this._proxy) {
				// p "var is proxied!",@proxy
				this._c = this._proxy[0].c() + '[' + this._proxy[1].c() + ']';
			} else {
				if (!this._resolved) this.resolve();
				var v = (this.alias() || this.name());
				this._c = typeof v == 'string' ? (v) : (v.c());
				// allow certain reserved words
				// should warn on others though (!!!)
				// if @c == 'new'
				// 	@c = '_new'
				// 	# should happen at earlier stage to
				// 	# get around naming conventions
				if (RESERVED_REGEX.test(this._c)) { this._c = ("" + this.c() + "$") }; // @c.match(/^(default)$/)
			};
			return this._c;
		};
		
		// variables should probably inherit from node(!)
		Variable.prototype.consume = function (node){
			// p "variable assignify!!!"
			return this;
		};
		
		// this should only generate the accessors - not dael with references
		Variable.prototype.accessor = function (ref){
			var node = new LocalVarAccess(".",null,this); // this is just wrong .. should not be a regular accessor
			// @references.push([ref,el]) if ref # weird temp format
			return node;
		};
		
		Variable.prototype.assignment = function (val){
			return new Assign('=',this,val);
		};
		
		Variable.prototype.addReference = function (ref){
			if (ref instanceof Identifier) {
				ref.references(this);
			};
			
			if (ref.region && ref.region()) {
				this._references.push(ref);
			};
			
			// p "reference is {ref:region and ref.region}"
			return this;
		};
		
		Variable.prototype.autodeclare = function (){
			if (this._declared) { return this };
			// p "variable should autodeclare(!) {name}"
			this._autodeclare = true;
			this.scope().autodeclare(this);
			this._declared = true;
			return this;
		};
		
		Variable.prototype.predeclared = function (){
			this._declared = true;
			return this;
		};
		
		
		Variable.prototype.toString = function (){
			return String(this.name());
		};
		
		Variable.prototype.dump = function (typ){
			var name = this.name();
			if (name[0].match(/[A-Z]/)) { return null };
			// console.log "dump variable of type {type} - {name}"
			return {
				type: this.type(),
				name: name,
				refs: dump__(this._references,typ)
			};
		};
		
		
		function SystemVariable(){ return Variable.apply(this,arguments) };
		
		subclass$(SystemVariable,Variable);
		exports.SystemVariable = SystemVariable; // export class 
		SystemVariable.prototype.pool = function (){
			return this._options.pool;
		};
		
		// weird name for this
		SystemVariable.prototype.predeclared = function (){
			// p "remove var from scope(!)"
			this.scope().vars().remove(this);
			return this;
		};
		
		SystemVariable.prototype.resolve = function (){
			var alias, v_;
			if (this._resolved || this._name) { return this };
			// p "RESOLVE SYSTEM VARIABLE".red
			this._resolved = true;
			// unless @name
			// adds a very random initial name
			// the auto-magical goes last, or at least, possibly reuse other names
			// "${Math.floor(Math.random * 1000)}"
			
			var typ = this._options.pool;
			var names = [].concat(this._options.names);
			var alt = null;
			var node = null;
			
			var scope = this.scope();
			
			if (typ == 'tag') {
				var i = 0;
				while (!this._name){
					alt = ("t" + (i++));
					if (!scope.lookup(alt)) { this._name = alt };
				};
			} else if (typ == 'iter') {
				names = ['ary__','ary_','coll','array','items','ary'];
			} else if (typ == 'val') {
				names = ['v_'];
			} else if (typ == 'arguments') {
				names = ['$_','$0'];
			} else if (typ == 'keypars') {
				names = ['opts','options','pars'];
			} else if (typ == 'counter') {
				names = ['i__','i_','k','j','i'];
			} else if (typ == 'len') {
				names = ['len__','len_','len'];
			} else if (typ == 'list') {
				names = ['tmplist_','tmplist','tmp'];
			};
			// or if type placeholder / cacher (add 0)
			
			while (!this._name && (alt = names.pop())){
				if (!scope.lookup(alt)) { this._name = alt };
			};
			
			if (!this._name && this._declarator) {
				if (node = this.declarator().node()) {
					if (alias = node.alias()) { names.push(alias + "_") };
				};
			};
			
			while (!this._name && (alt = names.pop())){
				if (!scope.lookup(alt)) { this._name = alt };
			};
			
			// p "suggested names {names.join(" , ")} {node}".cyan
			//  Math.floor(Math.random * 1000)
			this._name || (this._name = ("$" + (scope.setCounter(v_ = scope.counter() + 1),v_)));
			// p "name for variable is {@name}"
			scope.varmap()[this._name] = this;
			return this;
		};
		
		SystemVariable.prototype.name = function (){
			this.resolve();
			return this._name;
		};
		
		
		function ScopeContext(scope,value){
			this._scope = scope;
			this._value = value;
			this._reference = null;
			this;
		};
		
		subclass$(ScopeContext,Node);
		exports.ScopeContext = ScopeContext; // export class 
		ScopeContext.prototype.scope = function(v){ return this._scope; }
		ScopeContext.prototype.setScope = function(v){ this._scope = v; return this; };
		ScopeContext.prototype.value = function(v){ return this._value; }
		ScopeContext.prototype.setValue = function(v){ this._value = v; return this; };
		
		ScopeContext.prototype.namepath = function (){
			return this._scope.namepath();
		};
		
		// instead of all these references we should probably
		// just register when it is accessed / looked up from
		// a deeper function-scope, and when it is, we should
		// register the variable in scope, and then start to
		// use that for further references. Might clean things
		// up for the cases where we have yet to decide the
		// name of the variable etc?
		
		ScopeContext.prototype.reference = function (){
			// p "p reference {STACK.scoping}"
			// should be a special context-variable!!!
			return this._reference || (this._reference = this.scope().declare("self",new This()));
		};
		
		ScopeContext.prototype.c = function (){
			var val = this._value || this._reference;
			return val ? (val.c()) : ("this");
		};
		
		ScopeContext.prototype.cache = function (){
			return this;
		};
		
		function RootScopeContext(){ return ScopeContext.apply(this,arguments) };
		
		subclass$(RootScopeContext,ScopeContext);
		exports.RootScopeContext = RootScopeContext; // export class 
		RootScopeContext.prototype.c = function (o){
			// return "" if o and o:explicit
			var val = this._value || this._reference;
			return (val && val != this) ? (val.c()) : ("this");
			// should be the other way around, no?
			// o and o:explicit ? super : ""
		};
		
		function Super(){ return Node.apply(this,arguments) };
		
		subclass$(Super,Node);
		exports.Super = Super; // export class 
		Super.prototype.c = function (){
			// need to find the stuff here
			// this is really not that good8
			var m = STACK.method();
			var out = null;
			var up = STACK.current();
			var deep = (up instanceof Access);
			
			// TODO optimization for later - problematic if there is a different reference in the end
			if (false) {
				out = ("" + (m.target().c()) + ".superclass");
				if (!(deep)) { out += (".apply(" + (m.scope().context().c()) + ",arguments)") };
			} else {
				out = ("" + (m.target().c()) + ".__super__");
				if (!((up instanceof Access))) {
					out += ("." + c__(m.supername()));
					if (!((up instanceof Call))) { // autocall?
						out += (".apply(" + (m.scope().context().c()) + ",arguments)");
					};
				};
			};
			return out;
		};
		
		// constants
		
		module.exports.BR = BR = new Newline('\n');
		module.exports.BR2 = BR2 = new Newline('\n\n');
		module.exports.SELF = SELF = new Self();
		module.exports.SUPER = SUPER = new Super();
		
		module.exports.TRUE = TRUE = new True('true');
		module.exports.FALSE = FALSE = new False('false');
		module.exports.UNDEFINED = UNDEFINED = new Undefined();
		module.exports.NIL = NIL = new Nil();
		
		module.exports.ARGUMENTS = ARGUMENTS = new ArgsReference('arguments');
		module.exports.EMPTY = EMPTY = '';
		module.exports.NULL = NULL = 'null';
		
		module.exports.RESERVED = RESERVED = ['default','native','enum','with'];
		module.exports.RESERVED_REGEX = RESERVED_REGEX = /^(default|native|enum|with|new|char)$/;
		
		module.exports.UNION = UNION = new Const('union$');
		module.exports.INTERSECT = INTERSECT = new Const('intersect$');
		module.exports.CLASSDEF = CLASSDEF = new Const('imba$class');
		module.exports.TAGDEF = TAGDEF = new Const('Imba.TAGS.define');
		return module.exports.NEWTAG = NEWTAG = new Identifier("tag$");
		
		
		
		
		
		
		
		
		
		

	})()

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		
		var path = __webpack_require__(11);
		var util = __webpack_require__(3);
		
		function SourceMap(source){
			this._source = source;
			this._maps = [];
			this._map = "";
			this._js = "";
		};
		
		exports.SourceMap = SourceMap; // export class 
		SourceMap.prototype.source = function (){
			return this._source;
		};
		
		SourceMap.prototype.options = function (){
			return this._source;
		};
		
		SourceMap.prototype.filename = function (){
			return this.options().options.filename;
		};
		
		SourceMap.prototype.sourceCode = function (){
			return this.options().options._source;
		};
		
		SourceMap.prototype.targetPath = function (){
			return this.options().options.targetPath;
		};
		
		SourceMap.prototype.sourcePath = function (){
			return this.options().options.sourcePath;
		};
		
		SourceMap.prototype.sourceName = function (){
			return path.basename(this.sourcePath());
		};
		
		SourceMap.prototype.targetName = function (){
			return path.basename(this.targetPath());
		};
		
		
		SourceMap.prototype.sourceFiles = function (){
			return [this.sourceName()];
		};
		
		SourceMap.prototype.parse = function (){
			var self = this;
			var matcher = /\%\$(\d*)\$\%/;
			var replacer = /^(.*?)\%\$(\d*)\$\%/;
			var lines = this.options().js.split(/\n/g); // what about js?
			// return self
			var locmap = util.locationToLineColMap(this.sourceCode());
			this._maps = [];
			
			// console.log options:js
			
			var match;
			// split the code in lines. go through each line 
			// go through the code looking for LOC markers
			// remove markers along the way and keep track of
			// console.log source:js
			
			for (var i = 0, ary = iter$(lines), len = ary.length, line; i < len; i++) {
				// could split on these?
				line = ary[i];
				var col = 0;
				var caret = 0;
				
				this._maps[i] = [];
				while (line.match(matcher)){
					line = line.replace(replacer,function(m,pre,loc) {
						var lc = locmap[parseInt(loc)];
						caret = pre.length;
						var mapping = [[lc[0],lc[1]],[i,caret]]; // source and output
						self._maps[i].push(mapping);
						return pre;
					});
				};
				lines[i] = line;
			};
			
			
			self.source().js = lines.join('\n');
			return self;
		};
		
		SourceMap.prototype.generate = function (){
			this.parse();
			
			var lastColumn = 0;
			var lastSourceLine = 0;
			var lastSourceColumn = 0;
			var buffer = "";
			
			for (var lineNumber = 0, ary = iter$(this._maps), len = ary.length; lineNumber < len; lineNumber++) {
				lastColumn = 0;
				
				for (var nr = 0, items = iter$(ary[lineNumber]), len_ = items.length, map1; nr < len_; nr++) {
					map1 = items[nr];
					if (nr != 0) { buffer += ',' };
					var src = map1[0];
					var dest = map1[1];
					
					buffer += this.encodeVlq(dest[1] - lastColumn);
					lastColumn = dest[1];
					// add index
					buffer += this.encodeVlq(0);
					
					// The starting line in the original source, relative to the previous source line.
					buffer += this.encodeVlq(src[0] - lastSourceLine);
					lastSourceLine = src[0];
					// The starting column in the original source, relative to the previous column.
					buffer += this.encodeVlq(src[1] - lastSourceColumn);
					lastSourceColumn = src[1];
				};
				
				buffer += ";";
			};
			
			
			var rel = path.relative(path.dirname(this.targetPath()),this.sourcePath());
			
			var map = {
				version: 3,
				file: this.sourceName().replace(/\.imba/,'.js') || '',
				sourceRoot: this.options().sourceRoot || '',
				sources: [rel],
				sourcesContent: [this.sourceCode()],
				names: [],
				mappings: buffer
			};
			
			// source:sourcemap = sourcemap
			// var base64 = Buffer.new(JSON.stringify(map)).toString("base64")
			// source:js += "\n//# sourceMappingURL=data:application/json;base64,{base64}"
			return map;
		};
		
		VLQ_SHIFT = 5;
		VLQ_CONTINUATION_BIT = 1 << VLQ_SHIFT;
		VLQ_VALUE_MASK = VLQ_CONTINUATION_BIT - 1;
		BASE64_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
		
		// borrowed from CoffeeScript
		SourceMap.prototype.encodeVlq = function (value){
			var answer = '';
			// Least significant bit represents the sign.
			var signBit = value < 0 ? (1) : (0);
			var nextChunk;
			// The next bits are the actual value.
			var valueToEncode = (Math.abs(value) << 1) + signBit;
			// Make sure we encode at least one character, even if valueToEncode is 0.
			while (valueToEncode || !(answer)){
				nextChunk = valueToEncode & VLQ_VALUE_MASK;
				valueToEncode = valueToEncode >> VLQ_SHIFT;
				if (valueToEncode) {
					nextChunk |= VLQ_CONTINUATION_BIT;
				};
				
				answer += this.encodeBase64(nextChunk);
			};
			
			return answer;
		};
		
		SourceMap.prototype.encodeBase64 = function (value){
			return BASE64_CHARS[value]; // or throw Error.new("Cannot Base64 encode value: {value}")
		};
		return SourceMap;
		
		

	})()

/***/ },
/* 11 */
/***/ function(module, exports) {



/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgN2UzMDUwOTYyYThkZWIwZGM0YmYiLCJ3ZWJwYWNrOi8vL3NyYy9jb21waWxlci9jb21waWxlci5pbWJhIiwid2VicGFjazovLy9zcmMvY29tcGlsZXIvdG9rZW4uaW1iYSIsIndlYnBhY2s6Ly8vc3JjL2NvbXBpbGVyL2Vycm9ycy5pbWJhIiwid2VicGFjazovLy9zcmMvY29tcGlsZXIvaGVscGVycy5pbWJhIiwid2VicGFjazovLy9zcmMvY29tcGlsZXIvbGV4ZXIuaW1iYSIsIndlYnBhY2s6Ly8vc3JjL2NvbXBpbGVyL3Jld3JpdGVyLmltYmEiLCJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBpbGVyL3BhcnNlci5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovLy8od2VicGFjaykvfi9ub2RlLWxpYnMtYnJvd3Nlci9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vc3JjL2NvbXBpbGVyL25vZGVzLmltYmEiLCJ3ZWJwYWNrOi8vL3NyYy9jb21waWxlci9zb3VyY2VtYXAuaW1iYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7O21CQ3hCVzs7O01BWlAsRUFBRSxFQUFFO01BQ0osSUFBSSxFQUFFO01BQ04sS0FBSyxFQUFFO01BQ1AsTUFBTSxFQUFFO01BQ1IsU0FBUyxFQUFFO2lDQUNHLEVBQUU7TUFDaEIsSUFBSSxFQUFFOzs4Q0FFSDs7OzJCQUdRLE9BQUUsTUFBTTtpQkFDWixvQkFBUyxFQUFFLFNBQVM7O0VBRS9CLE9BQU8sTUFBTSxFQUFFLElB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF1QyxhQUFhO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBNkIsYUFBYTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0lBQ2hDLGNBQWMsRUFBRSxjQUFjLEdBQUc7SUFDakMsSUFBRztLQUNGLFVBQVUsR0FBRzs7O0lBRWQsT0FBTyxRQUFHLGFBQWE7OztVQUV4Qjs7O0VBRUQ7VUFDQyxhQUFhOztTQS9JRiIsImZpbGUiOiIuL2Rpc3QvaW1iYWMuZGV2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGlkOiBtb2R1bGVJZCxcbiBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiB3ZWJwYWNrL2Jvb3RzdHJhcCA3ZTMwNTA5NjJhOGRlYjBkYzRiZlxuICoqLyIsIlxuIyB2YXIgaW1iYSA9IHJlcXVpcmUgJy4uL2ltYmEnXG52YXIgVCA9IHJlcXVpcmUgJy4vdG9rZW4nXG52YXIgRVJSID0gcmVxdWlyZSAnLi9lcnJvcnMnXG52YXIgdXRpbCA9IHJlcXVpcmUgJy4vaGVscGVycydcbnZhciBsZXhlciA9IHJlcXVpcmUgJy4vbGV4ZXInXG52YXIgcmV3cml0ZXIgPSByZXF1aXJlICcuL3Jld3JpdGVyJ1xuZXhwb3J0IHZhciBwYXJzZXIgPSByZXF1aXJlKCcuLi8uLi9saWIvY29tcGlsZXIvcGFyc2VyJylbJ3BhcnNlciddXG52YXIgYXN0ID0gcmVxdWlyZSAnLi9ub2RlcydcblxuaW1wb3J0IEltYmFQYXJzZUVycm9yIGZyb20gJy4vZXJyb3JzJ1xuXG4jIEluc3RhbnRpYXRlIGEgTGV4ZXIgZm9yIG91ciB1c2UgaGVyZS5cbmV4cG9ydCB2YXIgbGV4ID0gbGV4ZXIuTGV4ZXIubmV3XG5leHBvcnQgdmFyIFJld3JpdGVyID0gcmV3cml0ZXIuUmV3cml0ZXJcblxucGFyc2VyOmxleGVyID0gbGV4Lmppc29uQnJpZGdlXG5wYXJzZXI6eXkgPSBhc3QgIyBldmVyeXRoaW5nIGlzIGV4cG9ydGVkIHJpZ2h0IGhlcmUgbm93XG5cblxuZXhwb3J0IGRlZiB0b2tlbml6ZSBjb2RlLCBvID0ge31cblx0dHJ5XG5cdFx0by5Ac291cmNlID0gY29kZVxuXHRcdGxleC5yZXNldFxuXHRcdGxleC50b2tlbml6ZSBjb2RlLCBvXG5cdGNhdGNoIGVyclxuXHRcdHRocm93IGVyclxuXG5leHBvcnQgZGVmIHJld3JpdGUgdG9rZW5zLCBvID0ge31cblx0dmFyIHJld3JpdGVyID0gUmV3cml0ZXIubmV3XG5cdHRyeVxuXHRcdHJld3JpdGVyLnJld3JpdGUgdG9rZW5zLCBvXG5cdGNhdGNoIGVyclxuXHRcdHRocm93IGVyclxuXG5cbmV4cG9ydCBkZWYgcGFyc2UgY29kZSwgbyA9IHt9XG5cdHZhciB0b2tlbnMgPSBjb2RlIGlzYSBBcnJheSA/IGNvZGUgOiB0b2tlbml6ZShjb2RlLG8pXG5cdHRyeVxuXHRcdCMgY29uc29sZS5sb2coXCJUb2tlbnNcIix0b2tlbnMpXG5cdFx0by5Ac291cmNlIHx8PSBjb2RlIGlmIHRva2VucyAhPSBjb2RlXG5cdFx0by5AdG9rZW5zID0gdG9rZW5zXG5cdFx0cmV0dXJuIHBhcnNlci5wYXJzZSB0b2tlbnNcblx0Y2F0Y2ggZXJyXG5cdFx0ZXJyOl9maWxlbmFtZSA9IG86ZmlsZW5hbWUgaWYgbzpmaWxlbmFtZVxuXHRcdHRocm93IGVyclxuXG5cbmV4cG9ydCBkZWYgY29tcGlsZSBjb2RlLCBvID0ge31cblx0dHJ5XG5cdFx0dmFyIHRva2VucyA9IHRva2VuaXplKGNvZGUsIG8pXG5cdFx0dmFyIGFzdCA9IHBhcnNlKHRva2Vucywgbylcblx0XHRyZXR1cm4gYXN0LmNvbXBpbGUobylcblx0Y2F0Y2ggZXJyXG5cdFx0ZXJyOl9maWxlbmFtZSA9IG86ZmlsZW5hbWUgaWYgbzpmaWxlbmFtZVxuXHRcdHRva2VucyB8fD0gby5AdG9rZW5zXG5cblx0XHRpZiB0b2tlbnMgJiYgZXJyIGlzYSBJbWJhUGFyc2VFcnJvclxuXHRcdFx0dHJ5XG5cdFx0XHRcdHZhciB0b2sgPSBlcnIuc3RhcnRcblx0XHRcdGNhdGNoIGVcblx0XHRcdFx0dGhyb3cgZXJyXG5cblx0XHRcdHZhciBsb2NtYXAgPSB1dGlsLmxvY2F0aW9uVG9MaW5lQ29sTWFwKGNvZGUpXG5cdFx0XHR2YXIgbGluZXMgID0gY29kZS5zcGxpdCgvXFxuL2cpXG5cblx0XHRcdHZhciBsYyA9IGxvY21hcFt0b2suQGxvY10gb3IgWzAsMF1cblx0XHRcdHZhciBsbiA9IGxjWzBdXG5cdFx0XHR2YXIgY29sID0gbGNbMV1cblx0XHRcdHZhciBsaW5lID0gbGluZXNbbG5dXG5cblx0XHRcdHZhciBtZXNzYWdlID0gZXJyOm1lc3NhZ2UgKyBcIlxcblxcbntsbn1cIiArIFwiXFxue2xuICsgMX0ge2xpbmV9XCIgKyBcIlxcbntsbiArIDJ9XCJcblx0XHRcdHZhciByZWR1Y2VyID0gZG8gfHMsYyxpfFxuXHRcdFx0XHRzICs9IGkgPT0gY29sID8gXCJeXCIgOiAoYyA9PSBcIlxcdFwiID8gYyA6IFwiIFwiKVxuXHRcdFx0bWVzc2FnZSArPSBsaW5lLnNwbGl0KCcnKS5yZWR1Y2UocmVkdWNlciwgXCJcIilcblxuXHRcdFx0ZXJyOm1lc3NhZ2UgPSBtZXNzYWdlXG5cdFx0dGhyb3cgZXJyXG5cbmV4cG9ydCBkZWYgYW5hbHl6ZSBjb2RlLCBvID0ge31cblx0dmFyIG1ldGFcblx0dHJ5XG5cdFx0dmFyIGFzdCA9IHBhcnNlKGNvZGUsbylcblx0XHRtZXRhID0gYXN0LmFuYWx5emUobylcblx0Y2F0Y2ggZVxuXHRcdCMgY29uc29sZS5sb2cgXCJzb21ldGhpbmcgd3Jvbmcge2U6bWVzc2FnZX1cIlxuXHRcdHVubGVzcyBlIGlzYSBJbWJhUGFyc2VFcnJvclxuXHRcdFx0aWYgZTpsZXhlclxuXHRcdFx0XHRlID0gSW1iYVBhcnNlRXJyb3IubmV3KGUsIHRva2VuczogZTpsZXhlcjp0b2tlbnMsIHBvczogZTpsZXhlcjpwb3MpXG5cdFx0XHRlbHNlXG5cdFx0XHRcdHRocm93IGVcblx0XHRtZXRhID0ge3dhcm5pbmdzOiBbZV19XG5cdHJldHVybiBtZXRhXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBzcmMvY29tcGlsZXIvY29tcGlsZXIuaW1iYVxuICoqLyIsIlxuXG5leHBvcnQgdmFyIFRPSyA9IHt9XG52YXIgVFRFUk1JTkFUT1IgPSBUT0suVEVSTUlOQVRPUiA9IDFcbnZhciBUSURFTlRJRklFUiA9IFRPSy5JREVOVElGSUVSID0gMlxudmFyIFRJREVOVElGSUVSID0gVE9LLklWQVIgPSAyXG52YXIgQ09OU1QgPSBUT0suQ09OU1QgPSAzXG52YXIgVkFSID0gVE9LLlZBUiA9IDRcbnZhciBJRiA9IFRPSy5JRiA9IDVcbnZhciBFTFNFID0gVE9LLkVMU0UgPSA2XG52YXIgREVGID0gVE9LLkRFRiA9IDdcblxuXG5cbmV4cG9ydCBjbGFzcyBUb2tlblxuXG5cdGRlZiBpbml0aWFsaXplIHR5cGUsIHZhbHVlLCBsb2MsIGxlblxuXHRcdEB0eXBlICA9IHR5cGVcblx0XHRAdmFsdWUgPSB2YWx1ZVxuXHRcdEBsb2MgICA9IGxvYyAhPSBudWxsID8gbG9jIDogLTFcblx0XHRAbGVuICAgPSBsZW4gb3IgMFxuXHRcdEBtZXRhICA9IG51bGxcblx0XHR0aGlzOmdlbmVyYXRlZCA9IG5vXG5cdFx0dGhpczpuZXdMaW5lID0gbm9cblx0XHR0aGlzOnNwYWNlZCA9IG5vXG5cdFx0cmV0dXJuIHNlbGZcblxuXHRkZWYgdHlwZVxuXHRcdEB0eXBlXG5cblx0ZGVmIHZhbHVlXG5cdFx0QHZhbHVlXG5cblx0ZGVmIHRyYXZlcnNlXG5cdFx0cmV0dXJuXG5cdFx0XG5cdGRlZiBjXG5cdFx0XCJcIiArIEB2YWx1ZVxuXG5cdGRlZiB0b1N0cmluZ1xuXHRcdEB2YWx1ZVxuXG5cdGRlZiBjaGFyQXQgaVxuXHRcdEB2YWx1ZS5jaGFyQXQoaSlcblxuXHRkZWYgc2xpY2UgaVxuXHRcdEB2YWx1ZS5zbGljZShpKVxuXG5cdGRlZiByZWdpb25cblx0XHRbQGxvYyxAbG9jICsgKEBsZW4gb3IgQHZhbHVlOmxlbmd0aCldXG5cblx0ZGVmIHNvdXJjZU1hcE1hcmtlclxuXHRcdEBsb2MgPT0gLTEgPyAnOicgOiBcIiUke0Bsb2N9JCVcIlxuXHRcdCMgQGNvbCA9PSAtMSA/ICcnIDogXCIlJXtAbGluZX0ke0Bjb2x9JSVcIlxuXG5cbmV4cG9ydCBkZWYgbGV4XG5cdHZhciB0b2tlbiA9IHRoaXM6dG9rZW5zW3RoaXM6cG9zKytdXG5cdHZhciB0dGFnXG5cblx0aWYgdG9rZW5cblx0XHR0dGFnID0gdG9rZW4uQHR5cGVcblx0XHR0aGlzOnl5dGV4dCA9IHRva2VuXG5cdGVsc2Vcblx0XHR0dGFnID0gJydcblxuXHRyZXR1cm4gdHRhZ1xuXG5cbiMgZXhwb3J0IGRlZiB0b2tlbiB0eXAsIHZhbCwgbGluZSwgY29sLCBsZW4gZG8gVG9rZW4ubmV3KHR5cCx2YWwsbGluZSwgY29sIG9yIDAsIGxlbiBvciAwKSAjIFtudWxsLHR5cCx2YWwsbG9jXVxuZXhwb3J0IGRlZiB0b2tlbiB0eXAsIHZhbCBkbyBUb2tlbi5uZXcodHlwLHZhbCwtMSwwKVxuXG5leHBvcnQgZGVmIHR5cCB0b2sgZG8gdG9rLkB0eXBlXG5leHBvcnQgZGVmIHZhbCB0b2sgZG8gdG9rLkB2YWx1ZSAjIHRva1tvZmZzZXQgKyAxXVxuZXhwb3J0IGRlZiBsaW5lIHRvayBkbyB0b2suQGxpbmUgIyB0b2tbb2Zmc2V0ICsgMl1cbmV4cG9ydCBkZWYgbG9jIHRvayBkbyB0b2suQGxvYyAjIHRva1tvZmZzZXQgKyAyXVxuXG5leHBvcnQgZGVmIHNldFR5cCB0b2ssIHYgZG8gdG9rLkB0eXBlID0gdlxuZXhwb3J0IGRlZiBzZXRWYWwgdG9rLCB2IGRvIHRvay5AdmFsdWUgPSB2XG5leHBvcnQgZGVmIHNldExpbmUgdG9rLCB2IGRvIHRvay5AbGluZSA9IHZcbmV4cG9ydCBkZWYgc2V0TG9jIHRvaywgdiBkbyB0b2suQGxvYyA9IHZcblxuXG5leHBvcnQgdmFyIExCUkFDS0VUID0gVG9rZW4ubmV3KCd7JywneycsMCwwLDApXG5leHBvcnQgdmFyIFJCUkFDS0VUID0gVG9rZW4ubmV3KCd9JywnfScsMCwwLDApXG5cbmV4cG9ydCB2YXIgTFBBUkVOID0gVG9rZW4ubmV3KCcoJywnKCcsMCwwLDApXG5leHBvcnQgdmFyIFJQQVJFTiA9IFRva2VuLm5ldygnKScsJyknLDAsMCwwKVxuXG5MQlJBQ0tFVDpnZW5lcmF0ZWQgPSB5ZXNcblJCUkFDS0VUOmdlbmVyYXRlZCA9IHllc1xuTFBBUkVOOmdlbmVyYXRlZCA9IHllc1xuUlBBUkVOOmdlbmVyYXRlZCA9IHllc1xuXG5leHBvcnQgdmFyIElOREVOVCA9IFRva2VuLm5ldygnSU5ERU5UJywnMicsMCwwLDApXG5leHBvcnQgdmFyIE9VVERFTlQgPSBUb2tlbi5uZXcoJ09VVERFTlQnLCcyJywwLDAsMClcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBzcmMvY29tcGlsZXIvdG9rZW4uaW1iYVxuICoqLyIsIiMgY3JlYXRlIHNlcGFyYXRlIGVycm9yLXR5cGVzIHdpdGggYWxsIHRoZSBsb2dpY1xuXG5leHBvcnQgY2xhc3MgSW1iYVBhcnNlRXJyb3IgPCBFcnJvclxuXHRcblx0ZGVmIHNlbGYud3JhcCBlcnJcblx0XHQjIHdoYXQgYWJvdXQgdGhlIHN0YWNrdHJhY2U/XG5cdFx0SW1iYVBhcnNlRXJyb3IubmV3KGVycilcblxuXHRkZWYgaW5pdGlhbGl6ZSBlLG9cblx0XHR0aGlzOmVycm9yID0gZVxuXHRcdHRoaXM6bWVzc2FnZSA9IGU6bWVzc2FnZVxuXHRcdHRoaXM6ZmlsZW5hbWUgPSBlOmZpbGVuYW1lXG5cdFx0dGhpczpsaW5lID0gZTpsaW5lXG5cdFx0QG9wdGlvbnMgPSBvIG9yIHt9XG5cdFx0c2VsZlxuXG5cdGRlZiBzZXQgb3B0c1xuXHRcdEBvcHRpb25zIHx8PSB7fVxuXHRcdGZvciBvd24gayx2IG9mIG9wdHNcblx0XHRcdEBvcHRpb25zW2tdID0gdlxuXHRcdHNlbGZcblxuXHRkZWYgc3RhcnRcblx0XHR2YXIgbyA9IEBvcHRpb25zXG5cdFx0dmFyIGlkeCA9IG86cG9zIC0gMVxuXHRcdHZhciB0b2sgPSBvOnRva2VucyBhbmQgbzp0b2tlbnNbaWR4XVxuXHRcdHRvayA9IG86dG9rZW5zWy0taWR4XSB3aGlsZSB0b2sgYW5kIHRvay5AbG9jID09IC0xXG5cdFx0cmV0dXJuIHRva1xuXG5cdGRlZiBkZXNjXG5cdFx0dmFyIG8gPSBAb3B0aW9uc1xuXHRcdGxldCBtc2cgPSBzZWxmOm1lc3NhZ2Vcblx0XHRpZiBvOnRva2VuIGFuZCBvOnRva2VuLkBsb2MgPT0gLTFcblx0XHRcdCdTeW50YXggRXJyb3InXG5cdFx0ZWxzZVxuXHRcdFx0bXNnXG5cdFxuXHRkZWYgbG9jXG5cdFx0c3RhcnQ/LnJlZ2lvblxuXG5cdGRlZiB0b0pTT05cblx0XHR2YXIgbyA9IEBvcHRpb25zXG5cdFx0dmFyIHRvayA9IHN0YXJ0XG5cdFx0IyB2YXIgdG9rID0gbzp0b2tlbnMgYW5kIG86dG9rZW5zW286cG9zIC0gMV1cblx0XHQjIHZhciBsb2MgPSB0b2sgYW5kIFt0b2suQGxvYyx0b2suQGxvYyArICh0b2suQGxlbiBvciB0b2suQHZhbHVlOmxlbmd0aCldIG9yIFswLDBdXG5cdFx0IyAsIGNvbDogdG9rLkBjb2wsIGxpbmU6IHRvay5AbGluZVxuXHRcdCMgZ2V0IHRoZSB0b2tlbiBpdHNlbGY/XG5cdFx0cmV0dXJuIHt3YXJuOiB5ZXMsIG1lc3NhZ2U6IGRlc2MsIGxvYzogbG9jfVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogc3JjL2NvbXBpbGVyL2Vycm9ycy5pbWJhXG4gKiovIiwiXG5leHBvcnQgZGVmIGJyYWNlIHN0clxuXHR2YXIgbGluZXMgPSBzdHIubWF0Y2goL1xcbi8pXG5cdCMgd2hhdCBhYm91dCBpbmRlbnRhdGlvbj9cblxuXHRpZiBsaW5lc1xuXHRcdCd7JyArIHN0ciArICdcXG59J1xuXHRlbHNlXG5cdFx0J3tcXG4nICsgc3RyICsgJ1xcbn0nXG5cbmV4cG9ydCBkZWYgbm9ybWFsaXplSW5kZW50YXRpb24gc3RyXG5cdHZhciBtXG5cdHZhciByZWcgPSAvXFxuKyhbXlxcblxcU10qKS9nXG5cdHZhciBpbmQgPSBudWxsXG5cblx0d2hpbGUgbSA9IHJlZy5leGVjKHN0cilcblx0XHR2YXIgYXR0ZW1wdCA9IG1bMV1cblx0XHRpZiBpbmQgaXMgbnVsbCBvciAwIDwgYXR0ZW1wdDpsZW5ndGggPCBpbmQ6bGVuZ3RoXG5cdFx0XHRpbmQgPSBhdHRlbXB0XG5cblx0c3RyID0gc3RyLnJlcGxhY2UoUmVnRXhwKFwiXFxcXG57aW5kfVwiLFwiZ1wiKSwgJ1xcbicpIGlmIGluZFxuXHRyZXR1cm4gc3RyXG5cblxuZXhwb3J0IGRlZiBmbGF0dGVuIGFyclxuXHR2YXIgb3V0ID0gW11cblx0YXJyLmZvckVhY2ggZG8gfHZ8IHYgaXNhIEFycmF5ID8gb3V0OnB1c2guYXBwbHkob3V0LGZsYXR0ZW4odikpIDogb3V0LnB1c2godilcblx0cmV0dXJuIG91dFxuXG5cbmV4cG9ydCBkZWYgcGFzY2FsQ2FzZSBzdHJcblx0c3RyLnJlcGxhY2UoLyhefFtcXC1cXF9cXHNdKShcXHcpL2cpIGRvIHxtLHYsbHwgbC50b1VwcGVyQ2FzZVxuXG5leHBvcnQgZGVmIGNhbWVsQ2FzZSBzdHJcblx0c3RyID0gU3RyaW5nKHN0cilcblx0IyBzaG91bGQgYWRkIHNob3J0Y3V0IG91dFxuXHRzdHIucmVwbGFjZSgvKFtcXC1cXF9cXHNdKShcXHcpL2cpIGRvIHxtLHYsbHwgbC50b1VwcGVyQ2FzZVxuXG5leHBvcnQgZGVmIHNuYWtlQ2FzZSBzdHJcblx0dmFyIHN0ciA9IHN0ci5yZXBsYWNlKC8oW1xcLVxcc10pKFxcdykvZywnXycpXG5cdHN0ci5yZXBsYWNlKC8oKShbQS1aXSkvZyxcIl8kMVwiKSBkbyB8bSx2LGx8IGwudG9VcHBlckNhc2VcblxuZXhwb3J0IGRlZiBzZXR0ZXJTeW0gc3ltXG5cdGNhbWVsQ2FzZShcInNldC17c3ltfVwiKVxuXG5leHBvcnQgZGVmIHF1b3RlIHN0clxuXHQnXCInICsgc3RyICsgJ1wiJ1xuXG5leHBvcnQgZGVmIHNpbmdsZXF1b3RlIHN0clxuXHRcIidcIiArIHN0ciArIFwiJ1wiXG5cbmV4cG9ydCBkZWYgc3ltYm9saXplIHN0clxuXHRzdHIgPSBTdHJpbmcoc3RyKVxuXHR2YXIgZW5kID0gc3RyLmNoYXJBdChzdHI6bGVuZ3RoIC0gMSlcblxuXHRpZiBlbmQgPT0gJz0nXG5cdFx0c3RyID0gJ3NldCcgKyBzdHJbMF0udG9VcHBlckNhc2UgKyBzdHIuc2xpY2UoMSwtMSlcblxuXHRpZiBzdHIuaW5kZXhPZihcIi1cIikgPj0gMFxuXHRcdHN0ciA9IHN0ci5yZXBsYWNlKC8oW1xcLVxcc10pKFxcdykvZykgZG8gfG0sdixsfCBsLnRvVXBwZXJDYXNlXG5cdFx0XHRcblx0cmV0dXJuIHN0clxuXG5cbmV4cG9ydCBkZWYgaW5kZW50IHN0clxuXHRTdHJpbmcoc3RyKS5yZXBsYWNlKC9eL2csXCJcXHRcIikucmVwbGFjZSgvXFxuL2csXCJcXG5cXHRcIikucmVwbGFjZSgvXFxuXFx0JC9nLFwiXFxuXCIpXG5cbmV4cG9ydCBkZWYgYnJhY2tldGl6ZSBzdHIsIGluZCA9IHllc1xuXHRzdHIgPSBcIlxcblwiICsgaW5kZW50KHN0cikgKyBcIlxcblwiIGlmIGluZFxuXHQneycgKyBzdHIgKyAnfSdcblx0XG5leHBvcnQgZGVmIHBhcmVudGhlc2l6ZSBzdHJcblx0JygnICsgU3RyaW5nKHN0cikgKyAnKSdcblxuZXhwb3J0IGRlZiBsb2NhdGlvblRvTGluZUNvbE1hcCBjb2RlXG5cdHZhciBsaW5lcyA9IGNvZGUuc3BsaXQoL1xcbi9nKVxuXHR2YXIgbWFwID0gW11cblxuXHR2YXIgY2hyXG5cdHZhciBsb2MgPSAwXG5cdHZhciBjb2wgPSAwXG5cdHZhciBsaW5lID0gMFxuXG5cdHdoaWxlIGNociA9IGNvZGVbbG9jXVxuXHRcdG1hcFtsb2NdID0gW2xpbmUsY29sXVxuXG5cdFx0aWYgY2hyID09ICdcXG4nXG5cdFx0XHRsaW5lKytcblx0XHRcdGNvbCA9IDBcblx0XHRlbHNlXG5cdFx0XHRjb2wrK1xuXG5cdFx0bG9jKytcblxuXHRyZXR1cm4gbWFwXG5cbmV4cG9ydCBkZWYgbWFya0xpbmVDb2xGb3JUb2tlbnMgdG9rZW5zLCBjb2RlXG5cdHNlbGZcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBzcmMvY29tcGlsZXIvaGVscGVycy5pbWJhXG4gKiovIiwiXG52YXIgVCA9IHJlcXVpcmUgJy4vdG9rZW4nXG52YXIgVG9rZW4gPSBULlRva2VuXG5cbnZhciBydyA9IHJlcXVpcmUgJy4vcmV3cml0ZXInXG52YXIgUmV3cml0ZXIgPSBydy5SZXdyaXRlclxudmFyIElOVkVSU0VTID0gcncuSU5WRVJTRVNcblxudmFyIEsgPSAwXG5cbnZhciBFUlIgPSByZXF1aXJlICcuL2Vycm9ycydcblxuIyBDb25zdGFudHNcbiMgLS0tLS0tLS0tXG5cbiMgS2V5d29yZHMgdGhhdCBJbWJhIHNoYXJlcyBpbiBjb21tb24gd2l0aCBKYXZhU2NyaXB0LlxudmFyIEpTX0tFWVdPUkRTID0gW1xuXHQndHJ1ZScsICdmYWxzZScsICdudWxsJywgJ3RoaXMnXG5cdCdkZWxldGUnLCAndHlwZW9mJywgJ2luJywgJ2luc3RhbmNlb2YnXG5cdCd0aHJvdycsICdicmVhaycsICdjb250aW51ZScsICdkZWJ1Z2dlcidcblx0J2lmJywgJ2Vsc2UnLCAnc3dpdGNoJywgJ2ZvcicsICd3aGlsZScsICdkbycsICd0cnknLCAnY2F0Y2gnLCAnZmluYWxseSdcblx0J2NsYXNzJywgJ2V4dGVuZHMnLCAnc3VwZXInLCAncmV0dXJuJ1xuXVxuXG4jIG5ldyBjYW4gYmUgdXNlZCBhcyBhIGtleXdvcmQgaW4gaW1iYSwgc2luY2Ugb2JqZWN0IGluaXRpbmcgaXMgZG9uZSB0aHJvdWdoXG4jIE15T2JqZWN0Lm5ldy4gbmV3IGlzIGEgdmVyeSB1c2VmdWwgdmFybmFtZS5cblxuIyBXZSB3YW50IHRvIHRyZWF0IHJldHVybiBsaWtlIGFueSByZWd1bGFyIGNhbGwgZm9yIG5vd1xuIyBNdXN0IGJlIGNhcmVmdWwgdG8gdGhyb3cgdGhlIGV4Y2VwdGlvbnMgaW4gQVNULCBzaW5jZSB0aGUgcGFyc2VyXG4jIHdvbnRcblxuIyBJbWJhLW9ubHkga2V5d29yZHMuIHZhciBzaG91bGQgbW92ZSB0byBKU19LZXl3b3Jkc1xuIyBzb21lIHdvcmRzIChsaWtlIHRva2lkKSBzaG91bGQgYmUgY29udGV4dC1zcGVjaWZpY1xudmFyIElNQkFfS0VZV09SRFMgPSBbXG5cdCd1bmRlZmluZWQnLCAndGhlbicsICd1bmxlc3MnLCAndW50aWwnLCAnbG9vcCcsICdvZicsICdieScsXG5cdCd3aGVuJywnZGVmJywndGFnJywnZG8nLCdlbGlmJywnYmVnaW4nLCd2YXInLCdsZXQnLCdzZWxmJywnYXdhaXQnLCdpbXBvcnQnXG5dXG5cbnZhciBJTUJBX0NPTlRFWFRVQUxfS0VZV09SRFMgPSBbJ2V4dGVuZCcsJ3N0YXRpYycsJ2xvY2FsJywnZXhwb3J0JywnZ2xvYmFsJywncHJvcCddXG5cbnZhciBJTUJBX0FMSUFTX01BUCA9XG5cdCdhbmQnICA6ICcmJidcblx0J29yJyAgIDogJ3x8J1xuXHQnaXMnICAgOiAnPT0nXG5cdCdpc250JyA6ICchPSdcblx0J25vdCcgIDogJyEnXG5cdCd5ZXMnICA6ICd0cnVlJ1xuXHQnbm8nICAgOiAnZmFsc2UnXG5cdCdpc2EnICA6ICdpbnN0YW5jZW9mJ1xuXHQnY2FzZScgOiAnc3dpdGNoJ1xuXHQnbmlsJyAgOiAnbnVsbCdcblxudmFyIElNQkFfQUxJQVNFUyAgPSBPYmplY3Qua2V5cyhJTUJBX0FMSUFTX01BUClcbnZhciBJTUJBX0tFWVdPUkRTID0gSU1CQV9LRVlXT1JEUy5jb25jYXQoSU1CQV9BTElBU0VTKVxuXG4jIEZpeGVkQXJyYXkgZm9yIHBlcmZvcm1hbmNlXG4jIHZhciBBTExfS0VZV09SRFMgPSBKU19LRVlXT1JEUy5jb25jYXQoSU1CQV9LRVlXT1JEUylcbmV4cG9ydCB2YXIgQUxMX0tFWVdPUkRTID0gW1xuXHQndHJ1ZScsICdmYWxzZScsICdudWxsJywgJ3RoaXMnLFxuXHQnZGVsZXRlJywgJ3R5cGVvZicsICdpbicsICdpbnN0YW5jZW9mJyxcblx0J3Rocm93JywgJ2JyZWFrJywgJ2NvbnRpbnVlJywgJ2RlYnVnZ2VyJyxcblx0J2lmJywgJ2Vsc2UnLCAnc3dpdGNoJywgJ2ZvcicsICd3aGlsZScsICdkbycsICd0cnknLCAnY2F0Y2gnLCAnZmluYWxseScsXG5cdCdjbGFzcycsICdleHRlbmRzJywgJ3N1cGVyJywgJ3JldHVybicsXG5cdCd1bmRlZmluZWQnLCAndGhlbicsICd1bmxlc3MnLCAndW50aWwnLCAnbG9vcCcsICdvZicsICdieScsXG5cdCd3aGVuJywnZGVmJywndGFnJywnZG8nLCdlbGlmJywnYmVnaW4nLCd2YXInLCdsZXQnLCdzZWxmJywnYXdhaXQnLCdpbXBvcnQnLFxuXHQnYW5kJywnb3InLCdpcycsJ2lzbnQnLCdub3QnLCd5ZXMnLCdubycsJ2lzYScsJ2Nhc2UnLCduaWwnXG5dXG5cbiMgVGhlIGxpc3Qgb2Yga2V5d29yZHMgdGhhdCBhcmUgcmVzZXJ2ZWQgYnkgSmF2YVNjcmlwdCwgYnV0IG5vdCB1c2VkLCBvciBhcmVcbiMgdXNlZCBieSBJbWJhIGludGVybmFsbHkuIFdlIHRocm93IGFuIGVycm9yIHdoZW4gdGhlc2UgYXJlIGVuY291bnRlcmVkLFxuIyB0byBhdm9pZCBoYXZpbmcgYSBKYXZhU2NyaXB0IGVycm9yIGF0IHJ1bnRpbWUuICAjICd2YXInLCAnbGV0JywgLSBub3QgaW5zaWRlIGhlcmVcbnZhciBSRVNFUlZFRCA9IFsnY2FzZScsICdkZWZhdWx0JywgJ2Z1bmN0aW9uJywgJ3ZvaWQnLCAnd2l0aCcsICdjb25zdCcsICdlbnVtJywgJ25hdGl2ZSddXG52YXIgU1RSSUNUX1JFU0VSVkVEID0gWydjYXNlJywnZnVuY3Rpb24nLCd2b2lkJywnY29uc3QnXVxuXG4jIFRoZSBzdXBlcnNldCBvZiBib3RoIEphdmFTY3JpcHQga2V5d29yZHMgYW5kIHJlc2VydmVkIHdvcmRzLCBub25lIG9mIHdoaWNoIG1heVxuIyBiZSB1c2VkIGFzIGlkZW50aWZpZXJzIG9yIHByb3BlcnRpZXMuXG52YXIgSlNfRk9SQklEREVOID0gSlNfS0VZV09SRFMuY29uY2F0IFJFU0VSVkVEXG5cbnZhciBNRVRIT0RfSURFTlRJRklFUiA9IC8vLyBeXG5cdCggXG5cdFx0KChbXFx4MjNdP1tcXCRBLVphLXpfXFx4N2YtXFx1ZmZmZl1bJFxcLVxcd1xceDdmLVxcdWZmZmZdKikoW1xcPV0/KSkgfCBcblx0XHQoPD0+fFxcfCg/IVtcXHw9XSkpXG5cdClcbi8vL1xuIyByZW1vdmVkIH49fH58IHwmKD8hWyY9XSlcblxuIyBUb2tlbiBtYXRjaGluZyByZWdleGVzLlxuIyBhZGRlZCBoeXBoZW5zIHRvIGlkZW50aWZpZXJzIG5vdyAtIHRvIHRlc3RcbnZhciBJREVOVElGSUVSID0gLy8vIF5cblx0KFxuXHRcdChcXCR8QEB8QHxcXCMpW1xcd0EtWmEtel9cXC1cXHg3Zi1cXHVmZmZmXVskXFx3XFx4N2YtXFx1ZmZmZl0qIChcXC1bJFxcd1xceDdmLVxcdWZmZmZdKykqIHxcblx0XHRbJEEtWmEtel9dWyRcXHdcXHg3Zi1cXHVmZmZmXSogKFxcLVskXFx3XFx4N2YtXFx1ZmZmZl0rKSpcblx0KVxuXHQoIFteXFxuXFxTXSogOiAoPyFbXFwqXFw9OiRcXHdcXHg3Zi1cXHVmZmZmXSkgKT8gICMgSXMgdGhpcyBhIHByb3BlcnR5IG5hbWU/XG4vLy9cblxudmFyIE9CSkVDVF9LRVkgPSAvLy8gXlxuXHQoIChcXCR8QEB8QHwpWyRBLVphLXpfXFx4N2YtXFx1ZmZmZlxcLV1bJFxcd1xceDdmLVxcdWZmZmZcXC1dKilcblx0KCBbXlxcblxcU1xcc10qIDogKD8hW1xcKlxcPTokXFx3XFx4N2YtXFx1ZmZmZl0pICkgICMgSXMgdGhpcyBhIHByb3BlcnR5IG5hbWU/XG4vLy9cblxudmFyIFRBRyA9IC8vLyBeXG5cdChcXDx8JSkoPz1bQS1aYS16XFwjXFwuXFx7XFxAXFw+XSlcbi8vL1xuXG52YXIgVEFHX1RZUEUgPSAvXihcXHdbXFx3XFxkXSo6KT8oXFx3W1xcd1xcZF0qKSgtW1xcd1xcZF0rKSovXG52YXIgVEFHX0lEID0gL14jKChcXHdbXFx3XFxkXSopKC1bXFx3XFxkXSspKikvXG5cbnZhciBUQUdfQVRUUiA9IC9eKFtcXC5cXDpdP1tcXHdcXF9dKyhbXFwtXFw6XVtcXHddKykqKShcXHMpKlxcPS9cblxudmFyIFNFTEVDVE9SID0gL14oWyVcXCRdezEsMn0pKFtcXChcXHdcXCNcXC5cXFtdKS9cbnZhciBTRUxFQ1RPUl9QQVJUID0gL14oXFwjfFxcLnw6fDo6KT8oW1xcd10rKFxcLVtcXHddKykqKS9cbnZhciBTRUxFQ1RPUl9DT01CSU5BVE9SID0gL14gKFxcK3xcXD58XFx+KSpcXHMqKD89W1xcd1xcLlxcI1xcOlxce1xcKlxcW10pL1xuXG52YXIgU0VMRUNUT1JfUFNFVURPX0NMQVNTID0gL14oOjo/KShbXFx3XSsoXFwtW1xcd10rKSopL1xudmFyIFNFTEVDVE9SX0FUVFJfT1AgPSAvXihcXCQ9fFxcfj18XFxePXxcXCo9fFxcfD18PXxcXCE9KS9cbnZhciBTRUxFQ1RPUl9BVFRSID0gL15cXFsoW1xcd1xcX1xcLV0rKShcXCQ9fFxcfj18XFxePXxcXCo9fFxcfD18PXxcXCE9KS9cblxudmFyIFNZTUJPTCA9IC8vL15cblx0XFw6KFxuXHRcdChcblx0XHRcdChbXFwqXFxAJFxcd1xceDdmLVxcdWZmZmZdKykrKFtcXC1cXC9cXFxcXFw6XVtcXHdcXHg3Zi1cXHVmZmZmXSspKlxuXHRcdCl8PT18XFw8PVxcPnxcXFtcXF18XFxbXFxdXFw9fFxcKnxbXFwvLFxcXFxdXG5cdClcbi8vL1xuXG5cbnZhciBOVU1CRVIgPSAvLy9cblx0XiAweFtcXGRhLWZdKyB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIyBoZXhcblx0XiAwYlswMV0rIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIGJpbmFyeVxuXHReIFxcZCpcXC4/XFxkKyAoPzplWystXT9cXGQrKT8gICMgZGVjaW1hbFxuLy8vaVxuXG52YXIgSEVSRURPQyA9IC8vLyBeIChcIlwiXCJ8JycnKSAoW1xcc1xcU10qPykgKD86XFxuW15cXG5cXFNdKik/IFxcMSAvLy9cblxudmFyIE9QRVJBVE9SID0gLy8vIF4gKFxuXHQ/OiBbLT1dPT4gICAgICAgICAgICAgIyBmdW5jdGlvbiAtIHdoYXRcblx0IHwgPT09XG5cdCB8IC0+XG5cdCB8ICE9PVxuXHQgfCBbLSsqLyU8PiZ8XiE/PV09ICAjIGNvbXBvdW5kIGFzc2lnbiAvIGNvbXBhcmVcblx0IHwgPTxcblx0IHwgPj4+PT8gICAgICAgICAgICAgIyB6ZXJvLWZpbGwgcmlnaHQgc2hpZnRcblx0IHwgKFstKzpdKVxcMSAgICAgICAgICMgZG91Ymxlc1xuXHQgfCAoWyZ8PD5dKVxcMj0/ICAgICAgIyBsb2dpYyAvIHNoaWZ0XG5cdCB8IFxcP1xcLiAgICAgICAgICAgICAgIyBzb2FrIGFjY2Vzc1xuXHQgfCBcXD9cXDogICAgICAgICAgICAgICMgc29hayBzeW1ib2xcblx0IHwgXFwuezIsM30gICAgICAgICAgICMgcmFuZ2Ugb3Igc3BsYXRcblx0IHwgXFwqKD89W2EtekEtWlxcX10pICAgIyBzcGxhdCAtLSBcbikgLy8vXG5cbiMgRklYTUUgc3BsYXQgc2hvdWxkIG9ubHkgYmUgYWxsb3dlZCB3aGVuIHRoZSBwcmV2aW91cyB0aGluZyBpcyBzcGFjZWQgb3IgaW5zaWRlIGNhbGw/XG5cbnZhciBXSElURVNQQUNFID0gL15bXlxcblxcU10rL1xuXG52YXIgQ09NTUVOVCAgICA9IC9eIyMjKFteI11bXFxzXFxTXSo/KSg/OiMjI1teXFxuXFxTXSp8KD86IyMjKT8kKS9cbiMgQ09NTUVOVCAgICA9IC9eIyMjKFteI11bXFxzXFxTXSo/KSg/OiMjI1teXFxuXFxTXSp8KD86IyMjKT8kKXxeKD86XFxzKigjXFxzLip8I1xccyokKSkrL1xudmFyIElOTElORV9DT01NRU5UID0gL14oXFxzKikoI1sgXFx0XFwhXSguKil8I1sgXFx0XT8oPz1cXG58JCkpKy9cblxudmFyIENPREUgICAgICAgPSAvXlstPV09Pi9cblxudmFyIE1VTFRJX0RFTlQgPSAvXig/OlxcblteXFxuXFxTXSopKy9cblxudmFyIFNJTVBMRVNUUiAgPSAvXidbXlxcXFwnXSooPzpcXFxcLlteXFxcXCddKikqJy9cblxudmFyIEpTVE9LRU4gICAgPSAvXmBbXlxcXFxgXSooPzpcXFxcLlteXFxcXGBdKikqYC9cblxuIyBSZWdleC1tYXRjaGluZy1yZWdleGVzLlxudmFyIFJFR0VYID0gLy8vIF5cblx0KC8gKD8hIFtcXHM9XSApICAgIyBkaXNhbGxvdyBsZWFkaW5nIHdoaXRlc3BhY2Ugb3IgZXF1YWxzIHNpZ25zXG5cdFteIFsgLyBcXG4gXFxcXCBdKiAgIyBldmVyeSBvdGhlciB0aGluZ1xuXHQoPzpcblx0XHQoPzogXFxcXFtcXHNcXFNdICAgIyBhbnl0aGluZyBlc2NhcGVkXG5cdFx0XHR8IFxcWyAgICAgICAgICMgY2hhcmFjdGVyIGNsYXNzXG5cdFx0XHRcdFx0IFteIFxcXSBcXG4gXFxcXCBdKlxuXHRcdFx0XHRcdCAoPzogXFxcXFtcXHNcXFNdIFteIFxcXSBcXG4gXFxcXCBdKiApKlxuXHRcdFx0XHQgXVxuXHRcdCkgW14gWyAvIFxcbiBcXFxcIF0qXG5cdCkqXG5cdC8pIChbaW1neV17MCw0fSkgKD8hXFx3KVxuLy8vXG5cbnZhciBIRVJFR0VYICAgICAgPSAvLy8gXiAvezN9IChbXFxzXFxTXSs/KSAvezN9IChbaW1neV17MCw0fSkgKD8hXFx3KSAvLy9cblxudmFyIEhFUkVHRVhfT01JVCA9IC9cXHMrKD86Iy4qKT8vZ1xuXG4jIFRva2VuIGNsZWFuaW5nIHJlZ2V4ZXMuXG52YXIgTVVMVElMSU5FUiAgICAgID0gL1xcbi9nXG5cbnZhciBIRVJFRE9DX0lOREVOVCAgPSAvXFxuKyhbXlxcblxcU10qKS9nXG5cbnZhciBIRVJFRE9DX0lMTEVHQUwgPSAvXFwqXFwvL1xuXG4jIGV4cGVuc2l2ZT9cbnZhciBMSU5FX0NPTlRJTlVFUiAgPSAvLy8gXiBcXHMqICg/OiAsIHwgXFw/P1xcLig/IVsuXFxkXSkgfCA6OiApIC8vL1xuXG52YXIgVFJBSUxJTkdfU1BBQ0VTID0gL1xccyskL1xuXG52YXIgQ09OU1RfSURFTlRJRklFUiA9IC9eW0EtWl0vXG5cbnZhciBBUkdWQVIgPSAvXlxcJFxcZCQvXG5cbiMgQ29tcG91bmQgYXNzaWdubWVudCB0b2tlbnMuXG52YXIgQ09NUE9VTkRfQVNTSUdOID0gWyAnLT0nLCAnKz0nLCAnLz0nLCAnKj0nLCAnJT0nLCAnfHw9JywgJyYmPScsICc/PScsICc8PD0nLCAnPj49JywgJz4+Pj0nLCAnJj0nLCAnXj0nLCAnfD0nLCc9PCddXG5cbiMgVW5hcnkgdG9rZW5zLlxudmFyIFVOQVJZID0gWychJywgJ34nLCAnTkVXJywgJ1RZUEVPRicsICdERUxFVEUnXVxuXG4jIExvZ2ljYWwgdG9rZW5zLlxudmFyIExPR0lDICAgPSBbJyYmJywgJ3x8JywgJyYnLCAnfCcsICdeJ11cblxuIyBCaXQtc2hpZnRpbmcgdG9rZW5zLlxudmFyIFNISUZUICAgPSBbJzw8JywgJz4+JywgJz4+PiddXG5cbiMgQ29tcGFyaXNvbiB0b2tlbnMuXG52YXIgQ09NUEFSRSA9IFsnPT09JywgJyE9PScsICc9PScsICchPScsICc8JywgJz4nLCAnPD0nLCAnPj0nLCc9PT0nLCchPT0nXVxuXG4jIE92ZXJpZGVhYmxlIG1ldGhvZHNcbnZhciBPUF9NRVRIT0RTID0gWyc8PT4nLCc8PCcsJy4uJ11cblxuIyBNYXRoZW1hdGljYWwgdG9rZW5zLlxudmFyIE1BVEggPSBbJyonLCAnLycsICclJywgJ+KIqicsICfiiKknLCfiiJonXVxuXG4jIFJlbGF0aW9uYWwgdG9rZW5zIHRoYXQgYXJlIG5lZ2F0YWJsZSB3aXRoIGBub3RgIHByZWZpeC5cbnZhciBSRUxBVElPTiA9IFsnSU4nLCAnT0YnLCAnSU5TVEFOQ0VPRicsJ0lTQSddXG5cbiMgQm9vbGVhbiB0b2tlbnMuXG52YXIgQk9PTCA9IFsnVFJVRScsICdGQUxTRScsICdOVUxMJywgJ1VOREVGSU5FRCddXG5cbiMgT3VyIGxpc3QgaXMgc2hvcnRlciwgZHVlIHRvIHNhbnMtcGFyZW50aGVzZXMgbWV0aG9kIGNhbGxzLlxudmFyIE5PVF9SRUdFWCA9IFsnTlVNQkVSJywgJ1JFR0VYJywgJ0JPT0wnLCAnVFJVRScsICdGQUxTRScsICcrKycsICctLScsICddJ11cblxuIyBJZiB0aGUgcHJldmlvdXMgdG9rZW4gaXMgbm90IHNwYWNlZCwgdGhlcmUgYXJlIG1vcmUgcHJlY2VkaW5nIHRva2VucyB0aGF0XG4jIGZvcmNlIGEgZGl2aXNpb24gcGFyc2U6XG52YXIgTk9UX1NQQUNFRF9SRUdFWCA9IFsnTlVNQkVSJywgJ1JFR0VYJywgJ0JPT0wnLCAnVFJVRScsICdGQUxTRScsICcrKycsICctLScsICddJywnKScsICd9JywgJ1RISVMnLCAnU0VMRicgLCAnSURFTlRJRklFUicsICdTVFJJTkcnXVxuXG4jIFRva2VucyB3aGljaCBjb3VsZCBsZWdpdGltYXRlbHkgYmUgaW52b2tlZCBvciBpbmRleGVkLiBBbiBvcGVuaW5nXG4jIHBhcmVudGhlc2VzIG9yIGJyYWNrZXQgZm9sbG93aW5nIHRoZXNlIHRva2VucyB3aWxsIGJlIHJlY29yZGVkIGFzIHRoZSBzdGFydFxuIyBvZiBhIGZ1bmN0aW9uIGludm9jYXRpb24gb3IgaW5kZXhpbmcgb3BlcmF0aW9uLlxuIyByZWFsbHk/IVxuXG52YXIgVU5GSU5JU0hFRCA9IFsnXFxcXCcsJy4nLCAnPy4nLCAnPzonLCAnVU5BUlknLCAnTUFUSCcsICcrJywgJy0nLCAnU0hJRlQnLCAnUkVMQVRJT04nLCAnQ09NUEFSRScsICdMT0dJQycsICdDT01QT1VORF9BU1NJR04nLCAnVEhST1cnLCAnRVhURU5EUyddXG5cbiMgfSBzaG91bGQgbm90IGJlIGNhbGxhYmxlIGFueW1vcmUhISEgJ30nLCAnOjonLFxudmFyIENBTExBQkxFICA9IFsnSURFTlRJRklFUicsICdTVFJJTkcnLCAnUkVHRVgnLCAnKScsICddJywgJ1RISVMnLCAnU1VQRVInLCAnVEFHX0VORCcsICdJVkFSJywgJ0dWQVInLCdTRUxGJywnQ09OU1QnLCdORVcnLCdBUkdWQVInLCdTWU1CT0wnLCdSRVRVUk4nXVxuIyB2YXIgSU5ERVhBQkxFID0gQ0FMTEFCTEUuY29uY2F0ICdOVU1CRVInLCAnQk9PTCcsICdUQUdfU0VMRUNUT1InLCAnSURSRUYnLCAnQVJHVU1FTlRTJywnfScgIyBhcmUgYm9vbGVhbnMgaW5kZXhhYmxlPyByZWFsbHk/XG4jIG9wdGltaXplIGZvciBGaXhlZEFycmF5XG52YXIgSU5ERVhBQkxFID0gW1xuXHQnSURFTlRJRklFUicsICdTVFJJTkcnLCAnUkVHRVgnLCAnKScsICddJywgJ1RISVMnLCAnU1VQRVInLCAnVEFHX0VORCcsICdJVkFSJywgJ0dWQVInLCdTRUxGJywnQ09OU1QnLCdORVcnLCdBUkdWQVInLCdTWU1CT0wnLCdSRVRVUk4nXG5cdCdOVU1CRVInLCAnQk9PTCcsICdUQUdfU0VMRUNUT1InLCAnSURSRUYnLCAnQVJHVU1FTlRTJywnfScsJ1RBR19UWVBFJ1xuXVxuXG52YXIgR0xPQkFMX0lERU5USUZJRVJTID0gWydnbG9iYWwnLCdleHBvcnRzJywncmVxdWlyZSddXG5cbiMgVG9rZW5zIHRoYXQsIHdoZW4gaW1tZWRpYXRlbHkgcHJlY2VkaW5nIGEgYFdIRU5gLCBpbmRpY2F0ZSB0aGF0IHRoZSBgV0hFTmBcbiMgb2NjdXJzIGF0IHRoZSBzdGFydCBvZiBhIGxpbmUuIFdlIGRpc2FtYmlndWF0ZSB0aGVzZSBmcm9tIHRyYWlsaW5nIHdoZW5zIHRvXG4jIGF2b2lkIGFuIGFtYmlndWl0eSBpbiB0aGUgZ3JhbW1hci5cbnZhciBMSU5FX0JSRUFLID0gWydJTkRFTlQnLCAnT1VUREVOVCcsICdURVJNSU5BVE9SJ11cblxuXG5leHBvcnQgY2xhc3MgTGV4ZXJFcnJvciA8IFN5bnRheEVycm9yXG5cdFxuXHRkZWYgaW5pdGlhbGl6ZSBtZXNzYWdlLCBmaWxlLCBsaW5lXG5cdFx0c2VsZjptZXNzYWdlID0gbWVzc2FnZVxuXHRcdHNlbGY6ZmlsZSA9IGZpbGVcblx0XHRzZWxmOmxpbmUgPSBsaW5lXG5cdFx0cmV0dXJuIHNlbGZcblxuXG5kZWYgbGFzdCBhcnJheSwgYmFjayA9IDBcblx0YXJyYXlbYXJyYXk6bGVuZ3RoIC0gYmFjayAtIDFdXG5cbmRlZiBjb3VudCBzdHIsIHN1YnN0clxuXHRyZXR1cm4gc3RyLnNwbGl0KHN1YnN0cik6bGVuZ3RoIC0gMVxuXHRcbmRlZiByZXBlYXRTdHJpbmcgc3RyLCB0aW1lc1xuXHR2YXIgcmVzID0gJydcblx0d2hpbGUgdGltZXMgPiAwXG5cdFx0aWYgdGltZXMgJSAyID09IDFcblx0XHRcdHJlcyArPSBzdHJcblx0XHRzdHIgKz0gc3RyXG5cdFx0dGltZXMgPj49IDFcblx0cmV0dXJuIHJlc1xuXG52YXIgdFQgID0gVDp0eXBcbnZhciB0ViAgPSBUOnZhbFxudmFyIHRUcyA9IFQ6c2V0VHlwXG52YXIgdFZzID0gVDpzZXRWYWxcblxuIyBUaGUgTGV4ZXIgY2xhc3MgcmVhZHMgYSBzdHJlYW0gb2YgSW1iYSBhbmQgZGl2dmllcyBpdCB1cCBpbnRvIHRva2lkZ2VkXG4jIHRva2Vucy4gU29tZSBwb3RlbnRpYWwgYW1iaWd1aXR5IGluIHRoZSBncmFtbWFyIGhhcyBiZWVuIGF2b2lkZWQgYnlcbiMgcHVzaGluZyBzb21lIGV4dHJhIHNtYXJ0cyBpbnRvIHRoZSBMZXhlci5cblxuIyBCYXNlZCBvbiB0aGUgb3JpZ2luYWwgbGV4ZXIuY29mZmVlIGZyb20gQ29mZmVlU2NyaXB0XG5leHBvcnQgY2xhc3MgTGV4ZXJcblxuXHRkZWYgaW5pdGlhbGl6ZVxuXHRcdHJlc2V0XG5cdFx0c2VsZlxuXG5cdGRlZiByZXNldFxuXHRcdEBjb2RlICAgID0gbnVsbFxuXHRcdEBjaHVuayAgID0gbnVsbCAgICAgICAgICAgIyBUaGUgcmVtYWluZGVyIG9mIHRoZSBzb3VyY2UgY29kZS5cblx0XHRAb3B0cyAgICA9IG51bGxcblx0XHRcblx0XHRAaW5kZW50ICA9IDAgICAgICAgICAgICAgICMgVGhlIGN1cnJlbnQgaW5kZW50YXRpb24gbGV2ZWwuXG5cdFx0QGluZGVidCAgPSAwICAgICAgICAgICAgICAjIFRoZSBvdmVyLWluZGVudGF0aW9uIGF0IHRoZSBjdXJyZW50IGxldmVsLlxuXHRcdEBvdXRkZWJ0ID0gMCAgICAgICAgICAgICAgIyBUaGUgdW5kZXItb3V0ZGVudGF0aW9uIGF0IHRoZSBjdXJyZW50IGxldmVsLlxuXG5cdFx0QGluZGVudHMgID0gW10gICAgICAgICAgICAgIyBUaGUgc3RhY2sgb2YgYWxsIGN1cnJlbnQgaW5kZW50YXRpb24gbGV2ZWxzLlxuXHRcdEBlbmRzICAgICA9IFtdICMgVGhlIHN0YWNrIGZvciBwYWlyaW5nIHVwIHRva2Vucy5cblx0XHRAY29udGV4dHMgPSBbXSAjIHN1cGxlbWVudHMgQGVuZHNcblx0XHRAc2NvcGVzICAgPSBbXVxuXHRcdEBuZXh0U2NvcGUgPSBudWxsICMgdGhlIHNjb3BlIHRvIGFkZCBvbiB0aGUgbmV4dCBpbmRlbnRcblx0XHQjIHNob3VsZCByYXRoZXIgbWFrZSBpdCBsaWtlIGEgc3RhdGVtYWNoaW5lIHRoYXQgbW92ZXMgZnJvbSBDTEFTU19ERUYgdG8gQ0xBU1NfQk9EWSBldGNcblx0XHQjIFRoaW5ncyBzaG91bGQgY29tcGlsZSBkaWZmZXJlbnRseSB3aGVuIHlvdSBhcmUgaW4gYSBDTEFTU19CT0RZIHRoYW4gd2hlbiBpbiBhIERFRl9CT0RZKytcblxuXHRcdEBpbmRlbnRTdHlsZSA9IG51bGxcblxuXHRcdEB0b2tlbnMgID0gW10gICAgICAgICAgICAgIyBTdHJlYW0gb2YgcGFyc2VkIHRva2VucyBpbiB0aGUgZm9ybSBgWydUWVBFJywgdmFsdWUsIGxpbmVdYC5cblx0XHRAc2VlbkZvciA9IG5vXG5cdFx0QGxvYyA9IDBcblx0XHRAbG9jT2Zmc2V0ID0gMFxuXG5cdFx0QGVuZCAgICAgPSBudWxsXG5cdFx0QGNoYXIgXHQgPSBudWxsXG5cdFx0QGJyaWRnZSAgPSBudWxsXG5cdFx0QGxhc3QgICAgPSBudWxsXG5cdFx0QGxhc3RUeXAgPSAnJ1xuXHRcdEBsYXN0VmFsID0gbnVsbFxuXHRcdHNlbGZcblxuXHRkZWYgamlzb25CcmlkZ2Ugamlzb25cblx0XHRAYnJpZGdlID0ge1xuXHRcdFx0bGV4OiBUOmxleFxuXHRcdFx0c2V0SW5wdXQ6IGRvIHx0b2tlbnN8XG5cdFx0XHRcdHRoaXM6dG9rZW5zID0gdG9rZW5zXG5cdFx0XHRcdHRoaXM6cG9zID0gMFxuXG5cdFx0XHR1cGNvbWluZ0lucHV0OiBkbyBcIlwiXG5cdFx0fVxuXG5cblx0ZGVmIHRva2VuaXplIGNvZGUsIG8gPSB7fVxuXG5cdFx0aWYgY29kZTpsZW5ndGggPT0gMFxuXHRcdFx0cmV0dXJuIFtdXG5cblx0XHR1bmxlc3MgbzppbmxpbmVcblx0XHRcdGlmIFdISVRFU1BBQ0UudGVzdChjb2RlKVxuXHRcdFx0XHRjb2RlID0gXCJcXG57Y29kZX1cIlxuXHRcdFx0XHRyZXR1cm4gW10gaWYgY29kZS5tYXRjaCgvXlxccyokL2cpXG5cblx0XHRcdGNvZGUgPSBjb2RlLnJlcGxhY2UoL1xcci9nLCAnJykucmVwbGFjZSAvW1xcdCBdKyQvZywgJydcblxuXHRcdEBsYXN0ICAgID0gbnVsbFxuXHRcdEBsYXN0VHlwID0gbnVsbFxuXHRcdEBsYXN0VmFsID0gbnVsbFxuXG5cdFx0QGNvZGUgICAgPSBjb2RlXG5cdFx0QG9wdHMgICAgPSBvXG5cdFx0QGxvY09mZnNldCA9IG86bG9jIG9yIDBcblxuXHRcdG86aW5kZW50IHx8PSB7c3R5bGU6IG51bGwsIHNpemU6IG51bGx9XG5cdFx0IyBhZGQgYSByZWZlcmVuY2UgdG8gdGhlIG9wdGlvbnMgb2JqZWN0XG5cdFx0by5AdG9rZW5zID0gQHRva2VucyBcblx0XHQjIHdoYXQgYWJvdXQgY29sIGhlcmU/XG5cblx0XHQjIEBpbmRlbnQgID0gMCAjIFRoZSBjdXJyZW50IGluZGVudGF0aW9uIGxldmVsLlxuXHRcdCMgQGluZGVidCAgPSAwICMgVGhlIG92ZXItaW5kZW50YXRpb24gYXQgdGhlIGN1cnJlbnQgbGV2ZWwuXG5cdFx0IyBAb3V0ZGVidCA9IDAgIyBUaGUgdW5kZXItb3V0ZGVudGF0aW9uIGF0IHRoZSBjdXJyZW50IGxldmVsLlxuXHRcdCMgQGluZGVudHMgPSBbXSAjIFRoZSBzdGFjayBvZiBhbGwgY3VycmVudCBpbmRlbnRhdGlvbiBsZXZlbHMuXG5cdFx0IyBAZW5kcyAgICA9IFtdICMgVGhlIHN0YWNrIGZvciBwYWlyaW5nIHVwIHRva2Vucy5cblx0XHQjIEB0b2tlbnMgID0gW10gIyBTdHJlYW0gb2YgcGFyc2VkIHRva2VucyBpbiB0aGUgZm9ybSBgWydUWVBFJywgdmFsdWUsIGxpbmVdYC5cblx0XHQjIEBjaGFyID0gbmlsXG5cdFx0XG5cdFx0Y29uc29sZS50aW1lKFwidG9rZW5pemU6bGV4ZXJcIikgaWYgbzpwcm9maWxlXG5cdFx0cGFyc2UoY29kZSlcblx0XHRjbG9zZUluZGVudGF0aW9uIHVubGVzcyBvOmlubGluZVxuXHRcdGlmICFvOnNpbGVudCBhbmQgQGVuZHM6bGVuZ3RoXG5cdFx0XHRlcnJvciBcIm1pc3Npbmcge0BlbmRzLnBvcH1cIlxuXG5cdFx0Y29uc29sZS50aW1lRW5kKFwidG9rZW5pemU6bGV4ZXJcIikgaWYgbzpwcm9maWxlXG5cdFx0cmV0dXJuIEB0b2tlbnMgaWYgbzpyZXdyaXRlID09IG5vIG9yIG86bm9yZXdyaXRlXG5cdFx0cmV0dXJuIFJld3JpdGVyLm5ldy5yZXdyaXRlKEB0b2tlbnMsIG8pXG5cblx0ZGVmIHBhcnNlIGNvZGVcblx0XHR2YXIgaSA9IDBcblx0XHR2YXIgcGkgPSAwXG5cblx0XHR3aGlsZSBAY2h1bmsgPSBjb2RlLnNsaWNlKGkpXG5cdFx0XHRAbG9jID0gQGxvY09mZnNldCArIGlcblx0XHRcdHBpID0gKEBlbmQgPT0gJ1RBRycgYW5kIHRhZ0RlZkNvbnRleHRUb2tlbikgfHwgKEBpblRhZyBhbmQgdGFnQ29udGV4dFRva2VuKSB8fCBiYXNpY0NvbnRleHRcblx0XHRcdGkgKz0gcGlcblxuXHRcdHJldHVyblxuXG5cdGRlZiBiYXNpY0NvbnRleHRcblx0XHRyZXR1cm4gc2VsZWN0b3JUb2tlbiB8fCBzeW1ib2xUb2tlbiB8fCBtZXRob2ROYW1lVG9rZW4gfHwgaWRlbnRpZmllclRva2VuIHx8IHdoaXRlc3BhY2VUb2tlbiB8fCBsaW5lVG9rZW4gfHwgY29tbWVudFRva2VuIHx8IGhlcmVkb2NUb2tlbiB8fCB0YWdUb2tlbiB8fCBzdHJpbmdUb2tlbiB8fCBudW1iZXJUb2tlbiB8fCByZWdleFRva2VuIHx8IGpzVG9rZW4gfHwgbGl0ZXJhbFRva2VuIHx8IDBcblxuXHRkZWYgbW92ZUNhcmV0IGlcblx0XHRAbG9jICs9IGlcblxuXHRkZWYgY29udGV4dFxuXHRcdEBlbmRzW0BlbmRzOmxlbmd0aCAtIDFdXG5cblx0ZGVmIGluQ29udGV4dCBrZXlcblx0XHR2YXIgbyA9IEBjb250ZXh0c1tAY29udGV4dHM6bGVuZ3RoIC0gMV1cblx0XHRyZXR1cm4gbyBhbmQgb1trZXldXG5cblx0ZGVmIHB1c2hFbmQgdmFsXG5cdFx0IyBjb25zb2xlLmxvZyBcInB1c2hpbmcgZW5kXCIsdmFsXG5cdFx0QGVuZHMucHVzaCh2YWwpXG5cdFx0QGNvbnRleHRzLnB1c2gobmlsKVxuXHRcdEBlbmQgPSB2YWxcblx0XHRyZWZyZXNoU2NvcGVcblx0XHRzZWxmXG5cblx0ZGVmIHBvcEVuZCB2YWxcblx0XHRAZW5kcy5wb3Bcblx0XHRAY29udGV4dHMucG9wXG5cdFx0QGVuZCA9IEBlbmRzW0BlbmRzOmxlbmd0aCAtIDFdXG5cdFx0cmVmcmVzaFNjb3BlXG5cdFx0c2VsZlxuXG5cdGRlZiByZWZyZXNoU2NvcGVcblx0XHR2YXIgY3R4MCA9IEBlbmRzW0BlbmRzOmxlbmd0aCAtIDFdXG5cdFx0dmFyIGN0eDEgPSBAZW5kc1tAZW5kczpsZW5ndGggLSAyXVxuXHRcdEBpblRhZyA9IGN0eDAgPT0gJ1RBR19FTkQnIG9yIChjdHgxID09ICdUQUdfRU5EJyBhbmQgY3R4MCA9PSAnT1VUREVOVCcpXG5cblx0XHRcblxuXHRkZWYgcXVldWVTY29wZSB2YWxcblx0XHQjIGNvbnNvbGUubG9nKFwicHVzaGluZyBzY29wZSB7dmFsfSAtIHtAaW5kZW50c30ge0BpbmRlbnRzOmxlbmd0aH1cIilcblx0XHQjIEBzY29wZXMucHVzaCh2YWwpICMgbm8gbm9cblx0XHRAc2NvcGVzW0BpbmRlbnRzOmxlbmd0aF0gPSB2YWxcblx0XHRzZWxmXG5cblx0ZGVmIHBvcFNjb3BlIHZhbFxuXHRcdEBzY29wZXMucG9wXG5cdFx0c2VsZlxuXG5cdGRlZiBnZXRTY29wZVxuXHRcdEBzY29wZXNbQGluZGVudHM6bGVuZ3RoIC0gMV1cblx0XHRcblx0ZGVmIHNjb3BlIHN5bSwgb3B0c1xuXHRcdHZhciBsZW4gPSBAZW5kcy5wdXNoKEBlbmQgPSBzeW0pXG5cdFx0QGNvbnRleHRzLnB1c2gob3B0cyBvciBuaWwpXG5cdFx0cmV0dXJuIHN5bVxuXHRcblxuXHRkZWYgY2xvc2VTZWxlY3RvclxuXHRcdGlmIEBlbmQgPT0gJyUnXG5cdFx0XHR0b2tlbignU0VMRUNUT1JfRU5EJywnJScsMClcblx0XHRcdHBhaXIoJyUnKVxuXHRcblxuXHRkZWYgb3BlbkRlZlxuXHRcdHB1c2hFbmQoJ0RFRicpXG5cblxuXHRkZWYgY2xvc2VEZWZcblx0XHRpZiBjb250ZXh0IGlzICdERUYnXG5cdFx0XHR2YXIgcHJldiA9IGxhc3QoQHRva2Vucylcblx0XHRcdCMgY29uc29sZS5sb2cgXCJjbG9zZSBkZWYge3ByZXZ9XCJcblx0XHRcdCMgY29uc29sZS5sb2coJ2Nsb3NlRGVmIHdpdGggbGFzdD4nLHByZXYpXG5cdFx0XHRpZiB0VChwcmV2KSA9PSAnREVGX0ZSQUdNRU5UJ1xuXHRcdFx0XHR0cnVlXG5cdFx0XHRlbGlmIHRUKHByZXYpID09ICdURVJNSU5BVE9SJ1xuXHRcdFx0XHQjIGNvbnNvbGUubG9nIFwiaGVyZT8hPz9cIlxuXHRcdFx0XHRsZXQgbiA9IEB0b2tlbnMucG9wXG5cdFx0XHRcdCMgY29uc29sZS5sb2cgblxuXHRcdFx0XHR0b2tlbignREVGX0JPRFknLCAnREVGX0JPRFknLDApXG5cdFx0XHRcdCMgdG9rZW4oJ1RFUk1JTkFUT1InLCAnJywwKSB1bmxlc3Mgbi5AdmFsdWUuaW5kZXhPZignLy8nKSA+PSAwXG5cdFx0XHRcdEB0b2tlbnMucHVzaChuKVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHR0b2tlbignREVGX0JPRFknLCAnREVGX0JPRFknLDApXG5cblx0XHRcdHBhaXIoJ0RFRicpXG5cdFx0cmV0dXJuXG5cblx0ZGVmIHRhZ0NvbnRleHRUb2tlblxuXHRcdGlmIEBjaHVua1swXSA9PSAnIydcblx0XHRcdCMgY29uc29sZS5sb2coJ2ZvdW5kIGlkICMgaW4gdGFnQ29udGV4dFRva2VuJylcblx0XHRcdHRva2VuKCcjJywnIycsMSlcblx0XHRcdHJldHVybiAxXG5cblx0XHRpZiB2YXIgbWF0Y2ggPSBUQUdfQVRUUi5leGVjKEBjaHVuaylcblx0XHRcdCMgY29uc29sZS5sb2cgJ1RBR19TRERTQVRUUiBJTiB0b2tpZCcsbWF0Y2hcblx0XHRcdCMgdmFyIHByZXYgPSBsYXN0IEB0b2tlbnNcblx0XHRcdCMgaWYgdGhlIHByZXYgaXMgYSB0ZXJtaW5hdG9yLCB3ZSBkb250IHJlYWxseSBuZWVkIHRvIGNhcmU/XG5cdFx0XHRpZiBAbGFzdFR5cCAhPSAnVEFHX05BTUUnXG5cdFx0XHRcdGlmIEBsYXN0VHlwID09ICdURVJNSU5BVE9SJ1xuXHRcdFx0XHRcdCMgY29uc29sZS5sb2coJ3ByZXYgd2FzIHRlcm1pbmF0b3IgLS0gZHJvcCBpdD8nKVxuXHRcdFx0XHRcdHRydWVcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHRva2VuKFwiLFwiLCBcIixcIilcblxuXHRcdFx0dmFyIGwgPSBtYXRjaFswXTpsZW5ndGhcblxuXHRcdFx0dG9rZW4gJ1RBR19BVFRSJyxtYXRjaFsxXSxsIC0gMSAgIyBhZGQgdG8gbG9jP1xuXHRcdFx0QGxvYyArPSBsIC0gMVxuXHRcdFx0dG9rZW4gJz0nLCc9JywxXG5cdFx0XHRyZXR1cm4gbFxuXHRcdHJldHVybiAwXG5cblx0ZGVmIHRhZ0RlZkNvbnRleHRUb2tlblxuXHRcdCMgY29uc29sZS5sb2cgXCJ0YWdDb250ZXh0VG9rZW5cIlxuXHRcdGlmIHZhciBtYXRjaCA9IFRBR19UWVBFLmV4ZWMoQGNodW5rKVxuXHRcdFx0dG9rZW4gJ1RBR19UWVBFJywgbWF0Y2hbMF0sIG1hdGNoWzBdOmxlbmd0aFxuXHRcdFx0cmV0dXJuIG1hdGNoWzBdOmxlbmd0aFxuXG5cdFx0aWYgdmFyIG1hdGNoID0gVEFHX0lELmV4ZWMoQGNodW5rKVxuXHRcdFx0dmFyIGlucHV0ID0gbWF0Y2hbMF1cblx0XHRcdHRva2VuICdUQUdfSUQnLCBpbnB1dCwgaW5wdXQ6bGVuZ3RoXG5cdFx0XHRyZXR1cm4gaW5wdXQ6bGVuZ3RoXG5cblx0XHRyZXR1cm4gMFxuXG5cblx0ZGVmIHRhZ1Rva2VuXG5cdFx0cmV0dXJuIDAgdW5sZXNzIHZhciBtYXRjaCA9IFRBRy5leGVjKEBjaHVuaylcblx0XHR2YXIgW2lucHV0LCB0eXBlLCBpZGVudGlmaWVyXSA9IG1hdGNoXG5cblx0XHRpZiB0eXBlID09ICc8J1xuXHRcdFx0dG9rZW4oJ1RBR19TVEFSVCcsICc8JywxKVxuXHRcdFx0cHVzaEVuZChJTlZFUlNFU1snVEFHX1NUQVJUJ10pXG5cblx0XHRcdGlmIG1hdGNoID0gVEFHX1RZUEUuZXhlYyhAY2h1bmsuc3Vic3RyKDEsNDApKVxuXHRcdFx0XHQjIHNwZWNpYWwgY2FzZSBzaG91bGQgcHJvYmFibHkgYmUgaGFuZGxlZCBpbiBBU1Rcblx0XHRcdFx0aWYgbWF0Y2hbMF0gIT0gJ3NlbGYnXG5cdFx0XHRcdFx0dG9rZW4oJ1RBR19UWVBFJyxtYXRjaFswXSxtYXRjaFswXTpsZW5ndGgsMSlcblx0XHRcdFx0XHRyZXR1cm4gaW5wdXQ6bGVuZ3RoICsgbWF0Y2hbMF06bGVuZ3RoXG5cblx0XHRcdGlmIGlkZW50aWZpZXJcblx0XHRcdFx0aWYgaWRlbnRpZmllci5zdWJzdHIoMCwxKSA9PSAneydcblx0XHRcdFx0XHRyZXR1cm4gdHlwZTpsZW5ndGhcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHRva2VuKCdUQUdfTkFNRScsIGlucHV0LnN1YnN0cigxKSwwKVxuXG5cdFx0cmV0dXJuIGlucHV0Omxlbmd0aFxuXG5cblx0ZGVmIHNlbGVjdG9yVG9rZW5cblx0XHR2YXIgbWF0Y2hcblxuXHRcdCMgc3BlY2lhbCBoYW5kbGluZyBpZiB3ZSBhcmUgaW4gdGhpcyBjb250ZXh0XG5cdFx0aWYgQGVuZCA9PSAnJSdcblx0XHRcdHZhciBjaHIgPSBAY2h1bmsuY2hhckF0KDApXG5cdFx0XHR2YXIgb3BlbiA9IGluQ29udGV4dCgnb3BlbicpXG5cblx0XHRcdCMgc2hvdWxkIGFkZCBmb3IgKywgfiBldGNcblx0XHRcdCMgc2hvdWxkIG1heWJlIHJhdGhlciBsb29rIGZvciB0aGUgY29ycmVjdCB0eXBlIG9mIGNoYXJhY3Rlcj9cblx0XHRcblx0XHRcdGlmIG9wZW4gYW5kIChjaHIgPT0gJyAnIG9yIGNociA9PSAnXFxuJyBvciBjaHIgPT0gJywnIG9yIGNociA9PSAnKycgb3IgY2hyID09ICd+JyBvciBjaHIgPT0gJyknIG9yIGNociA9PSAnXScpXG5cdFx0XHRcdCMgY29uc29sZS5sb2cgXCJjbG9zZSB0aGlzIHNlbGVjdG9yIGRpcmVjdGx5XCJcblx0XHRcdFx0dG9rZW4oJ1NFTEVDVE9SX0VORCcsJyUnLDApXG5cdFx0XHRcdHBhaXIgJyUnXG5cdFx0XHRcdHJldHVybiAwXG5cblx0XHRcdGlmIG1hdGNoID0gU0VMRUNUT1JfQ09NQklOQVRPUi5leGVjKEBjaHVuaylcblx0XHRcdFx0IyBzcGFjZXMgYmV0d2Vlbj8gLS0gaW5jbHVkZSB0aGUgd2hvbGVcblx0XHRcdFx0dG9rZW4gJ1NFTEVDVE9SX0NPTUJJTkFUT1InLCBtYXRjaFsxXSB8fCBcIiBcIiwgbWF0Y2hbMF06bGVuZ3RoXG5cdFx0XHRcdHJldHVybiBtYXRjaFswXTpsZW5ndGhcblx0XHRcdFxuXHRcdFx0ZWxpZiBtYXRjaCA9IFNFTEVDVE9SX1BBUlQuZXhlYyhAY2h1bmspXG5cdFx0XHRcdHZhciB0eXBlID0gbWF0Y2hbMV1cblx0XHRcdFx0dmFyIGlkID0gbWF0Y2hbMl1cblxuXHRcdFx0XHR2YXIgdG9raWQgPSBzd2l0Y2ggdHlwZVxuXHRcdFx0XHRcdHdoZW4gJy4nIHRoZW4gJ1NFTEVDVE9SX0NMQVNTJ1xuXHRcdFx0XHRcdHdoZW4gJyMnIHRoZW4gJ1NFTEVDVE9SX0lEJ1xuXHRcdFx0XHRcdHdoZW4gJzonIHRoZW4gJ1NFTEVDVE9SX1BTRVVET19DTEFTUydcblx0XHRcdFx0XHR3aGVuICc6OicgdGhlbiAnU0VMRUNUT1JfUFNFVURPX0NMQVNTJ1xuXHRcdFx0XHRcdGVsc2UgJ1NFTEVDVE9SX1RBRydcblxuXHRcdFx0XHR0b2tlbiB0b2tpZCwgbWF0Y2hbMl0sIG1hdGNoWzBdOmxlbmd0aFxuXHRcdFx0XHRyZXR1cm4gbWF0Y2hbMF06bGVuZ3RoXG5cblx0XHRcdCMgZWxpZiBtYXRjaCA9IFNFTEVDVE9SX1BTRVVET19DTEFTUy5leGVjKEBjaHVuaylcblx0XHRcdCMgIHRva2VuIHRva2lkLCBtYXRjaFsyXVxuXHRcdFx0IyAgcmV0dXJuIG1hdGNoWzBdOmxlbmd0aFxuXHRcdFx0XG5cdFx0XHRlbGlmIGNociA9PSAnWydcblx0XHRcdFx0dG9rZW4oJ1snLCdbJywxKVxuXHRcdFx0XHRzZWxmLnB1c2hFbmQoJ10nKVxuXHRcdFx0XHRpZiBtYXRjaCA9IFNFTEVDVE9SX0FUVFIuZXhlYyhAY2h1bmspXG5cdFx0XHRcdFx0IyBmdWNrIHRoaXMgbGVuZ3RoIHNoaXRcblx0XHRcdFx0XHR2YXIgaWRvZmZzZXQgPSBtYXRjaFswXS5pbmRleE9mKG1hdGNoWzFdKVxuXHRcdFx0XHRcdHZhciBvcG9mZnNldCA9IG1hdGNoWzBdLmluZGV4T2YobWF0Y2hbMl0pXG5cdFx0XHRcdFx0dG9rZW4oJ0lERU5USUZJRVInLCBtYXRjaFsxXSwgbWF0Y2hbMV06bGVuZ3RoLCBpZG9mZnNldClcblx0XHRcdFx0XHR0b2tlbignU0VMRUNUT1JfQVRUUl9PUCcsIG1hdGNoWzJdLCBtYXRjaFsyXTpsZW5ndGgsIG9wb2Zmc2V0KVxuXHRcdFx0XHRcdHJldHVybiBtYXRjaFswXTpsZW5ndGhcblx0XHRcdFx0cmV0dXJuIDFcblxuXHRcdFx0ZWxpZiBjaHIgPT0gJ3wnXG5cdFx0XHRcdHZhciB0b2sgPSBAdG9rZW5zW0B0b2tlbnM6bGVuZ3RoIC0gMV1cblx0XHRcdFx0dFRzKHRvaywnU0VMRUNUT1JfTlMnKVxuXHRcdFx0XHQjIHRva1swXSA9ICdTRUxFQ1RPUl9OUycgIyBGSVhcblx0XHRcdFx0cmV0dXJuIDFcblxuXHRcdFx0ZWxpZiBjaHIgPT0gJywnXG5cdFx0XHRcdHRva2VuKCdTRUxFQ1RPUl9HUk9VUCcsJywnLDEpXG5cdFx0XHRcdHJldHVybiAxXG5cdFx0XHRlbGlmIGNociA9PSAnKidcblx0XHRcdFx0dG9rZW4oJ1VOSVZFUlNBTF9TRUxFQ1RPUicsJyonLDEpXG5cdFx0XHRcdHJldHVybiAxXG5cdFx0XHRcblx0XHRcdGVsaWYgY2hyID09ICcpJ1xuXHRcdFx0XHRwYWlyICclJ1xuXHRcdFx0XHR0b2tlbignU0VMRUNUT1JfRU5EJywnKScsMSlcblx0XHRcdFx0cmV0dXJuIDFcblxuXHRcdFx0ZWxpZiBjaHIgaW4gWycpJywnfScsJ10nLCcnXVxuXHRcdFx0XHRwYWlyICclJ1xuXHRcdFx0XHRyZXR1cm4gMFxuXG5cdFx0cmV0dXJuIDAgdW5sZXNzIG1hdGNoID0gU0VMRUNUT1IuZXhlYyhAY2h1bmspXG5cdFx0dmFyIFtpbnB1dCwgaWQsIGtpbmRdID0gbWF0Y2hcblxuXHRcdCMgdGhpcyBpcyBhIGNsb3NlZCBzZWxlY3RvclxuXHRcdGlmIGtpbmQgPT0gJygnXG5cdFx0XHQjIHRva2VuICcoJywnKCdcblx0XHRcdHRva2VuICdTRUxFQ1RPUl9TVEFSVCcsIGlkLCBpZDpsZW5ndGggKyAxXG5cdFx0XHQjIHNlbGYucHVzaEVuZCgnKScpICMgYXJlIHdlIHNvIHN1cmUgYWJvdXQgdGhpcz9cblx0XHRcdHNlbGYucHVzaEVuZCgnJScpXG5cblx0XHRcdCMgQGVuZHMucHVzaCAnKSdcblx0XHRcdCMgQGVuZHMucHVzaCAnJSdcblx0XHRcdHJldHVybiBpZDpsZW5ndGggKyAxXG5cblx0XHRlbGlmIGlkID09ICclJ1xuXHRcdFx0IyB3ZSBhcmUgYWxyZWFkeSBzY29wZWQgaW4gb24gYSBzZWxlY3RvclxuXHRcdFx0cmV0dXJuIDEgaWYgY29udGV4dCA9PSAnJSdcblx0XHRcdHRva2VuICdTRUxFQ1RPUl9TVEFSVCcsIGlkLCBpZDpsZW5ndGhcblx0XHRcdCMgdGhpcyBpcyBhIHNlcGFyYXRlIC0gc2NvcGUuIEZ1bGwgc2VsZWN0b3Igc2hvdWxkIHJhdGhlciBiZSAkLCBhbmQga2VlcCB0aGUgc2luZ2xlIHNlbGVjdG9yIGFzICVcblx0XHRcblx0XHRcdHNjb3BlKCclJywgb3BlbjogeWVzKVxuXHRcdFx0IyBAZW5kcy5wdXNoICclJ1xuXHRcdFx0IyBtYWtlIHN1cmUgYSB0ZXJtaW5hdG9yIGJyZWFrcyBvdXRcblx0XHRcdHJldHVybiBpZDpsZW5ndGhcblx0XHRlbHNlXG5cdFx0XHRyZXR1cm4gMFxuXHRcblx0IyBpcyB0aGlzIHJlYWxseSBuZWVkZWQ/IFNob3VsZCBiZSBwb3NzaWJsZSB0b1xuXHQjIHBhcnNlIHRoZSBpZGVudGlmaWVycyBhbmQgPSBldGMgaSBqaXNvbj9cblx0IyB3aGF0IGlzIHNwZWNpYWwgYWJvdXQgbWV0aG9kTmFtZVRva2VuPyByZWFsbHk/XG5cdGRlZiBtZXRob2ROYW1lVG9rZW5cblx0XHQjIHdlIGNhbiBvcHRpbWl6ZSB0aGlzIGJ5IGFmdGVyIGEgZGVmIHNpbXBseVxuXHRcdCMgZmV0Y2hpbmcgYWxsIHRoZSB3YXkgYWZ0ZXIgdGhlIGRlZiB1bnRpbCBhIHNwYWNlIG9yIChcblx0XHQjIGFuZCB0aGVuIGFkZCB0aGlzIHRvIHRoZSBkZWYtdG9rZW4gaXRzZWxmIChhcyB3aXRoIGZyYWdtZW50KVxuXHRcdHJldHVybiAwIGlmIEBjaHVuay5jaGFyQXQoMCkgPT0gJyAnXG5cblx0XHR2YXIgbWF0Y2hcblxuXHRcdGlmIEBlbmQgPT0gJyknXG5cdFx0XHR2YXIgb3V0ZXJjdHggPSBAZW5kc1tAZW5kczpsZW5ndGggLSAyXVxuXHRcdFx0IyB3ZWlyZCBhc3N1bXB0aW9uLCBubz9cblx0XHRcdCMgY29uc29sZS5sb2cgJ2NvbnRleHQgaXMgaW5zaWRlISEhJ1xuXHRcdFx0aWYgb3V0ZXJjdHggPT0gJyUnIGFuZCBtYXRjaCA9IFRBR19BVFRSLmV4ZWMoQGNodW5rKVxuXHRcdFx0XHR0b2tlbignVEFHX0FUVFJfU0VUJyxtYXRjaFsxXSlcblx0XHRcdFx0cmV0dXJuIG1hdGNoWzBdOmxlbmd0aFxuXG5cdFx0dW5sZXNzIG1hdGNoID0gTUVUSE9EX0lERU5USUZJRVIuZXhlYyhAY2h1bmspXG5cdFx0XHRyZXR1cm4gMFx0XHRcdFxuXHRcdCMgdmFyIHByZXYgPSBsYXN0IEB0b2tlbnNcblx0XHR2YXIgbGVuZ3RoID0gbWF0Y2hbMF06bGVuZ3RoXG5cdFx0XG5cdFx0dmFyIGlkID0gbWF0Y2hbMF1cblx0XHR2YXIgbHR5cCA9IEBsYXN0VHlwXG5cdFx0dmFyIHR5cCA9ICdJREVOVElGSUVSJ1xuXHRcdHZhciBwcmUgPSBpZC5jaGFyQXQoMClcblx0XHR2YXIgc3BhY2UgPSBub1xuXG5cdFx0dmFyIG00ID0gbWF0Y2hbNF0gIyBtaWdodCBiZSBvdXQgb2YgYm91bmRzPyBzaG91bGQgcmF0aGVyIGNoZWNrIGNoYXJBdFxuXHRcdCMgZHJvcCBtYXRjaCA0Pz9cblxuXHRcdCMgc2hvdWxkIHRoaXMgbm90IHF1aXQgaGVyZSBpbiBwcmFjdGljYWxseSBhbGwgY2FzZXM/XG5cdFx0dW5sZXNzIChsdHlwID09ICcuJyBvciBsdHlwID09ICdERUYnKSBvciAobTQgPT0gJyEnIG9yIG00ID09ICc/Jykgb3IgbWF0Y2hbNV1cblx0XHRcdHJldHVybiAwXG5cblx0XHQjIGFnYWluLCB3aHk/XG5cdFx0aWYgaWQgPT0gJ3NlbGYnIG9yIGlkID09ICd0aGlzJyBvciBpZCA9PSAnc3VwZXInICMgaW4gWydTRUxGJywnVEhJUyddXG5cdFx0XHRyZXR1cm4gMFxuXG5cdFx0aWYgaWQgPT0gJ25ldydcblx0XHRcdHR5cCA9ICdORVcnXG5cblx0XHRpZiBpZCA9PSAnLi4uJyBhbmQgWycsJywnKCcsJ0NBTExfU1RBUlQnLCdCTE9DS19QQVJBTV9TVEFSVCcsJ1BBUkFNX1NUQVJUJ10uaW5kZXhPZihsdHlwKSA+PSAwXG5cdFx0XHRyZXR1cm4gMFxuXG5cdFx0aWYgaWQgPT0gJ3wnXG5cdFx0XHQjIGhhY2t5IHdheSB0byBpbXBsZW1lbnQgdGhpc1xuXHRcdFx0IyB3aXRoIG5ldyBsZXhlciB3ZSdsbCB1c2UgeyAuLi4gfSBpbnN0ZWFkLCBhbmQgYXNzdW1lIG9iamVjdC1jb250ZXh0LFxuXHRcdFx0IyB0aGVuIGdvIGJhY2sgYW5kIGNvcnJlY3Qgd2hlbiB3ZSBzZWUgdGhlIGNvbnRleHQgaXMgaW52YWxpZFxuXHRcdFx0aWYgbHR5cCA9PSAnKCcgb3IgbHR5cCA9PSAnQ0FMTF9TVEFSVCdcblx0XHRcdFx0dG9rZW4oJ0RPJywgJ0RPJywwKVxuXHRcdFx0XHRzZWxmLnB1c2hFbmQoJ3wnKVxuXHRcdFx0XHQjIEBlbmRzLnB1c2ggJ3wnXG5cdFx0XHRcdHRva2VuKCdCTE9DS19QQVJBTV9TVEFSVCcsIGlkLDEpXG5cdFx0XHRcdHJldHVybiBsZW5ndGhcblxuXHRcdFx0ZWxpZiBsdHlwID09ICdETycgb3IgbHR5cCA9PSAneydcblx0XHRcdFx0IyBAZW5kcy5wdXNoICd8J1xuXHRcdFx0XHRzZWxmLnB1c2hFbmQoJ3wnKVxuXHRcdFx0XHR0b2tlbignQkxPQ0tfUEFSQU1fU1RBUlQnLCBpZCwxKVxuXHRcdFx0XHRyZXR1cm4gbGVuZ3RoXG5cdFx0XHRcdFxuXHRcdFx0ZWxpZiBAZW5kc1tAZW5kczpsZW5ndGggLSAxXSA9PSAnfCdcblx0XHRcdFx0dG9rZW4oJ0JMT0NLX1BBUkFNX0VORCcsICd8JywxKVxuXHRcdFx0XHRwYWlyICd8J1xuXHRcdFx0XHRyZXR1cm4gbGVuZ3RoXG5cdFx0XHRlbHNlXG5cdFx0XHRcdHJldHVybiAwXG5cblx0XHQjIHdoYWF0P1xuXHRcdCMgY29uc29sZS5sb2coXCJtZXRob2QgaWRlbnRpZmllclwiLGlkKVxuXHRcdGlmIChbJyYnLCdeJywnPDwnLCc8PDwnLCc+PiddLmluZGV4T2YoaWQpID49IDAgb3IgKGlkID09ICd8JyBhbmQgY29udGV4dCAhPSAnfCcpKVxuXHRcdFx0cmV0dXJuIDBcblxuXHRcdGlmIE9QX01FVEhPRFMuaW5kZXhPZihpZCkgPj0gMFxuXHRcdFx0c3BhY2UgPSB5ZXNcblxuXHRcdCMgbm90IGV2ZW4gYW55dGhpbmcgd2Ugc2hvdWxkIHVzZT8hP1xuXHRcdGlmIHByZSA9PSAnQCdcblx0XHRcdHR5cCA9ICdJVkFSJ1xuXG5cdFx0ZWxpZiBwcmUgPT0gJyQnXG5cdFx0XHR5ZXNcblx0XHRcdCMgdHlwID0gJ0dWQVInXG5cblxuXHRcdGVsaWYgcHJlID09ICcjJ1xuXHRcdFx0dHlwID0gJ1RBR0lEJ1xuXG5cdFx0ZWxpZiBDT05TVF9JREVOVElGSUVSLnRlc3QocHJlKSBvciBpZCA9PSAncmVxdWlyZScgb3IgaWQgPT0gJ2dsb2JhbCcgb3IgaWQgPT0gJ2V4cG9ydHMnXG5cdFx0XHQjIHJlYWxseT8gc2VlbXMgdmVyeSBzdHJhbmdlXG5cdFx0XHQjIGNvbnNvbGUubG9nKCdnbG9iYWwhIScsdHlwLGlkKVxuXHRcdFx0dHlwID0gJ0NPTlNUJ1xuXHRcdFxuXHRcdCMgd2hhdCBpcyB0aGlzIHJlYWxseSBmb3I/XG5cdFx0aWYgbWF0Y2hbNV0gYW5kIFsnSURFTlRJRklFUicsJ0NPTlNUJywnR1ZBUicsJ0NWQVInLCdJVkFSJywnU0VMRicsJ1RISVMnLCddJywnfScsJyknLCdOVU1CRVInLCdTVFJJTkcnLCdJRFJFRiddLmluZGV4T2YobHR5cCkgPj0gMFxuXHRcdFx0dG9rZW4oJy4nLCcuJywwKVxuXHRcblx0XHR0b2tlbih0eXAsIGlkLCBsZW5ndGgpXG5cblx0XHRpZiBzcGFjZVxuXHRcdFx0QGxhc3Q6c3BhY2VkID0geWVzXG5cblx0XHRyZXR1cm4gbGVuZ3RoXG5cblxuXHRkZWYgaW5UYWdcblx0XHR2YXIgbGVuID0gQGVuZHM6bGVuZ3RoXG5cdFx0aWYgbGVuID4gMFxuXHRcdFx0dmFyIGN0eDAgPSBAZW5kc1tsZW4gLSAxXVxuXHRcdFx0dmFyIGN0eDEgPSBsZW4gPiAxID8gQGVuZHNbbGVuIC0gMl0gOiBjdHgwXG5cdFx0XHRyZXR1cm4gY3R4MCA9PSAnVEFHX0VORCcgb3IgKGN0eDEgPT0gJ1RBR19FTkQnIGFuZCBjdHgwID09ICdPVVRERU5UJylcblx0XHRyZXR1cm4gZmFsc2VcblxuXHRkZWYgaXNLZXl3b3JkIGlkXG5cdFx0aWYgKGlkID09ICdhdHRyJyBvciBpZCA9PSAncHJvcCcpXG5cdFx0XHR2YXIgc2NvcCA9IGdldFNjb3BlXG5cdFx0XHR2YXIgaW5jbHMgPSBzY29wID09ICdDTEFTUycgb3Igc2NvcCA9PSAnVEFHJ1xuXHRcdFx0IyB2YXIgc2NvcGVzID0gQGluZGVudHMubWFwKHxpbmQsaXwgQHNjb3Blc1tpXSBvciAnTk9ORScpXG5cdFx0XHQjIGNvbnNvbGUubG9nIFwiaWQgaXMgcHJvcDoge3Njb3Blcy5qb2luKFwiIC0+IFwiKX0gfCB7QGluZGVudHMuam9pbihcIiAtPiBcIil9XCJcblx0XHRcdHJldHVybiB0cnVlIGlmIGluY2xzXG5cblx0XHRBTExfS0VZV09SRFMuaW5kZXhPZihpZCkgPj0gMFxuXG5cdCMgTWF0Y2hlcyBpZGVudGlmeWluZyBsaXRlcmFsczogdmFyaWFibGVzLCBrZXl3b3JkcywgbWV0aG9kIG5hbWVzLCBldGMuXG5cdCMgQ2hlY2sgdG8gZW5zdXJlIHRoYXQgSmF2YVNjcmlwdCByZXNlcnZlZCB3b3JkcyBhcmVuJ3QgYmVpbmcgdXNlZCBhc1xuXHQjIGlkZW50aWZpZXJzLiBCZWNhdXNlIEltYmEgcmVzZXJ2ZXMgYSBoYW5kZnVsIG9mIGtleXdvcmRzIHRoYXQgYXJlXG5cdCMgYWxsb3dlZCBpbiBKYXZhU2NyaXB0LCB3ZSdyZSBjYXJlZnVsIG5vdCB0byB0b2tpZCB0aGVtIGFzIGtleXdvcmRzIHdoZW5cblx0IyByZWZlcmVuY2VkIGFzIHByb3BlcnR5IG5hbWVzIGhlcmUsIHNvIHlvdSBjYW4gc3RpbGwgZG8gYGpRdWVyeS5pcygpYCBldmVuXG5cdCMgdGhvdWdoIGBpc2AgbWVhbnMgYD09PWAgb3RoZXJ3aXNlLlxuXHRkZWYgaWRlbnRpZmllclRva2VuXG5cdFx0dmFyIG1hdGNoXG5cblx0XHR2YXIgY3R4MCA9IEBlbmRzW0BlbmRzOmxlbmd0aCAtIDFdXG5cdFx0dmFyIGN0eDEgPSBAZW5kc1tAZW5kczpsZW5ndGggLSAyXVxuXHRcdHZhciBpbm5lcmN0eCA9IGN0eDBcblx0XHR2YXIgdHlwXG5cdFx0dmFyIHJlc2VydmVkID0gbm9cblxuXHRcdHZhciBhZGRMb2MgPSBmYWxzZVxuXHRcdHZhciBpblRhZyA9IGN0eDAgPT0gJ1RBR19FTkQnIG9yIChjdHgxID09ICdUQUdfRU5EJyBhbmQgY3R4MCA9PSAnT1VUREVOVCcpXG5cblx0XHQjIGNvbnNvbGUubG9nIGN0eDEsY3R4MFxuXHRcblx0XHRpZiBpblRhZyAmJiBtYXRjaCA9IFRBR19BVFRSLmV4ZWMoQGNodW5rKVxuXHRcdFx0IyBjb25zb2xlLmxvZyAnVEFHX0FUVFIgSU4gdG9raWQnLG1hdGNoXG5cdFx0XHQjIHZhciBwcmV2ID0gbGFzdCBAdG9rZW5zXG5cdFx0XHQjIGlmIHRoZSBwcmV2IGlzIGEgdGVybWluYXRvciwgd2UgZG9udCByZWFsbHkgbmVlZCB0byBjYXJlP1xuXHRcdFx0aWYgQGxhc3RUeXAgIT0gJ1RBR19OQU1FJ1xuXHRcdFx0XHRpZiBAbGFzdFR5cCA9PSAnVEVSTUlOQVRPUidcblx0XHRcdFx0XHQjIGNvbnNvbGUubG9nKCdwcmV2IHdhcyB0ZXJtaW5hdG9yIC0tIGRyb3AgaXQ/Jylcblx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHR0b2tlbihcIixcIiwgXCIsXCIpXG5cblx0XHRcdHZhciBsID0gbWF0Y2hbMF06bGVuZ3RoXG5cblx0XHRcdHRva2VuICdUQUdfQVRUUicsbWF0Y2hbMV0sbCAtIDEgICMgYWRkIHRvIGxvYz9cblx0XHRcdEBsb2MgKz0gbCAtIDFcblx0XHRcdHRva2VuICc9JywnPScsMVxuXHRcdFx0cmV0dXJuIGxcblxuXHRcdCMgc2VlIGlmIHRoaXMgaXMgYSBwbGFpbiBvYmplY3Qta2V5XG5cdFx0IyB3YXkgdG9vIG11Y2ggbG9naWMgZ29pbmcgb24gaGVyZT9cblx0XHQjIHRoZSBhc3Qgc2hvdWxkIG5vcm1hbGl6ZSB3aGV0aGVyIGtleXNcblx0XHQjIGFyZSBhY2Nlc3NhYmxlIGFzIGtleXMgb3Igc3RyaW5ncyBldGNcblx0XHRpZiBtYXRjaCA9IE9CSkVDVF9LRVkuZXhlYyhAY2h1bmspXG5cdFx0XHR2YXIgaWQgPSBtYXRjaFsxXVxuXHRcdFx0dmFyIHR5cCA9ICdJREVOVElGSUVSJ1xuXG5cdFx0XHQjIEZJWE1FIGxvYyBvZiBrZXkgaW5jbHVkZXMgY29sb25cblx0XHRcdCMgbW92ZUNhcmV0KGlkOmxlbmd0aClcblx0XHRcdCMgY29uc29sZS5sb2cgXCJva1wiXG5cdFx0XHRpZiB0cnVlXG5cdFx0XHRcdCMgY29uc29sZS5sb2cgXCJnb3QgaGVyZT8ge21hdGNofVwiXG5cdFx0XHRcdHRva2VuKHR5cCwgaWQsIGlkOmxlbmd0aClcblx0XHRcdFx0bW92ZUNhcmV0KGlkOmxlbmd0aClcblx0XHRcdFx0dG9rZW4gJzonLCAnOicsIG1hdGNoWzNdOmxlbmd0aFxuXHRcdFx0XHRtb3ZlQ2FyZXQoLWlkOmxlbmd0aClcblx0XHRcdFx0IyBtb3ZlQ2FyZXQobWF0Y2hbM106bGVuZ3RoKVxuXHRcdFx0XHRyZXR1cm4gbWF0Y2hbMF06bGVuZ3RoXG5cblx0XHRcdCMgbW92ZUNhcmV0KG1hdGNoWzJdOmxlbmd0aClcblx0XHRcdCMgcmV0dXJuIDBcblx0XHRcdCMgY29uc29sZS5sb2cgbWF0Y2hbM106bGVuZ3RoXG5cdFx0XHR0b2tlbiB0eXAsIGlkLCBtYXRjaFswXTpsZW5ndGhcblx0XHRcdHRva2VuICc6JywgJzonLDFcblx0XHRcdHJldHVybiBtYXRjaFswXTpsZW5ndGhcblxuXHRcdHVubGVzcyBtYXRjaCA9IElERU5USUZJRVIuZXhlYyhAY2h1bmspXG5cdFx0XHRyZXR1cm4gMFxuXG5cdFx0dmFyIFtpbnB1dCwgaWQsIHR5cCwgbTMsIG00LCBjb2xvbl0gPSBtYXRjaFxuXHRcdHZhciBpZGxlbiA9IGlkOmxlbmd0aFxuXG5cdFx0IyBXaGF0IGlzIHRoZSBsb2dpYyBoZXJlP1xuXHRcdGlmIGlkIGlzICdvd24nIGFuZCBsYXN0VG9rZW5UeXBlID09ICdGT1InXG5cdFx0XHR0b2tlbiAnT1dOJywgaWQsIGlkOmxlbmd0aFxuXHRcdFx0cmV0dXJuIGlkOmxlbmd0aFxuXG5cdFx0dmFyIHByZXYgPSBsYXN0KEB0b2tlbnMpXG5cdFx0dmFyIGxhc3RUeXAgPSBAbGFzdFR5cFxuXG5cdFx0IyBzaG91bGQgd2UgZm9yY2UgdGhpcyB0byBiZSBhbiBpZGVudGlmaWVyIGV2ZW4gaWYgaXQgaXMgYSByZXNlcnZlZCB3b3JkP1xuXHRcdCMgdGhpcyBzaG91bGQgb25seSBoYXBwZW4gZm9yIHdoZW4gcGFydCBvZiBvYmplY3QgZXRjXG5cdFx0IyB3aWxsIHByZXYgZXZlciBiZSBAPz8/XG5cdFx0dmFyIGZvcmNlZElkZW50aWZpZXJcblxuXHRcdCMgYWdhaW5cblx0XHRmb3JjZWRJZGVudGlmaWVyID0gY29sb24gfHwgbGFzdFR5cCA9PSAnLicgb3IgbGFzdFR5cCA9PSAnPy4nICMgaW4gWycuJywgJz8uJ1xuXG5cblx0XHQjIHRlbXAgaGFjayEgbmVlZCB0byBzb2x2ZSBmb3Igb3RoZXIga2V5d29yZHMgZXRjIGFzIHdlbGxcblx0XHQjIHByb2JsZW0gYXBwZWFycyB3aXRoIHRlcm5hcnkgY29uZGl0aW9ucy5cblxuXHRcdCMgd2VsbCAtLSBpdCBzaG91bGQgc3RpbGwgYmUgYW4gaW5kZW50aWZpZXIgaWYgaW4gb2JqZWN0P1xuXHRcdCMgZm9yY2VkSWRlbnRpZmllciA9IG5vIGlmIGlkIGluIFsndW5kZWZpbmVkJywnYnJlYWsnXVxuXG5cdFx0Zm9yY2VkSWRlbnRpZmllciA9IG5vIGlmIGNvbG9uIGFuZCBsYXN0VHlwID09ICc/JyAjIGZvciB0ZXJuYXJ5XG5cblx0XHQjIGlmIHdlIGFyZSBub3QgYXQgdGhlIHRvcCBsZXZlbD8gLS0gaGFja3lcblx0XHRpZiBpZCA9PSAndGFnJyBhbmQgQGNodW5rLmluZGV4T2YoXCJ0YWcoXCIpID09IDAgIyBAY2h1bmsubWF0Y2goL150b2tpZFxcKC8pXG5cdFx0XHRmb3JjZWRJZGVudGlmaWVyID0geWVzXG5cblx0XHR2YXIgaXNLZXl3b3JkID0gbm9cblxuXHRcdCMgY29uc29sZS5sb2cgXCJtYXRjaFwiLG1hdGNoXG5cdFx0IyBjb25zb2xlLmxvZyBcInR5cCBpcyB7dHlwfVwiXG5cdFx0IyBsaXR0bGUgcmVhc29uIHRvIGNoZWNrIGZvciB0aGlzIHJpZ2h0IGhlcmU/IGJ1dCBJIGd1ZXNzIGl0IGlzIG9ubHkgYSBzaW1wbGUgY2hlY2tcblx0XHRpZiB0eXAgPT0gJyQnIGFuZCBBUkdWQVIudGVzdChpZCkgIyBpZC5tYXRjaCgvXlxcJFxcZCQvKVxuXHRcdFx0IyBjb25zb2xlLmxvZyBcIlRZUCAkXCJcblx0XHRcdGlmIGlkID09ICckMCdcblx0XHRcdFx0dHlwID0gJ0FSR1VNRU5UUydcblx0XHRcdGVsc2Vcblx0XHRcdFx0dHlwID0gJ0FSR1ZBUidcblx0XHRcdFx0aWQgPSBpZC5zdWJzdHIoMSlcblxuXHRcdGVsaWYgdHlwID09ICdAJ1xuXHRcdFx0dHlwID0gJ0lWQVInXG5cblx0XHRcdCMgaWQ6cmVzZXJ2ZWQgPSB5ZXMgaWYgY29sb25cblx0XHRlbGlmIHR5cCA9PSAnIydcblx0XHRcdCMgd2UgYXJlIHRyeWluZyB0byBtb3ZlIHRvIGdlbmVyaWMgdG9rZW5zLFxuXHRcdFx0IyBzbyB3ZSBhcmUgc3RhcnRpbmcgdG8gc3BsaXR0aW5nIHVwIHRoZSBzeW1ib2xzIGFuZCB0aGUgaXRlbXNcblx0XHRcdCMgd2UnbGwgc2VlIGlmIHRoYXQgd29ya3Ncblx0XHRcdHR5cCA9ICdJREVOVElGSUVSJ1xuXHRcdFx0dG9rZW4gJyMnLCAnIydcblx0XHRcdGlkID0gaWQuc3Vic3RyKDEpXG5cblx0XHRlbGlmIHR5cCA9PSAnQEAnXG5cdFx0XHR0eXAgPSAnQ1ZBUidcblxuXHRcdGVsaWYgdHlwID09ICckJyBhbmQgIWNvbG9uXG5cdFx0XHR0eXAgPSAnSURFTlRJRklFUidcblx0XHRcdCMgdHlwID0gJ0dWQVInXG5cblx0XHRlbGlmIENPTlNUX0lERU5USUZJRVIudGVzdChpZCkgb3IgaWQgPT0gJ3JlcXVpcmUnIG9yIGlkID09ICdnbG9iYWwnIG9yIGlkID09ICdleHBvcnRzJ1xuXHRcdFx0IyB0aG91cyBzaG91bGQgcmVhbGx5IGJlIGhhbmRsZWQgYnkgdGhlIGFzdCBpbnN0ZWFkXG5cdFx0XHR0eXAgPSAnQ09OU1QnXG5cblx0XHRlbGlmIGlkID09ICdlbGlmJ1xuXHRcdFx0dG9rZW4gJ0VMU0UnLCAnZWxpZicsIGlkOmxlbmd0aFxuXHRcdFx0dG9rZW4gJ0lGJywgJ2lmJ1xuXHRcdFx0cmV0dXJuIGlkOmxlbmd0aFxuXG5cdFx0ZWxzZVxuXHRcdFx0dHlwID0gJ0lERU5USUZJRVInXG5cblxuXG5cdFx0IyB0aGlzIGNhdGNoZXMgYWxsIFxuXHRcdGlmICFmb3JjZWRJZGVudGlmaWVyIGFuZCBpc0tleXdvcmQgPSBzZWxmLmlzS2V5d29yZChpZClcblx0XHRcdCMgKGlkIGluIEpTX0tFWVdPUkRTIG9yIGlkIGluIElNQkFfS0VZV09SRFMpXG5cdFx0XHR0eXAgPSBpZC50b1VwcGVyQ2FzZVxuXHRcdFx0YWRkTG9jID0gdHJ1ZVxuXG5cdFx0XHQjIGNsdW1zeSAtIGJ1dCB0ZXN0aW5nIHBlcmZvcm1hbmNlXG5cdFx0XHRpZiB0eXAgPT0gJ1lFUydcblx0XHRcdFx0dHlwID0gJ1RSVUUnXG5cdFx0XHRlbGlmIHR5cCA9PSAnTk8nXG5cdFx0XHRcdHR5cCA9ICdGQUxTRSdcblx0XHRcdGVsaWYgdHlwID09ICdOSUwnXG5cdFx0XHRcdHR5cCA9ICdOVUxMJ1xuXG5cdFx0XHRlbGlmIHR5cCA9PSAnVkFSJ1xuXHRcdFx0XHRpZiBAbGFzdFZhbCA9PSAnZXhwb3J0J1xuXHRcdFx0XHRcdHRUcyhwcmV2LCdFWFBPUlQnKVxuXG5cdFx0XHQjIHNraXBwaW5nIFxuXHRcdFx0ZWxpZiB0eXAgPT0gJ0lGJyBvciB0eXAgPT0gJ0VMU0UnIG9yIHR5cCA9PSAnVFJVRScgb3IgdHlwID09ICdGQUxTRScgb3IgdHlwID09ICdOVUxMJ1xuXHRcdFx0XHR0cnVlXG5cdFx0XHRlbGlmIHR5cCA9PSAnVEFHJ1xuXHRcdFx0XHRzZWxmLnB1c2hFbmQoJ1RBRycpXG5cdFx0XHRcdCMgQGVuZHMucHVzaCgnVEFHJylcblx0XHRcdCMgRklYTUUgQGVuZHMgaXMgbm90IHVzZWQgdGhlIHdheSBpdCBpcyBzdXBwb3NlZCB0by4uXG5cdFx0XHQjIHdoYXQgd2Ugd2FudCBpcyBhIGNvbnRleHQtc3RhY2tcblx0XHRcdGVsaWYgdHlwID09ICdERUYnXG5cdFx0XHRcdCMgc2hvdWxkIHByb2JhYmx5IHNoaWZ0IGNvbnRleHQgYW5kIG9wdGltaXplIHRoaXNcblx0XHRcdFx0b3BlbkRlZlxuXG5cdFx0XHRlbGlmIHR5cCA9PSAnRE8nXG5cdFx0XHRcdGNsb3NlRGVmIGlmIGNvbnRleHQgPT0gJ0RFRidcblxuXHRcdFx0ZWxpZiB0eXAgaXMgJ1dIRU4nIGFuZCBMSU5FX0JSRUFLLmluZGV4T2YobGFzdFRva2VuVHlwZSkgPj0gMFxuXHRcdFx0XHR0eXAgPSAnTEVBRElOR19XSEVOJ1xuXG5cdFx0XHRlbGlmIHR5cCBpcyAnRk9SJ1xuXHRcdFx0XHRAc2VlbkZvciA9IHllc1xuXG5cdFx0XHRlbGlmIHR5cCBpcyAnVU5MRVNTJ1xuXHRcdFx0XHR0eXAgPSAnSUYnICMgV0FSTlxuXG5cdFx0XHRlbGlmIFVOQVJZLmluZGV4T2YodHlwKSA+PSAwXG5cdFx0XHRcdHR5cCA9ICdVTkFSWSdcblxuXHRcdFx0ZWxpZiBSRUxBVElPTi5pbmRleE9mKHR5cCkgPj0gMFxuXHRcdFx0XHRpZiB0eXAgIT0gJ0lOU1RBTkNFT0YnIGFuZCB0eXAgIT0gJ0lTQScgYW5kIEBzZWVuRm9yXG5cdFx0XHRcdFx0dHlwID0gJ0ZPUicgKyB0eXAgIyA/XG5cdFx0XHRcdFx0QHNlZW5Gb3IgPSBub1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0dHlwID0gJ1JFTEFUSU9OJ1xuXHRcdFx0XHRcdGlmIFN0cmluZyh2YWx1ZSkgPT0gJyEnXG5cdFx0XHRcdFx0XHRAdG9rZW5zLnBvcCAjIGlzIGZ1Y2tlZCB1cD8/IVxuXHRcdFx0XHRcdFx0IyBXQVJOIHdlIG5lZWQgdG8ga2VlcCB0aGUgbG9jLCBubz9cblx0XHRcdFx0XHRcdGlkID0gJyEnICsgaWRcblxuXHRcdGlmIGlkID09ICdzdXBlcidcblx0XHRcdHR5cCA9ICdTVVBFUidcblxuXHRcdCMgZG8gd2UgcmVhbGx5IHdhbnQgdG8gY2hlY2sgdGhpcyBoZXJlXG5cdFx0aWYgIWZvcmNlZElkZW50aWZpZXJcblx0XHRcdCMgc2hvdWxkIGFscmVhZHkgaGF2ZSBkZWFsdCB3aXRoIHRoaXNcblxuXHRcdFx0aWQgPSBJTUJBX0FMSUFTX01BUFtpZF0gaWYgaXNLZXl3b3JkIGFuZCBJTUJBX0FMSUFTRVMuaW5kZXhPZihpZCkgPj0gMFxuXHRcdFx0IyB0aGVzZSByZWFsbHkgc2hvdWxkIG5vdCBnbyBoZXJlPyE/XG5cdFx0XHRzd2l0Y2ggaWRcblx0XHRcdFx0d2hlbiAnIScgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbiB0eXAgPSAnVU5BUlknXG5cdFx0XHRcdHdoZW4gJz09JywgJyE9JywgJz09PScsICchPT0nICAgICAgICAgICAgIHRoZW4gdHlwID0gJ0NPTVBBUkUnXG5cdFx0XHRcdHdoZW4gJyYmJywgJ3x8JyAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZW4gdHlwID0gJ0xPR0lDJ1xuXHRcdFx0XHR3aGVuICdicmVhaycsICdjb250aW51ZScsICdkZWJ1Z2dlcicsJ2FyZ3VtZW50cycgdGhlbiB0eXAgPSBpZC50b1VwcGVyQ2FzZVxuXHRcdFx0XHQjIHdoZW4gJ3RydWUnLCAnZmFsc2UnLCAnbnVsbCcsICd1bmRlZmluZWQnIHRoZW4gdHlwID0gJ0JPT0wnXG5cdFx0XHRcdCMgcmVhbGx5P1xuXG5cdFx0IyBwcmV2ID0gbGFzdCBAdG9rZW5zXG5cdFx0dmFyIGxlbiA9IGlucHV0Omxlbmd0aFxuXG5cdFx0IyBzaG91bGQgYmUgc3RyaWN0IGFib3V0IHRoZSBvcmRlciwgY2hlY2sgdGhpcyBtYW51YWxseSBpbnN0ZWFkXG5cdFx0aWYgdHlwID09ICdDTEFTUycgb3IgdHlwID09ICdERUYnIG9yIHR5cCA9PSAnVEFHJ1xuXHRcdFx0cXVldWVTY29wZSh0eXApXG5cblx0XHRcdHZhciBpID0gQHRva2VuczpsZW5ndGhcblxuXHRcdFx0d2hpbGUgaVxuXHRcdFx0XHR2YXIgcHJldiA9IEB0b2tlbnNbLS1pXVxuXHRcdFx0XHR2YXIgY3RybCA9IFwiXCIgKyB0VihwcmV2KVxuXHRcdFx0XHQjIGNvbnNvbGUubG9nKFwiY3RybCBpcyB7Y3RybH1cIilcblx0XHRcdFx0IyBuZWVkIHRvIGNvZXJjZSB0byBzdHJpbmcgYmVjYXVzZSBvZiBzdHVwaWQgQ1MgPT09XG5cdFx0XHRcdCMgY29uc29sZS5sb2coXCJwcmV2IGlzXCIscHJldlswXSxwcmV2WzFdKVxuXHRcdFx0XHRpZiBjdHJsIGluIElNQkFfQ09OVEVYVFVBTF9LRVlXT1JEU1xuXHRcdFx0XHRcdHRUcyhwcmV2LGN0cmwudG9VcHBlckNhc2UpXG5cdFx0XHRcdFx0IyBwcmV2WzBdID0gY3RybC50b1VwcGVyQ2FzZSAjIEZJWFxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0YnJlYWtcblxuXHRcdGVsaWYgdHlwID09ICdJRidcblx0XHRcdHF1ZXVlU2NvcGUodHlwKVxuXG5cdFx0ZWxpZiB0eXAgPT0gJ0lNUE9SVCdcblx0XHRcdCMgY291bGQgbWFudWFsbHkgcGFyc2UgdGhlIHdob2xlIHRpbmcgaGVyZT9cblx0XHRcdHB1c2hFbmQoJ0lNUE9SVCcpXG5cdFx0XHQjIEBlbmRzLnB1c2ggJ0lNUE9SVCdcblxuXHRcdGVsaWYgaWQgPT0gJ2Zyb20nIGFuZCBjdHgwID09ICdJTVBPUlQnXG5cdFx0XHR0eXAgPSAnRlJPTSdcblx0XHRcdHBhaXIgJ0lNUE9SVCdcblxuXHRcdCMgd2lsbCBiZSBtdWNoIGNsZWFuZXIgd2l0aCB0aGUgbmV3IGhhbmRtYWRlIGNvbWJpbmVkIGxleGVyK3BhcnNlclxuXHRcdCMgZm9yIG5vdyB3ZSBuZWVkIHRvIGRvIHNvbWUgdGVzdGluZ1xuXHRcdGVsaWYgaWQgPT0gJ2FzJyBhbmQgY3R4MCA9PSAnSU1QT1JUJ1xuXHRcdFx0dHlwID0gJ0FTJ1xuXHRcdFx0cGFpciAnSU1QT1JUJ1xuXG5cdFx0aWYgdHlwID09ICdJREVOVElGSUVSJ1xuXHRcdFx0IyBzZWUgaWYgcHJldmlvdXMgd2FzIGNhdGNoIC0tIGJlbG9uZ3MgaW4gcmV3cml0ZXI/XG5cdFx0XHRpZiBsYXN0VHlwID09ICdDQVRDSCdcblx0XHRcdFx0dHlwID0gJ0NBVENIX1ZBUidcblx0XHRcblx0XHRpZiBjb2xvblxuXHRcdFx0dG9rZW4odHlwLCBpZCwgaWRsZW4pXG5cdFx0XHRtb3ZlQ2FyZXQoaWRsZW4pXG5cdFx0XHQjIGNvbnNvbGUubG9nIFwiYWRkIGNvbG9uP1wiXG5cdFx0XHR0b2tlbignOicsICc6Jyxjb2xvbjpsZW5ndGgpXG5cdFx0XHRtb3ZlQ2FyZXQoLWlkbGVuKVxuXHRcdGVsc2Vcblx0XHRcdHRva2VuKHR5cCwgaWQsIGlkbGVuKVxuXG5cdFx0cmV0dXJuIGxlblxuXG5cdCMgTWF0Y2hlcyBudW1iZXJzLCBpbmNsdWRpbmcgZGVjaW1hbHMsIGhleCwgYW5kIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxuXHQjIEJlIGNhcmVmdWwgbm90IHRvIGludGVyZmVyZSB3aXRoIHJhbmdlcy1pbi1wcm9ncmVzcy5cblx0ZGVmIG51bWJlclRva2VuXG5cdFx0dmFyIG1hdGNoLCBudW1iZXIsIGxleGVkTGVuZ3RoXG5cblx0XHRyZXR1cm4gMCB1bmxlc3MgbWF0Y2ggPSBOVU1CRVIuZXhlYyhAY2h1bmspXG5cblx0XHRudW1iZXIgPSBtYXRjaFswXVxuXHRcdGxleGVkTGVuZ3RoID0gbnVtYmVyOmxlbmd0aFxuXG5cdFx0aWYgdmFyIGJpbmFyeUxpdGVyYWwgPSAvMGIoWzAxXSspLy5leGVjKG51bWJlcilcblx0XHRcdFxuXHRcdFx0bnVtYmVyID0gXCJcIiArIHBhcnNlSW50KGJpbmFyeUxpdGVyYWxbMV0sIDIpXG5cblx0XHR2YXIgcHJldiA9IGxhc3QoQHRva2VucylcblxuXHRcdGlmIG1hdGNoWzBdWzBdID09ICcuJyAmJiBwcmV2ICYmICFwcmV2OnNwYWNlZCAmJiBbJ0lERU5USUZJRVInLCcpJywnfScsJ10nLCdOVU1CRVInXS5pbmRleE9mKHRUKHByZXYpKSA+PSAwXG5cdFx0XHQjIGNvbnNvbGUubG9nIFwiZ290IGhlcmVcIlxuXHRcdFx0dG9rZW4gXCIuXCIsXCIuXCJcblx0XHRcdG51bWJlciA9IG51bWJlci5zdWJzdHIoMSlcblx0XHRcblxuXHRcdHRva2VuKCdOVU1CRVInLG51bWJlcixsZXhlZExlbmd0aClcblx0XHRyZXR1cm4gbGV4ZWRMZW5ndGhcblx0XG5cdGRlZiBzeW1ib2xUb2tlblxuXHRcdHZhciBtYXRjaCwgc3ltYm9sLCBwcmV2XG5cblx0XHRyZXR1cm4gMCB1bmxlc3MgbWF0Y2ggPSBTWU1CT0wuZXhlYyhAY2h1bmspXG5cdFx0c3ltYm9sID0gbWF0Y2hbMF0uc3Vic3RyKDEpXG5cdFx0cHJldiA9IGxhc3QoQHRva2VucylcblxuXHRcdCMgaXMgdGhpcyBhIHByb3BlcnR5LWFjY2Vzcz9cblx0XHQjIHNob3VsZCBpbnZlcnQgdGhpcyAtLSBvbmx5IGFsbG93IHdoZW4gcHJldiBJUyAuLiBcblx0XG5cdFx0IyA6IHNob3VsZCBiZSBhIHRva2VuIGl0c2VsZiwgd2l0aCBhIHNwZWNpZmljYXRpb24gb2Ygc3BhY2luZyAoTFIsUixMLE5PTkUpXG5cblx0XHQjIEZJWFxuXHRcdGlmIHByZXYgYW5kICFwcmV2OnNwYWNlZCBhbmQgdFQocHJldikgbm90IGluIFsnKCcsJ3snLCdbJywnLicsJ0NBTExfU1RBUlQnLCdJTkRFWF9TVEFSVCcsJywnLCc9JywnSU5ERU5UJywnVEVSTUlOQVRPUiddXG5cdFx0XHR0b2tlbiAnLjonLCc6JywgMVxuXHRcdFx0dmFyIHN5bSA9IHN5bWJvbC5zcGxpdCgvW1xcOlxcXFxcXC9dLylbMF0gIyByZWFsbHk/XG5cdFx0XHQjIHRva2VuICdTWU1CT0wnLCBcIicje3N5bWJvbH0nXCJcblx0XHRcdHRva2VuICdJREVOVElGSUVSJywgc3ltLCBzeW06bGVuZ3RoLCAxXG5cdFx0XHRyZXR1cm4gKHN5bTpsZW5ndGggKyAxKVxuXHRcdGVsc2Vcblx0XHRcdCMgdG9rZW4gJ1NZTUJPTCcsIFwiJyN7c3ltYm9sfSdcIlxuXHRcdFx0dG9rZW4gJ1NZTUJPTCcsIHN5bWJvbCwgbWF0Y2hbMF06bGVuZ3RoXG5cdFx0XHRtYXRjaFswXTpsZW5ndGhcblxuXHRkZWYgZXNjYXBlU3RyIHN0ciwgaGVyZWRvYywgcVxuXHRcdHN0ciA9IHN0ci5yZXBsYWNlIE1VTFRJTElORVIsIChoZXJlZG9jID8gJ1xcXFxuJyA6ICcnKVxuXHRcdGlmIHFcblx0XHRcdHZhciByID0gUmVnRXhwKFwiXFxcXFxcXFxbe3F9XVwiLFwiZ1wiKVxuXHRcdFx0c3RyID0gc3RyLnJlcGxhY2UocixxKVxuXHRcdFx0c3RyID0gc3RyLnJlcGxhY2UgUmVnRXhwKFwie3F9XCIsXCJnXCIpLCAnXFxcXCQmJ1xuXHRcdHJldHVybiBzdHJcblxuXHRcdCMgc3RyID0gc3RyLnJlcGxhY2UoTVVMVElMSU5FUiwgJ1xcXFxuJylcblx0XHQjIHN0ciA9IHN0ci5yZXBsYWNlKC9cXHQvZywgJ1xcXFx0Jylcblx0IyBNYXRjaGVzIHN0cmluZ3MsIGluY2x1ZGluZyBtdWx0aS1saW5lIHN0cmluZ3MuIEVuc3VyZXMgdGhhdCBxdW90YXRpb24gbWFya3Ncblx0IyBhcmUgYmFsYW5jZWQgd2l0aGluIHRoZSBzdHJpbmcncyBjb250ZW50cywgYW5kIHdpdGhpbiBuZXN0ZWQgaW50ZXJwb2xhdGlvbnMuXG5cdGRlZiBzdHJpbmdUb2tlblxuXHRcdHZhciBtYXRjaCwgc3RyaW5nXG5cblx0XHRzd2l0Y2ggQGNodW5rLmNoYXJBdCgwKVxuXHRcdFx0d2hlbiBcIidcIlxuXHRcdFx0XHRyZXR1cm4gMCB1bmxlc3MgbWF0Y2ggPSBTSU1QTEVTVFIuZXhlYyhAY2h1bmspXG5cdFx0XHRcdHN0cmluZyA9IG1hdGNoWzBdXG5cdFx0XHRcdHRva2VuICdTVFJJTkcnLCBlc2NhcGVTdHIoc3RyaW5nKSwgc3RyaW5nOmxlbmd0aFxuXHRcdFx0XHQjIHRva2VuICdTVFJJTkcnLCAoc3RyaW5nID0gbWF0Y2hbMF0pLnJlcGxhY2UoTVVMVElMSU5FUiwgJ1xcXFxcXG4nKSwgc3RyaW5nOmxlbmd0aFxuXG5cdFx0XHR3aGVuICdcIidcblx0XHRcdFx0cmV0dXJuIDAgdW5sZXNzIHN0cmluZyA9IGJhbGFuY2VkU3RyaW5nKEBjaHVuaywgJ1wiJylcblx0XHRcdFx0IyB3aGF0IGFib3V0IHRyaXBlIHF1b3RlZCBzdHJpbmdzP1xuXG5cdFx0XHRcdGlmIHN0cmluZy5pbmRleE9mKCd7JykgPj0gMFxuXHRcdFx0XHRcdHZhciBsZW4gPSBzdHJpbmc6bGVuZ3RoXG5cdFx0XHRcdFx0IyBpZiB0aGlzIGhhcyBubyBpbnRlcnBvbGF0aW9uP1xuXHRcdFx0XHRcdCMgd2UgYXJlIG5vdyBtZXNzaW5nIHdpdGggbG9jYXRpb25zIC0gYmV3YXJlXG5cdFx0XHRcdFx0dG9rZW4gJ1NUUklOR19TVEFSVCcsIHN0cmluZy5jaGFyQXQoMCksIDFcblx0XHRcdFx0XHRpbnRlcnBvbGF0ZVN0cmluZyhzdHJpbmcuc2xpY2UgMSwgLTEpXG5cdFx0XHRcdFx0dG9rZW4gJ1NUUklOR19FTkQnLCBzdHJpbmcuY2hhckF0KGxlbiAtIDEpLCAxLCBzdHJpbmc6bGVuZ3RoIC0gMVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0dmFyIGxlbiA9IHN0cmluZzpsZW5ndGhcblx0XHRcdFx0XHQjIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKE1VTFRJTElORVIsICdcXFxcXFxuJylcblx0XHRcdFx0XHR0b2tlbiAnU1RSSU5HJywgZXNjYXBlU3RyKHN0cmluZyksIGxlblxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRyZXR1cm4gMFxuXG5cdFx0bW92ZUhlYWQoc3RyaW5nKVxuXHRcdHJldHVybiBzdHJpbmc6bGVuZ3RoXG5cblx0IyBNYXRjaGVzIGhlcmVkb2NzLCBhZGp1c3RpbmcgaW5kZW50YXRpb24gdG8gdGhlIGNvcnJlY3QgbGV2ZWwsIGFzIGhlcmVkb2NzXG5cdCMgcHJlc2VydmUgd2hpdGVzcGFjZSwgYnV0IGlnbm9yZSBpbmRlbnRhdGlvbiB0byB0aGUgbGVmdC5cblx0ZGVmIGhlcmVkb2NUb2tlblxuXHRcdHZhciBtYXRjaCwgaGVyZWRvYywgcXVvdGUsIGRvY1xuXG5cdFx0cmV0dXJuIDAgdW5sZXNzIG1hdGNoID0gSEVSRURPQy5leGVjKEBjaHVuaylcblxuXHRcdGhlcmVkb2MgPSBtYXRjaFswXVxuXHRcdHF1b3RlID0gaGVyZWRvYy5jaGFyQXQgMFxuXHRcdGRvYyA9IHNhbml0aXplSGVyZWRvYyhtYXRjaFsyXSwgcXVvdGU6IHF1b3RlLCBpbmRlbnQ6IG51bGwpXG5cdFx0IyBjb25zb2xlLmxvZyBcImZvdW5kIGhlcmVkb2Mge21hdGNoWzBdOmxlbmd0aH0ge2RvYzpsZW5ndGh9XCJcblxuXHRcdGlmIHF1b3RlID09ICdcIicgJiYgZG9jLmluZGV4T2YoJ3snKSA+PSAwXG5cdFx0XHR2YXIgb3BlbiA9IG1hdGNoWzFdXG5cdFx0XHQjIGNvbnNvbGUubG9nIGRvYy5zdWJzdHIoMCwzKSxtYXRjaFsxXVxuXHRcdFx0dG9rZW4gJ1NUUklOR19TVEFSVCcsIG9wZW4sIG9wZW46bGVuZ3RoXG5cdFx0XHRpbnRlcnBvbGF0ZVN0cmluZyhkb2MsIGhlcmVkb2M6IHllcywgb2Zmc2V0OiBvcGVuOmxlbmd0aCwgcXVvdGU6IHF1b3RlKVxuXHRcdFx0dG9rZW4gJ1NUUklOR19FTkQnLCBvcGVuLCBvcGVuOmxlbmd0aCwgaGVyZWRvYzpsZW5ndGggLSBvcGVuOmxlbmd0aFxuXHRcdGVsc2Vcblx0XHRcdHRva2VuKCdTVFJJTkcnLCBtYWtlU3RyaW5nKGRvYywgcXVvdGUsIHllcyksIDApXG5cblx0XHRtb3ZlSGVhZChoZXJlZG9jKVxuXHRcdHJldHVybiBoZXJlZG9jOmxlbmd0aFxuXG5cdCMgTWF0Y2hlcyBhbmQgY29uc3VtZXMgY29tbWVudHMuXG5cdGRlZiBjb21tZW50VG9rZW5cblx0XHR2YXIgbWF0Y2gsIGxlbmd0aCwgY29tbWVudCwgaW5kZW50LCBwcmV2XG5cblx0XHR2YXIgdHlwID0gJ0hFUkVDT01NRU5UJ1xuXG5cdFx0aWYgbWF0Y2ggPSBJTkxJTkVfQ09NTUVOVC5leGVjKEBjaHVuaykgIyAubWF0Y2goSU5MSU5FX0NPTU1FTlQpXG5cdFx0XHQjIGNvbnNvbGUubG9nIFwibWF0Y2ggaW5saW5lIGNvbW1lbnRcIlxuXHRcdFx0bGVuZ3RoID0gbWF0Y2hbMF06bGVuZ3RoXG5cdFx0XHRpbmRlbnQgPSBtYXRjaFsxXVxuXHRcdFx0Y29tbWVudCA9IG1hdGNoWzJdXG5cblx0XHRcdHByZXYgPSBsYXN0KEB0b2tlbnMpXG5cdFx0XHR2YXIgcHQgPSBwcmV2IGFuZCB0VChwcmV2KVxuXHRcdFx0dmFyIG5vdGUgPSAnLy8nICsgY29tbWVudC5zdWJzdHIoMSlcblxuXHRcdFx0aWYgQGxhc3QgYW5kIEBsYXN0OnNwYWNlZFxuXHRcdFx0XHRub3RlID0gJyAnICsgbm90ZVxuXHRcdFx0XHQjIGNvbnNvbGUubG9nIFwidGhlIHByZXZpb3VzIG5vZGUgd2FzIFNQQUNFRFwiXG5cdFx0XHQjIGNvbnNvbGUubG9nIFwiY29tbWVudCB7bm90ZX0gLSBpbmRlbnQoe2luZGVudH0pIC0ge2xlbmd0aH0ge2NvbW1lbnQ6bGVuZ3RofVwiXG5cblx0XHRcdGlmIChwdCBhbmQgcHQgIT0gJ0lOREVOVCcgYW5kIHB0ICE9ICdURVJNSU5BVE9SJykgb3IgIXB0XG5cdFx0XHRcdCMgY29uc29sZS5sb2cgXCJza2lwIGNvbW1lbnRcIlxuXHRcdFx0XHQjIHRva2VuICdJTkxJTkVDT01NRU5UJywgY29tbWVudC5zdWJzdHIoMilcblx0XHRcdFx0IyBjb25zb2xlLmxvZyBcImFkZGluZyBhcyB0ZXJtaW5hdG9yXCJcblx0XHRcdFx0dG9rZW4oJ1RFUk1JTkFUT1InLCBub3RlLCBsZW5ndGgpICMgKyAnXFxuJ1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHQjIGNvbnNvbGUubG9nIFwiYWRkIGNvbW1lbnQgKHtub3RlfSlcIlxuXHRcdFx0XHRpZiBwdCA9PSAnVEVSTUlOQVRPUidcblx0XHRcdFx0XHR0VnMocHJldix0VihwcmV2KSArIG5vdGUpXG5cdFx0XHRcdFx0IyBwcmV2WzFdICs9IG5vdGVcblx0XHRcdFx0ZWxpZiBwdCA9PSAnSU5ERU5UJ1xuXHRcdFx0XHRcdCMgY29uc29sZS5sb2cgXCJhZGRpbmcgY29tbWVudCB0byBJTkRFTlQ6IHtub3RlfVwiICMgd2h5IG5vdCBhZGQgZGlyZWN0bHkgaGVyZT9cblx0XHRcdFx0XHRhZGRMaW5lYnJlYWtzKDEsbm90ZSlcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdCMgY29uc29sZS5sb2cgXCJjb21tZW50IGhlcmVcIlxuXHRcdFx0XHRcdCMgc2hvdWxkIHdlIGV2ZXIgZ2V0IGhlcmU/XG5cdFx0XHRcdFx0dG9rZW4odHlwLCBjb21tZW50LnN1YnN0cigyKSwgbGVuZ3RoKSAjIGFyZSB3ZSBzdXJlP1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gbGVuZ3RoICMgZGlzYWJsZSBub3cgd2hpbGUgY29tcGlsaW5nXG5cblx0XHQjIHNob3VsZCB1c2UgZXhlYz9cblx0XHRyZXR1cm4gMCB1bmxlc3MgbWF0Y2ggPSBDT01NRU5ULmV4ZWMoQGNodW5rKVxuXG5cdFx0dmFyIGNvbW1lbnQgPSBtYXRjaFswXVxuXHRcdHZhciBoZXJlID0gbWF0Y2hbMV1cblxuXHRcdGlmIGhlcmVcblx0XHRcdHRva2VuICdIRVJFQ09NTUVOVCcsIHNhbml0aXplSGVyZWRvYyhoZXJlLCBoZXJlY29tbWVudDogdHJ1ZSwgaW5kZW50OiBBcnJheShAaW5kZW50ICsgMSkuam9pbignICcpKSwgY29tbWVudDpsZW5ndGhcblx0XHRcdHRva2VuICdURVJNSU5BVE9SJywgJ1xcbidcblx0XHRlbHNlXG5cdFx0XHR0b2tlbiAnSEVSRUNPTU1FTlQnLCBjb21tZW50LCBjb21tZW50Omxlbmd0aFxuXHRcdFx0dG9rZW4gJ1RFUk1JTkFUT1InLCAnXFxuJyAjIGF1dG8/IHJlYWxseT9cblxuXHRcdG1vdmVIZWFkKGNvbW1lbnQpXG5cdFx0cmV0dXJuIGNvbW1lbnQ6bGVuZ3RoXG5cblx0IyBNYXRjaGVzIEphdmFTY3JpcHQgaW50ZXJwb2xhdGVkIGRpcmVjdGx5IGludG8gdGhlIHNvdXJjZSB2aWEgYmFja3RpY2tzLlxuXHRkZWYganNUb2tlblxuXHRcdHZhciBtYXRjaCwgc2NyaXB0XG5cblx0XHRyZXR1cm4gMCB1bmxlc3MgQGNodW5rLmNoYXJBdCgwKSBpcyAnYCcgYW5kIG1hdGNoID0gSlNUT0tFTi5leGVjKEBjaHVuaylcblx0XHR0b2tlbiAnSlMnLCAoc2NyaXB0ID0gbWF0Y2hbMF0pLnNsaWNlIDEsIC0xXG5cdFx0c2NyaXB0Omxlbmd0aFxuXG5cdCMgTWF0Y2hlcyByZWd1bGFyIGV4cHJlc3Npb24gbGl0ZXJhbHMuIExleGluZyByZWd1bGFyIGV4cHJlc3Npb25zIGlzIGRpZmZpY3VsdFxuXHQjIHRvIGRpc3Rpbmd1aXNoIGZyb20gZGl2aXNpb24sIHNvIHdlIGJvcnJvdyBzb21lIGJhc2ljIGhldXJpc3RpY3MgZnJvbVxuXHQjIEphdmFTY3JpcHQgYW5kIFJ1YnkuXG5cdGRlZiByZWdleFRva2VuXG5cdFx0dmFyIG1hdGNoLCBsZW5ndGgsIHByZXZcblxuXHRcdHJldHVybiAwIGlmIEBjaHVuay5jaGFyQXQoMCkgaXNudCAnLydcblx0XHRpZiBtYXRjaCA9IEhFUkVHRVguZXhlYyhAY2h1bmspXG5cdFx0XHRsZW5ndGggPSBoZXJlZ2V4VG9rZW4obWF0Y2gpXG5cdFx0XHRtb3ZlSGVhZChtYXRjaFswXSlcblx0XHRcdHJldHVybiBsZW5ndGhcblxuXHRcdHByZXYgPSBsYXN0IEB0b2tlbnNcblx0XHQjIEZJWFxuXHRcdHJldHVybiAwIGlmIHByZXYgYW5kICh0VChwcmV2KSBpbiAoaWYgcHJldjpzcGFjZWQgdGhlbiBOT1RfUkVHRVggZWxzZSBOT1RfU1BBQ0VEX1JFR0VYKSlcblx0XHRyZXR1cm4gMCB1bmxlc3MgbWF0Y2ggPSBSRUdFWC5leGVjKEBjaHVuaylcblx0XHR2YXIgW20sIHJlZ2V4LCBmbGFnc10gPSBtYXRjaFxuXG5cdFx0IyBGSVhNRVxuXHRcdCMgaWYgcmVnZXhbLi4xXSBpcyAnLyonXG5cdFx0I1x0ZXJyb3IgJ3JlZ3VsYXIgZXhwcmVzc2lvbnMgY2Fubm90IGJlZ2luIHdpdGggYCpgJ1xuXG5cdFx0aWYgcmVnZXggPT0gJy8vJ1xuXHRcdFx0cmVnZXggPSAnLyg/OikvJ1xuXG5cdFx0dG9rZW4gJ1JFR0VYJywgXCJ7cmVnZXh9e2ZsYWdzfVwiLCBtOmxlbmd0aFxuXHRcdG06bGVuZ3RoXG5cblx0IyBNYXRjaGVzIG11bHRpbGluZSBleHRlbmRlZCByZWd1bGFyIGV4cHJlc3Npb25zLlxuXHQjIFRoZSBlc2NhcGluZyBzaG91bGQgcmF0aGVyIGhhcHBlbiBpbiBBU1QgLSBwb3NzaWJseSBhcyBhbiBhZGRpdGlvbmFsIGZsYWc/XG5cdGRlZiBoZXJlZ2V4VG9rZW4gbWF0Y2hcblx0XHR2YXIgW2hlcmVnZXgsIGJvZHksIGZsYWdzXSA9IG1hdGNoXG5cblx0XHRpZiAwID4gYm9keS5pbmRleE9mKCcjeycpXG5cblx0XHRcdHZhciByZSA9IGJvZHkucmVwbGFjZShIRVJFR0VYX09NSVQsICcnKS5yZXBsYWNlKC9cXC8vZywgJ1xcXFwvJylcblxuXHRcdFx0aWYgcmUubWF0Y2goL15cXCovKVxuXHRcdFx0XHRlcnJvciAncmVndWxhciBleHByZXNzaW9ucyBjYW5ub3QgYmVnaW4gd2l0aCBgKmAnXG5cblx0XHRcdHRva2VuICdSRUdFWCcsIFwiL3sgcmUgb3IgJyg/OiknIH0ve2ZsYWdzfVwiLCBoZXJlZ2V4Omxlbmd0aFxuXHRcdFx0cmV0dXJuIGhlcmVnZXg6bGVuZ3RoXG5cblx0XHQjIHVzZSBtb3JlIGJhc2ljIHJlZ2V4IHR5cGVcblxuXHRcdHRva2VuICdDT05TVCcsICdSZWdFeHAnXG5cdFx0QHRva2Vucy5wdXNoIFQudG9rZW4oJ0NBTExfU1RBUlQnLCAnKCcsMClcblx0XHR2YXIgdG9rZW5zID0gW11cblxuXHRcdGZvciBwYWlyIGluIGludGVycG9sYXRlU3RyaW5nKGJvZHksIHJlZ2V4OiB5ZXMpXG5cblx0XHRcdHZhciB0b2sgPSB0VChwYWlyKSAjIEZJWFxuXHRcdFx0dmFyIHZhbHVlID0gdFYocGFpcikgIyBGSVhcblxuXHRcdFx0aWYgdG9rID09ICdUT0tFTlMnXG5cdFx0XHRcdCMgRklYTUUgd2hhdCBpcyB0aGlzP1xuXHRcdFx0XHR0b2tlbnMucHVzaCAqdmFsdWVcblx0XHRcdGVsc2Vcblx0XHRcdFx0aWYgIXZhbHVlXG5cdFx0XHRcdFx0Y29uc29sZS5sb2cgXCJ3aGF0Pz9cIlxuXG5cdFx0XHRcdGNvbnRpbnVlIHVubGVzcyB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoSEVSRUdFWF9PTUlULCAnJylcblxuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlLnJlcGxhY2UgL1xcXFwvZywgJ1xcXFxcXFxcJ1xuXHRcdFx0XHR0b2tlbnMucHVzaCBULnRva2VuKCdTVFJJTkcnLCBtYWtlU3RyaW5nKHZhbHVlLCAnXCInLCB5ZXMpLCAwKSAjIEZJWFxuXG5cdFx0XHR0b2tlbnMucHVzaCBULnRva2VuKCcrJywgJysnLCAwKSAjIEZJWFxuXG5cdFx0dG9rZW5zLnBvcFxuXG5cdFx0IyBGSVhcblx0XHR1bmxlc3MgdG9rZW5zWzBdIGFuZCB0VCh0b2tlbnNbMF0pIGlzICdTVFJJTkcnXG5cdFx0XHQjIEZJWFxuXHRcdFx0QHRva2Vucy5wdXNoIFQudG9rZW4oJ1NUUklORycsICdcIlwiJyksIFQudG9rZW4oJysnLCAnKycpXG5cblx0XHRAdG9rZW5zLnB1c2ggKnRva2VucyAjIHdoYXQgaXMgdGhpcz9cblx0XHQjIEZJWFxuXG5cdFx0aWYgZmxhZ3Ncblx0XHRcdEB0b2tlbnMucHVzaChULnRva2VuKCcsJywgJywnLCAwKSlcblx0XHRcdEB0b2tlbnMucHVzaChULnRva2VuKCdTVFJJTkcnLCAnXCInICsgZmxhZ3MgKyAnXCInLCAwKSlcblxuXHRcdHRva2VuKCcpJywgJyknLDApXG5cblx0XHRyZXR1cm4gaGVyZWdleDpsZW5ndGhcblxuXHQjIE1hdGNoZXMgbmV3bGluZXMsIGluZGVudHMsIGFuZCBvdXRkZW50cywgYW5kIGRldGVybWluZXMgd2hpY2ggaXMgd2hpY2guXG5cdCMgSWYgd2UgY2FuIGRldGVjdCB0aGF0IHRoZSBjdXJyZW50IGxpbmUgaXMgY29udGludWVkIG9udG8gdGhlIHRoZSBuZXh0IGxpbmUsXG5cdCMgdGhlbiB0aGUgbmV3bGluZSBpcyBzdXBwcmVzc2VkOlxuXHQjXG5cdCMgICAgIGVsZW1lbnRzXG5cdCMgICAgICAgLmVhY2goIC4uLiApXG5cdCMgICAgICAgLm1hcCggLi4uIClcblx0I1xuXHQjIEtlZXBzIHRyYWNrIG9mIHRoZSBsZXZlbCBvZiBpbmRlbnRhdGlvbiwgYmVjYXVzZSBhIHNpbmdsZSBvdXRkZW50IHRva2VuXG5cdCMgY2FuIGNsb3NlIG11bHRpcGxlIGluZGVudHMsIHNvIHdlIG5lZWQgdG8ga25vdyBob3cgZmFyIGluIHdlIGhhcHBlbiB0byBiZS5cblx0ZGVmIGxpbmVUb2tlblxuXHRcdHZhciBtYXRjaFxuXG5cdFx0cmV0dXJuIDAgdW5sZXNzIG1hdGNoID0gTVVMVElfREVOVC5leGVjKEBjaHVuaylcblxuXHRcdHZhciBpbmRlbnQgPSBtYXRjaFswXVxuXHRcdHZhciBickNvdW50ID0gbW92ZUhlYWQoaW5kZW50KVxuXG5cdFx0QHNlZW5Gb3IgPSBub1xuXHRcdCMgcmVzZXQgY29sdW1uIGFzIHdlbGw/XG5cblx0XHR2YXIgcHJldiA9IGxhc3QgQHRva2VucywgMVxuXHRcdGxldCB3aGl0ZXNwYWNlID0gaW5kZW50LnN1YnN0cihpbmRlbnQubGFzdEluZGV4T2YoJ1xcbicpICsgMSlcblx0XHR2YXIgc2l6ZSA9IHdoaXRlc3BhY2U6bGVuZ3RoXG5cdFx0dmFyIG5vTmV3bGluZXMgPSBzZWxmLnVuZmluaXNoZWRcblxuXHRcdGlmICgvXlxcbiNcXHMvKS50ZXN0KEBjaHVuaylcblx0XHRcdGFkZExpbmVicmVha3MoMSlcblx0XHRcdHJldHVybiAwXG5cblx0XHRpZiBzaXplID4gMFxuXHRcdFx0dW5sZXNzIEBpbmRlbnRTdHlsZVxuXHRcdFx0XHRAb3B0czppbmRlbnQgPSBAaW5kZW50U3R5bGUgPSB3aGl0ZXNwYWNlXG5cblx0XHRcdGxldCBpbmRlbnRTaXplID0gMFxuXHRcdFx0bGV0IG9mZnNldCA9IDBcblxuXHRcdFx0d2hpbGUgdHJ1ZVxuXHRcdFx0XHRsZXQgaWR4ID0gd2hpdGVzcGFjZS5pbmRleE9mKEBpbmRlbnRTdHlsZSxvZmZzZXQpXG5cdFx0XHRcdGlmIGlkeCA9PSBvZmZzZXRcblx0XHRcdFx0XHRpbmRlbnRTaXplKytcblx0XHRcdFx0XHRvZmZzZXQgKz0gQGluZGVudFN0eWxlWydsZW5ndGgnXVxuXHRcdFx0XHRlbGlmIG9mZnNldCA9PSB3aGl0ZXNwYWNlOmxlbmd0aFxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHQjIHdvcmthcm91bmQgdG8gcmVwb3J0IGNvcnJlY3QgbG9jYXRpb25cblx0XHRcdFx0XHRAbG9jICs9IGluZGVudDpsZW5ndGggLSB3aGl0ZXNwYWNlOmxlbmd0aFxuXHRcdFx0XHRcdHRva2VuKCdJTkRFTlQnLCB3aGl0ZXNwYWNlLHdoaXRlc3BhY2U6bGVuZ3RoKVxuXHRcdFx0XHRcdHJldHVybiBlcnJvcignaW5jb25zaXN0ZW50IGluZGVudGF0aW9uJylcblxuXHRcdFx0c2l6ZSA9IGluZGVudFNpemVcblxuXG5cdFx0aWYgc2l6ZSAtIEBpbmRlYnQgaXMgQGluZGVudFxuXHRcdFx0aWYgbm9OZXdsaW5lc1xuXHRcdFx0XHRzdXBwcmVzc05ld2xpbmVzKClcblx0XHRcdGVsc2Vcblx0XHRcdFx0bmV3bGluZVRva2VuKGJyQ291bnQpXG5cdFx0XHRyZXR1cm4gaW5kZW50Omxlbmd0aFxuXG5cdFx0aWYgc2l6ZSA+IEBpbmRlbnRcblx0XHRcdGlmIG5vTmV3bGluZXNcblx0XHRcdFx0QGluZGVidCA9IHNpemUgLSBAaW5kZW50XG5cdFx0XHRcdHN1cHByZXNzTmV3bGluZXNcblx0XHRcdFx0cmV0dXJuIGluZGVudDpsZW5ndGhcblxuXHRcdFx0aWYgaW5UYWcoKVxuXHRcdFx0XHQjIGNvbnNvbGUubG9nIFwiaW5kZW50IGluc2lkZSB0b2tpZD8hP1wiXG5cdFx0XHRcdCMgQGluZGVidCA9IHNpemUgLSBAaW5kZW50XG5cdFx0XHRcdCMgc3VwcHJlc3NOZXdsaW5lcygpXG5cdFx0XHRcdHJldHVybiBpbmRlbnQ6bGVuZ3RoXG5cblxuXHRcdFx0dmFyIGRpZmYgPSBzaXplIC0gQGluZGVudCArIEBvdXRkZWJ0XG5cdFx0XHRjbG9zZURlZigpXG5cblx0XHRcdHZhciBpbW1lZGlhdGUgPSBsYXN0KEB0b2tlbnMpXG5cblx0XHRcdGlmIGltbWVkaWF0ZSBhbmQgdFQoaW1tZWRpYXRlKSA9PSAnVEVSTUlOQVRPUidcblx0XHRcdFx0dFRzKGltbWVkaWF0ZSwnSU5ERU5UJylcblx0XHRcdFx0aW1tZWRpYXRlLkBtZXRhIHx8PSB7cHJlOiB0VihpbW1lZGlhdGUpLCBwb3N0OiAnJ31cblxuXHRcdFx0XHQjIHNob3VsZCByYXRoZXIgYWRkIHRvIG1ldGEgc29tZWhvdz8hP1xuXHRcdFx0XHQjIHRWcyhpbW1lZGlhdGUsdFYoaW1tZWRpYXRlKSArICclfCUnKSAjIGNyYXp5XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHRva2VuKCdJTkRFTlQnLCBcIlwiICsgZGlmZiwwKVxuXG5cdFx0XHQjIGNvbnNvbGUubG9nIFwiaW5kZW50aW5nXCIsIHByZXYsIGxhc3QoQHRva2VucywxKVxuXHRcdFx0IyBpZiBwcmV2IGFuZCBwcmV2WzBdID09ICdURVJNSU5BVE9SJ1xuXHRcdFx0IyAgIGNvbnNvbGUubG9nIFwidGVybWluYXRvciBiZWZvcmUgaW5kZW50Pz9cIlxuXG5cdFx0XHQjIGNoZWNrIGZvciBjb21tZW50cyBhcyB3ZWxsID9cblxuXHRcdFx0QGluZGVudHMucHVzaCBkaWZmXG5cdFx0XHRwdXNoRW5kKCdPVVRERU5UJylcblx0XHRcdCMgQGVuZHMucHVzaCAnT1VUREVOVCdcblx0XHRcdEBvdXRkZWJ0ID0gQGluZGVidCA9IDBcblx0XHRcdGFkZExpbmVicmVha3MoYnJDb3VudClcblx0XHRlbHNlXG5cdFx0XHRAaW5kZWJ0ID0gMFxuXHRcdFx0b3V0ZGVudFRva2VuKEBpbmRlbnQgLSBzaXplLCBub05ld2xpbmVzLCBickNvdW50KVxuXHRcdFx0YWRkTGluZWJyZWFrcyhickNvdW50IC0gMSlcblx0XHRcdCMgY29uc29sZS5sb2cgXCJvdXRkZW50XCIsbm9OZXdsaW5lcyx0b2tpZCgpXG5cblx0XHRAaW5kZW50ID0gc2l6ZVxuXHRcdHJldHVybiBpbmRlbnQ6bGVuZ3RoXG5cblx0IyBSZWNvcmQgYW4gb3V0ZGVudCB0b2tlbiBvciBtdWx0aXBsZSB0b2tlbnMsIGlmIHdlIGhhcHBlbiB0byBiZSBtb3ZpbmcgYmFja1xuXHQjIGlud2FyZHMgcGFzdCBzZXZlcmFsIHJlY29yZGVkIGluZGVudHMuXG5cdGRlZiBvdXRkZW50VG9rZW4gbW92ZU91dCwgbm9OZXdsaW5lcywgbmV3bGluZUNvdW50XG5cdFx0IyBoZXJlIHdlIHNob3VsZCBhbHNvIHRha2UgY2FyZSB0byBwb3AgLyByZXNldCB0aGUgc2NvcGUtYm9keVxuXHRcdCMgb3IgY29udGV4dC10eXBlIGZvciBpbmRlbnRhdGlvbiBcblx0XHR2YXIgZGVudCA9IDBcblx0XHR3aGlsZSBtb3ZlT3V0ID4gMFxuXHRcdFx0dmFyIGxlbiA9IEBpbmRlbnRzOmxlbmd0aCAtIDFcblx0XHRcdGlmIEBpbmRlbnRzW2xlbl0gaXMgdW5kZWZpbmVkXG5cdFx0XHRcdG1vdmVPdXQgPSAwXG5cdFx0XHRlbGlmIEBpbmRlbnRzW2xlbl0gaXMgQG91dGRlYnRcblx0XHRcdFx0bW92ZU91dCAtPSBAb3V0ZGVidFxuXHRcdFx0XHRAb3V0ZGVidCA9IDBcblx0XHRcdGVsaWYgQGluZGVudHNbbGVuXSA8IEBvdXRkZWJ0XG5cdFx0XHRcdEBvdXRkZWJ0IC09IEBpbmRlbnRzW2xlbl1cblx0XHRcdFx0bW92ZU91dCAgLT0gQGluZGVudHNbbGVuXVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRkZW50ID0gQGluZGVudHMucG9wIC0gQG91dGRlYnRcblx0XHRcdFx0bW92ZU91dCAtPSBkZW50XG5cdFx0XHRcdEBvdXRkZWJ0ID0gMFxuXG5cdFx0XHRcdGFkZExpbmVicmVha3MoMSkgdW5sZXNzIG5vTmV3bGluZXNcblxuXHRcdFx0XHRwYWlyICdPVVRERU5UJ1xuXHRcdFx0XHR0b2tlbignT1VUREVOVCcsIFwiXCIgKyBkZW50LCAwKVxuXG5cdFx0QG91dGRlYnQgLT0gbW92ZU91dCBpZiBkZW50XG5cblx0XHRAdG9rZW5zLnBvcCB3aGlsZSBsYXN0VG9rZW5WYWx1ZSA9PSAnOydcblxuXHRcdHRva2VuKCdURVJNSU5BVE9SJywnXFxuJywwKSB1bmxlc3MgbGFzdFRva2VuVHlwZSA9PSAnVEVSTUlOQVRPUicgb3Igbm9OZXdsaW5lc1xuXG5cdFx0IyBjYXBwaW5nIHNjb3BlcyBzbyB0aGV5IGRvbnQgaGFuZyBhcm91bmQgXG5cdFx0QHNjb3BlczpsZW5ndGggPSBAaW5kZW50czpsZW5ndGhcblxuXHRcdHZhciBjdHggPSBjb250ZXh0XG5cdFx0cGFpcihjdHgpIGlmIGN0eCA9PSAnJScgb3IgY3R4ID09ICdUQUcnICMgcmVhbGx5P1xuXHRcdGNsb3NlRGVmXG5cdFx0cmV0dXJuIHRoaXNcblxuXHQjIE1hdGNoZXMgYW5kIGNvbnN1bWVzIG5vbi1tZWFuaW5nZnVsIHdoaXRlc3BhY2UuIHRva2lkIHRoZSBwcmV2aW91cyB0b2tlblxuXHQjIGFzIGJlaW5nIFwic3BhY2VkXCIsIGJlY2F1c2UgdGhlcmUgYXJlIHNvbWUgY2FzZXMgd2hlcmUgaXQgbWFrZXMgYSBkaWZmZXJlbmNlLlxuXHRkZWYgd2hpdGVzcGFjZVRva2VuXG5cdFx0dmFyIG1hdGNoLCBubGluZSwgcHJldlxuXHRcdHJldHVybiAwIHVubGVzcyAobWF0Y2ggPSBXSElURVNQQUNFLmV4ZWMoQGNodW5rKSkgfHwgKG5saW5lID0gQGNodW5rLmNoYXJBdCgwKSBpcyAnXFxuJylcblx0XHRwcmV2ID0gbGFzdCBAdG9rZW5zXG5cblx0XHQjIEZJWCAtIHdoeSBvaCB3aHk/XG5cdFx0aWYgcHJldlxuXHRcdFx0aWYgbWF0Y2hcblx0XHRcdFx0cHJldjpzcGFjZWQgPSB5ZXNcblx0XHRcdFx0cmV0dXJuIG1hdGNoWzBdOmxlbmd0aFxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRwcmV2Om5ld0xpbmUgPSB5ZXNcblx0XHRcdFx0cmV0dXJuIDBcblxuXHRkZWYgYWRkTmV3bGluZVxuXHRcdHRva2VuICdURVJNSU5BVE9SJywgJ1xcbidcblxuXHRkZWYgbW92ZUhlYWQgc3RyXG5cdFx0dmFyIGJyID0gY291bnQoc3RyLCdcXG4nKVxuXHRcdHJldHVybiBiclxuXHRcdFxuXG5cdGRlZiBhZGRMaW5lYnJlYWtzIGNvdW50LCByYXdcblx0XHR2YXIgYnJcblxuXHRcdHJldHVybiB0aGlzIGlmICFyYXcgYW5kIGNvdW50ID09IDAgIyBubyB0ZXJtaW5hdG9ycz9cblxuXHRcdHZhciBwcmV2ID0gQGxhc3RcblxuXHRcdGlmICFyYXdcblx0XHRcdGlmIGNvdW50ID09IDFcblx0XHRcdFx0YnIgPSAnXFxuJ1xuXHRcdFx0ZWxpZiBjb3VudCA9PSAyXG5cdFx0XHRcdGJyID0gJ1xcblxcbidcblx0XHRcdGVsaWYgY291bnQgPT0gM1xuXHRcdFx0XHRiciA9ICdcXG5cXG5cXG4nXG5cdFx0XHRlbHNlXG5cdFx0XHRcdGJyID0gcmVwZWF0U3RyaW5nKCdcXG4nLGNvdW50KVxuXHRcdCMgRklYXG5cdFx0aWYgcHJldlxuXHRcdFx0dmFyIHQgPSBwcmV2LkB0eXBlICMgQGxhc3RUeXBcblx0XHRcdHZhciB2ID0gdFYocHJldilcblxuXHRcdFx0IyB3ZSByZWFsbHkgd2FudCB0byBhZGQgdGhpc1xuXHRcdFx0aWYgdCA9PSAnSU5ERU5UJ1xuXHRcdFx0XHQjIFRPRE8gd2Ugd2FudCB0byBhZGQgdG8gdGhlIGluZGVudFxuXHRcdFx0XHQjIGNvbnNvbGUubG9nIFwiYWRkIHRoZSBjb21tZW50IHRvIHRoZSBpbmRlbnQgLS0gcHJlPyB7cmF3fSB7YnJ9XCJcblx0XHRcdFxuXHRcdFx0XHR2YXIgbWV0YSA9IHByZXYuQG1ldGEgfHw9IHtwcmU6ICcnLCBwb3N0OiAnJ31cblx0XHRcdFx0bWV0YTpwb3N0ICs9IChyYXcgb3IgYnIpXG5cdFx0XHRcdCMgdFZzKHYgKyAocmF3IG9yIGJyKSlcblx0XHRcdFx0cmV0dXJuIHRoaXNcblxuXHRcdFx0ZWxpZiB0ID09ICdURVJNSU5BVE9SJ1xuXHRcdFx0XHQjIGNvbnNvbGUubG9nIFwiYWxyZWFkeSBleGlzdHMgdGVybWluYXRvciB7YnJ9IHtyYXd9XCJcblx0XHRcdFx0dFZzKHByZXYsdiArIChyYXcgb3IgYnIpKVxuXHRcdFx0XHRyZXR1cm4gdGhpc1xuXHRcdFxuXHRcdHRva2VuKCdURVJNSU5BVE9SJywgYnIsIDApXG5cdFx0cmV0dXJuXG5cblx0IyBHZW5lcmF0ZSBhIG5ld2xpbmUgdG9rZW4uIENvbnNlY3V0aXZlIG5ld2xpbmVzIGdldCBtZXJnZWQgdG9nZXRoZXIuXG5cdGRlZiBuZXdsaW5lVG9rZW4gbGluZXNcblx0XHQjIGNvbnNvbGUubG9nIFwibmV3bGluZVRva2VuXCJcblx0XHR3aGlsZSBsYXN0VG9rZW5WYWx1ZSgpID09ICc7J1xuXHRcdFx0Y29uc29sZS5sb2cgXCJwb3AgdG9rZW5cIixAdG9rZW5zW0B0b2tlbnM6bGVuZ3RoIC0gMV1cblx0XHRcdEB0b2tlbnMucG9wXG5cblx0XHRhZGRMaW5lYnJlYWtzKGxpbmVzKVxuXG5cdFx0dmFyIGN0eCA9IGNvbnRleHRcblx0XHQjIFdBUk4gbm93IGltcG9ydCBjYW5ub3QgZ28gb3ZlciBtdWx0aXBsZSBsaW5lc1xuXHRcdHBhaXIoY3R4KSBpZiBjdHggPT0gJ1RBRycgb3IgY3R4ID09ICdJTVBPUlQnXG5cdFx0Y2xvc2VEZWYoKSAgIyBjbG9zZSBkZWYgLS0gcmVhbGx5P1xuXHRcdHRoaXNcblxuXHQjIFVzZSBhIGBcXGAgYXQgYSBsaW5lLWVuZGluZyB0byBzdXBwcmVzcyB0aGUgbmV3bGluZS5cblx0IyBUaGUgc2xhc2ggaXMgcmVtb3ZlZCBoZXJlIG9uY2UgaXRzIGpvYiBpcyBkb25lLlxuXHRkZWYgc3VwcHJlc3NOZXdsaW5lc1xuXHRcdEB0b2tlbnMucG9wIGlmIHZhbHVlKCkgaXMgJ1xcXFwnXG5cdFx0dGhpc1xuXG5cdCMgV2UgdHJlYXQgYWxsIG90aGVyIHNpbmdsZSBjaGFyYWN0ZXJzIGFzIGEgdG9rZW4uIEUuZy46IGAoICkgLCAuICFgXG5cdCMgTXVsdGktY2hhcmFjdGVyIG9wZXJhdG9ycyBhcmUgYWxzbyBsaXRlcmFsIHRva2Vucywgc28gdGhhdCBKaXNvbiBjYW4gYXNzaWduXG5cdCMgdGhlIHByb3BlciBvcmRlciBvZiBvcGVyYXRpb25zLiBUaGVyZSBhcmUgc29tZSBzeW1ib2xzIHRoYXQgd2UgdG9raWQgc3BlY2lhbGx5XG5cdCMgaGVyZS4gYDtgIGFuZCBuZXdsaW5lcyBhcmUgYm90aCB0cmVhdGVkIGFzIGEgYFRFUk1JTkFUT1JgLCB3ZSBkaXN0aW5ndWlzaFxuXHQjIHBhcmVudGhlc2VzIHRoYXQgaW5kaWNhdGUgYSBtZXRob2QgY2FsbCBmcm9tIHJlZ3VsYXIgcGFyZW50aGVzZXMsIGFuZCBzbyBvbi5cblx0ZGVmIGxpdGVyYWxUb2tlblxuXHRcdHZhciBtYXRjaCwgdmFsdWVcblx0XHRpZiBtYXRjaCA9IE9QRVJBVE9SLmV4ZWMoQGNodW5rKVxuXHRcdFx0dmFsdWUgPSBtYXRjaFswXVxuXHRcdFx0dGFnUGFyYW1ldGVycyBpZiBDT0RFLnRlc3QodmFsdWUpXG5cdFx0ZWxzZVxuXHRcdFx0dmFsdWUgPSBAY2h1bmsuY2hhckF0KDApXG5cdFx0XG5cdFx0dmFyIGVuZDEgPSBAZW5kc1tAZW5kczpsZW5ndGggLSAxXVxuXHRcdHZhciBlbmQyID0gQGVuZHNbQGVuZHM6bGVuZ3RoIC0gMl1cblxuXHRcdHZhciBpblRhZyA9IGVuZDEgPT0gJ1RBR19FTkQnIG9yIGVuZDEgID09ICdPVVRERU5UJyBhbmQgZW5kMiA9PSAnVEFHX0VORCdcblxuXHRcdHZhciB0b2tpZCA9IHZhbHVlXG5cdFx0dmFyIHByZXYgID0gbGFzdCBAdG9rZW5zXG5cdFx0dmFyIHB0ID0gcHJldiBhbmQgdFQocHJldilcblx0XHR2YXIgcHYgPSBwcmV2IGFuZCB0VihwcmV2KVxuXHRcdHZhciBsZW5ndGggPSB2YWx1ZTpsZW5ndGhcblxuXHRcdCMgaXMgdGhpcyBuZWVkZWQ/XG5cdFx0aWYgdmFsdWUgPT0gJz0nIGFuZCBwcmV2XG5cblx0XHRcdGlmIHB2ID09ICd8fCcgb3IgcHYgPT0gJyYmJyAjIGluIFsnfHwnLCAnJiYnXVxuXHRcdFx0XHR0VHMocHJldiwnQ09NUE9VTkRfQVNTSUdOJylcblx0XHRcdFx0dFZzKHByZXYscHYgKyAnPScpXG5cdFx0XHRcdCMgcHJldlswXSA9ICdDT01QT1VORF9BU1NJR04nXG5cdFx0XHRcdCMgcHJldlsxXSArPSAnPSdcblx0XHRcdFx0cmV0dXJuIHZhbHVlOmxlbmd0aFxuXG5cdFx0aWYgdmFsdWUgaXMgJzsnICAgICAgICAgICAgIFxuXHRcdFx0QHNlZW5Gb3IgPSBub1xuXHRcdFx0dG9raWQgPSAnVEVSTUlOQVRPUidcblxuXHRcdGVsaWYgdmFsdWUgaXMgJygnIGFuZCBpblRhZyBhbmQgcHQgIT0gJz0nIGFuZCBwcmV2OnNwYWNlZCAjIEZJWGVkXG5cdFx0XHQjIGNvbnNvbGUubG9nICdzcGFjZWQgYmVmb3JlICggaW4gdG9raWQnXG5cdFx0XHQjIEZJWE1FIC0gc2hvdWxkIHJhdGhlciBhZGQgYSBzcGVjaWFsIHRva2VuIGxpa2UgVEFHX1BBUkFNU19TVEFSVFxuXHRcdFx0dG9rZW4gJywnLCcsJ1xuXG5cdFx0ZWxpZiB2YWx1ZSBpcyAnLT4nIGFuZCBpblRhZ1xuXHRcdFx0dG9raWQgPSAnVEFHX0VORCdcblx0XHRcdHBhaXIgJ1RBR19FTkQnXG5cblx0XHRlbGlmIHZhbHVlIGlzICcvPicgYW5kIGluVGFnXG5cdFx0XHR0b2tpZCA9ICdUQUdfRU5EJ1xuXHRcdFx0cGFpciAnVEFHX0VORCdcblxuXHRcdGVsaWYgdmFsdWUgaXMgJz4nIGFuZCBpblRhZ1xuXHRcdFx0dG9raWQgPSAnVEFHX0VORCdcblx0XHRcdHBhaXIgJ1RBR19FTkQnXG5cblx0XHQjIHRoaXMgaXMgYSB0b2tpZC1tZXRob2Rcblx0XHRlbGlmIHZhbHVlIGlzICc+JyBhbmQgY29udGV4dCA9PSAnREVGJ1xuXHRcdFx0IyBjb25zb2xlLmxvZygncGlja2VkIHVwID4hIScpXG5cdFx0XHR0b2tpZCA9ICdERUZfRlJBR01FTlQnXG5cdFxuXHRcdFx0IyBlbGlmIHZhbHVlIGlzICdURVJNSU5BVE9SJyBhbmQgZW5kMSBpcyAnJScgXG5cdFx0XHQjIFx0Y2xvc2VTZWxlY3RvcigpXG5cblx0XHRlbGlmIHZhbHVlIGlzICdURVJNSU5BVE9SJyBhbmQgZW5kMSBpcyAnREVGJ1xuXHRcdFx0Y2xvc2VEZWYoKVxuXG5cdFx0IyBUT0RPIEJMT0NLIFBBUkFNIEJVR1xuXHRcdCMgcmVhbGx5K1xuXHRcdGVsaWYgdmFsdWUgaXMgJyYnIGFuZCBjb250ZXh0ID09ICdERUYnXG5cdFx0XHQjIGNvbnNvbGUubG9nKFwib2theSFcIilcblx0XHRcdHRva2lkID0gJ0JMT0NLX0FSRydcblx0XHRcdCMgY2hhbmdlIHRoZSBuZXh0IGlkZW50aWZpZXIgaW5zdGVhZD9cblxuXHRcdCMgZWxpZiB2YWx1ZS5tYXRjaCgpXG5cdFx0ZWxpZiB2YWx1ZSA9PSAnKicgYW5kIEBjaHVuay5jaGFyQXQoMSkubWF0Y2goL1tBLVphLXpcXF9cXEBcXFtdLykgYW5kIChwcmV2OnNwYWNlZCBvciBbJywnLCcoJywnWycsJ3snLCd8JywnXFxuJywnXFx0J10uaW5kZXhPZihwdikgPj0gMClcblx0XHRcdHRva2lkID0gXCJTUExBVFwiXG5cblx0XHRlbGlmIHZhbHVlID09ICfiiJonXG5cdFx0XHR0b2tpZCA9ICdTUVJUJ1xuXHRcdGVsaWYgdmFsdWUgPT0gJ8aSJ1xuXHRcdFx0dG9raWQgPSAnRlVOQydcblx0XHRlbGlmIHZhbHVlIGluIE1BVEhcblx0XHRcdHRva2lkID0gJ01BVEgnXG5cdFx0ZWxpZiB2YWx1ZSBpbiBDT01QQVJFXG5cdFx0XHR0b2tpZCA9ICdDT01QQVJFJ1xuXHRcdGVsaWYgdmFsdWUgaW4gQ09NUE9VTkRfQVNTSUdOXG5cdFx0XHR0b2tpZCA9ICdDT01QT1VORF9BU1NJR04nXG5cdFx0ZWxpZiB2YWx1ZSBpbiBVTkFSWVxuXHRcdFx0dG9raWQgPSAnVU5BUlknXG5cdFx0ZWxpZiB2YWx1ZSBpbiBTSElGVFxuXHRcdFx0dG9raWQgPSAnU0hJRlQnXG5cdFx0ZWxpZiB2YWx1ZSBpbiBMT0dJQ1xuXHRcdFx0dG9raWQgPSAnTE9HSUMnICMgb3IgdmFsdWUgaXMgJz8nIGFuZCBwcmV2PzpzcGFjZWQgXG5cblx0XHRlbGlmIHByZXYgYW5kICFwcmV2OnNwYWNlZFxuXHRcdFx0IyBuZWVkIGEgYmV0dGVyIHdheSB0byBkbyB0aGVzZVxuXHRcdFx0aWYgdmFsdWUgaXMgJygnIGFuZCBlbmQxID09ICclJ1xuXHRcdFx0XHR0b2tpZCA9ICdUQUdfQVRUUlNfU1RBUlQnXG5cblx0XHRcdGVsaWYgdmFsdWUgaXMgJygnIGFuZCBwdCBpbiBDQUxMQUJMRVxuXHRcdFx0XHQjIG5vdCB1c2luZyB0aGlzID8/P1xuXHRcdFx0XHQjIHByZXZbMF0gPSAnRlVOQ19FWElTVCcgaWYgcHJldlswXSBpcyAnPydcblx0XHRcdFx0dG9raWQgPSAnQ0FMTF9TVEFSVCdcblxuXHRcdFx0ZWxpZiB2YWx1ZSBpcyAnWycgYW5kIHB0IGluIElOREVYQUJMRVxuXHRcdFx0XHR0b2tpZCA9ICdJTkRFWF9TVEFSVCdcblx0XHRcdFx0dFRzKHByZXYsJ0lOREVYX1NPQUsnKSBpZiBwdCA9PSAnPydcblx0XHRcdFx0IyBwcmV2WzBdID0gJ0lOREVYX1NPQUsnIGlmIHByZXZbMF0gPT0gJz8nXG5cblx0XHRzd2l0Y2ggdmFsdWVcblx0XHRcdHdoZW4gJygnLCAneycsICdbJyB0aGVuIHB1c2hFbmQoSU5WRVJTRVNbdmFsdWVdKVxuXHRcdFx0d2hlbiAnKScsICd9JywgJ10nIHRoZW4gcGFpciB2YWx1ZVxuXG5cdFx0IyBoYWNreSBydWxlIHRvIHRyeSB0byBhbGxvdyBmb3IgdHVwbGUtYXNzaWdubWVudHMgaW4gYmxvY2tzXG5cdFx0IyBpZiB2YWx1ZSBpcyAnLCcgYW5kIHByZXZbMF0gaXMgJ0lERU5USUZJRVInIGFuZCBAdG9rZW5zW0B0b2tlbnM6bGVuZ3RoIC0gMl1bMF0gaW4gWydURVJNSU5BVE9SJywnSU5ERU5UJ11cblx0XHQjICAgIyB0b2tlbiBcIlRVUExFXCIsIFwidHVwbGVcIiAjIHNob3VsZCByYXRoZXIgaW5zZXJ0IGl0IHNvbWV3aGVyZSBlbHNlLCBubz9cblx0XHQjICAgY29uc29sZS5sb2coXCJmb3VuZCBjb21tYVwiKVxuXG5cdFx0dG9rZW4odG9raWQsIHZhbHVlLCB2YWx1ZTpsZW5ndGgpXG5cdFx0cmV0dXJuIHZhbHVlOmxlbmd0aFxuXG5cdCMgVG9rZW4gTWFuaXB1bGF0b3JzXG5cdCMgLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0IyBTYW5pdGl6ZSBhIGhlcmVkb2Mgb3IgaGVyZWNvbW1lbnQgYnlcblx0IyBlcmFzaW5nIGFsbCBleHRlcm5hbCBpbmRlbnRhdGlvbiBvbiB0aGUgbGVmdC1oYW5kIHNpZGUuXG5cdGRlZiBzYW5pdGl6ZUhlcmVkb2MgZG9jLCBvcHRpb25zXG5cdFx0dmFyIG1hdGNoXG5cdFx0dmFyIGluZGVudCA9IG9wdGlvbnM6aW5kZW50XG5cdFx0dmFyIGhlcmVjb21tZW50ID0gb3B0aW9uczpoZXJlY29tbWVudFxuXG5cdFx0aWYgaGVyZWNvbW1lbnRcblx0XHRcdGlmIEhFUkVET0NfSUxMRUdBTC50ZXN0KGRvYylcblx0XHRcdFx0ZXJyb3IgXCJibG9jayBjb21tZW50IGNhbm5vdCBjb250YWluICcqLycgc3RhcnRpbmdcIlxuXHRcdFx0cmV0dXJuIGRvYyBpZiBkb2MuaW5kZXhPZignXFxuJykgPD0gMFxuXHRcdGVsc2Vcblx0XHRcdHdoaWxlIG1hdGNoID0gSEVSRURPQ19JTkRFTlQuZXhlYyhkb2MpXG5cdFx0XHRcdHZhciBhdHRlbXB0ID0gbWF0Y2hbMV1cblx0XHRcdFx0aWYgaW5kZW50IGlzIG51bGwgb3IgMCA8IGF0dGVtcHQ6bGVuZ3RoIDwgaW5kZW50Omxlbmd0aFxuXHRcdFx0XHRcdGluZGVudCA9IGF0dGVtcHRcblxuXHRcdGRvYyA9IGRvYy5yZXBsYWNlIFJlZ0V4cChcIlxcXFxue2luZGVudH1cIixcImdcIiksICdcXG4nIGlmIGluZGVudFxuXHRcdGRvYyA9IGRvYy5yZXBsYWNlIC9eXFxuLywgJycgdW5sZXNzIGhlcmVjb21tZW50XG5cdFx0cmV0dXJuIGRvY1xuXG5cdCMgQSBzb3VyY2Ugb2YgYW1iaWd1aXR5IGluIG91ciBncmFtbWFyIHVzZWQgdG8gYmUgcGFyYW1ldGVyIGxpc3RzIGluIGZ1bmN0aW9uXG5cdCMgZGVmaW5pdGlvbnMgdmVyc3VzIGFyZ3VtZW50IGxpc3RzIGluIGZ1bmN0aW9uIGNhbGxzLiBXYWxrIGJhY2t3YXJkcywgdG9raWRnaW5nXG5cdCMgcGFyYW1ldGVycyBzcGVjaWFsbHkgaW4gb3JkZXIgdG8gbWFrZSB0aGluZ3MgZWFzaWVyIGZvciB0aGUgcGFyc2VyLlxuXHRkZWYgdGFnUGFyYW1ldGVyc1xuXHRcdHJldHVybiB0aGlzIGlmIGxhc3RUb2tlblR5cGUgIT0gJyknXG5cdFx0dmFyIHN0YWNrID0gW11cblx0XHR2YXIgdG9rZW5zID0gQHRva2Vuc1xuXHRcdHZhciBpID0gdG9rZW5zOmxlbmd0aFxuXG5cdFx0dFRzKHRva2Vuc1stLWldLCAnUEFSQU1fRU5EJylcblxuXHRcdHdoaWxlIHZhciB0b2sgPSB0b2tlbnNbLS1pXVxuXHRcdFx0dmFyIHQgPSB0VCh0b2spXG5cdFx0XHRzd2l0Y2ggdFxuXHRcdFx0XHR3aGVuICcpJ1xuXHRcdFx0XHRcdHN0YWNrLnB1c2ggdG9rXG5cdFx0XHRcdHdoZW4gJygnLCAnQ0FMTF9TVEFSVCdcblx0XHRcdFx0XHRpZiBzdGFjazpsZW5ndGhcblx0XHRcdFx0XHRcdHN0YWNrLnBvcFxuXHRcdFx0XHRcdGVsaWYgdCBpcyAnKCdcblx0XHRcdFx0XHRcdHRUcyh0b2ssJ1BBUkFNX1NUQVJUJylcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzXG5cdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXNcblxuXHRcdHJldHVybiB0aGlzXG5cblx0IyBDbG9zZSB1cCBhbGwgcmVtYWluaW5nIG9wZW4gYmxvY2tzIGF0IHRoZSBlbmQgb2YgdGhlIGZpbGUuXG5cdGRlZiBjbG9zZUluZGVudGF0aW9uXG5cdFx0IyBjdHggPSBjb250ZXh0XG5cdFx0IyBwYWlyKGN0eCkgaWYgY3R4IGluIFsnJScsJ0RFRiddXG5cdFx0Y2xvc2VEZWZcblx0XHRjbG9zZVNlbGVjdG9yXG5cdFx0b3V0ZGVudFRva2VuKEBpbmRlbnQsbm8sMClcblxuXHQjIE1hdGNoZXMgYSBiYWxhbmNlZCBncm91cCBzdWNoIGFzIGEgc2luZ2xlIG9yIGRvdWJsZS1xdW90ZWQgc3RyaW5nLiBQYXNzIGluXG5cdCMgYSBzZXJpZXMgb2YgZGVsaW1pdGVycywgYWxsIG9mIHdoaWNoIG11c3QgYmUgbmVzdGVkIGNvcnJlY3RseSB3aXRoaW4gdGhlXG5cdCMgY29udGVudHMgb2YgdGhlIHN0cmluZy4gVGhpcyBtZXRob2QgYWxsb3dzIHVzIHRvIGhhdmUgc3RyaW5ncyB3aXRoaW5cblx0IyBpbnRlcnBvbGF0aW9ucyB3aXRoaW4gc3RyaW5ncywgYWQgaW5maW5pdHVtLlxuXHRkZWYgYmFsYW5jZWRTdHJpbmcgc3RyLCBlbmRcblx0XHR2YXIgbWF0Y2gsIGxldHRlciwgcHJldlxuXG5cdFx0IyBjb25zb2xlLmxvZyAnYmFsYW5jaW5nIHN0cmluZyEnLCBzdHIsIGVuZFxuXHRcdHZhciBzdGFjayA9IFtlbmRdXG5cdFx0dmFyIGkgPSAwXG5cblx0XHQjIGNvdWxkIGl0IG5vdCBoYXBwZW4gaGVyZT9cblx0XHR3aGlsZSBpIDwgKHN0cjpsZW5ndGggLSAxKVxuXHRcdFx0aSsrXG5cdFx0XHR2YXIgbGV0dGVyID0gc3RyLmNoYXJBdChpKVxuXHRcdFx0c3dpdGNoIGxldHRlclxuXHRcdFx0XHR3aGVuICdcXFxcJ1xuXHRcdFx0XHRcdGkrK1xuXHRcdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHRcdHdoZW4gZW5kXG5cdFx0XHRcdFx0c3RhY2sucG9wXG5cdFx0XHRcdFx0dW5sZXNzIHN0YWNrOmxlbmd0aFxuXHRcdFx0XHRcdFx0dmFyIHYgPSBzdHIuc2xpY2UoMCwgaSArIDEpXG5cdFx0XHRcdFx0XHRyZXR1cm4gdlxuXHRcdFx0XHRcdGVuZCA9IHN0YWNrW3N0YWNrOmxlbmd0aCAtIDFdXG5cdFx0XHRcdFx0Y29udGludWVcblxuXHRcdFx0aWYgZW5kIGlzICd9JyBhbmQgKGxldHRlciA9PSAnXCInIG9yIGxldHRlciA9PSBcIidcIilcblx0XHRcdFx0c3RhY2sucHVzaChlbmQgPSBsZXR0ZXIpXG5cblx0XHRcdGVsaWYgZW5kIGlzICd9JyBhbmQgbGV0dGVyIGlzICcvJyBhbmQgbWF0Y2ggPSAoSEVSRUdFWC5leGVjKHN0ci5zbGljZSBpKSBvciBSRUdFWC5leGVjKHN0ci5zbGljZSBpKSlcblx0XHRcdFx0aSArPSBtYXRjaFswXTpsZW5ndGggLSAxXG5cblx0XHRcdGVsaWYgZW5kIGlzICd9JyBhbmQgbGV0dGVyIGlzICd7J1xuXHRcdFx0XHRzdGFjay5wdXNoIGVuZCA9ICd9J1xuXHRcdFx0ZWxpZiBlbmQgaXMgJ1wiJyBhbmQgbGV0dGVyIGlzICd7J1xuXHRcdFx0XHRzdGFjay5wdXNoIGVuZCA9ICd9J1xuXHRcdFx0cHJldiA9IGxldHRlclxuXG5cdFx0ZXJyb3IgXCJtaXNzaW5nIHsgc3RhY2sucG9wIH0sIHN0YXJ0aW5nXCIgdW5sZXNzIEBvcHRzOnNpbGVudFxuXG5cdCMgRXhwYW5kIHZhcmlhYmxlcyBhbmQgZXhwcmVzc2lvbnMgaW5zaWRlIGRvdWJsZS1xdW90ZWQgc3RyaW5ncyB1c2luZ1xuXHQjIFJ1YnktbGlrZSBub3RhdGlvbiBmb3Igc3Vic3RpdHV0aW9uIG9mIGFyYml0cmFyeSBleHByZXNzaW9ucy5cblx0I1xuXHQjICAgICBcIkhlbGxvICN7bmFtZS5jYXBpdGFsaXplKCl9LlwiXG5cdCNcblx0IyBJZiBpdCBlbmNvdW50ZXJzIGFuIGludGVycG9sYXRpb24sIHRoaXMgbWV0aG9kIHdpbGwgcmVjdXJzaXZlbHkgY3JlYXRlIGFcblx0IyBuZXcgTGV4ZXIsIHRva2VuaXplIHRoZSBpbnRlcnBvbGF0ZWQgY29udGVudHMsIGFuZCBtZXJnZSB0aGVtIGludG8gdGhlXG5cdCMgdG9rZW4gc3RyZWFtLlxuXHRkZWYgaW50ZXJwb2xhdGVTdHJpbmcgc3RyLCBvcHRpb25zID0ge31cblx0XHQjIGNvbnNvbGUubG9nIFwiaW50ZXJwb2xhdGUgc3RyaW5nXCJcblx0XHR2YXIgaGVyZWRvYyA9IG9wdGlvbnM6aGVyZWRvY1xuXHRcdHZhciBxdW90ZSA9IG9wdGlvbnM6cXVvdGVcblx0XHR2YXIgcmVnZXggPSBvcHRpb25zOnJlZ2V4XG5cdFx0dmFyIHByZWZpeCA9IG9wdGlvbnM6cHJlZml4XG5cblx0XHR2YXIgc3RhcnRMb2MgPSBAbG9jXG5cdFx0dmFyIHRva2VucyA9IFtdXG5cdFx0dmFyIHBpID0gMFxuXHRcdHZhciBpICA9IC0xXG5cdFx0dmFyIGxvY09mZnNldCA9IG9wdGlvbnM6b2Zmc2V0IG9yIDFcblx0XHR2YXIgc3RybGVuID0gc3RyOmxlbmd0aFxuXHRcdHZhciBsZXR0ZXJcblx0XHR2YXIgZXhwclxuXG5cdFx0dmFyIGlzSW50ZXJwb2xhdGVkID0gbm9cblx0XHQjIG91dCBvZiBib3VuZHNcblx0XHR3aGlsZSBsZXR0ZXIgPSBzdHIuY2hhckF0KGkgKz0gMSlcblx0XHRcdGlmIGxldHRlciBpcyAnXFxcXCdcblx0XHRcdFx0aSArPSAxXG5cdFx0XHRcdGNvbnRpbnVlXG5cblx0XHRcdHVubGVzcyBzdHIuY2hhckF0KGkpIGlzICd7JyBhbmQgKGV4cHIgPSBiYWxhbmNlZFN0cmluZyhzdHIuc2xpY2UoaSksICd9JykpXG5cdFx0XHRcdGNvbnRpbnVlXG5cblx0XHRcdGlzSW50ZXJwb2xhdGVkID0geWVzXG5cblx0XHRcdCMgdGhlc2UgaGF2ZSBubyByZWFsIHNlbnNlIG9mIGxvY2F0aW9uIG9yIGFueXRoaW5nP1xuXHRcdFx0aWYgcGkgPCBpXG5cdFx0XHRcdCMgdGhpcyBpcyB0aGUgcHJlZml4LXN0cmluZyAtIGJlZm9yZSBhbnkgaXRlbVxuXHRcdFx0XHR2YXIgdG9rID0gVG9rZW4ubmV3KCdORU9TVFJJTkcnLCBlc2NhcGVTdHIoc3RyLnNsaWNlKHBpLCBpKSxoZXJlZG9jLHF1b3RlKSxAbG9jICsgcGkgKyBsb2NPZmZzZXQsaSAtIHBpKVxuXHRcdFx0XHQjIHRvay5AbG9jID0gQGxvYyArIHBpXG5cdFx0XHRcdCMgdG9rLkBsZW4gPSBpIC0gcGkgKyAyXG5cdFx0XHRcdHRva2Vucy5wdXNoKHRvaylcblxuXHRcdFx0dG9rZW5zLnB1c2ggVG9rZW4ubmV3KCd7eycsJ3snLEBsb2MgKyBpICsgbG9jT2Zmc2V0LDEpXG5cblx0XHRcdHZhciBpbm5lciA9IGV4cHIuc2xpY2UoMSwgLTEpXG5cdFx0XHQjIGNvbnNvbGUubG9nICdpbm5lciBpcycsaW5uZXJcblx0XHRcdCMgcmVtb3ZlIGxlYWRpbmcgc3BhY2VzIFxuXHRcdFx0IyBuZWVkIHRvIGtlZXAgdHJhY2sgb2YgaG93IG11Y2ggd2hpdGVzcGFjZSB3ZSBkcm9wcGVkIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRpbm5lciA9IGlubmVyLnJlcGxhY2UoL15bXlxcblxcU10rLywnJylcblxuXHRcdFx0aWYgaW5uZXI6bGVuZ3RoXG5cdFx0XHRcdCMgd2UgbmVlZCB0byByZW1lbWJlciB0aGUgbG9jIHdlIHN0YXJ0IGF0XG5cdFx0XHRcdCMgY29uc29sZS5sb2coJ2ludGVycG9sYXRlIGZyb20gbG9jJyxAbG9jLGkpXG5cdFx0XHRcdCMgcmVhbGx5PyB3aHkgbm90IGp1c3QgYWRkIHRvIHRoZSBzdGFjaz8/XG5cdFx0XHRcdCMgd2hhdCBhYm91dCB0aGUgYWRkZWQgXG5cdFx0XHRcdCMgc2hvdWxkIHNoYXJlIHdpdGggdGhlIHNlbGVjdG9yIG5vP1xuXHRcdFx0XHQjIGNvbnNvbGUubG9nIFwidG9rZW5pemUgaW5uZXIgcGFydHMgb2Ygc3RyaW5nXCIsaW5uZXJcblx0XHRcdFx0dmFyIHNwYWNlcyA9IDBcblx0XHRcdFx0dmFyIG9mZnNldCA9IEBsb2MgKyBpICsgKGV4cHI6bGVuZ3RoIC0gaW5uZXI6bGVuZ3RoKSAtIDFcblx0XHRcdFx0IyB3aHkgY3JlYXRlIGEgd2hvbGUgbmV3IGxleGVyPyBTaG91bGQgcmF0aGVyIHJldXNlIG9uZVxuXHRcdFx0XHQjIG11Y2ggYmV0dGVyIHRvIHNpbXBseSBtb3ZlIGludG8gaW50ZXJwb2xhdGlvbiBtb2RlIHdoZXJlXG5cdFx0XHRcdCMgd2UgY29udGludWUgcGFyc2luZyB1bnRpbCB3ZSBtZWV0IHVucGFpcmVkIH1cblx0XHRcdFx0dmFyIG5lc3RlZCA9IExleGVyLm5ldy50b2tlbml6ZSBpbm5lciwgaW5saW5lOiB5ZXMsIHJld3JpdGU6IG5vLCBsb2M6IG9mZnNldCArIGxvY09mZnNldFxuXHRcdFx0XHQjIGNvbnNvbGUubG9nIG5lc3RlZC5wb3BcblxuXHRcdFx0XHRpZiBuZXN0ZWRbMF0gYW5kIHRUKG5lc3RlZFswXSkgPT0gJ1RFUk1JTkFUT1InXG5cdFx0XHRcdFx0bmVzdGVkLnNoaWZ0XG5cblx0XHRcdFx0aWYgbmVzdGVkOmxlbmd0aFxuXHRcdFx0XHRcdHRva2Vucy5wdXNoICpuZXN0ZWQgIyBULnRva2VuKCdUT0tFTlMnLG5lc3RlZCwwKVxuXHRcdFx0XG5cdFx0XHQjIHNob3VsZCByYXRoZXIgYWRkIHRoZSBhbW91bnQgYnkgd2hpY2ggb3VyIGxleGVyIGhhcyBtb3ZlZD9cblx0XHRcdGkgKz0gZXhwcjpsZW5ndGggLSAxXG5cdFx0XHR0b2tlbnMucHVzaCBUb2tlbi5uZXcoJ319JywnfScsQGxvYyArIGkgKyBsb2NPZmZzZXQsMSlcblx0XHRcdHBpID0gaSArIDFcblxuXHRcdCMgYWRkaW5nIHRoZSBsYXN0IHBhcnQgb2YgdGhlIHN0cmluZyBoZXJlXG5cdFx0aWYgaSA+PSBwaSBhbmQgcGkgPCBzdHI6bGVuZ3RoXG5cdFx0XHQjIHNldCB0aGUgbGVuZ3RoIGFzIHdlbGwgLSBvcj9cblx0XHRcdCMgdGhlIHN0cmluZyBhZnRlcj9cblx0XHRcdCMgY29uc29sZS5sb2cgJ3B1c2ggbmVvc3RyaW5nJ1xuXHRcdFx0dG9rZW5zLnB1c2ggVG9rZW4ubmV3KCdORU9TVFJJTkcnLCBlc2NhcGVTdHIoc3RyLnNsaWNlKHBpKSxoZXJlZG9jLHF1b3RlKSxAbG9jICsgcGkgKyBsb2NPZmZzZXQsIHN0cjpsZW5ndGggLSBwaSlcblxuXHRcdCMgY29uc29sZS5sb2cgdG9rZW5zOmxlbmd0aFxuXHRcdHJldHVybiB0b2tlbnMgaWYgcmVnZXhcblxuXHRcdHJldHVybiB0b2tlbiAnTkVPU1RSSU5HJywgJ1wiXCInIHVubGVzcyB0b2tlbnM6bGVuZ3RoXG5cblx0XHRAdG9rZW5zLnB1c2godG9rKSBmb3IgdG9rIGluIHRva2Vuc1xuXG5cdFx0cmV0dXJuIHRva2Vuc1xuXG5cdCMgTWF0Y2hlcyBhIGJhbGFuY2VkIGdyb3VwIHN1Y2ggYXMgYSBzaW5nbGUgb3IgZG91YmxlLXF1b3RlZCBzdHJpbmcuIFBhc3MgaW5cblx0IyBhIHNlcmllcyBvZiBkZWxpbWl0ZXJzLCBhbGwgb2Ygd2hpY2ggbXVzdCBiZSBuZXN0ZWQgY29ycmVjdGx5IHdpdGhpbiB0aGVcblx0IyBjb250ZW50cyBvZiB0aGUgc3RyaW5nLiBUaGlzIG1ldGhvZCBhbGxvd3MgdXMgdG8gaGF2ZSBzdHJpbmdzIHdpdGhpblxuXHQjIGludGVycG9sYXRpb25zIHdpdGhpbiBzdHJpbmdzLCBhZCBpbmZpbml0dW0uXG5cdGRlZiBiYWxhbmNlZFNlbGVjdG9yIHN0ciwgZW5kXG5cdFx0dmFyIHByZXZcblx0XHR2YXIgbGV0dGVyXG5cdFx0dmFyIHN0YWNrID0gW2VuZF1cblx0XHQjIEZJWE1FXG5cdFx0Zm9yIGkgaW4gWzEuLi5zdHI6bGVuZ3RoXVxuXHRcdFx0c3dpdGNoIGxldHRlciA9IHN0ci5jaGFyQXQoaSlcblx0XHRcdFx0d2hlbiAnXFxcXCdcblx0XHRcdFx0XHRpKytcblx0XHRcdFx0XHRjb250aW51ZVxuXHRcdFx0XHR3aGVuIGVuZFxuXHRcdFx0XHRcdHN0YWNrLnBvcFxuXHRcdFx0XHRcdHVubGVzcyBzdGFjazpsZW5ndGhcblx0XHRcdFx0XHRcdHJldHVybiBzdHIuc2xpY2UoMCwgaSArIDEpXG5cblx0XHRcdFx0XHRlbmQgPSBzdGFja1tzdGFjazpsZW5ndGggLSAxXVxuXHRcdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHRpZiBlbmQgaXMgJ30nIGFuZCBsZXR0ZXIgaXMgWycpJ11cblx0XHRcdFx0c3RhY2sucHVzaCBlbmQgPSBsZXR0ZXJcblx0XHRcdGVsaWYgZW5kIGlzICd9JyBhbmQgbGV0dGVyIGlzICd7J1xuXHRcdFx0XHRzdGFjay5wdXNoIGVuZCA9ICd9J1xuXHRcdFx0ZWxpZiBlbmQgaXMgJyknIGFuZCBsZXR0ZXIgaXMgJ3snXG5cdFx0XHRcdHN0YWNrLnB1c2ggZW5kID0gJ30nXG5cdFx0XHRwcmV2ID0gbGV0dGVyICMgd2hhdCwgd2h5P1xuXG5cdFx0ZXJyb3IgXCJtaXNzaW5nIHsgc3RhY2sucG9wIH0sIHN0YXJ0aW5nXCJcblxuXHQjIFBhaXJzIHVwIGEgY2xvc2luZyB0b2tlbiwgZW5zdXJpbmcgdGhhdCBhbGwgbGlzdGVkIHBhaXJzIG9mIHRva2VucyBhcmVcblx0IyBjb3JyZWN0bHkgYmFsYW5jZWQgdGhyb3VnaG91dCB0aGUgY291cnNlIG9mIHRoZSB0b2tlbiBzdHJlYW0uXG5cdGRlZiBwYWlyIHRva1xuXHRcdHZhciB3YW50ZWQgPSBsYXN0KEBlbmRzKVxuXHRcdHVubGVzcyB0b2sgPT0gd2FudGVkXG5cdFx0XHRlcnJvciBcInVubWF0Y2hlZCB7dG9rfVwiIHVubGVzcyAnT1VUREVOVCcgaXMgd2FudGVkXG5cdFx0XHR2YXIgc2l6ZSA9IGxhc3QoQGluZGVudHMpXG5cdFx0XHRAaW5kZW50IC09IHNpemVcblx0XHRcdG91dGRlbnRUb2tlbihzaXplLCB0cnVlLCAwKVxuXHRcdFx0cmV0dXJuIHBhaXIodG9rKVxuXHRcdHNlbGYucG9wRW5kXG5cblxuXHQjIEhlbHBlcnNcblx0IyAtLS0tLS0tXG5cblx0IyBBZGQgYSB0b2tlbiB0byB0aGUgcmVzdWx0cywgdGFraW5nIG5vdGUgb2YgdGhlIGxpbmUgbnVtYmVyLlxuXHRkZWYgdG9rZW4gaWQsIHZhbHVlLCBsZW4sIG9mZnNldFxuXHRcdEBsYXN0VHlwID0gaWRcblx0XHRAbGFzdFZhbCA9IHZhbHVlXG5cdFx0dmFyIHRvayA9IEBsYXN0ID0gVG9rZW4ubmV3KGlkLCB2YWx1ZSwgQGxvYyArIChvZmZzZXQgb3IgMCksIGxlbiBvciAwKVxuXHRcdEB0b2tlbnMucHVzaCB0b2tcblx0XHRyZXR1cm5cblxuXHRkZWYgbGFzdFRva2VuVHlwZVxuXHRcdHZhciB0b2tlbiA9IEB0b2tlbnNbQHRva2VuczpsZW5ndGggLSAxXVxuXHRcdHRva2VuID8gdFQodG9rZW4pIDogJ05PTkUnXG5cblx0ZGVmIGxhc3RUb2tlblZhbHVlXG5cdFx0dmFyIHRva2VuID0gQHRva2Vuc1tAdG9rZW5zOmxlbmd0aCAtIDFdXG5cdFx0dG9rZW4gPyB0b2tlbi5AdmFsdWUgOiAnJ1xuXHRcdFxuXHQjIFBlZWsgYXQgYSB0b2tpZCBpbiB0aGUgY3VycmVudCB0b2tlbiBzdHJlYW0uXG5cdGRlZiB0b2tpZCBpbmRleCwgdmFsXG5cdFx0aWYgdmFyIHRvayA9IGxhc3QoQHRva2VucywgaW5kZXgpXG5cdFx0XHR0VHModG9rLHZhbCkgaWYgdmFsXG5cdFx0XHRyZXR1cm4gdFQodG9rKVxuXHRcdFx0IyB0b2suQHR5cGUgPSB0b2tpZCBpZiB0b2tpZCAjIHdoeT9cblx0XHRcdCMgdG9rLkB0eXBlXG5cdFx0ZWxzZSBudWxsXG5cblx0IyBQZWVrIGF0IGEgdmFsdWUgaW4gdGhlIGN1cnJlbnQgdG9rZW4gc3RyZWFtLlxuXHRkZWYgdmFsdWUgaW5kZXgsIHZhbFxuXHRcdGlmIHZhciB0b2sgPSBsYXN0KEB0b2tlbnMsIGluZGV4KVxuXHRcdFx0dFZzKHRvayx2YWwpIGlmIHZhbFxuXHRcdFx0cmV0dXJuIHRWKHRvaylcblx0XHRcdCMgdG9rLkB2YWx1ZSA9IHZhbCBpZiB2YWwgIyB3aHk/XG5cdFx0XHQjIHRvay5AdmFsdWVcblx0XHRlbHNlIG51bGxcblx0XHRcblxuXHQjIEFyZSB3ZSBpbiB0aGUgbWlkc3Qgb2YgYW4gdW5maW5pc2hlZCBleHByZXNzaW9uP1xuXHRkZWYgdW5maW5pc2hlZFxuXHRcdHJldHVybiB0cnVlIGlmIExJTkVfQ09OVElOVUVSLnRlc3QoQGNodW5rKVx0XG5cdFx0cmV0dXJuIFVORklOSVNIRUQuaW5kZXhPZihAbGFzdFR5cCkgPj0gMFxuXHRcblx0IyB2YXIgdG9rZW5zID0gWydcXFxcJywnLicsICc/LicsICdVTkFSWScsICdNQVRIJywgJysnLCAnLScsICdTSElGVCcsICdSRUxBVElPTicsICdDT01QQVJFJywgJ0xPR0lDJywgJ0NPTVBPVU5EX0FTU0lHTicsICdUSFJPVycsICdFWFRFTkRTJ11cblxuXHQjIENvbnZlcnRzIG5ld2xpbmVzIGZvciBzdHJpbmcgbGl0ZXJhbHMuXG5cdGRlZiBlc2NhcGVMaW5lcyBzdHIsIGhlcmVkb2Ncblx0XHRzdHIucmVwbGFjZSBNVUxUSUxJTkVSLCAoaGVyZWRvYyA/ICdcXFxcbicgOiAnJylcblxuXHQjIENvbnN0cnVjdHMgYSBzdHJpbmcgdG9rZW4gYnkgZXNjYXBpbmcgcXVvdGVzIGFuZCBuZXdsaW5lcy5cblx0ZGVmIG1ha2VTdHJpbmcgYm9keSwgcXVvdGUsIGhlcmVkb2Ncblx0XHRyZXR1cm4gcXVvdGUgKyBxdW90ZSB1bmxlc3MgYm9keVxuXHRcdGJvZHkgPSBib2R5LnJlcGxhY2UoL1xcXFwoW1xcc1xcU10pL2cpIGRvIHxtYXRjaCwgY29udGVudHN8XG5cdFx0XHQoY29udGVudHMgPT0gJ1xcbicgb3IgY29udGVudHMgPT0gcXVvdGUpID8gY29udGVudHMgOiBtYXRjaFxuXHRcdCMgRG9lcyBub3Qgd29yayBub3dcblx0XHRib2R5ID0gYm9keS5yZXBsYWNlIFJlZ0V4cChcIntxdW90ZX1cIixcImdcIiksICdcXFxcJCYnXG5cdFx0cXVvdGUgKyBlc2NhcGVMaW5lcyhib2R5LCBoZXJlZG9jKSArIHF1b3RlXG5cdFx0XG5cdCMgVGhyb3dzIGEgc3ludGF4IGVycm9yIG9uIHRoZSBjdXJyZW50IGBAbGluZWAuXG5cdGRlZiBlcnJvciBtZXNzYWdlLCBsZW5cblx0XHRtZXNzYWdlID0gXCJ7bWVzc2FnZX0gb24gbGluZSB7QGxpbmV9XCIgaWYgQGxpbmUgaXNhIE51bWJlclxuXG5cdFx0aWYgbGVuXG5cdFx0XHRtZXNzYWdlICs9IFwiIFt7QGxvY306e0Bsb2MgKyBsZW59XVwiXG5cblx0XHR2YXIgZXJyID0gU3ludGF4RXJyb3IubmV3KG1lc3NhZ2UpXG5cdFx0ZXJyOmxpbmUgPSBAbGluZVxuXHRcdCMgZXJyOmNvbHVtbk51bWJlclxuXHRcdHZhciBlcnIgPSBFUlIuSW1iYVBhcnNlRXJyb3IubmV3KGVyciwgdG9rZW5zOiBAdG9rZW5zLCBwb3M6IEB0b2tlbnM6bGVuZ3RoKVxuXHRcdGVycjpyZWdpb24gPSBbQGxvYyxAbG9jICsgKGxlbiBvciAwKV1cblx0XHR0aHJvdyBlcnJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHNyYy9jb21waWxlci9sZXhlci5pbWJhXG4gKiovIiwiXG4jIFRoZSBJbWJhIGxhbmd1YWdlIGhhcyBhIGdvb2QgZGVhbCBvZiBvcHRpb25hbCBzeW50YXgsIGltcGxpY2l0IHN5bnRheCxcbiMgYW5kIHNob3J0aGFuZCBzeW50YXguIFRoaXMgY2FuIGdyZWF0bHkgY29tcGxpY2F0ZSBhIGdyYW1tYXIgYW5kIGJsb2F0XG4jIHRoZSByZXN1bHRpbmcgcGFyc2UgdGFibGUuIEluc3RlYWQgb2YgbWFraW5nIHRoZSBwYXJzZXIgaGFuZGxlIGl0IGFsbCwgd2UgdGFrZVxuIyBhIHNlcmllcyBvZiBwYXNzZXMgb3ZlciB0aGUgdG9rZW4gc3RyZWFtLCB1c2luZyB0aGlzICoqUmV3cml0ZXIqKiB0byBjb252ZXJ0XG4jIHNob3J0aGFuZCBpbnRvIHRoZSB1bmFtYmlndW91cyBsb25nIGZvcm0sIGFkZCBpbXBsaWNpdCBpbmRlbnRhdGlvbiBhbmRcbiMgcGFyZW50aGVzZXMsIGFuZCBnZW5lcmFsbHkgY2xlYW4gdGhpbmdzIHVwLlxuXG52YXIgVCA9IHJlcXVpcmUgJy4vdG9rZW4nXG52YXIgVG9rZW4gPSBULlRva2VuXG5cbiMgQmFzZWQgb24gdGhlIG9yaWdpbmFsIHJld3JpdGVyLmNvZmZlZSBmcm9tIENvZmZlZVNjcmlwdFxuZXhwb3J0IGNsYXNzIFJld3JpdGVyXG5cdFxuXHRkZWYgdG9rZW5zXG5cdFx0QHRva2Vuc1xuXHRcdFxuXHQjIEhlbHBmdWwgc25pcHBldCBmb3IgZGVidWdnaW5nOlxuXHQjICAgICBjb25zb2xlLmxvZyAodFswXSArICcvJyArIHRbMV0gZm9yIHQgaW4gQHRva2Vucykuam9pbiAnICdcblx0IyBSZXdyaXRlIHRoZSB0b2tlbiBzdHJlYW0gaW4gbXVsdGlwbGUgcGFzc2VzLCBvbmUgbG9naWNhbCBmaWx0ZXIgYXRcblx0IyBhIHRpbWUuIFRoaXMgY291bGQgY2VydGFpbmx5IGJlIGNoYW5nZWQgaW50byBhIHNpbmdsZSBwYXNzIHRocm91Z2ggdGhlXG5cdCMgc3RyZWFtLCB3aXRoIGEgYmlnIG9sJyBlZmZpY2llbnQgc3dpdGNoLCBidXQgaXQncyBtdWNoIG5pY2VyIHRvIHdvcmsgd2l0aFxuXHQjIGxpa2UgdGhpcy4gVGhlIG9yZGVyIG9mIHRoZXNlIHBhc3NlcyBtYXR0ZXJzIC0tIGluZGVudGF0aW9uIG11c3QgYmVcblx0IyBjb3JyZWN0ZWQgYmVmb3JlIGltcGxpY2l0IHBhcmVudGhlc2VzIGNhbiBiZSB3cmFwcGVkIGFyb3VuZCBibG9ja3Mgb2YgY29kZS5cblx0ZGVmIHJld3JpdGUgdG9rZW5zLCBvcHRzID0ge31cblx0XHRAdG9rZW5zICA9IHRva2Vuc1xuXHRcdEBvcHRpb25zID0gb3B0c1xuXG5cdFx0IyBjb25zb2xlLmxvZyBcInRva2VucyBpbjogXCIgKyB0b2tlbnM6bGVuZ3RoXG5cdFx0Y29uc29sZS50aW1lKFwidG9rZW5pemU6cmV3cml0ZVwiKSBpZiBvcHRzOnByb2ZpbGVcblxuXHRcdHZhciBpID0gMFxuXHRcdCMgZmxhZyBlbXB0eSBtZXRob2RzXG5cdFx0d2hpbGUgdmFyIHRva2VuID0gdG9rZW5zW2ldXG5cdFx0XHR2YXIgbmV4dCA9IHRva2Vuc1tpICsgMV1cblx0XHRcdGlmIHRva2VuLkB0eXBlID09ICdERUZfQk9EWScgYW5kIG5leHQgYW5kIG5leHQuQHR5cGUgPT0gJ1RFUk1JTkFUT1InXG5cdFx0XHRcdHRva2VuLkB0eXBlID0gJ0RFRl9FTVBUWSdcblx0XHRcdGkrK1xuXG5cdFx0c3RlcChcImVuc3VyZUZpcnN0TGluZVwiKVxuXHRcdHN0ZXAoXCJyZW1vdmVMZWFkaW5nTmV3bGluZXNcIilcblx0XHRzdGVwKFwicmVtb3ZlTWlkRXhwcmVzc2lvbk5ld2xpbmVzXCIpXG5cdFx0c3RlcChcInRhZ0RlZkFyZ3VtZW50c1wiKVxuXHRcdHN0ZXAoXCJjbG9zZU9wZW5DYWxsc1wiKVxuXHRcdHN0ZXAoXCJjbG9zZU9wZW5JbmRleGVzXCIpXG5cdFx0c3RlcChcImNsb3NlT3BlblRhZ3NcIilcblx0XHRzdGVwKFwiY2xvc2VPcGVuVGFnQXR0ckxpc3RzXCIpXG5cdFx0c3RlcChcImFkZEltcGxpY2l0SW5kZW50YXRpb25cIilcblx0XHRzdGVwKFwidGFnUG9zdGZpeENvbmRpdGlvbmFsc1wiKVxuXHRcdHN0ZXAoXCJhZGRJbXBsaWNpdEJyYWNlc1wiKVxuXHRcdHN0ZXAoXCJhZGRJbXBsaWNpdFBhcmVudGhlc2VzXCIpXG5cblx0XHRjb25zb2xlLnRpbWVFbmQoXCJ0b2tlbml6ZTpyZXdyaXRlXCIpIGlmIG9wdHM6cHJvZmlsZVxuXHRcdCMgY29uc29sZS5sb2cgXCJ0b2tlbnMgb3V0OiBcIiArIEB0b2tlbnM6bGVuZ3RoXG5cdFx0QHRva2Vuc1xuXG5cdGRlZiBzdGVwIGZuXG5cdFx0aWYgQG9wdGlvbnM6cHJvZmlsZVxuXHRcdFx0Y29uc29sZS5sb2cgXCItLS0tIHN0YXJ0aW5nIHtmbn0gLS0tLSBcIlxuXHRcdFx0Y29uc29sZS50aW1lKGZuKVxuXG5cdFx0dGhpc1tmbl0oKVxuXG5cdFx0aWYgQG9wdGlvbnM6cHJvZmlsZVxuXHRcdFx0Y29uc29sZS50aW1lRW5kKGZuKVxuXHRcdFx0Y29uc29sZS5sb2cgXCJcXG5cXG5cIlxuXHRcdHJldHVyblxuXG5cdCMgUmV3cml0ZSB0aGUgdG9rZW4gc3RyZWFtLCBsb29raW5nIG9uZSB0b2tlbiBhaGVhZCBhbmQgYmVoaW5kLlxuXHQjIEFsbG93IHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGJsb2NrIHRvIHRlbGwgdXMgaG93IG1hbnkgdG9rZW5zIHRvIG1vdmVcblx0IyBmb3J3YXJkcyAob3IgYmFja3dhcmRzKSBpbiB0aGUgc3RyZWFtLCB0byBtYWtlIHN1cmUgd2UgZG9uJ3QgbWlzcyBhbnl0aGluZ1xuXHQjIGFzIHRva2VucyBhcmUgaW5zZXJ0ZWQgYW5kIHJlbW92ZWQsIGFuZCB0aGUgc3RyZWFtIGNoYW5nZXMgbGVuZ3RoIHVuZGVyXG5cdCMgb3VyIGZlZXQuXG5cdGRlZiBzY2FuVG9rZW5zIGJsb2NrXG5cdFx0dmFyIHRva2VucyA9IEB0b2tlbnNcblxuXHRcdHZhciBpID0gMFxuXHRcdHdoaWxlIHZhciB0b2tlbiA9IHRva2Vuc1tpXVxuXHRcdFx0aSArPSBibG9jay5jYWxsKHNlbGYsIHRva2VuLCBpLCB0b2tlbnMpXG5cblx0XHR0cnVlXG5cblx0ZGVmIGRldGVjdEVuZCBpLCBjb25kaXRpb24sIGFjdGlvblxuXHRcdHZhciB0b2tlbnMgPSBAdG9rZW5zXG5cdFx0dmFyIGxldmVscyA9IDBcblx0XHR2YXIgc3RhcnRzID0gW11cblx0XHR2YXIgdG9rZW5cblx0XHR2YXIgdCx2XG5cblx0XHR3aGlsZSB0b2tlbiA9IHRva2Vuc1tpXVxuXHRcdFx0aWYgbGV2ZWxzID09IDAgYW5kIGNvbmRpdGlvbi5jYWxsKHRoaXMsdG9rZW4saSxzdGFydHMpXG5cdFx0XHRcdHJldHVybiBhY3Rpb24uY2FsbChzZWxmLCB0b2tlbiwgaSlcblx0XHRcdGlmICF0b2tlbiBvciBsZXZlbHMgPCAwXG5cdFx0XHRcdHJldHVybiBhY3Rpb24uY2FsbChzZWxmLCB0b2tlbiwgaSAtIDEpXG5cblx0XHRcdHQgPSBULnR5cCh0b2tlbilcblxuXHRcdFx0aWYgRVhQUkVTU0lPTl9TVEFSVC5pbmRleE9mKHQpID49IDBcblx0XHRcdFx0c3RhcnRzLnB1c2goaSkgaWYgbGV2ZWxzID09IDBcblx0XHRcdFx0bGV2ZWxzICs9IDFcblx0XHRcdGVsaWYgRVhQUkVTU0lPTl9FTkQuaW5kZXhPZih0KSA+PSAwXG5cdFx0XHRcdGxldmVscyAtPSAxXG5cdFx0XHRpICs9IDFcblx0XHRpIC0gMVxuXG5cdGRlZiBlbnN1cmVGaXJzdExpbmVcblx0XHR2YXIgdG9rID0gQHRva2Vuc1swXVxuXG5cdFx0aWYgVC50eXAodG9rKSA9PSAnVEVSTUlOQVRPUidcblx0XHRcdCMgY29uc29sZS5sb2cgXCJhZGRpbmcgYm9keXN0YXJ0XCJcblx0XHRcdEB0b2tlbnMgPSBbVC50b2tlbignQk9EWVNUQVJUJywnQk9EWVNUQVJUJyldLmNvbmNhdChAdG9rZW5zKVxuXHRcdFx0IyBULnNldFR5cCh0b2ssJ0hFQURFUicpXG5cdFx0cmV0dXJuXG5cblx0IyBMZWFkaW5nIG5ld2xpbmVzIHdvdWxkIGludHJvZHVjZSBhbiBhbWJpZ3VpdHkgaW4gdGhlIGdyYW1tYXIsIHNvIHdlXG5cdCMgZGlzcGF0Y2ggdGhlbSBoZXJlLlxuXHRkZWYgcmVtb3ZlTGVhZGluZ05ld2xpbmVzXG5cdFx0dmFyIGF0ID0gMFxuXG5cdFx0Zm9yIHRva2VuLGkgaW4gQHRva2Vuc1xuXHRcdFx0aWYgVC50eXAodG9rZW4pICE9ICdURVJNSU5BVE9SJ1xuXHRcdFx0XHRicmVhayBhdCA9IGlcblx0XHRcblx0XHRAdG9rZW5zLnNwbGljZSgwLCBhdCkgaWYgYXRcblxuXHRcdHJldHVyblxuXG5cdCMgU29tZSBibG9ja3Mgb2NjdXIgaW4gdGhlIG1pZGRsZSBvZiBleHByZXNzaW9ucyAtLSB3aGVuIHdlJ3JlIGV4cGVjdGluZ1xuXHQjIHRoaXMsIHJlbW92ZSB0aGVpciB0cmFpbGluZyBuZXdsaW5lcy5cblx0ZGVmIHJlbW92ZU1pZEV4cHJlc3Npb25OZXdsaW5lc1xuXHRcdHNjYW5Ub2tlbnMgZG8gfHRva2VuLGksdG9rZW5zfCAjIGRvIHx0b2tlbixpLHRva2Vuc3xcblx0XHRcdHZhciBuZXh0ID0gdG9rZW5UeXBlKGkgKyAxKVxuXG5cdFx0XHRyZXR1cm4gMSB1bmxlc3MgVC50eXAodG9rZW4pIGlzICdURVJNSU5BVE9SJyBhbmQgRVhQUkVTU0lPTl9DTE9TRS5pbmRleE9mKG5leHQpID49IDBcblx0XHRcdHJldHVybiAxIGlmIG5leHQgPT0gJ09VVERFTlQnXG5cdFx0XHR0b2tlbnMuc3BsaWNlKGksIDEpXG5cdFx0XHQwXG5cblxuXHRkZWYgdGFnRGVmQXJndW1lbnRzXG5cdFx0eWVzXG5cblx0IyBUaGUgbGV4ZXIgaGFzIHRhZ2dlZCB0aGUgb3BlbmluZyBwYXJlbnRoZXNpcyBvZiBhIG1ldGhvZCBjYWxsLiBNYXRjaCBpdCB3aXRoXG5cdCMgaXRzIHBhaXJlZCBjbG9zZS4gV2UgaGF2ZSB0aGUgbWlzLW5lc3RlZCBvdXRkZW50IGNhc2UgaW5jbHVkZWQgaGVyZSBmb3Jcblx0IyBjYWxscyB0aGF0IGNsb3NlIG9uIHRoZSBzYW1lIGxpbmUsIGp1c3QgYmVmb3JlIHRoZWlyIG91dGRlbnQuXG5cdGRlZiBjbG9zZU9wZW5DYWxsc1xuXHRcdHZhciBjb25kaXRpb24gPSBkbyB8dG9rZW4saXxcblx0XHRcdHZhciB0ID0gVC50eXAodG9rZW4pXG5cdFx0XHQodCA9PSAnKScgb3IgdCA9PSAnQ0FMTF9FTkQnKSB8fCB0ID09ICdPVVRERU5UJyBhbmQgdG9rZW5UeXBlKGkgLSAxKSA9PSAnKSdcblxuXHRcdHZhciBhY3Rpb24gPSBkbyB8dG9rZW4sIGl8XG5cdFx0XHR2YXIgdCA9IFQudHlwKHRva2VuKVxuXHRcdFx0dmFyIHRvayA9IEB0b2tlbnNbdCA9PSAnT1VUREVOVCcgPyBpIC0gMSA6IGldXG5cdFx0XHRULnNldFR5cCh0b2ssJ0NBTExfRU5EJylcblxuXHRcdHNjYW5Ub2tlbnMgZG8gfHRva2VuLGl8XG5cdFx0XHRkZXRlY3RFbmQoaSArIDEsIGNvbmRpdGlvbiwgYWN0aW9uKSBpZiBULnR5cCh0b2tlbikgaXMgJ0NBTExfU1RBUlQnXG5cdFx0XHRyZXR1cm4gMVxuXG5cdCMgVGhlIGxleGVyIGhhcyB0YWdnZWQgdGhlIG9wZW5pbmcgcGFyZW50aGVzaXMgb2YgYW4gaW5kZXhpbmcgb3BlcmF0aW9uIGNhbGwuXG5cdCMgTWF0Y2ggaXQgd2l0aCBpdHMgcGFpcmVkIGNsb3NlLlxuXHRkZWYgY2xvc2VPcGVuSW5kZXhlc1xuXHRcdHZhciBjb25kaXRpb24gPSBkbyB8dG9rZW4sIGl8IFQudHlwKHRva2VuKSBpbiBbJ10nLCAnSU5ERVhfRU5EJ11cblx0XHR2YXIgYWN0aW9uICAgID0gZG8gfHRva2VuLCBpfCBULnNldFR5cCh0b2tlbiwnSU5ERVhfRU5EJylcblx0XHRcblx0XHRzY2FuVG9rZW5zIGRvIHx0b2tlbixpfFxuXHRcdFx0ZGV0ZWN0RW5kIGkgKyAxLCBjb25kaXRpb24sIGFjdGlvbiBpZiBULnR5cCh0b2tlbikgaXMgJ0lOREVYX1NUQVJUJ1xuXHRcdFx0cmV0dXJuIDFcblxuXHRcblx0ZGVmIGNsb3NlT3BlblRhZ0F0dHJMaXN0c1xuXHRcdHZhciBjb25kaXRpb24gPSBkbyB8dG9rZW4sIGl8IFQudHlwKHRva2VuKSBpbiBbJyknLCAnVEFHX0FUVFJTX0VORCddXG5cdFx0dmFyIGFjdGlvbiAgICA9IGRvIHx0b2tlbiwgaXwgVC5zZXRUeXAodG9rZW4sJ1RBR19BVFRSU19FTkQnKSAjICdUQUdfQVRUUlNfRU5EJ1xuXG5cdFx0c2NhblRva2VucyBkbyB8dG9rZW4saXxcblx0XHRcdGRldGVjdEVuZCBpICsgMSwgY29uZGl0aW9uLCBhY3Rpb24gaWYgVC50eXAodG9rZW4pIGlzICdUQUdfQVRUUlNfU1RBUlQnXG5cdFx0XHRyZXR1cm4gMVxuXHRcblx0IyBUaGUgbGV4ZXIgaGFzIHRhZ2dlZCB0aGUgb3BlbmluZyBwYXJlbnRoZXNpcyBvZiBhbiBpbmRleGluZyBvcGVyYXRpb24gY2FsbC5cblx0IyBNYXRjaCBpdCB3aXRoIGl0cyBwYWlyZWQgY2xvc2UuIFNob3VsZCBiZSBkb25lIGluIGxleGVyIGRpcmVjdGx5XG5cdGRlZiBjbG9zZU9wZW5UYWdzXG5cdFx0dmFyIGNvbmRpdGlvbiA9IGRvIHx0b2tlbiwgaXwgVC50eXAodG9rZW4pIGluIFsnPicsICdUQUdfRU5EJ11cblx0XHR2YXIgYWN0aW9uICAgID0gZG8gfHRva2VuLCBpfCBULnNldFR5cCh0b2tlbiwnVEFHX0VORCcpICMgdG9rZW5bMF0gPSAnVEFHX0VORCdcblxuXHRcdHNjYW5Ub2tlbnMgZG8gfHRva2VuLGl8XG5cdFx0XHRkZXRlY3RFbmQgaSArIDEsIGNvbmRpdGlvbiwgYWN0aW9uIGlmIFQudHlwKHRva2VuKSBpcyAnVEFHX1NUQVJUJ1xuXHRcdFx0cmV0dXJuIDFcblx0XHRcblx0ZGVmIGFkZEltcGxpY2l0Q29tbWFzXG5cdFx0cmV0dXJuXG5cblx0ZGVmIGFkZEltcGxpY2l0QmxvY2tDYWxsc1xuXHRcdHZhciBpID0gMVxuXHRcdHZhciB0b2tlbnMgPSBAdG9rZW5zXG5cblx0XHR3aGlsZSB2YXIgdG9rZW4gPSB0b2tlbnNbaV1cblx0XHRcdHZhciB0ID0gdG9rZW4uQHR5cGVcblx0XHRcdHZhciB2ID0gdG9rZW4uQHZhbHVlXG5cdFx0XHQjIGhtbVxuXHRcdFx0aWYgdCA9PSAnRE8nIGFuZCAodiA9PSAnSU5ERVhfRU5EJyBvciB2ID09ICdJREVOVElGSUVSJyBvciB2ID09ICdORVcnKVxuXHRcdFx0XHR0b2tlbnMuc3BsaWNlIGkgKyAxLCAwLCBULnRva2VuKCdDQUxMX0VORCcsJyknKVxuXHRcdFx0XHR0b2tlbnMuc3BsaWNlIGkgKyAxLCAwLCBULnRva2VuKCdDQUxMX1NUQVJUJywnKCcpXG5cdFx0XHRcdGkrK1xuXHRcdFx0aSsrXG5cblx0XHRyZXR1cm5cblxuXHQjIE9iamVjdCBsaXRlcmFscyBtYXkgYmUgd3JpdHRlbiB3aXRoIGltcGxpY2l0IGJyYWNlcywgZm9yIHNpbXBsZSBjYXNlcy5cblx0IyBJbnNlcnQgdGhlIG1pc3NpbmcgYnJhY2VzIGhlcmUsIHNvIHRoYXQgdGhlIHBhcnNlciBkb2Vzbid0IGhhdmUgdG8uXG5cdGRlZiBhZGRJbXBsaWNpdEJyYWNlc1xuXHRcdHZhciBzdGFjayAgICAgICA9IFtdXG5cdFx0dmFyIHN0YXJ0ICAgICAgID0gbnVsbFxuXHRcdHZhciBzdGFydEluZGVudCA9IDBcblx0XHR2YXIgc3RhcnRJZHggPSBudWxsXG5cblx0XHR2YXIgbm9CcmFjZVRhZyA9IFsnQ0xBU1MnLCAnSUYnLCdVTkxFU1MnLCdUQUcnLCdXSElMRScsJ0ZPUicsJ1VOVElMJywnQ0FUQ0gnLCdGSU5BTExZJywnTU9EVUxFJywnTEVBRElOR19XSEVOJ11cblx0XHR2YXIgbm9CcmFjZUNvbnRleHQgPSBbJ0lGJywnVEVSTkFSWScsJ0ZPUiddXG5cblx0XHR2YXIgbm9CcmFjZSA9IG5vXG5cblx0XHR2YXIgc2NvcGUgPSBkbyBcblx0XHRcdHN0YWNrW3N0YWNrOmxlbmd0aCAtIDFdIG9yIFtdXG5cblx0XHR2YXIgYWN0aW9uID0gZG8gfHRva2VuLGl8XG5cdFx0XHRAdG9rZW5zLnNwbGljZSBpLCAwLCBULlJCUkFDS0VUXG5cblx0XHR2YXIgb3BlbiA9IGRvIHx0b2tlbixpfFxuXHRcdFx0QHRva2Vucy5zcGxpY2UgaSwgMCwgVC5MQlJBQ0tFVFxuXG5cdFx0dmFyIGNsb3NlID0gZG8gfHRva2VuLGl8XG5cdFx0XHRAdG9rZW5zLnNwbGljZSBpLCAwLCBULlJCUkFDS0VUXG5cblx0XHR2YXIgc3RhY2tUb2tlbiA9IGRvIHxhLGJ8XG5cdFx0XHRyZXR1cm4gW2EsYl1cblxuXHRcdHNjYW5Ub2tlbnMgZG8gfHRva2VuLGksdG9rZW5zfFxuXHRcdFx0dmFyIHR5cGUgPSBULnR5cCh0b2tlbilcblx0XHRcdHZhciB2ID0gVC52YWwodG9rZW4pXG5cdFx0XHR2YXIgY3R4ID0gc3RhY2tbc3RhY2s6bGVuZ3RoIC0gMV0gb3IgW11cblx0XHRcdHZhciBpZHhcblxuXHRcdFx0aWYgbm9CcmFjZUNvbnRleHQuaW5kZXhPZih0eXBlKSA+PSAwXG5cdFx0XHRcdCMgY29uc29sZS5sb2cgXCJmb3VuZCBub0JyYWNlVGFnIHt0eXBlfVwiXG5cdFx0XHRcdHN0YWNrLnB1c2ggc3RhY2tUb2tlbih0eXBlLGkpXG5cdFx0XHRcdHJldHVybiAxXG5cblx0XHRcdGlmIHYgPT0gJz8nXG5cdFx0XHRcdCMgY29uc29sZS5sb2coJ1RFUk5BUlkgT1BFUkFUT1IhJylcblx0XHRcdFx0c3RhY2sucHVzaCBzdGFja1Rva2VuKCdURVJOQVJZJyxpKVxuXHRcdFx0XHRyZXR1cm4gMVxuXHRcdFx0XG5cdFx0XHQjIG5vIG5lZWQgdG8gdGVzdCBmb3IgdGhpcyBoZXJlIGFzIHdlbGwgYXMgaW5cblx0XHRcdGlmIEVYUFJFU1NJT05fU1RBUlQuaW5kZXhPZih0eXBlKSA+PSAwXG5cdFx0XHRcdGlmIHR5cGUgPT0gJ0lOREVOVCcgYW5kIG5vQnJhY2VDb250ZXh0LmluZGV4T2YoY3R4WzBdKSA+PSAwXG5cdFx0XHRcdFx0c3RhY2sucG9wXG5cblx0XHRcdFx0IyBjb25zb2xlLmxvZygnZXhwcmVzc2lvbiBzdGFydCcsdHlwZSxjdHhbMF0pXG5cdFx0XHRcdGlmIHR5cGUgPT0gJ0lOREVOVCcgYW5kIHRva2VuVHlwZShpIC0gMSkgPT0gJ3snXG5cdFx0XHRcdFx0IyBzdGFjayA/IT8gbm8gdG9rZW5cblx0XHRcdFx0XHRzdGFjay5wdXNoIHN0YWNrVG9rZW4oJ3snLCBpKSAjIHNob3VsZCBub3QgYXV0b2dlbmVyYXRlIGFub3RoZXI/XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRzdGFjay5wdXNoIHN0YWNrVG9rZW4odHlwZSwgaSlcblx0XHRcdFx0cmV0dXJuIDFcblxuXHRcdFx0aWYgRVhQUkVTU0lPTl9FTkQuaW5kZXhPZih0eXBlKSA+PSAwXG5cdFx0XHRcdCMgY29uc29sZS5sb2cgXCJFWFBSRVNTSU9OX0VORCBhdCB7dHlwZX0gLSBzdGFjayBpcyB7Y3R4WzBdfVwiXG5cdFx0XHRcdGlmIGN0eFswXSA9PSAnVEVSTkFSWScgIyBGSVg/XG5cdFx0XHRcdFx0c3RhY2sucG9wXG5cblx0XHRcdFx0c3RhcnQgPSBzdGFjay5wb3Bcblx0XHRcdFx0dW5sZXNzIHN0YXJ0XG5cdFx0XHRcdFx0Y29uc29sZS5sb2cgXCJOTyBTVEFDSyEhXCJcblx0XHRcdFx0c3RhcnRbMl0gPSBpXG5cblx0XHRcdFx0IyBzZWVtcyBsaWtlIHRoZSBzdGFjayBzaG91bGQgdXNlIHRva2Vucywgbm8/KVxuXHRcdFx0XHRpZiBzdGFydFswXSA9PSAneycgYW5kIHN0YXJ0OmdlbmVyYXRlZCAjICAjIHR5cGUgIT0gJ30nICMgYW5kIHN0YXJ0OmdlbmVyYXRlZFxuXHRcdFx0XHRcdGNsb3NlKHRva2VuLGkpXG5cdFx0XHRcdFx0cmV0dXJuIDFcblxuXHRcdFx0XHRyZXR1cm4gMVxuXHRcdFx0XG5cdFx0XHQjIGlzIHRoaXMgY29ycmVjdD8gc2FtZSBmb3IgaWYvY2xhc3MgZXRjP1xuXHRcdFx0aWYgY3R4WzBdID09ICdURVJOQVJZJyBhbmQgKHR5cGUgPT0gJ1RFUk1JTkFUT1InIG9yIHR5cGUgPT0gJ09VVERFTlQnKVxuXHRcdFx0XHRzdGFjay5wb3Bcblx0XHRcdFx0cmV0dXJuIDFcblxuXHRcdFx0aWYgbm9CcmFjZUNvbnRleHQuaW5kZXhPZihjdHhbMF0pID49IDAgYW5kIHR5cGUgPT0gJ0lOREVOVCdcblx0XHRcdFx0Y29uc29sZS5sb2cgXCJwb3BwaW5nIG5vQnJhY2VDb250ZXh0XCJcblx0XHRcdFx0c3RhY2sucG9wXG5cdFx0XHRcdHJldHVybiAxXG5cblxuXHRcdFx0aWYgdHlwZSA9PSAnLCdcblx0XHRcdFx0IyBhdXRvbWF0aWNhbGx5IGFkZCBhbiBlbmRpbmcgaGVyZSBpZiBpbnNpZGU6Z2VuZXJhdGVkIHNjb3BlP1xuXHRcdFx0XHQjIGl0IGlzIGltcG9ydGFudCB0aGF0IHRoaXMgaXM6Z2VuZXJhdGVkKCEpXG5cdFx0XHRcdGlmIGN0eFswXSA9PSAneycgYW5kIGN0eDpnZW5lcmF0ZWRcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKGksIDAsIFQuUkJSQUNLRVQpXG5cdFx0XHRcdFx0c3RhY2sucG9wXG5cdFx0XHRcdFx0cmV0dXJuIDJcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHJldHVybiAxXG5cdFx0XHRcdHRydWVcblxuXHRcdFx0IyBmb3VuZCBhIHR5cGVcblx0XHRcdGlmIHR5cGUgPT0gJzonIGFuZCBjdHhbMF0gIT0gJ3snIGFuZCBjdHhbMF0gIT0gJ1RFUk5BUlknIGFuZCAobm9CcmFjZUNvbnRleHQuaW5kZXhPZihjdHhbMF0pID09IC0xKVxuXHRcdFx0XHQjIGNvdWxkIGp1c3QgY2hlY2sgaWYgdGhlIGVuZCB3YXMgcmlnaHQgYmVmb3JlIHRoaXM/XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiBzdGFydCBhbmQgc3RhcnRbMl0gPT0gaSAtIDFcblx0XHRcdFx0XHQjIGNvbnNvbGUubG9nKCd0aGlzIGV4cHJlc3Npb24gd2FzIGp1c3QgZW5kaW5nIGJlZm9yZSBjb2xvbiEnKVxuXHRcdFx0XHRcdGlkeCA9IHN0YXJ0WzFdIC0gMSAjIHRoZXNlIGFyZSB0aGUgc3RhY2tUb2tlbnNcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdCMgY29uc29sZS5sb2cgXCJyZXdyaXRlIGhlcmU/ICN7aX1cIlxuXHRcdFx0XHRcdGlkeCA9IGkgLSAyICMgaWYgc3RhcnQgdGhlbiBzdGFydFsxXSAtIDEgZWxzZSBpIC0gMlxuXHRcdFx0XHRcdCMgaWR4ID0gaWR4IC0gMSBpZiB0b2tlblR5cGUoaWR4KSBpcyAnVEVSTUlOQVRPUidcblxuXHRcdFx0XHRpZHggLT0gMiB3aGlsZSB0b2tlblR5cGUoaWR4IC0gMSkgaXMgJ0hFUkVDT01NRU5UJ1xuXG5cdFx0XHRcdHZhciB0MCA9IHRva2Vuc1tpZHggLSAxXVxuXG5cdFx0XHRcdGlmIHQwIGFuZCBULnR5cCh0MCkgPT0gJ30nIGFuZCB0MDpnZW5lcmF0ZWRcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKGlkeCAtIDEsMSlcblx0XHRcdFx0XHR2YXIgcyA9IHN0YWNrVG9rZW4oJ3snKVxuXHRcdFx0XHRcdHM6Z2VuZXJhdGVkID0geWVzXG5cdFx0XHRcdFx0c3RhY2sucHVzaCBzXG5cdFx0XHRcdFx0cmV0dXJuIDBcblxuXHRcdFx0XHQjIGhhY2t5IGVkZ2VjYXNlIGZvciBpbmRlbnRzXG5cdFx0XHRcdGVsaWYgdDAgYW5kIFQudHlwKHQwKSA9PSAnLCcgYW5kIHRva2VuVHlwZShpZHggLSAyKSA9PSAnfSdcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKGlkeCAtIDIsMSlcblx0XHRcdFx0XHR2YXIgcyA9IHN0YWNrVG9rZW4oJ3snKVxuXHRcdFx0XHRcdHM6Z2VuZXJhdGVkID0geWVzXG5cdFx0XHRcdFx0c3RhY2sucHVzaCBzXG5cdFx0XHRcdFx0cmV0dXJuIDBcblxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0dmFyIHMgPSBzdGFja1Rva2VuKCd7Jylcblx0XHRcdFx0XHRzOmdlbmVyYXRlZCA9IHllc1xuXHRcdFx0XHRcdHN0YWNrLnB1c2ggc1xuXHRcdFx0XHRcdG9wZW4odG9rZW4saWR4ICsgMSlcblx0XHRcdFx0XHRyZXR1cm4gMlxuXG5cdFx0XHQjIHdlIHByb2JhYmx5IG5lZWQgdG8gcnVuIHRocm91Z2ggYXV0b2NhbGwgZmlyc3Q/IVxuXG5cdFx0XHRpZiB0eXBlID09ICdETycgIyBhbmQgY3R4OmdlbmVyYXRlZFxuXHRcdFx0XHR2YXIgcHJldiA9IFQudHlwKHRva2Vuc1tpIC0gMV0pICMgWzBdXG5cdFx0XHRcdGlmIFsnTlVNQkVSJywnU1RSSU5HJywnUkVHRVgnLCdTWU1CT0wnLCddJywnfScsJyknLCdTVFJJTkdfRU5EJ10uaW5kZXhPZihwcmV2KSA+PSAwXG5cblx0XHRcdFx0XHR2YXIgdG9rID0gVC50b2tlbignLCcsICcsJylcblx0XHRcdFx0XHR0b2s6Z2VuZXJhdGVkID0geWVzXG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZShpLDAsdG9rKVxuXG5cdFx0XHRcdFx0aWYgY3R4OmdlbmVyYXRlZFxuXHRcdFx0XHRcdFx0Y2xvc2UodG9rZW4saSlcblx0XHRcdFx0XHRcdHN0YWNrLnBvcFxuXHRcdFx0XHRcdFx0cmV0dXJuIDJcblxuXHRcdFx0aWYgKHR5cGUgPT0gJ1RFUk1JTkFUT1InIG9yIHR5cGUgPT0gJ09VVERFTlQnIG9yIHR5cGUgPT0gJ0RFRl9CT0RZJykgYW5kIGN0eDpnZW5lcmF0ZWRcblx0XHRcdFx0Y2xvc2UodG9rZW4saSlcblx0XHRcdFx0c3RhY2sucG9wXG5cdFx0XHRcdHJldHVybiAyXG5cblx0XHRcdHJldHVybiAxXG5cblx0IyBNZXRob2RzIG1heSBiZSBvcHRpb25hbGx5IGNhbGxlZCB3aXRob3V0IHBhcmVudGhlc2VzLCBmb3Igc2ltcGxlIGNhc2VzLlxuXHQjIEluc2VydCB0aGUgaW1wbGljaXQgcGFyZW50aGVzZXMgaGVyZSwgc28gdGhhdCB0aGUgcGFyc2VyIGRvZXNuJ3QgaGF2ZSB0b1xuXHQjIGRlYWwgd2l0aCB0aGVtLlxuXHQjIFByYWN0aWNhbGx5IGV2ZXJ5dGhpbmcgd2lsbCBub3cgYmUgY2FsbGFibGUgdGhpcyB3YXkgKGV2ZXJ5IGlkZW50aWZpZXIpXG5cdGRlZiBhZGRJbXBsaWNpdFBhcmVudGhlc2VzXG5cdFx0XG5cdFx0dmFyIG5vQ2FsbFRhZyA9IFsnQ0xBU1MnLCAnSUYnLCdVTkxFU1MnLCdUQUcnLCdXSElMRScsJ0ZPUicsJ1VOVElMJywnQ0FUQ0gnLCdGSU5BTExZJywnTU9EVUxFJywnTEVBRElOR19XSEVOJ11cblx0XHRcblx0XHR2YXIgYWN0aW9uID0gZG8gfHRva2VuLGl8XG5cdFx0XHRAdG9rZW5zLnNwbGljZSBpLCAwLCBULnRva2VuKCdDQUxMX0VORCcsICcpJylcblxuXHRcdCMgY29uc29sZS5sb2cgXCJhZGRpbmcgaW1wbGljaXQgcGFyZW50aGVzaXNcIiAjICxzZWxmOnNjYW5Ub2tlbnNcblx0XHR2YXIgdG9rZW5zID0gQHRva2Vuc1xuXG5cdFx0dmFyIG5vQ2FsbCA9IG5vXG5cdFx0dmFyIHNlZW5Gb3IgPSBub1xuXHRcdHZhciBlbmRDYWxsQXRUZXJtaW5hdG9yID0gbm9cblxuXHRcdHZhciBpID0gMFxuXHRcdHdoaWxlIHZhciB0b2tlbiA9IHRva2Vuc1tpXVxuXG5cdFx0XHQjIHRvIGhhbmRsZSBjYXNlcyBsaWtlOlxuXHRcdFx0IyBpZiBhKGRvIHllcykudGVzdFxuXHRcdFx0IyBcdHllc1xuXHRcdFx0IyB3ZSBuZWVkIHRvIGtlZXAgYSBzdGFjayBmb3IgYmFsYW5jZWQgcGFpcnNcblx0XHRcdCMgdW50aWwgdGhlbiB5b3UgbXVzdCBleHBsaWNpdGx5IGVuZCB0aGUgY2FsbCBsaWtlXG5cdFx0XHQjIGlmIGEoZG8geWVzKS50ZXN0KClcblx0XHRcdCMgXHR5ZXNcblxuXHRcdFx0dmFyIHR5cGUgPSB0b2tlbi5AdHlwZVxuXG5cdFx0XHR2YXIgcHJldiAgICA9IHRva2Vuc1tpIC0gMV1cblx0XHRcdHZhciBjdXJyZW50ID0gdG9rZW5zW2ldXG5cdFx0XHR2YXIgbmV4dCAgICA9IHRva2Vuc1tpICsgMV1cblxuXHRcdFx0dmFyIHB0ID0gcHJldiBhbmQgcHJldi5AdHlwZVxuXHRcdFx0dmFyIG50ID0gbmV4dCBhbmQgbmV4dC5AdHlwZVxuXG5cdFx0XHQjIGlmIHB0ID09ICdXSEVOJ1xuXHRcdFx0IyBOZXZlciBtYWtlIHRoZXNlIHRhZ3MgaW1wbGljaXRseSBjYWxsXG5cdFx0XHQjIHNob3VsZCB3ZSBub3QganVzdCByZW1vdmUgdGhlc2UgZnJvbSBJTVBMSUNJVF9GVU5DP1xuXHRcdFx0aWYgKHB0ID09ICcpJyBvciBwdCA9PSAnXScpIGFuZCB0eXBlID09ICdJTkRFTlQnXG5cdFx0XHRcdG5vQ2FsbCA9IHllc1xuXG5cdFx0XHRpZiBub0NhbGxUYWcuaW5kZXhPZihwdCkgPj0gMFxuXHRcdFx0XHQjIGNvbnNvbGUubG9nKFwic2VlbiBub2NhbGwgdGFnIHtwdH0gKHtwdH0ge3R5cGV9IHtudH0pXCIpXG5cdFx0XHRcdGVuZENhbGxBdFRlcm1pbmF0b3IgPSB5ZXNcblx0XHRcdFx0bm9DYWxsICA9IHllc1xuXHRcdFx0XHRzZWVuRm9yID0geWVzIGlmIHB0ID09ICdGT1InXG5cdFx0XHRcdFxuXG5cdFx0XHR2YXIgY2FsbE9iamVjdCA9IG5vXG5cdFx0XHR2YXIgY2FsbEluZGVudCA9IG5vXG5cblx0XHRcdCMgW3ByZXYsIGN1cnJlbnQsIG5leHRdID0gdG9rZW5zW2kgLSAxIC4uIGkgKyAxXVxuXG5cdFx0XHQjIGNoZWNrIGZvciBjb21tZW50c1xuXHRcdFx0IyBjb25zb2xlLmxvZyBcImRldGVjdCBlbmQ/P1wiXG5cdFx0XHRpZiAhbm9DYWxsIGFuZCB0eXBlID09ICdJTkRFTlQnIGFuZCBuZXh0XG5cdFx0XHRcdHZhciBwcmV2SW1wRnVuYyA9IHB0IGFuZCBJTVBMSUNJVF9GVU5DLmluZGV4T2YocHQpID49IDBcblx0XHRcdFx0dmFyIG5leHRJbXBDYWxsID0gbnQgYW5kIElNUExJQ0lUX0NBTEwuaW5kZXhPZihudCkgPj0gMFxuXHRcdFx0XHRjYWxsT2JqZWN0ID0gKChuZXh0OmdlbmVyYXRlZCBhbmQgbnQgaXMgJ3snKSBvciBuZXh0SW1wQ2FsbCkgYW5kIHByZXZJbXBGdW5jXG5cdFx0XHRcdGNhbGxJbmRlbnQgPSBuZXh0SW1wQ2FsbCBhbmQgcHJldkltcEZ1bmNcblxuXHRcdFx0dmFyIHNlZW5TaW5nbGUgID0gbm9cblx0XHRcdHZhciBzZWVuQ29udHJvbCA9IG5vXG5cdFx0XHQjIEhtbSA/XG5cblx0XHRcdCMgdGhpcyBpcyBub3QgY29ycmVjdCBpZiB0aGlzIGlzIGluc2lkZSBhIGJsb2NrLG5vP1xuXHRcdFx0aWYgKHR5cGUgPT0gJ1RFUk1JTkFUT1InIG9yIHR5cGUgPT0gJ09VVERFTlQnIG9yIHR5cGUgPT0gJ0lOREVOVCcpXG5cdFx0XHRcdGVuZENhbGxBdFRlcm1pbmF0b3IgPSBub1xuXHRcdFx0XHRub0NhbGwgPSBubyBcblxuXHRcdFx0dG9rZW46Y2FsbCAgPSB5ZXMgaWYgdHlwZSBpcyAnPycgYW5kIHByZXYgYW5kICFwcmV2OnNwYWNlZFxuXG5cdFx0XHQjIHdoZXJlIGRvZXMgZnJvbVRoZW0gY29tZSBmcm9tP1xuXHRcdFx0aWYgdG9rZW46ZnJvbVRoZW5cblx0XHRcdFx0Y29udGludWUgaSArPSAxIFxuXHRcdFx0IyBoZXJlIHdlIGRlYWwgd2l0aCA6c3BhY2VkIGFuZCA6bmV3TGluZVxuXHRcdFx0dW5sZXNzIGNhbGxPYmplY3Qgb3IgY2FsbEluZGVudCBvciAocHJldiBhbmQgcHJldjpzcGFjZWQpIGFuZCAocHJldjpjYWxsIG9yIElNUExJQ0lUX0ZVTkMuaW5kZXhPZihwdCkgPj0gMCkgYW5kIChJTVBMSUNJVF9DQUxMLmluZGV4T2YodHlwZSkgPj0gMCBvciAhKHRva2VuOnNwYWNlZCBvciB0b2tlbjpuZXdMaW5lKSBhbmQgSU1QTElDSVRfVU5TUEFDRURfQ0FMTC5pbmRleE9mKHR5cGUpID49IDApXG5cdFx0XHRcdGNvbnRpbnVlIGkgKz0gMVxuXG5cblx0XHRcdHRva2Vucy5zcGxpY2UgaSwgMCwgVC50b2tlbignQ0FMTF9TVEFSVCcsICcoJylcblx0XHRcdCMgY29uc29sZS5sb2cgXCJhZGRlZCAoIHtwcmV2fVwiXG5cdFx0XHR2YXIgY29uZCA9IGRvIHx0b2tlbixpfFxuXHRcdFx0XHR2YXIgdHlwZSA9IFQudHlwKHRva2VuKVxuXHRcdFx0XHRyZXR1cm4geWVzIGlmICFzZWVuU2luZ2xlIGFuZCB0b2tlbjpmcm9tVGhlblxuXHRcdFx0XHR2YXIgaWZlbHNlID0gdHlwZSA9PSAnSUYnIG9yIHR5cGUgPT0gJ1VOTEVTUycgb3IgdHlwZSA9PSAnRUxTRSdcblx0XHRcdFx0c2VlblNpbmdsZSAgPSB5ZXMgaWYgaWZlbHNlIG9yIHR5cGUgPT0gJ0NBVENIJ1xuXHRcdFx0XHRzZWVuQ29udHJvbCA9IHllcyBpZiBpZmVsc2Ugb3IgdHlwZSA9PSAnU1dJVENIJyBvciB0eXBlID09ICdUUlknXG5cdFx0XHRcdHZhciBwcmV2ID0gdG9rZW5UeXBlKGkgLSAxKVxuXG5cdFx0XHRcdHJldHVybiB5ZXMgaWYgKHR5cGUgPT0gJy4nIG9yIHR5cGUgPT0gJz8uJyBvciB0eXBlID09ICc6OicpIGFuZCBwcmV2IGlzICdPVVRERU5UJ1xuXHRcdFx0XHRyZXR1cm4geWVzIGlmIGVuZENhbGxBdFRlcm1pbmF0b3IgYW5kICh0eXBlID09ICdJTkRFTlQnIG9yIHR5cGUgPT0gJ1RFUk1JTkFUT1InKVxuXHRcdFx0XHRpZiAodHlwZSA9PSAnV0hFTicgb3IgdHlwZSA9PSAnQlknKSBhbmQgIXNlZW5Gb3Jcblx0XHRcdFx0XHQjIGNvbnNvbGUubG9nIFwiZG9udCBjbG9zZSBpbXBsaWNpdCBjYWxsIG91dHNpZGUgZm9yXCJcblx0XHRcdFx0XHRyZXR1cm4gbm8gXG5cblx0XHRcdFx0dmFyIHBvc3QgPSB0b2tlbnNbaSArIDFdXG5cdFx0XHRcdHZhciBwb3N0VHlwID0gcG9zdCBhbmQgVC50eXAocG9zdClcblx0XHRcdFx0IyBXVEZcblx0XHRcdFx0cmV0dXJuICF0b2tlbjpnZW5lcmF0ZWQgYW5kIHByZXYgaXNudCAnLCcgYW5kIChJTVBMSUNJVF9FTkQuaW5kZXhPZih0eXBlKSA+PSAwIG9yICh0eXBlIGlzICdJTkRFTlQnIGFuZCAhc2VlbkNvbnRyb2wpIG9yICh0eXBlIGlzICdET1MnIGFuZCBwcmV2ICE9ICc9JykpIGFuZCAodHlwZSBpc250ICdJTkRFTlQnIG9yICh0b2tlblR5cGUoaSAtIDIpIGlzbnQgJ0NMQVNTJyBhbmQgSU1QTElDSVRfQkxPQ0suaW5kZXhPZihwcmV2KSA9PSAtMSBhbmQgbm90IChwb3N0IGFuZCAoKHBvc3Q6Z2VuZXJhdGVkIGFuZCBwb3N0VHlwIGlzICd7Jykgb3IgSU1QTElDSVRfQ0FMTC5pbmRleE9mKHBvc3RUeXApID49IDApKSkpXG5cblx0XHRcdCMgVGhlIGFjdGlvbiBmb3IgZGV0ZWN0aW5nIHdoZW4gdGhlIGNhbGwgc2hvdWxkIGVuZFxuXHRcdFx0IyBjb25zb2xlLmxvZyBcImRldGVjdCBlbmQ/P1wiXG5cdFx0XHRkZXRlY3RFbmQoaSArIDEsIGNvbmQsIGFjdGlvbilcblx0XHRcdFQuc2V0VHlwKHByZXYsJ0ZVTkNfRVhJU1QnKSBpZiBULnR5cChwcmV2KSA9PSAnPydcblx0XHRcdGkgKz0gMlxuXHRcdFx0IyBuZWVkIHRvIHJlc2V0IGFmdGVyIGEgbWF0Y2hcblx0XHRcdGVuZENhbGxBdFRlcm1pbmF0b3IgPSBub1xuXHRcdFx0bm9DYWxsID0gbm9cblx0XHRcdHNlZW5Gb3IgPSBub1xuXG5cblx0XHRyZXR1cm5cblxuXHQjIEJlY2F1c2Ugb3VyIGdyYW1tYXIgaXMgTEFMUigxKSwgaXQgY2FuJ3QgaGFuZGxlIHNvbWUgc2luZ2xlLWxpbmVcblx0IyBleHByZXNzaW9ucyB0aGF0IGxhY2sgZW5kaW5nIGRlbGltaXRlcnMuIFRoZSAqKlJld3JpdGVyKiogYWRkcyB0aGUgaW1wbGljaXRcblx0IyBibG9ja3MsIHNvIGl0IGRvZXNuJ3QgbmVlZCB0by4gJyknIGNhbiBjbG9zZSBhIHNpbmdsZS1saW5lIGJsb2NrLFxuXHQjIGJ1dCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSBpdCdzIGJhbGFuY2VkLlxuXHRkZWYgYWRkSW1wbGljaXRJbmRlbnRhdGlvblxuXG5cdFx0XG5cdFx0dmFyIGkgPSAwXG5cdFx0dmFyIHRva2VucyA9IEB0b2tlbnNcblx0XHR3aGlsZSB2YXIgdG9rZW4gPSB0b2tlbnNbaV1cblx0XHRcdHZhciB0eXBlID0gVC50eXAodG9rZW4pXG5cdFx0XHR2YXIgbmV4dCA9IHRva2VuVHlwZShpICsgMSlcblxuXHRcdFx0IyB3aHkgYXJlIHdlIHJlbW92aW5nIHRlcm1pbmF0b3JzIGFmdGVyIHRoZW4/IHNob3VsZCBiZSBhYmxlIHRvIGhhbmRsZVxuXHRcdFx0aWYgdHlwZSA9PSAnVEVSTUlOQVRPUicgYW5kIG5leHQgPT0gJ1RIRU4nXG5cdFx0XHRcdHRva2Vucy5zcGxpY2UoaSwgMSlcblx0XHRcdFx0Y29udGludWVcblxuXHRcdFx0aWYgdHlwZSBpcyAnQ0FUQ0gnIGFuZCB0b2tlblR5cGUoaSArIDIpIGluIFsnT1VUREVOVCcsICdURVJNSU5BVE9SJywgJ0ZJTkFMTFknXVxuXHRcdFx0XHR0b2tlbnMuc3BsaWNlIGkgKyAyLCAwLCAqaW5kZW50YXRpb24odG9rZW4pXG5cdFx0XHRcdGNvbnRpbnVlIGkgKz0gNFxuXG5cdFx0XHRpZiBTSU5HTEVfTElORVJTLmluZGV4T2YodHlwZSkgPj0gMCBhbmQgKG5leHQgIT0gJ0lOREVOVCcgYW5kIG5leHQgIT0gJ0JMT0NLX1BBUkFNX1NUQVJUJykgYW5kIG5vdCAodHlwZSA9PSAnRUxTRScgYW5kIG5leHQgPT0gJ0lGJykgYW5kIHR5cGUgIT0gJ0VMSUYnXG5cblx0XHRcdFx0dmFyIHN0YXJ0ZXIgPSB0eXBlXG5cblx0XHRcdFx0dmFyIGluZGVudCA9IFQudG9rZW4oJ0lOREVOVCcsICcyJylcblx0XHRcdFx0dmFyIG91dGRlbnQgPSBULk9VVERFTlRcblx0XHRcdFx0IyB2YXIgaW5kZW50LCBvdXRkZW50ID0gaW5kZW50YXRpb24odG9rZW4pXG5cdFx0XHRcdGluZGVudDpmcm9tVGhlbiAgID0gdHJ1ZSBpZiBzdGFydGVyIGlzICdUSEVOJyAjIHNldHRpbmcgc3BlY2lhbCB2YWx1ZXMgZm9yIHRoZXNlIC0tIGNhbm5vdCByZWFsbHkgcmV1c2U/XG5cdFx0XHRcdGluZGVudDpnZW5lcmF0ZWQgID0gdHJ1ZVxuXHRcdFx0XHQjIG91dGRlbnQ6Z2VuZXJhdGVkID0gdHJ1ZVxuXHRcdFx0XHR0b2tlbnMuc3BsaWNlIGkgKyAxLCAwLCBpbmRlbnRcblxuXHRcdFx0XHR2YXIgY29uZGl0aW9uID0gZG8gfHRva2VuLGl8XG5cdFx0XHRcdFx0dmFyIHQgPSBULnR5cCh0b2tlbilcblx0XHRcdFx0XHRULnZhbCh0b2tlbikgIT0gJzsnIGFuZCBTSU5HTEVfQ0xPU0VSUy5pbmRleE9mKHQpID49IDAgYW5kIG5vdCAodCA9PSAnRUxTRScgYW5kIHN0YXJ0ZXIgIT0gJ0lGJyBhbmQgc3RhcnRlciAhPSAnVEhFTicpXG5cblx0XHRcdFx0dmFyIGFjdGlvbiA9IGRvIHx0b2tlbixpfFxuXHRcdFx0XHRcdHZhciBpZHggPSB0b2tlblR5cGUoaSAtIDEpIGlzICcsJyA/IGkgLSAxIDogaVxuXHRcdFx0XHRcdHRva2Vucy5zcGxpY2UgaWR4LCAwLCBvdXRkZW50XG5cblx0XHRcdFx0ZGV0ZWN0RW5kKGkgKyAyLCBjb25kaXRpb24sIGFjdGlvbilcblx0XHRcdFx0dG9rZW5zLnNwbGljZSBpLCAxIGlmIHR5cGUgaXMgJ1RIRU4nXG5cdFx0XHRcblx0XHRcdGkrK1xuXG5cdFx0cmV0dXJuXG5cblx0IyBUYWcgcG9zdGZpeCBjb25kaXRpb25hbHMgYXMgc3VjaCwgc28gdGhhdCB3ZSBjYW4gcGFyc2UgdGhlbSB3aXRoIGFcblx0IyBkaWZmZXJlbnQgcHJlY2VkZW5jZS5cblx0ZGVmIHRhZ1Bvc3RmaXhDb25kaXRpb25hbHNcblx0XHR2YXIgY29uZGl0aW9uID0gZG8gfHRva2VuLGl8IFQudHlwKHRva2VuKSBpbiBbJ1RFUk1JTkFUT1InLCAnSU5ERU5UJ11cblxuXHRcdHNjYW5Ub2tlbnMgZG8gfHRva2VuLCBpfFxuXHRcdFx0dmFyIHR5cCA9IFQudHlwKHRva2VuKVxuXHRcdFx0cmV0dXJuIDEgdW5sZXNzIHR5cCA9PSAnSUYnIG9yIHR5cCA9PSAnRk9SJ1xuXHRcdFx0dmFyIG9yaWdpbmFsID0gdG9rZW5cblx0XHRcdGRldGVjdEVuZChpICsgMSwgY29uZGl0aW9uKSBkbyB8dG9rZW4saXxcblx0XHRcdFx0VC5zZXRUeXAob3JpZ2luYWwsICdQT1NUXycgKyBULnR5cChvcmlnaW5hbCkpIGlmIFQudHlwKHRva2VuKSAhPSAnSU5ERU5UJ1xuXHRcdFx0MVxuXG5cdCMgR2VuZXJhdGUgdGhlIGluZGVudGF0aW9uIHRva2VucywgYmFzZWQgb24gYW5vdGhlciB0b2tlbiBvbiB0aGUgc2FtZSBsaW5lLlxuXHRkZWYgaW5kZW50YXRpb24gdG9rZW5cblx0XHRbVC50b2tlbignSU5ERU5UJywgJzInKSwgVC50b2tlbignT1VUREVOVCcsICcyJyldXG5cblx0IyBMb29rIHVwIGEgdHlwZSBieSB0b2tlbiBpbmRleC5cblx0ZGVmIHR5cGUgaSBcblx0XHQjIGlmIGkgPCAwIHRoZW4gcmV0dXJuIG51bGxcblx0XHR2YXIgdG9rID0gQHRva2Vuc1tpXVxuXHRcdHRvayBhbmQgVC50eXAodG9rKVxuXHRcdCMgaWYgdG9rIHRoZW4gdG9rWzBdIGVsc2UgbnVsbFxuXG5cdGRlZiB0b2tlblR5cGUgaSBcblx0XHR2YXIgdG9rID0gQHRva2Vuc1tpXVxuXHRcdHRvayBhbmQgVC50eXAodG9rKVxuXHRcdCMgcmV0dXJuIHRvayBhbmQgdG9rWzBdXG5cbiMgQ29uc3RhbnRzXG4jIC0tLS0tLS0tLVxuXG4jIExpc3Qgb2YgdGhlIHRva2VuIHBhaXJzIHRoYXQgbXVzdCBiZSBiYWxhbmNlZC5cbnZhciBCQUxBTkNFRF9QQUlSUyA9IFtcblx0WycoJywgJyknXVxuXHRbJ1snLCAnXSddXG5cdFsneycsICd9J11cblx0Wyd7eycsICd9fSddXG5cdFsnSU5ERU5UJywgJ09VVERFTlQnXSxcblx0WydDQUxMX1NUQVJUJywgJ0NBTExfRU5EJ11cblx0WydQQVJBTV9TVEFSVCcsICdQQVJBTV9FTkQnXVxuXHRbJ0lOREVYX1NUQVJUJywgJ0lOREVYX0VORCddXG5cdFsnVEFHX1NUQVJUJywnVEFHX0VORCddXG5cdFsnVEFHX1BBUkFNX1NUQVJUJywnVEFHX1BBUkFNX0VORCddXG5cdFsnVEFHX0FUVFJTX1NUQVJUJywnVEFHX0FUVFJTX0VORCddXG5cdFsnQkxPQ0tfUEFSQU1fU1RBUlQnLCdCTE9DS19QQVJBTV9FTkQnXVxuXVxuXG4jIFRoZSBpbnZlcnNlIG1hcHBpbmdzIG9mIGBCQUxBTkNFRF9QQUlSU2Agd2UncmUgdHJ5aW5nIHRvIGZpeCB1cCwgc28gd2UgY2FuXG4jIGxvb2sgdGhpbmdzIHVwIGZyb20gZWl0aGVyIGVuZC5cbmV4cG9ydCB2YXIgSU5WRVJTRVMgPSB7fVxuXG4jIFRoZSB0b2tlbnMgdGhhdCBzaWduYWwgdGhlIHN0YXJ0L2VuZCBvZiBhIGJhbGFuY2VkIHBhaXIuXG4jIHZhciBFWFBSRVNTSU9OX1NUQVJUID0gW11cbiMgdmFyIEVYUFJFU1NJT05fRU5EICAgPSBbXVxuXG5mb3IgcGFpciBpbiBCQUxBTkNFRF9QQUlSU1xuXHR2YXIgbGVmdCA9IHBhaXJbMF1cblx0dmFyIHJpdGUgPSBwYWlyWzFdXG5cdElOVkVSU0VTW3JpdGVdID0gbGVmdFxuXHRJTlZFUlNFU1tsZWZ0XSA9IHJpdGVcblxudmFyIEVYUFJFU1NJT05fU1RBUlQgPSBbJygnLCdbJywneycsJ0lOREVOVCcsJ0NBTExfU1RBUlQnLCdQQVJBTV9TVEFSVCcsJ0lOREVYX1NUQVJUJywnVEFHX1BBUkFNX1NUQVJUJywnQkxPQ0tfUEFSQU1fU1RBUlQnLCdTVFJJTkdfU1RBUlQnLCd7eycsICdUQUdfU1RBUlQnXVxudmFyIEVYUFJFU1NJT05fRU5EID0gWycpJywnXScsJ30nLCdPVVRERU5UJywnQ0FMTF9FTkQnLCdQQVJBTV9FTkQnLCdJTkRFWF9FTkQnLCdUQUdfUEFSQU1fRU5EJywnQkxPQ0tfUEFSQU1fRU5EJywnU1RSSU5HX0VORCcsJ319JywgJ1RBR19FTkQnXVxuXG52YXIgSURFTlRJRklFUlMgPSBbJ0lERU5USUZJRVInLCAnR1ZBUicsICdJVkFSJywgJ0NWQVInLCAnQ09OU1QnLCAnQVJHVkFSJ11cblxuIyBUb2tlbnMgdGhhdCBpbmRpY2F0ZSB0aGUgY2xvc2Ugb2YgYSBjbGF1c2Ugb2YgYW4gZXhwcmVzc2lvbi5cbnZhciBFWFBSRVNTSU9OX0NMT1NFID0gWydDQVRDSCcsICdXSEVOJywgJ0VMU0UnLCAnRklOQUxMWSddLmNvbmNhdCBFWFBSRVNTSU9OX0VORFxuXG4jIFRva2VucyB0aGF0LCBpZiBmb2xsb3dlZCBieSBhbiBgSU1QTElDSVRfQ0FMTGAsIGluZGljYXRlIGEgZnVuY3Rpb24gaW52b2NhdGlvbi5cbnZhciBJTVBMSUNJVF9GVU5DICAgID0gWydJREVOVElGSUVSJywgJ1NVUEVSJywgIyAnKScsICdJTkRFWF9FTkQnLCAjICAnQ0FMTF9FTkQnLFxuXHQnQCcsICdUSElTJywnU0VMRicsICdFVkVOVCcsJ1RSSUdHRVInLCdUQUdfRU5EJywgJ0lWQVInLCBcblx0J0dWQVInLCAnQ09OU1QnLCAnQVJHVkFSJywgJ05FVycsICdCUkVBSycsICdDT05USU5VRScsJ1JFVFVSTidcbl1cblxuIyBJZiBwcmVjZWRlZCBieSBhbiBgSU1QTElDSVRfRlVOQ2AsIGluZGljYXRlcyBhIGZ1bmN0aW9uIGludm9jYXRpb24uXG52YXIgSU1QTElDSVRfQ0FMTCAgICA9IFtcblx0J1NFTEVDVE9SJywnSURFTlRJRklFUicsICdOVU1CRVInLCAnU1RSSU5HJywgJ1NZTUJPTCcsICdKUycsICdSRUdFWCcsICdORVcnLCAnUEFSQU1fU1RBUlQnLCAnQ0xBU1MnXG5cdCdJRicsICdVTkxFU1MnLCAnVFJZJywgJ1NXSVRDSCcsICdUSElTJywgJ0JPT0wnLCAnVFJVRScsJ0ZBTFNFJywgJ05VTEwnLCAnVU5ERUZJTkVEJywgJ1VOQVJZJywgJ1NVUEVSJywgJ0lWQVInLCAnR1ZBUicsICdDT05TVCcsICdBUkdWQVInLCdTRUxGJywgXG5cdCdAJywgJ1snLCAnKCcsICd7JywgJy0tJywgJysrJywnU0VMRUNUT1InLCAnVEFHX1NUQVJUJywgJ1RBR0lEJywgJyMnLCAnU0VMRUNUT1JfU1RBUlQnLCAnSURSRUYnLCAnU1BMQVQnLCAnRE8nLCAnQkxPQ0tfQVJHJ1xuXHQnRk9SJywgJ1NUUklOR19TVEFSVCcsJ0NPTlRJTlVFJywnQlJFQUsnXG5dICMgJy0+JywgJz0+Jywgd2h5IGRvZXMgaXQgbm90IHdvcmsgd2l0aCBzeW1ib2w/XG5cbnZhciBJTVBMSUNJVF9JTkRFTlRfQ0FMTCA9IFtcblx0J0ZPUidcbl1cbiMgaXMgbm90IGRvIGFuIGltcGxpY2l0IGNhbGw/P1xuXG52YXIgSU1QTElDSVRfVU5TUEFDRURfQ0FMTCA9IFsnKycsICctJ11cblxuIyBUb2tlbnMgaW5kaWNhdGluZyB0aGF0IHRoZSBpbXBsaWNpdCBjYWxsIG11c3QgZW5jbG9zZSBhIGJsb2NrIG9mIGV4cHJlc3Npb25zLlxudmFyIElNUExJQ0lUX0JMT0NLICAgPSBbJ3snLCAnWycsICcsJywnQkxPQ0tfUEFSQU1fRU5EJywgJ0RPJ10gIyAnLT4nLCAnPT4nLCBcblxudmFyIENPTkRJVElPTkFMX0FTU0lHTiA9IFsnfHw9JywgJyYmPScsICc/PScsICcmPScsICd8PSddXG52YXIgQ09NUE9VTkRfQVNTSUdOID0gWyctPScsICcrPScsICcvPScsICcqPScsICclPScsICd8fD0nLCAnJiY9JywgJz89JywgJzw8PScsICc+Pj0nLCAnPj4+PScsICcmPScsICdePScsICd8PSddXG52YXIgVU5BUlkgPSBbJyEnLCAnficsICdORVcnLCAnVFlQRU9GJywgJ0RFTEVURSddXG52YXIgTE9HSUMgICA9IFsnJiYnLCAnfHwnLCAnJicsICd8JywgJ14nXVxuXG4jIG9wdGltaXplIGZvciBmaXhlZCBhcnJheXNcbnZhciBOT19JTVBMSUNJVF9CTE9DS19DQUxMID0gW1xuXHQnQ0FMTF9FTkQnLCc9JywnREVGX0JPRFknLCcoJywnQ0FMTF9TVEFSVCcsJywnLCc6JywnUkVUVVJOJ1xuXHQnLT0nLCAnKz0nLCAnLz0nLCAnKj0nLCAnJT0nLCAnfHw9JywgJyYmPScsICc/PScsICc8PD0nLCAnPj49JywgJz4+Pj0nLCAnJj0nLCAnXj0nLCAnfD0nXG5dICMgLmNvbmNhdChDT01QT1VORF9BU1NJR04pXG5cblxuIyBjb25zb2xlLmxvZyBOT19JTVBMSUNJVF9CTE9DS19DQUxMOmxlbmd0aFxuIyBOT19JTVBMSUNJVF9CTE9DS19DQUxMXG4jIElNUExJQ0lUX0NPTU1BID0gWyctPicsICc9PicsICd7JywgJ1snLCAnTlVNQkVSJywgJ1NUUklORycsICdTWU1CT0wnLCAnSURFTlRJRklFUicsJ0RPJ11cblxudmFyIElNUExJQ0lUX0NPTU1BID0gWydETyddXG5cbiMgVG9rZW5zIHRoYXQgYWx3YXlzIG1hcmsgdGhlIGVuZCBvZiBhbiBpbXBsaWNpdCBjYWxsIGZvciBzaW5nbGUtbGluZXJzLlxudmFyIElNUExJQ0lUX0VORCAgICAgPSBbJ1BPU1RfSUYnLCAnUE9TVF9VTkxFU1MnLCAnUE9TVF9GT1InLCAnV0hJTEUnLCAnVU5USUwnLCAnV0hFTicsICdCWScsICdMT09QJywgJ1RFUk1JTkFUT1InLCdERUZfQk9EWScsJ0RFRl9GUkFHTUVOVCddXG5cbiMgU2luZ2xlLWxpbmUgZmxhdm9ycyBvZiBibG9jayBleHByZXNzaW9ucyB0aGF0IGhhdmUgdW5jbG9zZWQgZW5kaW5ncy5cbiMgVGhlIGdyYW1tYXIgY2FuJ3QgZGlzYW1iaWd1YXRlIHRoZW0sIHNvIHdlIGluc2VydCB0aGUgaW1wbGljaXQgaW5kZW50YXRpb24uXG52YXIgU0lOR0xFX0xJTkVSUyAgICA9IFsnRUxTRScsICdUUlknLCAnRklOQUxMWScsICdUSEVOJywnQkxPQ0tfUEFSQU1fRU5EJywnRE8nLCdCRUdJTicsJ0NBVENIX1ZBUiddICMgJy0+JywgJz0+JywgcmVhbGx5P1xudmFyIFNJTkdMRV9DTE9TRVJTICAgPSBbJ1RFUk1JTkFUT1InLCAnQ0FUQ0gnLCAnRklOQUxMWScsICdFTFNFJywgJ09VVERFTlQnLCAnTEVBRElOR19XSEVOJ11cblxuIyBUb2tlbnMgdGhhdCBlbmQgYSBsaW5lLlxudmFyIExJTkVCUkVBS1MgICAgICAgPSBbJ1RFUk1JTkFUT1InLCAnSU5ERU5UJywgJ09VVERFTlQnXVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogc3JjL2NvbXBpbGVyL3Jld3JpdGVyLmltYmFcbiAqKi8iLCIvKiBwYXJzZXIgZ2VuZXJhdGVkIGJ5IGppc29uLWZvcmsgKi9cbnZhciBwYXJzZXIgPSAoZnVuY3Rpb24oKXtcbnZhciBvPWZ1bmN0aW9uKGssdixvLGwpe2ZvcihvPW98fHt9LGw9ay5sZW5ndGg7bC0tO29ba1tsXV09dik7cmV0dXJuIG99LCRWMD1bMSw0XSwkVjE9WzEsNl0sJFYyPVsxLDMyXSwkVjM9WzEsMzNdLCRWND1bMSwzNF0sJFY1PVsxLDM1XSwkVjY9WzEsNzVdLCRWNz1bMSwxMTVdLCRWOD1bMSwxMjhdLCRWOT1bMSwxMjFdLCRWYT1bMSwxMjJdLCRWYj1bMSwxMjNdLCRWYz1bMSwxMjBdLCRWZD1bMSwxMjRdLCRWZT1bMSwxMzFdLCRWZj1bMSwxMTRdLCRWZz1bMSwxMzJdLCRWaD1bMSw4MF0sJFZpPVsxLDgxXSwkVmo9WzEsODJdLCRWaz1bMSw4M10sJFZsPVsxLDg0XSwkVm09WzEsODVdLCRWbj1bMSw4Nl0sJFZvPVsxLDczXSwkVnA9WzEsMTE4XSwkVnE9WzEsOTVdLCRWcj1bMSw5MV0sJFZzPVsxLDg4XSwkVnQ9WzEsNzFdLCRWdT1bMSw2NV0sJFZ2PVsxLDY2XSwkVnc9WzEsMTExXSwkVng9WzEsOTBdLCRWeT1bMSw4N10sJFZ6PVsxLDI4XSwkVkE9WzEsMjldLCRWQj1bMSw5Nl0sJFZDPVsxLDk0XSwkVkQ9WzEsMTEyXSwkVkU9WzEsMTEzXSwkVkY9WzEsMTI2XSwkVkc9WzEsNjddLCRWSD1bMSw2OF0sJFZJPVsxLDExOV0sJFZKPVsxLDExXSwkVks9WzEsMTI3XSwkVkw9WzEsNzhdLCRWTT1bMSwzN10sJFZOPVsxLDQzXSwkVk89WzEsMTEwXSwkVlA9WzEsNjldLCRWUT1bMSw4OV0sJFZSPVsxLDEyNV0sJFZTPVsxLDU5XSwkVlQ9WzEsNzRdLCRWVT1bMSwxMDVdLCRWVj1bMSwxMDZdLCRWVz1bMSwxMDddLCRWWD1bMSwxMjldLCRWWT1bMSwxMzBdLCRWWj1bMSw2M10sJFZfPVsxLDEwNF0sJFYkPVsxLDUxXSwkVjAxPVsxLDUyXSwkVjExPVsxLDUzXSwkVjIxPVsxLDU0XSwkVjMxPVsxLDU1XSwkVjQxPVsxLDU2XSwkVjUxPVsxLDEzNF0sJFY2MT1bMSw2LDExLDEzN10sJFY3MT1bMSwxMzZdLCRWODE9WzEsNiwxMSwxNCwxMzddLCRWOTE9WzEsMTQ0XSwkVmExPVsxLDE0NV0sJFZiMT1bMSwxNDddLCRWYzE9WzEsMTQ4XSwkVmQxPVsxLDE0MV0sJFZlMT1bMSwxNDBdLCRWZjE9WzEsMTQyXSwkVmcxPVsxLDE0M10sJFZoMT1bMSwxNDZdLCRWaTE9WzEsMTUxXSwkVmoxPVsxLDYsMTAsMTEsMTQsMjIsNzEsOTAsOTcsMTA2LDExMiwxMjYsMTM1LDEzNywxNDcsMTcxLDIwMCwyMDEsMjEyLDIxMywyMTQsMjE5LDIyMCwyMjksMjM4LDIzOSwyNDIsMjQzLDI0NiwyNDcsMjQ4XSwkVmsxPVsyLDI2M10sJFZsMT1bMSwxNThdLCRWbTE9WzEsMTY0XSwkVm4xPVsxLDE2Ml0sJFZvMT1bMSwxNjBdLCRWcDE9WzEsMTYxXSwkVnExPVsxLDE2NV0sJFZyMT1bMSwxNjNdLCRWczE9WzEsNiwxMCwxMSwxNCwyMiw5MCw5NywxMzddLCRWdDE9WzEsNiwxMSwxNCwxMzcsMjEyLDIxNCwyMTksMjIwLDIzOF0sJFZ1MT1bMSw2LDEwLDExLDE0LDIxLDIyLDcxLDg4LDg5LDkwLDk3LDEwNiwxMTEsMTEyLDEyNiwxMzUsMTM3LDE0NCwxNDcsMTcxLDE4MCwxODEsMTgzLDE5NiwyMDAsMjAxLDIxMiwyMTMsMjE0LDIxOSwyMjAsMjI5LDIzOCwyMzksMjQyLDI0MywyNDYsMjQ3LDI0OF0sJFZ2MT1bMiwyMzFdLCRWdzE9WzEsMTc4XSwkVngxPVsxLDE3Nl0sJFZ5MT1bMSw2LDEwLDExLDE0LDIxLDIyLDcxLDg4LDg5LDkwLDk3LDEwNiwxMTEsMTEyLDExNywxMjYsMTM1LDEzNywxNDQsMTQ3LDE3MSwxODAsMTgxLDE4MywxOTYsMjAwLDIwMSwyMTIsMjEzLDIxNCwyMTksMjIwLDIyOSwyMzgsMjM5LDI0MiwyNDMsMjQ2LDI0NywyNDhdLCRWejE9WzIsMjI3XSwkVkExPVs2LDE0LDUzLDU0LDg4LDkxLDEwNiwxMTEsMTEzLDExNl0sJFZCMT1bMSwyMTJdLCRWQzE9WzEsMjE3XSwkVkQxPVsxLDYsMTAsMTEsMTQsMjEsMjIsNzEsODgsODksOTAsOTcsMTA2LDExMSwxMTIsMTE3LDEyNiwxMzUsMTM3LDE0NCwxNDcsMTcxLDE4MCwxODEsMTgzLDE5NiwyMDAsMjAxLDIxMiwyMTMsMjE0LDIxOSwyMjAsMjI5LDIzOCwyMzksMjQyLDI0MywyNDQsMjQ1LDI0NiwyNDcsMjQ4LDI0OV0sJFZFMT1bMSwyMjddLCRWRjE9WzEsMjI0XSwkVkcxPVsxLDIyOV0sJFZIMT1bNiwxMCwxNCw5MF0sJFZJMT1bMiwyNDRdLCRWSjE9WzEsMjU3XSwkVksxPVsxLDI0N10sJFZMMT1bMSwyNzZdLCRWTTE9WzEsMjc3XSwkVk4xPVs1MSw4OV0sJFZPMT1bODUsODYsODcsODgsOTEsOTIsOTMsOTQsOTUsOTYsMTAwLDEwMl0sJFZQMT1bMSwyODldLCRWUTE9WzEsNiwxMCwxMSwxNCwyMSwyMiw1Myw1NCw3MSw4OCw4OSw5MCw5MSw5NywxMDYsMTExLDExMiwxMTMsMTE2LDExNywxMjYsMTM1LDEzNywxNDQsMTQ3LDE3MSwxODAsMTgxLDE4MywxOTYsMjAwLDIwMSwyMTIsMjEzLDIxNCwyMTksMjIwLDIyOSwyMzgsMjM5LDI0MiwyNDMsMjQ0LDI0NSwyNDYsMjQ3LDI0OCwyNDldLCRWUjE9WzEsMjk1XSwkVlMxPVs1MSw4OSw5NiwyMjVdLCRWVDE9WzEsNiwxMCwxMSwxNCwyMSwyMiw2Nyw2OSw3MCw3MSw4OCw4OSw5MCw5NywxMDYsMTExLDExMiwxMjYsMTM1LDEzNywxNDQsMTQ3LDE3MSwxODAsMTgxLDE4MywxOTYsMjAwLDIwMSwyMTIsMjEzLDIxNCwyMTksMjIwLDIyOSwyMzgsMjM5LDI0MiwyNDMsMjQ2LDI0NywyNDhdLCRWVTE9WzEsNiwxMCwxMSwxNCwyMSwyMiw3MSw4OCw4OSw5MCw5NywxMDYsMTExLDExMiwxMjYsMTM1LDEzNywxNDQsMTQ3LDE3MSwxODAsMTgxLDE4MywxOTYsMjAwLDIwMSwyMDcsMjA4LDIxMiwyMTMsMjE0LDIxOSwyMjAsMjI5LDIzMiwyMzQsMjM3LDIzOCwyMzksMjQyLDI0MywyNDYsMjQ3LDI0OF0sJFZWMT1bNTEsNTMsNTQsNThdLCRWVzE9WzEsMzI2XSwkVlgxPVsxLDMyN10sJFZZMT1bMSw2LDEwLDExLDE0LDIyLDcxLDkwLDk3LDEwNiwxMTIsMTM1LDEzNywxNDcsMjAwLDIwMSwyMTIsMjEzLDIxNCwyMTksMjIwLDIyOSwyMzhdLCRWWjE9WzEsMzQwXSwkVl8xPVsxLDM0NF0sJFYkMT1bMSw2LDExLDE0LDIyLDcxLDkwLDk3LDEwNiwxMTIsMTI2LDEzNSwxMzcsMTQ3LDE3MSwyMDAsMjAxLDIxMiwyMTMsMjE0LDIxOSwyMjAsMjI5LDIzOCwyMzksMjQyLDI0MywyNDYsMjQ3LDI0OF0sJFYwMj1bNiwxNCwxMDZdLCRWMTI9WzEsMzU0XSwkVjIyPVsxLDYsMTAsMTEsMTQsMjEsMjIsNzEsODksOTAsOTcsMTA2LDExMiwxMjYsMTM1LDEzNywxNDcsMTcxLDIwMCwyMDEsMjEyLDIxMywyMTQsMjE5LDIyMCwyMjksMjM4LDIzOSwyNDIsMjQzLDI0NiwyNDcsMjQ4XSwkVjMyPVsxNCwyOF0sJFY0Mj1bMSw2LDExLDE0LDI4LDEzNywyMTIsMjE0LDIxOSwyMjAsMjM4XSwkVjUyPVsyLDI4NF0sJFY2Mj1bMSw2LDEwLDExLDE0LDIxLDIyLDcxLDg4LDg5LDkwLDk3LDEwNiwxMTEsMTEyLDExNywxMjYsMTM1LDEzNywxNDQsMTQ3LDE3MSwxODAsMTgxLDE4MywxOTYsMjAwLDIwMSwyMTIsMjEzLDIxNCwyMTksMjIwLDIyNywyMjgsMjI5LDIzOCwyMzksMjQyLDI0MywyNDQsMjQ1LDI0NiwyNDcsMjQ4LDI0OV0sJFY3Mj1bMiwxODRdLCRWODI9WzEsMzY5XSwkVjkyPVs2LDEwLDExLDE0LDIyLDk3XSwkVmEyPVsxNCwxNDddLCRWYjI9WzIsMTg2XSwkVmMyPVsxLDM3OV0sJFZkMj1bMSwzODBdLCRWZTI9WzEsMzgxXSwkVmYyPVsxLDM4NV0sJFZnMj1bNiwxMCwxMSwxNCw5MF0sJFZoMj1bNiwxMCwxMSwxNCw5MCwxMzVdLCRWaTI9WzEsNiwxMCwxMSwxNCwyMiw3MSw5MCw5NywxMDYsMTEyLDEzNSwxMzcsMTQ3LDIwMCwyMDEsMjIwLDIyOSwyMzhdLCRWajI9WzEsNiwxMCwxMSwxNCwyMiw3MSw5MCw5NywxMDYsMTEyLDEzNSwxMzcsMTQ3LDIwMCwyMDEsMjEzLDIyMCwyMjksMjM4XSwkVmsyPVsyMjcsMjI4XSwkVmwyPVsxNCwyMjcsMjI4XSwkVm0yPVsxLDYsMTEsMTQsMjIsNzEsOTAsOTcsMTA2LDExMiwxMzUsMTM3LDE0NywxNzEsMjAwLDIwMSwyMTIsMjEzLDIxNCwyMTksMjIwLDIyOSwyMzgsMjM5LDI0MiwyNDMsMjQ2LDI0NywyNDhdLCRWbjI9Wzg4LDkxXSwkVm8yPVsxLDQwNl0sJFZwMj1bMSw0MDddLCRWcTI9WzIxLDg4LDkxLDE2NCwxNjVdLCRWcjI9WzEsNiwxMCwxMSwxNCwyMiw3MSw5MCw5NywxMDYsMTEyLDEyNiwxMzUsMTM3LDE0NywxNzEsMjAwLDIwMSwyMTIsMjEzLDIxNCwyMTksMjIwLDIyOSwyMzgsMjM5LDI0MiwyNDMsMjQ3LDI0OF0sJFZzMj1bMSw2LDEwLDExLDE0LDIyLDcxLDkwLDk3LDEwNiwxMTIsMTM1LDEzNywxNDcsMjAwLDIwMSwyMTMsMjI5XSwkVnQyPVsxOSwyMCwyMywyNCwyNiwzMiw1MSw1Myw1NCw1Niw1OCw2MCw2Miw2NCw2Niw3Myw3NCw3NSw3Niw3Nyw3OCw3OSw4MCw4Myw4OSw5MSw5NiwxMDMsMTEyLDEyMiwxMjMsMTI0LDEzMCwxMzYsMTQzLDE0NCwxNTEsMTUyLDE1NCwxNTYsMTU3LDE1OCwxNzUsMTg0LDE4NSwxODgsMTkzLDE5NCwxOTcsMTk4LDIwNCwyMTAsMjEyLDIxNCwyMTYsMjE5LDIyMCwyMzAsMjM2LDI0MCwyNDEsMjQyLDI0MywyNDQsMjQ1XSwkVnUyPVsxLDYsMTAsMTEsMTQsMjIsNzEsOTAsOTcsMTA2LDExMiwxMjYsMTM1LDEzNywxNDcsMTcxLDIwMCwyMDEsMjEyLDIxMywyMTQsMjE5LDIyMCwyMjksMjMyLDIzNywyMzgsMjM5LDI0MiwyNDMsMjQ2LDI0NywyNDhdLCRWdjI9WzExLDIzMiwyMzRdLCRWdzI9WzEsNDUzXSwkVngyPVsyLDE4NV0sJFZ5Mj1bNiwxMCwxMV0sJFZ6Mj1bMSw0NjFdLCRWQTI9WzE0LDIyLDE0N10sJFZCMj1bMSw0NjldLCRWQzI9WzEsNiwxMCwxMSwxNCwyMiw3MSw5MCw5NywxMDYsMTEyLDEzNSwxMzcsMTQ3LDIwMCwyMDEsMjEyLDIxNCwyMTksMjIwLDIyOSwyMzhdLCRWRDI9WzUxLDU4LDg5XSwkVkUyPVsxNCwyMl0sJFZGMj1bMSw0OTJdLCRWRzI9WzEwLDE0XSwkVkgyPVsxLDU0Ml0sJFZJMj1bNiwxMF07XG52YXIgcGFyc2VyID0ge3RyYWNlOiBmdW5jdGlvbiB0cmFjZSgpIHsgfSxcbnl5OiB7fSxcbnN5bWJvbHNfOiB7XCJlcnJvclwiOjIsXCJSb290XCI6MyxcIkJvZHlcIjo0LFwiQmxvY2tcIjo1LFwiVEVSTUlOQVRPUlwiOjYsXCJCT0RZU1RBUlRcIjo3LFwiTGluZVwiOjgsXCJUZXJtaW5hdG9yXCI6OSxcIklOREVOVFwiOjEwLFwiT1VUREVOVFwiOjExLFwiU3BsYXRcIjoxMixcIkV4cHJlc3Npb25cIjoxMyxcIixcIjoxNCxcIkNvbW1lbnRcIjoxNSxcIlN0YXRlbWVudFwiOjE2LFwiUmV0dXJuXCI6MTcsXCJUaHJvd1wiOjE4LFwiU1RBVEVNRU5UXCI6MTksXCJCUkVBS1wiOjIwLFwiQ0FMTF9TVEFSVFwiOjIxLFwiQ0FMTF9FTkRcIjoyMixcIkNPTlRJTlVFXCI6MjMsXCJERUJVR0dFUlwiOjI0LFwiSW1wb3J0U3RhdGVtZW50XCI6MjUsXCJJTVBPUlRcIjoyNixcIkltcG9ydEFyZ0xpc3RcIjoyNyxcIkZST01cIjoyOCxcIkltcG9ydEZyb21cIjoyOSxcIkFTXCI6MzAsXCJJbXBvcnRBcmdcIjozMSxcIlNUUklOR1wiOjMyLFwiVmFySWRlbnRpZmllclwiOjMzLFwiQXdhaXRcIjozNCxcIlZhbHVlXCI6MzUsXCJDb2RlXCI6MzYsXCJPcGVyYXRpb25cIjozNyxcIkFzc2lnblwiOjM4LFwiSWZcIjozOSxcIlRlcm5hcnlcIjo0MCxcIlRyeVwiOjQxLFwiV2hpbGVcIjo0MixcIkZvclwiOjQzLFwiU3dpdGNoXCI6NDQsXCJDbGFzc1wiOjQ1LFwiTW9kdWxlXCI6NDYsXCJUYWdEZWNsYXJhdGlvblwiOjQ3LFwiVGFnXCI6NDgsXCJQcm9wZXJ0eVwiOjQ5LFwiSWRlbnRpZmllclwiOjUwLFwiSURFTlRJRklFUlwiOjUxLFwiSXZhclwiOjUyLFwiSVZBUlwiOjUzLFwiQ1ZBUlwiOjU0LFwiR3ZhclwiOjU1LFwiR1ZBUlwiOjU2LFwiQ29uc3RcIjo1NyxcIkNPTlNUXCI6NTgsXCJBcmd2YXJcIjo1OSxcIkFSR1ZBUlwiOjYwLFwiU3ltYm9sXCI6NjEsXCJTWU1CT0xcIjo2MixcIkFscGhhTnVtZXJpY1wiOjYzLFwiTlVNQkVSXCI6NjQsXCJJbnRlcnBvbGF0ZWRTdHJpbmdcIjo2NSxcIlNUUklOR19TVEFSVFwiOjY2LFwiTkVPU1RSSU5HXCI6NjcsXCJJbnRlcnBvbGF0aW9uXCI6NjgsXCJTVFJJTkdfRU5EXCI6NjksXCJ7e1wiOjcwLFwifX1cIjo3MSxcIkxpdGVyYWxcIjo3MixcIkpTXCI6NzMsXCJSRUdFWFwiOjc0LFwiQk9PTFwiOjc1LFwiVFJVRVwiOjc2LFwiRkFMU0VcIjo3NyxcIk5VTExcIjo3OCxcIlVOREVGSU5FRFwiOjc5LFwiUkVUVVJOXCI6ODAsXCJBcmd1bWVudHNcIjo4MSxcIlRhZ1NlbGVjdG9yXCI6ODIsXCJTRUxFQ1RPUl9TVEFSVFwiOjgzLFwiVGFnU2VsZWN0b3JUeXBlXCI6ODQsXCJTRUxFQ1RPUl9OU1wiOjg1LFwiU0VMRUNUT1JfSURcIjo4NixcIlNFTEVDVE9SX0NMQVNTXCI6ODcsXCIuXCI6ODgsXCJ7XCI6ODksXCJ9XCI6OTAsXCIjXCI6OTEsXCJTRUxFQ1RPUl9DT01CSU5BVE9SXCI6OTIsXCJTRUxFQ1RPUl9QU0VVRE9fQ0xBU1NcIjo5MyxcIlNFTEVDVE9SX0dST1VQXCI6OTQsXCJVTklWRVJTQUxfU0VMRUNUT1JcIjo5NSxcIltcIjo5NixcIl1cIjo5NyxcIlNFTEVDVE9SX0FUVFJfT1BcIjo5OCxcIlRhZ1NlbGVjdG9yQXR0clZhbHVlXCI6OTksXCJTRUxFQ1RPUl9UQUdcIjoxMDAsXCJTZWxlY3RvclwiOjEwMSxcIlNFTEVDVE9SX0VORFwiOjEwMixcIlRBR19TVEFSVFwiOjEwMyxcIlRhZ09wdGlvbnNcIjoxMDQsXCJUYWdBdHRyaWJ1dGVzXCI6MTA1LFwiVEFHX0VORFwiOjEwNixcIlRhZ0JvZHlcIjoxMDcsXCJUYWdUeXBlTmFtZVwiOjEwOCxcIlNlbGZcIjoxMDksXCJUQUdfVFlQRVwiOjExMCxcIklOREVYX1NUQVJUXCI6MTExLFwiSU5ERVhfRU5EXCI6MTEyLFwiQFwiOjExMyxcIlRhZ0F0dHJcIjoxMTQsXCJPcHRDb21tYVwiOjExNSxcIlRBR19BVFRSXCI6MTE2LFwiPVwiOjExNyxcIlRhZ0F0dHJWYWx1ZVwiOjExOCxcIkFyZ0xpc3RcIjoxMTksXCJUYWdUeXBlRGVmXCI6MTIwLFwiVGFnRGVjbGFyYXRpb25CbG9ja1wiOjEyMSxcIkVYVEVORFwiOjEyMixcIkxPQ0FMXCI6MTIzLFwiVEFHXCI6MTI0LFwiVGFnVHlwZVwiOjEyNSxcIkNPTVBBUkVcIjoxMjYsXCJUYWdEZWNsS2V5d29yZHNcIjoxMjcsXCJUQUdfSURcIjoxMjgsXCJUYWdJZFwiOjEyOSxcIklEUkVGXCI6MTMwLFwiQXNzaWduYWJsZVwiOjEzMSxcIk91dGRlbnRcIjoxMzIsXCJBc3NpZ25PYmpcIjoxMzMsXCJPYmpBc3NpZ25hYmxlXCI6MTM0LFwiOlwiOjEzNSxcIihcIjoxMzYsXCIpXCI6MTM3LFwiSEVSRUNPTU1FTlRcIjoxMzgsXCJDT01NRU5UXCI6MTM5LFwiTWV0aG9kXCI6MTQwLFwiRG9cIjoxNDEsXCJCZWdpblwiOjE0MixcIkJFR0lOXCI6MTQzLFwiRE9cIjoxNDQsXCJCTE9DS19QQVJBTV9TVEFSVFwiOjE0NSxcIlBhcmFtTGlzdFwiOjE0NixcIkJMT0NLX1BBUkFNX0VORFwiOjE0NyxcIlByb3BUeXBlXCI6MTQ4LFwiUHJvcGVydHlJZGVudGlmaWVyXCI6MTQ5LFwiT2JqZWN0XCI6MTUwLFwiUFJPUFwiOjE1MSxcIkFUVFJcIjoxNTIsXCJUdXBsZUFzc2lnblwiOjE1MyxcIlZBUlwiOjE1NCxcIk1ldGhvZERlY2xhcmF0aW9uXCI6MTU1LFwiR0xPQkFMXCI6MTU2LFwiRVhQT1JUXCI6MTU3LFwiREVGXCI6MTU4LFwiTWV0aG9kU2NvcGVcIjoxNTksXCJNZXRob2RTY29wZVR5cGVcIjoxNjAsXCJNZXRob2RJZGVudGlmaWVyXCI6MTYxLFwiTWV0aG9kQm9keVwiOjE2MixcIk1ldGhvZFJlY2VpdmVyXCI6MTYzLFwiREVGX0JPRFlcIjoxNjQsXCJERUZfRU1QVFlcIjoxNjUsXCJUaGlzXCI6MTY2LFwiUGFyYW1cIjoxNjcsXCJBcnJheVwiOjE2OCxcIlBhcmFtVmFyXCI6MTY5LFwiU1BMQVRcIjoxNzAsXCJMT0dJQ1wiOjE3MSxcIkJMT0NLX0FSR1wiOjE3MixcIlZhclJlZmVyZW5jZVwiOjE3MyxcIlZhckFzc2lnbmFibGVcIjoxNzQsXCJMRVRcIjoxNzUsXCJTaW1wbGVBc3NpZ25hYmxlXCI6MTc2LFwiTkVXXCI6MTc3LFwiU3VwZXJcIjoxNzgsXCJTb2FrYWJsZU9wXCI6MTc5LFwiPzpcIjoxODAsXCIuOlwiOjE4MSxcIkluZGV4VmFsdWVcIjoxODIsXCI/LlwiOjE4MyxcIlNVUEVSXCI6MTg0LFwiQVdBSVRcIjoxODUsXCJQYXJlbnRoZXRpY2FsXCI6MTg2LFwiUmFuZ2VcIjoxODcsXCJBUkdVTUVOVFNcIjoxODgsXCJJbnZvY2F0aW9uXCI6MTg5LFwiU2xpY2VcIjoxOTAsXCJBc3NpZ25MaXN0XCI6MTkxLFwiQ2xhc3NTdGFydFwiOjE5MixcIkNMQVNTXCI6MTkzLFwiTU9EVUxFXCI6MTk0LFwiT3B0RnVuY0V4aXN0XCI6MTk1LFwiRlVOQ19FWElTVFwiOjE5NixcIlRISVNcIjoxOTcsXCJTRUxGXCI6MTk4LFwiUmFuZ2VEb3RzXCI6MTk5LFwiLi5cIjoyMDAsXCIuLi5cIjoyMDEsXCJBcmdcIjoyMDIsXCJTaW1wbGVBcmdzXCI6MjAzLFwiVFJZXCI6MjA0LFwiQ2F0Y2hcIjoyMDUsXCJGaW5hbGx5XCI6MjA2LFwiRklOQUxMWVwiOjIwNyxcIkNBVENIXCI6MjA4LFwiQ0FUQ0hfVkFSXCI6MjA5LFwiVEhST1dcIjoyMTAsXCJXaGlsZVNvdXJjZVwiOjIxMSxcIldISUxFXCI6MjEyLFwiV0hFTlwiOjIxMyxcIlVOVElMXCI6MjE0LFwiTG9vcFwiOjIxNSxcIkxPT1BcIjoyMTYsXCJGb3JCb2R5XCI6MjE3LFwiRm9yS2V5d29yZFwiOjIxOCxcIkZPUlwiOjIxOSxcIlBPU1RfRk9SXCI6MjIwLFwiRm9yQmxvY2tcIjoyMjEsXCJGb3JTdGFydFwiOjIyMixcIkZvclNvdXJjZVwiOjIyMyxcIkZvclZhcmlhYmxlc1wiOjIyNCxcIk9XTlwiOjIyNSxcIkZvclZhbHVlXCI6MjI2LFwiRk9SSU5cIjoyMjcsXCJGT1JPRlwiOjIyOCxcIkJZXCI6MjI5LFwiU1dJVENIXCI6MjMwLFwiV2hlbnNcIjoyMzEsXCJFTFNFXCI6MjMyLFwiV2hlblwiOjIzMyxcIkxFQURJTkdfV0hFTlwiOjIzNCxcIklmQmxvY2tcIjoyMzUsXCJJRlwiOjIzNixcIkVMSUZcIjoyMzcsXCJQT1NUX0lGXCI6MjM4LFwiP1wiOjIzOSxcIlVOQVJZXCI6MjQwLFwiU1FSVFwiOjI0MSxcIi1cIjoyNDIsXCIrXCI6MjQzLFwiLS1cIjoyNDQsXCIrK1wiOjI0NSxcIk1BVEhcIjoyNDYsXCJTSElGVFwiOjI0NyxcIlJFTEFUSU9OXCI6MjQ4LFwiQ09NUE9VTkRfQVNTSUdOXCI6MjQ5LFwiJGFjY2VwdFwiOjAsXCIkZW5kXCI6MX0sXG50ZXJtaW5hbHNfOiB7MjpcImVycm9yXCIsNjpcIlRFUk1JTkFUT1JcIiw3OlwiQk9EWVNUQVJUXCIsMTA6XCJJTkRFTlRcIiwxMTpcIk9VVERFTlRcIiwxNDpcIixcIiwxOTpcIlNUQVRFTUVOVFwiLDIwOlwiQlJFQUtcIiwyMTpcIkNBTExfU1RBUlRcIiwyMjpcIkNBTExfRU5EXCIsMjM6XCJDT05USU5VRVwiLDI0OlwiREVCVUdHRVJcIiwyNjpcIklNUE9SVFwiLDI4OlwiRlJPTVwiLDMwOlwiQVNcIiwzMjpcIlNUUklOR1wiLDUxOlwiSURFTlRJRklFUlwiLDUzOlwiSVZBUlwiLDU0OlwiQ1ZBUlwiLDU2OlwiR1ZBUlwiLDU4OlwiQ09OU1RcIiw2MDpcIkFSR1ZBUlwiLDYyOlwiU1lNQk9MXCIsNjQ6XCJOVU1CRVJcIiw2NjpcIlNUUklOR19TVEFSVFwiLDY3OlwiTkVPU1RSSU5HXCIsNjk6XCJTVFJJTkdfRU5EXCIsNzA6XCJ7e1wiLDcxOlwifX1cIiw3MzpcIkpTXCIsNzQ6XCJSRUdFWFwiLDc1OlwiQk9PTFwiLDc2OlwiVFJVRVwiLDc3OlwiRkFMU0VcIiw3ODpcIk5VTExcIiw3OTpcIlVOREVGSU5FRFwiLDgwOlwiUkVUVVJOXCIsODM6XCJTRUxFQ1RPUl9TVEFSVFwiLDg1OlwiU0VMRUNUT1JfTlNcIiw4NjpcIlNFTEVDVE9SX0lEXCIsODc6XCJTRUxFQ1RPUl9DTEFTU1wiLDg4OlwiLlwiLDg5Olwie1wiLDkwOlwifVwiLDkxOlwiI1wiLDkyOlwiU0VMRUNUT1JfQ09NQklOQVRPUlwiLDkzOlwiU0VMRUNUT1JfUFNFVURPX0NMQVNTXCIsOTQ6XCJTRUxFQ1RPUl9HUk9VUFwiLDk1OlwiVU5JVkVSU0FMX1NFTEVDVE9SXCIsOTY6XCJbXCIsOTc6XCJdXCIsOTg6XCJTRUxFQ1RPUl9BVFRSX09QXCIsMTAwOlwiU0VMRUNUT1JfVEFHXCIsMTAyOlwiU0VMRUNUT1JfRU5EXCIsMTAzOlwiVEFHX1NUQVJUXCIsMTA2OlwiVEFHX0VORFwiLDExMDpcIlRBR19UWVBFXCIsMTExOlwiSU5ERVhfU1RBUlRcIiwxMTI6XCJJTkRFWF9FTkRcIiwxMTM6XCJAXCIsMTE2OlwiVEFHX0FUVFJcIiwxMTc6XCI9XCIsMTIyOlwiRVhURU5EXCIsMTIzOlwiTE9DQUxcIiwxMjQ6XCJUQUdcIiwxMjY6XCJDT01QQVJFXCIsMTI4OlwiVEFHX0lEXCIsMTMwOlwiSURSRUZcIiwxMzU6XCI6XCIsMTM2OlwiKFwiLDEzNzpcIilcIiwxMzg6XCJIRVJFQ09NTUVOVFwiLDEzOTpcIkNPTU1FTlRcIiwxNDM6XCJCRUdJTlwiLDE0NDpcIkRPXCIsMTQ1OlwiQkxPQ0tfUEFSQU1fU1RBUlRcIiwxNDc6XCJCTE9DS19QQVJBTV9FTkRcIiwxNTE6XCJQUk9QXCIsMTUyOlwiQVRUUlwiLDE1NDpcIlZBUlwiLDE1NjpcIkdMT0JBTFwiLDE1NzpcIkVYUE9SVFwiLDE1ODpcIkRFRlwiLDE2NDpcIkRFRl9CT0RZXCIsMTY1OlwiREVGX0VNUFRZXCIsMTcwOlwiU1BMQVRcIiwxNzE6XCJMT0dJQ1wiLDE3MjpcIkJMT0NLX0FSR1wiLDE3NTpcIkxFVFwiLDE3NzpcIk5FV1wiLDE4MDpcIj86XCIsMTgxOlwiLjpcIiwxODM6XCI/LlwiLDE4NDpcIlNVUEVSXCIsMTg1OlwiQVdBSVRcIiwxODg6XCJBUkdVTUVOVFNcIiwxOTM6XCJDTEFTU1wiLDE5NDpcIk1PRFVMRVwiLDE5NjpcIkZVTkNfRVhJU1RcIiwxOTc6XCJUSElTXCIsMTk4OlwiU0VMRlwiLDIwMDpcIi4uXCIsMjAxOlwiLi4uXCIsMjA0OlwiVFJZXCIsMjA3OlwiRklOQUxMWVwiLDIwODpcIkNBVENIXCIsMjA5OlwiQ0FUQ0hfVkFSXCIsMjEwOlwiVEhST1dcIiwyMTI6XCJXSElMRVwiLDIxMzpcIldIRU5cIiwyMTQ6XCJVTlRJTFwiLDIxNjpcIkxPT1BcIiwyMTk6XCJGT1JcIiwyMjA6XCJQT1NUX0ZPUlwiLDIyNTpcIk9XTlwiLDIyNzpcIkZPUklOXCIsMjI4OlwiRk9ST0ZcIiwyMjk6XCJCWVwiLDIzMDpcIlNXSVRDSFwiLDIzMjpcIkVMU0VcIiwyMzQ6XCJMRUFESU5HX1dIRU5cIiwyMzY6XCJJRlwiLDIzNzpcIkVMSUZcIiwyMzg6XCJQT1NUX0lGXCIsMjM5OlwiP1wiLDI0MDpcIlVOQVJZXCIsMjQxOlwiU1FSVFwiLDI0MjpcIi1cIiwyNDM6XCIrXCIsMjQ0OlwiLS1cIiwyNDU6XCIrK1wiLDI0NjpcIk1BVEhcIiwyNDc6XCJTSElGVFwiLDI0ODpcIlJFTEFUSU9OXCIsMjQ5OlwiQ09NUE9VTkRfQVNTSUdOXCJ9LFxucHJvZHVjdGlvbnNfOiBbMCxbMywwXSxbMywxXSxbMywyXSxbNCwxXSxbNCwxXSxbNCwzXSxbNCwyXSxbOSwxXSxbNSwyXSxbNSwzXSxbNSw0XSxbOCwxXSxbOCwxXSxbOCwzXSxbOCwzXSxbOCwxXSxbOCwxXSxbMTYsMV0sWzE2LDFdLFsxNiwxXSxbMTYsMV0sWzE2LDRdLFsxNiwxXSxbMTYsNF0sWzE2LDFdLFsxNiwxXSxbMjUsNF0sWzI1LDRdLFsyNSwyXSxbMjksMV0sWzI3LDFdLFsyNywzXSxbMzEsMV0sWzEzLDFdLFsxMywxXSxbMTMsMV0sWzEzLDFdLFsxMywxXSxbMTMsMV0sWzEzLDFdLFsxMywxXSxbMTMsMV0sWzEzLDFdLFsxMywxXSxbMTMsMV0sWzEzLDFdLFsxMywxXSxbMTMsMV0sWzEzLDFdLFs1MCwxXSxbNTIsMV0sWzUyLDFdLFs1NSwxXSxbNTcsMV0sWzU5LDFdLFs2MSwxXSxbNjMsMV0sWzYzLDFdLFs2MywxXSxbNjMsMV0sWzY1LDFdLFs2NSwyXSxbNjUsMl0sWzY1LDJdLFs2OCwyXSxbNjgsM10sWzcyLDFdLFs3MiwxXSxbNzIsMV0sWzcyLDFdLFs3MiwxXSxbNzIsMV0sWzcyLDFdLFs3MiwxXSxbMTcsMl0sWzE3LDJdLFsxNywxXSxbODIsMV0sWzgyLDJdLFs4MiwyXSxbODIsMl0sWzgyLDJdLFs4Miw1XSxbODIsNV0sWzgyLDJdLFs4MiwyXSxbODIsMl0sWzgyLDJdLFs4Miw0XSxbODIsNl0sWzg0LDFdLFsxMDEsMl0sWzk5LDFdLFs5OSwxXSxbOTksM10sWzQ4LDRdLFs0OCw1XSxbNDgsNV0sWzEwOCwxXSxbMTA4LDFdLFsxMDgsMV0sWzEwOCwwXSxbMTA0LDFdLFsxMDQsM10sWzEwNCw0XSxbMTA0LDNdLFsxMDQsNV0sWzEwNCw1XSxbMTA0LDNdLFsxMDQsMl0sWzEwNCw1XSxbMTA1LDBdLFsxMDUsMV0sWzEwNSwzXSxbMTA1LDRdLFsxMTQsMV0sWzExNCwzXSxbMTE4LDFdLFsxMDcsM10sWzEwNywzXSxbMTIwLDFdLFsxMjAsM10sWzQ3LDFdLFs0NywyXSxbNDcsMl0sWzEyMSwyXSxbMTIxLDNdLFsxMjEsNF0sWzEyMSw1XSxbMTI3LDBdLFsxMjcsMV0sWzEyNSwxXSxbMTI1LDFdLFsxMjksMV0sWzEyOSwyXSxbMzgsM10sWzM4LDVdLFsxMzMsMV0sWzEzMywzXSxbMTMzLDVdLFsxMzMsMV0sWzEzNCwxXSxbMTM0LDFdLFsxMzQsMV0sWzEzNCwxXSxbMTM0LDFdLFsxMzQsM10sWzE1LDFdLFsxNSwxXSxbMzYsMV0sWzM2LDFdLFszNiwxXSxbMTQyLDJdLFsxNDEsMl0sWzE0MSw1XSxbMTQxLDZdLFs0OSwzXSxbNDksNV0sWzQ5LDJdLFsxNDgsMV0sWzE0OCwxXSxbMTQ5LDFdLFsxNDksM10sWzE1Myw0XSxbMTQwLDFdLFsxNDAsMl0sWzE0MCwyXSxbMTU1LDhdLFsxNTUsNV0sWzE1NSw2XSxbMTU1LDNdLFsxNjAsMV0sWzE2MCwxXSxbMTYxLDFdLFsxNjEsMV0sWzE2MSwzXSxbMTYyLDJdLFsxNjIsMl0sWzE2MiwxXSxbMTU5LDFdLFsxNTksMV0sWzE1OSwxXSxbMTU5LDFdLFsxMTUsMF0sWzExNSwxXSxbMTQ2LDBdLFsxNDYsMV0sWzE0NiwzXSxbMTY3LDFdLFsxNjcsMV0sWzE2NywxXSxbMTY3LDJdLFsxNjcsMl0sWzE2NywyXSxbMTY3LDNdLFsxNjksMV0sWzEyLDJdLFsxNzMsM10sWzE3MywyXSxbMTczLDJdLFsxNzMsM10sWzE3MywyXSxbMzMsMV0sWzMzLDFdLFsxNzQsMV0sWzE3NCwxXSxbMTc0LDFdLFsxNzYsMV0sWzE3NiwxXSxbMTc2LDFdLFsxNzYsMV0sWzE3NiwxXSxbMTc2LDFdLFsxNzYsMV0sWzE3NiwzXSxbMTc2LDNdLFsxNzYsM10sWzE3NiwzXSxbMTc2LDNdLFsxNzYsM10sWzE3NiwzXSxbMTc2LDNdLFsxNzYsNF0sWzE3OSwxXSxbMTc5LDFdLFsxNzgsMV0sWzEzMSwxXSxbMTMxLDFdLFsxMzEsMV0sWzM0LDJdLFszNSwxXSxbMzUsMV0sWzM1LDFdLFszNSwxXSxbMzUsMV0sWzM1LDFdLFszNSwxXSxbMzUsMV0sWzM1LDFdLFszNSwxXSxbMTgyLDFdLFsxODIsMV0sWzE1MCw0XSxbMTkxLDBdLFsxOTEsMV0sWzE5MSwzXSxbMTkxLDRdLFsxOTEsNl0sWzQ1LDFdLFs0NSwyXSxbNDUsMl0sWzQ1LDJdLFs0NSwyXSxbNDUsM10sWzE5MiwyXSxbMTkyLDNdLFsxOTIsNF0sWzE5Miw1XSxbNDYsMl0sWzQ2LDNdLFsxODksM10sWzE4OSwyXSxbMTk1LDBdLFsxOTUsMV0sWzgxLDJdLFs4MSw0XSxbMTY2LDFdLFsxMDksMV0sWzE2OCwyXSxbMTY4LDRdLFsxOTksMV0sWzE5OSwxXSxbMTg3LDVdLFsxOTAsM10sWzE5MCwyXSxbMTkwLDJdLFsxMTksMV0sWzExOSwzXSxbMTE5LDRdLFsxMTksNF0sWzExOSw2XSxbMTMyLDJdLFsxMzIsMV0sWzIwMiwxXSxbMjAyLDFdLFsyMDIsMV0sWzIwMiwxXSxbMjAzLDFdLFsyMDMsM10sWzQxLDJdLFs0MSwzXSxbNDEsM10sWzQxLDRdLFsyMDYsMl0sWzIwNSwzXSxbMTgsMl0sWzE4NiwzXSxbMTg2LDVdLFsyMTEsMl0sWzIxMSw0XSxbMjExLDJdLFsyMTEsNF0sWzQyLDJdLFs0MiwyXSxbNDIsMl0sWzQyLDFdLFsyMTUsMl0sWzIxNSwyXSxbNDMsMl0sWzQzLDJdLFs0MywyXSxbMjE4LDFdLFsyMTgsMV0sWzIyMSwyXSxbMjE3LDJdLFsyMTcsMl0sWzIyMiwyXSxbMjIyLDNdLFsyMjYsMV0sWzIyNiwxXSxbMjI2LDFdLFsyMjQsMV0sWzIyNCwzXSxbMjIzLDJdLFsyMjMsMl0sWzIyMyw0XSxbMjIzLDRdLFsyMjMsNF0sWzIyMyw2XSxbMjIzLDZdLFs0NCw1XSxbNDQsN10sWzQ0LDRdLFs0NCw2XSxbMjMxLDFdLFsyMzEsMl0sWzIzMywzXSxbMjMzLDRdLFsyMzUsM10sWzIzNSw1XSxbMjM1LDRdLFsyMzUsM10sWzM5LDFdLFszOSwzXSxbMzksM10sWzQwLDVdLFszNywyXSxbMzcsMl0sWzM3LDJdLFszNywyXSxbMzcsMl0sWzM3LDJdLFszNywyXSxbMzcsMl0sWzM3LDNdLFszNywzXSxbMzcsM10sWzM3LDNdLFszNywzXSxbMzcsM10sWzM3LDNdLFszNywzXSxbMzcsNV1dLFxucGVyZm9ybUFjdGlvbjogZnVuY3Rpb24gcGVyZm9ybUFjdGlvbihzZWxmLCB5eXRleHQsIHl5LCB5eXN0YXRlIC8qIGFjdGlvblsxXSAqLywgJCQgLyogdnN0YWNrICovKSB7XG4vKiBzZWxmID09IHl5dmFsICovXG5cbnZhciAkMCA9ICQkLmxlbmd0aCAtIDE7XG5zd2l0Y2ggKHl5c3RhdGUpIHtcbmNhc2UgMTpcbnJldHVybiBzZWxmLiQgPSBuZXcgeXkuUm9vdChbXSk7XG5icmVhaztcbmNhc2UgMjpcbnJldHVybiBzZWxmLiQgPSBuZXcgeXkuUm9vdCgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDM6XG5yZXR1cm4gc2VsZi4kID0gJCRbJDAtMV07XG5icmVhaztcbmNhc2UgNDpcbnNlbGYuJCA9IG5ldyB5eS5CbG9jayhbXSk7XG5icmVhaztcbmNhc2UgNTpcbnNlbGYuJCA9IG5ldyB5eS5CbG9jayhbJCRbJDBdXSk7XG5icmVhaztcbmNhc2UgNjpcbnNlbGYuJCA9ICQkWyQwLTJdLmJyZWFrKCQkWyQwLTFdKS5hZGQoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSA3Olxuc2VsZi4kID0gJCRbJDAtMV0uYnJlYWsoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSA4Olxuc2VsZi4kID0gbmV3IHl5LlRlcm1pbmF0b3IoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSA5Olxuc2VsZi4kID0gbmV3IHl5LkJsb2NrKFtdKS5pbmRlbnRlZCgkJFskMC0xXSwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDEwOiBjYXNlIDExOTpcbnNlbGYuJCA9ICQkWyQwLTFdLmluZGVudGVkKCQkWyQwLTJdLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMTE6XG5zZWxmLiQgPSAkJFskMC0xXS5wcmVicmVhaygkJFskMC0yXSkuaW5kZW50ZWQoJCRbJDAtM10sJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAxMjogY2FzZSAxMzogY2FzZSAxNjogY2FzZSAxNzogY2FzZSAxODogY2FzZSAxOTogY2FzZSAyNjogY2FzZSAzMDogY2FzZSAzMzogY2FzZSAzNDogY2FzZSAzNTogY2FzZSAzNjogY2FzZSAzNzogY2FzZSAzODogY2FzZSAzOTogY2FzZSA0MDogY2FzZSA0MTogY2FzZSA0MjogY2FzZSA0MzogY2FzZSA0NDogY2FzZSA0NTogY2FzZSA0NjogY2FzZSA0NzogY2FzZSA0ODogY2FzZSA0OTogY2FzZSA1OTogY2FzZSA2MDogY2FzZSA2NzogY2FzZSA5MzogY2FzZSA5NDogY2FzZSA5OTogY2FzZSAxMTg6IGNhc2UgMTIzOiBjYXNlIDEzMDogY2FzZSAxNDE6IGNhc2UgMTQyOiBjYXNlIDE0MzogY2FzZSAxNDQ6IGNhc2UgMTQ1OiBjYXNlIDE0NjogY2FzZSAxNTA6IGNhc2UgMTUxOiBjYXNlIDE1MjogY2FzZSAxNjA6IGNhc2UgMTYxOiBjYXNlIDE2MjogY2FzZSAxNjU6IGNhc2UgMTc0OiBjYXNlIDE3NTogY2FzZSAxNzc6IGNhc2UgMTgwOiBjYXNlIDE4MTogY2FzZSAxODI6IGNhc2UgMTgzOiBjYXNlIDE4NDogY2FzZSAxODU6IGNhc2UgMTk2OiBjYXNlIDIwMzogY2FzZSAyMDQ6IGNhc2UgMjA1OiBjYXNlIDIwNjogY2FzZSAyMDc6IGNhc2UgMjA4OiBjYXNlIDIxMDogY2FzZSAyMTE6IGNhc2UgMjEyOiBjYXNlIDIxMzogY2FzZSAyMjc6IGNhc2UgMjI4OiBjYXNlIDIyOTogY2FzZSAyMzE6IGNhc2UgMjMyOiBjYXNlIDIzMzogY2FzZSAyMzQ6IGNhc2UgMjM1OiBjYXNlIDIzNzogY2FzZSAyMzg6IGNhc2UgMjM5OiBjYXNlIDI0MDogY2FzZSAyNDk6IGNhc2UgMjgzOiBjYXNlIDI4NDogY2FzZSAyODU6IGNhc2UgMjg2OiBjYXNlIDI4NzogY2FzZSAyODg6IGNhc2UgMzA2OiBjYXNlIDMxMjogY2FzZSAzMTM6IGNhc2UgMzE5OiBjYXNlIDMzNTogY2FzZSAzNDM6XG5zZWxmLiQgPSAkJFskMF07XG5icmVhaztcbmNhc2UgMTQ6IGNhc2UgMTU6XG5zZWxmLiQgPSAkJFskMC0yXS5hZGRFeHByZXNzaW9uKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjA6IGNhc2UgNjg6XG5zZWxmLiQgPSBuZXcgeXkuTGl0ZXJhbCgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDIxOlxuc2VsZi4kID0gbmV3IHl5LkJyZWFrU3RhdGVtZW50KCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjI6XG5zZWxmLiQgPSBuZXcgeXkuQnJlYWtTdGF0ZW1lbnQoJCRbJDAtM10sJCRbJDAtMV0pO1xuYnJlYWs7XG5jYXNlIDIzOlxuc2VsZi4kID0gbmV3IHl5LkNvbnRpbnVlU3RhdGVtZW50KCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjQ6XG5zZWxmLiQgPSBuZXcgeXkuQ29udGludWVTdGF0ZW1lbnQoJCRbJDAtM10sJCRbJDAtMV0pO1xuYnJlYWs7XG5jYXNlIDI1Olxuc2VsZi4kID0gbmV3IHl5LkRlYnVnZ2VyU3RhdGVtZW50KCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjc6XG5zZWxmLiQgPSBuZXcgeXkuSW1wb3J0U3RhdGVtZW50KCQkWyQwLTJdLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjg6XG5zZWxmLiQgPSBuZXcgeXkuSW1wb3J0U3RhdGVtZW50KG51bGwsJCRbJDAtMl0sJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyOTpcbnNlbGYuJCA9IG5ldyB5eS5JbXBvcnRTdGF0ZW1lbnQobnVsbCwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDMxOiBjYXNlIDExMzogY2FzZSAxODc6IGNhc2UgMzIyOlxuc2VsZi4kID0gWyQkWyQwXV07XG5icmVhaztcbmNhc2UgMzI6IGNhc2UgMTE0OiBjYXNlIDE4ODpcbnNlbGYuJCA9ICQkWyQwLTJdLmNvbmNhdCgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDUwOlxuc2VsZi4kID0gbmV3IHl5LklkZW50aWZpZXIoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSA1MTogY2FzZSA1MjpcbnNlbGYuJCA9IG5ldyB5eS5JdmFyKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgNTM6XG5zZWxmLiQgPSBuZXcgeXkuR3ZhcigkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDU0Olxuc2VsZi4kID0gbmV3IHl5LkNvbnN0KCQkWyQwXSk7XG5icmVhaztcbmNhc2UgNTU6XG5zZWxmLiQgPSBuZXcgeXkuQXJndmFyKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgNTY6XG5zZWxmLiQgPSBuZXcgeXkuU3ltYm9sKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgNTc6XG5zZWxmLiQgPSBuZXcgeXkuTnVtKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgNTg6XG5zZWxmLiQgPSBuZXcgeXkuU3RyKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgNjE6XG5zZWxmLiQgPSBuZXcgeXkuSW50ZXJwb2xhdGVkU3RyaW5nKFtdLHtvcGVuOiAkJFskMF19KTtcbmJyZWFrO1xuY2FzZSA2MjpcbnNlbGYuJCA9ICQkWyQwLTFdLmFkZCgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDYzOlxuc2VsZi4kID0gJCRbJDBdID8gKCQkWyQwLTFdLmFkZCgkJFskMF0pKSA6ICgkJFskMC0xXSk7XG5icmVhaztcbmNhc2UgNjQ6XG5zZWxmLiQgPSAkJFskMC0xXS5vcHRpb24oJ2Nsb3NlJywkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDY1Olxuc2VsZi4kID0gbnVsbDtcbmJyZWFrO1xuY2FzZSA2NjogY2FzZSA5MjogY2FzZSA5NTogY2FzZSAxMjA6IGNhc2UgMTQ3OiBjYXNlIDE2MzogY2FzZSAxNzY6IGNhc2UgMjgyOlxuc2VsZi4kID0gJCRbJDAtMV07XG5icmVhaztcbmNhc2UgNjk6XG5zZWxmLiQgPSBuZXcgeXkuUmVnRXhwKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgNzA6XG5zZWxmLiQgPSBuZXcgeXkuQm9vbCgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDcxOlxuc2VsZi4kID0geXkuVFJVRTtcbmJyZWFrO1xuY2FzZSA3MjpcbnNlbGYuJCA9IHl5LkZBTFNFO1xuYnJlYWs7XG5jYXNlIDczOlxuc2VsZi4kID0geXkuTklMO1xuYnJlYWs7XG5jYXNlIDc0Olxuc2VsZi4kID0geXkuVU5ERUZJTkVEO1xuYnJlYWs7XG5jYXNlIDc1OiBjYXNlIDc2Olxuc2VsZi4kID0gbmV3IHl5LlJldHVybigkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDc3Olxuc2VsZi4kID0gbmV3IHl5LlJldHVybigpO1xuYnJlYWs7XG5jYXNlIDc4Olxuc2VsZi4kID0gbmV3IHl5LlNlbGVjdG9yKFtdLHt0eXBlOiAkJFskMF19KTtcbmJyZWFrO1xuY2FzZSA3OTpcbnNlbGYuJCA9ICQkWyQwLTFdLmFkZChuZXcgeXkuU2VsZWN0b3JUeXBlKCQkWyQwXSksJ3RhZycpO1xuYnJlYWs7XG5jYXNlIDgwOlxuc2VsZi4kID0gJCRbJDAtMV0uYWRkKG5ldyB5eS5TZWxlY3Rvck5hbWVzcGFjZSgkJFskMF0pLCducycpO1xuYnJlYWs7XG5jYXNlIDgxOlxuc2VsZi4kID0gJCRbJDAtMV0uYWRkKG5ldyB5eS5TZWxlY3RvcklkKCQkWyQwXSksJ2lkJyk7XG5icmVhaztcbmNhc2UgODI6XG5zZWxmLiQgPSAkJFskMC0xXS5hZGQobmV3IHl5LlNlbGVjdG9yQ2xhc3MoJCRbJDBdKSwnY2xhc3MnKTtcbmJyZWFrO1xuY2FzZSA4MzpcbnNlbGYuJCA9ICQkWyQwLTRdLmFkZChuZXcgeXkuU2VsZWN0b3JDbGFzcygkJFskMC0xXSksJ2NsYXNzJyk7XG5icmVhaztcbmNhc2UgODQ6XG5zZWxmLiQgPSAkJFskMC00XS5hZGQobmV3IHl5LlNlbGVjdG9ySWQoJCRbJDAtMV0pLCdpZCcpO1xuYnJlYWs7XG5jYXNlIDg1Olxuc2VsZi4kID0gJCRbJDAtMV0uYWRkKG5ldyB5eS5TZWxlY3RvckNvbWJpbmF0b3IoJCRbJDBdKSwnc2VwJyk7XG5icmVhaztcbmNhc2UgODY6XG5zZWxmLiQgPSAkJFskMC0xXS5hZGQobmV3IHl5LlNlbGVjdG9yUHNldWRvQ2xhc3MoJCRbJDBdKSwncHNldWRvY2xhc3MnKTtcbmJyZWFrO1xuY2FzZSA4NzpcbnNlbGYuJCA9ICQkWyQwLTFdLmdyb3VwKCk7XG5icmVhaztcbmNhc2UgODg6XG5zZWxmLiQgPSAkJFskMC0xXS5hZGQobmV3IHl5LlNlbGVjdG9yVW5pdmVyc2FsKCQkWyQwXSksJ3VuaXZlcnNhbCcpO1xuYnJlYWs7XG5jYXNlIDg5Olxuc2VsZi4kID0gJCRbJDAtM10uYWRkKG5ldyB5eS5TZWxlY3RvckF0dHJpYnV0ZSgkJFskMC0xXSksJ2F0dHInKTtcbmJyZWFrO1xuY2FzZSA5MDpcbnNlbGYuJCA9ICQkWyQwLTVdLmFkZChuZXcgeXkuU2VsZWN0b3JBdHRyaWJ1dGUoJCRbJDAtM10sJCRbJDAtMl0sJCRbJDAtMV0pLCdhdHRyJyk7XG5icmVhaztcbmNhc2UgOTE6IGNhc2UgMTAwOiBjYXNlIDEwMTogY2FzZSAxMzI6IGNhc2UgMTMzOlxuc2VsZi4kID0gbmV3IHl5LlRhZ1R5cGVJZGVudGlmaWVyKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgOTY6XG5zZWxmLiQgPSAkJFskMC0yXS5zZXQoe2F0dHJpYnV0ZXM6ICQkWyQwLTFdLG9wZW46ICQkWyQwLTNdLGNsb3NlOiAkJFskMF19KTtcbmJyZWFrO1xuY2FzZSA5NzpcbnNlbGYuJCA9ICQkWyQwLTNdLnNldCh7YXR0cmlidXRlczogJCRbJDAtMl0sYm9keTogJCRbJDBdLG9wZW46ICQkWyQwLTRdLGNsb3NlOiAkJFskMC0xXX0pO1xuYnJlYWs7XG5jYXNlIDk4Olxuc2VsZi4kID0gbmV3IHl5LlRhZ1dyYXBwZXIoJCRbJDAtMl0sJCRbJDAtNF0sJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAxMDI6XG5zZWxmLiQgPSBuZXcgeXkuVGFnVHlwZUlkZW50aWZpZXIoJ2RpdicpO1xuYnJlYWs7XG5jYXNlIDEwMzpcbnNlbGYuJCA9IG5ldyB5eS5UYWcoe3R5cGU6ICQkWyQwXX0pO1xuYnJlYWs7XG5jYXNlIDEwNDpcbnNlbGYuJCA9ICQkWyQwLTJdLmFkZFN5bWJvbCgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDEwNTpcbnNlbGYuJCA9ICQkWyQwLTNdLmFkZEluZGV4KCQkWyQwLTFdKTtcbmJyZWFrO1xuY2FzZSAxMDY6XG5zZWxmLiQgPSAkJFskMC0yXS5hZGRDbGFzcygkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDEwNzpcbnNlbGYuJCA9ICQkWyQwLTRdLmFkZENsYXNzKCQkWyQwLTFdKTtcbmJyZWFrO1xuY2FzZSAxMDg6XG5zZWxmLiQgPSAkJFskMC00XS5zZXQoe2tleTogJCRbJDAtMV19KTtcbmJyZWFrO1xuY2FzZSAxMDk6XG5zZWxmLiQgPSAkJFskMC0yXS5zZXQoe2lkOiAkJFskMF19KTtcbmJyZWFrO1xuY2FzZSAxMTA6XG5zZWxmLiQgPSAkJFskMC0xXS5zZXQoe2l2YXI6ICQkWyQwXX0pO1xuYnJlYWs7XG5jYXNlIDExMTpcbnNlbGYuJCA9ICQkWyQwLTRdLnNldCh7aWQ6ICQkWyQwLTFdfSk7XG5icmVhaztcbmNhc2UgMTEyOiBjYXNlIDE3OTogY2FzZSAxODY6XG5zZWxmLiQgPSBbXTtcbmJyZWFrO1xuY2FzZSAxMTU6XG5zZWxmLiQgPSAkJFskMC0zXS5jb25jYXQoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAxMTY6XG5zZWxmLiQgPSBuZXcgeXkuVGFnQXR0cigkJFskMF0sJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAxMTc6XG5zZWxmLiQgPSBuZXcgeXkuVGFnQXR0cigkJFskMC0yXSwkJFskMF0sJCRbJDAtMV0pO1xuYnJlYWs7XG5jYXNlIDEyMTpcbnNlbGYuJCA9IG5ldyB5eS5UYWdEZXNjKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMTIyOlxuc2VsZi4kID0gJCRbJDAtMl0uY2xhc3NlcygkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDEyNDpcbnNlbGYuJCA9ICQkWyQwXS5zZXQoe2V4dGVuc2lvbjogdHJ1ZX0pO1xuYnJlYWs7XG5jYXNlIDEyNTpcbnNlbGYuJCA9ICQkWyQwXS5zZXQoe2xvY2FsOiB0cnVlfSk7XG5icmVhaztcbmNhc2UgMTI2Olxuc2VsZi4kID0gbmV3IHl5LlRhZ0RlY2xhcmF0aW9uKCQkWyQwXSkuc2V0KHtrZXl3b3JkOiAkJFskMC0xXX0pO1xuYnJlYWs7XG5jYXNlIDEyNzpcbnNlbGYuJCA9IG5ldyB5eS5UYWdEZWNsYXJhdGlvbigkJFskMC0xXSxudWxsLCQkWyQwXSkuc2V0KHtrZXl3b3JkOiAkJFskMC0yXX0pO1xuYnJlYWs7XG5jYXNlIDEyODpcbnNlbGYuJCA9IG5ldyB5eS5UYWdEZWNsYXJhdGlvbigkJFskMC0yXSwkJFskMF0pLnNldCh7a2V5d29yZDogJCRbJDAtM119KTtcbmJyZWFrO1xuY2FzZSAxMjk6XG5zZWxmLiQgPSBuZXcgeXkuVGFnRGVjbGFyYXRpb24oJCRbJDAtM10sJCRbJDAtMV0sJCRbJDBdKS5zZXQoe2tleXdvcmQ6ICQkWyQwLTRdfSk7XG5icmVhaztcbmNhc2UgMTMxOlxuc2VsZi4kID0gWyd5eS5leHRlbmQnXTtcbmJyZWFrO1xuY2FzZSAxMzQ6IGNhc2UgMTM1Olxuc2VsZi4kID0gbmV3IHl5LlRhZ0lkKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMTM2Olxuc2VsZi4kID0gbmV3IHl5LkFzc2lnbigkJFskMC0xXSwkJFskMC0yXSwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDEzNzpcbnNlbGYuJCA9IG5ldyB5eS5Bc3NpZ24oJCRbJDAtM10sJCRbJDAtNF0sJCRbJDAtMV0uaW5kZW50ZWQoJCRbJDAtMl0sJCRbJDBdKSk7XG5icmVhaztcbmNhc2UgMTM4Olxuc2VsZi4kID0gbmV3IHl5Lk9iakF0dHIoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAxMzk6XG5zZWxmLiQgPSBuZXcgeXkuT2JqQXR0cigkJFskMC0yXSwkJFskMF0sJ29iamVjdCcpO1xuYnJlYWs7XG5jYXNlIDE0MDpcbnNlbGYuJCA9IG5ldyB5eS5PYmpBdHRyKCQkWyQwLTRdLCQkWyQwLTFdLmluZGVudGVkKCQkWyQwLTJdLCQkWyQwXSksJ29iamVjdCcpO1xuYnJlYWs7XG5jYXNlIDE0ODpcbnNlbGYuJCA9IG5ldyB5eS5Db21tZW50KCQkWyQwXSx0cnVlKTtcbmJyZWFrO1xuY2FzZSAxNDk6XG5zZWxmLiQgPSBuZXcgeXkuQ29tbWVudCgkJFskMF0sZmFsc2UpO1xuYnJlYWs7XG5jYXNlIDE1MzpcbnNlbGYuJCA9IG5ldyB5eS5CZWdpbigkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDE1NDpcbnNlbGYuJCA9IG5ldyB5eS5MYW1iZGEoW10sJCRbJDBdLG51bGwsbnVsbCx7Ym91bmQ6IHRydWV9KTtcbmJyZWFrO1xuY2FzZSAxNTU6XG5zZWxmLiQgPSBuZXcgeXkuTGFtYmRhKCQkWyQwLTJdLCQkWyQwXSxudWxsLG51bGwse2JvdW5kOiB0cnVlfSk7XG5icmVhaztcbmNhc2UgMTU2Olxuc2VsZi4kID0gbmV3IHl5LkxhbWJkYSgkJFskMC0zXSwkJFskMC0xXSxudWxsLG51bGwse2JvdW5kOiB0cnVlfSk7XG5icmVhaztcbmNhc2UgMTU3Olxuc2VsZi4kID0gbmV3IHl5LlByb3BlcnR5RGVjbGFyYXRpb24oJCRbJDAtMV0sJCRbJDBdLCQkWyQwLTJdKTtcbmJyZWFrO1xuY2FzZSAxNTg6XG5zZWxmLiQgPSBuZXcgeXkuUHJvcGVydHlEZWNsYXJhdGlvbigkJFskMC0zXSwkJFskMC0xXSwkJFskMC00XSk7XG5icmVhaztcbmNhc2UgMTU5Olxuc2VsZi4kID0gbmV3IHl5LlByb3BlcnR5RGVjbGFyYXRpb24oJCRbJDBdLG51bGwsJCRbJDAtMV0pO1xuYnJlYWs7XG5jYXNlIDE2NDpcbnNlbGYuJCA9ICQkWyQwLTNdO1xuYnJlYWs7XG5jYXNlIDE2NjogY2FzZSAyNTI6XG5zZWxmLiQgPSAkJFskMF0uc2V0KHtnbG9iYWw6ICQkWyQwLTFdfSk7XG5icmVhaztcbmNhc2UgMTY3OiBjYXNlIDIwMjogY2FzZSAyNTM6XG5zZWxmLiQgPSAkJFskMF0uc2V0KHtleHBvcnQ6ICQkWyQwLTFdfSk7XG5icmVhaztcbmNhc2UgMTY4Olxuc2VsZi4kID0gbmV3IHl5Lk1ldGhvZERlY2xhcmF0aW9uKCQkWyQwLTJdLCQkWyQwXSwkJFskMC00XSwkJFskMC02XSwkJFskMC01XSkuc2V0KHtkZWY6ICQkWyQwLTddfSk7XG5icmVhaztcbmNhc2UgMTY5Olxuc2VsZi4kID0gbmV3IHl5Lk1ldGhvZERlY2xhcmF0aW9uKFtdLCQkWyQwXSwkJFskMC0xXSwkJFskMC0zXSwkJFskMC0yXSkuc2V0KHtkZWY6ICQkWyQwLTRdfSk7XG5icmVhaztcbmNhc2UgMTcwOlxuc2VsZi4kID0gbmV3IHl5Lk1ldGhvZERlY2xhcmF0aW9uKCQkWyQwLTJdLCQkWyQwXSwkJFskMC00XSxudWxsKS5zZXQoe2RlZjogJCRbJDAtNV19KTtcbmJyZWFrO1xuY2FzZSAxNzE6XG5zZWxmLiQgPSBuZXcgeXkuTWV0aG9kRGVjbGFyYXRpb24oW10sJCRbJDBdLCQkWyQwLTFdLG51bGwpLnNldCh7ZGVmOiAkJFskMC0yXX0pO1xuYnJlYWs7XG5jYXNlIDE3MjpcbnNlbGYuJCA9IHtzdGF0aWM6IHRydWV9O1xuYnJlYWs7XG5jYXNlIDE3MzpcbnNlbGYuJCA9IHt9O1xuYnJlYWs7XG5jYXNlIDE3ODpcbnNlbGYuJCA9ICQkWyQwXS5ib2R5KCk7XG5icmVhaztcbmNhc2UgMTg5Olxuc2VsZi4kID0gbmV3IHl5Lk5hbWVkUGFyYW1zKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMTkwOlxuc2VsZi4kID0gbmV3IHl5LkFycmF5UGFyYW1zKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMTkxOlxuc2VsZi4kID0gbmV3IHl5LlJlcXVpcmVkUGFyYW0oJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAxOTI6XG5zZWxmLiQgPSBuZXcgeXkuU3BsYXRQYXJhbSgkJFskMF0sbnVsbCwkJFskMC0xXSk7XG5icmVhaztcbmNhc2UgMTkzOiBjYXNlIDE5NDpcbnNlbGYuJCA9IG5ldyB5eS5CbG9ja1BhcmFtKCQkWyQwXSxudWxsLCQkWyQwLTFdKTtcbmJyZWFrO1xuY2FzZSAxOTU6XG5zZWxmLiQgPSBuZXcgeXkuT3B0aW9uYWxQYXJhbSgkJFskMC0yXSwkJFskMF0sJCRbJDAtMV0pO1xuYnJlYWs7XG5jYXNlIDE5NzpcbnNlbGYuJCA9IHl5LlNQTEFUKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMTk4OiBjYXNlIDIwMTpcbnNlbGYuJCA9IHl5LlNQTEFUKG5ldyB5eS5WYXJSZWZlcmVuY2UoJCRbJDBdLCQkWyQwLTJdKSwkJFskMC0xXSk7XG5icmVhaztcbmNhc2UgMTk5OiBjYXNlIDIwMDpcbnNlbGYuJCA9IG5ldyB5eS5WYXJSZWZlcmVuY2UoJCRbJDBdLCQkWyQwLTFdKTtcbmJyZWFrO1xuY2FzZSAyMDk6XG5zZWxmLiQgPSBuZXcgeXkuSXZhckFjY2VzcygnLicsbnVsbCwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDIxNDpcbnNlbGYuJCA9IG5ldyB5eS5WYXJPckFjY2VzcygkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDIxNTpcbnNlbGYuJCA9IG5ldyB5eS5OZXcoJCRbJDAtMl0pO1xuYnJlYWs7XG5jYXNlIDIxNjpcbnNlbGYuJCA9IG5ldyB5eS5TdXBlckFjY2VzcygnLicsJCRbJDAtMl0sJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyMTc6XG5zZWxmLiQgPSBuZXcgeXkuUHJvcGVydHlBY2Nlc3MoJCRbJDAtMV0sJCRbJDAtMl0sJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyMTg6IGNhc2UgMjE5OiBjYXNlIDIyMDogY2FzZSAyMjI6XG5zZWxmLiQgPSBuZXcgeXkuQWNjZXNzKCQkWyQwLTFdLCQkWyQwLTJdLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjIxOlxuc2VsZi4kID0gbmV3IHl5LkFjY2VzcygnLicsJCRbJDAtMl0sbmV3IHl5LklkZW50aWZpZXIoJCRbJDBdLnZhbHVlKCkpKTtcbmJyZWFrO1xuY2FzZSAyMjM6XG5zZWxmLiQgPSBuZXcgeXkuSW5kZXhBY2Nlc3MoJy4nLCQkWyQwLTNdLCQkWyQwLTFdKTtcbmJyZWFrO1xuY2FzZSAyMjY6XG5zZWxmLiQgPSB5eS5TVVBFUjtcbmJyZWFrO1xuY2FzZSAyMzA6XG5zZWxmLiQgPSBuZXcgeXkuQXdhaXQoJCRbJDBdKS5zZXQoe2tleXdvcmQ6ICQkWyQwLTFdfSk7XG5icmVhaztcbmNhc2UgMjM2Olxuc2VsZi4kID0geXkuQVJHVU1FTlRTO1xuYnJlYWs7XG5jYXNlIDI0MTpcbnNlbGYuJCA9IG5ldyB5eS5JbmRleCgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDI0MjpcbnNlbGYuJCA9IG5ldyB5eS5TbGljZSgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDI0MzpcbnNlbGYuJCA9IG5ldyB5eS5PYmooJCRbJDAtMl0sJCRbJDAtM10uZ2VuZXJhdGVkKTtcbmJyZWFrO1xuY2FzZSAyNDQ6XG5zZWxmLiQgPSBuZXcgeXkuQXNzaWduTGlzdChbXSk7XG5icmVhaztcbmNhc2UgMjQ1Olxuc2VsZi4kID0gbmV3IHl5LkFzc2lnbkxpc3QoWyQkWyQwXV0pO1xuYnJlYWs7XG5jYXNlIDI0NjogY2FzZSAyNzg6XG5zZWxmLiQgPSAkJFskMC0yXS5hZGQoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyNDc6IGNhc2UgMjc5Olxuc2VsZi4kID0gJCRbJDAtM10uYWRkKCQkWyQwLTFdKS5hZGQoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyNDg6XG5zZWxmLiQgPSAkJFskMC01XS5jb25jYXQoJCRbJDAtMl0uaW5kZW50ZWQoJCRbJDAtM10sJCRbJDBdKSk7XG5icmVhaztcbmNhc2UgMjUwOlxuc2VsZi4kID0gJCRbJDBdLnNldCh7ZXh0ZW5zaW9uOiAkJFskMC0xXX0pO1xuYnJlYWs7XG5jYXNlIDI1MTpcbnNlbGYuJCA9ICQkWyQwXS5zZXQoe2xvY2FsOiAkJFskMC0xXX0pO1xuYnJlYWs7XG5jYXNlIDI1NDpcbnNlbGYuJCA9ICQkWyQwXS5zZXQoe2V4cG9ydDogJCRbJDAtMl0sbG9jYWw6ICQkWyQwLTFdfSk7XG5icmVhaztcbmNhc2UgMjU1Olxuc2VsZi4kID0gbmV3IHl5LkNsYXNzRGVjbGFyYXRpb24oJCRbJDBdLG51bGwsW10pLnNldCh7a2V5d29yZDogJCRbJDAtMV19KTtcbmJyZWFrO1xuY2FzZSAyNTY6XG5zZWxmLiQgPSBuZXcgeXkuQ2xhc3NEZWNsYXJhdGlvbigkJFskMC0xXSxudWxsLCQkWyQwXSkuc2V0KHtrZXl3b3JkOiAkJFskMC0yXX0pO1xuYnJlYWs7XG5jYXNlIDI1NzpcbnNlbGYuJCA9IG5ldyB5eS5DbGFzc0RlY2xhcmF0aW9uKCQkWyQwLTJdLCQkWyQwXSxbXSkuc2V0KHtrZXl3b3JkOiAkJFskMC0zXX0pO1xuYnJlYWs7XG5jYXNlIDI1ODpcbnNlbGYuJCA9IG5ldyB5eS5DbGFzc0RlY2xhcmF0aW9uKCQkWyQwLTNdLCQkWyQwLTFdLCQkWyQwXSkuc2V0KHtrZXl3b3JkOiAkJFskMC00XX0pO1xuYnJlYWs7XG5jYXNlIDI1OTpcbnNlbGYuJCA9IG5ldyB5eS5Nb2R1bGUoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyNjA6XG5zZWxmLiQgPSBuZXcgeXkuTW9kdWxlKCQkWyQwLTFdLG51bGwsJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyNjE6XG5zZWxmLiQgPSBuZXcgeXkuQ2FsbCgkJFskMC0yXSwkJFskMF0sJCRbJDAtMV0pO1xuYnJlYWs7XG5jYXNlIDI2MjpcbnNlbGYuJCA9ICQkWyQwLTFdLmFkZEJsb2NrKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjYzOlxuc2VsZi4kID0gZmFsc2U7XG5icmVhaztcbmNhc2UgMjY0Olxuc2VsZi4kID0gdHJ1ZTtcbmJyZWFrO1xuY2FzZSAyNjU6XG5zZWxmLiQgPSBuZXcgeXkuQXJnTGlzdChbXSk7XG5icmVhaztcbmNhc2UgMjY2Olxuc2VsZi4kID0gJCRbJDAtMl07XG5icmVhaztcbmNhc2UgMjY3Olxuc2VsZi4kID0gbmV3IHl5LlRoaXMoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyNjg6XG5zZWxmLiQgPSBuZXcgeXkuU2VsZigkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDI2OTpcbnNlbGYuJCA9IG5ldyB5eS5BcnIobmV3IHl5LkFyZ0xpc3QoW10pKTtcbmJyZWFrO1xuY2FzZSAyNzA6XG5zZWxmLiQgPSBuZXcgeXkuQXJyKCQkWyQwLTJdKTtcbmJyZWFrO1xuY2FzZSAyNzE6XG5zZWxmLiQgPSAnLi4nO1xuYnJlYWs7XG5jYXNlIDI3MjpcbnNlbGYuJCA9ICcuLi4nO1xuYnJlYWs7XG5jYXNlIDI3MzpcbnNlbGYuJCA9IHl5Lk9QKCQkWyQwLTJdLCQkWyQwLTNdLCQkWyQwLTFdKTtcbmJyZWFrO1xuY2FzZSAyNzQ6XG5zZWxmLiQgPSBuZXcgeXkuUmFuZ2UoJCRbJDAtMl0sJCRbJDBdLCQkWyQwLTFdKTtcbmJyZWFrO1xuY2FzZSAyNzU6XG5zZWxmLiQgPSBuZXcgeXkuUmFuZ2UoJCRbJDAtMV0sbnVsbCwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDI3NjpcbnNlbGYuJCA9IG5ldyB5eS5SYW5nZShudWxsLCQkWyQwXSwkJFskMC0xXSk7XG5icmVhaztcbmNhc2UgMjc3Olxuc2VsZi4kID0gbmV3IHl5LkFyZ0xpc3QoWyQkWyQwXV0pO1xuYnJlYWs7XG5jYXNlIDI4MDpcbnNlbGYuJCA9ICQkWyQwLTJdLmluZGVudGVkKCQkWyQwLTNdLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjgxOlxuc2VsZi4kID0gJCRbJDAtNV0uY29uY2F0KCQkWyQwLTJdKTtcbmJyZWFrO1xuY2FzZSAyODk6XG5zZWxmLiQgPSBbXS5jb25jYXQoJCRbJDAtMl0sJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyOTA6XG5zZWxmLiQgPSBuZXcgeXkuVHJ5KCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjkxOlxuc2VsZi4kID0gbmV3IHl5LlRyeSgkJFskMC0xXSwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDI5MjpcbnNlbGYuJCA9IG5ldyB5eS5UcnkoJCRbJDAtMV0sbnVsbCwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDI5MzpcbnNlbGYuJCA9IG5ldyB5eS5UcnkoJCRbJDAtMl0sJCRbJDAtMV0sJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyOTQ6XG5zZWxmLiQgPSBuZXcgeXkuRmluYWxseSgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDI5NTpcbnNlbGYuJCA9IG5ldyB5eS5DYXRjaCgkJFskMF0sJCRbJDAtMV0pO1xuYnJlYWs7XG5jYXNlIDI5NjpcbnNlbGYuJCA9IG5ldyB5eS5UaHJvdygkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDI5NzpcbnNlbGYuJCA9IG5ldyB5eS5QYXJlbnMoJCRbJDAtMV0sJCRbJDAtMl0sJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyOTg6XG5zZWxmLiQgPSBuZXcgeXkuUGFyZW5zKCQkWyQwLTJdLCQkWyQwLTRdLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjk5Olxuc2VsZi4kID0gbmV3IHl5LldoaWxlKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMzAwOlxuc2VsZi4kID0gbmV3IHl5LldoaWxlKCQkWyQwLTJdLHtndWFyZDogJCRbJDBdfSk7XG5icmVhaztcbmNhc2UgMzAxOlxuc2VsZi4kID0gbmV3IHl5LldoaWxlKCQkWyQwXSx7aW52ZXJ0OiB0cnVlfSk7XG5icmVhaztcbmNhc2UgMzAyOlxuc2VsZi4kID0gbmV3IHl5LldoaWxlKCQkWyQwLTJdLHtpbnZlcnQ6IHRydWUsZ3VhcmQ6ICQkWyQwXX0pO1xuYnJlYWs7XG5jYXNlIDMwMzogY2FzZSAzMTE6IGNhc2UgMzE0Olxuc2VsZi4kID0gJCRbJDAtMV0uYWRkQm9keSgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDMwNDogY2FzZSAzMDU6XG5zZWxmLiQgPSAkJFskMF0uYWRkQm9keSh5eS5CbG9jay53cmFwKFskJFskMC0xXV0pKTtcbmJyZWFrO1xuY2FzZSAzMDc6XG5zZWxmLiQgPSBuZXcgeXkuV2hpbGUobmV3IHl5LkxpdGVyYWwoJ3RydWUnKSkuYWRkQm9keSgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDMwODpcbnNlbGYuJCA9IG5ldyB5eS5XaGlsZShuZXcgeXkuTGl0ZXJhbCgndHJ1ZScpKS5hZGRCb2R5KHl5LkJsb2NrLndyYXAoWyQkWyQwXV0pKTtcbmJyZWFrO1xuY2FzZSAzMDk6IGNhc2UgMzEwOlxuc2VsZi4kID0gJCRbJDBdLmFkZEJvZHkoWyQkWyQwLTFdXSk7XG5icmVhaztcbmNhc2UgMzE1Olxuc2VsZi4kID0ge3NvdXJjZTogbmV3IHl5LlZhbHVlTm9kZSgkJFskMF0pfTtcbmJyZWFrO1xuY2FzZSAzMTY6XG5zZWxmLiQgPSAkJFskMF0uY29uZmlndXJlKHtvd246ICQkWyQwLTFdLm93bixuYW1lOiAkJFskMC0xXVswXSxpbmRleDogJCRbJDAtMV1bMV0sa2V5d29yZDogJCRbJDAtMV0ua2V5d29yZH0pO1xuYnJlYWs7XG5jYXNlIDMxNzpcbnNlbGYuJCA9ICgkJFskMF0ua2V5d29yZCA9ICQkWyQwLTFdKSAmJiAkJFskMF07XG5icmVhaztcbmNhc2UgMzE4Olxuc2VsZi4kID0gKCQkWyQwXS5vd24gPSB0cnVlKSAmJiAoJCRbJDBdLmtleXdvcmQgPSAkJFskMC0yXSkgJiYgJCRbJDBdO1xuYnJlYWs7XG5jYXNlIDMyMDogY2FzZSAzMjE6XG5zZWxmLiQgPSBuZXcgeXkuVmFsdWVOb2RlKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMzIzOlxuc2VsZi4kID0gWyQkWyQwLTJdLCQkWyQwXV07XG5icmVhaztcbmNhc2UgMzI0Olxuc2VsZi4kID0gbmV3IHl5LkZvckluKHtzb3VyY2U6ICQkWyQwXX0pO1xuYnJlYWs7XG5jYXNlIDMyNTpcbnNlbGYuJCA9IG5ldyB5eS5Gb3JPZih7c291cmNlOiAkJFskMF0sb2JqZWN0OiB0cnVlfSk7XG5icmVhaztcbmNhc2UgMzI2Olxuc2VsZi4kID0gbmV3IHl5LkZvckluKHtzb3VyY2U6ICQkWyQwLTJdLGd1YXJkOiAkJFskMF19KTtcbmJyZWFrO1xuY2FzZSAzMjc6XG5zZWxmLiQgPSBuZXcgeXkuRm9yT2Yoe3NvdXJjZTogJCRbJDAtMl0sZ3VhcmQ6ICQkWyQwXSxvYmplY3Q6IHRydWV9KTtcbmJyZWFrO1xuY2FzZSAzMjg6XG5zZWxmLiQgPSBuZXcgeXkuRm9ySW4oe3NvdXJjZTogJCRbJDAtMl0sc3RlcDogJCRbJDBdfSk7XG5icmVhaztcbmNhc2UgMzI5Olxuc2VsZi4kID0gbmV3IHl5LkZvckluKHtzb3VyY2U6ICQkWyQwLTRdLGd1YXJkOiAkJFskMC0yXSxzdGVwOiAkJFskMF19KTtcbmJyZWFrO1xuY2FzZSAzMzA6XG5zZWxmLiQgPSBuZXcgeXkuRm9ySW4oe3NvdXJjZTogJCRbJDAtNF0sc3RlcDogJCRbJDAtMl0sZ3VhcmQ6ICQkWyQwXX0pO1xuYnJlYWs7XG5jYXNlIDMzMTpcbnNlbGYuJCA9IG5ldyB5eS5Td2l0Y2goJCRbJDAtM10sJCRbJDAtMV0pO1xuYnJlYWs7XG5jYXNlIDMzMjpcbnNlbGYuJCA9IG5ldyB5eS5Td2l0Y2goJCRbJDAtNV0sJCRbJDAtM10sJCRbJDAtMV0pO1xuYnJlYWs7XG5jYXNlIDMzMzpcbnNlbGYuJCA9IG5ldyB5eS5Td2l0Y2gobnVsbCwkJFskMC0xXSk7XG5icmVhaztcbmNhc2UgMzM0Olxuc2VsZi4kID0gbmV3IHl5LlN3aXRjaChudWxsLCQkWyQwLTNdLCQkWyQwLTFdKTtcbmJyZWFrO1xuY2FzZSAzMzY6XG5zZWxmLiQgPSAkJFskMC0xXS5jb25jYXQoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAzMzc6XG5zZWxmLiQgPSBbbmV3IHl5LlN3aXRjaENhc2UoJCRbJDAtMV0sJCRbJDBdKV07XG5icmVhaztcbmNhc2UgMzM4Olxuc2VsZi4kID0gW25ldyB5eS5Td2l0Y2hDYXNlKCQkWyQwLTJdLCQkWyQwLTFdKV07XG5icmVhaztcbmNhc2UgMzM5Olxuc2VsZi4kID0gbmV3IHl5LklmKCQkWyQwLTFdLCQkWyQwXSx7dHlwZTogJCRbJDAtMl19KTtcbmJyZWFrO1xuY2FzZSAzNDA6XG5zZWxmLiQgPSAkJFskMC00XS5hZGRFbHNlKG5ldyB5eS5JZigkJFskMC0xXSwkJFskMF0se3R5cGU6ICQkWyQwLTJdfSkpO1xuYnJlYWs7XG5jYXNlIDM0MTpcbnNlbGYuJCA9ICQkWyQwLTNdLmFkZEVsc2UobmV3IHl5LklmKCQkWyQwLTFdLCQkWyQwXSx7dHlwZTogJCRbJDAtMl19KSk7XG5icmVhaztcbmNhc2UgMzQyOlxuc2VsZi4kID0gJCRbJDAtMl0uYWRkRWxzZSgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDM0NDpcbnNlbGYuJCA9IG5ldyB5eS5JZigkJFskMF0sbmV3IHl5LkJsb2NrKFskJFskMC0yXV0pLHt0eXBlOiAkJFskMC0xXSxzdGF0ZW1lbnQ6IHRydWV9KTtcbmJyZWFrO1xuY2FzZSAzNDU6XG5zZWxmLiQgPSBuZXcgeXkuSWYoJCRbJDBdLG5ldyB5eS5CbG9jayhbJCRbJDAtMl1dKSx7dHlwZTogJCRbJDAtMV19KTtcbmJyZWFrO1xuY2FzZSAzNDY6XG5zZWxmLiQgPSB5eS5JZi50ZXJuYXJ5KCQkWyQwLTRdLCQkWyQwLTJdLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMzQ3OiBjYXNlIDM0ODpcbnNlbGYuJCA9IHl5Lk9QKCQkWyQwLTFdLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMzQ5Olxuc2VsZi4kID0gbmV3IHl5Lk9wKCctJywkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDM1MDpcbnNlbGYuJCA9IG5ldyB5eS5PcCgnKycsJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAzNTE6XG5zZWxmLiQgPSBuZXcgeXkuVW5hcnlPcCgnLS0nLG51bGwsJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAzNTI6XG5zZWxmLiQgPSBuZXcgeXkuVW5hcnlPcCgnKysnLG51bGwsJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAzNTM6XG5zZWxmLiQgPSBuZXcgeXkuVW5hcnlPcCgnLS0nLCQkWyQwLTFdLG51bGwsdHJ1ZSk7XG5icmVhaztcbmNhc2UgMzU0Olxuc2VsZi4kID0gbmV3IHl5LlVuYXJ5T3AoJysrJywkJFskMC0xXSxudWxsLHRydWUpO1xuYnJlYWs7XG5jYXNlIDM1NTogY2FzZSAzNTY6XG5zZWxmLiQgPSBuZXcgeXkuT3AoJCRbJDAtMV0sJCRbJDAtMl0sJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAzNTc6IGNhc2UgMzU4OiBjYXNlIDM1OTogY2FzZSAzNjA6XG5zZWxmLiQgPSB5eS5PUCgkJFskMC0xXSwkJFskMC0yXSwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDM2MTpcbnNlbGYuJCA9IChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGlmICgkJFskMC0xXS5jaGFyQXQoMCkgPT0gJyEnKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHl5Lk9QKCQkWyQwLTFdLnNsaWNlKDEpLCQkWyQwLTJdLCQkWyQwXSkuaW52ZXJ0KCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIHl5Lk9QKCQkWyQwLTFdLCQkWyQwLTJdLCQkWyQwXSk7XG5cdFx0XHRcdH07XG5cdFx0XHR9KCkpO1xuYnJlYWs7XG5jYXNlIDM2MjpcbnNlbGYuJCA9IHl5Lk9QX0NPTVBPVU5EKCQkWyQwLTFdLl92YWx1ZSwkJFskMC0xXSwkJFskMC0yXSwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDM2MzpcbnNlbGYuJCA9IHl5Lk9QX0NPTVBPVU5EKCQkWyQwLTNdLl92YWx1ZSwkJFskMC00XSwkJFskMC0xXS5pbmRlbnRlZCgkJFskMC0yXSwkJFskMF0pKTtcbmJyZWFrO1xufVxufSxcbnRhYmxlOiBbezE6WzIsMV0sMzoxLDQ6Miw1OjMsNzokVjAsODo1LDEwOiRWMSwxMjo3LDEzOjgsMTU6OSwxNjoxMCwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTM4OiRWeiwxMzk6JFZBLDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MDokVkosMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTpbM119LHsxOlsyLDJdLDY6JFY1MSw5OjEzM30sezY6WzEsMTM1XX0sbygkVjYxLFsyLDRdKSxvKCRWNjEsWzIsNV0sezE0OiRWNzF9KSx7NDoxMzgsNjpbMSwxMzldLDc6JFYwLDg6NSwxMTpbMSwxMzddLDEyOjcsMTM6OCwxNTo5LDE2OjEwLDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxMzg6JFZ6LDEzOTokVkEsMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTcwOiRWSiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oJFY4MSxbMiwxMl0pLG8oJFY4MSxbMiwxM10sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMTI2OiRWOTEsMTcxOiRWYTEsMjEyOiRWVSwyMTQ6JFZWLDIxOTokVlgsMjIwOiRWWSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0pLG8oJFY4MSxbMiwxNl0pLG8oJFY4MSxbMiwxN10sezIxODoxMDgsMjIyOjEwOSwyMTE6MTUyLDIxNzoxNTMsMjEyOiRWVSwyMTQ6JFZWLDIxOTokVlgsMjIwOiRWWSwyMzg6JFZpMX0pLHsxMzoxNTQsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oJFZqMSxbMiwzNF0pLG8oJFZqMSxbMiwzNV0sezE5NToxNTYsMTQxOjE1NywxNzk6MTU5LDIxOiRWazEsODg6JFZsMSw4OTokVm0xLDExMTokVm4xLDE0NDokVkMsMTgwOiRWbzEsMTgxOiRWcDEsMTgzOiRWcTEsMTk2OiRWcjF9KSxvKCRWajEsWzIsMzZdKSxvKCRWajEsWzIsMzddKSxvKCRWajEsWzIsMzhdKSxvKCRWajEsWzIsMzldKSxvKCRWajEsWzIsNDBdKSxvKCRWajEsWzIsNDFdKSxvKCRWajEsWzIsNDJdKSxvKCRWajEsWzIsNDNdKSxvKCRWajEsWzIsNDRdKSxvKCRWajEsWzIsNDVdKSxvKCRWajEsWzIsNDZdKSxvKCRWajEsWzIsNDddKSxvKCRWajEsWzIsNDhdKSxvKCRWajEsWzIsNDldKSxvKCRWczEsWzIsMTQ4XSksbygkVnMxLFsyLDE0OV0pLG8oJFZ0MSxbMiwxOF0pLG8oJFZ0MSxbMiwxOV0pLG8oJFZ0MSxbMiwyMF0pLG8oJFZ0MSxbMiwyMV0sezIxOlsxLDE2Nl19KSxvKCRWdDEsWzIsMjNdLHsyMTpbMSwxNjddfSksbygkVnQxLFsyLDI1XSksbygkVnQxLFsyLDI2XSksezEzOjE2OCwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sbygkVnUxLCRWdjEsezExNzpbMSwxNjldfSksbygkVnUxLFsyLDIzMl0pLG8oJFZ1MSxbMiwyMzNdKSxvKCRWdTEsWzIsMjM0XSksbygkVnUxLFsyLDIzNV0pLG8oJFZ1MSxbMiwyMzZdKSxvKCRWdTEsWzIsMjM3XSksbygkVnUxLFsyLDIzOF0pLG8oJFZ1MSxbMiwyMzldKSxvKCRWdTEsWzIsMjQwXSksbygkVmoxLFsyLDE1MF0pLG8oJFZqMSxbMiwxNTFdKSxvKCRWajEsWzIsMTUyXSksezEzOjE3MCwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezEzOjE3MSwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezEzOjE3MiwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezEzOjE3MywxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezMyOiRWNywzNToxNzUsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4Mjo5Miw4MzokVnAsODk6JFZ3MSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDk6MTAxLDEyOTo0NSwxMzA6JFZ4LDEzMToxNzcsMTM2OiRWeSwxNTA6NzcsMTU0OiRWRiwxNTc6JFZ4MSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6MTc0LDE3ODozOSwxODQ6JFZMLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTk3OiRWUSwxOTg6JFZSfSx7MzI6JFY3LDM1OjE3NSw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgyOjkyLDgzOiRWcCw4OTokVncxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwOToxMDEsMTI5OjQ1LDEzMDokVngsMTMxOjE3NywxMzY6JFZ5LDE1MDo3NywxNTQ6JFZGLDE1NzokVngxLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3NjoxNzksMTc4OjM5LDE4NDokVkwsMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTc6JFZRLDE5ODokVlJ9LG8oJFZ5MSwkVnoxLHsyNDQ6WzEsMTgwXSwyNDU6WzEsMTgxXSwyNDk6WzEsMTgyXX0pLG8oJFZqMSxbMiwzNDNdLHsyMzI6WzEsMTgzXSwyMzc6WzEsMTg0XX0pLHs1OjE4NSwxMDokVjF9LHs1OjE4NiwxMDokVjF9LG8oJFZqMSxbMiwzMDZdKSx7NToxODcsMTA6JFYxfSx7MTA6WzEsMTg5XSwxMzoxODgsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oJFZqMSxbMiwyNDldKSx7MTIxOjE5MSwxMjQ6JFZ3LDE5MjoxOTAsMTkzOiRWT30sezEyMToxOTMsMTI0OiRWdywxOTI6MTkyLDE5MzokVk99LHsxNTU6MTk1LDE1ODokVkksMTkyOjE5NCwxOTM6JFZPfSx7MTIzOlsxLDE5N10sMTU0OiRWRiwxNTU6MTk4LDE1NzokVngxLDE1ODokVkksMTczOjE5OSwxNzU6JFZLLDE5MjoxOTYsMTkzOiRWT30sezMyOiRWNywzNToxNzUsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4Mjo5Miw4MzokVnAsODk6JFZ3MSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDk6MTAxLDEyOTo0NSwxMzA6JFZ4LDEzMToxNzcsMTM2OiRWeSwxNTA6NzcsMTU0OiRWRiwxNTc6JFZ4MSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6MjAwLDE3ODozOSwxODQ6JFZMLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTk3OiRWUSwxOTg6JFZSfSxvKCRWajEsWzIsMTIzXSksbygkVkExLFsyLDEwMl0sezEwNDoyMDEsMTA4OjIwMywxMDk6MjA0LDUxOlsxLDIwNV0sODk6WzEsMjAyXSwxMTA6WzEsMjA2XSwxOTg6JFZSfSksezUwOjIwOCw1MTokVjgsODk6WzEsMjA5XSwxNDk6MjA3fSxvKCRWdDEsWzIsNzddLHszNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNywxNzozMCwxODozMSwyNTozNiwxMzE6MzgsMTc4OjM5LDcyOjQwLDE4Njo0MSwxODc6NDIsMTY2OjQ0LDEyOTo0NSwxMDE6NDYsMTg5OjQ3LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE3Njo1NywyMzU6NTgsMjExOjYwLDIxNTo2MSwyMTc6NjIsMTkyOjY0LDEyMTo3MCwxNDg6NzIsMTY4Ojc2LDE1MDo3Nyw2Mzo3OSw4Mjo5MiwxNTU6OTMsNTc6OTcsNTI6OTgsNTU6OTksNTk6MTAwLDEwOToxMDEsMTczOjEwMiw1MDoxMDMsMjE4OjEwOCwyMjI6MTA5LDYxOjExNiw2NToxMTcsMTY6MTU1LDEzOjIxMCw4MToyMTEsMTk6JFYyLDIwOiRWMywyMTokVkIxLDIzOiRWNCwyNDokVjUsMjY6JFY2LDMyOiRWNyw1MTokVjgsNTM6JFY5LDU0OiRWYSw1NjokVmIsNTg6JFZjLDYwOiRWZCw2MjokVmUsNjQ6JFZmLDY2OiRWZyw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDM6JFZ0LDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEzMDokVngsMTM2OiRWeSwxNDM6JFZCLDE0NDokVkMsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTc1OiRWSywxODQ6JFZMLDE4NTokVk0sMTg4OiRWTiwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTY6JFZXLDIzMDokVlosMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSksezEzOjIxMywxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezI3OjIxNCwyOToyMTUsMzE6MjE2LDMyOiRWQzEsMzM6MjE4LDUwOjIyMCw1MTokVjgsNTc6MjE5LDU4OiRWY30sbygkVnkxLFsyLDIyOF0pLG8oJFZ5MSxbMiwyMjldKSxvKCRWRDEsWzIsMjI2XSksbygkVnUxLFsyLDY3XSksbygkVnUxLFsyLDY4XSksbygkVnUxLFsyLDY5XSksbygkVnUxLFsyLDcwXSksbygkVnUxLFsyLDcxXSksbygkVnUxLFsyLDcyXSksbygkVnUxLFsyLDczXSksbygkVnUxLFsyLDc0XSksezQ6MjIxLDc6JFYwLDg6NSwxMDpbMSwyMjJdLDEyOjcsMTM6OCwxNTo5LDE2OjEwLDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxMzg6JFZ6LDEzOTokVkEsMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTcwOiRWSiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHsxMDokVkUxLDEyOjIyOCwxMzoyMjMsMTU6MjMwLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsOTc6JFZGMSwxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDExOToyMjUsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDEzODokVnosMTM5OiRWQSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzA6JFZKLDE3MTokVkcxLDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwMjoyMjYsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKFsxLDYsMTAsMTEsMTQsMjEsMjIsNzEsODgsODksOTAsOTEsOTcsMTA2LDExMSwxMTIsMTI2LDEzNSwxMzcsMTQ0LDE0NywxNzEsMTgwLDE4MSwxODMsMTk2LDIwMCwyMDEsMjEyLDIxMywyMTQsMjE5LDIyMCwyMjksMjM4LDIzOSwyNDIsMjQzLDI0NiwyNDcsMjQ4XSxbMiwyNjddKSxvKCRWdTEsWzIsMTM0XSksezUwOjIzMSw1MTokVjh9LHs4NDoyMzMsODU6WzEsMjM0XSw4NjpbMSwyMzVdLDg3OlsxLDIzNl0sODg6WzEsMjM3XSw5MTpbMSwyMzhdLDkyOlsxLDIzOV0sOTM6WzEsMjQwXSw5NDpbMSwyNDFdLDk1OlsxLDI0Ml0sOTY6WzEsMjQzXSwxMDA6WzEsMjQ0XSwxMDI6WzEsMjMyXX0sbygkVmoxLFsyLDE2NV0pLHs1OjI0NSwxMDokVjEsMTQ1OlsxLDI0Nl19LG8oJFZIMSwkVkkxLHs2MToxMTYsNjU6MTE3LDE5MToyNDgsMTMzOjI0OSwxMzQ6MjUwLDE1OjI1MSw1MDoyNTIsNTc6MjUzLDYzOjI1NCw1MjoyNTUsNTU6MjU2LDMyOiRWNyw1MTokVjgsNTM6JFY5LDU0OiRWYSw1NjokVmIsNTg6JFZjLDYyOiRWZSw2NDokVmYsNjY6JFZnLDEzNjokVkoxLDEzODokVnosMTM5OiRWQSwxNDU6JFZLMX0pLHs1OjI1OCwxMDokVjF9LG8oJFZEMSxbMiwyMDhdKSxvKCRWRDEsWzIsMjA5XSksbygkVkQxLFsyLDIxMF0pLG8oJFZEMSxbMiwyMTFdKSxvKCRWRDEsWzIsMjEyXSksbygkVkQxLFsyLDIxM10pLG8oJFZEMSxbMiwyMTRdKSx7MTM6MjU5LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTM6MjYwLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTM6MjYxLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7NToyNjIsMTA6JFYxLDEzOjI2MywxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezUwOjI2OCw1MTokVjgsODk6JFZ3MSw5NjokVnMsMTUwOjI3MCwxNjg6MjY5LDE4NzoyNjQsMjI0OjI2NSwyMjU6WzEsMjY2XSwyMjY6MjY3fSx7MjIzOjI3MSwyMjc6WzEsMjcyXSwyMjg6WzEsMjczXX0sezMyOiRWNywzNToxNzUsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4Mjo5Miw4MzokVnAsODk6JFZ3MSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDk6MTAxLDEyOTo0NSwxMzA6JFZ4LDEzMToxNzcsMTM2OiRWeSwxNTA6NzcsMTU0OiRWRiwxNTc6JFZ4MSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6Mjc0LDE3ODozOSwxODQ6JFZMLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTk3OiRWUSwxOTg6JFZSfSx7MTEwOiRWTDEsMTI1OjI3NSwxMjg6JFZNMX0sbygkVk4xLFsyLDE2MF0pLG8oJFZOMSxbMiwxNjFdKSxvKCRWdTEsWzIsNTddKSxvKCRWdTEsWzIsNThdKSxvKCRWdTEsWzIsNTldKSxvKCRWdTEsWzIsNjBdLHs2ODoyNzksNjc6WzEsMjc4XSw2OTpbMSwyODBdLDcwOlsxLDI4MV19KSxvKCRWTzEsWzIsNzhdKSx7NTA6Mjg3LDUxOiRWOCw1NToyODYsNTY6JFZiLDU3OjI4OCw1ODokVmMsODk6JFZQMSwxMDk6Mjg1LDE1OToyODIsMTYxOjI4MywxNjY6Mjg0LDE5NzokVlEsMTk4OiRWUn0sbyhbMSw2LDEwLDExLDE0LDIxLDIyLDI4LDcxLDg4LDg5LDkwLDkxLDk3LDEwNiwxMTEsMTEyLDExNywxMjYsMTM1LDEzNywxNDQsMTQ3LDE2NCwxNjUsMTcxLDE4MCwxODEsMTgzLDE5NiwyMDAsMjAxLDIxMiwyMTMsMjE0LDIxOSwyMjAsMjI5LDIzOCwyMzksMjQyLDI0MywyNDQsMjQ1LDI0NiwyNDcsMjQ4LDI0OV0sWzIsNTRdKSxvKCRWUTEsWzIsNTFdKSxvKCRWUTEsWzIsNTJdKSxvKFsxLDYsMTAsMTEsMTQsMjEsMjIsNzEsODgsODksOTAsOTEsOTcsMTA2LDExMSwxMTIsMTE3LDEyNiwxMzUsMTM3LDE0NCwxNDcsMTcxLDE4MCwxODEsMTgzLDE5NiwyMDAsMjAxLDIxMiwyMTMsMjE0LDIxOSwyMjAsMjI5LDIzOCwyMzksMjQyLDI0MywyNDQsMjQ1LDI0NiwyNDcsMjQ4LDI0OV0sWzIsNTNdKSxvKCRWRDEsWzIsNTVdKSxvKCRWUTEsWzIsMjY4XSksezUwOjI5Myw1MTokVjgsNTc6MjkyLDU4OiRWYyw5NjokVlIxLDE2ODoyOTQsMTcwOlsxLDI5MF0sMTc0OjI5MX0sezUwOjI5Myw1MTokVjgsNTc6MjkyLDU4OiRWYyw5NjokVlIxLDE2ODoyOTQsMTcwOlsxLDI5N10sMTc0OjI5Nn0sbyhbMSw2LDEwLDExLDE0LDIxLDIyLDI4LDcxLDg4LDg5LDkwLDkxLDk3LDk4LDEwNiwxMTEsMTEyLDExNywxMjYsMTM1LDEzNywxNDQsMTQ3LDE2NCwxNjUsMTcxLDE4MCwxODEsMTgzLDE5NiwyMDAsMjAxLDIxMiwyMTMsMjE0LDIxOSwyMjAsMjI3LDIyOCwyMjksMjM4LDIzOSwyNDIsMjQzLDI0NCwyNDUsMjQ2LDI0NywyNDgsMjQ5XSxbMiw1MF0pLG8oJFZTMSxbMiwzMTJdKSxvKCRWUzEsWzIsMzEzXSksbygkVkQxLFsyLDU2XSksbygkVlQxLFsyLDYxXSksbygkVjYxLFsyLDddLHsxMjo3LDEzOjgsMTU6OSwxNjoxMCwzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNywxNzozMCwxODozMSwyNTozNiwxMzE6MzgsMTc4OjM5LDcyOjQwLDE4Njo0MSwxODc6NDIsMTY2OjQ0LDEyOTo0NSwxMDE6NDYsMTg5OjQ3LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE3Njo1NywyMzU6NTgsMjExOjYwLDIxNTo2MSwyMTc6NjIsMTkyOjY0LDEyMTo3MCwxNDg6NzIsMTY4Ojc2LDE1MDo3Nyw2Mzo3OSw4Mjo5MiwxNTU6OTMsNTc6OTcsNTI6OTgsNTU6OTksNTk6MTAwLDEwOToxMDEsMTczOjEwMiw1MDoxMDMsMjE4OjEwOCwyMjI6MTA5LDYxOjExNiw2NToxMTcsODoyOTgsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI2OiRWNiwzMjokVjcsNTE6JFY4LDUzOiRWOSw1NDokVmEsNTY6JFZiLDU4OiRWYyw2MDokVmQsNjI6JFZlLDY0OiRWZiw2NjokVmcsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAzOiRWdCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMzA6JFZ4LDEzNjokVnksMTM4OiRWeiwxMzk6JFZBLDE0MzokVkIsMTQ0OiRWQywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNzA6JFZKLDE3NTokVkssMTg0OiRWTCwxODU6JFZNLDE4ODokVk4sMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjEyOiRWVSwyMTQ6JFZWLDIxNjokVlcsMjE5OiRWWCwyMjA6JFZZLDIzMDokVlosMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSksbyhbMSw2LDExLDE5LDIwLDIzLDI0LDI2LDMyLDUxLDUzLDU0LDU2LDU4LDYwLDYyLDY0LDY2LDczLDc0LDc1LDc2LDc3LDc4LDc5LDgwLDgzLDg5LDkxLDk2LDEwMywxMjIsMTIzLDEyNCwxMzAsMTM2LDEzNywxMzgsMTM5LDE0MywxNDQsMTUxLDE1MiwxNTQsMTU2LDE1NywxNTgsMTcwLDE3MSwxNzUsMTg0LDE4NSwxODgsMTkzLDE5NCwxOTcsMTk4LDIwNCwyMTAsMjEyLDIxNCwyMTYsMjE5LDIyMCwyMzAsMjM2LDI0MCwyNDEsMjQyLDI0MywyNDQsMjQ1XSxbMiw4XSksezE6WzIsM119LHsxMjozMDAsMTM6Mjk5LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTcwOiRWSiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oJFZVMSxbMiw5XSksezY6JFY1MSw5OjEzMywxMTpbMSwzMDFdfSx7NDozMDIsNzokVjAsODo1LDEyOjcsMTM6OCwxNTo5LDE2OjEwLDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxMzg6JFZ6LDEzOTokVkEsMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTcwOiRWSiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHsxMzozMDMsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHsxMzozMDQsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHsxMzozMDUsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHsxMzozMDYsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHsxMzozMDcsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHsxMzozMDgsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHsxMzozMDksMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHsxMzozMTAsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHsxMzozMTEsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oJFZqMSxbMiwzMDVdKSxvKCRWajEsWzIsMzEwXSksezEzOjMxMiwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sbygkVmoxLFsyLDMwNF0pLG8oJFZqMSxbMiwzMDldKSxvKFsxLDYsMTAsMTEsMTQsMjIsOTcsMTM3XSxbMiwxOTddLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDEyNjokVjkxLDE3MTokVmExLDIxMjokVlUsMjE0OiRWViwyMTk6JFZYLDIyMDokVlksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSx7MjExOjE1MiwyMTI6JFZVLDIxNDokVlYsMjE3OjE1MywyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzODokVmkxfSx7MjE6JFZCMSw4MTozMTN9LG8oJFZ1MSxbMiwyNjJdKSxvKCRWVjEsWzIsMjI0XSx7MTc4OjMxNSw2MTozMTYsNjI6JFZlLDE3NzpbMSwzMTRdLDE4NDokVkx9KSx7NTA6MzE3LDUxOiRWOCw1MjozMTgsNTM6JFY5LDU0OiRWYSw1NzozMTksNTg6JFZjfSx7NTA6MzIwLDUxOiRWOH0sezUwOjMyMSw1MTokVjh9LHsxMzozMjMsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODI6MzIyLDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5MDozMjQsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMTk5OjMyNSwyMDA6JFZXMSwyMDE6JFZYMSwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHsyMTpbMiwyNjRdfSx7MTQ1OiRWSzF9LG8oJFZWMSxbMiwyMjVdKSx7MTM6MzI4LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTM6MzI5LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWWTEsWzIsMjMwXSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwxMjY6JFY5MSwxNzE6JFZhMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0pLHsxMDpbMSwzMzFdLDEzOjMzMCwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sbygkVmoxLFsyLDM0N10sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTB9KSxvKCRWajEsWzIsMzQ4XSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MH0pLG8oJFZqMSxbMiwzNDldLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwfSksbygkVmoxLFsyLDM1MF0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTB9KSxvKCRWajEsWzIsMzUxXSx7MjE6JFZ6MSw4ODokVnoxLDg5OiRWejEsMTExOiRWejEsMTQ0OiRWejEsMTgwOiRWejEsMTgxOiRWejEsMTgzOiRWejEsMTk2OiRWejF9KSx7MjE6JFZrMSw4ODokVmwxLDg5OiRWbTEsMTExOiRWbjEsMTQxOjE1NywxNDQ6JFZDLDE3OToxNTksMTgwOiRWbzEsMTgxOiRWcDEsMTgzOiRWcTEsMTk1OjE1NiwxOTY6JFZyMX0sezE1NDokVkYsMTU3OiRWeDEsMTczOjE5OSwxNzU6JFZLfSxvKFsyMSw4OCw4OSwxMTEsMTQ0LDE4MCwxODEsMTgzLDE5Nl0sJFZ2MSksbygkVkgxLCRWSTEsezYxOjExNiw2NToxMTcsMTkxOjI0OCwxMzM6MjQ5LDEzNDoyNTAsMTU6MjUxLDUwOjI1Miw1NzoyNTMsNjM6MjU0LDUyOjI1NSw1NToyNTYsMzI6JFY3LDUxOiRWOCw1MzokVjksNTQ6JFZhLDU2OiRWYiw1ODokVmMsNjI6JFZlLDY0OiRWZiw2NjokVmcsMTM2OiRWSjEsMTM4OiRWeiwxMzk6JFZBfSksbygkVmoxLFsyLDM1Ml0sezIxOiRWejEsODg6JFZ6MSw4OTokVnoxLDExMTokVnoxLDE0NDokVnoxLDE4MDokVnoxLDE4MTokVnoxLDE4MzokVnoxLDE5NjokVnoxfSksbygkVmoxLFsyLDM1M10pLG8oJFZqMSxbMiwzNTRdKSx7MTA6WzEsMzMzXSwxMzozMzIsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHs1OjMzNSwxMDokVjEsMjM2OlsxLDMzNF19LHsxMzozMzYsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oJFZqMSxbMiwyOTBdLHsyMDU6MzM3LDIwNjozMzgsMjA3OiRWWjEsMjA4OlsxLDMzOV19KSxvKCRWajEsWzIsMzAzXSksbygkVmoxLFsyLDMxMV0pLHsxMDpbMSwzNDFdLDEyNjokVjkxLDE3MTokVmExLDIxMToxNDksMjEyOiRWVSwyMTQ6JFZWLDIxNzoxNTAsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0sezIzMTozNDIsMjMzOjM0MywyMzQ6JFZfMX0sbygkVmoxLFsyLDI1MF0pLG8oJFZqMSxbMiwxMjRdKSxvKCRWajEsWzIsMjUxXSksbygkVmoxLFsyLDEyNV0pLG8oJFZqMSxbMiwyNTJdKSxvKCRWajEsWzIsMTY2XSksbygkVmoxLFsyLDI1M10pLHsxOTI6MzQ1LDE5MzokVk99LG8oJFZqMSxbMiwxNjddKSxvKCRWRDEsWzIsMjAyXSksbygkViQxLFsyLDI1OV0sezU6MzQ2LDEwOiRWMSwyMTokVnoxLDg4OiRWejEsODk6JFZ6MSwxMTE6JFZ6MSwxNDQ6JFZ6MSwxODA6JFZ6MSwxODE6JFZ6MSwxODM6JFZ6MSwxOTY6JFZ6MX0pLG8oJFYwMixbMiwxMTJdLHsxMDU6MzQ3LDUyOjM1MiwxMTQ6MzUzLDUzOiRWOSw1NDokVmEsODg6WzEsMzQ4XSw5MTpbMSwzNTFdLDExMTpbMSwzNDldLDExMzpbMSwzNTBdLDExNjokVjEyfSksezEzOjM1NSwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sbygkVkExLFsyLDEwM10pLG8oJFZBMSxbMiw5OV0pLG8oJFZBMSxbMiwxMDBdKSxvKCRWQTEsWzIsMTAxXSksbygkVmoxLFsyLDE1OV0sezE1MDozNTYsMjE6WzEsMzU3XSw4OTokVncxfSksbygkVjIyLFsyLDE2Ml0pLHsxMzozNTgsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oJFZ0MSxbMiw3NV0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMTI2OiRWOTEsMTcxOiRWYTEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSxvKCRWdDEsWzIsNzZdKSx7MTA6JFZFMSwxMjoyMjgsMTM6MzYxLDE1OjIzMCwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMjpbMSwzNTldLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMTk6MzYwLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxMzg6JFZ6LDEzOTokVkEsMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTcwOiRWSiwxNzE6JFZHMSwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDI6MjI2LDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sbygkVnQxLFsyLDI5Nl0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMTI2OiRWOTEsMTcxOiRWYTEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSx7MTQ6WzEsMzYzXSwyODpbMSwzNjJdfSxvKCRWdDEsWzIsMjldLHszMDpbMSwzNjRdfSksbygkVjMyLFsyLDMxXSksbyhbMSw2LDExLDE0LDMwLDEzNywyMTIsMjE0LDIxOSwyMjAsMjM4XSxbMiwzMF0pLG8oJFY0MixbMiwzM10pLG8oJFY0MixbMiwyMDNdKSxvKCRWNDIsWzIsMjA0XSksezY6JFY1MSw5OjEzMywxMzc6WzEsMzY1XX0sezQ6MzY2LDc6JFYwLDg6NSwxMjo3LDEzOjgsMTU6OSwxNjoxMCwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTM4OiRWeiwxMzk6JFZBLDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MDokVkosMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKFs2LDEwLDE0LDk3XSwkVjUyLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDE5OTozNjcsMTI2OiRWOTEsMTcxOiRWYTEsMjAwOiRWVzEsMjAxOiRWWDEsMjEyOiRWVSwyMTQ6JFZWLDIxOTokVlgsMjIwOiRWWSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0pLG8oJFY2MixbMiwyNjldKSxvKFs2LDEwLDk3XSwkVjcyLHsxMTU6MzY4LDE0OiRWODJ9KSxvKCRWOTIsWzIsMjc3XSksezEwOiRWRTEsMTI6MjI4LDEzOjM2MSwxNToyMzAsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDExOTozNzAsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDEzODokVnosMTM5OiRWQSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzA6JFZKLDE3MTokVkcxLDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwMjoyMjYsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWOTIsWzIsMjg1XSksbygkVjkyLFsyLDI4Nl0pLG8oJFY5MixbMiwyODddKSxvKCRWdTEsWzIsMTM1XSksbygkVnUxLFsyLDkyXSksbygkVk8xLFsyLDc5XSksbygkVk8xLFsyLDgwXSksbygkVk8xLFsyLDgxXSksbygkVk8xLFsyLDgyXSksezg5OlsxLDM3MV19LHs4OTpbMSwzNzJdfSxvKCRWTzEsWzIsODVdKSxvKCRWTzEsWzIsODZdKSxvKCRWTzEsWzIsODddKSxvKCRWTzEsWzIsODhdKSx7NTA6MzczLDUxOiRWOH0sbygkVk8xLFsyLDkxXSksbygkVnUxLFsyLDE1NF0pLG8oJFZhMiwkVmIyLHsxNDY6Mzc0LDE2NzozNzUsMTUwOjM3NiwxNjg6Mzc3LDE2OTozNzgsNTA6MzgyLDUxOiRWOCw4OTokVncxLDk2OiRWUjEsMTcwOiRWYzIsMTcxOiRWZDIsMTcyOiRWZTJ9KSxvKCRWYTIsJFZiMix7MTY3OjM3NSwxNTA6Mzc2LDE2ODozNzcsMTY5OjM3OCw1MDozODIsMTQ2OjM4Myw1MTokVjgsODk6JFZ3MSw5NjokVlIxLDE3MDokVmMyLDE3MTokVmQyLDE3MjokVmUyfSksbyhbNiwxMCw5MF0sJFY3Mix7MTE1OjM4NCwxNDokVmYyfSksbygkVmcyLFsyLDI0NV0pLG8oJFZnMixbMiwxMzhdLHsxMzU6WzEsMzg2XX0pLG8oJFZnMixbMiwxNDFdKSxvKCRWaDIsWzIsMTQyXSksbygkVmgyLFsyLDE0M10pLG8oJFZoMixbMiwxNDRdKSxvKCRWaDIsWzIsMTQ1XSksbygkVmgyLFsyLDE0Nl0pLHsxMzozODcsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oJFZqMSxbMiwxNTNdKSx7NTozODgsMTA6JFYxLDEyNjokVjkxLDE3MTokVmExLDIxMToxNDksMjEyOiRWVSwyMTQ6JFZWLDIxNzoxNTAsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0sbygkVmkyLFsyLDI5OV0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMTI2OiRWOTEsMTcxOiRWYTEsMjEyOiRWVSwyMTM6WzEsMzg5XSwyMTQ6JFZWLDIxOTokVlgsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSxvKCRWaTIsWzIsMzAxXSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwxMjY6JFY5MSwxNzE6JFZhMSwyMTI6JFZVLDIxMzpbMSwzOTBdLDIxNDokVlYsMjE5OiRWWCwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0pLG8oJFZqMSxbMiwzMDddKSxvKCRWajIsWzIsMzA4XSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwxMjY6JFY5MSwxNzE6JFZhMSwyMTI6JFZVLDIxNDokVlYsMjE5OiRWWCwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0pLG8oJFZqMSxbMiwzMTVdKSxvKCRWazIsWzIsMzE3XSksezUwOjI2OCw1MTokVjgsODk6JFZ3MSw5NjokVlIxLDE1MDoyNzAsMTY4OjI2OSwyMjQ6MzkxLDIyNjoyNjd9LG8oJFZrMixbMiwzMjJdLHsxNDpbMSwzOTJdfSksbygkVmwyLFsyLDMxOV0pLG8oJFZsMixbMiwzMjBdKSxvKCRWbDIsWzIsMzIxXSksbygkVmoxLFsyLDMxNl0pLHsxMzozOTMsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHsxMzozOTQsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oJFZtMixbMiwyNTVdLHs1OjM5NSwxMDokVjEsMjE6JFZ6MSw4ODokVnoxLDg5OiRWejEsMTExOiRWejEsMTQ0OiRWejEsMTgwOiRWejEsMTgxOiRWejEsMTgzOiRWejEsMTk2OiRWejEsMTI2OlsxLDM5Nl19KSxvKCRWbTIsWzIsMTI2XSx7NTozOTcsMTA6JFYxLDEyNjpbMSwzOThdfSksbygkVmoxLFsyLDEzMl0pLG8oJFZqMSxbMiwxMzNdKSxvKCRWVDEsWzIsNjJdKSxvKCRWVDEsWzIsNjNdKSxvKCRWVDEsWzIsNjRdKSx7MTM6NDAwLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzE6WzEsMzk5XSw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHs4ODpbMSw0MDJdLDkxOlsxLDQwM10sMTYwOjQwMX0sbygkVm4yLFsyLDE4MF0sezE2Mjo0MDUsMjE6WzEsNDA0XSwxNjQ6JFZvMiwxNjU6JFZwMn0pLG8oJFZuMixbMiwxODFdKSxvKCRWbjIsWzIsMTgyXSksbygkVm4yLFsyLDE4M10pLG8oJFZxMixbMiwxNzRdKSxvKCRWcTIsWzIsMTc1XSksezEzOjQwOCwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezUwOjI5Myw1MTokVjgsNTc6MjkyLDU4OiRWYyw5NjokVlIxLDE2ODoyOTQsMTc0OjQwOX0sbygkVkQxLFsyLDE5OV0pLG8oJFZEMSxbMiwyMDVdKSxvKCRWRDEsWzIsMjA2XSksbygkVkQxLFsyLDIwN10pLHsxMDokVkUxLDEyOjIyOCwxMzozNjEsMTU6MjMwLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsOTc6JFZGMSwxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDExOToyMjUsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDEzODokVnosMTM5OiRWQSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzA6JFZKLDE3MTokVkcxLDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwMjoyMjYsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWRDEsWzIsMjAwXSksezUwOjI5Myw1MTokVjgsNTc6MjkyLDU4OiRWYyw5NjokVlIxLDE2ODoyOTQsMTc0OjQxMH0sbygkVjYxLFsyLDZdLHsxNDokVjcxfSksbygkVjgxLFsyLDE0XSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwxMjY6JFY5MSwxNzE6JFZhMSwyMTI6JFZVLDIxNDokVlYsMjE5OiRWWCwyMjA6JFZZLDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSksbygkVjgxLFsyLDE1XSksbygkVlUxLFsyLDEwXSksezY6JFY1MSw5OjEzMywxMTpbMSw0MTFdfSxvKCRWcjIsWzIsMzU1XSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwyNDY6JFZmMX0pLG8oJFZyMixbMiwzNTZdLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDI0NjokVmYxfSksbygkVmoxLFsyLDM1N10sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTB9KSxvKFsxLDYsMTAsMTEsMTQsMjIsNzEsOTAsOTcsMTA2LDExMiwxMjYsMTM1LDEzNywxNDcsMTcxLDIwMCwyMDEsMjEyLDIxMywyMTQsMjE5LDIyMCwyMjksMjM4LDIzOSwyNDcsMjQ4XSxbMiwzNThdLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxfSksbyhbMSw2LDEwLDExLDE0LDIyLDcxLDkwLDk3LDEwNiwxMTIsMTI2LDEzNSwxMzcsMTQ3LDE3MSwyMDAsMjAxLDIxMiwyMTMsMjE0LDIxOSwyMjAsMjI5LDIzOCwyMzldLFsyLDM1OV0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSxvKFsxLDYsMTAsMTEsMTQsMjIsNzEsOTAsOTcsMTA2LDExMiwxMzUsMTM3LDE0NywxNzEsMjAwLDIwMSwyMTIsMjEzLDIxNCwyMTksMjIwLDIyOSwyMzgsMjM5XSxbMiwzNjBdLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDEyNjokVjkxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSksbyhbMSw2LDEwLDExLDE0LDIyLDcxLDkwLDk3LDEwNiwxMTIsMTI2LDEzNSwxMzcsMTQ3LDE3MSwyMDAsMjAxLDIxMiwyMTMsMjE0LDIxOSwyMjAsMjI5LDIzOCwyMzksMjQ4XSxbMiwzNjFdLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxfSksbygkVnMyLFsyLDM0NV0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMTI2OiRWOTEsMTcxOiRWYTEsMjEyOiRWVSwyMTQ6JFZWLDIxOTokVlgsMjIwOiRWWSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0pLHsxMjY6JFY5MSwxMzU6WzEsNDEyXSwxNzE6JFZhMSwyMTE6MTQ5LDIxMjokVlUsMjE0OiRWViwyMTc6MTUwLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9LG8oJFZzMixbMiwzNDRdLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDEyNjokVjkxLDE3MTokVmExLDIxMjokVlUsMjE0OiRWViwyMTk6JFZYLDIyMDokVlksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSxvKCRWdTEsWzIsMjYxXSksbygkVkQxLFsyLDIxNV0pLG8oJFZEMSxbMiwyMTZdKSxvKCRWRDEsWzIsMjIxXSksbygkVkQxLFsyLDIxN10pLG8oJFZEMSxbMiwyMjBdKSxvKCRWRDEsWzIsMjIyXSksbygkVkQxLFsyLDIxOF0pLG8oJFZEMSxbMiwyMTldKSx7MTEyOlsxLDQxM119LHsxMTI6WzIsMjQxXSwxMjY6JFY5MSwxNzE6JFZhMSwxOTk6NDE0LDIwMDokVlcxLDIwMTokVlgxLDIxMToxNDksMjEyOiRWVSwyMTQ6JFZWLDIxNzoxNTAsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0sezExMjpbMiwyNDJdfSx7MTM6NDE1LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWdDIsWzIsMjcxXSksbygkVnQyLFsyLDI3Ml0pLHsyMjpbMSw0MTZdLDEyNjokVjkxLDE3MTokVmExLDIxMToxNDksMjEyOiRWVSwyMTQ6JFZWLDIxNzoxNTAsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0sezIyOlsxLDQxN10sMTI2OiRWOTEsMTcxOiRWYTEsMjExOjE0OSwyMTI6JFZVLDIxNDokVlYsMjE3OjE1MCwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSxvKCRWWTEsWzIsMTM2XSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwxMjY6JFY5MSwxNzE6JFZhMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0pLHsxMzo0MTgsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oJFZZMSxbMiwzNjJdLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDEyNjokVjkxLDE3MTokVmExLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSksezEzOjQxOSwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezEzOjQyMCwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sbygkVnUyLFsyLDM0Ml0pLHs1OjQyMSwxMDokVjEsMTI2OiRWOTEsMTcxOiRWYTEsMjExOjE0OSwyMTI6JFZVLDIxNDokVlYsMjE3OjE1MCwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSxvKCRWajEsWzIsMjkxXSx7MjA2OjQyMiwyMDc6JFZaMX0pLG8oJFZqMSxbMiwyOTJdKSx7MjA5OlsxLDQyM119LHs1OjQyNCwxMDokVjF9LHsyMzE6NDI1LDIzMzozNDMsMjM0OiRWXzF9LHsxMTpbMSw0MjZdLDIzMjpbMSw0MjddLDIzMzo0MjgsMjM0OiRWXzF9LG8oJFZ2MixbMiwzMzVdKSx7MTM6NDMwLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjAzOjQyOSwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oJFZqMSxbMiwyNTRdKSxvKCRWajEsWzIsMjYwXSksezY6JFY3MiwxNDpbMSw0MzJdLDEwNjpbMSw0MzFdLDExNTo0MzN9LHs1MTpbMSw0MzVdLDYyOlsxLDQzNF0sODk6WzEsNDM2XX0sezEzOjQzNywxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezg5OlsxLDQzOF19LHs1MTpbMSw0MzldLDg5OlsxLDQ0MF19LG8oJFZBMSxbMiwxMTBdKSxvKCRWMDIsWzIsMTEzXSksbygkVjAyLFsyLDExNl0sezExNzpbMSw0NDFdfSksezkwOlsxLDQ0Ml0sMTI2OiRWOTEsMTcxOiRWYTEsMjExOjE0OSwyMTI6JFZVLDIxNDokVlYsMjE3OjE1MCwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSxvKCRWajEsWzIsMTU3XSksezg5OiRWdzEsMTUwOjQ0M30sezkwOlsxLDQ0NF0sMTI2OiRWOTEsMTcxOiRWYTEsMjExOjE0OSwyMTI6JFZVLDIxNDokVlYsMjE3OjE1MCwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSxvKCRWdTEsWzIsMjY1XSksbyhbNiwxMCwyMl0sJFY3Mix7MTE1OjQ0NSwxNDokVjgyfSksbygkVjkyLCRWNTIsezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMTI2OiRWOTEsMTcxOiRWYTEsMjEyOiRWVSwyMTQ6JFZWLDIxOTokVlgsMjIwOiRWWSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0pLHsyOTo0NDYsMzI6JFZDMX0sezMxOjQ0NywzMzoyMTgsNTA6MjIwLDUxOiRWOCw1NzoyMTksNTg6JFZjfSx7MzE6NDQ4LDMzOjIxOCw1MDoyMjAsNTE6JFY4LDU3OjIxOSw1ODokVmN9LG8oJFZ1MSxbMiwyOTddKSx7NjokVjUxLDk6MTMzLDExOlsxLDQ0OV19LHsxMzo0NTAsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHs2OiRWNTEsOTo0NTIsMTA6JFZ3Miw5NzpbMSw0NTFdfSxvKFs2LDEwLDExLDIyLDk3XSwkVngyLHszNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNywxNzozMCwxODozMSwyNTozNiwxMzE6MzgsMTc4OjM5LDcyOjQwLDE4Njo0MSwxODc6NDIsMTY2OjQ0LDEyOTo0NSwxMDE6NDYsMTg5OjQ3LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE3Njo1NywyMzU6NTgsMjExOjYwLDIxNTo2MSwyMTc6NjIsMTkyOjY0LDEyMTo3MCwxNDg6NzIsMTY4Ojc2LDE1MDo3Nyw2Mzo3OSw4Mjo5MiwxNTU6OTMsNTc6OTcsNTI6OTgsNTU6OTksNTk6MTAwLDEwOToxMDEsMTczOjEwMiw1MDoxMDMsMjE4OjEwOCwyMjI6MTA5LDYxOjExNiw2NToxMTcsMTY6MTU1LDEyOjIyOCwxNToyMzAsMTM6MzYxLDIwMjo0NTQsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI2OiRWNiwzMjokVjcsNTE6JFY4LDUzOiRWOSw1NDokVmEsNTY6JFZiLDU4OiRWYyw2MDokVmQsNjI6JFZlLDY0OiRWZiw2NjokVmcsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAzOiRWdCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMzA6JFZ4LDEzNjokVnksMTM4OiRWeiwxMzk6JFZBLDE0MzokVkIsMTQ0OiRWQywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNzA6JFZKLDE3MTokVkcxLDE3NTokVkssMTg0OiRWTCwxODU6JFZNLDE4ODokVk4sMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjEyOiRWVSwyMTQ6JFZWLDIxNjokVlcsMjE5OiRWWCwyMjA6JFZZLDIzMDokVlosMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSksbygkVnkyLCRWNzIsezExNTo0NTUsMTQ6JFY4Mn0pLHsxMzo0NTYsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHsxMzo0NTcsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHs5NzpbMSw0NThdLDk4OlsxLDQ1OV19LHsxNDokVnoyLDE0NzpbMSw0NjBdfSxvKCRWQTIsWzIsMTg3XSksbygkVkEyLFsyLDE4OV0pLG8oJFZBMixbMiwxOTBdKSxvKCRWQTIsWzIsMTkxXSx7MTE3OlsxLDQ2Ml19KSx7NTA6MzgyLDUxOiRWOCwxNjk6NDYzfSx7NTA6MzgyLDUxOiRWOCwxNjk6NDY0fSx7NTA6MzgyLDUxOiRWOCwxNjk6NDY1fSxvKFsxNCwyMiwxMTcsMTQ3XSxbMiwxOTZdKSx7MTQ6JFZ6MiwxNDc6WzEsNDY2XX0sezY6JFY1MSw5OjQ2OCwxMDokVkIyLDkwOlsxLDQ2N119LG8oWzYsMTAsMTEsOTBdLCRWeDIsezYxOjExNiw2NToxMTcsMTM0OjI1MCwxNToyNTEsNTA6MjUyLDU3OjI1Myw2MzoyNTQsNTI6MjU1LDU1OjI1NiwxMzM6NDcwLDMyOiRWNyw1MTokVjgsNTM6JFY5LDU0OiRWYSw1NjokVmIsNTg6JFZjLDYyOiRWZSw2NDokVmYsNjY6JFZnLDEzNjokVkoxLDEzODokVnosMTM5OiRWQX0pLHsxMDpbMSw0NzJdLDEzOjQ3MSwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezEyNjokVjkxLDEzNzpbMSw0NzNdLDE3MTokVmExLDIxMToxNDksMjEyOiRWVSwyMTQ6JFZWLDIxNzoxNTAsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0sbygkVnUyLFsyLDMzOV0pLHsxMzo0NzQsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHsxMzo0NzUsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oJFZrMixbMiwzMThdKSx7NTA6MjY4LDUxOiRWOCw4OTokVncxLDk2OiRWUjEsMTUwOjI3MCwxNjg6MjY5LDIyNjo0NzZ9LG8oWzEsNiwxMCwxMSwxNCwyMiw3MSw5MCw5NywxMDYsMTEyLDEzNSwxMzcsMTQ3LDIwMCwyMDEsMjEyLDIxNCwyMTksMjIwLDIzOF0sWzIsMzI0XSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwxMjY6JFY5MSwxNzE6JFZhMSwyMTM6WzEsNDc3XSwyMjk6WzEsNDc4XSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0pLG8oJFZDMixbMiwzMjVdLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDEyNjokVjkxLDE3MTokVmExLDIxMzpbMSw0NzldLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSksbygkVmoxLFsyLDI1Nl0pLHsxMzo0ODAsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oJFZqMSxbMiwxMjddKSx7MTEwOiRWTDEsMTI1OjQ4MSwxMjg6JFZNMX0sbygkVlQxLFsyLDY1XSksezcxOlsxLDQ4Ml0sMTI2OiRWOTEsMTcxOiRWYTEsMjExOjE0OSwyMTI6JFZVLDIxNDokVlYsMjE3OjE1MCwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSx7NTA6Mjg3LDUxOiRWOCw1NzoyODgsNTg6JFZjLDg5OiRWUDEsMTYxOjQ4M30sbygkVkQyLFsyLDE3Ml0pLG8oJFZEMixbMiwxNzNdKSxvKCRWRTIsJFZiMix7MTY3OjM3NSwxNTA6Mzc2LDE2ODozNzcsMTY5OjM3OCw1MDozODIsMTQ2OjQ4NCw1MTokVjgsODk6JFZ3MSw5NjokVlIxLDE3MDokVmMyLDE3MTokVmQyLDE3MjokVmUyfSksbygkVmoxLFsyLDE3MV0pLHs1OjQ4NSwxMDokVjEsODk6JFZtMSwxNDE6NDg2LDE0NDokVkN9LG8oJFZqMSxbMiwxNzldKSx7OTA6WzEsNDg3XSwxMjY6JFY5MSwxNzE6JFZhMSwyMTE6MTQ5LDIxMjokVlUsMjE0OiRWViwyMTc6MTUwLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9LG8oJFZEMSxbMiwxOThdKSxvKCRWRDEsWzIsMjAxXSksbygkVlUxLFsyLDExXSksezEzOjQ4OCwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sbygkVkQxLFsyLDIyM10pLHsxMzo0ODksMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDExMjpbMiwyNzVdLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHsxMTI6WzIsMjc2XSwxMjY6JFY5MSwxNzE6JFZhMSwyMTE6MTQ5LDIxMjokVlUsMjE0OiRWViwyMTc6MTUwLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9LG8oJFZ0MSxbMiwyMl0pLG8oJFZ0MSxbMiwyNF0pLHs2OiRWNTEsOTo0OTEsMTE6JFZGMiwxMjY6JFY5MSwxMzI6NDkwLDE3MTokVmExLDIxMToxNDksMjEyOiRWVSwyMTQ6JFZWLDIxNzoxNTAsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0sezY6JFY1MSw5OjQ5MSwxMTokVkYyLDEyNjokVjkxLDEzMjo0OTMsMTcxOiRWYTEsMjExOjE0OSwyMTI6JFZVLDIxNDokVlYsMjE3OjE1MCwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSx7NTo0OTQsMTA6JFYxLDEyNjokVjkxLDE3MTokVmExLDIxMToxNDksMjEyOiRWVSwyMTQ6JFZWLDIxNzoxNTAsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0sbygkVnUyLFsyLDM0MV0pLG8oJFZqMSxbMiwyOTNdKSx7NTo0OTUsMTA6JFYxfSxvKCRWajEsWzIsMjk0XSksezExOlsxLDQ5Nl0sMjMyOlsxLDQ5N10sMjMzOjQyOCwyMzQ6JFZfMX0sbygkVmoxLFsyLDMzM10pLHs1OjQ5OCwxMDokVjF9LG8oJFZ2MixbMiwzMzZdKSx7NTo0OTksMTA6JFYxLDE0OlsxLDUwMF19LG8oJFZHMixbMiwyODhdLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDEyNjokVjkxLDE3MTokVmExLDIxMjokVlUsMjE0OiRWViwyMTk6JFZYLDIyMDokVlksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSxvKCRWJDEsWzIsOTZdLHsxMDc6NTAxLDEwOlsxLDUwMl0sMjE6WzEsNTAzXX0pLHs2OiRWeDIsMTE0OjUwNCwxMTY6JFYxMn0sezY6WzEsNTA1XX0sbygkVkExLFsyLDEwNF0pLG8oJFZBMSxbMiwxMDZdKSx7MTM6NTA2LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTEyOlsxLDUwN10sMTI2OiRWOTEsMTcxOiRWYTEsMjExOjE0OSwyMTI6JFZVLDIxNDokVlYsMjE3OjE1MCwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSx7MTM6NTA4LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWQTEsWzIsMTA5XSksezEzOjUwOSwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezEzOjUxMSwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTE4OjUxMCwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTA2OlsxLDUxMl19LHsyMjpbMSw1MTNdfSxvKCRWMjIsWzIsMTYzXSksezY6JFY1MSw5OjQ1MiwxMDokVncyLDIyOlsxLDUxNF19LG8oJFZ0MSxbMiwyN10pLG8oJFYzMixbMiwzMl0pLG8oJFZ0MSxbMiwyOF0pLHsxMzc6WzEsNTE1XX0sezk3OlsxLDUxNl0sMTI2OiRWOTEsMTcxOiRWYTEsMjExOjE0OSwyMTI6JFZVLDIxNDokVlYsMjE3OjE1MCwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSxvKCRWNjIsWzIsMjcwXSksezEyOjIyOCwxMzozNjEsMTU6MjMwLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTM4OiRWeiwxMzk6JFZBLDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MDokVkosMTcxOiRWRzEsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjAyOjUxNywyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHsxMDokVkUxLDEyOjIyOCwxMzozNjEsMTU6MjMwLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMTk6NTE4LDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxMzg6JFZ6LDEzOTokVkEsMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTcwOiRWSiwxNzE6JFZHMSwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDI6MjI2LDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sbygkVjkyLFsyLDI3OF0pLHs2OiRWNTEsOTo1MjAsMTA6JFZ3MiwxMTokVkYyLDEzMjo1MTl9LHs5MDpbMSw1MjFdLDEyNjokVjkxLDE3MTokVmExLDIxMToxNDksMjEyOiRWVSwyMTQ6JFZWLDIxNzoxNTAsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0sezkwOlsxLDUyMl0sMTI2OiRWOTEsMTcxOiRWYTEsMjExOjE0OSwyMTI6JFZVLDIxNDokVlYsMjE3OjE1MCwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSxvKCRWTzEsWzIsODldKSx7MzI6JFY3LDUxOlsxLDUyNF0sNjE6MTE2LDYyOiRWZSw2Mzo1MjUsNjQ6JFZmLDY1OjExNyw2NjokVmcsODk6WzEsNTI2XSw5OTo1MjN9LHs1OjUyNywxMDokVjF9LHs1MDozODIsNTE6JFY4LDg5OiRWdzEsOTY6JFZSMSwxNTA6Mzc2LDE2Nzo1MjgsMTY4OjM3NywxNjk6Mzc4LDE3MDokVmMyLDE3MTokVmQyLDE3MjokVmUyfSx7MTM6NTI5LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWQTIsWzIsMTkyXSksbygkVkEyLFsyLDE5M10pLG8oJFZBMixbMiwxOTRdKSx7NTo1MzAsMTA6JFYxfSxvKFsxLDYsMTAsMTEsMTQsMjEsMjIsNzEsODgsODksOTAsOTcsMTA2LDExMSwxMTIsMTE3LDEyNiwxMzUsMTM3LDE0NCwxNDcsMTcxLDE4MCwxODEsMTgzLDE5NiwyMDAsMjAxLDIxMiwyMTMsMjE0LDIxOSwyMjAsMjI3LDIyOCwyMjksMjM4LDIzOSwyNDIsMjQzLDI0NiwyNDcsMjQ4XSxbMiwyNDNdKSx7MTU6MjUxLDMyOiRWNyw1MDoyNTIsNTE6JFY4LDUyOjI1NSw1MzokVjksNTQ6JFZhLDU1OjI1Niw1NjokVmIsNTc6MjUzLDU4OiRWYyw2MToxMTYsNjI6JFZlLDYzOjI1NCw2NDokVmYsNjU6MTE3LDY2OiRWZywxMzM6NTMxLDEzNDoyNTAsMTM2OiRWSjEsMTM4OiRWeiwxMzk6JFZBfSxvKFs2LDEwLDExLDE0XSwkVkkxLHs2MToxMTYsNjU6MTE3LDEzMzoyNDksMTM0OjI1MCwxNToyNTEsNTA6MjUyLDU3OjI1Myw2MzoyNTQsNTI6MjU1LDU1OjI1NiwxOTE6NTMyLDMyOiRWNyw1MTokVjgsNTM6JFY5LDU0OiRWYSw1NjokVmIsNTg6JFZjLDYyOiRWZSw2NDokVmYsNjY6JFZnLDEzNjokVkoxLDEzODokVnosMTM5OiRWQX0pLG8oJFZnMixbMiwyNDZdKSxvKCRWZzIsWzIsMTM5XSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwxMjY6JFY5MSwxNzE6JFZhMSwyMTI6JFZVLDIxNDokVlYsMjE5OiRWWCwyMjA6JFZZLDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSksezEzOjUzMywxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sbygkVmgyLFsyLDE0N10pLG8oJFZqMixbMiwzMDBdLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDEyNjokVjkxLDE3MTokVmExLDIxMjokVlUsMjE0OiRWViwyMTk6JFZYLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSksbygkVmoyLFsyLDMwMl0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMTI2OiRWOTEsMTcxOiRWYTEsMjEyOiRWVSwyMTQ6JFZWLDIxOTokVlgsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSxvKCRWazIsWzIsMzIzXSksezEzOjUzNCwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezEzOjUzNSwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezEzOjUzNiwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sbyhbMSw2LDExLDE0LDIyLDcxLDkwLDk3LDEwNiwxMTIsMTM1LDEzNywxNDcsMjAwLDIwMSwyMTMsMjIwLDIyOSwyMzhdLFsyLDI1N10sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsNTo1MzcsMTA6JFYxLDEyNjokVjkxLDE3MTokVmExLDIxMjokVlUsMjE0OiRWViwyMTk6JFZYLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSksbygkViQxLFsyLDEyOF0sezU6NTM4LDEwOiRWMX0pLG8oJFZUMSxbMiw2Nl0pLHsyMTpbMSw1MzldLDE2Mjo1NDAsMTY0OiRWbzIsMTY1OiRWcDJ9LHsxNDokVnoyLDIyOlsxLDU0MV19LG8oJFZqMSxbMiwxNzddKSxvKCRWajEsWzIsMTc4XSksbygkVnEyLFsyLDE3Nl0pLG8oWzEsNiwxMCwxMSwxNCwyMiw3MSw5MCw5NywxMDYsMTEyLDEzNSwxMzcsMTQ3LDIwMCwyMDEsMjEyLDIxMywyMTQsMjE5LDIyMCwyMjksMjM4LDIzOV0sWzIsMzQ2XSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwxMjY6JFY5MSwxNzE6JFZhMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0pLHsxMTI6WzIsMjc0XSwxMjY6JFY5MSwxNzE6JFZhMSwyMTE6MTQ5LDIxMjokVlUsMjE0OiRWViwyMTc6MTUwLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9LG8oJFZqMSxbMiwxMzddKSx7MTE6JFZIMn0sbygkVmoxLFsyLDI4M10pLG8oJFZqMSxbMiwzNjNdKSxvKCRWdTIsWzIsMzQwXSksbyhbMSw2LDEwLDExLDE0LDIyLDcxLDkwLDk3LDEwNiwxMTIsMTI2LDEzNSwxMzcsMTQ3LDE3MSwyMDAsMjAxLDIwNywyMTIsMjEzLDIxNCwyMTksMjIwLDIyOSwyMzgsMjM5LDI0MiwyNDMsMjQ2LDI0NywyNDhdLFsyLDI5NV0pLG8oJFZqMSxbMiwzMzFdKSx7NTo1NDMsMTA6JFYxfSx7MTE6WzEsNTQ0XX0sbygkVnYyLFsyLDMzN10sezY6WzEsNTQ1XX0pLHsxMzo1NDYsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oJFZqMSxbMiw5N10pLHsxMDokVkUxLDEyOjIyOCwxMzozNjEsMTU6MjMwLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMTk6NTQ3LDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxMzg6JFZ6LDEzOTokVkEsMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTcwOiRWSiwxNzE6JFZHMSwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDI6MjI2LDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezEwOiRWRTEsMTI6MjI4LDEzOjM2MSwxNToyMzAsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDExOTo1NDgsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDEzODokVnosMTM5OiRWQSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzA6JFZKLDE3MTokVkcxLDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwMjoyMjYsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWMDIsWzIsMTE0XSksezExNDo1NDksMTE2OiRWMTJ9LHs5MDpbMSw1NTBdLDEyNjokVjkxLDE3MTokVmExLDIxMToxNDksMjEyOiRWVSwyMTQ6JFZWLDIxNzoxNTAsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0sbygkVkExLFsyLDEwNV0pLHs5MDpbMSw1NTFdLDEyNjokVjkxLDE3MTokVmExLDIxMToxNDksMjEyOiRWVSwyMTQ6JFZWLDIxNzoxNTAsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0sezkwOlsxLDU1Ml0sMTI2OiRWOTEsMTcxOiRWYTEsMjExOjE0OSwyMTI6JFZVLDIxNDokVlYsMjE3OjE1MCwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSxvKCRWMDIsWzIsMTE3XSksbygkVjAyLFsyLDExOF0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMTI2OiRWOTEsMTcxOiRWYTEsMjEyOiRWVSwyMTQ6JFZWLDIxOTokVlgsMjIwOiRWWSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0pLG8oJFZqMSxbMiw5OF0pLG8oJFZqMSxbMiwxNThdKSxvKCRWdTEsWzIsMjY2XSksbygkVnUxLFsyLDI5OF0pLG8oJFZ1MSxbMiwyNzNdKSxvKCRWOTIsWzIsMjc5XSksbygkVnkyLCRWNzIsezExNTo1NTMsMTQ6JFY4Mn0pLG8oJFY5MixbMiwyODBdKSx7MTE6JFZIMiwxMjoyMjgsMTM6MzYxLDE1OjIzMCwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDEzODokVnosMTM5OiRWQSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzA6JFZKLDE3MTokVkcxLDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwMjo1MTcsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWTzEsWzIsODNdKSxvKCRWTzEsWzIsODRdKSx7OTc6WzEsNTU0XX0sezk3OlsyLDkzXX0sezk3OlsyLDk0XX0sezEzOjU1NSwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sbygkVnUxLFsyLDE1NV0pLG8oJFZBMixbMiwxODhdKSxvKCRWQTIsWzIsMTk1XSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwxMjY6JFY5MSwxNzE6JFZhMSwyMTI6JFZVLDIxNDokVlYsMjE5OiRWWCwyMjA6JFZZLDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSksezkwOlsxLDU1Nl19LG8oJFZnMixbMiwyNDddKSxvKCRWeTIsJFY3Mix7MTE1OjU1NywxNDokVmYyfSksezY6JFY1MSw5OjQ5MSwxMTokVkYyLDEyNjokVjkxLDEzMjo1NTgsMTcxOiRWYTEsMjExOjE0OSwyMTI6JFZVLDIxNDokVlYsMjE3OjE1MCwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSxvKFsxLDYsMTAsMTEsMTQsMjIsNzEsOTAsOTcsMTA2LDExMiwxMzUsMTM3LDE0NywyMDAsMjAxLDIxMiwyMTMsMjE0LDIxOSwyMjAsMjM4XSxbMiwzMjZdLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDEyNjokVjkxLDE3MTokVmExLDIyOTpbMSw1NTldLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSksbygkVkMyLFsyLDMyOF0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMTI2OiRWOTEsMTcxOiRWYTEsMjEzOlsxLDU2MF0sMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSxvKCRWWTEsWzIsMzI3XSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwxMjY6JFY5MSwxNzE6JFZhMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0pLG8oJFZqMSxbMiwyNThdKSxvKCRWajEsWzIsMTI5XSksbygkVkUyLCRWYjIsezE2NzozNzUsMTUwOjM3NiwxNjg6Mzc3LDE2OTozNzgsNTA6MzgyLDE0Njo1NjEsNTE6JFY4LDg5OiRWdzEsOTY6JFZSMSwxNzA6JFZjMiwxNzE6JFZkMiwxNzI6JFZlMn0pLG8oJFZqMSxbMiwxNjldKSx7MTYyOjU2MiwxNjQ6JFZvMiwxNjU6JFZwMn0sbygkVmoxLFsyLDI4Ml0pLHs2OiRWNTEsOTo0OTEsMTE6JFZGMiwxMzI6NTYzfSxvKCRWajEsWzIsMzM0XSksbygkVnYyLFsyLDMzOF0pLG8oJFZHMixbMiwyODldLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDEyNjokVjkxLDE3MTokVmExLDIxMjokVlUsMjE0OiRWViwyMTk6JFZYLDIyMDokVlksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSxvKCRWSTIsJFY3Mix7MTE1OjU2NSwxMTpbMSw1NjRdLDE0OiRWODJ9KSxvKCRWSTIsJFY3Mix7MTE1OjU2NSwxNDokVjgyLDIyOlsxLDU2Nl19KSxvKCRWMDIsWzIsMTE1XSksbygkVkExLFsyLDEwN10pLG8oJFZBMSxbMiwxMDhdKSxvKCRWQTEsWzIsMTExXSksezY6JFY1MSw5OjUyMCwxMDokVncyLDExOiRWRjIsMTMyOjU2N30sbygkVk8xLFsyLDkwXSksezkwOlsxLDU2OF0sMTI2OiRWOTEsMTcxOiRWYTEsMjExOjE0OSwyMTI6JFZVLDIxNDokVlYsMjE3OjE1MCwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSxvKCRWdTEsWzIsMTU2XSksezY6JFY1MSw5OjU3MCwxMDokVkIyLDExOiRWRjIsMTMyOjU2OX0sbygkVmcyLFsyLDE0MF0pLHsxMzo1NzEsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHsxMzo1NzIsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHsxNDokVnoyLDIyOlsxLDU3M119LG8oJFZqMSxbMiwxNzBdKSxvKCRWajEsWzIsMzMyXSksbygkVmoxLFsyLDExOV0pLHs2OiRWNTEsOTo0NTIsMTA6JFZ3Mn0sbygkVmoxLFsyLDEyMF0pLG8oJFY5MixbMiwyODFdKSx7OTc6WzIsOTVdfSxvKCRWZzIsWzIsMjQ4XSksezExOiRWSDIsMTU6MjUxLDMyOiRWNyw1MDoyNTIsNTE6JFY4LDUyOjI1NSw1MzokVjksNTQ6JFZhLDU1OjI1Niw1NjokVmIsNTc6MjUzLDU4OiRWYyw2MToxMTYsNjI6JFZlLDYzOjI1NCw2NDokVmYsNjU6MTE3LDY2OiRWZywxMzM6NTMxLDEzNDoyNTAsMTM2OiRWSjEsMTM4OiRWeiwxMzk6JFZBfSxvKCRWWTEsWzIsMzI5XSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwxMjY6JFY5MSwxNzE6JFZhMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0pLG8oJFZZMSxbMiwzMzBdLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDEyNjokVjkxLDE3MTokVmExLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSksezE2Mjo1NzQsMTY0OiRWbzIsMTY1OiRWcDJ9LG8oJFZqMSxbMiwxNjhdKV0sXG5kZWZhdWx0QWN0aW9uczogezEzNTpbMiwzXSwxNjM6WzIsMjY0XSwzMjQ6WzIsMjQyXSw1MjQ6WzIsOTNdLDUyNTpbMiw5NF0sNTY4OlsyLDk1XX0sXG5wYXJzZUVycm9yOiBmdW5jdGlvbiBwYXJzZUVycm9yKHN0ciwgaGFzaCkge1xuICAgIGlmIChoYXNoLnJlY292ZXJhYmxlKSB7XG4gICAgICAgIHRoaXMudHJhY2Uoc3RyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc3RyKTtcbiAgICB9XG59LFxucGFyc2U6IGZ1bmN0aW9uIHBhcnNlKGlucHV0KSB7XG5cbiAgICAvLyBGb3IgSW1iYSB3ZSBhcmUgZ29pbmcgdG8gZHJvcCBtb3N0IG9mIHRoZSBmZWF0dXJlcyB0aGF0IGFyZSBub3QgdXNlZFxuICAgIC8vIExvY2F0aW9ucyBhcmUgcHJvdmlkZWQgYnkgdGhlIHRva2VucyBmcm9tIHRoZSBsZXhlciBkaXJlY3RseSAtIHNvIGRyb3AgeXlsbG9jXG4gICAgLy8gV2UgZG9udCByZWFsbHkgbmVlZCB0aGUgc2hhcmVkIHN0YXRlIChpdCBzZWVtcylcblxuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgc3RhY2sgPSBbMF0sXG4gICAgICAgIHRzdGFjayA9IFtdLCAvLyB0b2tlbiBzdGFja1xuICAgICAgICB2c3RhY2sgPSBbbnVsbF0sIC8vIHNlbWFudGljIHZhbHVlIHN0YWNrXG4gICAgICAgIHRhYmxlID0gdGhpcy50YWJsZSxcbiAgICAgICAgeXl0ZXh0ID0gJycsXG4gICAgICAgIHl5bGluZW5vID0gMCxcbiAgICAgICAgeXlsZW5nID0gMCxcbiAgICAgICAgcmVjb3ZlcmluZyA9IDAsXG4gICAgICAgIFRFUlJPUiA9IDIsXG4gICAgICAgIEVPRiA9IDE7XG5cbiAgICAvLyB2YXIgYXJncyA9IGxzdGFjay5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgLy90aGlzLnJlZHVjdGlvbkNvdW50ID0gdGhpcy5zaGlmdENvdW50ID0gMDtcblxuICAgIHZhciBsZXhlciA9IE9iamVjdC5jcmVhdGUodGhpcy5sZXhlcik7XG4gICAgdmFyIHl5ID0gdGhpcy55eTtcblxuICAgIGxleGVyLnNldElucHV0KGlucHV0LHl5KTtcblxuICAgIGlmICh0eXBlb2YgeXkucGFyc2VFcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnBhcnNlRXJyb3IgPSB5eS5wYXJzZUVycm9yO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGFyc2VFcnJvciA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5wYXJzZUVycm9yOyAvLyB3aGF0P1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvcFN0YWNrIChuKSB7XG4gICAgICAgIHN0YWNrLmxlbmd0aCA9IHN0YWNrLmxlbmd0aCAtIDIgKiBuO1xuICAgICAgICB2c3RhY2subGVuZ3RoID0gdnN0YWNrLmxlbmd0aCAtIG47XG4gICAgfVxuXG4gICAgdmFyIHN5bWJvbCwgcHJlRXJyb3JTeW1ib2wsIHN0YXRlLCBhY3Rpb24sIGEsIHIsIHl5dmFsID0ge30sIHAsIGxlbiwgbmV3U3RhdGUsIGV4cGVjdGVkO1xuXG4gICAgZnVuY3Rpb24gaGFuZGxlRXJyb3IoKXtcbiAgICAgICAgdmFyIGVycm9yX3J1bGVfZGVwdGg7XG4gICAgICAgIHZhciBlcnJTdHIgPSAnJztcblxuICAgICAgICAvLyBSZXR1cm4gdGhlIHJ1bGUgc3RhY2sgZGVwdGggd2hlcmUgdGhlIG5lYXJlc3QgZXJyb3IgcnVsZSBjYW4gYmUgZm91bmQuXG4gICAgICAgIC8vIFJldHVybiBGQUxTRSB3aGVuIG5vIGVycm9yIHJlY292ZXJ5IHJ1bGUgd2FzIGZvdW5kLlxuICAgICAgICAvLyB3ZSBoYXZlIG5vIHJ1bGVzIG5vd1xuICAgICAgICBmdW5jdGlvbiBsb2NhdGVOZWFyZXN0RXJyb3JSZWNvdmVyeVJ1bGUoc3RhdGUpIHtcbiAgICAgICAgICAgIHZhciBzdGFja19wcm9iZSA9IHN0YWNrLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB2YXIgZGVwdGggPSAwO1xuXG4gICAgICAgICAgICAvLyB0cnkgdG8gcmVjb3ZlciBmcm9tIGVycm9yXG4gICAgICAgICAgICBmb3IoOzspIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgZXJyb3IgcmVjb3ZlcnkgcnVsZSBpbiB0aGlzIHN0YXRlXG4gICAgICAgICAgICAgICAgaWYgKChURVJST1IudG9TdHJpbmcoKSkgaW4gdGFibGVbc3RhdGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXB0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlID09PSAwIHx8IHN0YWNrX3Byb2JlIDwgMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIE5vIHN1aXRhYmxlIGVycm9yIHJlY292ZXJ5IHJ1bGUgYXZhaWxhYmxlLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGFja19wcm9iZSAtPSAyOyAvLyBwb3BTdGFjaygxKTogW3N5bWJvbCwgYWN0aW9uXVxuICAgICAgICAgICAgICAgIHN0YXRlID0gc3RhY2tbc3RhY2tfcHJvYmVdO1xuICAgICAgICAgICAgICAgICsrZGVwdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJlY292ZXJpbmcpIHtcbiAgICAgICAgICAgIC8vIGZpcnN0IHNlZSBpZiB0aGVyZSdzIGFueSBjaGFuY2UgYXQgaGl0dGluZyBhbiBlcnJvciByZWNvdmVyeSBydWxlOlxuICAgICAgICAgICAgZXJyb3JfcnVsZV9kZXB0aCA9IGxvY2F0ZU5lYXJlc3RFcnJvclJlY292ZXJ5UnVsZShzdGF0ZSk7XG5cbiAgICAgICAgICAgIC8vIFJlcG9ydCBlcnJvclxuICAgICAgICAgICAgZXhwZWN0ZWQgPSBbXTtcblxuICAgICAgICAgICAgdmFyIHRzeW0gPSBsZXhlci55eXRleHQ7XG4gICAgICAgICAgICB2YXIgdG9rID0gc2VsZi50ZXJtaW5hbHNfW3N5bWJvbF0gfHwgc3ltYm9sO1xuICAgICAgICAgICAgdmFyIHRsb2MgPSB0c3ltID8gdHN5bS5fbG9jIDogLTE7XG4gICAgICAgICAgICB2YXIgdHBvcyA9IHRsb2MgIT0gLTEgPyBcIltcIiArIHRzeW0uX2xvYyArIFwiOlwiICsgdHN5bS5fbGVuICsgXCJdXCIgOiAnWzA6MF0nO1xuXG4gICAgICAgICAgICBpZiAobGV4ZXIuc2hvd1Bvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgZXJyU3RyID0gJ1BhcnNlIGVycm9yIGF0ICcrKHRwb3MpK1wiOlxcblwiK2xleGVyLnNob3dQb3NpdGlvbigpK1wiXFxuRXhwZWN0aW5nIFwiK2V4cGVjdGVkLmpvaW4oJywgJykgKyBcIiwgZ290ICdcIiArIChzZWxmLnRlcm1pbmFsc19bc3ltYm9sXSB8fCBzeW1ib2wpKyBcIidcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXJyU3RyID0gJ1BhcnNlIGVycm9yIGF0ICcrKHRwb3MpK1wiOiBVbmV4cGVjdGVkIFwiICsgKHN5bWJvbCA9PSBFT0YgPyBcImVuZCBvZiBpbnB1dFwiIDogKFwiJ1wiKyh0b2spK1wiJ1wiKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYucGFyc2VFcnJvcihlcnJTdHIsIHtcbiAgICAgICAgICAgICAgICBsZXhlcjogbGV4ZXIsXG4gICAgICAgICAgICAgICAgdGV4dDogbGV4ZXIubWF0Y2gsXG4gICAgICAgICAgICAgICAgdG9rZW46IHRvayxcbiAgICAgICAgICAgICAgICBsaW5lOiBsZXhlci55eWxpbmVubyxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICAgICAgICAgICAgcmVjb3ZlcmFibGU6IChlcnJvcl9ydWxlX2RlcHRoICE9PSBmYWxzZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHByZUVycm9yU3ltYm9sICE9PSBFT0YpIHtcbiAgICAgICAgICAgIGVycm9yX3J1bGVfZGVwdGggPSBsb2NhdGVOZWFyZXN0RXJyb3JSZWNvdmVyeVJ1bGUoc3RhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8ganVzdCByZWNvdmVyZWQgZnJvbSBhbm90aGVyIGVycm9yXG4gICAgICAgIGlmIChyZWNvdmVyaW5nID09IDMpIHtcbiAgICAgICAgICAgIGlmIChzeW1ib2wgPT09IEVPRiB8fCBwcmVFcnJvclN5bWJvbCA9PT0gRU9GKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyclN0ciB8fCAnUGFyc2luZyBoYWx0ZWQgd2hpbGUgc3RhcnRpbmcgdG8gcmVjb3ZlciBmcm9tIGFub3RoZXIgZXJyb3IuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRpc2NhcmQgY3VycmVudCBsb29rYWhlYWQgYW5kIGdyYWIgYW5vdGhlclxuICAgICAgICAgICAgeXl0ZXh0ID0gbGV4ZXIueXl0ZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJ5IHRvIHJlY292ZXIgZnJvbSBlcnJvclxuICAgICAgICBpZiAoZXJyb3JfcnVsZV9kZXB0aCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJTdHIgfHwgJ1BhcnNpbmcgaGFsdGVkLiBObyBzdWl0YWJsZSBlcnJvciByZWNvdmVyeSBydWxlIGF2YWlsYWJsZS4nKTtcbiAgICAgICAgfVxuICAgICAgICBwb3BTdGFjayhlcnJvcl9ydWxlX2RlcHRoKTtcbiAgICAgICAgcHJlRXJyb3JTeW1ib2wgPSAoc3ltYm9sID09IFRFUlJPUiA/IG51bGwgOiBzeW1ib2wpOyAvLyBzYXZlIHRoZSBsb29rYWhlYWQgdG9rZW5cbiAgICAgICAgc3ltYm9sID0gVEVSUk9SOyAgICAgICAgIC8vIGluc2VydCBnZW5lcmljIGVycm9yIHN5bWJvbCBhcyBuZXcgbG9va2FoZWFkXG4gICAgICAgIHN0YXRlID0gc3RhY2tbc3RhY2subGVuZ3RoLTFdO1xuICAgICAgICBhY3Rpb24gPSB0YWJsZVtzdGF0ZV0gJiYgdGFibGVbc3RhdGVdW1RFUlJPUl07XG4gICAgICAgIHJlY292ZXJpbmcgPSAzOyAvLyBhbGxvdyAzIHJlYWwgc3ltYm9scyB0byBiZSBzaGlmdGVkIGJlZm9yZSByZXBvcnRpbmcgYSBuZXcgZXJyb3JcbiAgICB9XG5cblxuICAgIHZhciBfX3N5bSA9IHRoaXMuc3ltYm9sc187XG4gICAgdmFyIF9fcHJvZCA9IHRoaXMucHJvZHVjdGlvbnNfO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgLy8gcmV0cmVpdmUgc3RhdGUgbnVtYmVyIGZyb20gdG9wIG9mIHN0YWNrXG4gICAgICAgIHN0YXRlID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG5cbiAgICAgICAgaWYgKHN5bWJvbCA9PT0gbnVsbCB8fCB0eXBlb2Ygc3ltYm9sID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBzeW1ib2wgPSBfX3N5bVtsZXhlci5sZXgoKV0gfHwgRU9GO1xuICAgICAgICB9XG4gICAgICAgIGFjdGlvbiA9IHRhYmxlW3N0YXRlXSAmJiB0YWJsZVtzdGF0ZV1bc3ltYm9sXTtcblxuX2hhbmRsZV9lcnJvcjpcbiAgICAgICAgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICd1bmRlZmluZWQnIHx8ICFhY3Rpb24ubGVuZ3RoIHx8ICFhY3Rpb25bMF0pIHtcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKCk7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKGFjdGlvblswXSkge1xuICAgICAgICAgICAgY2FzZSAxOiAvLyBzaGlmdFxuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goc3ltYm9sKTtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKGFjdGlvblsxXSk7IC8vIHB1c2ggc3RhdGVcbiAgICAgICAgICAgICAgICB2c3RhY2sucHVzaChsZXhlci55eXRleHQpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHN5bWJvbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmVFcnJvclN5bWJvbCkgeyAvLyBub3JtYWwgZXhlY3V0aW9uL25vIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIHl5dGV4dCA9IGxleGVyLnl5dGV4dDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY292ZXJpbmcgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvdmVyaW5nLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBlcnJvciBqdXN0IG9jY3VycmVkLCByZXN1bWUgb2xkIGxvb2thaGVhZCBmLyBiZWZvcmUgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gcHJlRXJyb3JTeW1ib2w7XG4gICAgICAgICAgICAgICAgICAgIHByZUVycm9yU3ltYm9sID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBsZW4gPSBfX3Byb2RbYWN0aW9uWzFdXVsxXTtcbiAgICAgICAgICAgICAgICAvLyBwZXJmb3JtIHNlbWFudGljIGFjdGlvblxuICAgICAgICAgICAgICAgIHl5dmFsLiQgPSB2c3RhY2tbdnN0YWNrLmxlbmd0aC1sZW5dO1xuICAgICAgICAgICAgICAgIHIgPSB0aGlzLnBlcmZvcm1BY3Rpb24oeXl2YWwsIHl5dGV4dCwgeXksIGFjdGlvblsxXSwgdnN0YWNrKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHdoaWxlKGxlbiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICB2c3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGxlbi0tO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goX19wcm9kW2FjdGlvblsxXV1bMF0pO1xuICAgICAgICAgICAgICAgIG5ld1N0YXRlID0gdGFibGVbc3RhY2tbc3RhY2subGVuZ3RoLTJdXVtzdGFja1tzdGFjay5sZW5ndGgtMV1dO1xuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gobmV3U3RhdGUpO1xuICAgICAgICAgICAgICAgIHZzdGFjay5wdXNoKHl5dmFsLiQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn19O1xuXG5mdW5jdGlvbiBQYXJzZXIgKCkge1xuICB0aGlzLnl5ID0ge307XG59XG5QYXJzZXIucHJvdG90eXBlID0gcGFyc2VyO3BhcnNlci5QYXJzZXIgPSBQYXJzZXI7XG5yZXR1cm4gbmV3IFBhcnNlcjtcbn0pKCk7XG5cblxuaWYgKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbmV4cG9ydHMucGFyc2VyID0gcGFyc2VyO1xuZXhwb3J0cy5QYXJzZXIgPSBwYXJzZXIuUGFyc2VyO1xuZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBhcnNlci5wYXJzZS5hcHBseShwYXJzZXIsIGFyZ3VtZW50cyk7IH07XG4vLyBleHBvcnRzLm1haW4gPSBmdW5jdGlvbiBjb21tb25qc01haW4oYXJncykge1xuLy8gICAgIGlmICghYXJnc1sxXSkge1xuLy8gICAgICAgICBjb25zb2xlLmxvZygnVXNhZ2U6ICcrYXJnc1swXSsnIEZJTEUnKTtcbi8vICAgICAgICAgcHJvY2Vzcy5leGl0KDEpO1xuLy8gICAgIH1cbi8vICAgICB2YXIgc291cmNlID0gcmVxdWlyZSgnZnMnKS5yZWFkRmlsZVN5bmMocmVxdWlyZSgncGF0aCcpLm5vcm1hbGl6ZShhcmdzWzFdKSwgXCJ1dGY4XCIpO1xuLy8gICAgIHJldHVybiBleHBvcnRzLnBhcnNlci5wYXJzZShzb3VyY2UpO1xuLy8gfTtcbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiByZXF1aXJlLm1haW4gPT09IG1vZHVsZSkge1xuICBleHBvcnRzLm1haW4ocHJvY2Vzcy5hcmd2LnNsaWNlKDEpKTtcbn1cbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2NvbXBpbGVyL3BhcnNlci5qc1xuICoqIG1vZHVsZSBpZCA9IDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn1cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAod2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanNcbiAqKiBtb2R1bGUgaWQgPSA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogKHdlYnBhY2spL34vbm9kZS1saWJzLWJyb3dzZXIvfi9wcm9jZXNzL2Jyb3dzZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIjIFRPRE8gQ3JlYXRlIEV4cHJlc3Npb24gLSBtYWtlIGFsbCBleHByZXNzaW9ucyBpbmhlcml0IGZyb20gdGhlc2U/XG5cbmV4dGVybiBwYXJzZUludFxuXG52YXIgaGVscGVycyA9IHJlcXVpcmUgJy4vaGVscGVycydcbnZhciBFUlIgPSByZXF1aXJlICcuL2Vycm9ycydcbnZhciB2OCA9IG51bGwgIyByZXF1aXJlICd2OC1uYXRpdmVzJ1xuXG52YXIgVCA9IHJlcXVpcmUgJy4vdG9rZW4nXG52YXIgVG9rZW4gPSBULlRva2VuXG5cbmltcG9ydCBTb3VyY2VNYXAgZnJvbSAnLi9zb3VyY2VtYXAnXG5cbmV4cG9ydCB2YXIgQVNUID0ge31cblxuIyBIZWxwZXJzIGZvciBvcGVyYXRvcnNcbmV4cG9ydCB2YXIgT1AgPSBkbyB8b3AsIGwsIHJ8XG5cdHZhciBvID0gU3RyaW5nKG9wKVxuXHQjIGNvbnNvbGUubG9nIFwib3BlcmF0b3JcIixvXG5cdHN3aXRjaCBvXG5cdFx0d2hlbiAnLidcblx0XHRcdHIgPSBJZGVudGlmaWVyLm5ldyhyKSBpZiByIGlzYSBTdHJpbmdcblx0XHRcdCMgciA9IHIudmFsdWUgaWYgciBpc2EgVmFyT3JBY2Nlc3Ncblx0XHRcdEFjY2Vzcy5uZXcob3AsbCxyKVxuXHRcdHdoZW4gJz0nXG5cdFx0XHRyZXR1cm4gVHVwbGVBc3NpZ24ubmV3KG9wLGwscikgaWYgbCBpc2EgVHVwbGVcblx0XHRcdEFzc2lnbi5uZXcob3AsbCxyKVxuXG5cdFx0d2hlbiAnPz0nLCd8fD0nLCcmJj0nXG5cdFx0XHRDb25kaXRpb25hbEFzc2lnbi5uZXcob3AsbCxyKVxuXHRcdHdoZW4gJys9JywnLT0nLCcqPScsJy89JywnXj0nLCclPSdcblx0XHRcdENvbXBvdW5kQXNzaWduLm5ldyhvcCxsLHIpXG5cblx0XHR3aGVuICc/Lidcblx0XHRcdGlmIHIgaXNhIFZhck9yQWNjZXNzXG5cdFx0XHRcdCMgY29uc29sZS5sb2cgXCJpcyB2YXIgb3IgYWNjZXNzXCJcblx0XHRcdFx0ciA9IHIudmFsdWVcblx0XHRcdCMgZGVwZW5kcyBvbiB0aGUgcmlnaHQgc2lkZSAtIHRoaXMgaXMgd3Jvbmdcblx0XHRcdFByb3BlcnR5QWNjZXNzLm5ldyhvcCxsLHIpXG5cblx0XHR3aGVuICdpbnN0YW5jZW9mJ1xuXHRcdFx0SW5zdGFuY2VPZi5uZXcob3AsbCxyKVxuXHRcdHdoZW4gJ2luJ1xuXHRcdFx0SW4ubmV3KG9wLGwscilcblx0XHR3aGVuICd0eXBlb2YnXG5cdFx0XHRUeXBlT2YubmV3KG9wLGwscilcblx0XHR3aGVuICdkZWxldGUnXG5cdFx0XHREZWxldGUubmV3KG9wLGwscilcblx0XHR3aGVuICctLScsJysrJywnIScsJ+KImidcblx0XHRcdFVuYXJ5T3AubmV3KG9wLGwscilcblx0XHR3aGVuICc+JywnPCcsJz49JywnPD0nLCc9PScsJz09PScsJyE9JywnIT09J1xuXHRcdFx0Q29tcGFyaXNvbk9wLm5ldyhvcCxsLHIpXG5cdFx0d2hlbiAn4oipJywn4oiqJ1xuXHRcdFx0TWF0aE9wLm5ldyhvcCxsLHIpXG5cdFx0d2hlbiAnLi4nLCcuLi4nXG5cdFx0XHRSYW5nZS5uZXcob3AsbCxyKVxuXHRcdGVsc2Vcblx0XHRcdE9wLm5ldyhvcCxsLHIpXG5cbmV4cG9ydCB2YXIgT1BfQ09NUE9VTkQgPSBkbyB8c3ltLG9wLGwscnxcblx0IyBjb25zb2xlLmxvZyBcIj8uIHNvYWsgb3BlcmF0b3JcIixzeW1cblx0aWYgc3ltID09ICc/Lidcblx0XHRjb25zb2xlLmxvZyBcIj8uIHNvYWsgb3BlcmF0b3JcIlxuXHRcdHJldHVybiBudWxsXG5cdGlmIHN5bSA9PSAnPz0nIG9yIHN5bSA9PSAnfHw9JyBvciBzeW0gPT0gJyYmPSdcblx0XHRyZXR1cm4gQ29uZGl0aW9uYWxBc3NpZ24ubmV3KG9wLGwscilcblx0ZWxzZVxuXHRcdHJldHVybiBDb21wb3VuZEFzc2lnbi5uZXcob3AsbCxyKVxuXG52YXIgT1BUUyA9IHt9XG52YXIgUk9PVCA9IG51bGxcblxuZXhwb3J0IHZhciBOT0RFUyA9IFtdXG5cbnZhciBMSVQgPSBkbyB8dmFsfFxuXHRMaXRlcmFsLm5ldyh2YWwpXG5cbnZhciBTWU0gPSBkbyB8dmFsfFxuXHRTeW1ib2wubmV3KHZhbClcblxudmFyIElGID0gZG8gfGNvbmQsYm9keSxhbHR8XG5cdHZhciBub2RlID0gSWYubmV3KGNvbmQsYm9keSlcblx0bm9kZS5hZGRFbHNlKGFsdCkgaWYgYWx0XG5cdG5vZGVcblxudmFyIEZOID0gZG8gfHBhcnMsYm9keXxcblx0RnVuYy5uZXcocGFycyxib2R5KVxuXG52YXIgQ0FMTCA9IGRvIHxjYWxsZWUscGFycyA9IFtdfFxuXHQjIHBvc3NpYmx5IHJldHVybiBpbnN0ZWFkKCEpXG5cdENhbGwubmV3KGNhbGxlZSxwYXJzKVxuXG52YXIgQ0FMTFNFTEYgPSBkbyB8bmFtZSxwYXJzID0gW118XG5cdHZhciByZWYgPSBJZGVudGlmaWVyLm5ldyhuYW1lKVxuXHRDYWxsLm5ldyhPUCgnLicsU0VMRixyZWYpLHBhcnMpXG5cbnZhciBCTE9DSyA9IGRvXG5cdEJsb2NrLndyYXAoW106c2xpY2UuY2FsbChhcmd1bWVudHMpKVxuXG52YXIgV0hJTEUgPSBkbyB8dGVzdCxjb2RlfFxuXHRXaGlsZS5uZXcodGVzdCkuYWRkQm9keShjb2RlKVxuXG5leHBvcnQgdmFyIFNQTEFUID0gZG8gfHZhbHVlfFxuXHRpZiB2YWx1ZSBpc2EgQXNzaWduXG5cdFx0IyBwIFwiV0FSTlwiXG5cdFx0dmFsdWUubGVmdCA9IFNwbGF0Lm5ldyh2YWx1ZS5sZWZ0KVxuXHRcdHJldHVybiB2YWx1ZVxuXHRlbHNlXG5cdFx0U3BsYXQubmV3KHZhbHVlKVxuXHRcdCMgbm90IHN1cmUgYWJvdXQgdGhpc1xuXG4jIE9QLkFTU0lHTk1FTlQgPSBbIFwiPVwiICwgXCIrPVwiICwgXCItPVwiICwgXCIqPVwiICwgXCIvPVwiICwgXCIlPVwiLCBcIjw8PVwiICwgXCI+Pj1cIiAsIFwiPj4+PVwiLCBcInw9XCIgLCBcIl49XCIgLCBcIiY9XCIgXVxuIyBPUC5MT0dJQ0FMID0gWyBcInx8XCIgLCBcIiYmXCIgXVxuIyBPUC5VTkFSWSA9IFsgXCIrK1wiICwgXCItLVwiIF1cblxudmFyIFNFTUlDT0xPTl9URVNUID0gLzsoXFxzKlxcL1xcLy4qKT9bXFxuXFxzXFx0XSokL1xudmFyIFJFU0VSVkVEX1RFU1QgPSAvXihkZWZhdWx0fGNoYXIpJC9cblxuIyBjYXB0dXJlcyBlcnJvciBmcm9tIHBhcnNlclxuZXhwb3J0IGRlZiBwYXJzZUVycm9yIHN0ciwgb1xuXHQjIGNvbnNvbGUubG9nICdwYXJzZUVycm9yJyxvOnRva2VuXG5cblx0IyBmaW5kIG5lYXJlc3QgdG9rZW5cblx0dmFyIGVyclxuXG5cdGlmIG86bGV4ZXJcblx0XHR2YXIgdG9rZW4gPSBvOmxleGVyOnl5dGV4dFxuXHRcdCMgY29uc29sZS5sb2cgbzpsZXhlcjpwb3MsdG9rZW4uQGxvY1xuXHRcdGVyciA9IEVSUi5JbWJhUGFyc2VFcnJvci5uZXcoe21lc3NhZ2U6IHN0cn0se1xuXHRcdFx0cG9zOiBvOmxleGVyOnBvc1xuXHRcdFx0dG9rZW5zOiBvOmxleGVyOnRva2Vuc1xuXHRcdFx0dG9rZW46IG86bGV4ZXI6eXl0ZXh0XG5cdFx0XHRtZXRhOiBvXG5cdFx0fSlcblxuXHRcdHRocm93IGVyclxuXG5cdFx0IyBzaG91bGQgZmluZCB0aGUgY2xvc2VzdCB0b2tlbiB3aXRoIGFjdHVhbCBwb3NpdGlvblxuXHRcdCMgc3RyID0gXCJbe3Rva2VuLkBsb2N9Ont0b2tlbi5AbGVuIHx8IFN0cmluZyh0b2tlbik6bGVuZ3RofV0ge3N0cn1cIlxuXHR2YXIgZSA9IEVycm9yLm5ldyhzdHIpXG5cdGU6bGV4ZXIgPSBvOmxleGVyXG5cdGU6b3B0aW9ucyA9IG9cblx0dGhyb3cgZVxuXG5kZWYgY19fIG9ialxuXHR0eXBlb2Ygb2JqID09ICdzdHJpbmcnID8gb2JqIDogb2JqLmNcblxuZGVmIG1hcmtfXyB0b2tcblx0aWYgdG9rIGFuZCAoT1BUUzpzb3VyY2VNYXBJbmxpbmUgb3IgT1BUUzpzb3VyY2VNYXApIGFuZCB0b2s6c291cmNlTWFwTWFya2VyXG5cdFx0dG9rLnNvdXJjZU1hcE1hcmtlclxuXHRlbHNlXG5cdFx0JydcblxuZGVmIG51bV9fIG51bVxuXHROdW0ubmV3KG51bSlcblxuZGVmIHN0cl9fIHN0clxuXHQjIHNob3VsZCBwYWNrIGluIHRva2VuPyE/XG5cdFN0ci5uZXcoc3RyKVxuXG5kZWYgYmxrX18gb2JqXG5cdG9iaiBpc2EgQXJyYXkgPyBCbG9jay53cmFwKG9iaikgOiBvYmpcblxuZGVmIHN5bV9fIG9ialxuXHQjIGNvbnNvbGUubG9nIFwic3ltIHtvYmp9XCJcblx0aGVscGVycy5zeW1ib2xpemUoU3RyaW5nKG9iaikpXG5cbmRlZiBjYXJ5X18gYXJ5XG5cdGFyeS5tYXAofHZ8IHR5cGVvZiB2ID09ICdzdHJpbmcnID8gdiA6IHYuYyApXG5cbmRlZiBkdW1wX18gb2JqLCBrZXlcblx0aWYgb2JqIGlzYSBBcnJheVxuXHRcdG9iai5tYXAgZG8gfHZ8IHYgJiYgdjpkdW1wID8gdi5kdW1wKGtleSkgOiB2XG5cdGVsaWYgb2JqIGFuZCBvYmo6ZHVtcFxuXHRcdG9iai5kdW1wXG5cbmRlZiBjb21wYWN0X18gYXJ5XG5cdGlmIGFyeSBpc2EgTGlzdE5vZGVcblx0XHRyZXR1cm4gYXJ5LmNvbXBhY3RcblxuXHRhcnkuZmlsdGVyIGRvIHx2fCB2ICE9IHVuZGVmaW5lZCAmJiB2ICE9IG51bGxcblxuZGVmIHJlZHVjZV9fIHJlcyxhcnlcblx0Zm9yIHYgaW4gYXJ5XG5cdFx0diBpc2EgQXJyYXkgPyByZWR1Y2VfXyhyZXMsdikgOiByZXMucHVzaCh2KVxuXHRyZXR1cm5cblxuZGVmIGZsYXR0ZW5fXyBhcnksIGNvbXBhY3QgPSBub1xuXHR2YXIgb3V0ID0gW11cblx0Zm9yIHYgaW4gYXJ5XG5cdFx0diBpc2EgQXJyYXkgPyByZWR1Y2VfXyhvdXQsdikgOiBvdXQucHVzaCh2KVxuXHRyZXR1cm4gb3V0XG5cdFxuZGVmIEFTVC5wYXJzZSBzdHIsIG9wdHMgPSB7fVxuXHR2YXIgaW5kZW50ID0gc3RyLm1hdGNoKC9cXHQrLylbMF1cblx0IyByZWFsbHk/IFJlcXVpcmUgdGhlIGNvbXBpbGVyLCBub3QgdGhpc1xuXHRJbWJhYy5wYXJzZShzdHIsb3B0cylcblxuZGVmIEFTVC5pbmxpbmUgc3RyLCBvcHRzID0ge31cblx0cGFyc2Uoc3RyLG9wdHMpLmJvZHlcblxuZGVmIEFTVC5ub2RlIHR5cCwgcGFyc1xuXHRpZiB0eXAgPT0gJ2NhbGwnXG5cdFx0aWYgcGFyc1swXS5jID09ICdyZXR1cm4nXG5cdFx0XHRwYXJzWzBdID0gJ3RhdGEnXHRcblx0XHRDYWxsLm5ldyhwYXJzWzBdLHBhcnNbMV0scGFyc1syXSlcblxuXG5kZWYgQVNULmVzY2FwZUNvbW1lbnRzIHN0clxuXHRyZXR1cm4gJycgdW5sZXNzIHN0clxuXHRyZXR1cm4gc3RyXG5cbmV4cG9ydCBjbGFzcyBJbmRlbnRhdGlvblxuXG5cdHByb3Agb3BlblxuXHRwcm9wIGNsb3NlXG5cblx0ZGVmIGluaXRpYWxpemUgYSxiXG5cdFx0QG9wZW4gPSBhXG5cdFx0QGNsb3NlID0gYlxuXHRcdHNlbGZcblxuXHRkZWYgaXNHZW5lcmF0ZWRcblx0XHRAb3BlbiBhbmQgQG9wZW46Z2VuZXJhdGVkXG5cblx0ZGVmIGFsb2Ncblx0XHRAb3BlbiBhbmQgQG9wZW4uQGxvYyBvciAwXG5cblx0ZGVmIGJsb2Ncblx0XHRAY2xvc2UgYW5kIEBjbG9zZS5AbG9jIG9yIDBcblxuXHQjIHNob3VsZCByYXRoZXIgcGFyc2UgYW5kIGV4dHJhY3QgdGhlIGNvbW1lbnRzLCBubz9cblx0ZGVmIHdyYXAgc3RyXG5cdFx0IyB2YXIgcHJlLCBwb3N0XG5cdFxuXHRcdCMgY29uc29sZS5sb2cgXCJJTkRFTlQge0BvcGVuIGFuZCBKU09OLnN0cmluZ2lmeShAb3Blbi5AbWV0YSl9XCJcblx0XHQjIGNvbnNvbGUubG9nIFwiT1VUREVOVCB7QGNsb3NlfVwiXG5cdFx0IyB2YXIgb3YgPSBAb3BlbiBhbmQgQG9wZW4uQHZhbHVlXG5cdFx0IyBpZiBvdiBhbmQgb3Y6bGVuZ3RoID4gMVxuXHRcdCMgXHRjb25zb2xlLmxvZyBcInZhbHVlIGZvciBpbmRlbnRcIixvdlxuXHRcdCMgXHRpZiBvdi5pbmRleE9mKCclfCUnKVxuXHRcdCMgXHRcdHByZSA9IG92LnN1YnN0clxuXHRcdHZhciBvbSA9IEBvcGVuIGFuZCBAb3Blbi5AbWV0YVxuXHRcdHZhciBwcmUgPSBvbSBhbmQgb206cHJlIG9yICcnXG5cdFx0dmFyIHBvc3QgPSBvbSBhbmQgb206cG9zdCBvciAnJ1xuXHRcdHZhciBlc2MgPSBBU1Q6ZXNjYXBlQ29tbWVudHNcblx0XHR2YXIgb3V0ID0gQGNsb3NlXG5cblx0XHQjIHRoZSBmaXJzdCBuZXdsaW5lIHNob3VsZCBub3QgYmUgaW5kZW50ZWQ/XG5cdFx0c3RyID0gcG9zdC5yZXBsYWNlKC9eXFxuLywnJykgKyBzdHJcblx0XHRzdHIgPSBzdHIucmVwbGFjZSgvXi9nLFwiXFx0XCIpLnJlcGxhY2UoL1xcbi9nLFwiXFxuXFx0XCIpLnJlcGxhY2UoL1xcblxcdCQvZyxcIlxcblwiKVxuXG5cdFx0c3RyID0gcHJlICsgJ1xcbicgKyBzdHJcblx0XHRzdHIgKz0gb3V0LmMgaWYgb3V0IGlzYSBUZXJtaW5hdG9yXG5cdFx0c3RyID0gc3RyICsgJ1xcbicgdW5sZXNzIHN0cltzdHI6bGVuZ3RoIC0gMV0gPT0gJ1xcbidcblx0XHRyZXR1cm4gc3RyXG5cdFx0XG52YXIgSU5ERU5UID0gSW5kZW50YXRpb24ubmV3KHt9LHt9KVxuXG5jbGFzcyBTdGFzaFxuXG5cdGRlZiBpbml0aWFsaXplXG5cdFx0QGVudGl0aWVzID0gW11cblxuXHRkZWYgYWRkIGl0ZW1cblx0XHRAZW50aXRpZXMudW5zaGlmdChpdGVtKVxuXHRcdHNlbGZcblxuXHRkZWYgcGx1Y2sgaXRlbVxuXHRcdHZhciBtYXRjaCA9IG51bGxcblx0XHRmb3IgZW50aXR5LGkgaW4gQGVudGl0aWVzXG5cdFx0XHRpZiBlbnRpdHkgPT0gaXRlbSBvciBlbnRpdHkgaXNhIGl0ZW1cblx0XHRcdFx0bWF0Y2ggPSBlbnRpdHlcblx0XHRcdFx0QGVudGl0aWVzLnNwbGljZShpLDEpXG5cdFx0XHRcdHJldHVybiBtYXRjaFxuXHRcdHJldHVybiBudWxsXG5cblxuZXhwb3J0IGNsYXNzIFN0YWNrXG5cblx0cHJvcCBsb2dsZXZlbFxuXHRwcm9wIG5vZGVzXG5cdHByb3Agc2NvcGVzXG5cblx0ZGVmIGluaXRpYWxpemVcblx0XHRyZXNldFxuXG5cdGRlZiByZXNldFxuXHRcdEBub2RlcyAgICA9IFtdXG5cdFx0QHNjb3BpbmcgID0gW11cblx0XHRAc2NvcGVzICAgPSBbXSAjIGZvciBhbmFseXNpcyAtIHNob3VsZCByZW5hbWVcblx0XHRAc3Rhc2ggICAgPSBTdGFzaC5uZXcoc2VsZilcblx0XHRAbG9nbGV2ZWwgPSAzXG5cdFx0QGNvdW50ZXIgID0gMFxuXHRcdEBjb3VudGVycyA9IHt9XG5cdFx0c2VsZlxuXG5cdGRlZiBpbmNyIG5hbWVcblx0XHRAY291bnRlcnNbbmFtZV0gfHw9IDBcblx0XHRAY291bnRlcnNbbmFtZV0gKz0gMVxuXG5cdGRlZiBzdGFzaFxuXHRcdEBzdGFzaFxuXG5cdGRlZiBvcHRpb24ga2V5XG5cdFx0QG9wdGlvbnMgYW5kIEBvcHRpb25zW2tleV1cblxuXHRkZWYgYWRkU2NvcGUgc2NvcGVcblx0XHRAc2NvcGVzLnB1c2goc2NvcGUpXG5cdFx0c2VsZlxuXG5cdGRlZiB0cmF2ZXJzZSBub2RlXG5cdFx0c2VsZlxuXG5cdGRlZiBwdXNoIG5vZGVcblx0XHRAbm9kZXMucHVzaChub2RlKVxuXHRcdCMgbm90IHN1cmUgaWYgd2UgaGF2ZSBhbHJlYWR5IGRlZmluZWQgYSBzY29wZT9cblx0XHRzZWxmXG5cblx0ZGVmIHBvcCBub2RlXG5cdFx0QG5vZGVzLnBvcCAjIChub2RlKVxuXHRcdHNlbGZcblxuXHRkZWYgcGFyZW50XG5cdFx0QG5vZGVzW0Bub2RlczpsZW5ndGggLSAyXVxuXG5cdGRlZiBjdXJyZW50XG5cdFx0QG5vZGVzW0Bub2RlczpsZW5ndGggLSAxXVxuXG5cdGRlZiB1cCB0ZXN0XG5cdFx0dGVzdCB8fD0gZG8gfHZ8ICEodiBpc2EgVmFyT3JBY2Nlc3MpXG5cblx0XHRpZiB0ZXN0OnByb3RvdHlwZSBpc2EgTm9kZVxuXHRcdFx0dmFyIHR5cCA9IHRlc3Rcblx0XHRcdHRlc3QgPSBkbyB8dnwgdiBpc2EgdHlwXG5cblx0XHR2YXIgaSA9IEBub2RlczpsZW5ndGggLSAyICMga2V5XG5cdFx0d2hpbGUgaSA+PSAwXG5cdFx0XHR2YXIgbm9kZSA9IEBub2Rlc1tpXVxuXHRcdFx0cmV0dXJuIG5vZGUgaWYgdGVzdChub2RlKVxuXHRcdFx0aSAtPSAxXG5cdFx0cmV0dXJuIG51bGxcblxuXHRkZWYgcmVsYXRpdmUgbm9kZSwgb2Zmc2V0ID0gMFxuXHRcdHZhciBpZHggPSBAbm9kZXMuaW5kZXhPZihub2RlKVxuXHRcdGlkeCA+PSAwID8gQG5vZGVzW2lkeCArIG9mZnNldF0gOiBudWxsXG5cblx0ZGVmIHNjb3BlIGx2bCA9IDBcblx0XHR2YXIgaSA9IEBub2RlczpsZW5ndGggLSAxIC0gbHZsXG5cdFx0d2hpbGUgaSA+PSAwXG5cdFx0XHR2YXIgbm9kZSA9IEBub2Rlc1tpXVxuXHRcdFx0cmV0dXJuIG5vZGUuQHNjb3BlIGlmIG5vZGUuQHNjb3BlXG5cdFx0XHRpIC09IDFcblx0XHRyZXR1cm4gbnVsbFxuXG5cdGRlZiBzY29wZXNcblx0XHQjIGluY2x1ZGUgZGVlcGVyIHNjb3BlcyBhcyB3ZWxsP1xuXHRcdHZhciBzY29wZXMgPSBbXVxuXHRcdHZhciBpID0gQG5vZGVzOmxlbmd0aCAtIDFcblx0XHR3aGlsZSBpID49IDBcblx0XHRcdHZhciBub2RlID0gQG5vZGVzW2ldXG5cdFx0XHRzY29wZXMucHVzaChub2RlLkBzY29wZSkgaWYgbm9kZS5Ac2NvcGVcblx0XHRcdGkgLT0gMVxuXHRcdHJldHVybiBzY29wZXNcblxuXHRkZWYgbWV0aG9kXG5cdFx0dXAoTWV0aG9kRGVjbGFyYXRpb24pXG5cblx0ZGVmIGJsb2NrXG5cdFx0dXAoQmxvY2spXG5cblx0ZGVmIGlzRXhwcmVzc2lvblxuXHRcdHZhciBpID0gQG5vZGVzOmxlbmd0aCAtIDFcblx0XHR3aGlsZSBpID49IDBcblx0XHRcdHZhciBub2RlID0gQG5vZGVzW2ldXG5cdFx0XHQjIHdoeSBhcmUgd2Ugbm90IHVzaW5nIGlzRXhwcmVzc2lvbiBoZXJlIGFzIHdlbGw/XG5cdFx0XHRpZiBub2RlIGlzYSBDb2RlIG9yIG5vZGUgaXNhIExvb3Bcblx0XHRcdFx0cmV0dXJuIGZhbHNlXG5cdFx0XHRpZiBub2RlLmlzRXhwcmVzc2lvblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdFx0IyBwcm9iYWJseSBub3QgdGhlIHJpZ2h0IHRlc3QgLSBuZWVkIHRvIGJlIG1vcmUgZXhwbGljaXRcblx0XHRcdGkgLT0gMVxuXHRcdHJldHVybiBmYWxzZVxuXG5cdGRlZiB0b1N0cmluZ1xuXHRcdFwiU3RhY2soe0Bub2Rlcy5qb2luKFwiIC0+IFwiKX0pXCJcblxuXHRkZWYgc2NvcGluZ1xuXHRcdEBub2Rlcy5maWx0ZXIofG58IG4uQHNjb3BlICkubWFwKHxufCBuLkBzY29wZSApXG5cbiMgTG90cyBvZiBnbG9iYWxzIC0tIHJlYWxseSBuZWVkIHRvIGRlYWwgd2l0aCBvbmUgc3RhY2sgcGVyIGZpbGUgLyBjb250ZXh0XG5leHBvcnQgdmFyIFNUQUNLID0gU3RhY2submV3XG5cbkdMT0JTVEFDSyA9IFNUQUNLXG5cbiMgdXNlIGEgYml0bWFzayBmb3IgdGhlc2VcblxuZXhwb3J0IGNsYXNzIE5vZGVcblxuXHRwcm9wIG9cblx0cHJvcCBvcHRpb25zXG5cdHByb3AgdHJhdmVyc2VkXG5cblx0ZGVmIHNhZmVjaGFpblxuXHRcdG5vXG5cblx0IyBkZWYgZG9tXG5cdCMgXHR2YXIgbmFtZSA9IFwiYXN0X1wiICsgc2VsZjpjb25zdHJ1Y3RvcjpuYW1lLnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csXCIkMV8kMlwiKS50b0xvd2VyQ2FzZVxuXHQjIFx0IyBwIFwidHJ5IHRvIGdldCB0aGUgZG9tLW5vZGUgZm9yIHRoaXMgYXN0LW5vZGVcIixuYW1lXG5cdCMgXHRpZiBJbWJhLlRBR1NbbmFtZV1cblx0IyBcdFx0dmFyIG5vZGUgPSBJbWJhLnRhZyhuYW1lKVxuXHQjIFx0XHRub2RlLmJpbmQoc2VsZikuYnVpbGRcblx0IyBcdFx0cmV0dXJuIG5vZGVcblx0IyBcdGVsc2Vcblx0IyBcdFx0cmV0dXJuIFwiW3tuYW1lfV1cIlxuXG5cdGRlZiBwXG5cdFxuXHRcdCMgYWxsb3cgY29udHJvbGxpbmcgdGhpcyBmcm9tIGNvbW1hbmRsaW5lXG5cdFx0aWYgU1RBQ0subG9nbGV2ZWwgPiAwXG5cdFx0XHRjb25zb2xlLmxvZygqYXJndW1lbnRzKVxuXHRcdHNlbGZcblxuXHRkZWYgdHlwZU5hbWVcblx0XHRzZWxmOmNvbnN0cnVjdG9yOm5hbWVcblxuXHRkZWYgbmFtZXBhdGhcblx0XHR0eXBlTmFtZVxuXG5cdGRlZiBpbml0aWFsaXplXG5cdFx0c2V0dXBcblx0XHRzZWxmXG5cblx0ZGVmIHNldHVwXG5cdFx0QGV4cHJlc3Npb24gPSBub1xuXHRcdEB0cmF2ZXJzZWQgPSBub1xuXHRcdEBwYXJlbnMgPSBub1xuXHRcdEBjYWNoZSA9IG51bGxcblx0XHRAdmFsdWUgPSBudWxsXG5cdFx0c2VsZlxuXG5cdGRlZiBzZXQgb2JqXG5cdFx0IyBjb25zb2xlLmxvZyBcInNldHRpbmcgb3B0aW9ucyB7SlNPTi5zdHJpbmdpZnkob2JqKX1cIlxuXHRcdEBvcHRpb25zIHx8PSB7fVxuXHRcdGZvciBvd24gayx2IG9mIG9ialxuXHRcdFx0QG9wdGlvbnNba10gPSB2XG5cdFx0c2VsZlxuXG5cdCMgZ2V0IGFuZCBzZXRcblx0ZGVmIG9wdGlvbiBrZXksIHZhbFxuXHRcdGlmIHZhbCAhPSB1bmRlZmluZWRcblx0XHRcdCMgY29uc29sZS5sb2cgXCJzZXR0aW5nIG9wdGlvbiB7a2V5fSB7dmFsfVwiXG5cdFx0XHRAb3B0aW9ucyB8fD0ge31cblx0XHRcdEBvcHRpb25zW2tleV0gPSB2YWxcblx0XHRcdHJldHVybiBzZWxmXG5cblx0XHRAb3B0aW9ucyAmJiBAb3B0aW9uc1trZXldXG5cblx0ZGVmIGNvbmZpZ3VyZSBvYmpcblx0XHRzZXQob2JqKVxuXG5cdGRlZiByZWdpb25cblx0XHRbMCwwXVxuXG5cdGRlZiBsb2Ncblx0XHRbMCwwXVxuXG5cdGRlZiB0b2tlblxuXHRcdG51bGxcblxuXHRkZWYgY29tcGlsZVxuXHRcdHNlbGZcblxuXHRkZWYgdmlzaXRcblx0XHRzZWxmXG5cblx0ZGVmIHN0YWNrXG5cdFx0U1RBQ0tcblxuXHRkZWYgaXNTdHJpbmdcblx0XHRub1xuXG5cdGRlZiBpc1ByaW1pdGl2ZSBkZWVwXG5cdFx0bm9cblxuXHRkZWYgaXNSZXNlcnZlZFxuXHRcdG5vXG5cblx0IyBzaG91bGQgcmF0aGVyIGRvIHRyYXZlcnNhbHNcblx0IyBvID0ge30sIHVwLCBrZXksIGluZGV4XG5cdGRlZiB0cmF2ZXJzZVxuXHRcdGlmIEB0cmF2ZXJzZWRcblx0XHRcdHJldHVybiBzZWxmIFxuXHRcdCMgTk9ERVMucHVzaChzZWxmKVxuXHRcdEB0cmF2ZXJzZWQgPSB5ZXNcblx0XHRTVEFDSy5wdXNoIHNlbGZcblx0XHR2aXNpdChTVEFDSylcblx0XHRTVEFDSy5wb3Agc2VsZlxuXHRcdHJldHVybiBzZWxmXG5cblx0ZGVmIGluc3BlY3Rcblx0XHR7dHlwZTogc2VsZjpjb25zdHJ1Y3Rvci50b1N0cmluZ31cblxuXHRkZWYganMgb1xuXHRcdFwiTk9ERVwiXG5cblx0ZGVmIHRvU3RyaW5nXG5cdFx0XCJ7c2VsZjpjb25zdHJ1Y3RvcjpuYW1lfVwiXG5cblx0IyBzd2FsbG93IG1pZ2h0IGJlIGJldHRlciBuYW1lXG5cdGRlZiBjb25zdW1lIG5vZGVcblx0XHRpZiBub2RlIGlzYSBQdXNoQXNzaWduXG5cdFx0XHRyZXR1cm4gUHVzaEFzc2lnbi5uZXcobm9kZS5vcCxub2RlLmxlZnQsc2VsZilcblxuXHRcdGlmIG5vZGUgaXNhIEFzc2lnblxuXHRcdFx0IyBwIFwiY29uc3VtZSBhc3NpZ25tZW50XCIuY3lhblxuXHRcdFx0IyBub2RlLnJpZ2h0ID0gc2VsZlxuXHRcdFx0cmV0dXJuIE9QKG5vZGUub3Asbm9kZS5sZWZ0LHNlbGYpXG5cdFx0ZWxpZiBub2RlIGlzYSBPcFxuXHRcdFx0cmV0dXJuIE9QKG5vZGUub3Asbm9kZS5sZWZ0LHNlbGYpXG5cdFx0ZWxpZiBub2RlIGlzYSBSZXR1cm5cblx0XHRcdCMgcCBcImNvbnN1bWUgcmV0dXJuXCIuY3lhblxuXHRcdFx0cmV0dXJuIFJldHVybi5uZXcoc2VsZilcblx0XHRyZXR1cm4gc2VsZlxuXG5cdGRlZiB0b0V4cHJlc3Npb25cblx0XHRAZXhwcmVzc2lvbiA9IHRydWVcblx0XHRzZWxmXG5cblx0ZGVmIGZvcmNlRXhwcmVzc2lvblxuXHRcdEBleHByZXNzaW9uID0gdHJ1ZVxuXHRcdHNlbGZcblxuXHRkZWYgaXNFeHByZXNzYWJsZVxuXHRcdHRydWVcblxuXHRkZWYgaXNFeHByZXNzaW9uXG5cdFx0QGV4cHJlc3Npb24gfHwgZmFsc2VcblxuXHRkZWYgaGFzU2lkZUVmZmVjdHNcblx0XHR0cnVlXG5cblx0ZGVmIGlzVXNlZFxuXHRcdHRydWVcblx0XHRcblx0ZGVmIHNob3VsZFBhcmVudGhlc2l6ZVxuXHRcdGZhbHNlXG5cblx0ZGVmIGJsb2NrXG5cdFx0QmxvY2sud3JhcChbc2VsZl0pXG5cblx0ZGVmIG5vZGVcblx0XHRzZWxmXG5cblx0ZGVmIHNjb3BlX19cblx0XHRTVEFDSy5zY29wZVxuXG5cdGRlZiB1cFxuXHRcdFNUQUNLLnBhcmVudFxuXG5cdGRlZiB1dGlsXG5cdFx0VXRpbFxuXG5cdGRlZiByZWNlaXZlclxuXHRcdHNlbGZcblxuXHRkZWYgYWRkRXhwcmVzc2lvbiBleHByXG5cdFx0IyBtaWdodCBiZSBiZXR0ZXIgdG8gbmVzdCB0aGlzIHVwIGFmdGVyIHBhcnNpbmcgaXMgZG9uZT9cblx0XHQjIHAgXCJhZGRFeHByZXNzaW9uIHtzZWxmfSA8LSB7ZXhwcn1cIlxuXHRcdHZhciBub2RlID0gRXhwcmVzc2lvbkJsb2NrLm5ldyhbc2VsZl0pXG5cdFx0cmV0dXJuIG5vZGUuYWRkRXhwcmVzc2lvbihleHByKVxuXG5cblx0ZGVmIGluZGVudGVkIGEsYlxuXG5cdFx0aWYgYSBpc2EgSW5kZW50YXRpb25cblx0XHRcdEBpbmRlbnRhdGlvbiA9IGFcblx0XHRcdHJldHVybiBzZWxmXG5cblx0XHQjIHRoaXMgaXMgYSBfQklHXyBoYWNrXG5cdFx0aWYgYiBpc2EgQXJyYXlcblx0XHRcdGFkZChiWzBdKVxuXHRcdFx0YiA9IGJbMV1cblxuXHRcdCMgaWYgaW5kZW50IGFuZCBpbmRlbnQubWF0Y2goL1xcOi8pXG5cdFx0QGluZGVudGF0aW9uIHx8PSBhIGFuZCBiID8gSW5kZW50YXRpb24ubmV3KGEsYikgOiBJTkRFTlRcblx0XHRzZWxmXG5cblx0ZGVmIHByZWJyZWFrIHRlcm0gPSAnXFxuJ1xuXHRcdCMgaW4gb3B0aW9ucyBpbnN0ZWFkP1xuXHRcdCMgY29uc29sZS5sb2cgXCJwcmVicmVhayEhISFcIlxuXHRcdCMgQHByZWJyZWFrID0gQHByZWJyZWFrIG9yIHRlcm1cblx0XHRzZWxmXG5cblx0ZGVmIGludmVydFxuXHRcdHJldHVybiBPUCgnIScsc2VsZilcblxuXHRkZWYgY2FjaGUgbyA9IHt9XG5cdFx0QGNhY2hlID0gb1xuXHRcdG86dmFyID0gc2NvcGVfXy50ZW1wb3Jhcnkoc2VsZixvKVxuXHRcdG86bG9va3VwcyA9IDBcblx0XHRzZWxmXG5cblx0ZGVmIGNhY2hldmFyXG5cdFx0QGNhY2hlICYmIEBjYWNoZTp2YXJcblxuXHRkZWYgZGVjYWNoZVxuXHRcdGlmIEBjYWNoZVxuXHRcdFx0Y2FjaGV2YXIuZnJlZVxuXHRcdFx0QGNhY2hlID0gbnVsbFxuXHRcdHNlbGZcblxuXHQjIGlzIHRoaXMgd2l0aG91dCBzaWRlLWVmZmVjdHM/IGhtbSAtIHdoYXQgZG9lcyBpdCBldmVuIGRvP1xuXHRkZWYgcHJlZGVjbGFyZVxuXHRcdGlmIEBjYWNoZVxuXHRcdFx0c2NvcGVfXy52YXJzLnN3YXAoQGNhY2hlOnZhcixzZWxmKVxuXHRcdHNlbGZcblxuXHQjIHRoZSBcIm5hbWUtc3VnZ2VzdGlvblwiIGZvciBub2RlcyBpZiB0aGV5IG5lZWQgdG8gYmUgY2FjaGVkXG5cdGRlZiBhbGlhc1xuXHRcdG51bGxcblxuXHRkZWYgd2FybiB0ZXh0LCBvcHRzID0ge31cblx0XHRvcHRzOm1lc3NhZ2UgPSB0ZXh0XG5cdFx0b3B0czpsb2MgfHw9IGxvY1xuXHRcdHNjb3BlX18ucm9vdC53YXJuIG9wdHNcblx0XHRzZWxmXG5cblx0ZGVmIGMgb1xuXHRcdHZhciBzID0gU1RBQ0tcblx0XHR2YXIgY2ggPSBAY2FjaGVcblx0XHRyZXR1cm4gY19jYWNoZWQoY2gpIGlmIGNoIGFuZCBjaDpjYWNoZWRcblxuXHRcdHMucHVzaChzZWxmKVxuXHRcdGZvcmNlRXhwcmVzc2lvbiBpZiBvICYmIG86ZXhwcmVzc2lvblxuXG5cdFx0djggYW5kIGNvbnNvbGUubG9nIHY4Lmhhc0Zhc3RPYmplY3RFbGVtZW50cyhzZWxmKVxuXG5cdFx0aWYgbyBhbmQgbzppbmRlbnRcblx0XHRcdEBpbmRlbnRhdGlvbiB8fD0gSU5ERU5UXG5cblx0XHR2YXIgb3V0ID0ganMocyxvKVxuXG5cdFx0IyByZWFsbHk/IHdoeSBub3QgY2FsbCB0aGlzIHNvbWV3aGVyZSBlbHNlP1xuXHRcdHZhciBwYXJlbiA9IHNob3VsZFBhcmVudGhlc2l6ZVxuXHRcdFxuXHRcdGlmIHZhciBpbmRlbnQgPSBAaW5kZW50YXRpb25cblx0XHRcdG91dCA9IGluZGVudC53cmFwKG91dCxvKVxuXG5cdFx0IyBzaG91bGQgbW92ZSB0aGlzIHNvbWV3aGVyZSBlbHNlIHJlYWxseVxuXHRcdG91dCA9IFwiKHtvdXR9KVwiIGlmIHBhcmVuXG5cdFx0aWYgbyBhbmQgbzpicmFjZXNcblx0XHRcdGlmIGluZGVudFxuXHRcdFx0XHRvdXQgPSAneycgKyBvdXQgKyAnfScgXG5cdFx0XHRlbHNlXG5cdFx0XHRcdG91dCA9ICd7ICcgKyBvdXQgKyAnIH0nXG5cblx0XHRzLnBvcChzZWxmKVxuXG5cdFx0aWYgY2ggPSBAY2FjaGVcblx0XHRcdG91dCA9IFwie2NoOnZhci5jfSA9IHtvdXR9XCIgdW5sZXNzIGNoOm1hbnVhbFxuXHRcdFx0dmFyIHBhciA9IHMuY3VycmVudFxuXHRcdFx0b3V0ID0gJygnICsgb3V0ICsgJyknIGlmIHBhciBpc2EgQWNjZXNzIHx8IHBhciBpc2EgT3AgIyBvdGhlcnM/ICMgXG5cdFx0XHRjaDpjYWNoZWQgPSB5ZXNcblx0XHRyZXR1cm4gb3V0XG5cblx0ZGVmIGNfY2FjaGVkIGNhY2hlXG5cdFx0Y2FjaGU6bG9va3VwcysrXG5cdFx0Y2FjaGU6dmFyLmZyZWUgaWYgY2FjaGU6dXNlcyA9PSBjYWNoZTpsb29rdXBzXG5cdFx0cmV0dXJuIGNhY2hlOnZhci5jICMgcmVjb21waWxlIGV2ZXJ5IHRpbWU/P1xuXG5leHBvcnQgY2xhc3MgVmFsdWVOb2RlIDwgTm9kZVxuXG5cdHByb3AgdmFsdWVcblxuXHRkZWYgaW5pdGlhbGl6ZSB2YWx1ZVxuXHRcdHNldHVwXG5cdFx0QHZhbHVlID0gbG9hZCh2YWx1ZSlcblxuXHRkZWYgbG9hZCB2YWx1ZVxuXHRcdHZhbHVlXG5cblx0ZGVmIGpzIG9cblx0XHR0eXBlb2YgQHZhbHVlID09ICdzdHJpbmcnID8gQHZhbHVlIDogQHZhbHVlLmNcblxuXHRkZWYgdmlzaXRcblx0XG5cdFx0QHZhbHVlLnRyYXZlcnNlIGlmIEB2YWx1ZSBpc2EgTm9kZSAjICAmJiBAdmFsdWU6dHJhdmVyc2Vcblx0XHRzZWxmXG5cblx0ZGVmIHJlZ2lvblxuXHRcdFtAdmFsdWUuQGxvYyxAdmFsdWUuQGxvYyArIEB2YWx1ZS5AbGVuXVxuXG5cbmV4cG9ydCBjbGFzcyBTdGF0ZW1lbnQgPCBWYWx1ZU5vZGVcblxuXHRkZWYgaXNFeHByZXNzYWJsZVxuXHRcdHJldHVybiBub1xuXG5cbmV4cG9ydCBjbGFzcyBNZXRhIDwgVmFsdWVOb2RlXG5cblx0ZGVmIGlzUHJpbWl0aXZlIGRlZXBcblx0XHR5ZXNcblxuZXhwb3J0IGNsYXNzIENvbW1lbnQgPCBNZXRhXG5cdFxuXHRkZWYgdmlzaXRcblx0XHQjIHN0YWNrLnN0YXNoLmFkZChzZWxmKVxuXG5cdFx0aWYgdmFyIGJsb2NrID0gdXBcblx0XHRcdHZhciBpZHggPSBibG9jay5pbmRleE9mKHNlbGYpICsgMVxuXHRcdFx0aWR4ICs9IDEgaWYgYmxvY2suaW5kZXgoaWR4KSBpc2EgVGVybWluYXRvclxuXHRcdFx0aWYgdmFyIG5leHQgPSBibG9jay5pbmRleChpZHgpXG5cdFx0XHRcdG5leHQuQGRlc2MgPSBzZWxmXG5cblx0XHRcdCMgY29uc29sZS5sb2cgXCJOZXh0IGl0ZW0gYWZ0ZXIgY29tbWVudCBpcyB7YmxvY2suaW5kZXgoaWR4KX1cIlxuXG5cdFx0c2VsZlxuXG5cdGRlZiB0b0RvY1xuXHRcdGhlbHBlcnMubm9ybWFsaXplSW5kZW50YXRpb24oXCJcIiArIEB2YWx1ZS5AdmFsdWUpXG5cblx0ZGVmIHRvSlNPTlxuXHRcdGhlbHBlcnMubm9ybWFsaXplSW5kZW50YXRpb24oXCJcIiArIEB2YWx1ZS5AdmFsdWUpXG5cblx0ZGVmIGMgb1xuXHRcdHZhciB2ID0gQHZhbHVlLkB2YWx1ZVxuXHRcdCMgcCBAdmFsdWUudHlwZVxuXHRcdGlmIG8gYW5kIG86ZXhwcmVzc2lvbiBvciB2Lm1hdGNoKC9cXG4vKSBvciBAdmFsdWUudHlwZSA9PSAnSEVSRUNPTU1FTlQnICMgbXVsdGlsaW5lP1xuXHRcdFx0XCIvKnt2fSovXCJcblx0XHRlbHNlXG5cdFx0XHRcIi8vIHt2fVwiXG5cbmV4cG9ydCBjbGFzcyBUZXJtaW5hdG9yIDwgTWV0YVxuXHRcblx0ZGVmIGluaXRpYWxpemUgdlxuXHRcdEB2YWx1ZSA9IHZcblx0XHRzZWxmXG5cblx0ZGVmIHRyYXZlcnNlXG5cdFx0c2VsZlxuXG5cdGRlZiBjXG5cdFx0IyBUT0RPIHRoaXMgY2FuIGNvbnRhaW4gc2V2ZXJhbCBuZXdsaW5lc1xuXHRcdCMgZm9yIHNvdXJjZW1hcHMgaXQgd291bGQgYmUgbmljZSB0byBwYXJzZSB0aGlzXG5cdFx0IyBhbmQgZml4IGl0IHVwIG1hcmtfXyhAdmFsdWUpICsgXG5cdFx0cmV0dXJuIEB2YWx1ZS5jXG5cdFx0IyB2YXIgdiA9IHZhbHVlLnJlcGxhY2UoL1xcXFxuL2csJ1xcbicpXG5cdFx0IyB2ICMgLnNwbGl0KClcblx0XHQjIHYuc3BsaXQoXCJcXG5cIikubWFwKHx2fCB2ID8gXCIgLy8ge3Z9XCIgOiB2KS5qb2luKFwiXFxuXCIpXG5cbmV4cG9ydCBjbGFzcyBOZXdsaW5lIDwgVGVybWluYXRvclxuXG5cdGRlZiBpbml0aWFsaXplIHZcblx0XHRAdHJhdmVyc2VkID0gbm9cblx0XHRAdmFsdWUgPSB2IG9yICdcXG4nXG5cblx0ZGVmIGNcblx0XHRjX18oQHZhbHVlKVxuXHRcdFxuXG4jIHdlaXJkIHBsYWNlP1xuZXhwb3J0IGNsYXNzIEluZGV4IDwgVmFsdWVOb2RlXG5cblx0ZGVmIGpzIG9cblx0XHRAdmFsdWUuY1xuXG5leHBvcnQgY2xhc3MgTGlzdE5vZGUgPCBOb2RlXG5cblx0cHJvcCBub2Rlc1xuXG5cdGRlZiBpbml0aWFsaXplIGxpc3Rcblx0XHRzZXR1cFxuXHRcdEBub2RlcyA9IGxvYWQobGlzdCBvciBbXSlcblx0XHRAaW5kZW50YXRpb24gPSBudWxsXG5cblx0IyBQRVJGIGFjY2VzIEBub2RlcyBkaXJlY3RseT9cblx0ZGVmIGxpc3Rcblx0XHRAbm9kZXNcblxuXHRkZWYgY29tcGFjdFxuXHRcdEBub2RlcyA9IGNvbXBhY3RfXyhAbm9kZXMpXG5cdFx0c2VsZlxuXG5cdGRlZiBsb2FkIGxpc3Rcblx0XHRsaXN0XG5cblx0ZGVmIGNvbmNhdCBvdGhlclxuXHRcdCMgbmVlZCB0byBzdG9yZSBpbmRlbnRlZCBjb250ZW50IGFzIHdlbGw/XG5cdFx0QG5vZGVzID0gbm9kZXMuY29uY2F0KG90aGVyIGlzYSBBcnJheSA/IG90aGVyIDogb3RoZXIubm9kZXMpXG5cdFx0c2VsZlxuXG5cdGRlZiBzd2FwIGl0ZW0sIG90aGVyXG5cdFx0dmFyIGlkeCA9IGluZGV4T2YoaXRlbSlcblx0XHRub2Rlc1tpZHhdID0gb3RoZXIgaWYgaWR4ID49IDBcblx0XHRzZWxmXG5cblx0ZGVmIHB1c2ggaXRlbVxuXHRcdEBub2Rlcy5wdXNoKGl0ZW0pXG5cdFx0c2VsZlxuXG5cdGRlZiBwb3Bcblx0XHR2YXIgZW5kID0gQG5vZGVzLnBvcFxuXHRcdHJldHVybiBlbmRcblxuXHRkZWYgYWRkIGl0ZW1cblx0XHRAbm9kZXMucHVzaChpdGVtKVxuXHRcdHNlbGZcblxuXHRkZWYgdW5zaGlmdCBpdGVtLCBiclxuXHRcdEBub2Rlcy51bnNoaWZ0KEJSKSBpZiBiclxuXHRcdEBub2Rlcy51bnNoaWZ0KGl0ZW0pXG5cdFx0c2VsZlxuXG5cdCMgdGVzdFxuXHRkZWYgc2xpY2UgYSwgYlxuXHRcdHNlbGY6Y29uc3RydWN0b3IubmV3KEBub2Rlcy5zbGljZShhLGIpKVxuXG5cdFxuXG5cdGRlZiBicmVhayBiciwgcHJlID0gbm9cblx0XHRiciA9IFRlcm1pbmF0b3IubmV3KGJyKSBpZiB0eXBlb2YgYnIgPT0gJ3N0cmluZydcblx0XHRwcmUgPyB1bnNoaWZ0KGJyKSA6IHB1c2goYnIpXG5cdFx0c2VsZlxuXG5cdGRlZiBzb21lIGNiXG5cdFx0Zm9yIG5vZGUgaW4gQG5vZGVzXG5cdFx0XHRyZXR1cm4geWVzIGlmIGNiKG5vZGUpXG5cdFx0cmV0dXJuIG5vXG5cblx0ZGVmIGV2ZXJ5IGNiXG5cdFx0Zm9yIG5vZGUgaW4gQG5vZGVzXG5cdFx0XHRyZXR1cm4gbm8gdW5sZXNzIGNiKG5vZGUpXG5cdFx0cmV0dXJuIHllc1xuXG5cdGRlZiBmaWx0ZXIgY2Jcblx0XHRAbm9kZXMuZmlsdGVyKGNiKVxuXG5cdGRlZiBwbHVjayBjYlxuXHRcdHZhciBpdGVtID0gZmlsdGVyKGNiKVswXVxuXHRcdHJlbW92ZShpdGVtKSBpZiBpdGVtXG5cdFx0cmV0dXJuIGl0ZW1cblxuXHRkZWYgaW5kZXhPZiBpdGVtXG5cdFx0QG5vZGVzLmluZGV4T2YoaXRlbSlcblxuXHRkZWYgaW5kZXggaVxuXHRcdEBub2Rlc1tpXVxuXG5cdGRlZiByZW1vdmUgaXRlbVxuXHRcdHZhciBpZHggPSBAbm9kZXMuaW5kZXhPZihpdGVtKVxuXHRcdEBub2Rlcy5zcGxpY2UoaWR4LCAxKSBpZiBpZHggPj0gMFxuXHRcdHNlbGZcblxuXHRkZWYgcmVtb3ZlQXQgaWR4XG5cdFx0dmFyIGl0ZW0gPSBAbm9kZXNbaWR4XVxuXHRcdEBub2Rlcy5zcGxpY2UoaWR4LCAxKSBpZiBpZHggPj0gMFxuXHRcdHJldHVybiBpdGVtXG5cdFx0XG5cblx0ZGVmIHJlcGxhY2Ugb3JpZ2luYWwsIHJlcGxhY2VtZW50XG5cdFx0dmFyIGlkeCA9IEBub2Rlcy5pbmRleE9mKG9yaWdpbmFsKVxuXHRcdGlmIGlkeCA+PSAwXG5cdFx0XHRpZiByZXBsYWNlbWVudCBpc2EgQXJyYXlcblx0XHRcdFx0IyBwIFwicmVwbGFjZWluZyB3aXRoIGFycmF5IG9mIGl0ZW1zXCJcblx0XHRcdFx0QG5vZGVzLnNwbGljZShpZHgsMSwqcmVwbGFjZW1lbnQpXG5cdFx0XHRlbHNlXG5cdFx0XHRcdEBub2Rlc1tpZHhdID0gcmVwbGFjZW1lbnQgXG5cdFx0c2VsZlxuXG5cdGRlZiBmaXJzdFxuXHRcdEBub2Rlc1swXVxuXG5cdGRlZiBsYXN0XG5cdFx0dmFyIGkgPSBAbm9kZXM6bGVuZ3RoXG5cdFx0d2hpbGUgaVxuXHRcdFx0aSA9IGkgLSAxXG5cdFx0XHR2YXIgdiA9IEBub2Rlc1tpXVxuXHRcdFx0cmV0dXJuIHYgdW5sZXNzIHYgaXNhIE1ldGFcblx0XHRyZXR1cm4gbnVsbFxuXG5cdGRlZiBtYXAgZm5cblx0XHRAbm9kZXMubWFwKGZuKVxuXG5cdGRlZiBmb3JFYWNoIGZuXG5cdFx0QG5vZGVzLmZvckVhY2goZm4pXG5cblx0ZGVmIHJlbWFwIGZuXG5cdFx0QG5vZGVzID0gbWFwKGZuKVxuXHRcdHNlbGZcblxuXHRkZWYgY291bnRcblx0XHRAbm9kZXM6bGVuZ3RoXG5cblx0ZGVmIHJlYWxDb3VudFxuXHRcdHZhciBrID0gMFxuXHRcdGZvciBub2RlIGluIEBub2Rlc1xuXHRcdFx0aysrIGlmIG5vZGUgYW5kICEobm9kZSBpc2EgTWV0YSlcblx0XHRyZXR1cm4ga1xuXG5cdGRlZiB2aXNpdFxuXHRcdGZvciBub2RlIGluIEBub2Rlc1xuXHRcdFx0bm9kZSBhbmQgbm9kZS50cmF2ZXJzZVxuXHRcdHNlbGZcblxuXHRkZWYgaXNFeHByZXNzYWJsZVxuXHRcdGZvciBub2RlIGluIG5vZGVzXG5cdFx0XHRyZXR1cm4gbm8gaWYgbm9kZSBhbmQgIW5vZGUuaXNFeHByZXNzYWJsZVxuXHRcdCMgcmV0dXJuIG5vIHVubGVzcyBub2Rlcy5ldmVyeSh8dnwgdi5pc0V4cHJlc3NhYmxlIClcblx0XHRyZXR1cm4geWVzXG5cblx0ZGVmIHRvQXJyYXlcblx0XHRAbm9kZXNcblxuXHRkZWYgZGVsaW1pdGVyXG5cdFx0QGRlbGltaXRlciBvciBcIixcIlxuXG5cdGRlZiBqcyBvLCBub2RlczogQG5vZGVzXG5cdFx0dmFyIGRlbGltID0gJywnXG5cdFx0dmFyIGV4cHJlc3MgPSBkZWxpbSAhPSAnOydcblx0XHR2YXIgbGFzdCA9IGxhc3RcblxuXHRcdHZhciBpID0gMFxuXHRcdHZhciBsID0gbm9kZXM6bGVuZ3RoXG5cdFx0dmFyIHN0ciA9IFwiXCJcblxuXHRcdGZvciBhcmcgaW4gbm9kZXNcblx0XHRcdHZhciBwYXJ0ID0gdHlwZW9mIGFyZyA9PSAnc3RyaW5nJyA/IGFyZyA6IChhcmcgPyBhcmcuYyhleHByZXNzaW9uOiBleHByZXNzKSA6ICcnKVxuXHRcdFx0c3RyICs9IHBhcnRcblx0XHRcdHN0ciArPSBkZWxpbSBpZiBwYXJ0IGFuZCAoIWV4cHJlc3Mgb3IgYXJnICE9IGxhc3QpIGFuZCAhKGFyZyBpc2EgTWV0YSlcblxuXHRcdHJldHVybiBzdHJcblxuXHRkZWYgaW5kZW50ZWQgYSxiXG5cdFx0aWYgYSBpc2EgSW5kZW50YXRpb25cblx0XHRcdEBpbmRlbnRhdGlvbiA9IGFcblx0XHRcdHJldHVybiBzZWxmXG5cblx0XHRAaW5kZW50YXRpb24gfHw9IGEgYW5kIGIgPyBJbmRlbnRhdGlvbi5uZXcoYSxiKSA6IElOREVOVFxuXHRcdHNlbGZcblx0XHRcblxuZXhwb3J0IGNsYXNzIEFyZ0xpc3QgPCBMaXN0Tm9kZVxuXG4jXHRkZWYgaW5kZW50ZWQgYSxiXG4jXHRcdGlmIGEgaXNhIEluZGVudGF0aW9uXG4jXHRcdFx0QGluZGVudGF0aW9uID0gYVxuI1x0XHRcdHJldHVybiBzZWxmXG4jXG4jXHRcdEBpbmRlbnRhdGlvbiB8fD0gYSBhbmQgYiA/IEluZGVudGF0aW9uLm5ldyhhLGIpIDogSU5ERU5UXG4jXHRcdHNlbGZcblxuIyBkZWYgaGFzU3BsYXRcbiMgXHRAbm9kZXMuc29tZSBkbyB8dnwgdiBpc2EgU3BsYXRcbiMgZGVmIGRlbGltaXRlclxuIyBcdFwiLFwiXG5cblxuZXhwb3J0IGNsYXNzIEFzc2lnbkxpc3QgPCBBcmdMaXN0XHRcblxuXHRkZWYgY29uY2F0IG90aGVyXG5cdFx0aWYgQG5vZGVzOmxlbmd0aCA9PSAwIGFuZCBvdGhlciBpc2EgQXNzaWduTGlzdFxuXHRcdFx0cmV0dXJuIG90aGVyXG5cdFx0ZWxzZVxuXHRcdFx0c3VwZXIob3RoZXIpXG5cdFx0IyBuZWVkIHRvIHN0b3JlIGluZGVudGVkIGNvbnRlbnQgYXMgd2VsbD9cblx0XHQjIEBub2RlcyA9IG5vZGVzLmNvbmNhdChvdGhlciBpc2EgQXJyYXkgPyBvdGhlciA6IG90aGVyLm5vZGVzKVxuXHRcdHNlbGZcblxuXG5leHBvcnQgY2xhc3MgQmxvY2sgPCBMaXN0Tm9kZVx0XG5cdFxuXHRwcm9wIGhlYWRcblxuXHRkZWYgaW5pdGlhbGl6ZSBsaXN0XG5cdFx0c2V0dXBcblx0XHQjIEBub2RlcyA9IGNvbXBhY3RfXyhmbGF0dGVuX18obGlzdCkpIG9yIFtdXG5cdFx0QG5vZGVzID0gbGlzdCBvciBbXVxuXHRcdEBoZWFkID0gbnVsbFxuXHRcdEBpbmRlbnRhdGlvbiA9IG51bGxcblxuXHRkZWYgc2VsZi53cmFwIGFyeVxuXHRcdHVubGVzcyBhcnkgaXNhIEFycmF5XG5cdFx0XHR0aHJvdyBTeW50YXhFcnJvci5uZXcoXCJ3aGF0XCIpXG5cdFx0YXJ5Omxlbmd0aCA9PSAxICYmIGFyeVswXSBpc2EgQmxvY2sgPyBhcnlbMF0gOiBCbG9jay5uZXcoYXJ5KVxuXG5cdGRlZiB2aXNpdFxuXHRcdEBzY29wZS52aXNpdCBpZiBAc2NvcGVcblxuXHRcdGZvciBub2RlLGkgaW4gQG5vZGVzXG5cdFx0XHRub2RlIGFuZCBub2RlLnRyYXZlcnNlXG5cdFx0c2VsZlxuXG5cdGRlZiBibG9ja1xuXHRcdHNlbGZcblxuXHQjIGRlZiBpbmRlbnRlZCBhLGJcblx0IyBcdEBpbmRlbnRhdGlvbiB8fD0gYSBhbmQgYiA/IEluZGVudGF0aW9uLm5ldyhhLGIpIDogSU5ERU5UXG5cdCMgXHRzZWxmXG5cblx0ZGVmIGxvY1xuXHRcdCMgcmF0aGVyIGluZGVudHMsIG5vP1xuXHRcdGlmIHZhciBvcHQgPSBvcHRpb24oOmVuZHMpXG5cdFx0XHQjIHAgXCJsb2NhdGlvbiBpc1wiLG9wdFxuXHRcdFx0dmFyIGEgPSBvcHRbMF0ubG9jXG5cdFx0XHR2YXIgYiA9IG9wdFsxXS5sb2NcblxuXHRcdFx0cCBcIm5vIGxvYyBmb3Ige29wdFswXX1cIiB1bmxlc3MgYVxuXHRcdFx0cCBcIm5vIGxvYyBmb3Ige29wdFsxXX1cIiB1bmxlc3MgYlxuXG5cdFx0XHRbYVswXSxiWzFdXVxuXHRcdGVsaWYgdmFyIGluZCA9IEBpbmRlbnRhdGlvblxuXHRcdFx0W2luZC5hbG9jLGluZC5ibG9jXVxuXHRcdGVsc2Vcblx0XHRcdFswLDBdXG5cblx0IyBnbyB0aHJvdWdoIGNoaWxkcmVuIGFuZCB1bndyYXAgaW5uZXIgbm9kZXNcblx0ZGVmIHVud3JhcFxuXHRcdHZhciBhcnkgPSBbXVxuXHRcdGZvciBub2RlLGkgaW4gbm9kZXNcblx0XHRcdGlmIG5vZGUgaXNhIEJsb2NrXG5cdFx0XHRcdCMgcCBcInVud3JhcHBpbmcgaW5uZXIgYmxvY2tcIlxuXHRcdFx0XHRhcnk6cHVzaC5hcHBseShhcnksbm9kZS51bndyYXApXG5cdFx0XHRlbHNlXG5cdFx0XHRcdGFyeS5wdXNoKG5vZGUpXG5cdFx0cmV0dXJuIGFyeVxuXG5cdGRlZiBwdXNoIGl0ZW1cblx0XHRAbm9kZXMucHVzaChpdGVtKVxuXHRcdHNlbGZcblxuXHRkZWYgYWRkIGl0ZW1cblx0XHRAbm9kZXMucHVzaChpdGVtKVxuXHRcdHNlbGZcblxuXHQjIFRoaXMgaXMganVzdCB0byB3b3JrIGFzIGFuIGlucGxhY2UgcmVwbGFjZW1lbnQgb2Ygbm9kZXMuY29mZmVlXG5cdCMgQWZ0ZXIgdGhpbmdzIGFyZSB3b3JraW5nIG9rYXkgd2UnbGwgZG8gYmlnZ2VyIHJlZmFjdG9yaW5nc1xuXHRkZWYgY29tcGlsZSBvID0ge31cblx0XHR2YXIgcm9vdCA9IFJvb3QubmV3KHNlbGYsbylcblx0XHRyb290LmNvbXBpbGUobylcblxuXG5cdCMgTm90IHN1cmUgaWYgd2Ugc2hvdWxkIGNyZWF0ZSBhIHNlcGFyYXRlIGJsb2NrP1xuXHRkZWYgYW5hbHl6ZSBvID0ge31cblx0XHQjIHAgXCJhbmFseXppbmcgYmxvY2shISFcIixvXG5cdFx0c2VsZlxuXG5cdGRlZiBjcGFydCBub2RlXG5cdFx0dmFyIG91dCA9IHR5cGVvZiBub2RlID09ICdzdHJpbmcnID8gbm9kZSA6IChub2RlID8gbm9kZS5jIDogXCJcIilcblx0XHRyZXR1cm4gXCJcIiBpZiBvdXQgPT0gbnVsbCBvciBvdXQgPT0gdW5kZWZpbmVkIG9yIG91dCA9PSBcIlwiXG5cblx0XHRpZiBvdXQgaXNhIEFycmF5XG5cdFx0XHR2YXIgc3RyID0gXCJcIlxuXHRcdFx0dmFyIGwgPSBvdXQ6bGVuZ3RoXG5cdFx0XHR2YXIgaSA9IDBcblx0XHRcdHdoaWxlIGkgPCBsXG5cdFx0XHRcdHN0ciArPSBjcGFydChvdXRbaSsrXSlcblx0XHRcdHJldHVybiBzdHJcblxuXHRcdHZhciBoYXNTZW1pQ29sb24gPSBTRU1JQ09MT05fVEVTVC50ZXN0KG91dClcblx0XHRvdXQgKz0gXCI7XCIgdW5sZXNzIGhhc1NlbWlDb2xvbiBvciBub2RlIGlzYSBNZXRhXG5cdFx0cmV0dXJuIG91dFxuXG5cdGRlZiBqcyBvLCBvcHRzXG5cdFx0dmFyIGFzdCA9IEBub2Rlc1xuXHRcdHZhciBsID0gYXN0Omxlbmd0aFxuXHRcdCMgcmVhbGx5P1xuXHRcdHZhciBleHByZXNzID0gaXNFeHByZXNzaW9uIG9yIG8uaXNFeHByZXNzaW9uIG9yIChvcHRpb24oOmV4cHJlc3MpIGFuZCBpc0V4cHJlc3NhYmxlKVxuXHRcdHJldHVybiAnJyBpZiBhc3Q6bGVuZ3RoID09IDBcblxuXHRcdGlmIGV4cHJlc3Ncblx0XHRcdHJldHVybiBzdXBlcihvLG5vZGVzOiBhc3QpXG5cblx0XHR2YXIgc3RyID0gXCJcIlxuXHRcdGZvciB2IGluIGFzdFxuXHRcdFx0c3RyICs9IGNwYXJ0KHYpXG5cblx0XHQjIG5vdyBhZGQgdGhlIGhlYWQgaXRlbXMgYXMgd2VsbFxuXHRcdGlmIEBoZWFkIGFuZCBAaGVhZDpsZW5ndGggPiAwXG5cdFx0XHR2YXIgcHJlZml4ID0gXCJcIlxuXHRcdFx0Zm9yIHYgaW4gQGhlYWRcblx0XHRcdFx0dmFyIGh2ID0gY3BhcnQodilcblx0XHRcdFx0cHJlZml4ICs9IGh2ICsgJ1xcbicgaWYgaHZcblx0XHRcdHN0ciA9IHByZWZpeCArIHN0clxuXHRcdHJldHVybiBzdHJcblxuXG5cdCMgU2hvdWxkIHRoaXMgY3JlYXRlIHRoZSBmdW5jdGlvbiBhcyB3ZWxsP1xuXHRkZWYgZGVmZXJzIG9yaWdpbmFsLCByZXBsYWNlbWVudFxuXHRcdHZhciBpZHggPSBAbm9kZXMuaW5kZXhPZihvcmlnaW5hbClcblx0XHRAbm9kZXNbaWR4XSA9IHJlcGxhY2VtZW50IGlmIGlkeCA+PSAwXG5cdFx0dmFyIHJlc3QgPSBAbm9kZXMuc3BsaWNlKGlkeCArIDEpXG5cdFx0cmV0dXJuIHJlc3RcblxuXHRkZWYgZXhwcmVzc2lvbnNcblx0XHR2YXIgZXhwcmVzc2lvbnMgPSBbXVxuXHRcdGZvciBub2RlIGluIG5vZGVzXG5cdFx0XHRleHByZXNzaW9ucy5wdXNoKG5vZGUpIHVubGVzcyBub2RlIGlzYSBUZXJtaW5hdG9yXG5cdFx0cmV0dXJuIGV4cHJlc3Npb25zXG5cdFx0XG5cblx0ZGVmIGNvbnN1bWUgbm9kZVxuXHRcdGlmIG5vZGUgaXNhIFRhZ1RyZWUgIyBzcGVjaWFsIGNhc2U/IT9cblx0XHRcdEBub2RlcyA9IEBub2Rlcy5tYXAgZG8gfGNoaWxkfFxuXHRcdFx0XHRjaGlsZC5jb25zdW1lKG5vZGUpXG5cblx0XHRcdGxldCByZWFsID0gZXhwcmVzc2lvbnNcblx0XHRcdCMgRklYTUUgc2hvdWxkIG5vdCBpbmNsdWRlIHRlcm1pbmF0b3JzIGFuZCBjb21tZW50cyB3aGVuIGNvdW50aW5nXG5cdFx0XHQjIHNob3VsZCBvbmx5IHdyYXAgdGhlIGNvbnRlbnQgaW4gYXJyYXkgKHJldHVybmluZyBhbGwgcGFydHMpXG5cdFx0XHQjIGZvciBpZi9lbHNlIGJsb2NrcyAtLSBub3QgbG9vcHNcblxuXHRcdFx0IyB3ZSBuZWVkIHRvIGNvbXBhcmUgdGhlIHJlYWwgbGVuZ3RoXG5cdFx0XHRpZiAhbm9kZS5AbG9vcCAmJiByZWFsOmxlbmd0aCA+IDFcblx0XHRcdFx0IyBwIFwibGVuZ3Roc1wiLEBub2RlczpsZW5ndGgsZXhwcmVzc2lvbnM6bGVuZ3RoXG5cdFx0XHRcdGxldCBuciA9IG5vZGUuYmxvY2tzLnB1c2goc2VsZilcblx0XHRcdFx0dmFyIGFyciA9IEFyci5uZXcoQXJnTGlzdC5uZXcoIEBub2RlcyApKVxuXHRcdFx0XHRhcnIuaW5kZW50ZWQoQGluZGVudGF0aW9uKVxuXHRcdFx0XHRAaW5kZW50YXRpb24gPSBudWxsXG5cblx0XHRcdFx0aWYgbm9kZS5yZWFjdGl2ZVxuXHRcdFx0XHRcdEBub2RlcyA9IFtVdGlsLmNhbGxJbWJhKFwic3RhdGljXCIsW2FycixOdW0ubmV3KG5yKV0pXVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0QG5vZGVzID0gW2Fycl1cblxuXHRcdFx0XG5cdFx0XG5cdFx0XHRyZXR1cm4gc2VsZlxuXG5cdFx0IyBjYW4gYWxzbyByZXR1cm4gc3VwZXIgaWYgaXQgaXMgZXhwcmVzc2FibGUsIGJ1dCBzaG91bGQgd2UgcmVhbGx5P1xuXHRcdGlmIHZhciBiZWZvcmUgPSBsYXN0XG5cdFx0XHR2YXIgYWZ0ZXIgPSBiZWZvcmUuY29uc3VtZShub2RlKVxuXHRcdFx0aWYgYWZ0ZXIgIT0gYmVmb3JlXG5cdFx0XHRcdCMgcCBcInJlcGxhY2Ugbm9kZSBpbiBibG9jayB7YmVmb3JlfSAtPiB7YWZ0ZXJ9XCJcblx0XHRcdFx0aWYgYWZ0ZXIgaXNhIEJsb2NrXG5cdFx0XHRcdFx0IyBwIFwicmVwbGFjZWQgd2l0aCBibG9jayAtLSBzaG91bGQgYmFzaWNhbGx5IGFkZCBpdCBpbnN0ZWFkP1wiXG5cdFx0XHRcdFx0YWZ0ZXIgPSBhZnRlci5ub2Rlc1xuXG5cdFx0XHRcdHJlcGxhY2UoYmVmb3JlLGFmdGVyKVxuXHRcdCMgcmVhbGx5P1xuXHRcdHJldHVybiBzZWxmXG5cblxuXHRkZWYgaXNFeHByZXNzYWJsZVxuXHRcdHJldHVybiBubyB1bmxlc3MgQG5vZGVzLmV2ZXJ5KHx2fCB2LmlzRXhwcmVzc2FibGUgKVxuXHRcdHJldHVybiB5ZXNcblxuXHRkZWYgaXNFeHByZXNzaW9uXG5cdFxuXHRcdG9wdGlvbig6ZXhwcmVzcykgfHwgQGV4cHJlc3Npb25cblxuXG4jIHRoaXMgaXMgYWxtb3N0IGxpa2UgdGhlIG9sZCBWYXJEZWNsYXJhdGlvbnMgYnV0IHdpdGhvdXQgdGhlIHZhbHVlc1xuZXhwb3J0IGNsYXNzIFZhckJsb2NrIDwgTGlzdE5vZGVcblxuXG5cdGRlZiBsb2FkIGxpc3Rcblx0XHR2YXIgZmlyc3QgPSBsaXN0WzBdXG5cblx0XHRpZiBmaXJzdCBpc2EgQXNzaWduXG5cdFx0XHRAdHlwZSA9IGZpcnN0LmxlZnQuQHR5cGVcblx0XHRlbGlmIGZpcnN0IGlzYSBWYXJSZWZlcmVuY2Vcblx0XHRcdEB0eXBlID0gZmlyc3QuQHR5cGVcblx0XHQjIHAgXCJoZXJlIHtsaXN0WzBdfSAtIHtAdHlwZX1cIlxuXHRcdCMgQHR5cGUgPSBsaXN0WzBdIGFuZCBsaXN0WzBdLnR5cGVcblx0XHRsaXN0XG5cdFx0XG5cdCMgVE9ETyBBbGwgdGhlc2UgaW5uZXIgaXRlbXMgc2hvdWxkIHJhdGhlciBiZSBzdHJhaWdodCB1cCBsaXRlcmFsc1xuXHQjIG9yIGJhc2ljIGxvY2FsdmFycyAtIHdpdGhvdXQgYW55IGNhcmUgd2hhdHNvZXZlciBhYm91dCBhZGRpbmcgdmFyIHRvIHRoZVxuXHQjIGJlZ2lubmluZyBldGMuIFxuXHRkZWYgYWRkRXhwcmVzc2lvbiBleHByXG5cdFx0IyBwIFwiVmFyQmxvY2suYWRkRXhwcmVzc2lvbiB7c2VsZn0gPC0ge2V4cHJ9XCJcblxuXHRcdGlmIGV4cHIgaXNhIEFzc2lnblxuXHRcdFx0IyBtYWtlIHN1cmUgdGhlIGxlZnQtc2lkZSBpcyBhIHZhci1yZWZlcmVuY2Vcblx0XHRcdCMgdGhpcyBzaG91bGQgYmUgYSBkaWZmZXJlbnQgdHlwZSBvZiBhc3NpZ24sIG5vP1xuXHRcdFx0aWYgZXhwci5sZWZ0IGlzYSBWYXJPckFjY2Vzc1xuXHRcdFx0XHRleHByLmxlZnQgPSBWYXJSZWZlcmVuY2UubmV3KGV4cHIubGVmdC52YWx1ZSxAdHlwZSlcblxuXHRcdFx0cHVzaChleHByKVxuXG5cdFx0ZWxpZiBleHByIGlzYSBBc3NpZ25cblx0XHRcdGFkZEV4cHJlc3Npb24oZXhwci5sZWZ0KSAjIG1ha2Ugc3VyZSB0aGlzIGlzIGEgdmFsaWQgdGhpbmc/XG5cdFx0XHQjIG1ha2UgdGhpcyBpbnRvIGEgdHVwbGUgaW5zdGVhZFxuXHRcdFx0IyBkb2VzIG5vdCBuZWVkIHRvIGJlIGEgdHVwbGU/XG5cdFx0XHRyZXR1cm4gVHVwbGVBc3NpZ24ubmV3KCc9JyxUdXBsZS5uZXcobm9kZXMpLGV4cHIucmlnaHQpXG5cblx0XHRlbGlmIGV4cHIgaXNhIFZhck9yQWNjZXNzXG5cdFx0XHQjIHRoaXMgaXMgcmVhbGx5IGEgVmFyUmVmZXJlbmNlXG5cdFx0XHRwdXNoKFZhclJlZmVyZW5jZS5uZXcoZXhwci52YWx1ZSxAdHlwZSkpXG5cblx0XHRlbGlmIGV4cHIgaXNhIFNwbGF0ICYmIGV4cHIubm9kZSBpc2EgVmFyT3JBY2Nlc3Ncblx0XHRcdCMgcCBcImlzIGEgc3BsYXQgLSBvbmx5IGFsbG93ZWQgaW4gdHVwbGUtYXNzaWdubWVudFwiXG5cdFx0XHQjIHdoYXQ/XG5cdFx0XHRleHByLnZhbHVlID0gVmFyUmVmZXJlbmNlLm5ldyhleHByLm5vZGUudmFsdWUsQHR5cGUpXG5cdFx0XHRwdXNoKGV4cHIpXG5cdFx0ZWxzZVxuXHRcdFx0cCBcIlZhckJsb2NrLmFkZEV4cHJlc3Npb24ge3NlbGZ9IDwtIHtleHByfVwiXG5cdFx0XHR0aHJvdyBcIlZhckJsb2NrIGRvZXMgbm90IGFsbG93IG5vbi12YXJpYWJsZSBleHByZXNzaW9uc1wiXG5cdFx0c2VsZlxuXG5cblx0ZGVmIGlzRXhwcmVzc2FibGVcblx0XHQjIHdlIHdvdWxkIG5lZWQgdG8gZm9yY2UtZHJvcCB0aGUgdmFyaWFibGVzLCBtYWtlcyBsaXR0bGUgc2Vuc2Vcblx0XHQjIGJ1dCwgaXQgY291bGQgYmUsIGNvdWxkIGp1c3QgcHVzaCB0aGUgdmFyaWFibGVzIG91dD9cblx0XHRub1xuXG5cdGRlZiBqcyBvXG5cdFx0IyBwIFwiVmFyQmxvY2tcIlxuXHRcdCMgZm9yIG4gaW4gQG5vZGVzXG5cdFx0IyBcdHAgXCJWYXJCbG9jayBjaGlsZCB7bn1cIlxuXHRcdHZhciBjb2RlID0gY29tcGFjdF9fKGZsYXR0ZW5fXyhjYXJ5X18obm9kZXMpKSlcblx0XHRjb2RlID0gY29kZS5maWx0ZXIofG58IG4gIT0gbnVsbCAmJiBuICE9IHVuZGVmaW5lZCAmJiBuICE9IEVNUFRZKVxuXHRcdHZhciBvdXQgPSBjb2RlLmpvaW4oXCIsXCIpXG5cdFx0IyB3ZSBqdXN0IG5lZWQgdG8gdHJ1c3QgdGhhdCB0aGUgdmFyaWFibGVzIGhhdmUgYmVlbiBhdXRvZGVjbGFyZWQgYmVmb3JlaGFuZFxuXHRcdCMgaWYgd2UgYXJlIGluc2lkZSBhbiBleHByZXNzaW9uXG5cdFx0b3V0ID0gXCJ2YXIgXCIgKyBvdXQgdW5sZXNzIG8uaXNFeHByZXNzaW9uXG5cdFx0cmV0dXJuIG91dFxuXG5cblx0ZGVmIGNvbnN1bWUgbm9kZVxuXHRcdCMgSXQgZG9lc250IG1ha2UgbXVjaCBzZW5zZSBmb3IgYSBWYXJCbG9jayB0byBjb25zdW1lIGFueXRoaW5nXG5cdFx0IyBpdCBzaG91bGQgcHJvYmFibHkgcmV0dXJuIHZvaWQgZm9yIG1ldGhvZHNcblx0XHRyZXR1cm4gc2VsZlxuXG5cbiMgQ291bGQgaW5oZXJpdCBmcm9tIHZhbHVlTm9kZVxuZXhwb3J0IGNsYXNzIFBhcmVucyA8IFZhbHVlTm9kZVxuXG5cdGRlZiBpbml0aWFsaXplIHZhbHVlLCBvcGVuLCBjbG9zZVxuXHRcdHNldHVwXG5cdFx0QG9wZW4gPSBvcGVuXG5cdFx0QGNsb3NlID0gY2xvc2Vcblx0XHRAdmFsdWUgPSBsb2FkKHZhbHVlKVxuXHRcblx0ZGVmIGxvYWQgdmFsdWVcblx0XHRAbm9wYXJlbiA9IG5vXG5cdFx0dmFsdWUgaXNhIEJsb2NrIGFuZCB2YWx1ZS5jb3VudCA9PSAxID8gdmFsdWUuZmlyc3QgOiB2YWx1ZVxuXG5cdGRlZiBpc1N0cmluZ1xuXHRcdCMgY2hlY2tpbmcgaWYgdGhpcyBpcyBhbiBpbnRlcnBvbGF0ZWQgc3RyaW5nXG5cdFx0QG9wZW4gYW5kIFN0cmluZyhAb3BlbikgPT0gJyhcIicgb3IgdmFsdWUuaXNTdHJpbmdcblx0XHRcblx0ZGVmIGpzIG9cblxuXHRcdHZhciBwYXIgPSB1cFxuXHRcdHZhciB2ID0gQHZhbHVlXG5cdFx0dmFyIHN0ciA9IG51bGxcblxuXHRcdEBub3BhcmVuID0geWVzIGlmIHYgaXNhIEZ1bmNcblx0XHQjIHAgXCJjb21waWxlIHBhcmVucyB7dn0ge3YgaXNhIEJsb2NrIGFuZCB2LmNvdW50fVwiXG5cdFx0IyBwIFwiUGFyZW5zIHVwIHtwYXJ9IHtvLmlzRXhwcmVzc2lvbn1cIlxuXHRcdGlmIHBhciBpc2EgQmxvY2tcblx0XHRcdCMgaXMgaXQgd29ydGggaXQ/XG5cdFx0XHRAbm9wYXJlbiA9IHllcyB1bmxlc3Mgby5pc0V4cHJlc3Npb25cblx0XHRcdHN0ciA9IHYgaXNhIEFycmF5ID8gY2FyeV9fKHYpIDogdi5jKGV4cHJlc3Npb246IG8uaXNFeHByZXNzaW9uKVxuXHRcdGVsc2Vcblx0XHRcdHN0ciA9IHYgaXNhIEFycmF5ID8gY2FyeV9fKHYpIDogdi5jKGV4cHJlc3Npb246IHllcylcblxuXHRcdCMgY2hlY2sgaWYgd2UgcmVhbGx5IG5lZWQgcGFyZW5zIGhlcmU/XG5cdFx0cmV0dXJuIHN0clxuXG5cdGRlZiBzZXQgb2JqXG5cdFx0Y29uc29sZS5sb2cgXCJQYXJlbnMgc2V0IHtKU09OLnN0cmluZ2lmeShvYmopfVwiXG5cdFx0c3VwZXIob2JqKVxuXHRcdFxuXG5cdGRlZiBzaG91bGRQYXJlbnRoZXNpemVcblx0XHQjIG5vIG5lZWQgdG8gcGFyZW50aGVzaXplIGlmIHRoaXMgaXMgYSBsaW5lIGluIGEgYmxvY2tcblx0XHRyZXR1cm4gbm8gaWYgQG5vcGFyZW4gIyAgb3IgcGFyIGlzYSBBcmdMaXN0XG5cdFx0cmV0dXJuIHllc1xuXG5cblx0ZGVmIHByZWJyZWFrIGJyXG5cdFx0c3VwZXIoYnIpXG5cdFx0Y29uc29sZS5sb2cgXCJQUkVCUkVBS1wiXG5cdFx0QHZhbHVlLnByZWJyZWFrKGJyKSBpZiBAdmFsdWVcblx0XHRzZWxmXG5cblxuXHRkZWYgaXNFeHByZXNzYWJsZVxuXHRcdEB2YWx1ZS5pc0V4cHJlc3NhYmxlXG5cblx0ZGVmIGNvbnN1bWUgbm9kZVxuXHRcdEB2YWx1ZS5jb25zdW1lKG5vZGUpXG5cblxuIyBDb3VsZCBpbmhlcml0IGZyb20gdmFsdWVOb2RlXG4jIGFuIGV4cGxpY2l0IGV4cHJlc3Npb24tYmxvY2sgKHdpdGggcGFyZW5zKSBpcyBzb21ld2hhdCBkaWZmZXJlbnRcbiMgY2FuIGJlIHVzZWQgdG8gcmV0dXJuIGFmdGVyIGFuIGV4cHJlc3Npb25cbmV4cG9ydCBjbGFzcyBFeHByZXNzaW9uQmxvY2sgPCBMaXN0Tm9kZVxuXG5cblx0ZGVmIGNcblx0XHRtYXAofGl0ZW18IGl0ZW0uYykuam9pbihcIixcIilcblxuXHRkZWYgY29uc3VtZSBub2RlXG5cdFx0dmFsdWUuY29uc3VtZShub2RlKVxuXG5cdGRlZiBhZGRFeHByZXNzaW9uIGV4cHJcblx0XHQjIE5lZWQgdG8gdGFrZSBjYXJlIG9mIHRoZSBzcGxhdCBoZXJlIHRvLi4gaGF6emxlXG5cdFx0aWYgZXhwci5ub2RlIGlzYSBBc3NpZ25cblx0XHRcdCMgcCBcImlzIGFzc2lnbm1lbnQhXCJcblx0XHRcdHB1c2goZXhwci5sZWZ0KVxuXHRcdFx0IyBtYWtlIHRoaXMgaW50byBhIHR1cGxlIGluc3RlYWRcblx0XHRcdCMgcG9zc2libHkgZml4IHRoaXMgYXMgd2VsbD8hP1xuXHRcdFx0cmV0dXJuIFR1cGxlQXNzaWduLm5ldygnPScsVHVwbGUubmV3KG5vZGVzKSxleHByLnJpZ2h0KVxuXHRcdGVsc2Vcblx0XHRcdHB1c2goZXhwcilcblx0XHRzZWxmXG5cblxuXG4jIFNUQVRFTUVOVFNcblxuZXhwb3J0IGNsYXNzIFJldHVybiA8IFN0YXRlbWVudFxuXG5cdHByb3AgdmFsdWVcblxuXHRkZWYgaW5pdGlhbGl6ZSB2XG5cdFx0QHRyYXZlcnNlZCA9IG5vXG5cdFx0QHZhbHVlID0gdiBpc2EgQXJnTGlzdCBhbmQgdi5jb3VudCA9PSAxID8gdi5sYXN0IDogdlxuXHRcdCMgQHByZWJyZWFrID0gdiBhbmQgdi5AcHJlYnJlYWtcblx0XHQjIGNvbnNvbGUubG9nIFwicmV0dXJuPyE/IHt2fVwiLEBwcmVicmVha1xuXHRcdCMgaWYgdiBpc2EgQXJnTGlzdCBhbmQgdi5jb3VudCA9PSAxXG5cdFx0cmV0dXJuIHNlbGZcblxuXHRkZWYgdmlzaXRcblx0XHRAdmFsdWUudHJhdmVyc2UgaWYgQHZhbHVlICYmIEB2YWx1ZTp0cmF2ZXJzZVxuXG5cdGRlZiBqcyBvXG5cdFx0dmFyIHYgPSBAdmFsdWVcblxuXHRcdGlmIHYgaXNhIEFyZ0xpc3Rcblx0XHRcdHJldHVybiBcInJldHVybiBbe3YuYyhleHByZXNzaW9uOiB5ZXMpfV1cIlxuXHRcdGVsaWYgdlxuXHRcdFx0cmV0dXJuIFwicmV0dXJuIHt2LmMoZXhwcmVzc2lvbjogeWVzKX1cIlxuXHRcdGVsc2Vcblx0XHRcdFwicmV0dXJuXCJcblxuXHRkZWYgY1xuXHRcdHJldHVybiBzdXBlciBpZiAhdmFsdWUgb3IgdmFsdWUuaXNFeHByZXNzYWJsZVxuXHRcdCMgcCBcInJldHVybiBtdXN0IGNhc2NhZGUgaW50byB2YWx1ZVwiLnJlZFxuXHRcdHZhbHVlLmNvbnN1bWUoc2VsZikuY1xuXG5cdGRlZiBjb25zdW1lIG5vZGVcblx0XHRyZXR1cm4gc2VsZlxuXG5leHBvcnQgY2xhc3MgSW1wbGljaXRSZXR1cm4gPCBSZXR1cm5cblxuZXhwb3J0IGNsYXNzIEdyZWVkeVJldHVybiA8IEltcGxpY2l0UmV0dXJuXG5cbiMgY2Fubm90IGxpdmUgaW5zaWRlIGFuIGV4cHJlc3Npb24oISlcbmV4cG9ydCBjbGFzcyBUaHJvdyA8IFN0YXRlbWVudFxuXG5cdGRlZiBqcyBvXG5cdFx0XCJ0aHJvdyB7dmFsdWUuY31cIlxuXG5cdGRlZiBjb25zdW1lIG5vZGVcblx0XHQjIFJPQURNQVAgc2hvdWxkIHBvc3NpYmx5IGNvbnN1bWUgdG8gdGhlIHZhbHVlIG9mIHRocm93IGFuZCB0aGVuIHRocm93P1xuXHRcdHJldHVybiBzZWxmXG5cdFx0XG5cbmV4cG9ydCBjbGFzcyBMb29wRmxvd1N0YXRlbWVudCA8IFN0YXRlbWVudFxuXG5cdHByb3AgbGl0ZXJhbFxuXHRwcm9wIGV4cHJlc3Npb25cblxuXHRkZWYgaW5pdGlhbGl6ZSBsaXQsIGV4cHJcblx0XHRzZWxmLmxpdGVyYWwgPSBsaXRcblx0XHRzZWxmLmV4cHJlc3Npb24gPSBleHByICMgJiYgQXJnTGlzdC5uZXcoZXhwcikgIyByZWFsbHk/XG5cblx0ZGVmIHZpc2l0XG5cdFx0ZXhwcmVzc2lvbi50cmF2ZXJzZSBpZiBleHByZXNzaW9uXG5cblx0ZGVmIGNvbnN1bWUgbm9kZVxuXHRcdCMgcCBcImJyZWFrL2NvbnRpbnVlIHNob3VsZCBjb25zdW1lPyFcIlxuXHRcdHNlbGZcblxuXHRkZWYgY1xuXHRcdHJldHVybiBzdXBlciB1bmxlc3MgZXhwcmVzc2lvblxuXHRcdCMgZ2V0IHVwIHRvIHRoZSBvdXRlciBsb29wXG5cdFx0dmFyIF9sb29wID0gU1RBQ0sudXAoTG9vcClcblx0XHQjIHAgXCJmb3VuZCBsb29wP1wiLF9sb29wXG5cblx0XHQjIG5lZWQgdG8gZml4IHRoZSBncmFtbWFyIGZvciB0aGlzLiBSaWdodCBub3cgaXQgXG5cdFx0IyBpcyBsaWtlIGEgZmFrZSBjYWxsLCBidXQgc2hvdWxkIG9ubHkgY2FyZSBhYm91dCB0aGUgZmlyc3QgYXJndW1lbnRcblx0XHR2YXIgZXhwciA9IHNlbGYuZXhwcmVzc2lvblxuXG5cdFx0aWYgX2xvb3AuY2F0Y2hlclxuXHRcdFx0ZXhwciA9IGV4cHIuY29uc3VtZShfbG9vcC5jYXRjaGVyKVxuXHRcdFx0dmFyIGNvcHkgPSBzZWxmOmNvbnN0cnVjdG9yLm5ldyhsaXRlcmFsKVxuXHRcdFx0QmxvY2submV3KFtleHByLGNvcHldKS5jXG5cdFx0ZWxpZiBleHByXG5cdFx0XHR2YXIgY29weSA9IHNlbGY6Y29uc3RydWN0b3IubmV3KGxpdGVyYWwpXG5cdFx0XHRCbG9jay5uZXcoW2V4cHIsY29weV0pLmNcblx0XHRlbHNlXG5cdFx0XHRzdXBlclxuXHRcdCMgcmV0dXJuIFwibG9vcGZsb3dcIlxuXHRcdFxuXG5leHBvcnQgY2xhc3MgQnJlYWtTdGF0ZW1lbnQgPCBMb29wRmxvd1N0YXRlbWVudFxuXHRkZWYganMgbyBkbyBcImJyZWFrXCJcblxuZXhwb3J0IGNsYXNzIENvbnRpbnVlU3RhdGVtZW50IDwgTG9vcEZsb3dTdGF0ZW1lbnRcblx0ZGVmIGpzIG8gZG8gXCJjb250aW51ZVwiXG5cbmV4cG9ydCBjbGFzcyBEZWJ1Z2dlclN0YXRlbWVudCA8IFN0YXRlbWVudFxuXG5cbiMgUEFSQU1TXG5cbmV4cG9ydCBjbGFzcyBQYXJhbSA8IE5vZGVcblxuXHRwcm9wIG5hbWVcblx0cHJvcCBpbmRleFxuXHRwcm9wIGRlZmF1bHRzXG5cdHByb3Agc3BsYXRcblx0cHJvcCB2YXJpYWJsZVxuXG5cdCMgd2hhdCBhYm91dCBvYmplY3QtcGFyYW1zP1xuXG5cdGRlZiBpbml0aWFsaXplIG5hbWUsIGRlZmF1bHRzLCB0eXBcblx0XHQjIGNvdWxkIGhhdmUgaW50cm9kdWNlZCBidWdzIGJ5IG1vdmluZyBiYWNrIHRvIGlkZW50aWZpZXIgaGVyZVxuXHRcdEB0cmF2ZXJzZWQgPSBub1xuXHRcdEBuYW1lID0gbmFtZSAjIC52YWx1ZSAjIHRoaXMgaXMgYW4gaWRlbnRpZmllcighKVxuXHRcdEBkZWZhdWx0cyA9IGRlZmF1bHRzXG5cdFx0QHR5cCA9IHR5cFxuXHRcdEB2YXJpYWJsZSA9IG51bGxcblxuXHRkZWYgdmFybmFtZVxuXHRcdEB2YXJpYWJsZSA/IEB2YXJpYWJsZS5jIDogbmFtZVxuXG5cdGRlZiBqcyBvXG5cdFx0cmV0dXJuIEB2YXJpYWJsZS5jIGlmIEB2YXJpYWJsZVxuXG5cdFx0aWYgZGVmYXVsdHNcblx0XHRcdCMgc2hvdWxkIG5vdCBpbmNsdWRlIGFueSBzb3VyY2UtbWFwcGluZyBoZXJlP1xuXHRcdFx0XCJpZih7bmFtZS5jfSA9PSBudWxsKSB7bmFtZS5jfSA9IHtkZWZhdWx0cy5jfVwiXG5cdFx0IyBzZWUgaWYgdGhpcyBpcyB0aGUgaW5pdGlhbCBkZWNsYXJhdG9yP1xuXG5cdGRlZiB2aXNpdFxuXHRcdEBkZWZhdWx0cy50cmF2ZXJzZSBpZiBAZGVmYXVsdHNcblx0XHRzZWxmLnZhcmlhYmxlIHx8PSBzY29wZV9fLnJlZ2lzdGVyKG5hbWUsc2VsZilcblxuXHRcdGlmIEBuYW1lIGlzYSBJZGVudGlmaWVyXG5cdFx0XHQjIGNoYW5nZSB0eXBlIGhlcmU/XG5cdFx0XHRAbmFtZS5AdmFsdWUuQHR5cGUgPSBcIlBBUkFNVkFSXCIgaWYgQG5hbWUuQHZhbHVlXG5cdFx0XHRAbmFtZS5yZWZlcmVuY2VzKEB2YXJpYWJsZSlcblx0XHRcdCMgY29uc29sZS5sb2cgXCJnb3QgaGVyZSEhIHtAbmFtZTpjb25zdHJ1Y3Rvcn1cIlxuXHRcdFx0IyBAbmFtZS5AdG9rZW4uQHZhcmlhYmxlID0gQHZhcmlhYmxlIGlmIEBuYW1lLkB0b2tlblxuXHRcdFxuXHRcdHNlbGZcblxuXHRkZWYgYXNzaWdubWVudFxuXHRcdE9QKCc9Jyx2YXJpYWJsZS5hY2Nlc3NvcixkZWZhdWx0cylcblxuXHRkZWYgaXNFeHByZXNzYWJsZVxuXHRcdCFkZWZhdWx0cyB8fCBkZWZhdWx0cy5pc0V4cHJlc3NhYmxlXG5cdFx0IyBwIFwidmlzaXRpbmcgcGFyYW0hISFcIlxuXG5cdGRlZiBkdW1wXG5cdFx0e2xvYzogbG9jfVxuXG5cdGRlZiBsb2Ncblx0XHRAbmFtZSAmJiBAbmFtZS5yZWdpb25cblxuXHRkZWYgdG9KU09OXG5cdFx0e1xuXHRcdFx0dHlwZTogdHlwZU5hbWVcblx0XHRcdG5hbWU6IG5hbWVcblx0XHRcdGRlZmF1bHRzOiBkZWZhdWx0c1xuXHRcdH1cblx0XHRcblxuZXhwb3J0IGNsYXNzIFNwbGF0UGFyYW0gPCBQYXJhbVxuXG5cdGRlZiBsb2Ncblx0XHQjIGhhY2t5Li4gY2Fubm90IGtub3cgZm9yIHN1cmUgdGhhdCB0aGlzIGlzIHJpZ2h0P1xuXHRcdHZhciByID0gbmFtZS5yZWdpb25cblx0XHRbclswXSAtIDEsclsxXV1cblxuZXhwb3J0IGNsYXNzIEJsb2NrUGFyYW0gPCBQYXJhbVxuXG5cdGRlZiBjXG5cdFx0XCJibG9ja3BhcmFtXCJcblxuXHRkZWYgbG9jXG5cdFx0IyBoYWNreS4uIGNhbm5vdCBrbm93IGZvciBzdXJlIHRoYXQgdGhpcyBpcyByaWdodD9cblx0XHR2YXIgciA9IG5hbWUucmVnaW9uXG5cdFx0W3JbMF0gLSAxLHJbMV1dXG5cblxuZXhwb3J0IGNsYXNzIE9wdGlvbmFsUGFyYW0gPCBQYXJhbVxuXG5leHBvcnQgY2xhc3MgTmFtZWRQYXJhbSA8IFBhcmFtXG5cbmV4cG9ydCBjbGFzcyBSZXF1aXJlZFBhcmFtIDwgUGFyYW1cblxuZXhwb3J0IGNsYXNzIE5hbWVkUGFyYW1zIDwgTGlzdE5vZGVcblxuXHRwcm9wIGluZGV4XG5cdHByb3AgdmFyaWFibGVcblxuXHRkZWYgbG9hZCBsaXN0XG5cdFx0dmFyIGxvYWQgPSAofGt8IE5hbWVkUGFyYW0ubmV3KGsua2V5LGsudmFsdWUpIClcblx0XHRsaXN0IGlzYSBPYmogPyBsaXN0LnZhbHVlLm1hcChsb2FkKSA6IGxpc3RcblxuXHRkZWYgdmlzaXRcblx0XHR2YXIgcyA9IHNjb3BlX19cblx0XHRAdmFyaWFibGUgfHw9IHMudGVtcG9yYXJ5KHNlbGYsIHBvb2w6ICdrZXlwYXJzJylcblx0XHRAdmFyaWFibGUucHJlZGVjbGFyZWRcblxuXHRcdCMgdGhpcyBpcyBhIGxpc3Rub2RlLCB3aGljaCB3aWxsIGF1dG9tYXRpY2FsbHkgdHJhdmVyc2Vcblx0XHQjIGFuZCB2aXNpdCBhbGwgY2hpbGRyZW5cblx0XHRzdXBlclxuXHRcdCMgcmVnaXN0ZXIgdGhlIGlubmVyIHZhcmlhYmxlcyBhcyB3ZWxsKCEpXG5cdFx0c2VsZlxuXG5cblx0ZGVmIHZhcm5hbWVcblx0XHR2YXJpYWJsZS5jXG5cblx0ZGVmIG5hbWVcblx0XHR2YXJuYW1lXG5cblx0ZGVmIGpzIG9cblx0XHRcIm5hbWVkcGFyXCJcblxuXHRkZWYgdG9KU09OXG5cdFx0e1xuXHRcdFx0dHlwZTogdHlwZU5hbWVcblx0XHRcdG5vZGVzOiBmaWx0ZXIofHZ8IHYgaXNhIE5hbWVkUGFyYW0pXG5cdFx0fVxuXG5cbmV4cG9ydCBjbGFzcyBJbmRleGVkUGFyYW0gPCBQYXJhbVxuXG5cdHByb3AgcGFyZW50XG5cdHByb3Agc3ViaW5kZXhcblxuXHRkZWYgdmlzaXRcblx0XHQjIHAgXCJWSVNJVCBQQVJBTSB7bmFtZX0hXCJcblx0XHQjIGFyeS5bLTFdICMgcG9zc2libGVcblx0XHQjIGFyeS4oLTEpICMgcG9zc2libGVcblx0XHQjIHN0cigvb2svLC0xKVxuXHRcdCMgc2NvcGUucmVnaXN0ZXIoQG5hbWUsc2VsZilcblx0XHQjIEJVRyBUaGUgZGVmYXVsdHMgc2hvdWxkIHByb2JhYmx5IGJlIGxvb2tlZCB1cCBsaWtlIHZhcnNcblx0XHRzZWxmLnZhcmlhYmxlIHx8PSBzY29wZV9fLnJlZ2lzdGVyKG5hbWUsc2VsZilcblx0XHRzZWxmLnZhcmlhYmxlLnByb3h5KHBhcmVudC52YXJpYWJsZSxzdWJpbmRleClcblx0XHRzZWxmXG5cblxuZXhwb3J0IGNsYXNzIEFycmF5UGFyYW1zIDwgTGlzdE5vZGVcblxuXHRwcm9wIGluZGV4XG5cdHByb3AgdmFyaWFibGVcblxuXHRkZWYgdmlzaXRcblx0XHR2YXIgcyA9IHNjb3BlX19cblx0XHRAdmFyaWFibGUgfHw9IHMudGVtcG9yYXJ5KHNlbGYsIHBvb2w6ICdrZXlwYXJzJylcblx0XHRAdmFyaWFibGUucHJlZGVjbGFyZWRcblxuXHRcdCMgbm93IHdoZW4gd2UgbG9vcCB0aHJvdWdoIHRoZXNlIGlubmVyIHBhcmFtcyAtIHdlIGNyZWF0ZSB0aGUgcGFyc1xuXHRcdCMgd2l0aCB0aGUgY29ycmVjdCBuYW1lLCBidXQgYmluZCB0aGVtIHRvIHRoZSBwYXJlbnRcblx0XHRzdXBlclxuXG5cdGRlZiBuYW1lXG5cdFx0dmFyaWFibGUuY1xuXG5cdGRlZiBsb2FkIGxpc3Rcblx0XHRyZXR1cm4gbnVsbCB1bmxlc3MgbGlzdCBpc2EgQXJyXG5cdFx0IyBwIFwibG9hZGluZyBhcnJheXBhcmFtc1wiXG5cdFx0IyB0cnkgdGhlIGJhc2ljIGZpcnN0XG5cdFx0dW5sZXNzIGxpc3Quc3BsYXRcblx0XHRcdGxpc3QudmFsdWUubWFwIGRvIHx2LGl8XG5cdFx0XHRcdCMgbXVzdCBtYWtlIHN1cmUgdGhlIHBhcmFtcyBhcmUgc3VwcG9ydGVkIGhlcmVcblx0XHRcdFx0IyBzaG91bGQgcmVhbGx5IG5vdCBwYXJzZSBhbnkgYXJyYXkgYXQgYWxsKCEpXG5cdFx0XHRcdHZhciBuYW1lID0gdlxuXHRcdFx0XHRpZiB2IGlzYSBWYXJPckFjY2Vzc1xuXHRcdFx0XHRcdCMgcCBcInZhcm9yYWNjZXNzIHt2LnZhbHVlfVwiXG5cdFx0XHRcdFx0IyBGSVg/XG5cdFx0XHRcdFx0bmFtZSA9IHYudmFsdWUudmFsdWVcblx0XHRcdFx0XHQjIHRoaXMgaXMgYWNjZXB0ZWRcblx0XHRcdFx0cGFyc2UobmFtZSx2LGkpXG5cblx0ZGVmIHBhcnNlIG5hbWUsY2hpbGQsaVxuXHRcdHZhciBwYXJhbSA9IEluZGV4ZWRQYXJhbS5uZXcobmFtZSxudWxsKVxuXG5cdFx0cGFyYW0ucGFyZW50ID0gc2VsZlxuXHRcdHBhcmFtLnN1YmluZGV4ID0gaVxuXHRcdHBhcmFtXG5cblx0ZGVmIGhlYWQgYXN0XG5cdFx0IyBcImFycmF5cGFyYW1zXCJcblx0XHRzZWxmXG5cbmV4cG9ydCBjbGFzcyBQYXJhbUxpc3QgPCBMaXN0Tm9kZVxuXG5cdHByb3Agc3BsYXRcblx0cHJvcCBibG9ja1xuXG5cdGRlZiBhdCBpbmRleCwgZm9yY2UgPSBubywgbmFtZSA9IG51bGxcblx0XHRpZiBmb3JjZVxuXHRcdFx0YWRkKFBhcmFtLm5ldyhjb3VudCA9PSBpbmRleCAmJiBuYW1lIHx8IFwiX3tjb3VudH1cIikpIHVudGlsIGNvdW50ID4gaW5kZXhcblx0XHRcdCMgbmVlZCB0byB2aXNpdCBhdCB0aGUgc2FtZSB0aW1lLCBubz9cblx0XHRsaXN0W2luZGV4XVxuXG5cdGRlZiBtZXRhZGF0YVxuXHRcdGZpbHRlcih8cGFyfCAhKHBhciBpc2EgTWV0YSkpXG5cblx0ZGVmIHRvSlNPTlxuXHRcdG1ldGFkYXRhXG5cblx0ZGVmIHZpc2l0XG5cdFx0QHNwbGF0ID0gZmlsdGVyKHxwYXJ8IHBhciBpc2EgU3BsYXRQYXJhbSlbMF1cblx0XHR2YXIgYmxrID0gZmlsdGVyKHxwYXJ8IHBhciBpc2EgQmxvY2tQYXJhbSlcblxuXHRcdGlmIGJsazpsZW5ndGggPiAxXG5cdFx0XHRibGtbMV0ud2FybiBcImEgbWV0aG9kIGNhbiBvbmx5IGhhdmUgb25lICZibG9jayBwYXJhbWV0ZXJcIlxuXG5cdFx0ZWxpZiBibGtbMF0gJiYgYmxrWzBdICE9IGxhc3Rcblx0XHRcdGJsa1swXS53YXJuIFwiJmJsb2NrIG11c3QgYmUgdGhlIGxhc3QgcGFyYW1ldGVyIG9mIGEgbWV0aG9kXCJcblx0XHRcdCMgd2FybiBcIiZibG9jayBtdXN0IGJlIHRoZSBsYXN0IHBhcmFtZXRlciBvZiBhIG1ldGhvZFwiLCBibGtbMF1cblxuXHRcdCMgYWRkIG1vcmUgd2FybmluZ3MgbGF0ZXIoISlcblx0XHQjIHNob3VsZCBwcm9iYWJseSB0aHJvdyBlcnJvciBhcyB3ZWxsIHRvIHN0b3AgY29tcGlsYXRpb25cblxuXHRcdCMgbmVlZCB0byByZWdpc3RlciB0aGUgcmVxdWlyZWQtcGFycyBhcyB2YXJpYWJsZXNcblx0XHRzdXBlclxuXG5cdGRlZiBqcyBvXG5cdFx0cmV0dXJuIEVNUFRZIGlmIGNvdW50ID09IDBcblx0XHRyZXR1cm4gaGVhZChvKSBpZiBvLnBhcmVudCBpc2EgQmxvY2tcblxuXHRcdCMgaXRlbXMgPSBtYXAofGFyZ3wgYXJnLm5hbWUuYyApLmNvbXBhY3Rcblx0XHQjIHJldHVybiBudWxsIHVubGVzcyBpdGVtc1swXVxuXG5cdFx0aWYgby5wYXJlbnQgaXNhIENvZGVcblx0XHRcdCMgcmVtb3ZlIHRoZSBzcGxhdCwgZm9yIHN1cmUuLiBuZWVkIHRvIGhhbmRsZSB0aGUgb3RoZXIgaXRlbXMgYXMgd2VsbFxuXHRcdFx0IyB0aGlzIGlzIG1lc3N5IHdpdGggcmVmZXJlbmNlcyB0byBhcmd2YXJzIGV0YyBldGMuIEZpeFxuXHRcdFx0dmFyIHBhcnMgPSBub2Rlc1xuXHRcdFx0IyBwYXJzID0gZmlsdGVyKHxhcmd8IGFyZyAhPSBAc3BsYXQgJiYgIShhcmcgaXNhIEJsb2NrUGFyYW0pKSBpZiBAc3BsYXRcblx0XHRcdHBhcnMgPSBmaWx0ZXIofGFyZ3wgYXJnIGlzYSBSZXF1aXJlZFBhcmFtIG9yIGFyZyBpc2EgT3B0aW9uYWxQYXJhbSkgaWYgQHNwbGF0XG5cdFx0XHRjb21wYWN0X18ocGFycy5tYXAofGFyZ3wgY19fKGFyZy52YXJuYW1lKSApKS5qb2luKFwiLFwiKVxuXHRcdGVsc2Vcblx0XHRcdHRocm93IFwibm90IGltcGxlbWVudGVkIHBhcmFtbGlzdCBqc1wiXG5cdFx0XHRcInRhXCIgKyBjb21wYWN0X18obWFwKHxhcmd8IGFyZy5jICkpLmpvaW4oXCIsXCIpXG5cblx0ZGVmIGhlYWQgb1xuXHRcdHZhciByZWcgPSBbXVxuXHRcdHZhciBvcHQgPSBbXVxuXHRcdHZhciBibGsgPSBudWxsXG5cdFx0dmFyIHNwbGF0ID0gbnVsbFxuXHRcdHZhciBuYW1lZCA9IG51bGxcblx0XHR2YXIgYXJ5cyA9IFtdXG5cdFx0dmFyIHNpZ25hdHVyZSA9IFtdXG5cdFx0dmFyIGlkeCA9IDBcblxuXHRcdG5vZGVzLmZvckVhY2ggZG8gfHBhcixpfFxuXHRcdFx0cGFyLmluZGV4ID0gaWR4XG5cdFx0XHRpZiBwYXIgaXNhIE5hbWVkUGFyYW1zXG5cdFx0XHRcdHNpZ25hdHVyZS5wdXNoKCduYW1lZCcpXG5cdFx0XHRcdG5hbWVkID0gcGFyXG5cdFx0XHRlbGlmIHBhciBpc2EgT3B0aW9uYWxQYXJhbSBcblx0XHRcdFx0c2lnbmF0dXJlLnB1c2goJ29wdCcpXG5cdFx0XHRcdG9wdC5wdXNoKHBhcilcblx0XHRcdGVsaWYgcGFyIGlzYSBCbG9ja1BhcmFtXG5cdFx0XHRcdHNpZ25hdHVyZS5wdXNoKCdibGsnKVxuXHRcdFx0XHRibGsgPSBwYXJcblx0XHRcdGVsaWYgcGFyIGlzYSBTcGxhdFBhcmFtXG5cdFx0XHRcdHNpZ25hdHVyZS5wdXNoKCdzcGxhdCcpXG5cdFx0XHRcdHNwbGF0ID0gcGFyXG5cdFx0XHRcdGlkeCAtPSAxICMgdGhpcyBzaG91bGQgcmVhbGx5IGJlIHJlbW92ZWQgZnJvbSB0aGUgbGlzdCwgbm8/XG5cdFx0XHRlbGlmIHBhciBpc2EgQXJyYXlQYXJhbXNcblx0XHRcdFx0YXJ5cy5wdXNoKHBhcilcblx0XHRcdFx0c2lnbmF0dXJlLnB1c2goJ2FyeScpXG5cdFx0XHRlbHNlXG5cdFx0XHRcdHNpZ25hdHVyZS5wdXNoKCdyZWcnKVxuXHRcdFx0XHRyZWcucHVzaChwYXIpXG5cdFx0XHRpZHgrK1xuXG5cdFx0aWYgbmFtZWRcblx0XHRcdHZhciBuYW1lZHZhciA9IG5hbWVkLnZhcmlhYmxlXG5cblx0XHQjIHZhciBvcHQgPSBub2Rlcy5maWx0ZXIofG58IG4gaXNhIE9wdGlvbmFsUGFyYW0pXG5cdFx0IyB2YXIgYmxrID0gbm9kZXMuZmlsdGVyKHxufCBuIGlzYSBCbG9ja1BhcmFtKVswXVxuXHRcdCMgdmFyIHNwbGF0ID0gbm9kZXMuZmlsdGVyKHxufCBuIGlzYSBTcGxhdFBhcmFtKVswXVxuXG5cdFx0IyBzaW1wbGUgc2l0dWF0aW9uIHdoZXJlIHdlIHNpbXBseSBzd2l0Y2hcblx0XHQjIGNhbiBwcm9iYWJseSBvcHRpbWl6ZSBieSBub3QgbG9va2luZyBhdCBhcmd1bWVudHMgYXQgYWxsXG5cdFx0dmFyIGFzdCA9IFtdXG5cdFx0dmFyIGlzRnVuYyA9IGRvIHxqc3wgXCJ0eXBlb2Yge2pzfSA9PSAnZnVuY3Rpb24nXCJcblxuXHRcdCMgVGhpcyBpcyBicm9rZW4gd2hlbiBkZWFsaW5nIHdpdGggaWZyYW1lcyBhbmMgWFNTIHNjcmlwdGluZ1xuXHRcdCMgYnV0IGZvciBub3cgaXQgaXMgdGhlIGJlc3QgdGVzdCBmb3IgYWN0dWFsIGFyZ3VtZW50c1xuXHRcdCMgY2FuIGFsc28gZG8gY29uc3RydWN0b3IubmFtZSA9PSAnT2JqZWN0J1xuXHRcdHZhciBpc09iaiA9IGRvIHxqc3wgXCJ7anN9LmNvbnN0cnVjdG9yID09PSBPYmplY3RcIlxuXHRcdHZhciBpc250T2JqID0gZG8gfGpzfCBcIntqc30uY29uc3RydWN0b3IgIT09IE9iamVjdFwiXG5cdFx0IyBzaG91bGQgaGFuZGxlIHNvbWUgY29tbW9uIGNhc2VzIGluIGEgY2xlYW5lciAobGVzcyB2ZXJib3NlKSBtYW5uZXJcblx0XHQjIGRvZXMgdGhpcyB3b3JrIHdpdGggZGVmYXVsdCBwYXJhbXMgYWZ0ZXIgb3B0aW9uYWwgb25lcz8gSXMgdGhhdCBldmVuIHdvcnRoIGFueXRoaW5nP1xuXHRcdCMgdGhpcyBvbmx5IHdvcmtzIGluIG9uZSBkaXJlY3Rpb24gbm93LCB1bmxpa2UgVHVwbGVBc3NpZ25cblxuXHRcdCMgd2UgZG9udCByZWFsbHkgY2hlY2sgdGhlIGxlbmd0aCBldGMgbm93IC0tIHNvIGl0IGlzIGJ1Z2d5IGZvciBsb3RzIG9mIGFyZ3VtZW50c1xuXG5cdFx0IyBpZiB3ZSBoYXZlIG9wdGlvbmFsIHBhcmFtcyBpbiB0aGUgcmVndWxhciBvcmRlciBldGMgd2UgY2FuIGdvIHRoZSBlYXN5IHJvdXRlXG5cdFx0IyBzbGlnaHRseSBoYWNreSBub3cuIFNob3VsZCByZWZhY3RvciBhbGwgb2YgdGhlc2UgdG8gdXNlIHRoZSBzaWduYXR1cmU/XG5cdFx0aWYgIW5hbWVkICYmICFzcGxhdCAmJiAhYmxrICYmIG9wdDpsZW5ndGggPiAwICYmIHNpZ25hdHVyZS5qb2luKFwiIFwiKS5tYXRjaCgvb3B0JC8pXG5cdFx0XHRmb3IgcGFyLGkgaW4gb3B0XG5cdFx0XHRcdGFzdC5wdXNoIFwiaWYoe3Bhci5uYW1lLmN9ID09PSB1bmRlZmluZWQpIHtwYXIubmFtZS5jfSA9IHtwYXIuZGVmYXVsdHMuY31cIlxuXG5cdFx0XG5cdFx0ZWxpZiBuYW1lZCAmJiAhc3BsYXQgJiYgIWJsayAmJiBvcHQ6bGVuZ3RoID09IDAgIyBhbmQgbm8gYmxvY2s/IVxuXHRcdFx0IyBkaWZmZXJlbnQgc2hvcnRoYW5kc1xuXHRcdFx0IyBpZiBuYW1lZFxuXHRcdFx0YXN0LnB1c2ggXCJpZighe25hbWVkdmFyLmN9fHx7aXNudE9iaihuYW1lZHZhci5jKX0pIHtuYW1lZHZhci5jfSA9IFxce1xcfVwiXG5cblx0XHRlbGlmIGJsayAmJiBvcHQ6bGVuZ3RoID09IDEgJiYgIXNwbGF0ICYmICFuYW1lZFxuXHRcdFx0dmFyIG9wID0gb3B0WzBdXG5cdFx0XHR2YXIgb3BuID0gb3AubmFtZS5jXG5cdFx0XHR2YXIgYm4gPSBibGsubmFtZS5jXG5cdFx0XHRhc3QucHVzaCBcImlmKHtibn09PXVuZGVmaW5lZCAmJiB7aXNGdW5jKG9wbil9KSB7Ym59ID0ge29wbn0se29wbn0gPSB7b3AuZGVmYXVsdHMuY31cIlxuXHRcdFx0YXN0LnB1c2ggXCJpZih7b3BufT09dW5kZWZpbmVkKSB7b3BufSA9IHtvcC5kZWZhdWx0cy5jfVwiXG5cblx0XHRlbGlmIGJsayAmJiBuYW1lZCAmJiBvcHQ6bGVuZ3RoID09IDAgJiYgIXNwbGF0XG5cdFx0XHR2YXIgYm4gPSBibGsubmFtZS5jXG5cdFx0XHRhc3QucHVzaCBcImlmKHtibn09PXVuZGVmaW5lZCAmJiB7aXNGdW5jKG5hbWVkdmFyLmMpfSkge2JufSA9IHtuYW1lZHZhci5jfSx7bmFtZWR2YXIuY30gPSBcXHtcXH1cIlxuXHRcdFx0YXN0LnB1c2ggXCJlbHNlIGlmKCF7bmFtZWR2YXIuY318fHtpc250T2JqKG5hbWVkdmFyLmMpfSkge25hbWVkdmFyLmN9ID0gXFx7XFx9XCJcblxuXHRcdGVsaWYgb3B0Omxlbmd0aCA+IDAgfHwgc3BsYXQgIyAmJiBibGsgICMgJiYgIXNwbGF0XG5cblx0XHRcdHZhciBhcmd2YXIgPSBzY29wZV9fLnRlbXBvcmFyeShzZWxmLCBwb29sOiAnYXJndW1lbnRzJykucHJlZGVjbGFyZWQuY1xuXHRcdFx0dmFyIGxlbiA9IHNjb3BlX18udGVtcG9yYXJ5KHNlbGYsIHBvb2w6ICdjb3VudGVyJykucHJlZGVjbGFyZWQuY1xuXG5cdFx0XHR2YXIgbGFzdCA9IFwie2FyZ3Zhcn1be2xlbn0tMV1cIlxuXHRcdFx0dmFyIHBvcCA9IFwie2FyZ3Zhcn1bLS17bGVufV1cIlxuXHRcdFx0YXN0LnB1c2ggXCJ2YXIge2FyZ3Zhcn0gPSBhcmd1bWVudHMsIHtsZW59ID0ge2FyZ3Zhcn0ubGVuZ3RoXCJcblxuXHRcdFx0aWYgYmxrXG5cdFx0XHRcdHZhciBibiA9IGJsay5uYW1lLmNcblx0XHRcdFx0aWYgc3BsYXRcblx0XHRcdFx0XHRhc3QucHVzaCBcInZhciB7Ym59ID0ge2lzRnVuYyhsYXN0KX0gPyB7cG9wfSA6IG51bGxcIlxuXHRcdFx0XHRlbGlmIHJlZzpsZW5ndGggPiAwXG5cdFx0XHRcdFx0IyBhc3QucHVzaCBcIi8vIHNldmVyYWwgcmVncyByZWFsbHk/XCJcblx0XHRcdFx0XHRhc3QucHVzaCBcInZhciB7Ym59ID0ge2xlbn0gPiB7cmVnOmxlbmd0aH0gJiYge2lzRnVuYyhsYXN0KX0gPyB7cG9wfSA6IG51bGxcIlxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0YXN0LnB1c2ggXCJ2YXIge2JufSA9IHtpc0Z1bmMobGFzdCl9ID8ge3BvcH0gOiBudWxsXCJcblxuXHRcdFx0IyBpZiB3ZSBoYXZlIG5hbWVkIHBhcmFtcyAtIGxvb2sgZm9yIHRoZW0gYmVmb3JlIHNwbGF0XG5cdFx0XHQjIHNob3VsZCBwcm9iYWJseSBsb29wIHRocm91Z2ggcGFycyBpbiB0aGUgc2FtZSBvcmRlciB0aGV5IHdlcmUgYWRkZWRcblx0XHRcdCMgc2hvdWxkIGl0IGJlIHByaW9yaXRpemVkIGFib3ZlIG9wdGlvbmFsIG9iamVjdHM/P1xuXHRcdFx0aWYgbmFtZWRcblx0XHRcdFx0IyBzaG91bGQgbm90IGluY2x1ZGUgaXQgd2hlbiB0aGVyZSBpcyBhIHNwbGF0P1xuXHRcdFx0XHRhc3QucHVzaCBcInZhciB7bmFtZWR2YXIuY30gPSB7bGFzdH0mJntpc09iaihsYXN0KX0gPyB7cG9wfSA6IFxce1xcfVwiXG5cblx0XHRcdGZvciBwYXIsaSBpbiBvcHRcblx0XHRcdFx0YXN0LnB1c2ggXCJpZih7bGVufSA8IHtwYXIuaW5kZXggKyAxfSkge3Bhci5uYW1lLmN9ID0ge3Bhci5kZWZhdWx0cy5jfVwiXG5cblx0XHRcdCMgYWRkIHRoZSBzcGxhdFxuXHRcdFx0aWYgc3BsYXRcblx0XHRcdFx0dmFyIHNuID0gc3BsYXQubmFtZS5jXG5cdFx0XHRcdHZhciBzaSA9IHNwbGF0LmluZGV4XG5cblx0XHRcdFx0aWYgc2kgPT0gMFxuXHRcdFx0XHRcdGFzdC5wdXNoIFwidmFyIHtzbn0gPSBuZXcgQXJyYXkoe2xlbn0+e3NpfSA/IHtsZW59IDogMClcIlxuXHRcdFx0XHRcdGFzdC5wdXNoIFwid2hpbGUoe2xlbn0+e3NpfSkge3NufVt7bGVufS0xXSA9IHtwb3B9XCJcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdGFzdC5wdXNoIFwidmFyIHtzbn0gPSBuZXcgQXJyYXkoe2xlbn0+e3NpfSA/IHtsZW59LXtzaX0gOiAwKVwiXG5cdFx0XHRcdFx0YXN0LnB1c2ggXCJ3aGlsZSh7bGVufT57c2l9KSB7c259Wy0te2xlbn0gLSB7c2l9XSA9IHthcmd2YXJ9W3tsZW59XVwiXG5cblx0XHRcdCMgaWYgbmFtZWRcblx0XHRcdCMgXHRmb3IgayxpIGluIG5hbWVkLm5vZGVzXG5cdFx0XHQjIFx0XHQjIE9QKCcuJyxuYW1lZHZhcikgPC0gdGhpcyBpcyB0aGUgcmlnaHQgd2F5LCB3aXRoIGludmFsaWQgbmFtZXMgZXRjXG5cdFx0XHQjIFx0XHR2YXIgb3AgPSBPUCgnLicsbmFtZWR2YXIsay5rZXkpLmNcblx0XHRcdCMgXHRcdGFzdC5wdXNoIFwidmFyIHtrLmtleS5jfSA9IHtvcH0gIT09IHVuZGVmaW5lZCA/IHtvcH0gOiB7ay52YWx1ZS5jfVwiXG5cblx0XHRcdCMgaWYgbmFtZWRcblxuXHRcdFx0IyByZXR1cm4gYXN0LmpvaW4oXCI7XFxuXCIpICsgXCI7XCJcblx0XHRcdCMgcmV0dXJuIFwiaWYoe29wdFswXS5uYW1lLmN9IGluc3RhbmNlb2YgRnVuY3Rpb24pIHtibGsuY30gPSB7b3B0WzBdLmN9O1wiXG5cblxuXHRcdGVsaWYgb3B0Omxlbmd0aCA+IDBcblx0XHRcdGZvciBwYXIsaSBpbiBvcHRcblx0XHRcdFx0YXN0LnB1c2ggXCJpZih7cGFyLm5hbWUuY30gPT09IHVuZGVmaW5lZCkge3Bhci5uYW1lLmN9ID0ge3Bhci5kZWZhdWx0cy5jfVwiXG5cblx0XHQjIG5vdyBzZXQgc3R1ZmYgaWYgbmFtZWQgcGFyYW1zKCEpXG5cblx0XHRpZiBuYW1lZFxuXHRcdFx0Zm9yIGssaSBpbiBuYW1lZC5ub2Rlc1xuXHRcdFx0XHQjIGNvbnNvbGUubG9nIFwibmFtZWQgdmFyIHtrLmN9XCJcblx0XHRcdFx0dmFyIG9wID0gT1AoJy4nLG5hbWVkdmFyLGsuYykuY1xuXHRcdFx0XHRhc3QucHVzaCBcInZhciB7ay5jfSA9IHtvcH0gIT09IHVuZGVmaW5lZCA/IHtvcH0gOiB7ay5kZWZhdWx0cy5jfVwiXG5cblx0XHRpZiBhcnlzOmxlbmd0aFxuXHRcdFx0Zm9yIHYsaSBpbiBhcnlzXG5cdFx0XHRcdCMgY3JlYXRlIHR1cGxlc1xuXHRcdFx0XHQjIHAgXCJhZGRpbmcgYXJyYXlwYXJhbXNcIlxuXHRcdFx0XHR2LmhlYWQobyxhc3Qsc2VsZilcblx0XHRcdFx0IyBhc3QucHVzaCB2LmNcblx0XHRcdFx0XG5cblxuXHRcdCMgaWYgb3B0Omxlbmd0aCA9PSAwXG5cdFx0cmV0dXJuIGFzdDpsZW5ndGggPiAwID8gKGFzdC5qb2luKFwiO1xcblwiKSArIFwiO1wiKSA6IEVNUFRZXG5cblxuIyBMZWdhY3kuIFNob3VsZCBtb3ZlIGF3YXkgZnJvbSB0aGlzP1xuZXhwb3J0IGNsYXNzIFZhcmlhYmxlRGVjbGFyYXRpb24gPCBMaXN0Tm9kZVxuXG5cdCMgZm9yIGxhdGVyLCBtb3otYXN0IHN0eWxlXG5cdHByb3Aga2luZFxuXG5cdCMgd2Ugd2FudCB0byByZWdpc3RlciB0aGVzZSB2YXJpYWJsZXMgaW5cblx0ZGVmIGFkZCBuYW1lLCBpbml0LCBwb3MgPSAtMVxuXHRcdHZhciB2YXJkZWMgPSBWYXJpYWJsZURlY2xhcmF0b3IubmV3KG5hbWUsaW5pdClcblx0XHR2YXJkZWMudmFyaWFibGUgPSBuYW1lIGlmIG5hbWUgaXNhIFZhcmlhYmxlXG5cdFx0cG9zID09IDAgPyB1bnNoaWZ0KHZhcmRlYykgOiBwdXNoKHZhcmRlYylcblx0XHR2YXJkZWNcblxuXHRcdCMgVE9ETyAodGFyZ2V0KSA8PCAobm9kZSkgcmV3cml0ZXMgdG8gYSBjYWNoaW5nIHB1c2ggd2hpY2ggcmV0dXJucyBub2RlXG5cblx0IyBkZWYgcmVtb3ZlIGl0ZW1cblx0IyBcdGlmIGl0ZW0gaXNhIFZhcmlhYmxlXG5cdCMgXHRcdG1hcCBkbyB8dixpfFxuXHQjIFx0XHRcdGlmIHYudmFyaWFibGUgPT0gaXRlbVxuXHQjIFx0XHRcdFx0cCBcImZvdW5kIHZhcmlhYmxlIHRvIHJlbW92ZVwiXG5cdCMgXHRcdFx0XHRzdXBlci5yZW1vdmUodilcblx0IyBcdGVsc2Vcblx0IyBcdFx0c3VwZXIucmVtb3ZlKGl0ZW0pXG5cdCMgXHRzZWxmXG5cdFxuXHRkZWYgbG9hZCBsaXN0XG5cdFx0IyB0ZW1wb3Jhcnkgc29sdXRpb24hISFcblx0XHRsaXN0Lm1hcCBkbyB8cGFyfCBWYXJpYWJsZURlY2xhcmF0b3IubmV3KHBhci5uYW1lLHBhci5kZWZhdWx0cyxwYXIuc3BsYXQpXG5cblx0ZGVmIGlzRXhwcmVzc2FibGVcblx0XHRub2Rlcy5ldmVyeSh8aXRlbXwgaXRlbS5pc0V4cHJlc3NhYmxlKVxuXG5cdGRlZiBqcyBvXG5cdFx0cmV0dXJuIEVNUFRZIGlmIGNvdW50ID09IDBcblxuXHRcdGlmIGNvdW50ID09IDEgJiYgIWlzRXhwcmVzc2FibGVcblx0XHRcdCMgcCBcIlNIT1VMRCBBTFRFUiBWQVJERUMhISFcIi5jeWFuXG5cdFx0XHRmaXJzdC52YXJpYWJsZS5hdXRvZGVjbGFyZVxuXHRcdFx0dmFyIG5vZGUgPSBmaXJzdC5hc3NpZ25tZW50XG5cdFx0XHRyZXR1cm4gbm9kZS5jXG5cblx0XHQjIEZJWCBQRVJGT1JNQU5DRVxuXHRcdHZhciBvdXQgPSBjb21wYWN0X18oY2FyeV9fKG5vZGVzKSkuam9pbihcIiwgXCIpXG5cdFx0b3V0ID8gXCJ2YXIge291dH1cIiA6IFwiXCJcblx0XHQjIFwidmFyIFwiICsgY29tcGFjdF9fKGNhcnlfXyhub2RlcykpLmpvaW4oXCIsIFwiKSArIFwiXCJcblxuZXhwb3J0IGNsYXNzIFZhcmlhYmxlRGVjbGFyYXRvciA8IFBhcmFtXG5cblx0IyBjYW4gcG9zc2libHkgY3JlYXRlIHRoZSB2YXJpYWJsZSBpbW1lZGlhdGVseSBidXQgd2FpdCB3aXRoIHNjb3BlLWRlY2xhcmluZ1xuXHQjIFdoYXQgaWYgdGhpcyBpcyBtZXJlbHkgdGhlIGRlY2xhcmF0aW9uIG9mIGEgc3lzdGVtL3RlbXBvcmFyeSB2YXJpYWJsZT9cblx0ZGVmIHZpc2l0XG5cdFx0IyBldmVuIGlmIHdlIHNob3VsZCB0cmF2ZXJzZSB0aGUgZGVmYXVsdHMgYXMgaWYgdGhpcyB2YXJpYWJsZSBkb2VzIG5vdCBleGlzdFxuXHRcdCMgd2UgbmVlZCB0byBwcmVyZWdpc3RlciBpdCBhbmQgdGhlbiBhY3RpdmF0ZSBpdCBsYXRlclxuXHRcdHNlbGYudmFyaWFibGUgfHw9IHNjb3BlX18ucmVnaXN0ZXIobmFtZSxudWxsKVxuXHRcdGRlZmF1bHRzLnRyYXZlcnNlIGlmIGRlZmF1bHRzXG5cdFx0IyBXQVJOIHdoYXQgaWYgaXQgaXMgYWxyZWFkeSBkZWNsYXJlZD9cblx0XHRzZWxmLnZhcmlhYmxlLmRlY2xhcmF0b3IgPSBzZWxmXG5cdFx0c2VsZi52YXJpYWJsZS5hZGRSZWZlcmVuY2UobmFtZSlcblx0XHRzZWxmXG5cdFx0XG5cdCMgbmVlZHMgdG8gYmUgbGlua2VkIHVwIHRvIHRoZSBhY3R1YWwgc2NvcGVkIHZhcmlhYmxlcywgbm8/XG5cdGRlZiBqcyBvXG5cdFx0cmV0dXJuIG51bGwgaWYgdmFyaWFibGUuQHByb3h5XG5cblx0XHR2YXIgZGVmcyA9IGRlZmF1bHRzXG5cdFx0IyBGSVhNRSBuZWVkIHRvIGRlYWwgd2l0aCB2YXItZGVmaW5lcyB3aXRoaW4gb3RoZXIgc3RhdGVtZW50cyBldGNcblx0XHQjIEZJWE1FIG5lZWQgYmV0dGVyIHN5bnRheCBmb3IgdGhpc1xuXHRcdGlmIGRlZnMgIT0gbnVsbCAmJiBkZWZzICE9IHVuZGVmaW5lZFxuXHRcdFx0IyBjb25zb2xlLmxvZyBcImRlZmF1bHRzIGlzIHtkZWZhdWx0c31cIlxuXHRcdFx0ZGVmcyA9IGRlZnMuYyhleHByZXNzaW9uOiB5ZXMpIGlmIGRlZnMgaXNhIE5vZGVcblxuXHRcdFx0XCJ7dmFyaWFibGUuY30gPSB7ZGVmc31cIlxuXHRcdGVsc2Vcblx0XHRcdFwie3ZhcmlhYmxlLmN9XCJcblxuXHRkZWYgYWNjZXNzb3Jcblx0XHRzZWxmXG5cblxuIyBUT0RPIGNsZWFuIHVwIGFuZCByZWZhY3RvciBhbGwgdGhlIGRpZmZlcmVudCByZXByZXNlbnRhdGlvbnMgb2YgdmFyc1xuIyBWYXJOYW1lLCBWYXJSZWZlcmVuY2UsIExvY2FsVmFyQWNjZXNzP1xuZXhwb3J0IGNsYXNzIFZhck5hbWUgPCBWYWx1ZU5vZGVcblxuXHRwcm9wIHZhcmlhYmxlXG5cdHByb3Agc3BsYXRcblxuXHRkZWYgaW5pdGlhbGl6ZSBhLGJcblx0XHRzdXBlclxuXHRcdEBzcGxhdCA9IGJcblxuXHRkZWYgdmlzaXRcblx0XHQjIHAgXCJ2aXNpdGluZyB2YXJuYW1lKCEpXCIsIHZhbHVlLmNcblx0XHQjIHNob3VsZCB3ZSBub3QgbG9va3VwIGluc3RlYWQ/XG5cdFx0IyBGSVhNRSBwIFwicmVnaXN0ZXIgdmFsdWUge3ZhbHVlLmN9XCJcblx0XHRzZWxmLnZhcmlhYmxlIHx8PSBzY29wZV9fLnJlZ2lzdGVyKHZhbHVlLmMsbnVsbClcblx0XHRzZWxmLnZhcmlhYmxlLmRlY2xhcmF0b3IgPSBzZWxmXG5cdFx0c2VsZi52YXJpYWJsZS5hZGRSZWZlcmVuY2UodmFsdWUpXG5cdFx0c2VsZlxuXG5cdGRlZiBqcyBvXG5cdFx0dmFyaWFibGUuY1xuXG5cdGRlZiBjXG5cdFx0dmFyaWFibGUuY1x0XHRcblx0XHRcblxuZXhwb3J0IGNsYXNzIFZhckxpc3QgPCBOb2RlXG5cblx0cHJvcCB0eXBlICMgbGV0IC8gdmFyIC8gY29uc3Rcblx0cHJvcCBsZWZ0XG5cdHByb3AgcmlnaHRcblxuXHQjIGZvcm1hdCA6dHlwZSwgOmxlZnQsIDpyaWdodFxuXG5cdCMgc2hvdWxkIHRocm93IGVycm9yIGlmIHRoZXJlIGFyZSBtb3JlIHZhbHVlcyBvbiByaWdodCB0aGFuIGxlZnRcblxuXHRkZWYgaW5pdGlhbGl6ZSB0LGwsclxuXHRcdEB0cmF2ZXJzZWQgPSBub1xuXHRcdEB0eXBlID0gdHlwZVxuXHRcdEBsZWZ0ID0gbFxuXHRcdEByaWdodCA9IHJcblxuXHRkZWYgdmlzaXRcblxuXHRcdCMgd2UgbmVlZCB0byBjYXJlZnVsbHkgdHJhdmVyc2UgY2hpbGRyZW4gaW4gdGhlIHJpZ2h0IG9yZGVyXG5cdFx0IyBzaW5jZSB3ZSBzaG91bGQgYmUgYWJsZSB0byByZWZlcmVuY2Vcblx0XHRmb3IgbCxpIGluIGxlZnRcblx0XHRcdGwudHJhdmVyc2UgIyB0aGlzIHNob3VsZCByZWFsbHkgYmUgYSB2YXItZGVjbGFyYXRpb25cblx0XHRcdHIudHJhdmVyc2UgaWYgdmFyIHIgPSByaWdodFtpXVxuXHRcdHNlbGZcblxuXHRkZWYganMgb1xuXHRcdCMgZm9yIHRoZSByZWd1bGFyIGl0ZW1zIFxuXHRcdHZhciBwYWlycyA9IFtdXG5cdFx0dmFyIGxsID0gbGVmdDpsZW5ndGhcblx0XHR2YXIgcmwgPSByaWdodDpsZW5ndGhcblx0XHR2YXIgdiA9IG51bGxcblxuXHRcdCMgc3BsYXR0aW5nIGhlcmUgd2UgY29tZVxuXHRcdGlmIGxsID4gMSAmJiBybCA9PSAxXG5cdFx0XHRwIFwibXVsdGlhc3NpZ24hXCJcblx0XHRcdHZhciByID0gcmlnaHRbMF1cblx0XHRcdHIuY2FjaGVcblx0XHRcdGZvciBsLGkgaW4gbGVmdFxuXHRcdFx0XHRpZiBsLnNwbGF0XG5cdFx0XHRcdFx0dGhyb3cgXCJub3Qgc3VwcG9ydGVkP1wiXG5cdFx0XHRcdFx0cCBcInNwbGF0XCIgIyBGSVggcmVpbXBsZW1lbnQgc2xpY2U/XG5cdFx0XHRcdFx0aWYgaSA9PSBsbCAtIDFcblx0XHRcdFx0XHRcdHYgPSB1dGlsLnNsaWNlKHIsaSlcblx0XHRcdFx0XHRcdHAgXCJsYXN0XCJcblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHR2ID0gdXRpbC5zbGljZShyLGksLShsbCAtIGkpICsgMSlcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHYgPSBPUCgnLicscixudW1fXyhpKSlcblx0XHRcdFx0XG5cdFx0XHRcdHBhaXJzLnB1c2goT1AoJz0nLGwsdikpXG5cblx0XHRlbHNlXG5cdFx0XHRmb3IgbCxpIGluIGxlZnRcblx0XHRcdFx0dmFyIHIgPSByaWdodFtpXVxuXHRcdFx0XHRwYWlycy5wdXNoKHIgPyBPUCgnPScsbC52YXJpYWJsZS5hY2Nlc3NvcixyKSA6IGwpXG5cblx0XHRyZXR1cm4gXCJ2YXIge3BhaXJzLmN9XCJcblxuXG4jIENPREVcblxuZXhwb3J0IGNsYXNzIENvZGUgPCBOb2RlXG5cblx0cHJvcCBoZWFkXG5cdHByb3AgYm9keVxuXHRwcm9wIHNjb3BlXG5cdHByb3AgcGFyYW1zXG5cblx0ZGVmIHNjb3BldHlwZVxuXHRcdFNjb3BlXG5cblx0ZGVmIHZpc2l0XG5cdFx0QHNjb3BlLnZpc2l0IGlmIEBzY29wZVxuXHRcdCMgQHNjb3BlLnBhcmVudCA9IFNUQUNLLnNjb3BlKDEpIGlmIEBzY29wZVxuXHRcdHNlbGZcblxuXG4jIFJlbmFtZSB0byBQcm9ncmFtP1xuZXhwb3J0IGNsYXNzIFJvb3QgPCBDb2RlXG5cblx0ZGVmIGluaXRpYWxpemUgYm9keSwgb3B0c1xuXHRcdCMgcCBcImNyZWF0ZSByb290IVwiXG5cdFx0QHRyYXZlcnNlZCA9IG5vXG5cdFx0QGJvZHkgPSBibGtfXyhib2R5KVxuXHRcdEBzY29wZSA9IFJvb3RTY29wZS5uZXcoc2VsZixudWxsKVxuXHRcdEBvcHRpb25zID0ge31cblxuXHRkZWYgdmlzaXRcblx0XHRST09UID0gU1RBQ0suUk9PVCA9IEBzY29wZVxuXHRcdHNjb3BlLnZpc2l0XG5cdFx0Ym9keS50cmF2ZXJzZVxuXG5cdGRlZiBjb21waWxlIG9cblx0XHRTVEFDSy5yZXNldCAjIC0tIG5lc3RlZCBjb21waWxhdGlvbiBkb2VzIG5vdCB3b3JrIG5vd1xuXHRcdE9QVFMgPSBTVEFDSy5Ab3B0aW9ucyA9IEBvcHRpb25zID0gbyBvciB7fVxuXG5cdFx0dHJhdmVyc2VcblxuXHRcdHZhciBvdXQgPSBjXG5cdFx0dmFyIHJlc3VsdCA9IHtcblx0XHRcdGpzOiBvdXQsXG5cdFx0XHRhc3Q6IHNlbGYsXG5cdFx0XHR3YXJuaW5nczogc2NvcGUud2FybmluZ3MsXG5cdFx0XHRvcHRpb25zOiBvLFxuXHRcdFx0dG9TdHJpbmc6IChkbyB0aGlzOmpzKVxuXHRcdH1cblx0XHRpZiBvOnNvdXJjZU1hcElubGluZSBvciBvOnNvdXJjZU1hcFxuXHRcdFx0cmVzdWx0OnNvdXJjZW1hcCA9IFNvdXJjZU1hcC5uZXcocmVzdWx0KS5nZW5lcmF0ZVxuXG5cdFx0cmV0dXJuIHJlc3VsdFxuXG5cdGRlZiBqcyBvXG5cdFx0dmFyIG91dFxuXHRcdGlmIEBvcHRpb25zOmJhcmVcblx0XHRcdG91dCA9IHNjb3BlLmNcblx0XHRlbHNlXG5cdFx0XHRib2R5LmNvbnN1bWUoSW1wbGljaXRSZXR1cm4ubmV3KVxuXHRcdFx0b3V0ID0gc2NvcGUuYyhpbmRlbnQ6IHllcylcblx0XHRcdG91dCA9IG91dC5yZXBsYWNlKC9eXFxuPy8sJ1xcbicpXG5cdFx0XHRvdXQgPSBvdXQucmVwbGFjZSgvXFxuPyQvLCdcXG5cXG4nKVxuXHRcdFx0b3V0ID0gJyhmdW5jdGlvbigpeycgKyBvdXQgKyAnfSkoKSdcblxuXHRcdCMgZmluZCBhbmQgcmVwbGFjZSBzaGViYW5nc1xuXHRcdHZhciBzaGViYW5ncyA9IFtdXG5cdFx0b3V0ID0gb3V0LnJlcGxhY2UoL15bIFxcdF0qXFwvXFwvKFxcIS4rKSQvbWcpIGRvIHxtLHNoZWJhbmd8XG5cdFx0XHQjIHAgXCJmb3VuZCBzaGViYW5nIHtzaGViYW5nfVwiXG5cdFx0XHRzaGViYW5nID0gc2hlYmFuZy5yZXBsYWNlKC9cXGJpbWJhXFxiL2csJ25vZGUnKVxuXHRcdFx0c2hlYmFuZ3MucHVzaChcIiN7c2hlYmFuZ31cXG5cIilcblx0XHRcdHJldHVybiBcIlwiXG5cblx0XHRvdXQgPSBzaGViYW5ncy5qb2luKCcnKSArIG91dFxuXG5cdFx0cmV0dXJuIG91dFxuXG5cblx0ZGVmIGFuYWx5emUgbG9nbGV2ZWw6IDAsIGVudGl0aWVzOiBubywgc2NvcGVzOiB5ZXNcblx0XHRTVEFDSy5sb2dsZXZlbCA9IGxvZ2xldmVsXG5cdFx0U1RBQ0suQGFuYWx5emluZyA9IHRydWVcblx0XHRST09UID0gU1RBQ0suUk9PVCA9IEBzY29wZVxuXG5cdFx0T1BUUyA9IHtcblx0XHRcdGFuYWx5c2lzOiB7XG5cdFx0XHRcdGVudGl0aWVzOiBlbnRpdGllcyxcblx0XHRcdFx0c2NvcGVzOiBzY29wZXNcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0cmF2ZXJzZVxuXHRcdFNUQUNLLkBhbmFseXppbmcgPSBmYWxzZVxuXG5cdFx0cmV0dXJuIHNjb3BlLmR1bXBcblxuXHRkZWYgaW5zcGVjdFxuXHRcdHRydWVcblxuZXhwb3J0IGNsYXNzIENsYXNzRGVjbGFyYXRpb24gPCBDb2RlXG5cblx0cHJvcCBuYW1lXG5cdHByb3Agc3VwZXJjbGFzc1xuXHRwcm9wIGluaXRvclxuXG5cdGRlZiBjb25zdW1lIG5vZGVcblx0XHRpZiBub2RlIGlzYSBSZXR1cm5cblx0XHRcdG9wdGlvbigncmV0dXJuJyx5ZXMpXG5cdFx0XHRyZXR1cm4gc2VsZlxuXHRcdHN1cGVyXG5cblx0ZGVmIG5hbWVwYXRoXG5cdFx0QG5hbWVwYXRoIHx8PSBcIntuYW1lLmN9XCJcblxuXHRkZWYgbWV0YWRhdGFcblx0XHR7XG5cdFx0XHR0eXBlOiAnY2xhc3MnXG5cdFx0XHRuYW1lcGF0aDogbmFtZXBhdGhcblx0XHRcdGluaGVyaXRzOiBzdXBlcmNsYXNzPy5uYW1lcGF0aFxuXHRcdFx0cGF0aDogbmFtZS5jLnRvU3RyaW5nXG5cdFx0XHRkZXNjOiBAZGVzY1xuXHRcdFx0bG9jOiBsb2Ncblx0XHR9XHRcblxuXHRkZWYgdG9KU09OXG5cdFx0bWV0YWRhdGFcblxuXHRkZWYgaW5pdGlhbGl6ZSBuYW1lLCBzdXBlcmNsYXNzLCBib2R5XG5cdFx0IyB3aGF0IGFib3V0IHRoZSBuYW1lc3BhY2U/XG5cdFx0QHRyYXZlcnNlZCA9IG5vXG5cdFx0QG5hbWUgPSBuYW1lXG5cdFx0QHN1cGVyY2xhc3MgPSBzdXBlcmNsYXNzXG5cdFx0QHNjb3BlID0gQ2xhc3NTY29wZS5uZXcoc2VsZilcblx0XHRAYm9keSA9IGJsa19fKGJvZHkpXG5cdFx0c2VsZlxuXG5cdGRlZiB2aXNpdFxuXHRcdCMgcmVwbGFjZSB3aXRoIHNvbWUgYWR2YW5jZWQgbG9va3VwP1xuXHRcdFJPT1QuZW50aXRpZXMuYWRkKG5hbWVwYXRoLHNlbGYpXG5cdFx0c2NvcGUudmlzaXRcblx0XHRib2R5LnRyYXZlcnNlXG5cdFx0c2VsZlxuXG5cdGRlZiBqcyBvXG5cdFx0c2NvcGUudmlydHVhbGl6ZSAjIGlzIHRoaXMgYWx3YXlzIG5lZWRlZD9cblx0XHRzY29wZS5jb250ZXh0LnZhbHVlID0gbmFtZVxuXG5cdFx0IyBzaG91bGQgcHJvYmFibHkgYWxzbyB3YXJuIGFib3V0IHN0dWZmIGV0Y1xuXHRcdGlmIG9wdGlvbig6ZXh0ZW5zaW9uKVxuXHRcdFx0cmV0dXJuIGJvZHkuY1xuXG5cdFx0dmFyIGhlYWQgPSBbXVxuXHRcdHZhciBvID0gQG9wdGlvbnMgb3Ige31cblx0XHR2YXIgY25hbWUgPSBuYW1lIGlzYSBBY2Nlc3MgPyBuYW1lLnJpZ2h0IDogbmFtZVxuXHRcdHZhciBuYW1lc3BhY2VkID0gbmFtZSAhPSBjbmFtZVxuXHRcdHZhciBpbml0b3IgPSBudWxsXG5cdFx0dmFyIHN1cCA9IHN1cGVyY2xhc3NcblxuXHRcdHZhciBib2R5aW5kZXggPSAtMVxuXHRcdHZhciBzcGFjZXMgPSBib2R5LmZpbHRlciBkbyB8aXRlbXwgaXRlbSBpc2EgVGVybWluYXRvclxuXHRcdHZhciBtYXJrID0gbWFya19fKG9wdGlvbigna2V5d29yZCcpKVxuXG5cdFx0Ym9keS5tYXAgZG8gfGMsaXxcblx0XHRcdGlmIGMgaXNhIE1ldGhvZERlY2xhcmF0aW9uICYmIGMudHlwZSA9PSA6Y29uc3RydWN0b3Jcblx0XHRcdFx0Ym9keWluZGV4ID0gaVxuXG5cdFx0aWYgYm9keWluZGV4ID49IDBcblx0XHRcdGluaXRvciA9IGJvZHkucmVtb3ZlQXQoYm9keWluZGV4KVxuXG5cdFx0IyB2YXIgaW5pdG9yID0gYm9keS5wbHVjayBkbyB8Y3wgYyBpc2EgTWV0aG9kRGVjbGFyYXRpb24gJiYgYy50eXBlID09IDpjb25zdHJ1Y3RvclxuXHRcdCMgY29tcGlsZSB0aGUgY25hbWVcblx0XHRjbmFtZSA9IGNuYW1lLmMgdW5sZXNzIHR5cGVvZiBjbmFtZSA9PSAnc3RyaW5nJ1xuXG5cdFx0dmFyIGNwYXRoID0gdHlwZW9mIG5hbWUgID09ICdzdHJpbmcnID8gbmFtZSA6IG5hbWUuY1xuXG5cdFx0aWYgIWluaXRvclxuXHRcdFx0aWYgc3VwXG5cdFx0XHRcdGluaXRvciA9IFwie21hcmt9ZnVuY3Rpb24ge2NuYW1lfSgpXFx7IHJldHVybiB7c3VwLmN9LmFwcGx5KHRoaXMsYXJndW1lbnRzKSBcXH07XFxuXFxuXCJcblx0XHRcdGVsc2Vcblx0XHRcdFx0aW5pdG9yID0gXCJ7bWFya31mdW5jdGlvbiB7Y25hbWV9KClcIiArICd7IH07XFxuXFxuJ1xuXHRcdFx0XG5cdFx0ZWxzZVxuXHRcdFx0aW5pdG9yLm5hbWUgPSBjbmFtZVxuXHRcdFx0aW5pdG9yID0gaW5pdG9yLmMgKyAnOydcblx0XHRcblx0XHQjIGlmIHdlIGFyZSBkZWZpbmluZyBhIGNsYXNzIGluc2lkZSBhIG5hbWVzcGFjZSBldGMgLS0gaG93IHNob3VsZCB3ZSBzZXQgdXAgdGhlIGNsYXNzP1xuXHRcdFxuXHRcdGlmIG5hbWVzcGFjZWRcblx0XHRcdCMgc2hvdWxkIHVzZSBOb2RlcyB0byBidWlsZCB0aGlzIGluc3RlYWRcblx0XHRcdGluaXRvciA9IFwie2NwYXRofSA9IHtpbml0b3J9XCIgIyBPUCgnPScsbmFtZSxpbml0b3IpXG5cblx0XHRoZWFkLnB1c2goaW5pdG9yKSAjIC8vIEBjbGFzcyB7Y25hbWV9XFxuXG5cblx0XHRpZiBib2R5aW5kZXggPj0gMFxuXHRcdFx0IyBhZGQgdGhlIHNwYWNlIGFmdGVyIGluaXRvcj9cblx0XHRcdGlmIGJvZHkuaW5kZXgoYm9keWluZGV4KSBpc2EgVGVybWluYXRvclxuXHRcdFx0XHRoZWFkLnB1c2goYm9keS5yZW1vdmVBdChib2R5aW5kZXgpKVxuXHRcdGVsc2Vcblx0XHRcdCMgaGVhZC5wdXNoKFRlcm1pbmF0b3IubmV3KCdcXG5cXG4nKSlcblx0XHRcdHRydWVcblx0XHRcblxuXG5cdFx0aWYgc3VwXG5cdFx0XHQjIGNvbnNvbGUubG9nIFwiZGVhbCB3aXRoIHN1cGVyY2xhc3MhXCJcblx0XHRcdCMgaGVhZC5wdXNoKFwiLy8gZXh0ZW5kaW5nIHRoZSBzdXBlcmNsYXNzXFxuaW1iYSRjbGFzcyh7bmFtZS5jfSx7c3VwLmN9KTtcXG5cXG5cIilcblx0XHRcdGhlYWQucHVzaChVdGlsLlN1YmNsYXNzLm5ldyhbbmFtZSxzdXBdKSlcblxuXHRcdCMgb25seSBpZiBpdCBpcyBub3QgbmFtZXNwYWNlZFxuXHRcdGlmIG86Z2xvYmFsIGFuZCAhbmFtZXNwYWNlZCAjIG9wdGlvbig6Z2xvYmFsKVxuXHRcdFx0aGVhZC5wdXNoKFwiZ2xvYmFsLntjbmFtZX0gPSB7Y3BhdGh9OyAvLyBnbG9iYWwgY2xhc3MgXFxuXCIpXG5cblx0XHRpZiBvOmV4cG9ydCBhbmQgIW5hbWVzcGFjZWRcblx0XHRcdGhlYWQucHVzaChcImV4cG9ydHMue2NuYW1lfSA9IHtjcGF0aH07IC8vIGV4cG9ydCBjbGFzcyBcXG5cIilcblxuXHRcdCMgRklYTUVcblx0XHQjIGlmIG5hbWVzcGFjZWQgYW5kIChvOmxvY2FsIG9yIG86ZXhwb3J0KVxuXHRcdCMgXHRjb25zb2xlLmxvZyBcIm5hbWVzcGFjZWQgY2xhc3NlcyBhcmUgaW1wbGljaXRseSBsb2NhbC9nbG9iYWwgZGVwZW5kaW5nIG9uIHRoZSBuYW1lc3BhY2VcIlxuXG5cdFx0aWYgb3B0aW9uKCdyZXR1cm4nKVxuXHRcdFx0Ym9keS5wdXNoKFwicmV0dXJuIHtjcGF0aH07XCIpXG5cblx0XHRib2R5LnVuc2hpZnQocGFydCkgZm9yIHBhcnQgaW4gaGVhZC5yZXZlcnNlXG5cdFx0Ym9keS5AaW5kZW50YXRpb24gPSBudWxsXG5cdFx0dmFyIGVuZCA9IGJvZHkuaW5kZXgoYm9keS5jb3VudCAtIDEpXG5cdFx0Ym9keS5wb3AgaWYgZW5kIGlzYSBUZXJtaW5hdG9yIGFuZCBlbmQuYzpsZW5ndGggPT0gMVxuXG5cdFx0dmFyIG91dCA9IGJvZHkuY1xuXG5cdFx0cmV0dXJuIG91dFxuXG5cbmV4cG9ydCBjbGFzcyBUYWdEZWNsYXJhdGlvbiA8IENvZGVcblxuXHRwcm9wIG5hbWVcblx0cHJvcCBzdXBlcmNsYXNzXG5cdHByb3AgaW5pdG9yXG5cblx0ZGVmIG5hbWVwYXRoXG5cdFx0XCI8e25hbWV9PlwiXG5cblx0ZGVmIHRvSlNPTlxuXHRcdHtcblx0XHRcdHR5cGU6ICd0YWcnXG5cdFx0XHRuYW1lcGF0aDogbmFtZXBhdGhcblx0XHRcdGluaGVyaXRzOiBzdXBlcmNsYXNzID8gXCI8e3N1cGVyY2xhc3MubmFtZX0+XCIgOiBudWxsXG5cdFx0XHRsb2M6IGxvY1xuXHRcdFx0ZGVzYzogQGRlc2Ncblx0XHR9XG5cblx0ZGVmIGluaXRpYWxpemUgbmFtZSwgc3VwZXJjbGFzcywgYm9keVxuXHRcdCMgd2hhdCBhYm91dCB0aGUgbmFtZXNwYWNlP1xuXHRcdCMgQG5hbWUgPSBUYWdUeXBlUmVmLm5ldyhuYW1lKVxuXHRcdEB0cmF2ZXJzZWQgPSBub1xuXHRcdEBuYW1lID0gbmFtZVxuXHRcdEBzdXBlcmNsYXNzID0gc3VwZXJjbGFzc1xuXHRcdEBzY29wZSA9IFRhZ1Njb3BlLm5ldyhzZWxmKVxuXHRcdEBib2R5ID0gYmxrX18oYm9keSB8fCBbXSlcblxuXHRkZWYgdmlzaXRcblx0XHRST09ULmVudGl0aWVzLnJlZ2lzdGVyKHNlbGYpICMgd2hhdCBpZiB0aGlzIGlzIG5vdCBsb2NhbD9cblxuXHRcdGZvciBzY29wZSxpIGluIFNUQUNLLnNjb3Blc1xuXHRcdFx0aWYgaSA+IDAgYW5kIHNjb3BlIGlzYSBUYWdTY29wZVxuXHRcdFx0XHQjIHJlZ2lzdGVyIGluc2lkZSBoZXJlP1xuXHRcdFx0XHRzY29wZS5ub2RlLm9wdGlvbig6aGFzTG9jYWxUYWdzLHllcylcblx0XHRcdFx0b3B0aW9uKDpwYXJlbnQsc2NvcGUubm9kZSlcblx0XHRcdFx0YnJlYWtcblx0XHRcdFx0IyBjb25zb2xlLmxvZyBcInRhZyBpcyBsb2NhbCEhIVwiXG5cdFx0IyByZXBsYWNlIHdpdGggc29tZSBhZHZhbmNlZCBsb29rdXA/XG5cdFx0c2NvcGUudmlzaXRcblx0XHRib2R5LnRyYXZlcnNlXG5cblx0ZGVmIGlkXG5cdFx0bmFtZS5pZFxuXG5cdGRlZiB0YWdzcGFjZVxuXHRcdHZhciBjdHggPSBzY29wZS5jbG9zdXJlLnRhZ0NvbnRleHRQYXRoXG5cdFx0bmFtZS5ucyA/IFwie2N0eH0ue25hbWUubnMudG9VcHBlckNhc2V9XCIgOiBjdHhcblxuXHRkZWYganMgb1xuXHRcdHNjb3BlLmNvbnRleHQudmFsdWUgPSBAY3R4ID0gc2NvcGUuZGVjbGFyZSgndGFnJyxudWxsLHN5c3RlbTogeWVzKVxuXG5cdFx0dmFyIG5zID0gbmFtZS5uc1xuXHRcdHZhciBtYXJrID0gbWFya19fKG9wdGlvbigna2V5d29yZCcpKVxuXG5cdFx0dmFyIHBhcmFtcyA9IFtoZWxwZXJzLnNpbmdsZXF1b3RlKG5hbWUubmFtZSldXG5cdFx0dmFyIGNib2R5ID0gYm9keS5jXG5cdFx0IyB2YXIgb3V0Ym9keSA9IGJvZHkuY291bnQgPyBcIiwgZnVuY3Rpb24oe0BjdHguY30pXFx7e2Nib2R5fVxcfVwiIDogJydcblxuXHRcdGlmIHN1cGVyY2xhc3Ncblx0XHRcdCMgV0FSTiB3aGF0IGlmIHRoZSBzdXBlcmNsYXNzIGhhcyBhIG5hbWVzcGFjZT9cblx0XHRcdHBhcmFtcy5wdXNoKGhlbHBlcnMuc2luZ2xlcXVvdGUoc3VwZXJjbGFzcy5uYW1lKSlcblxuXHRcdGlmIGJvZHkuY291bnRcblx0XHRcdGlmIG9wdGlvbig6aGFzTG9jYWxUYWdzKVxuXHRcdFx0XHRwYXJhbXMucHVzaChcImZ1bmN0aW9uKHtAY3R4LmN9LHtzY29wZS5jbG9zdXJlLnRhZ0NvbnRleHRQYXRofSlcXHt7Y2JvZHl9XFx9XCIpXG5cdFx0XHRlbHNlXG5cdFx0XHRcdHBhcmFtcy5wdXNoKFwiZnVuY3Rpb24oe0BjdHguY30pXFx7e2Nib2R5fVxcfVwiKVxuXG5cdFx0dmFyIG1ldGggPSBvcHRpb24oOmV4dGVuc2lvbikgPyAnZXh0ZW5kVGFnJyA6ICdkZWZpbmVUYWcnXG5cdFx0IyByZXR1cm4gXCJ7bWFya317dGFnc3BhY2V9LmV4dGVuZFRhZygne25hbWUubmFtZX0ne291dGJvZHl9KVwiXG5cblx0XHQjIHZhciBzdXAgPSBzdXBlcmNsYXNzIGFuZCBcIixcIiArIGhlbHBlcnMuc2luZ2xlcXVvdGUoc3VwZXJjbGFzcy5mdW5jKSBvciBcIlwiXG5cblx0XHQjIHZhciBvdXQgPSBpZiBuYW1lLmlkXG5cdFx0I1x0XCJ7bWFya317dGFnc3BhY2V9LmRlZmluZVNpbmdsZXRvbigne25hbWUubmFtZX0ne3N1cH17b3V0Ym9keX0pXCJcblx0XHQjIGVsc2VcblxuXHRcdHJldHVybiBcInttYXJrfXt0YWdzcGFjZX0ue21ldGh9KHtwYXJhbXMuam9pbignLCAnKX0pXCJcblxuXHRcdCMgcmV0dXJuIG91dFxuXG5leHBvcnQgY2xhc3MgRnVuYyA8IENvZGVcblxuXHRwcm9wIG5hbWVcblx0cHJvcCBwYXJhbXNcblx0cHJvcCB0YXJnZXRcblx0cHJvcCBvcHRpb25zXG5cdHByb3AgdHlwZVxuXHRwcm9wIGNvbnRleHRcblxuXHRkZWYgc2NvcGV0eXBlIGRvIEZ1bmN0aW9uU2NvcGVcblxuXHRkZWYgaW5pdGlhbGl6ZSBwYXJhbXMsIGJvZHksIG5hbWUsIHRhcmdldCwgb1xuXHRcdCMgcCBcIklOSVQgRnVuY3Rpb24hIVwiLHBhcmFtcyxib2R5LG5hbWVcblx0XHR2YXIgdHlwID0gc2NvcGV0eXBlXG5cdFx0QHRyYXZlcnNlZCA9IG5vXG5cdFx0QGJvZHkgPSBibGtfXyhib2R5KVxuXHRcdEBzY29wZSB8fD0gKG8gYW5kIG86c2NvcGUpIHx8IHR5cC5uZXcoc2VsZilcblx0XHRAc2NvcGUucGFyYW1zID0gQHBhcmFtcyA9IFBhcmFtTGlzdC5uZXcocGFyYW1zKVxuXHRcdEBuYW1lID0gbmFtZSB8fCAnJ1xuXHRcdEB0YXJnZXQgPSB0YXJnZXRcblx0XHRAb3B0aW9ucyA9IG9cblx0XHRAdHlwZSA9IDpmdW5jdGlvblxuXHRcdEB2YXJpYWJsZSA9IG51bGxcblx0XHRzZWxmXG5cblx0ZGVmIHZpc2l0XG5cdFx0c2NvcGUudmlzaXRcblx0XHRAY29udGV4dCA9IHNjb3BlLnBhcmVudFxuXHRcdEBwYXJhbXMudHJhdmVyc2Vcblx0XHRAYm9keS50cmF2ZXJzZSAjIHNvIHNvb24/XG5cdFx0XG5cblx0ZGVmIGpzIG9cblx0XHRib2R5LmNvbnN1bWUoSW1wbGljaXRSZXR1cm4ubmV3KSB1bmxlc3Mgb3B0aW9uKDpub3JldHVybilcblx0XHR2YXIgaW5kID0gYm9keS5AaW5kZW50YXRpb25cblx0XHQjIHZhciBzID0gaW5kIGFuZCBpbmQuQG9wZW5cblx0XHQjIHAgXCJpbmRlbnQgZnVuY3Rpb24/IHtib2R5LkBpbmRlbnRhdGlvbn0ge3N9IHtzOmdlbmVyYXRlZH0ge2JvZHkuY291bnR9XCJcblx0XHRib2R5LkBpbmRlbnRhdGlvbiA9IG51bGwgaWYgaW5kIGFuZCBpbmQuaXNHZW5lcmF0ZWRcblx0XHR2YXIgY29kZSA9IHNjb3BlLmMoaW5kZW50OiAoIWluZCBvciAhaW5kLmlzR2VuZXJhdGVkKSwgYnJhY2VzOiB5ZXMpXG5cblx0XHQjIGFyZ3MgPSBwYXJhbXMubWFwIGRvIHxwYXJ8IHBhci5uYW1lXG5cdFx0IyBoZWFkID0gcGFyYW1zLm1hcCBkbyB8cGFyfCBwYXIuY1xuXHRcdCMgY29kZSA9IFtoZWFkLGJvZHkuYyhleHByZXNzaW9uOiBubyldLmZsYXR0ZW5fXy5jb21wYWN0LmpvaW4oXCJcXG5cIikud3JhcFxuXHRcdCMgRklYTUUgY3JlYXRpbmcgdGhlIGZ1bmN0aW9uLW5hbWUgdGhpcyB3YXkgaXMgcHJvbmUgdG8gY3JlYXRlIG5hbWluZy1jb2xsaXNpb25zXG5cdFx0IyB3aWxsIG5lZWQgdG8gd3JhcCB0aGUgdmFsdWUgaW4gYSBGdW5jdGlvbk5hbWUgd2hpY2ggdGFrZXMgY2FyZSBvZiBsb29raW5nIHVwIHNjb3BlXG5cdFx0IyBhbmQgcG9zc2libHkgZGVhbGluZyB3aXRoIGl0XG5cdFx0dmFyIG5hbWUgPSB0eXBlb2YgQG5hbWUgPT0gJ3N0cmluZycgPyBAbmFtZSA6IEBuYW1lLmNcblx0XHR2YXIgbmFtZSA9IG5hbWUgPyAnICcgKyBuYW1lLnJlcGxhY2UoL1xcLi9nLCdfJykgOiAnJ1xuXHRcdHZhciBvdXQgPSBcImZ1bmN0aW9ue25hbWV9KHtwYXJhbXMuY30pIFwiICsgY29kZVxuXHRcdG91dCA9IFwiKHtvdXR9KSgpXCIgaWYgb3B0aW9uKDpldmFsKVxuXHRcdHJldHVybiBvdXRcblxuXHRkZWYgc2hvdWxkUGFyZW50aGVzaXplIHBhciA9IHVwXG5cdFx0cGFyIGlzYSBDYWxsICYmIHBhci5jYWxsZWUgPT0gc2VsZlxuXHRcdCMgaWYgdXAgYXMgYSBjYWxsPyBPbmx5IGlmIHdlIGFyZSBcblxuZXhwb3J0IGNsYXNzIExhbWJkYSA8IEZ1bmNcblx0ZGVmIHNjb3BldHlwZSBkbyBMYW1iZGFTY29wZVxuXG5leHBvcnQgY2xhc3MgVGFnRnJhZ21lbnRGdW5jIDwgRnVuY1xuXG4jIE1ldGhvZERlY2xhcmF0aW9uXG4jIENyZWF0ZSBhIHNoYXJlZCBib2R5P1xuXG5leHBvcnQgY2xhc3MgTWV0aG9kRGVjbGFyYXRpb24gPCBGdW5jXG5cblx0cHJvcCB2YXJpYWJsZVxuXG5cdGRlZiBzY29wZXR5cGUgZG8gTWV0aG9kU2NvcGVcblxuXHRkZWYgY29uc3VtZSBub2RlXG5cdFx0aWYgbm9kZSBpc2EgUmV0dXJuXG5cdFx0XHRvcHRpb24oJ3JldHVybicseWVzKVxuXHRcdFx0cmV0dXJuIHNlbGZcblx0XHRzdXBlclxuXG5cdGRlZiBtZXRhZGF0YVxuXHRcdHtcblx0XHRcdHR5cGU6IFwibWV0aG9kXCJcblx0XHRcdG5hbWU6IFwiXCIgKyBuYW1lXG5cdFx0XHRuYW1lcGF0aDogbmFtZXBhdGhcblx0XHRcdHBhcmFtczogQHBhcmFtcy5tZXRhZGF0YVxuXHRcdFx0ZGVzYzogQGRlc2Ncblx0XHRcdHNjb3BlbnI6IHNjb3BlLkBuclxuXHRcdFx0bG9jOiBsb2Ncblx0XHR9XG5cblx0ZGVmIGxvY1xuXHRcdGlmIGxldCBkID0gb3B0aW9uKDpkZWYpXG5cdFx0XHRbZC5AbG9jLGJvZHkubG9jWzFdXVxuXHRcdGVsc2Vcblx0XHRcdFswLDBdXG5cdFx0XG5cblx0ZGVmIHRvSlNPTlxuXHRcdG1ldGFkYXRhXG5cblx0ZGVmIG5hbWVwYXRoXG5cdFx0cmV0dXJuIEBuYW1lcGF0aCBpZiBAbmFtZXBhdGhcblx0XHRcblx0XHR2YXIgbmFtZSA9IFN0cmluZyhuYW1lKVxuXHRcdHZhciBzZXAgPSAob3B0aW9uKCdzdGF0aWMnKSA/ICcuJyA6ICcjJylcblx0XHRpZiB0YXJnZXRcblx0XHRcdEBuYW1lcGF0aCA9IEB0YXJnZXQubmFtZXBhdGggKyBzZXAgKyBuYW1lXG5cdFx0ZWxzZVxuXHRcdFx0QG5hbWVwYXRoID0gJyYnICsgbmFtZVxuXG5cdGRlZiB2aXNpdFxuXHRcdCMgQGRlc2MgPSBzdGFjay5zdGFzaC5wbHVjayhDb21tZW50KVxuXHRcdCMgQGRlc2MgPSBzdGFjay5zdGFzaC5wbHVjayhDb21tZW50KVxuXHRcdCMgcHJlYnJlYWsgIyBtYWtlIHN1cmUgdGhpcyBoYXMgYSBicmVhaz9cblx0XHRzY29wZS52aXNpdFxuXG5cdFx0aWYgU3RyaW5nKG5hbWUpID09ICdpbml0aWFsaXplJ1xuXHRcdFx0c2VsZi50eXBlID0gOmNvbnN0cnVjdG9yXG5cblx0XHRpZiBvcHRpb24oOmdyZWVkeSlcblx0XHRcdHdhcm4gXCJkZXByZWNhdGVkXCJcblx0XHRcdCMgc2V0KGdyZWVkeTogdHJ1ZSlcblx0XHRcdCMgcCBcIkJPRFkgRVhQUkVTU0lPTlMhISBUaGlzIGlzIGEgZnJhZ21lbnRcIlxuXHRcdFx0dmFyIHRyZWUgPSBUYWdUcmVlLm5ld1xuXHRcdFx0QGJvZHkgPSBib2R5LmNvbnN1bWUodHJlZSlcblx0XHRcdCMgYm9keS5ub2RlcyA9IFtBcnIubmV3KGJvZHkubm9kZXMpXVxuXHRcdFxuXHRcdEBjb250ZXh0ID0gc2NvcGUucGFyZW50LmNsb3N1cmVcblx0XHRAcGFyYW1zLnRyYXZlcnNlXG5cblx0XHRpZiB0YXJnZXQgaXNhIFNlbGZcblx0XHRcdEB0YXJnZXQgPSBAY29udGV4dC5jb250ZXh0XG5cdFx0XHRzZXQoc3RhdGljOiB5ZXMpXG5cblx0XHRpZiBjb250ZXh0IGlzYSBDbGFzc1Njb3BlXG5cdFx0XHRjb250ZXh0LmFubm90YXRlKHNlbGYpXG5cdFx0XHRAdGFyZ2V0IHx8PSBjb250ZXh0LmNvbnRleHRcblx0XHRcdCMgcmVnaXN0ZXIgYXMgY2xhc3MtbWV0aG9kP1xuXHRcdFx0IyBzaG91bGQgcmVnaXN0ZXIgZm9yIHRoaXNcblx0XHRcdCMgY29uc29sZS5sb2cgXCJjb250ZXh0IGlzIGNsYXNzc2NvcGUge0BuYW1lfVwiXG5cblx0XHRpZiAhQHRhcmdldFxuXHRcdFx0IyBzaG91bGQgbm90IGJlIHJlZ2lzdGVyZWQgb24gdGhlIG91dGVybW9zdCBjbG9zdXJlP1xuXHRcdFx0QHZhcmlhYmxlID0gY29udGV4dC5yZWdpc3RlcihuYW1lLCBzZWxmLCB0eXBlOiAnbWV0aCcpXG5cblx0XHRST09ULmVudGl0aWVzLmFkZChuYW1lcGF0aCxzZWxmKVxuXHRcdEBib2R5LnRyYXZlcnNlICMgc28gc29vbj9cblx0XHRzZWxmXG5cblx0ZGVmIHN1cGVybmFtZVxuXHRcdHR5cGUgPT0gOmNvbnN0cnVjdG9yID8gdHlwZSA6IG5hbWVcblxuXG5cdCMgRklYTUUgZXhwb3J0IGdsb2JhbCBldGMgYXJlIE5PVCB2YWxpZCBmb3IgbWV0aG9kcyBpbnNpZGUgYW55IG90aGVyIHNjb3BlIHRoYW5cblx0IyB0aGUgb3V0ZXJtb3N0IHNjb3BlIChyb290KVxuXG5cdGRlZiBqcyBvXG5cdFx0IyBGSVhNRSBEbyB0aGlzIGluIHRoZSBncmFtbWFyIC0gcmVtbmFudHMgb2Ygb2xkIGltcGxlbWVudGF0aW9uXG5cdFx0dW5sZXNzIHR5cGUgPT0gOmNvbnN0cnVjdG9yIG9yIG9wdGlvbig6bm9yZXR1cm4pXG5cdFx0XHRpZiBvcHRpb24oOmdyZWVkeSlcblx0XHRcdFx0IyBoYWFhY2tcblx0XHRcdFx0Ym9keS5jb25zdW1lKEdyZWVkeVJldHVybi5uZXcpXG5cdFx0XHRlbHNlXG5cdFx0XHRcdGJvZHkuY29uc3VtZShJbXBsaWNpdFJldHVybi5uZXcpXG5cblx0XHR2YXIgY29kZSA9IHNjb3BlLmMoaW5kZW50OiB5ZXMsIGJyYWNlczogeWVzKVxuXG5cdFx0IyBzYW1lIGZvciBGdW5jIC0tIHNob3VsZCBnZW5lcmFsaXplXG5cdFx0dmFyIG5hbWUgPSB0eXBlb2YgQG5hbWUgPT0gJ3N0cmluZycgPyBAbmFtZSA6IEBuYW1lLmNcblx0XHRuYW1lID0gbmFtZS5yZXBsYWNlKC9cXC4vZywnXycpXG5cblx0XHQjIHZhciBuYW1lID0gc2VsZi5uYW1lLmMucmVwbGFjZSgvXFwuL2csJ18nKSAjIFdIQVQ/XG5cdFx0dmFyIGZvb3QgPSBbXVxuXG5cdFx0dmFyIGxlZnQgPSBcIlwiXG5cdFx0dmFyIGZ1bmMgPSBcIih7cGFyYW1zLmN9KVwiICsgY29kZSAjIC53cmFwXG5cdFx0dmFyIHRhcmdldCA9IHNlbGYudGFyZ2V0XG5cdFx0dmFyIGRlY2wgPSAhb3B0aW9uKDpnbG9iYWwpIGFuZCAhb3B0aW9uKDpleHBvcnQpXG5cblx0XHRpZiB0YXJnZXQgaXNhIFNjb3BlQ29udGV4dFxuXHRcdFx0IyB0aGUgdGFyZ2V0IGlzIGEgc2NvcGUgY29udGV4dFxuXHRcdFx0dGFyZ2V0ID0gbnVsbFxuXG5cdFx0dmFyIGN0eCA9IGNvbnRleHRcblx0XHR2YXIgb3V0ID0gXCJcIlxuXHRcdHZhciBtYXJrID0gbWFya19fKG9wdGlvbignZGVmJykpXG5cdFx0IyBpZiBjdHggXG5cblx0XHR2YXIgZm5hbWUgPSBzeW1fXyhzZWxmLm5hbWUpXG5cdFx0IyBjb25zb2xlLmxvZyBcInN5bWJvbGl6ZSB7c2VsZi5uYW1lfSAtLSB7Zm5hbWV9XCJcblx0XHR2YXIgZmRlY2wgPSBmbmFtZSAjIGRlY2wgPyBmbmFtZSA6ICcnXG5cblx0XHRpZiBjdHggaXNhIENsYXNzU2NvcGUgYW5kICF0YXJnZXRcblx0XHRcdGlmIHR5cGUgPT0gOmNvbnN0cnVjdG9yXG5cdFx0XHRcdG91dCA9IFwie21hcmt9ZnVuY3Rpb24ge2ZuYW1lfXtmdW5jfVwiXG5cdFx0XHRlbGlmIG9wdGlvbig6c3RhdGljKVxuXHRcdFx0XHRvdXQgPSBcInttYXJrfXtjdHguY29udGV4dC5jfS57Zm5hbWV9ID0gZnVuY3Rpb24ge2Z1bmN9XCJcblx0XHRcdGVsc2Vcblx0XHRcdFx0b3V0ID0gXCJ7bWFya317Y3R4LmNvbnRleHQuY30ucHJvdG90eXBlLntmbmFtZX0gPSBmdW5jdGlvbiB7ZnVuY31cIlxuXG5cdFx0ZWxpZiBjdHggaXNhIFJvb3RTY29wZSBhbmQgIXRhcmdldFxuXHRcdFx0IyByZWdpc3RlciBtZXRob2QgYXMgYSByb290LWZ1bmN0aW9uLCBidXQgd2l0aCBhdXRvLWNhbGw/IGhtbVxuXHRcdFx0IyBzaG91bGQgcHJvYmFibHkgc2V0IHVzaW5nIHZhcmlhYmxlIGRpcmVjdGx5IGluc3RlYWQsIG5vP1xuXHRcdFx0b3V0ID0gXCJ7bWFya31mdW5jdGlvbiB7ZmRlY2x9e2Z1bmN9XCJcblxuXHRcdGVsaWYgdGFyZ2V0IGFuZCBvcHRpb24oOnN0YXRpYylcblx0XHRcdG91dCA9IFwie21hcmt9e3RhcmdldC5jfS57Zm5hbWV9ID0gZnVuY3Rpb24ge2Z1bmN9XCJcblxuXHRcdGVsaWYgdGFyZ2V0XG5cdFx0XHRvdXQgPSBcInttYXJrfXt0YXJnZXQuY30ucHJvdG90eXBlLntmbmFtZX0gPSBmdW5jdGlvbiB7ZnVuY31cIlxuXHRcdGVsc2Vcblx0XHRcdG91dCA9IFwie21hcmt9ZnVuY3Rpb24ge2ZkZWNsfXtmdW5jfVwiXG5cblx0XHRpZiBvcHRpb24oOmdsb2JhbClcblx0XHRcdG91dCA9IFwie2ZuYW1lfSA9IHtvdXR9XCJcblxuXHRcdGlmIG9wdGlvbig6ZXhwb3J0KVxuXHRcdFx0b3V0ID0gXCJ7b3V0fTsgZXhwb3J0cy57Zm5hbWV9ID0ge2ZuYW1lfTtcIlxuXHRcdFx0b3V0ID0gXCJ7b3V0fTsgcmV0dXJuIHtmbmFtZX07XCIgaWYgb3B0aW9uKDpyZXR1cm4pXG5cblx0XHRlbGlmIG9wdGlvbig6cmV0dXJuKVxuXHRcdFx0b3V0ID0gXCJyZXR1cm4ge291dH1cIlxuXG5cdFx0b3V0XG5cblxuZXhwb3J0IGNsYXNzIFRhZ0ZyYWdtZW50RGVjbGFyYXRpb24gPCBNZXRob2REZWNsYXJhdGlvblxuXG5cbmV4cG9ydCBjbGFzcyBQcm9wZXJ0eURlY2xhcmF0aW9uIDwgTm9kZVxuXG5cdHZhciBwcm9wVGVtcGxhdGUgPSAnJydcblx0JHtoZWFkZXJzfVxuXHQke3BhdGh9LiR7Z2V0dGVyfSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gJHtnZXR9OyB9XG5cdCR7cGF0aH0uJHtzZXR0ZXJ9ID0gZnVuY3Rpb24odil7ICR7c2V0fTsgcmV0dXJuIHRoaXM7IH1cblx0JHtpbml0fVxuXHQnJydcblxuXHR2YXIgcHJvcFdhdGNoVGVtcGxhdGUgPSAnJydcblx0JHtoZWFkZXJzfVxuXHQke3BhdGh9LiR7Z2V0dGVyfSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gJHtnZXR9OyB9XG5cdCR7cGF0aH0uJHtzZXR0ZXJ9ID0gZnVuY3Rpb24odil7XG5cdFx0dmFyIGEgPSB0aGlzLiR7Z2V0dGVyfSgpO1xuXHRcdGlmKHYgIT0gYSkgeyAke3NldH07IH1cblx0XHRpZih2ICE9IGEpIHsgJHtvbmRpcnR5fSB9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0JHtpbml0fVxuXHQnJydcblxuXHRwcm9wIG5hbWVcblx0cHJvcCBvcHRpb25zXG5cblx0ZGVmIGluaXRpYWxpemUgbmFtZSwgb3B0aW9ucywgdG9rZW5cblx0XHRAdG9rZW4gPSB0b2tlblxuXHRcdEB0cmF2ZXJzZWQgPSBub1xuXHRcdEBuYW1lID0gbmFtZVxuXHRcdEBvcHRpb25zID0gb3B0aW9ucyB8fCBPYmoubmV3KEFzc2lnbkxpc3QubmV3KVxuXG5cdGRlZiB2aXNpdFxuXHRcdEBvcHRpb25zLnRyYXZlcnNlXG5cdFx0c2VsZlxuXG5cdCMgVGhpcyB3aWxsIHNvb24gc3VwcG9ydCBiaW5kaW5ncyAvIGxpc3RlbmVycyBldGMsIG11Y2ggbW9yZVxuXHQjIGFkdmFuY2VkIGdlbmVyYXRlZCBjb2RlIGJhc2VkIG9uIG9wdGlvbnMgcGFzc2VkIGluLlxuXHRkZWYgY1xuXHRcdHZhciBvID0gb3B0aW9uc1xuXHRcdHZhciBhc3QgPSBcIlwiXG5cdFx0dmFyIGtleSA9IG5hbWUuanNcblx0XHR2YXIgc2NvcGUgPSBTVEFDSy5zY29wZVxuXG5cdFx0dmFyIGFkZERlc2MgPSBvLmtleXM6bGVuZ3RoXG5cblx0XHR2YXIgcGFycyA9IG8uaGFzaFxuXG5cdFx0dmFyIGlzQXR0ciA9IChAdG9rZW4gYW5kIFN0cmluZyhAdG9rZW4pID09ICdhdHRyJykgb3Igby5rZXkoOmF0dHIpXG5cblx0XHR2YXIganMgPVxuXHRcdFx0a2V5OiBrZXlcblx0XHRcdGdldHRlcjoga2V5XG5cdFx0XHRzZXR0ZXI6IHN5bV9fKFwic2V0LXtrZXl9XCIpXG5cdFx0XHRzY29wZTogXCJ7c2NvcGUuY29udGV4dC5jfVwiIFxuXHRcdFx0cGF0aDogJyR7c2NvcGV9LnByb3RvdHlwZSdcblx0XHRcdHNldDogXCJ0aGlzLl97a2V5fSA9IHZcIlxuXHRcdFx0Z2V0OiBcInRoaXMuX3trZXl9XCJcblx0XHRcdGluaXQ6IFwiXCJcblx0XHRcdGhlYWRlcnM6IFwiXCJcblx0XHRcdG9uZGlydHk6IFwiXCJcblxuXG5cdFx0aWYgcGFyczppbmxpbmVcblx0XHRcdGlmIHBhcnM6aW5saW5lIGlzYSBCb29sIGFuZCAhcGFyczppbmxpbmUudHJ1dGh5XG5cdFx0XHRcdG8ucmVtb3ZlKCdpbmxpbmUnKVxuXHRcdFx0XHQjIHAgXCJkb250IG1ha2UgYXR0ciBpbmxpbmUoISlcIlxuXHRcdFx0XHRyZXR1cm4gXCJJbWJhLntAdG9rZW59KHtqczpzY29wZX0sJ3tuYW1lLnZhbHVlfScse28uY30pXCIucmVwbGFjZSgnLHt9KScsJyknKVxuXG5cdFx0XHQjIHAgXCJwYXJzIGlubGluZT8hPyB7cGFyczppbmxpbmV9XCIsIHR5cGVvZiBwYXJzOmlubGluZVxuXG5cdFx0dmFyIHRwbCA9IHByb3BUZW1wbGF0ZVxuXG5cdFx0by5hZGQoJ25hbWUnLFN5bWJvbC5uZXcoa2V5KSlcblxuXHRcdGlmIHBhcnM6d2F0Y2hcblx0XHRcdCMgcCBcIndhdGNoIGlzIGEgcHJvcGVydHkge3BhcnM6d2F0Y2h9XCJcblx0XHRcdHRwbCA9IHByb3BXYXRjaFRlbXBsYXRlIHVubGVzcyBwYXJzOndhdGNoIGlzYSBCb29sIGFuZCAhcGFyczp3YXRjaC50cnV0aHlcblx0XHRcdHZhciB3Zm4gPSBcIntrZXl9RGlkU2V0XCJcblxuXHRcdFx0aWYgcGFyczp3YXRjaCBpc2EgU3ltYm9sXG5cdFx0XHRcdHdmbiA9IHBhcnM6d2F0Y2hcblx0XHRcdGVsaWYgcGFyczp3YXRjaCBpc2EgQm9vbFxuXHRcdFx0XHRvLmtleSg6d2F0Y2gpLnZhbHVlID0gU3ltYm9sLm5ldyhcIntrZXl9RGlkU2V0XCIpXG5cblx0XHRcdHZhciBmbiA9IE9QKCcuJyxUaGlzLm5ldyx3Zm4pXG5cdFx0XHRqczpvbmRpcnR5ID0gT1AoJyYmJyxmbixDQUxMKGZuLFsndicsJ2EnLFwidGhpcy5fX3trZXl9XCJdKSkuY1xuXG5cdFx0aWYgcGFyczpvYnNlcnZlXG5cdFx0XHRpZiBwYXJzOm9ic2VydmUgaXNhIEJvb2xcblx0XHRcdFx0by5rZXkoOm9ic2VydmUpLnZhbHVlID0gU3ltYm9sLm5ldyhcIntrZXl9RGlkRW1pdFwiKVxuXG5cdFx0XHR0cGwgPSBwcm9wV2F0Y2hUZW1wbGF0ZVxuXHRcdFx0anM6b25kaXJ0eSA9IFwiSW1iYS5vYnNlcnZlUHJvcGVydHkodGhpcywne2tleX0nLHtvLmtleSg6b2JzZXJ2ZSkudmFsdWUuY30sdixhKTtcIiArwqAoanM6b25kaXJ0eSBvciAnJylcblx0XHRcdCMgT1AoJyYmJyxmbixDQUxMKGZuLFsndicsJ2EnLFwidGhpcy5fX3trZXl9XCJdKSkuY1xuXG5cdFx0aWYgKEB0b2tlbiBhbmQgU3RyaW5nKEB0b2tlbikgPT0gJ2F0dHInKSBvciBvLmtleSg6ZG9tKSBvciBvLmtleSg6YXR0cilcblx0XHRcdGxldCBhdHRyS2V5ID0gby5rZXkoOmRvbSkgaXNhIFN0ciA/IG8ua2V5KDpkb20pIDogbmFtZS52YWx1ZVxuXHRcdFx0IyBuZWVkIHRvIG1ha2Ugc3VyZSBvIGhhcyBhIGtleSBmb3IgYXR0ciB0aGVuIC0gc28gdGhhdCB0aGUgZGVsZWdhdGUgY2FuIGtub3c/XG5cdFx0XHRqczpzZXQgPSBcInRoaXMuc2V0QXR0cmlidXRlKCd7YXR0cktleX0nLHYpXCJcblx0XHRcdGpzOmdldCA9IFwidGhpcy5nZXRBdHRyaWJ1dGUoJ3thdHRyS2V5fScpXCJcblxuXHRcdGVsaWYgby5rZXkoOmRlbGVnYXRlKVxuXHRcdFx0IyBpZiB3ZSBoYXZlIGEgZGVsZWdhdGVcblx0XHRcdGpzOnNldCA9IFwidiA9IHRoaXMuX197a2V5fS5kZWxlZ2F0ZS5zZXQodGhpcywne2tleX0nLHYsdGhpcy5fX3trZXl9KVwiXG5cdFx0XHRqczpnZXQgPSBcInRoaXMuX197a2V5fS5kZWxlZ2F0ZS5nZXQodGhpcywne2tleX0nLHRoaXMuX197a2V5fSlcIlxuXG5cblxuXHRcdGlmIHBhcnM6ZGVmYXVsdFxuXHRcdFx0aWYgby5rZXkoOmRvbSlcblx0XHRcdFx0IyBGSVhNRSBnbyB0aHJvdWdoIGNsYXNzLW1ldGhvZCBzZXRBdHRyaWJ1dGUgaW5zdGVhZFxuXHRcdFx0XHRqczppbml0ID0gXCJ7anM6c2NvcGV9LmRvbSgpLnNldEF0dHJpYnV0ZSgne2tleX0nLHtwYXJzOmRlZmF1bHQuY30pO1wiXG5cdFx0XHRlbHNlXG5cdFx0XHRcdCMgaWYgdGhpcyBpcyBub3QgYSBwcmltaXRpdmUgLSBpdCBNVVNUIGJlIGluY2x1ZGVkIGluIHRoZVxuXHRcdFx0XHQjIGdldHRlciAvIHNldHRlciBpbnN0ZWFkXG5cdFx0XHRcdGpzOmluaXQgPSBcIntqczpzY29wZX0ucHJvdG90eXBlLl97a2V5fSA9IHtwYXJzOmRlZmF1bHQuY307XCJcblxuXHRcdGlmIG8ua2V5KDpjaGFpbmFibGUpXG5cdFx0XHRqczpnZXQgPSBcInYgIT09IHVuZGVmaW5lZCA/ICh0aGlzLntqczpzZXR0ZXJ9KHYpLHRoaXMpIDoge2pzOmdldH1cIlxuXG5cblx0XHRqczpvcHRpb25zID0gby5jXG5cblx0XHRpZiBhZGREZXNjXG5cdFx0XHRqczpoZWFkZXJzID0gXCJ7anM6cGF0aH0uX197anM6Z2V0dGVyfSA9IHtqczpvcHRpb25zfTtcIlxuXG5cdFx0dmFyIHJlZyA9IC9cXCRcXHsoXFx3KylcXH0vZ21cblx0XHQjIHZhciB0cGwgPSBvLmtleSg6d2F0Y2gpID8gcHJvcFdhdGNoVGVtcGxhdGUgOiBwcm9wVGVtcGxhdGVcblx0XHR2YXIgb3V0ID0gdHBsLnJlcGxhY2UocmVnKSBkbyB8bSxhfCBqc1thXVxuXHRcdCMgcnVuIGFub3RoZXIgdGltZSBmb3IgbmVzdGluZy4gaGFja3lcblx0XHRvdXQgPSBvdXQucmVwbGFjZShyZWcpIGRvIHxtLGF8IGpzW2FdXG5cdFx0IyBvdXQgPSBvdXQucmVwbGFjZSgvXFxuXFxzKiQvLCcnKVxuXHRcdG91dCA9IG91dC5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcblx0XHRcblx0XHQjIGlmIG8ua2V5KDp2KVxuXHRcdHJldHVybiBvdXRcblxuXG5cbiMgTGl0ZXJhbHMgc2hvdWxkIHByb2JhYmx5IG5vdCBpbmhlcml0IGZyb20gdGhlIHNhbWUgcGFyZW50XG4jIGFzIGFycmF5cywgdHVwbGVzLCBvYmplY3RzIHdvdWxkIGJlIGJldHRlciBvZmYgaW5oZXJpdGluZ1xuIyBmcm9tIGxpc3Rub2RlLlxuXG5leHBvcnQgY2xhc3MgTGl0ZXJhbCA8IFZhbHVlTm9kZVxuXHRcblx0ZGVmIGluaXRpYWxpemUgdlxuXHRcdEB0cmF2ZXJzZWQgPSBub1xuXHRcdEBleHByZXNzaW9uID0geWVzXG5cdFx0QGNhY2hlID0gbnVsbFxuXHRcdEByYXcgPSBudWxsXG5cdFx0QHZhbHVlID0gdlxuXG5cdGRlZiB0b1N0cmluZ1xuXHRcdFwiXCIgKyB2YWx1ZVxuXG5cdGRlZiBoYXNTaWRlRWZmZWN0c1xuXHRcdGZhbHNlXG5cdFx0XG5cbmV4cG9ydCBjbGFzcyBCb29sIDwgTGl0ZXJhbFxuXHRcblx0IyBTaG91bGQga2VlcCB0aGUgcmVhbCB2YWx1ZSAoeWVzL25vL3RydWUvZmFsc2UpP1xuXHRkZWYgaW5pdGlhbGl6ZSB2XG5cdFx0QHZhbHVlID0gdlxuXHRcdEByYXcgPSBTdHJpbmcodikgPT0gXCJ0cnVlXCIgPyB0cnVlIDogZmFsc2VcblxuXHRkZWYgY2FjaGVcblx0XHRzZWxmXG5cblx0ZGVmIGlzUHJpbWl0aXZlXG5cdFx0eWVzXG5cblx0ZGVmIHRydXRoeVxuXHRcdCMgcCBcImJvb2wgaXMgdHJ1dGh5PyB7dmFsdWV9XCJcblx0XHRTdHJpbmcodmFsdWUpID09IFwidHJ1ZVwiXG5cdFx0IyB5ZXNcblxuXHRkZWYganMgb1xuXHRcdFN0cmluZyhAdmFsdWUpXG5cblx0ZGVmIGNcblx0XHRTVEFDSy5AY291bnRlciArPSAxXG5cdFx0IyB1bmRlZmluZWQgc2hvdWxkIG5vdCBiZSBhIGJvb2xcblx0XHRTdHJpbmcoQHZhbHVlKVxuXHRcdCMgQHJhdyA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiXG5cblx0ZGVmIHRvSlNPTlxuXHRcdHt0eXBlOiAnQm9vbCcsIHZhbHVlOiBAdmFsdWV9XG5cbmV4cG9ydCBjbGFzcyBVbmRlZmluZWQgPCBMaXRlcmFsXG5cdFxuXHRkZWYgaXNQcmltaXRpdmVcblx0XHR5ZXNcblxuXHRkZWYgY1xuXHRcdG1hcmtfXyhAdmFsdWUpICsgXCJ1bmRlZmluZWRcIlxuXG5leHBvcnQgY2xhc3MgTmlsIDwgTGl0ZXJhbFxuXHRcblx0ZGVmIGlzUHJpbWl0aXZlXG5cdFx0eWVzXG5cblx0ZGVmIGNcblx0XHRtYXJrX18oQHZhbHVlKSArIFwibnVsbFwiXG5cbmV4cG9ydCBjbGFzcyBUcnVlIDwgQm9vbFxuXG5cdGRlZiByYXdcblx0XHR0cnVlXG5cblx0ZGVmIGNcblx0XHRtYXJrX18oQHZhbHVlKSArIFwidHJ1ZVwiXG5cdFx0XG5leHBvcnQgY2xhc3MgRmFsc2UgPCBCb29sXG5cblx0ZGVmIHJhd1xuXHRcdGZhbHNlXG5cblx0ZGVmIGNcblx0XHRtYXJrX18oQHZhbHVlKSArIFwiZmFsc2VcIlxuXG5leHBvcnQgY2xhc3MgTnVtIDwgTGl0ZXJhbFxuXHRcblx0IyB2YWx1ZSBpcyB0b2tlbiAtIHNob3VsZCBub3QgYmVcblx0ZGVmIGluaXRpYWxpemUgdlxuXHRcdEB0cmF2ZXJzZWQgPSBub1xuXHRcdEB2YWx1ZSA9IHZcblxuXHRkZWYgdG9TdHJpbmdcblx0XHRTdHJpbmcoQHZhbHVlKVxuXG5cdGRlZiBpc1ByaW1pdGl2ZSBkZWVwXG5cdFx0eWVzXG5cblx0ZGVmIHNob3VsZFBhcmVudGhlc2l6ZSBwYXIgPSB1cFxuXHRcdHBhciBpc2EgQWNjZXNzIGFuZCBwYXIubGVmdCA9PSBzZWxmXG5cblx0ZGVmIGpzIG9cblx0XHR2YXIgbnVtID0gU3RyaW5nKEB2YWx1ZSlcblx0XHQjIGNvbnNvbGUubG9nIFwiY29tcGlsZWQgbnVtIHRvIHtudW19XCJcblx0XHRyZXR1cm4gbnVtXG5cblx0ZGVmIGMgb1xuXHRcdHJldHVybiBzdXBlcihvKSBpZiBAY2FjaGVcblx0XHR2YXIganMgPSBTdHJpbmcoQHZhbHVlKVxuXHRcdHZhciBwYXIgPSBTVEFDSy5jdXJyZW50XG5cdFx0dmFyIHBhcmVuID0gcGFyIGlzYSBBY2Nlc3MgYW5kIHBhci5sZWZ0ID09IHNlbGZcblx0XHQjIG9ubHkgaWYgdGhpcyBpcyB0aGUgcmlnaHQgcGFydCBvZiB0ZWggYWNjZXNcblx0XHQjIGNvbnNvbGUubG9nIFwic2hvdWxkIHBhcmVuPz8ge3Nob3VsZFBhcmVudGhlc2l6ZX1cIlxuXHRcdHBhcmVuID8gXCIoe21hcmtfXyhAdmFsdWUpfVwiICsganMgKyBcIilcIiA6IChtYXJrX18oQHZhbHVlKSArIGpzKVxuXHRcdCMgQGNhY2hlID8gc3VwZXIobykgOiBTdHJpbmcoQHZhbHVlKVxuXG5cdGRlZiBjYWNoZSBvXG5cdFx0IyBwIFwiY2FjaGUgbnVtXCIsb1xuXHRcdHJldHVybiBzZWxmIHVubGVzcyBvIGFuZCAobzpjYWNoZSBvciBvOnBvb2wpXG5cdFx0c3VwZXIobylcblxuXHRkZWYgcmF3XG5cdFx0IyByZWFsbHk/XG5cdFx0SlNPTi5wYXJzZShTdHJpbmcodmFsdWUpKVxuXG5cdGRlZiB0b0pTT05cblx0XHR7dHlwZTogdHlwZU5hbWUsIHZhbHVlOiByYXd9XG5cbiMgc2hvdWxkIGJlIHF1b3RlZCBubz9cbiMgd2hhdCBhYm91dCBzdHJpbmdzIGluIG9iamVjdC1saXRlcmFscz9cbiMgd2Ugd2FudCB0byBiZSBhYmxlIHRvIHNlZSBpZiB0aGUgdmFsdWVzIGFyZSBhbGxvd2VkXG5leHBvcnQgY2xhc3MgU3RyIDwgTGl0ZXJhbFxuXG5cdGRlZiBpbml0aWFsaXplIHZcblx0XHRAdHJhdmVyc2VkID0gbm9cblx0XHRAZXhwcmVzc2lvbiA9IHllc1xuXHRcdEBjYWNoZSA9IG51bGxcblx0XHRAdmFsdWUgPSB2XG5cdFx0IyBzaG91bGQgZ3JhYiB0aGUgYWN0dWFsIHZhbHVlIGltbWVkaWF0ZWx5P1xuXG5cdGRlZiBpc1N0cmluZ1xuXHRcdHllc1xuXG5cdGRlZiBpc1ByaW1pdGl2ZSBkZWVwXG5cdFx0eWVzXG5cblx0ZGVmIHJhd1xuXHRcdCMgSlNPTi5wYXJzZSByZXF1aXJlcyBkb3VibGUtcXVvdGVkIHN0cmluZ3MsXG5cdFx0IyB3aGlsZSBldmFsIGFsc28gYWxsb3dzIHNpbmdsZSBxdW90ZXMuIFxuXHRcdCMgTkVYVCBldmFsIGlzIG5vdCBhY2Nlc3NpYmxlIGxpa2UgdGhpc1xuXHRcdCMgV0FSTklORyBUT0RPIGJlIGNhcmVmdWwhIC0gc2hvdWxkIGNsZWFuIHVwXG5cblx0XHRAcmF3IHx8PSBTdHJpbmcodmFsdWUpLnNsaWNlKDEsLTEpICMgaW5jcmVkaWJseSBzdHVwaWQgc29sdXRpb25cblxuXHRkZWYgaXNWYWxpZElkZW50aWZpZXJcblx0XHQjIHRoZXJlIGFyZSBhbHNvIHNvbWUgdmFsdWVzIHdlIGNhbm5vdCB1c2Vcblx0XHRyYXcubWF0Y2goL15bYS16QS1aXFwkXFxfXStbXFxkXFx3XFwkXFxfXSokLykgPyB0cnVlIDogZmFsc2VcblxuXHRkZWYganMgb1xuXHRcdFN0cmluZyhAdmFsdWUpXG5cblx0ZGVmIGMgb1xuXHRcdEBjYWNoZSA/IHN1cGVyKG8pIDogU3RyaW5nKEB2YWx1ZSlcblxuXG5leHBvcnQgY2xhc3MgSW50ZXJwb2xhdGlvbiA8IFZhbHVlTm9kZVxuXG4jIEN1cnJlbnRseSBub3QgdXNlZCAtIGl0IHdvdWxkIGJlIGJldHRlciB0byB1c2UgdGhpc1xuIyBmb3IgcmVhbCBpbnRlcnBvbGF0ZWQgc3RyaW5ncyB0aG91Z2gsIHRoYW4gdG8gYnJlYWtcbiMgdGhlbSB1cCBpbnRvIHRoZWlyIHBhcnRzIGJlZm9yZSBwYXJzaW5nXG5leHBvcnQgY2xhc3MgSW50ZXJwb2xhdGVkU3RyaW5nIDwgTm9kZVxuXG5cdGRlZiBpbml0aWFsaXplIG5vZGVzLCBvID0ge31cblx0XHRAbm9kZXMgPSBub2Rlc1xuXHRcdEBvcHRpb25zID0gb1xuXHRcdHNlbGZcblxuXHRkZWYgYWRkIHBhcnRcblx0XHRAbm9kZXMucHVzaChwYXJ0KSBpZiBwYXJ0XG5cdFx0c2VsZlxuXG5cdGRlZiB2aXNpdFxuXHRcdGZvciBub2RlIGluIEBub2Rlc1xuXHRcdFx0bm9kZS50cmF2ZXJzZVxuXHRcdHNlbGZcblxuXHRkZWYgZXNjYXBlU3RyaW5nIHN0clxuXHRcdCMgdmFyIGlkeCA9IDBcblx0XHQjIHZhciBsZW4gPSBzdHI6bGVuZ3RoXG5cdFx0IyB2YXIgY2hyXG5cdFx0IyB3aGlsZSBjaHIgPSBzdHJbaWR4KytdXG5cdFx0c3RyID0gc3RyLnJlcGxhY2UoL1xcbi9nLCAnXFxcXFxcbicpXG5cblx0ZGVmIGpzIG9cblx0XHQjIGNyZWF0aW5nIHRoZSBzdHJpbmdcblx0XHR2YXIgcGFydHMgPSBbXVxuXHRcdHZhciBzdHIgPSAnKCdcblxuXHRcdEBub2Rlcy5tYXAgZG8gfHBhcnQsaXxcblx0XHRcdGlmIHBhcnQgaXNhIFRva2VuIGFuZCBwYXJ0LkB0eXBlID09ICdORU9TVFJJTkcnXG5cdFx0XHRcdCMgZXNjYVxuXHRcdFx0XHRwYXJ0cy5wdXNoKCdcIicgKyBlc2NhcGVTdHJpbmcocGFydC5AdmFsdWUpICsgJ1wiJylcblx0XHRcdGVsaWYgcGFydFxuXHRcdFx0XHRpZiBpID09IDBcblx0XHRcdFx0XHQjIGZvcmNlIGZpcnN0IHBhcnQgdG8gYmUgc3RyaW5nXG5cdFx0XHRcdFx0cGFydHMucHVzaCgnXCJcIicpXG5cdFx0XHRcdHBhcnQuQHBhcmVucyA9IHllc1xuXHRcdFx0XHRwYXJ0cy5wdXNoKHBhcnQuYyhleHByZXNzaW9uOiB5ZXMpKVxuXG5cdFx0c3RyICs9IHBhcnRzLmpvaW4oXCIgKyBcIilcblx0XHRzdHIgKz0gJyknXG5cdFx0cmV0dXJuIHN0clxuXG5cbmV4cG9ydCBjbGFzcyBUdXBsZSA8IExpc3ROb2RlXG5cblx0ZGVmIGNcblx0XHQjIGNvbXBpbGVzIGFzIGFuIGFycmF5XG5cdFx0QXJyLm5ldyhub2RlcykuY1xuXG5cdGRlZiBoYXNTcGxhdFxuXHRcdGZpbHRlcih8dnwgdiBpc2EgU3BsYXQgKVswXVxuXG5cdGRlZiBjb25zdW1lIG5vZGVcblx0XHRpZiBjb3VudCA9PSAxXG5cdFx0XHRyZXR1cm4gZmlyc3QuY29uc3VtZShub2RlKVxuXHRcdGVsc2Vcblx0XHRcdHRocm93IFwibXVsdGl0dXBsZSBjYW5ub3QgY29uc3VtZVwiXG5cdFx0XG5cdFxuIyBCZWNhdXNlIHdlJ3ZlIGRyb3BwZWQgdGhlIFN0ci13cmFwcGVyIGl0IGlzIGtpbmRhIGRpZmZpY3VsdFxuZXhwb3J0IGNsYXNzIFN5bWJvbCA8IExpdGVyYWxcblxuXHRkZWYgaXNWYWxpZElkZW50aWZpZXJcblx0XHRyYXcubWF0Y2goL15bYS16QS1aXFwkXFxfXStbXFxkXFx3XFwkXFxfXSokLykgPyB0cnVlIDogZmFsc2VcblxuXHRkZWYgaXNQcmltaXRpdmUgZGVlcFxuXHRcdHllc1xuXG5cdGRlZiByYXdcblx0XHRAcmF3IHx8PSBzeW1fXyh2YWx1ZSlcblxuXHRkZWYganMgb1xuXHRcdFwiJ3tzeW1fXyh2YWx1ZSl9J1wiXG5cbmV4cG9ydCBjbGFzcyBSZWdFeHAgPCBMaXRlcmFsXG5cblx0ZGVmIGlzUHJpbWl0aXZlXG5cdFx0eWVzXG5cblx0IyBkZWYgdG9TdHJpbmdcblx0IyBcdFwiXCIgKyB2YWx1ZVxuXG4jIFNob3VsZCBpbmhlcml0IGZyb20gTGlzdE5vZGUgLSB3b3VsZCBzaW1wbGlmeVxuZXhwb3J0IGNsYXNzIEFyciA8IExpdGVyYWxcblxuXHRkZWYgbG9hZCB2YWx1ZVxuXHRcdHZhbHVlIGlzYSBBcnJheSA/IEFyZ0xpc3QubmV3KHZhbHVlKSA6IHZhbHVlXG5cblx0ZGVmIHB1c2ggaXRlbVxuXHRcdHZhbHVlLnB1c2goaXRlbSlcblx0XHRzZWxmXG5cblx0ZGVmIGNvdW50XG5cdFx0dmFsdWU6bGVuZ3RoXG5cblx0ZGVmIG5vZGVzXG5cdFx0dmFyIHZhbCA9IHZhbHVlXG5cdFx0dmFsIGlzYSBBcnJheSA/IHZhbCA6IHZhbC5ub2Rlc1xuXG5cdGRlZiBzcGxhdFxuXHRcdHZhbHVlLnNvbWUofHZ8IHYgaXNhIFNwbGF0KVxuXG5cdGRlZiB2aXNpdFxuXHRcdEB2YWx1ZS50cmF2ZXJzZSBpZiBAdmFsdWUgYW5kIEB2YWx1ZTp0cmF2ZXJzZVxuXHRcdHNlbGZcblxuXHRkZWYgaXNQcmltaXRpdmUgZGVlcFxuXHRcdCF2YWx1ZS5zb21lKHx2fCAhdi5pc1ByaW1pdGl2ZSh5ZXMpIClcblxuXHRkZWYganMgb1xuXG5cdFx0dmFyIHZhbCA9IEB2YWx1ZVxuXHRcdHJldHVybiBcIltdXCIgdW5sZXNzIHZhbFxuXG5cdFx0dmFyIHNwbGF0ID0gc3BsYXRcblx0XHR2YXIgbm9kZXMgPSB2YWwgaXNhIEFycmF5ID8gdmFsIDogdmFsLm5vZGVzXG5cdFx0IyBwIFwidmFsdWUgb2YgYXJyYXkgaXNhIHtAdmFsdWV9XCJcblxuXHRcdCMgZm9yIHYgaW4gQHZhbHVlXG5cdFx0IyBcdGJyZWFrIHNwbGF0ID0geWVzIGlmIHYgaXNhIFNwbGF0XG5cdFx0IyB2YXIgc3BsYXQgPSB2YWx1ZS5zb21lKHx2fCB2IGlzYSBTcGxhdClcblxuXHRcdGlmIHNwbGF0XG5cdFx0XHQjIFwiU1BMQVRURUQgQVJSQVkhXCJcblx0XHRcdCMgaWYgd2Uga25vdyBmb3IgY2VydGFpbiB0aGF0IHRoZSBzcGxhdHMgYXJlIGFycmF5cyB3ZSBjYW4gZHJvcCB0aGUgc2xpY2U/XG5cdFx0XHQjIHAgXCJhcnJheSBpcyBzcGxhdD8hP1wiXG5cdFx0XHR2YXIgc2xpY2VzID0gW11cblx0XHRcdHZhciBncm91cCA9IG51bGxcblxuXHRcdFx0Zm9yIHYgaW4gbm9kZXNcblx0XHRcdFx0aWYgdiBpc2EgU3BsYXRcblx0XHRcdFx0XHRzbGljZXMucHVzaCh2KVxuXHRcdFx0XHRcdGdyb3VwID0gbnVsbFxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0c2xpY2VzLnB1c2goZ3JvdXAgPSBBcnIubmV3KFtdKSkgdW5sZXNzIGdyb3VwXG5cdFx0XHRcdFx0Z3JvdXAucHVzaCh2KVxuXG5cdFx0XHRcIltdLmNvbmNhdCh7Y2FyeV9fKHNsaWNlcykuam9pbihcIiwgXCIpfSlcIlxuXHRcdGVsc2Vcblx0XHRcdCMgdmVyeSB0ZW1wb3JhcnkuIG5lZWQgYSBtb3JlIGdlbmVyaWMgd2F5IHRvIHByZXR0aWZ5IGNvZGVcblx0XHRcdCMgc2hvdWxkIGRlcGVuZCBvbiB0aGUgbGVuZ3RoIG9mIHRoZSBpbm5lciBpdGVtcyBldGNcblx0XHRcdCMgaWYgQGluZGVudGVkIG9yIG9wdGlvbig6aW5kZW50KSBvciB2YWx1ZS5AaW5kZW50ZWRcblx0XHRcdCNcdFwiW1xcbnt2YWx1ZS5jLmpvaW4oXCIsXFxuXCIpLmluZGVudH1cXG5dXCJcblx0XHRcdHZhciBvdXQgPSB2YWwgaXNhIEFycmF5ID8gY2FyeV9fKHZhbCkgOiB2YWwuY1xuXHRcdFx0XCJbe291dH1dXCJcblxuXHRkZWYgaGFzU2lkZUVmZmVjdHNcblx0XHR2YWx1ZS5zb21lKHx2fCB2Lmhhc1NpZGVFZmZlY3RzIClcblxuXHRkZWYgdG9TdHJpbmdcblx0XHRcIkFyclwiXG5cdFxuXHRkZWYgaW5kZW50ZWQgYSxiXG5cdFx0QHZhbHVlLmluZGVudGVkKGEsYilcblx0XHRzZWxmXG5cblx0ZGVmIHNlbGYud3JhcCB2YWxcblx0XHRBcnIubmV3KHZhbClcblxuIyBzaG91bGQgbm90IGJlIGNrbGFzc2lmaWVkIGFzIGEgbGl0ZXJhbD9cbmV4cG9ydCBjbGFzcyBPYmogPCBMaXRlcmFsXG5cblx0ZGVmIGxvYWQgdmFsdWVcblx0XHR2YWx1ZSBpc2EgQXJyYXkgPyBBc3NpZ25MaXN0Lm5ldyh2YWx1ZSkgOiB2YWx1ZVxuXG5cdGRlZiB2aXNpdFxuXHRcdEB2YWx1ZS50cmF2ZXJzZSBpZiBAdmFsdWVcblx0XHQjIGZvciB2IGluIHZhbHVlXG5cdFx0IyBcdHYudHJhdmVyc2Vcblx0XHRzZWxmXG5cblx0ZGVmIGpzIG9cblx0XHR2YXIgZHluID0gdmFsdWUuZmlsdGVyKHx2fCB2IGlzYSBPYmpBdHRyIGFuZCAodi5rZXkgaXNhIE9wIG9yIHYua2V5IGlzYSBJbnRlcnBvbGF0ZWRTdHJpbmcpICApXG5cblx0XHRpZiBkeW46bGVuZ3RoID4gMFxuXHRcdFx0dmFyIGlkeCA9IHZhbHVlLmluZGV4T2YoZHluWzBdKVxuXHRcdFx0IyBwIFwiZHluYW1pYyBrZXlzISB7ZHlufVwiXG5cdFx0XHQjIGNyZWF0ZSBhIHRlbXAgdmFyaWFibGVcblxuXHRcdFx0dmFyIHRtcCA9IHNjb3BlX18udGVtcG9yYXJ5KHNlbGYpXG5cdFx0XHQjIHNldCB0aGUgdGVtcG9yYXJ5IG9iamVjdCB0byB0aGUgc2FtZVxuXHRcdFx0dmFyIGZpcnN0ID0gdmFsdWUuc2xpY2UoMCxpZHgpXG5cdFx0XHR2YXIgb2JqID0gT2JqLm5ldyhmaXJzdClcblx0XHRcdHZhciBhc3QgPSBbT1AoJz0nLHRtcCxvYmopXVxuXG5cdFx0XHR2YWx1ZS5zbGljZShpZHgpLmZvckVhY2ggZG8gfGF0cnxcblx0XHRcdFx0YXN0LnB1c2goT1AoJz0nLE9QKCcuJyx0bXAsYXRyLmtleSksYXRyLnZhbHVlKSlcblx0XHRcdGFzdC5wdXNoKHRtcCkgIyBhY2Nlc3MgdGhlIHRtcCBhdCBpbiB0aGUgbGFzdCBwYXJ0XG5cdFx0XHRyZXR1cm4gUGFyZW5zLm5ldyhhc3QpLmNcblxuXHRcdCMgZm9yIG9iamVjdHMgd2l0aCBleHByZXNzaW9uLWtleXMgd2UgbmVlZCB0byB0aGluayBkaWZmZXJlbnRseVxuXHRcdCd7JyArIHZhbHVlLmMgKyAnfSdcblxuXHRkZWYgYWRkIGssIHZcblx0XHRrID0gSWRlbnRpZmllci5uZXcoaykgaWYgayBpc2EgU3RyaW5nXG5cdFx0dmFyIGt2ID0gT2JqQXR0ci5uZXcoayx2KVxuXHRcdHZhbHVlLnB1c2goa3YpXG5cdFx0cmV0dXJuIGt2XG5cblx0ZGVmIHJlbW92ZSBrZXlcblx0XHRmb3IgayBpbiB2YWx1ZVxuXHRcdFx0dmFsdWUucmVtb3ZlKGspIGlmIGsua2V5LnN5bWJvbCA9PSBrZXlcblx0XHRzZWxmXG5cblx0ZGVmIGtleXNcblx0XHRPYmplY3Qua2V5cyhoYXNoKVxuXG5cdGRlZiBoYXNoXG5cdFx0dmFyIGhhc2ggPSB7fVxuXHRcdGZvciBrIGluIHZhbHVlXG5cdFx0XHRoYXNoW2sua2V5LnN5bWJvbF0gPSBrLnZhbHVlIGlmIGsgaXNhIE9iakF0dHJcblx0XHRyZXR1cm4gaGFzaFxuXHRcdCMgcmV0dXJuIGsgaWYgay5rZXkuc3ltYm9sID09IGtleVxuXG5cdCMgYWRkIG1ldGhvZCBmb3IgZmluZGluZyBwcm9wZXJ0aWVzIGV0Yz9cblx0ZGVmIGtleSBrZXlcblx0XHRmb3IgayBpbiB2YWx1ZVxuXHRcdFx0cmV0dXJuIGsgaWYgayBpc2EgT2JqQXR0ciBhbmQgay5rZXkuc3ltYm9sID09IGtleVxuXHRcdG51bGxcblxuXHRkZWYgaW5kZW50ZWQgYSxiXG5cdFx0QHZhbHVlLmluZGVudGVkKGEsYilcblx0XHRzZWxmXG5cblx0ZGVmIGhhc1NpZGVFZmZlY3RzXG5cdFx0dmFsdWUuc29tZSh8dnwgdi5oYXNTaWRlRWZmZWN0cyApXG5cblx0IyBmb3IgY29udmVydGluZyBhIHJlYWwgb2JqZWN0IGludG8gYW4gYXN0LXJlcHJlc2VudGF0aW9uXG5cdGRlZiBzZWxmLndyYXAgb2JqXG5cdFx0dmFyIGF0dHJzID0gW11cblx0XHRmb3Igb3duIGssdiBvZiBvYmpcblx0XHRcdGlmIHYgaXNhIEFycmF5XG5cdFx0XHRcdHYgPSBBcnIud3JhcCh2KVxuXHRcdFx0ZWxpZiB2OmNvbnN0cnVjdG9yID09IE9iamVjdFxuXHRcdFx0XHR2ID0gT2JqLndyYXAodilcblx0XHRcdGF0dHJzLnB1c2goT2JqQXR0ci5uZXcoayx2KSlcblx0XHRyZXR1cm4gT2JqLm5ldyhhdHRycylcblxuXHRkZWYgdG9TdHJpbmdcblx0XHRcIk9ialwiXG5cdFx0XG5leHBvcnQgY2xhc3MgT2JqQXR0ciA8IE5vZGVcblxuXHRwcm9wIGtleVxuXHRwcm9wIHZhbHVlXG5cdHByb3Agb3B0aW9uc1xuXG5cdGRlZiBpbml0aWFsaXplIGtleSwgdmFsdWVcblx0XHRAdHJhdmVyc2VkID0gbm9cblx0XHRAa2V5ID0ga2V5XG5cdFx0QHZhbHVlID0gdmFsdWVcblx0XHRAZHluYW1pYyA9IGtleSBpc2EgT3Bcblx0XHRzZWxmXG5cblx0ZGVmIHZpc2l0XG5cdFx0IyBzaG91bGQgcHJvYmFibHkgdHJhdmVyc2Uga2V5IGFzIHdlbGwsIHVubGVzcyBpdCBpcyBhIGRlYWQgc2ltcGxlIGlkZW50aWZpZXJcblx0XHRrZXkudHJhdmVyc2Vcblx0XHR2YWx1ZS50cmF2ZXJzZVxuXG5cdGRlZiBqcyBvXG5cdFx0dmFyIGsgPSBrZXkuaXNSZXNlcnZlZCA/IFwiJ3trZXkuY30nXCIgOiBrZXkuY1xuXHRcdFwie2t9OiB7dmFsdWUuY31cIlxuXG5cdGRlZiBoYXNTaWRlRWZmZWN0c1xuXHRcdHRydWVcblx0XHRcblxuXG5leHBvcnQgY2xhc3MgQXJnc1JlZmVyZW5jZSA8IE5vZGVcblxuXHQjIHNob3VsZCByZWdpc3RlciBpbiB0aGlzIHNjb3BlIC0tXG5cdGRlZiBjXG5cdFx0XCJhcmd1bWVudHNcIlxuXG4jIHNob3VsZCBiZSBhIHNlcGFyYXRlIENvbnRleHQgb3Igc29tZXRoaW5nXG5leHBvcnQgY2xhc3MgU2VsZiA8IExpdGVyYWxcblxuXHRwcm9wIHNjb3BlXG5cblx0ZGVmIGluaXRpYWxpemUgc2NvcGVcblx0XHRAc2NvcGUgPSBzY29wZVxuXG5cdGRlZiBjYWNoZVxuXHRcdHNlbGZcblxuXHRkZWYgcmVmZXJlbmNlXG5cdFx0cmV0dXJuIHNlbGZcblxuXHRkZWYgY1xuXHRcdHZhciBzID0gc2NvcGVfX1xuXHRcdChzID8gcy5jb250ZXh0LmMgOiBcInRoaXNcIilcblxuZXhwb3J0IGNsYXNzIEltcGxpY2l0U2VsZiA8IFNlbGZcblx0XHRcbmV4cG9ydCBjbGFzcyBUaGlzIDwgU2VsZlxuXG5cdGRlZiBjYWNoZVxuXHRcdHNlbGZcblxuXHRkZWYgcmVmZXJlbmNlXG5cdFx0IyBwIFwicmVmZXJlbmNpbmcgdGhpc1wiXG5cdFx0c2VsZlxuXG5cdGRlZiBjXG5cdFx0XCJ0aGlzXCJcblxuXG5cblxuIyBPUEVSQVRPUlNcblxuZXhwb3J0IGNsYXNzIE9wIDwgTm9kZVxuXG5cdHByb3Agb3Bcblx0cHJvcCBsZWZ0XG5cdHByb3AgcmlnaHRcblxuXHRkZWYgaW5pdGlhbGl6ZSBvLCBsLCByIFxuXHRcdCMgc2V0IGV4cHJlc3Npb24geWVzLCBubz9cblx0XHRAZXhwcmVzc2lvbiA9IG5vXG5cdFx0QHRyYXZlcnNlZCA9IG5vXG5cdFx0QHBhcmVucyA9IG5vXG5cdFx0QGNhY2hlID0gbnVsbFxuXHRcdEBpbnZlcnQgPSBub1xuXHRcdEBvcFRva2VuID0gb1xuXHRcdEBvcCA9IG8gYW5kIG8uQHZhbHVlIG9yIG9cblx0XHRAbGVmdCA9IGxcblx0XHRAcmlnaHQgPSByXG5cdFx0cmV0dXJuIHNlbGZcblxuXHRkZWYgdmlzaXRcblx0XHRAcmlnaHQudHJhdmVyc2UgaWYgQHJpZ2h0XG5cdFx0QGxlZnQudHJhdmVyc2UgaWYgQGxlZnRcblx0XHRyZXR1cm4gc2VsZlxuXG5cdGRlZiBpc0V4cHJlc3NhYmxlXG5cdFx0IyB3aGF0IGlmIHJpZ2h0IGlzIGEgc3RyaW5nPyE/XG5cdFx0IXJpZ2h0IHx8IHJpZ2h0LmlzRXhwcmVzc2FibGVcblxuXHRkZWYganMgb1xuXHRcdHZhciBvdXQgPSBudWxsXG5cdFx0dmFyIG9wID0gQG9wXG5cblx0XHR2YXIgbCA9IEBsZWZ0XG5cdFx0dmFyIHIgPSBAcmlnaHRcblxuXHRcdGwgPSBsLmMgaWYgbCBpc2EgTm9kZVxuXHRcdHIgPSByLmMgaWYgciBpc2EgTm9kZVxuXG5cdFx0aWYgbCAmJiByXG5cdFx0XHRvdXQgPSBcIntsfSB7bWFya19fKEBvcFRva2VuKX17b3B9IHtyfVwiXG5cdFx0ZWxpZiBsXG5cdFx0XHRvdXQgPSBcInttYXJrX18oQG9wVG9rZW4pfXtvcH17bH1cIlxuXHRcdCMgb3V0ID0gb3V0LnBhcmVudGhlc2l6ZSBpZiB1cCBpc2EgT3AgIyByZWFsbHk/XG5cdFx0b3V0XG5cblx0ZGVmIHNob3VsZFBhcmVudGhlc2l6ZVxuXHRcdEBwYXJlbnNcblx0XHQjIG9wdGlvbig6cGFyZW5zKVxuXG5cdGRlZiBwcmVjZWRlbmNlXG5cdFx0MTBcblxuXHRkZWYgY29uc3VtZSBub2RlXG5cdFx0IyBwICdhc3NpZ25pZnkgaWY/ISdcblx0XHQjIGlmIGl0IGlzIHBvc3NpYmxlLCBjb252ZXJ0IGludG8gZXhwcmVzc2lvblxuXHRcdGlmIG5vZGUgaXNhIFRhZ1RyZWVcblx0XHRcdEBsZWZ0LmNvbnN1bWUobm9kZSkgaWYgQGxlZnRcblx0XHRcdEByaWdodC5jb25zdW1lKG5vZGUpIGlmIEByaWdodFxuXHRcdFx0IyBAYm9keSA9IEBib2R5LmNvbnN1bWUobm9kZSlcblx0XHRcdCMgQGFsdCA9IEBhbHQuY29uc3VtZShub2RlKSBpZiBAYWx0XG5cdFx0XHRyZXR1cm4gc2VsZlxuXHRcdCMgcCBcIk9wLmNvbnN1bWUge25vZGV9XCIuY3lhblxuXHRcdHJldHVybiBzdXBlciBpZiBpc0V4cHJlc3NhYmxlXG5cblx0XHQjIFRPRE8gY2FuIHJhdGhlciB1c2UgZ2xvYmFsIGNhY2hpbmc/XG5cdFx0dmFyIHRtcHZhciA9IHNjb3BlX18uZGVjbGFyZSg6dG1wLG51bGwsc3lzdGVtOiB5ZXMpXG5cdFx0dmFyIGNsb25lID0gT1Aob3AsbGVmdCxudWxsKVxuXHRcdHZhciBhc3QgPSByaWdodC5jb25zdW1lKGNsb25lKVxuXHRcdGFzdC5jb25zdW1lKG5vZGUpIGlmIG5vZGVcblx0XHRyZXR1cm4gYXN0XG5cbmV4cG9ydCBjbGFzcyBDb21wYXJpc29uT3AgPCBPcFxuXG5cdGRlZiBpbnZlcnRcblx0XHQjIGFyZSB0aGVyZSBvdGhlciBjb21wYXJpc29uIG9wcz9cblx0XHQjIHdoYXQgYWJvdXQgYSBjaGFpbj9cblx0XHR2YXIgb3AgPSBAb3Bcblx0XHR2YXIgcGFpcnMgPSBbIFwiPT1cIixcIiE9XCIgLCBcIj09PVwiLFwiIT09XCIgLCBcIj5cIixcIjw9XCIgLCBcIjxcIixcIj49XCIgXVxuXHRcdHZhciBpZHggPSBwYWlycy5pbmRleE9mKG9wKVxuXHRcdGlkeCArPSAoaWR4ICUgMiA/IC0xIDogMSlcblxuXHRcdCMgcCBcImludmVydCB7QG9wfVwiXG5cdFx0IyBwIFwiaW52ZXJ0ZWQgY29tcGFyaXNvbighKSB7aWR4fSB7b3B9IC0+IHtwYWlyc1tpZHhdfVwiXG5cdFx0c2VsZi5vcCA9IHBhaXJzW2lkeF1cblx0XHRAaW52ZXJ0ID0gIUBpbnZlcnRcblx0XHRzZWxmXG5cblx0ZGVmIGNcblx0XHRpZiBsZWZ0IGlzYSBDb21wYXJpc29uT3Bcblx0XHRcdGxlZnQucmlnaHQuY2FjaGVcblx0XHRcdE9QKCcmJicsbGVmdCxPUChvcCxsZWZ0LnJpZ2h0LHJpZ2h0KSkuY1xuXHRcdGVsc2Vcblx0XHRcdHN1cGVyXG5cblx0ZGVmIGpzIG9cblx0XHR2YXIgb3AgPSBAb3Bcblx0XHR2YXIgbCA9IEBsZWZ0XG5cdFx0dmFyIHIgPSBAcmlnaHRcblxuXHRcdGwgPSBsLmMgaWYgbCBpc2EgTm9kZVxuXHRcdHIgPSByLmMgaWYgciBpc2EgTm9kZVxuXHRcdHJldHVybiBcIntsfSB7bWFya19fKEBvcFRva2VuKX17b3B9IHtyfVwiXG5cblx0XHRcbmV4cG9ydCBjbGFzcyBNYXRoT3AgPCBPcFxuXHQjIEJVRyBpZiB3ZSBoYXZlIGEgc3RhdGVtZW50IGluIGxlZnQgb3IgcmlnaHQgd2UgbmVlZFxuXHQjIHRvIEZPUkNFIGl0IGludG8gYW4gZXhwcmVzc2lvbiwgYW5kIHJlZ2lzdGVyIHdhcm5pbmdcblx0IyBzaG91bGQgbm90IGF0IGFsbCBjb25zdW1lIGFueXRoaW5nIGxpa2UgYSByZWd1bGFyIE9wXG5cdGRlZiBjXG5cdFx0aWYgb3AgPT0gJ+KIqidcblx0XHRcdHJldHVybiB1dGlsLnVuaW9uKGxlZnQscmlnaHQpLmNcblx0XHRlbGlmIG9wID09ICfiiKknXG5cdFx0XHRyZXR1cm4gdXRpbC5pbnRlcnNlY3QobGVmdCxyaWdodCkuY1xuXG5cbmV4cG9ydCBjbGFzcyBVbmFyeU9wIDwgT3BcblxuXHRkZWYgaW52ZXJ0XG5cdFx0aWYgb3AgPT0gJyEnXG5cdFx0XHRyZXR1cm4gbGVmdFxuXHRcdGVsc2Vcblx0XHRcdHN1cGVyICMgcmVndWxhciBpbnZlcnRcblxuXHRkZWYganMgb1xuXHRcdHZhciBsID0gQGxlZnRcblx0XHR2YXIgciA9IEByaWdodFxuXHRcdCMgYWxsIG9mIHRoaXMgY291bGQgcmVhbGx5IGJlIGRvbmUgaSBhIG11Y2hcblx0XHQjIGNsZWFuZXIgd2F5LlxuXHRcdCMgbC5zZXQocGFyZW5zOiB5ZXMpIGlmIGwgIyBhcmUgd2UgcmVhbGx5IHN1cmUgYWJvdXQgdGhpcz9cblx0XHQjIHIuc2V0KHBhcmVuczogeWVzKSBpZiByXG5cblx0XHRpZiBvcCA9PSAnISdcblx0XHRcdCMgbC5AcGFyZW5zID0geWVzXG5cdFx0XHR2YXIgc3RyID0gbC5jXG5cdFx0XHR2YXIgcGFyZW4gPSBsLnNob3VsZFBhcmVudGhlc2l6ZShzZWxmKVxuXHRcdFx0IyBwIFwiY2hlY2sgZm9yIHBhcmVucyBpbiAhOiB7c3RyfSB7bH0ge2wuQHBhcmVuc30ge2wuc2hvdWxkUGFyZW50aGVzaXplKHNlbGYpfVwiXG5cdFx0XHQjIEZJWE1FIHRoaXMgaXMgYSB2ZXJ5IGhhY2t5IHdvcmthcm91bmQuIE5lZWQgdG8gaGFuZGxlIGFsbCB0aGlzXG5cdFx0XHQjIGluIHRoZSBjaGlsZCBpbnN0ZWFkLCBwcm9ibGVtcyBhcmlzZSBkdWUgdG8gYXV0b21hdGljIGNhY2hpbmdcblx0XHRcdHN0ciA9ICcoJyArIHN0ciArICcpJyB1bmxlc3Mgc3RyLm1hdGNoKC9eXFwhPyhbXFx3XFwuXSspJC8pIG9yIGwgaXNhIFBhcmVucyBvciBwYXJlbiBvciBsIGlzYSBBY2Nlc3Mgb3IgbCBpc2EgQ2FsbFxuXHRcdFx0IyBsLnNldChwYXJlbnM6IHllcykgIyBzdXJlP1xuXHRcdFx0XCJ7b3B9e3N0cn1cIlxuXG5cdFx0ZWxpZiBvcCA9PSAn4oiaJ1xuXHRcdFx0XCJNYXRoLnNxcnQoe2wuY30pXCJcblxuXHRcdGVsaWYgbGVmdFxuXHRcdFx0XCJ7bC5jfXtvcH1cIlxuXG5cdFx0ZWxzZVxuXHRcdFx0XCJ7b3B9e3IuY31cIlxuXG5cdGRlZiBub3JtYWxpemVcblx0XHRyZXR1cm4gc2VsZiBpZiBvcCA9PSAnIScgb3Igb3AgPT0gJ+KImidcblx0XHR2YXIgbm9kZSA9IChsZWZ0IHx8IHJpZ2h0KS5ub2RlXG5cdFx0IyBmb3IgcHJvcGVydHktYWNjZXNzb3JzIHdlIG5lZWQgdG8gcmV3cml0ZSB0aGUgYXN0XG5cdFx0cmV0dXJuIHNlbGYgdW5sZXNzIG5vZGUgaXNhIFByb3BlcnR5QWNjZXNzXG5cblx0XHQjIGFzayB0byBjYWNoZSB0aGUgcGF0aFxuXHRcdG5vZGUubGVmdC5jYWNoZSBpZiBub2RlIGlzYSBBY2Nlc3MgJiYgbm9kZS5sZWZ0XG5cblx0XHR2YXIgbnVtID0gTnVtLm5ldygxKVxuXHRcdHZhciBhc3QgPSBPUCgnPScsbm9kZSxPUChvcFswXSxub2RlLG51bSkpXG5cdFx0YXN0ID0gT1Aob3BbMF0gPT0gJy0nID8gJysnIDogJy0nLGFzdCxudW0pIGlmIGxlZnRcblxuXHRcdHJldHVybiBhc3RcblxuXHRkZWYgY29uc3VtZSBub2RlXG5cdFx0dmFyIG5vcm0gPSBub3JtYWxpemVcblx0XHRub3JtID09IHNlbGYgPyBzdXBlciA6IG5vcm0uY29uc3VtZShub2RlKVxuXG5cdGRlZiBjXG5cdFx0dmFyIG5vcm0gPSBub3JtYWxpemVcblx0XHRub3JtID09IHNlbGYgPyBzdXBlciA6IG5vcm0uY1xuXG5leHBvcnQgY2xhc3MgSW5zdGFuY2VPZiA8IE9wXG5cblx0ZGVmIGpzIG9cblx0XHQjIGZpeCBjaGVja3MgZm9yIFN0cmluZyBhbmQgTnVtYmVyXG5cdFx0IyBwIHJpZ2h0Lmluc3BlY3RcblxuXHRcdGlmIHJpZ2h0IGlzYSBDb25zdFxuXHRcdFx0IyBXQVJOIG90aGVyd2lzZSAtIHdoYXQgZG8gd2UgZG8/IGRvZXMgbm90IHdvcmsgd2l0aCBkeW5hbWljXG5cdFx0XHQjIGNsYXNzZXMgZXRjPyBTaG91bGQgcHJvYmFibHkgc2VuZCB0byB1dGlsaXR5IGZ1bmN0aW9uIGlzYSRcblx0XHRcdHZhciBuYW1lID0gY19fKHJpZ2h0LnZhbHVlKVxuXHRcdFx0dmFyIG9iaiA9IGxlZnQubm9kZVxuXHRcdFx0IyBUT0RPIGFsc28gY2hlY2sgZm9yIHByaW1pdGl2ZS1jb25zdHJ1Y3RvclxuXHRcdFx0aWYgbmFtZSBpbiBbJ1N0cmluZycsJ051bWJlcicsJ0Jvb2xlYW4nXVxuXHRcdFx0XHR1bmxlc3Mgb2JqIGlzYSBMb2NhbFZhckFjY2Vzc1xuXHRcdFx0XHRcdG9iai5jYWNoZVxuXHRcdFx0XHQjIG5lZWQgYSBkb3VibGUgY2hlY2sgZm9yIHRoZXNlIChjYWNoZSBsZWZ0KSAtIHBvc3NpYmx5XG5cdFx0XHRcdHJldHVybiBcIih0eXBlb2Yge29iai5jfT09J3tuYW1lLnRvTG93ZXJDYXNlfSd8fHtvYmouY30gaW5zdGFuY2VvZiB7bmFtZX0pXCJcblx0XHRcdFxuXHRcdFx0XHQjIGNvbnZlcnRcblx0XHR2YXIgb3V0ID0gXCJ7bGVmdC5jfSB7b3B9IHtyaWdodC5jfVwiXG5cblx0XHQjIHNob3VsZCB0aGlzIG5vdCBoYXBwZW4gaW4gI2M/XG5cdFx0b3V0ID0gaGVscGVycy5wYXJlbnRoZXNpemUob3V0KSBpZiBvLnBhcmVudCBpc2EgT3Bcblx0XHRvdXRcblxuZXhwb3J0IGNsYXNzIFR5cGVPZiA8IE9wXG5cblx0ZGVmIGpzIG9cblx0XHRcInR5cGVvZiB7bGVmdC5jfVwiXG5cbmV4cG9ydCBjbGFzcyBEZWxldGUgPCBPcFxuXG5cdGRlZiBqcyBvXG5cdFx0IyBUT0RPIHRoaXMgd2lsbCBleGVjdXRlIGNhbGxzIHNldmVyYWwgdGltZXMgaWYgdGhlIHBhdGggaXMgbm90IGRpcmVjdGx5IHRvIGFuIG9iamVjdFxuXHRcdCMgbmVlZCB0byBjYWNoZSB0aGUgcmVjZWl2ZXJcblx0XHR2YXIgbCA9IGxlZnRcblx0XHR2YXIgdG1wID0gc2NvcGVfXy50ZW1wb3Jhcnkoc2VsZiwgcG9vbDogJ3ZhbCcpXG5cdFx0dmFyIG8gPSBPUCgnPScsdG1wLGwpXG5cdFx0IyBGSVhNRVxuXHRcdHJldHVybiBcIih7by5jfSxkZWxldGUge2wuY30sIHt0bXAuY30pXCIgIyBvaCB3ZWxsXG5cdFx0IyB2YXIgYXN0ID0gW09QKCc9Jyx0bXAsbGVmdCksXCJkZWxldGUge2xlZnQuY31cIix0bXBdXG5cdFx0IyBzaG91bGQgcGFyZW50aGVzaXplIGRpcmVjdGx5IG5vP1xuXHRcdCMgYXN0LmNcblxuXHRkZWYgc2hvdWxkUGFyZW50aGVzaXplXG5cdFx0eWVzXG5cbmV4cG9ydCBjbGFzcyBJbiA8IE9wXG5cblx0ZGVmIGludmVydFxuXHRcdEBpbnZlcnQgPSAhQGludmVydFxuXHRcdHNlbGZcblxuXHRkZWYganMgb1xuXHRcdHZhciBjb25kID0gQGludmVydCA/IFwiPT0gLTFcIiA6IFwiPj0gMFwiXG5cdFx0dmFyIGlkeCA9IFV0aWwuaW5kZXhPZihsZWZ0LHJpZ2h0KVxuXHRcdFwie2lkeC5jfSB7Y29uZH1cIlxuXHRcblxuXG5cblxuXG5cbiMgQUNDRVNTXG5cbmV4cG9ydCB2YXIgS19JVkFSID0gMVxuZXhwb3J0IHZhciBLX1NZTSA9IDJcbmV4cG9ydCB2YXIgS19TVFIgPSAzXG5leHBvcnQgdmFyIEtfUFJPUCA9IDRcblxuZXhwb3J0IGNsYXNzIEFjY2VzcyA8IE9wXG5cblx0ZGVmIGluaXRpYWxpemUgbywgbCwgciBcblx0XHQjIHNldCBleHByZXNzaW9uIHllcywgbm8/XG5cdFx0QGV4cHJlc3Npb24gPSBub1xuXHRcdEB0cmF2ZXJzZWQgPSBub1xuXHRcdEBwYXJlbnMgPSBub1xuXHRcdEBjYWNoZSA9IG51bGxcblx0XHRAaW52ZXJ0ID0gbm9cblx0XHRAb3AgPSBvIGFuZCBvLkB2YWx1ZSBvciBvXG5cdFx0QGxlZnQgPSBsXG5cdFx0QHJpZ2h0ID0gclxuXHRcdHJldHVybiBzZWxmXG5cblx0ZGVmIGNsb25lIGxlZnQsIHJpZ2h0XG5cdFx0dmFyIGN0b3IgPSBzZWxmOmNvbnN0cnVjdG9yXG5cdFx0Y3Rvci5uZXcob3AsbGVmdCxyaWdodClcblxuXHRkZWYganMgb1xuXHRcdHZhciByYXcgPSBudWxsXG5cdFx0dmFyIHJndCA9IHJpZ2h0XG5cdFx0dmFyIGN0eCA9IChsZWZ0IHx8IHNjb3BlX18uY29udGV4dClcblx0XHR2YXIgcHJlID0gXCJcIlxuXHRcdHZhciBtYXJrID0gJydcblxuXHRcdCMgaWYgc2FmZWNoYWluXG5cdFx0I1x0cCBcIkFjY2VzcyBpcyBzYWZlY2hhaW5lZCB7cmd0LmN9XCJcblxuXG5cdFx0aWYgcmd0IGlzYSBOdW1cblx0XHRcdHJldHVybiBjdHguYyArIFwiW1wiICsgcmd0LmMgKyBcIl1cIlxuXG5cdFx0IyBpcyB0aGlzIHJpZ2h0PyBTaG91bGQgbm90IHRoZSBpbmRleCBjb21waWxlIHRoZSBicmFja2V0c1xuXHRcdCMgb3IgdmFsdWUgaXMgYSBzeW1ib2wgLS0gc2hvdWxkIGJlIHRoZSBzYW1lLCBubz9cblx0XHRpZiByZ3QgaXNhIEluZGV4IGFuZCAocmd0LnZhbHVlIGlzYSBTdHIgb3Igcmd0LnZhbHVlIGlzYSBTeW1ib2wpXG5cdFx0XHRyZ3QgPSByZ3QudmFsdWVcblxuXHRcdCMgVE9ETyBkbyB0aGUgaWRlbnRpZmllci12YWxpZGF0aW9uIGluIGEgY2VudHJhbCBwbGFjZSBpbnN0ZWFkXG5cdFx0aWYgcmd0IGlzYSBTdHIgYW5kIHJndC5pc1ZhbGlkSWRlbnRpZmllclxuXHRcdFx0cmF3ID0gcmd0LnJhd1xuXG5cdFx0ZWxpZiByZ3QgaXNhIFN5bWJvbCBhbmQgcmd0LmlzVmFsaWRJZGVudGlmaWVyXG5cdFx0XHRyYXcgPSByZ3QucmF3XG5cblx0XHRlbGlmIHJndCBpc2EgSWRlbnRpZmllciBhbmQgcmd0LmlzVmFsaWRJZGVudGlmaWVyXG5cdFx0XHRtYXJrID0gbWFya19fKHJndC5AdmFsdWUpXG5cdFx0XHRyYXcgPSByZ3QuY1xuXG5cdFx0aWYgc2FmZWNoYWluIGFuZCBjdHhcblx0XHRcdGN0eC5jYWNoZShmb3JjZTogeWVzKVxuXHRcdFx0cHJlID0gY3R4LmMgKyBcIiAmJiBcIlxuXG5cdFx0IyByZWFsbHk/XG5cdFx0IyB2YXIgY3R4ID0gKGxlZnQgfHwgc2NvcGVfXy5jb250ZXh0KVxuXHRcdHZhciBvdXQgPSBpZiByYXdcblx0XHRcdCMgc2VlIGlmIGl0IG5lZWRzIHF1b3Rpbmdcblx0XHRcdCMgbmVlZCB0byBjaGVjayB0byBzZWUgaWYgaXQgaXMgbGVnYWxcblx0XHRcdGN0eCA/IFwie2N0eC5jfS57bWFya317cmF3fVwiIDogcmF3XG5cdFx0ZWxzZVxuXHRcdFx0dmFyIHIgPSByZ3QgaXNhIE5vZGUgPyByZ3QuYyhleHByZXNzaW9uOiB5ZXMpIDogcmd0XG5cdFx0XHRcIntjdHguY31be3J9XVwiXG5cblx0XHQjIGlmIHNhZmVjaGFpbiBhbmQgY3R4XG5cdFx0IyBcdG91dCA9IFwie2N0eC5jfSAmJiB7b3V0fVwiXG5cblx0XHRyZXR1cm4gcHJlICsgb3V0XG5cblx0ZGVmIHZpc2l0XG5cdFx0bGVmdC50cmF2ZXJzZSBpZiBsZWZ0XG5cdFx0cmlnaHQudHJhdmVyc2UgaWYgcmlnaHRcblx0XHRyZXR1cm5cblxuXHRkZWYgaXNFeHByZXNzYWJsZVxuXHRcdHRydWVcblxuXHRkZWYgYWxpYXNcblx0XHRyaWdodCBpc2EgSWRlbnRpZmllciA/IHJpZ2h0LmFsaWFzIDogc3VwZXIoKVxuXG5cdGRlZiBzYWZlY2hhaW5cblx0XHQjIHJpZ2h0LnNhZmVjaGFpblxuXHRcdFN0cmluZyhAb3ApID09ICc/Licgb3IgU3RyaW5nKEBvcCkgPT0gJz86J1xuXG5cdGRlZiBjYWNoZSBvXG5cdFx0KHJpZ2h0IGlzYSBJdmFyICYmICFsZWZ0KSA/IHNlbGYgOiBzdXBlcihvKVxuXHRcdFxuXG5cbiMgU2hvdWxkIGNoYW5nZSB0aGlzIHRvIGp1c3QgcmVmZXIgZGlyZWN0bHkgdG8gdGhlIHZhcmlhYmxlPyBPciBWYXJSZWZlcmVuY2VcbmV4cG9ydCBjbGFzcyBMb2NhbFZhckFjY2VzcyA8IEFjY2Vzc1xuXG5cdHByb3Agc2FmZWNoYWluXG5cblx0ZGVmIGpzIG9cblx0XHRpZiByaWdodCBpc2EgVmFyaWFibGUgYW5kIHJpZ2h0LnR5cGUgPT0gJ21ldGgnXG5cdFx0XHRyZXR1cm4gXCJ7cmlnaHQuY30oKVwiIHVubGVzcyB1cCBpc2EgQ2FsbFxuXG5cdFx0cmlnaHQuY1xuXG5cdGRlZiB2YXJpYWJsZVxuXHRcdHJpZ2h0XG5cblx0ZGVmIGNhY2hlIG8gPSB7fVxuXHRcdHN1cGVyKG8pIGlmIG86Zm9yY2Vcblx0XHRzZWxmXG5cblx0ZGVmIGFsaWFzXG5cdFx0dmFyaWFibGUuQGFsaWFzIG9yIHN1cGVyKClcblxuXG5leHBvcnQgY2xhc3MgR2xvYmFsVmFyQWNjZXNzIDwgVmFsdWVOb2RlXG5cblx0ZGVmIGpzIG9cblx0XHR2YWx1ZS5jXG5cblxuZXhwb3J0IGNsYXNzIE9iamVjdEFjY2VzcyA8IEFjY2Vzc1xuXG5cbmV4cG9ydCBjbGFzcyBQcm9wZXJ0eUFjY2VzcyA8IEFjY2Vzc1xuXG5cdGRlZiBpbml0aWFsaXplIG8sIGwsIHIgXG5cdFx0QHRyYXZlcnNlZCA9IG5vXG5cdFx0QGludmVydCA9IG5vXG5cdFx0QHBhcmVucyA9IG5vXG5cdFx0QGV4cHJlc3Npb24gPSBubyAjIHllcz9cblx0XHRAY2FjaGUgPSBudWxsXG5cdFx0QG9wID0gb1xuXHRcdEBsZWZ0ID0gbFxuXHRcdEByaWdodCA9IHJcblx0XHRyZXR1cm4gc2VsZlxuXG5cdGRlZiB2aXNpdFxuXHRcdEByaWdodC50cmF2ZXJzZSBpZiBAcmlnaHRcblx0XHRAbGVmdC50cmF2ZXJzZSBpZiBAbGVmdFxuXHRcdHJldHVybiBzZWxmXG5cblx0IyByaWdodCBpbiBjIHdlIHNob3VsZCBwb3NzaWJseSBvdmVycmlkZVxuXHQjIHRvIGNyZWF0ZSBhIGNhbGwgYW5kIHJlZ3VsYXIgYWNjZXNzIGluc3RlYWRcblxuXHRkZWYganMgb1xuXHRcblx0XHRpZiB2YXIgcmVjID0gcmVjZWl2ZXJcblx0XHRcdCMgcCBcImNvbnZlcnRpbmcgdG8gY2FsbFwiXG5cdFx0XHR2YXIgYXN0ID0gQ0FMTChPUCgnLicsbGVmdCxyaWdodCksW10pICMgY29udmVydCB0byBBcmdMaXN0IG9yIG51bGxcblx0XHRcdGFzdC5yZWNlaXZlciA9IHJlY1xuXHRcdFx0cmV0dXJuIGFzdC5jXG5cblx0XHR2YXIgdXAgPSB1cFxuXG5cdFx0dW5sZXNzIHVwIGlzYSBDYWxsXG5cdFx0XHQjIHAgXCJjb252ZXJ0IHRvIGNhbGwgaW5zdGVhZFwiXG5cdFx0XHR2YXIgYXN0ID0gQ0FMTChBY2Nlc3MubmV3KG9wLGxlZnQscmlnaHQpLFtdKVxuXHRcdFx0cmV0dXJuIGFzdC5jXG5cblx0XHQjIHJlYWxseSBuZWVkIHRvIGZpeCB0aGlzIC0gZm9yIHN1cmVcblx0XHQjIHNob3VsZCBiZSBwb3NzaWJsZSBmb3IgdGhlIGZ1bmN0aW9uIHRvIHJlbW92ZSB0aGlzIHRoaXMgaW5zdGVhZD9cblx0XHR2YXIganMgPSBcIntzdXBlcihvKX1cIlxuXG5cdFx0dW5sZXNzICh1cCBpc2EgQ2FsbCBvciB1cCBpc2EgVXRpbC5Jc0Z1bmN0aW9uKVxuXHRcdFx0IyBwIFwiQ2FsbGVkXCJcblx0XHRcdGpzICs9IFwiKClcIlxuXG5cdFx0cmV0dXJuIGpzXG5cblxuXHRkZWYgcmVjZWl2ZXJcblx0XHRpZiBsZWZ0IGlzYSBTdXBlckFjY2VzcyB8fCBsZWZ0IGlzYSBTdXBlclxuXHRcdFx0U0VMRlxuXHRcdGVsc2Vcblx0XHRcdG51bGxcblxuXG5leHBvcnQgY2xhc3MgSXZhckFjY2VzcyA8IEFjY2Vzc1xuXG5cdGRlZiBjYWNoZVxuXHRcdCMgV0FSTiBobW0sIHRoaXMgaXMgbm90IHJpZ2h0Li4uIHdoZW4gYWNjZXNzaW5nIG9uIGFub3RoZXIgb2JqZWN0IGl0IHdpbGwgbmVlZCB0byBiZSBjYWNoZWRcblx0XHRyZXR1cm4gc2VsZlxuXG5cbmV4cG9ydCBjbGFzcyBDb25zdEFjY2VzcyA8IEFjY2Vzc1xuXG5cbmV4cG9ydCBjbGFzcyBJbmRleEFjY2VzcyA8IEFjY2Vzc1xuXG5cdGRlZiBjYWNoZSBvID0ge31cblx0XHRyZXR1cm4gc3VwZXIgaWYgbzpmb3JjZVxuXHRcdHJpZ2h0LmNhY2hlXG5cdFx0c2VsZlxuXG5cbmV4cG9ydCBjbGFzcyBTdXBlckFjY2VzcyA8IEFjY2Vzc1xuXG5cdGRlZiBqcyBvXG5cdFx0dmFyIG0gPSBvLm1ldGhvZFxuXHRcdHZhciB1cCA9IG8ucGFyZW50XG5cdFx0dmFyIGRlZXAgPSBvLnBhcmVudCBpc2EgQWNjZXNzXG5cblx0XHR2YXIgb3V0ID0gXCJ7bGVmdC5jfS5fX3N1cGVyX19cIlxuXG5cdFx0dW5sZXNzIHVwIGlzYSBBY2Nlc3Ncblx0XHRcdG91dCArPSBcIi57bS5zdXBlcm5hbWUuY31cIlxuXHRcdFx0dW5sZXNzIHVwIGlzYSBDYWxsICMgYXV0b2NhbGw/XG5cdFx0XHRcdG91dCArPSBcIi5hcHBseSh7bS5zY29wZS5jb250ZXh0LmN9LGFyZ3VtZW50cylcIlxuXG5cdFx0cmV0dXJuIG91dFxuXG5cdGRlZiByZWNlaXZlclxuXHRcdFNFTEZcblxuXG5leHBvcnQgY2xhc3MgVmFyT3JBY2Nlc3MgPCBWYWx1ZU5vZGVcblxuXHRkZWYgaW5pdGlhbGl6ZSB2YWx1ZVxuXHRcdCMgc2hvdWxkIHJhdGhlciBjYWxsIHVwIHRvIHZhbHVlbm9kZT9cblx0XHRAdHJhdmVyc2VkIFx0PSBub1xuXHRcdEBwYXJlbnMgXHQ9IG5vXG5cdFx0QHZhbHVlIFx0XHQ9IHZhbHVlXG5cdFx0QGlkZW50aWZpZXIgPSB2YWx1ZVxuXHRcdEB0b2tlbiBcdFx0PSB2YWx1ZS5AdmFsdWVcblx0XHRAdmFyaWFibGUgPSBudWxsXG5cdFx0c2VsZlxuXG5cdCMgU2hvcnRjaXJjdWl0IHRyYXZlcnNlIHNvIHRoYXQgaXQgaXMgbm90IGFkZGVkIHRvIHRoZSBzdGFjaz8hXG5cdGRlZiB2aXNpdFxuXHRcdCMgQGlkZW50aWZpZXIgPSB2YWx1ZSAjIHRoaXMgaXMgbm90IGEgcmVhbCBpZGVudGlmaWVyP1xuXHRcdCMgY29uc29sZS5sb2cgXCJWYXJPckFjY2VzcyB7QGlkZW50aWZpZXJ9XCJcblx0XHQjIHAgXCJ2aXNpdCB7c2VsZn1cIlxuXG5cblx0XHR2YXIgc2NvcGUgPSBzY29wZV9fXG5cblx0XHR2YXIgdmFyaWFibGUgPSBzY29wZS5sb29rdXAodmFsdWUpXG5cblx0XHQjIGRvZXMgbm90IHJlYWxseSBuZWVkIHRvIGhhdmUgYSBkZWNsYXJhdG9yIGFscmVhZHk/IC0tIHRyaWNreVxuXHRcdGlmIHZhcmlhYmxlICYmIHZhcmlhYmxlLmRlY2xhcmF0b3Jcblx0XHRcdCMgdmFyIGRlY2wgPSB2YXJpYWJsZS5kZWNsYXJhdG9yXG5cblx0XHRcdCMgaWYgdGhlIHZhcmlhYmxlIGlzIG5vdCBpbml0aWFsaXplZCBqdXN0IHlldCBhbmQgd2UgYXJlXG5cdFx0XHQjIGluIHRoZSBzYW1lIHNjb3BlIC0gd2Ugc2hvdWxkIG5vdCB0cmVhdCB0aGlzIGFzIGEgdmFyLWxvb2t1cFxuXHRcdFx0IyBpZS4gIHZhciB4ID0geCB3b3VsZCByZXNvbHZlIHRvIHZhciB4ID0gdGhpcy54KCkgaWYgeFxuXHRcdFx0IyB3YXMgbm90IHByZXZpb3VzbHkgZGVmaW5lZFxuXG5cdFx0XHQjIHNob3VsZCBkbyB0aGlzIGV2ZW4gaWYgd2UgYXJlIG5vdCBpbiB0aGUgc2FtZSBzY29wZT9cblx0XHRcdCMgd2Ugb25seSBuZWVkIHRvIGJlIGluIHRoZSBzYW1lIGNsb3N1cmUoISlcblxuXHRcdFx0aWYgdmFyaWFibGUuQGluaXRpYWxpemVkIG9yIChzY29wZS5jbG9zdXJlICE9IHZhcmlhYmxlLnNjb3BlLmNsb3N1cmUpXG5cdFx0XHRcdEB2YXJpYWJsZSA9IHZhcmlhYmxlXG5cdFx0XHRcdHZhcmlhYmxlLmFkZFJlZmVyZW5jZShzZWxmKVxuXHRcdFx0XHRAdmFsdWUgPSB2YXJpYWJsZSAjIHZhcmlhYmxlLmFjY2Vzc29yKHNlbGYpXG5cdFx0XHRcdEB0b2tlbi5AdmFyaWFibGUgPSB2YXJpYWJsZVxuXHRcdFx0XHRyZXR1cm4gc2VsZlxuXG5cdFx0XHQjIHAgXCJ2YXIgaXMgbm90IHlldCBpbml0aWFsaXplZCFcIlxuXHRcdFx0IyBwIFwiZGVjbGFyYXRvciBmb3IgdmFyIHtkZWNsLkBkZWNsYXJlZH1cIlxuXHRcdFx0IyBGSVhcblx0XHRcdCMgQHZhbHVlLnNhZmVjaGFpbiA9IHNhZmVjaGFpblxuXG5cdFx0IyBUT0RPIGRlcHJlY2F0ZSBhbmQgcmVtb3ZlXG5cdFx0aWYgdmFsdWUuc3ltYm9sLmluZGV4T2YoJyQnKSA+PSAwXG5cdFx0XHQjIGJpZyBoYWNrIC0gc2hvdWxkIGRpc2FibGVcblx0XHRcdCMgbWFqb3IgaGFjayBoZXJlLCBubz9cblx0XHRcdCMgY29uc29sZS5sb2cgXCJHbG9iYWxWYXJBY2Nlc3NcIlxuXHRcdFx0QHZhbHVlID0gR2xvYmFsVmFyQWNjZXNzLm5ldyh2YWx1ZSlcblx0XHRcdHJldHVybiBzZWxmXG5cblx0XHQjIHJlYWxseT8gd2hhdCBhYm91dCBqdXN0IG1pbWlja2luZyB0aGUgdHdvIGRpZmZyZW50IGluc3RlYWQ/XG5cdFx0IyBTaG91bGQgd2Ugbm90IHJldHVybiBhIGNhbGwgZGlyZWN0bHkgaW5zdGVhZD9cblx0XHRAdmFsdWUgPSBQcm9wZXJ0eUFjY2Vzcy5uZXcoXCIuXCIsc2NvcGUuY29udGV4dCx2YWx1ZSlcblx0XHQjIG1hcmsgdGhlIHNjb3BlIC8gY29udGV4dCAtLSBzbyB3ZSBjYW4gc2hvdyBjb3JyZWN0IGltcGxpY2l0XG5cdFx0QHRva2VuLkBtZXRhID0ge3R5cGU6ICdBQ0NFU1MnfVxuXHRcdCMgQHZhbHVlLnRyYXZlcnNlICMgbmFoXG5cdFx0c2VsZlxuXG5cdGRlZiBjXG5cdFx0bWFya19fKEB0b2tlbikgKyAoQHZhcmlhYmxlID8gc3VwZXIoKSA6IHZhbHVlLmMpXG5cblx0ZGVmIGpzIG9cblx0XG5cdFx0aWYgdmFyIHYgPSBAdmFyaWFibGVcblx0XHRcdHZhciBvdXQgPSB2LmNcblx0XHRcdG91dCArPSBcIigpXCIgaWYgdi5AdHlwZSA9PSAnbWV0aCcgYW5kICEoby51cCBpc2EgQ2FsbClcblx0XHRcdHJldHVybiBvdXRcblx0XHRyZXR1cm4gXCJOT05PXCJcblx0XHRcblx0ZGVmIG5vZGVcblx0XHRAdmFyaWFibGUgPyBzZWxmIDogdmFsdWVcblxuXHRkZWYgc3ltYm9sXG5cdFx0QGlkZW50aWZpZXIuc3ltYm9sXG5cdFx0IyB2YWx1ZSBhbmQgdmFsdWUuc3ltYm9sXG5cblx0ZGVmIGNhY2hlIG8gPSB7fVxuXHRcdEB2YXJpYWJsZSA/IChvOmZvcmNlIGFuZCBzdXBlcihvKSkgOiB2YWx1ZS5jYWNoZShvKVxuXHRcdCMgc2hvdWxkIHdlIHJlYWxseSBjYWNoZSB0aGlzP1xuXHRcdCMgdmFsdWUuY2FjaGUobylcblxuXHRkZWYgZGVjYWNoZVxuXHRcdEB2YXJpYWJsZSA/IHN1cGVyKCkgOiB2YWx1ZS5kZWNhY2hlXG5cdFx0c2VsZlxuXG5cdGRlZiBkb21cblx0XHR2YWx1ZS5kb21cblxuXHRkZWYgc2FmZWNoYWluXG5cdFx0QGlkZW50aWZpZXIuc2FmZWNoYWluXG5cblx0ZGVmIGR1bXBcblx0XHR7IGxvYzogbG9jIH1cblxuXHRkZWYgbG9jXG5cdFx0dmFyIGxvYyA9IEBpZGVudGlmaWVyLnJlZ2lvblxuXHRcdHJldHVybiBsb2Mgb3IgWzAsMF1cblxuXHRkZWYgcmVnaW9uXG5cdFx0QGlkZW50aWZpZXIucmVnaW9uXG5cblx0ZGVmIHRvU3RyaW5nXG5cdFx0XCJWYXJPckFjY2Vzcyh7dmFsdWV9KVwiXG5cblx0ZGVmIHRvSlNPTlxuXHRcdHt0eXBlOiB0eXBlTmFtZSwgdmFsdWU6IEBpZGVudGlmaWVyLnRvU3RyaW5nfVxuXG4jXHRkZWYganNcbiNcdFx0aWYgcmlnaHQgaXNhIFZhcmlhYmxlIGFuZCByaWdodC50eXBlID09ICdtZXRoJ1xuI1x0XHRcdHJldHVybiBcIntyaWdodC5jfSgpXCIgdW5sZXNzIHVwIGlzYSBDYWxsXG4jXG4jXHRcdHJpZ2h0LmNcbiNcbiNcdGRlZiB2YXJpYWJsZVxuI1x0XHRyaWdodFxuI1xuI1x0ZGVmIGNhY2hlIG8gPSB7fVxuI1x0XHRzdXBlciBpZiBvOmZvcmNlXG4jXHRcdHNlbGZcbiNcbiNcdGRlZiBhbGlhc1xuI1x0XHR2YXJpYWJsZS5AYWxpYXMgb3Igc3VwZXIgIyBpZiByZXNvbHZlZD9cbiNcblxuZXhwb3J0IGNsYXNzIFZhclJlZmVyZW5jZSA8IFZhbHVlTm9kZVxuXG5cdCMgVE9ETyBWYXJCbG9jayBzaG91bGQgY29udmVydCB0aGVzZSB0byBwbGFpbiAvIGR1bWIgbm9kZXNcblxuXHRwcm9wIHZhcmlhYmxlXG5cdHByb3AgZGVjbGFyZWRcblx0cHJvcCB0eXBlXG5cblx0ZGVmIGluaXRpYWxpemUgdmFsdWUsIHR5cGVcblx0XHRpZiB2YWx1ZSBpc2EgVmFyT3JBY2Nlc3Ncblx0XHRcdHZhbHVlID0gdmFsdWUudmFsdWVcblx0XHQjIGZvciBub3cgLSB0aGlzIGNhbiBoYXBwZW5cblx0XHRzdXBlcih2YWx1ZSlcblx0XHRAZXhwb3J0ID0gbm9cblx0XHRAdHlwZSA9IHR5cGUgYW5kIFN0cmluZyh0eXBlKVxuXHRcdEB2YXJpYWJsZSA9IG51bGxcblx0XHRAZGVjbGFyZWQgPSB5ZXMgIyBqdXN0IHRlc3Rpbmcgbm93XG5cblxuXHRkZWYgbG9jXG5cdFx0IyBwIFwibG9jIGZvciBWYXJSZWZlcmVuY2Uge0B2YWx1ZTpjb25zdHJ1Y3Rvcn0ge0B2YWx1ZS5AdmFsdWU6Y29uc3RydWN0b3J9IHtAdmFsdWUucmVnaW9ufVwiXG5cdFx0QHZhbHVlLnJlZ2lvblxuXG5cdGRlZiBzZXQgb1xuXHRcdCMgaGFjayAtIHdvcmthcm91bmQgZm9yIGhpZGRlbiBjbGFzc2VzIHBlcmZcblx0XHRAZXhwb3J0ID0geWVzIGlmIG86ZXhwb3J0XG5cdFx0cmV0dXJuIHNlbGZcblxuXHRkZWYganMgb1xuXHRcdCMgZXhwZXJpbWVudGFsIGZpeFxuXHRcdFxuXHRcdCMgd2hhdCBhYm91dCByZXNvbHZpbmc/XG5cdFx0dmFyIHJlZiA9IEB2YXJpYWJsZVxuXHRcdHZhciBvdXQgPSBcInttYXJrX18oQHZhbHVlKX17cmVmLmN9XCJcblxuXHRcdCMgcCBcIlZhclJlZmVyZW5jZSB7b3V0fSAtIHtvLnVwfSB7by51cCA9PSBzZWxmfVxcbntvfVwiXG5cblx0XHRpZiByZWYgJiYgIXJlZi5AZGVjbGFyZWQgIyAub3B0aW9uKDpkZWNsYXJlZClcblx0XHRcdGlmIG8udXAoVmFyQmxvY2spICMgdXAgdmFyYmxvY2s/P1xuXHRcdFx0XHRyZWYuQGRlY2xhcmVkID0geWVzXG5cblx0XHRcdFx0IyByZWYuc2V0KGRlY2xhcmVkOiB5ZXMpXG5cdFx0XHRlbGlmIG8uaXNFeHByZXNzaW9uIG9yIEBleHBvcnQgIyB3aHk/XG5cdFx0XHRcdCMgcCBcImF1dG9kZWNsYXJlXCJcblx0XHRcdFx0cmVmLmF1dG9kZWNsYXJlXG5cdFx0XHRlbHNlXG5cdFx0XHRcdG91dCA9IFwidmFyIHtvdXR9XCJcblx0XHRcdFx0cmVmLkBkZWNsYXJlZCA9IHllc1xuXHRcdFx0XHQjIHJlZi5zZXQoZGVjbGFyZWQ6IHllcylcblxuXHRcdCMgbmVlZCB0byB0aGluayB0aGUgZXhwb3J0IHRocm91Z2ggLS0gbGlrZSByZWdpc3RlcmluZyBzb21laG93XG5cdFx0IyBzaG91bGQgcmVnaXN0ZXIgaW4gc2NvcGUgLSBleHBvcnQgb24gYW5hbHlzaXMrK1xuXHRcdGlmIEBleHBvcnRcblx0XHRcdG91dCA9IFwibW9kdWxlLmV4cG9ydHMue3JlZi5jfSA9IHtyZWYuY31cIlxuXG5cdFx0cmV0dXJuIG91dFxuXG5cdGRlZiBkZWNsYXJlXG5cdFx0c2VsZlxuXG5cdGRlZiBjb25zdW1lIG5vZGVcblx0XHQjIHJlYWxseT8gdGhlIGNvbnN1bWVkIG5vZGUgZGlzc2FwcGVhcj9cblx0XHRAdmFyaWFibGUgJiYgQHZhcmlhYmxlLmF1dG9kZWNsYXJlXG5cdFx0c2VsZlxuXG5cdGRlZiB2aXNpdFxuXHRcdFxuXHRcdCMgY29uc29sZS5sb2cgXCJ2YWx1ZSB0eXBlIGZvciBWYXJSZWZlcmVuY2Uge0B2YWx1ZX0ge0B2YWx1ZS5AbG9jfSB7QHZhbHVlOmNvbnN0cnVjdG9yfVwiXG5cblx0XHQjIHNob3VsZCBiZSBwb3NzaWJsZSB0byBoYXZlIGEgVmFyUmVmZXJlbmNlIHdpdGhvdXQgYSBuYW1lIGFzIHdlbGw/IGZvciBhIHN5c3RlbS12YXJpYWJsZVxuXHRcdCMgbmFtZSBzaG91bGQgbm90IHNldCB0aGlzIHdheS5cblx0XHQjIHAgXCJ2YXJuYW1lIHt2YWx1ZX0ge3ZhbHVlOmNvbnN0cnVjdG9yfVwiXG5cdFx0dmFyIG5hbWUgPSB2YWx1ZS5jXG5cdFx0IyBwIFwidmlzaXQgdmFyZGVjbCB7bmFtZX0ge3ZhbHVlfVwiXG5cblx0XHQjIHdoYXQgYWJvdXQgbG9va2luZyB1cD8gLSBvbiByZWdpc3RlciB3ZSB3YW50IHRvIG1hcmtcblx0XHR2YXIgdiA9IEB2YXJpYWJsZSB8fD0gc2NvcGVfXy5yZWdpc3RlcihuYW1lLCBzZWxmLCB0eXBlOiBAdHlwZSlcblx0XHQjIEZJWE1FIC0tIHNob3VsZCBub3Qgc2ltcGx5IG92ZXJyaWRlIHRoZSBkZWNsYXJhdG9yIGhlcmUoISlcblxuXHRcdGlmICF2LmRlY2xhcmF0b3Jcblx0XHRcdHYuZGVjbGFyYXRvciA9IHNlbGZcblxuXHRcdHYuYWRkUmVmZXJlbmNlKEB2YWx1ZSkgaWYgQHZhbHVlICMgaXMgdGhpcyB0aGUgZmlyc3QgcmVmZXJlbmNlP1xuXG5cdFx0IyBvbmx5IG5lZWRlZCB3aGVuIGFuYWx5emluZz9cblx0XHRAdmFsdWUuQHZhbHVlLkB2YXJpYWJsZSA9IHZcblx0XHRzZWxmXG5cblx0ZGVmIHJlZm5yXG5cdFx0dmFyaWFibGUucmVmZXJlbmNlcy5pbmRleE9mKHZhbHVlKVxuXG5cdCMgY29udmVydCB0aGlzIGludG8gYSBsaXN0IG9mIHJlZmVyZW5jZXNcblx0ZGVmIGFkZEV4cHJlc3Npb24gZXhwclxuXG5cdFx0VmFyQmxvY2submV3KFtzZWxmXSkuYWRkRXhwcmVzc2lvbihleHByKVxuXG5cbiMgQVNTSUdOXG5cbmV4cG9ydCBjbGFzcyBBc3NpZ24gPCBPcFxuXG5cdGRlZiBpbml0aWFsaXplIG8sIGwsIHJcblxuXHRcdCMgd29ya2Fyb3VuZCB1bnRpbCB3ZSBjb21wbGV0ZSB0cmFuc2l0aW9uIGZyb20gbHVhLXN0eWxlIGFzc2lnbm1lbnRzXG5cdFx0IyB0byBhbHdheXMgdXNlIGV4cGxpY2l0IHR1cGxlcyAtIHRoZW4gd2UgY2FuIG1vdmUgYXNzaWdubWVudHMgb3V0IGV0Y1xuXHRcdCMgdGhpcyB3aWxsIG5vdCBiZSBuZWVkZWQgYWZ0ZXIgd2UgcmVtb3ZlIHN1cHBvcnQgZm9yIHZhciBhLGIsYyA9IDEsMiwzXG5cdFx0aWYgbCBpc2EgVmFyUmVmZXJlbmNlIGFuZCBsLnZhbHVlIGlzYSBBcnJcblx0XHRcdCMgY29udmVydGluZyBhbGwgbm9kZXMgdG8gdmFyLXJlZmVyZW5jZXMgP1xuXHRcdFx0IyBkbyB3ZSBuZWVkIHRvIGtlZXAgaXQgaW4gYSB2YXJibG9jayBhdCBhbGw/XG5cdFx0XHR2YXIgdmFycyA9IGwudmFsdWUubm9kZXMubWFwIGRvIHx2fFxuXHRcdFx0XHQjIHdoYXQgYWJvdXQgaW5uZXIgdHVwbGVzIGV0Yz9cblx0XHRcdFx0IyBrZWVwIHRoZSBzcGxhdHMgLS0gY2x1bXN5IGJ1dCB0cnVlXG5cdFx0XHRcdGlmIHYgaXNhIFNwbGF0XG5cdFx0XHRcdFx0IyBwIFwidmFsdWUgaXMgYSBzcGxhdCEhXCJcblx0XHRcdFx0XHR2LnZhbHVlID0gVmFyUmVmZXJlbmNlLm5ldyh2LnZhbHVlLGwudHlwZSkgdW5sZXNzIHYudmFsdWUgaXNhIFZhclJlZmVyZW5jZVxuXHRcdFx0XHRlbGlmIHYgaXNhIFZhclJlZmVyZW5jZVxuXHRcdFx0XHRcdHRydWVcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdCMgd2hhdCBhYm91dCByZXRhaW5pbmcgbG9jYXRpb24/XG5cdFx0XHRcdFx0IyB2ID0gdi52YWx1ZSBpZiB2IGlzYSBWYXJPckFjY2Vzc1xuXHRcdFx0XHRcdHYgPSBWYXJSZWZlcmVuY2UubmV3KHYsbC50eXBlKVxuXG5cdFx0XHRcdHJldHVybiB2XG5cdFx0XHRcdFxuXHRcdFx0XHQjIHYgaXNhIFZhclJlZmVyZW5jZSA/IHYgOiBWYXJSZWZlcmVuY2UubmV3KHYpXG5cdFx0XHRyZXR1cm4gVHVwbGVBc3NpZ24ubmV3KG8sVHVwbGUubmV3KHZhcnMpLHIpXG5cblx0XHRpZiBsIGlzYSBBcnJcblx0XHRcdHJldHVybiBUdXBsZUFzc2lnbi5uZXcobyxUdXBsZS5uZXcobC5ub2Rlcykscilcblx0XHRcdCMgcCBcImxlZnQgaXMgYXJyYXkgaW4gYXNzaWduIC0gaW4gaW5pdFwiXG5cblxuXHRcdCMgc2V0IGV4cHJlc3Npb24geWVzLCBubz9cblx0XHRAZXhwcmVzc2lvbiA9IG5vXG5cdFx0QHRyYXZlcnNlZCA9IG5vXG5cdFx0QHBhcmVucyA9IG5vXG5cdFx0QGNhY2hlID0gbnVsbFxuXHRcdEBpbnZlcnQgPSBub1xuXHRcdEBvcFRva2VuID0gb1xuXHRcdEBvcCA9IG8gYW5kIG8uQHZhbHVlIG9yIG9cblx0XHRAbGVmdCA9IGxcblx0XHRAcmlnaHQgPSByXG5cdFx0cmV0dXJuIHNlbGZcblxuXHRkZWYgaXNFeHByZXNzYWJsZVxuXHRcdCFyaWdodCB8fCByaWdodC5pc0V4cHJlc3NhYmxlXG5cblx0ZGVmIGlzVXNlZFxuXHRcdCMgcmVhbGx5P1xuXHRcdCMgaWYgdXAgaXMgYSBibG9jayBpbiBnZW5lcmFsIHRoaXMgc2hvdWxkIG5vdCBiZSB1c2VkIC0tIHNpbmNlIGl0IHNob3VsZCBhbHJlYWR5IGhhdmUgcmVjZWl2ZWQgaW1wbGljaXQgc2VsZj9cblx0XHRpZiB1cCBpc2EgQmxvY2sgIyAmJiB1cC5sYXN0ICE9IHNlbGZcblx0XHRcdHJldHVybiBubyBcblx0XHRyZXR1cm4geWVzXG5cblx0IyBGSVhNRSBvcHRpbWl6ZVxuXHRkZWYgdmlzaXRcblx0XHR2YXIgbCA9IEBsZWZ0XG5cdFx0dmFyIHIgPSBAcmlnaHRcblxuXHRcdCMgV0FSTklORyAtIHNsaWdodGx5IHVuZGVmaW5lZFxuXHRcdCMgTUFSSyBUSEUgU1RBQ0tcblx0XHRsLnRyYXZlcnNlIGlmIGxcblxuXHRcdHZhciBsdmFyID0gbCBpc2EgVmFyUmVmZXJlbmNlIGFuZCBsLnZhcmlhYmxlXG5cblx0XHQjIGhvdyBkb2VzIHRoaXMgd29yayB3aXRoIGNvbnN0YW50cyB0aGF0IGFyZSByZWFsbHkgdmFyIHJlZmVyZW5jZXM/XG5cdFx0IyBzaG91bGQgd29yayB3aGVuIHRoaW5ncyBhcmUgbm90IGRlc2NyaWJlZCBhcyB3ZWxsIC0gYnV0IHRoaXMgaXMgZm9yIHRlc3Rpbmdcblx0XHQjIGJ1dCBpZiBpdCByZWZlcnMgdG8gc29tZXRoaW5nIGVsc2UgXG5cdFx0aWYgIWx2YXIgYW5kIEBkZXNjXG5cdFx0XHQjIGVudGl0aWVzIHNob3VsZCBiZSBhYmxlIHRvIGV4dHJhY3QgdGhlIG5lZWRlZCBpbmZvIGluc3RlYWRcblx0XHRcdFJPT1QuZW50aXRpZXMuYWRkKGwubmFtZXBhdGgse25hbWVwYXRoOiBsLm5hbWVwYXRoLCB0eXBlOiByLnR5cGVOYW1lLCBkZXNjOiBAZGVzY30pXG5cblx0XHQjIHRoaXMgc2hvdWxkIHByb2JhYmx5IGJlIGRvbmUgaW4gYSBkaWZmZXJlbnQgbWFubmVyXG5cdFx0aWYgbHZhciBhbmQgbHZhci5kZWNsYXJhdG9yID09IGxcblx0XHRcdGx2YXIuQGluaXRpYWxpemVkID0gbm9cblx0XHRcdHIudHJhdmVyc2UgaWYgclxuXHRcdFx0bHZhci5AaW5pdGlhbGl6ZWQgPSB5ZXNcblxuXHRcdGVsc2Vcblx0XHRcdHIudHJhdmVyc2UgaWYgclxuXG5cdFx0aWYgbCBpc2EgVmFyUmVmZXJlbmNlIG9yIGwuQHZhcmlhYmxlXG5cdFx0XHRsLkB2YXJpYWJsZS5hc3NpZ25lZChyLHNlbGYpXG5cblx0XHRyZXR1cm4gc2VsZlxuXHRcblx0ZGVmIGMgb1xuXHRcdHVubGVzcyByaWdodC5pc0V4cHJlc3NhYmxlXG5cdFx0XHQjIHAgXCJBc3NpZ24jYyByaWdodCBpcyBub3QgZXhwcmVzc2FibGUgXCJcblx0XHRcdHJldHVybiByaWdodC5jb25zdW1lKHNlbGYpLmMobylcblx0XHQjIHRlc3RpbmcgdGhpc1xuXHRcdHJldHVybiBzdXBlcihvKVxuXG5cdGRlZiBqcyBvXG5cdFx0dW5sZXNzIHJpZ2h0LmlzRXhwcmVzc2FibGVcblx0XHRcdHAgXCJBc3NpZ24janMgcmlnaHQgaXMgbm90IGV4cHJlc3NhYmxlIFwiXG5cdFx0XHQjIGhlcmUgdGhpcyBzaG91bGQgYmUgZ28gb3V0IG9mIHRoZSBzdGFjayghKVxuXHRcdFx0IyBpdCBzaG91bGQgYWxyZWFkeSBiZSBjb25zdW1lZD9cblx0XHRcdHJldHVybiByaWdodC5jb25zdW1lKHNlbGYpLmNcblxuXHRcdCMgcCBcImFzc2lnbiBsZWZ0IHtsZWZ0OmNvbnRyc3RydX1cIlxuXHRcdHZhciBsID0gbGVmdC5ub2RlXG5cdFx0dmFyIHIgPSByaWdodFxuXG5cdFx0IyBXZSBhcmUgc2V0dGluZyBzZWxmKCEpXG5cdFx0IyBUT0RPIGRvY3VtZW50IGZ1bmN0aW9uYWxpdHlcblx0XHRpZiBsIGlzYSBTZWxmXG5cdFx0XHR2YXIgY3R4ID0gc2NvcGVfXy5jb250ZXh0XG5cdFx0XHRsID0gY3R4LnJlZmVyZW5jZVxuXG5cblx0XHRpZiBsIGlzYSBQcm9wZXJ0eUFjY2Vzc1xuXHRcdFx0dmFyIGFzdCA9IENBTEwoT1AoJy4nLGwubGVmdCxsLnJpZ2h0LnNldHRlciksW3JpZ2h0XSlcblx0XHRcdGFzdC5yZWNlaXZlciA9IGwucmVjZWl2ZXJcblxuXHRcdFx0aWYgaXNVc2VkXG5cdFx0XHRcdCMgcCBcIkFzc2lnbiBpcyB1c2VkIHtzdGFja31cIlxuXHRcdFx0XHQjIGRvbnQgY2FjaGUgaXQgYWdhaW4gaWYgaXQgaXMgYWxyZWFkeSBjYWNoZWQoISlcblx0XHRcdFx0cmlnaHQuY2FjaGUocG9vbDogJ3ZhbCcsIHVzZXM6IDEpIHVubGVzcyByaWdodC5jYWNoZXZhciAjIFxuXHRcdFx0XHQjIHRoaXMgaXMgb25seSB3aGVuIHVzZWQuLiBzaG91bGQgYmUgbW9yZSBjbGV2ZXIgYWJvdXQgaXRcblx0XHRcdFx0YXN0ID0gUGFyZW5zLm5ldyhibGtfXyhbYXN0LHJpZ2h0XSkpXG5cblx0XHRcdCMgc2hvdWxkIGNoZWNrIHRoZSB1cC12YWx1ZSBubz9cblx0XHRcdHJldHVybiBhc3QuYyhleHByZXNzaW9uOiB5ZXMpXG5cblx0XHQjIGlmIGwgaXNhIFZhclJlZmVyZW5jZVxuXHRcdCMgXHRwIFwiYXNzaWduIHZhci1yZWZcIlxuXHRcdCMgXHRsLkB2YXJpYWJsZS5hc3NpZ25lZChyKVxuXG5cdFx0IyBGSVhNRSAtLSBkb2VzIG5vdCBhbHdheXMgbmVlZCB0byBiZSBhbiBleHByZXNzaW9uP1xuXHRcdCMgcCBcInR5cGVvZiBvcCB7QG9wVG9rZW4gYW5kIEBvcFRva2VuOmNvbnN0cnVjdG9yfVwiXG5cdFx0dmFyIG91dCA9IFwie2wuY30ge21hcmtfXyhAb3BUb2tlbil9e29wfSB7cmlnaHQuYyhleHByZXNzaW9uOiB0cnVlKX1cIlxuXG5cdFx0cmV0dXJuIG91dFxuXG5cdCMgRklYTUUgb3AgaXMgYSB0b2tlbj8gX0ZJWF9cblx0IyB0aGlzIChhbmQgc2ltaWxhciBjYXNlcykgaXMgYnJva2VuIHdoZW4gY2FsbGVkIGZyb21cblx0IyBhbm90aGVyIHBvc2l0aW9uIGluIHRoZSBzdGFjaywgc2luY2UgJ3VwJyBpcyBkeW5hbWljXG5cdCMgc2hvdWxkIG1heWJlIGZyZWV6ZSB1cD9cblx0ZGVmIHNob3VsZFBhcmVudGhlc2l6ZSBwYXIgPSB1cFxuXHRcdEBwYXJlbnMgb3IgcGFyIGlzYSBPcCAmJiBwYXIub3AgIT0gJz0nXG5cblx0ZGVmIGNvbnN1bWUgbm9kZVxuXHRcdGlmIGlzRXhwcmVzc2FibGVcblx0XHRcdGZvcmNlRXhwcmVzc2lvblxuXHRcdFx0cmV0dXJuIHN1cGVyKG5vZGUpXG5cblx0XHR2YXIgYXN0ID0gcmlnaHQuY29uc3VtZShzZWxmKVxuXHRcdHJldHVybiBhc3QuY29uc3VtZShub2RlKVxuXG5cdCMgbW9yZSB3b3JrYXJvdW5kIGR1cmluZyB0cmFuc2l0aW9uIGF3YXkgZnJvbSBhLGIsYyA9IDEsMiwzIHN0eWxlIGFzc2lnblxuXHRkZWYgYWRkRXhwcmVzc2lvbiBleHByXG5cdFx0dmFyIHR5cCA9IEV4cHJlc3Npb25CbG9ja1xuXHRcdGlmIEBsZWZ0IGFuZCBAbGVmdCBpc2EgVmFyUmVmZXJlbmNlXG5cdFx0XHR0eXAgPSBWYXJCbG9ja1xuXHRcdCMgbWlnaHQgYmUgYmV0dGVyIHRvIG5lc3QgdGhpcyB1cCBhZnRlciBwYXJzaW5nIGlzIGRvbmU/XG5cdFx0IyBwIFwiQXNzaWduLmFkZEV4cHJlc3Npb24ge3NlbGZ9IDwtIHtleHByfVwiXG5cdFx0dmFyIG5vZGUgPSB0eXAubmV3KFtzZWxmXSlcblx0XHRyZXR1cm4gbm9kZS5hZGRFeHByZXNzaW9uKGV4cHIpXG5cblxuZXhwb3J0IGNsYXNzIFB1c2hBc3NpZ24gPCBBc3NpZ25cblxuXHRkZWYganMgb1xuXHRcdFwie2xlZnQuY30ucHVzaCh7cmlnaHQuY30pXCJcblxuXHRkZWYgY29uc3VtZSBub2RlXG5cdFx0cmV0dXJuIHNlbGZcblxuXG5leHBvcnQgY2xhc3MgQ29uZGl0aW9uYWxBc3NpZ24gPCBBc3NpZ25cblxuXHRkZWYgY29uc3VtZSBub2RlXG5cdFx0bm9ybWFsaXplLmNvbnN1bWUobm9kZSlcblxuXHRkZWYgbm9ybWFsaXplXG5cdFx0dmFyIGwgPSBsZWZ0Lm5vZGVcblx0XHR2YXIgbHMgPSBsXG5cblx0XHRpZiBsIGlzYSBBY2Nlc3Ncblx0XHRcdCMgcCBcImNvbmRpdGlvbmFsLWFzc2lnbiB7bH0ge2wubGVmdH0ge2wucmlnaHR9XCJcblx0XHRcdGlmIGwubGVmdFxuXHRcdFx0XHQjIHAgXCJjYWNoZSBsLmxlZnQge2wubGVmdDpjb25zdHJ1Y3Rvcn3Mi1wiXG5cdFx0XHRcdGwubGVmdC5jYWNoZSBcblx0XHRcdGxzID0gbC5jbG9uZShsLmxlZnQsbC5yaWdodCkgIyB0aGlzIHNob3VsZCBzdGlsbCBiZSBjYWNoZWQ/XG5cdFx0XHRsLmNhY2hlIGlmIGwgaXNhIFByb3BlcnR5QWNjZXNzICMgY29ycmVjdCBub3csIHRvIGEgY2VydGFpbiBkZWdyZWVcblx0XHRcdGlmIGwgaXNhIEluZGV4QWNjZXNzXG5cdFx0XHRcdCMgcCBcImNhY2hlIHRoZSByaWdodCBzaWRlIG9mIGluZGV4QWNjZXNzISEhIHtsLnJpZ2h0fVwiXG5cdFx0XHRcdGwucmlnaHQuY2FjaGUgXG5cblx0XHRcdCMgd2Ugc2hvdWxkIG9ubHkgY2FjaGUgdGhlIHZhbHVlIGl0c2VsZiBpZiBpdCBpcyBkeW5hbWljP1xuXHRcdFx0IyBsLmNhY2hlICMgY2FjaGUgdGhlIHZhbHVlIGFzIHdlbGwgLS0gd2UgY2Fubm90IHVzZSB0aGlzIGluIGFzc2lnbnMgdGhlbVxuXG5cdFx0IyBzb21lIG9wcyBhcmUgbGVzcyBtZXNzeVxuXHRcdCMgbmVlZCBvcCB0byBzdXBwb3J0IGNvbnN1bWUgdGhlbj9cblx0XHR2YXIgZXhwciA9IHJpZ2h0LmlzRXhwcmVzc2FibGVcblx0XHR2YXIgYXN0ID0gbnVsbFxuXHRcdCMgaGVyZSB3ZSBzaG91bGQgdXNlIGFzdCA9IGlmIC4uLlxuXHRcdGlmIGV4cHIgJiYgb3AgPT0gJ3x8PSdcblx0XHRcdGFzdCA9IE9QKCd8fCcsbCwgT1AoJz0nLGxzLHJpZ2h0KSlcblx0XHRlbGlmIGV4cHIgJiYgb3AgPT0gJyYmPSdcblx0XHRcdGFzdCA9IE9QKCcmJicsbCwgT1AoJz0nLGxzLHJpZ2h0KSlcblx0XHRlbHNlXG5cdFx0XHRhc3QgPSBJRihjb25kaXRpb24sIE9QKCc9JyxscyxyaWdodCksIGwpICMgZG8gd2UgbmVlZCBhIHNjb3BlIGZvciB0aGVzZT9cblx0XHRcdGFzdC5zY29wZSA9IG51bGxcblx0XHRcdCMgZHJvcCB0aGUgc2NvcGVcblx0XHRcdCMgdG91Y2ggc2NvcGUgLS0gc2hvdWxkIHByb2JhYmx5IHZpc2l0IHRoZSB3aG9sZSB0aGluZz9cblx0XHRcdCMgYXN0LnNjb3BlLnZpc2l0XG5cdFx0YXN0LnRvRXhwcmVzc2lvbiBpZiBhc3QuaXNFeHByZXNzYWJsZVxuXHRcdGFzdFxuXG5cblx0ZGVmIGNcblx0XHQjIFdBUk4gd2hhdCBpZiB3ZSByZXR1cm4gdGhlIHNhbWU/XG5cdFx0bm9ybWFsaXplLmNcblxuXHRkZWYgY29uZGl0aW9uXG5cblx0XHQjIHVzZSBzd2l0Y2ggaW5zdGVhZCB0byBjYWNoZSBvcCBhY2Nlc3Ncblx0XHRpZiBvcCA9PSAnPz0nXG5cdFx0XHRPUCgnPT0nLGxlZnQsTlVMTClcblx0XHRlbGlmIG9wID09ICd8fD0nXG5cdFx0XHRPUCgnIScsbGVmdClcblx0XHRlbGlmIG9wID09ICcmJj0nXG5cdFx0XHRsZWZ0XG5cdFx0ZWxpZiBvcCA9PSAnIT89J1xuXHRcdFx0T1AoJyE9JyxsZWZ0LE5VTEwpXG5cdFx0ZWxzZVxuXHRcdFx0bGVmdFxuXHRcdFxuXHRkZWYganMgb1xuXHRcdCMgcCBcIkNvbmRpdGlvbmFsQXNzaWduLmpzXCIucmVkXG5cdFx0dmFyIGFzdCA9IElGKGNvbmRpdGlvbiwgT1AoJz0nLGxlZnQscmlnaHQpLCBsZWZ0KVxuXHRcdGFzdC5zY29wZSA9IG51bGwgIyBub3Qgc3VyZSBhYm91dCB0aGlzXG5cdFx0YXN0LnRvRXhwcmVzc2lvbiBpZiBhc3QuaXNFeHByZXNzYWJsZSAjIGZvcmNlZCBleHByZXNzaW9uIGFscmVhZHlcblx0XHRyZXR1cm4gYXN0LmNcblxuZXhwb3J0IGNsYXNzIENvbXBvdW5kQXNzaWduIDwgQXNzaWduXG5cblx0IyBGSVhNRSBjYW4gd2UgbWVyZ2UgY29uc3VtZSBhbmQganM/XG5cdGRlZiBjb25zdW1lIG5vZGVcblx0XHRyZXR1cm4gc3VwZXIgaWYgaXNFeHByZXNzYWJsZVxuXG5cdFx0dmFyIGFzdCA9IG5vcm1hbGl6ZVxuXHRcdHJldHVybiBhc3QuY29uc3VtZShub2RlKSB1bmxlc3MgYXN0ID09IHNlbGZcblxuXHRcdGFzdCA9IHJpZ2h0LmNvbnN1bWUoc2VsZilcblx0XHRyZXR1cm4gYXN0LmNvbnN1bWUobm9kZSlcblxuXHRkZWYgbm9ybWFsaXplXG5cdFx0dmFyIGxuID0gbGVmdC5ub2RlXG5cdFx0IyB3ZSBkb250IG5lZWQgdG8gY2hhbmdlIHRoaXMgYXQgYWxsXG5cdFx0dW5sZXNzIGxuIGlzYSBQcm9wZXJ0eUFjY2Vzc1xuXHRcdFx0cmV0dXJuIHNlbGZcblxuXHRcdGlmIGxuIGlzYSBBY2Nlc3Ncblx0XHRcdCMgbGVmdCBtaWdodCBiZSB6ZXJvPyE/IVxuXHRcdFx0bG4ubGVmdC5jYWNoZSBpZiBsbi5sZWZ0XG5cdFx0IyBUT0RPIEZJWE1FIHdlIHdhbnQgdG8gY2FjaGUgdGhlIGNvbnRleHQgb2YgdGhlIGFzc2lnbm1lbnRcblx0XHQjIHAgXCJub3JtYWxpemUgY29tcG91bmQgYXNzaWduIHtsZWZ0fVwiXG5cdFx0dmFyIGFzdCA9IE9QKCc9JyxsZWZ0LE9QKG9wWzBdLGxlZnQscmlnaHQpKVxuXHRcdGFzdC50b0V4cHJlc3Npb24gaWYgYXN0LmlzRXhwcmVzc2FibGVcblxuXHRcdHJldHVybiBhc3Rcblx0XHRcblx0ZGVmIGNcblx0XHR2YXIgYXN0ID0gbm9ybWFsaXplXG5cdFx0cmV0dXJuIHN1cGVyIGlmIGFzdCA9PSBzZWxmXG5cblx0XHQjIG90aGVyd2lzZSBpdCBpcyBpbXBvcnRhbnQgdGhhdCB3ZSBhY3R1YWxseSByZXBsYWNlIHRoaXMgbm9kZSBpbiB0aGUgb3V0ZXIgYmxvY2tcblx0XHQjIHdoZW5ldmVyIHdlIG5vcm1hbGl6ZSBhbmQgb3ZlcnJpZGUgYyBpdCBpcyBpbXBvcnRhbnQgdGhhdCB3ZSBjYW4gcGFzcyBvbiBjYWNoaW5nXG5cdFx0IyBldGMgLS0gb3RoZXJ3aXNlIHRoZXJlIFdJTEwgYmUgaXNzdWVzLlxuXHRcdHZhciB1cCA9IFNUQUNLLmN1cnJlbnRcblx0XHRpZiB1cCBpc2EgQmxvY2tcblx0XHRcdCMgcCBcInBhcmVudCBpcyBibG9jaywgc2hvdWxkIHJlcGxhY2UhXCJcblx0XHRcdCMgYW4gYWx0ZXJuYXRpdmUgd291bGQgYmUgdG8ganVzdCBwYXNzXG5cdFx0XHR1cC5yZXBsYWNlKHNlbGYsYXN0KVxuXHRcdGFzdC5jXG5cblxuZXhwb3J0IGNsYXNzIEFzeW5jQXNzaWduIDwgQXNzaWduXG5cblx0IyB0aGlzIHdpbGwgdHJhbnNmb3JtIHRoZSB0cmVlIGJ5IGEgZGVjZW50IGFtb3VudC5cblx0IyBOZWVkIHRvIGFkanVzdCBCbG9jayB0byBhbGxvdyB0aGlzXG5cblxuZXhwb3J0IGNsYXNzIFR1cGxlQXNzaWduIDwgQXNzaWduXG5cblx0cHJvcCBvcFxuXHRwcm9wIGxlZnRcblx0cHJvcCByaWdodFxuXHRwcm9wIHR5cGVcblxuXHRkZWYgaW5pdGlhbGl6ZSBhLGIsY1xuXHRcdEB0cmF2ZXJzZWQgPSBub1xuXHRcdEBvcCA9IGFcblx0XHRAbGVmdCA9IGJcblx0XHRAcmlnaHQgPSBjXG5cdFx0QHRlbXBvcmFyeSA9IFtdXG5cblx0ZGVmIGlzRXhwcmVzc2FibGVcblx0XHRyaWdodC5pc0V4cHJlc3NhYmxlXG5cblx0ZGVmIGFkZEV4cHJlc3Npb24gZXhwclxuXHRcdGlmIHJpZ2h0IGlzYSBUdXBsZVxuXHRcdFx0cmlnaHQucHVzaChleHByKVxuXHRcdGVsc2Vcblx0XHRcdCMgcCBcIm1ha2luZyBjaGlsZCBiZWNvbWUgYSB0dXBsZT9cIlxuXHRcdFx0c2VsZi5yaWdodCA9IFR1cGxlLm5ldyhbcmlnaHQsZXhwcl0pXG5cdFx0XG5cdFx0cmV0dXJuIHNlbGZcblxuXHRkZWYgdmlzaXRcblx0XHQjIGlmIHRoZSBmaXJzdCBsZWZ0LXZhbHVlIGlzIGEgdmFyLXJlZmVyZW5jZSwgdGhlblxuXHRcdCMgYWxsIHRoZSB2YXJpYWJsZXMgc2hvdWxkIGJlIGRlY2xhcmVkIGFzIHZhcmlhYmxlcy5cblx0XHQjIGJ1dCBpZiB3ZSBoYXZlIGNvbXBsZXggaXRlbXMgaW4gdGhlIG90aGVyIGxpc3QgLSBpdCBkb2VzIGJlY29tZSBtdWNoIGhhcmRlclxuXG5cdFx0IyBpZiB0aGUgZmlyc3QgaXMgYSB2YXItcmVmZXJlbmNlLCB0aGV5IHNob3VsZCBhbGwgYmUoISkgLi4gb3Igc3BsYXRzP1xuXHRcdCMgdGhpcyBpcyByZWFsbHkgYSBoYWNreSB3YW8gdG8gZG8gaXQgdGhvdWdoXG5cdFx0aWYgbGVmdC5maXJzdC5ub2RlIGlzYSBWYXJSZWZlcmVuY2Vcblx0XHRcdHNlbGYudHlwZSA9ICd2YXInXG5cdFx0XHQjIHNob3VsZCBwb3NzaWJseSBhbGxvdyByZWFsIHZhcnMgYXMgd2VsbCwgbm8/XG5cdFx0XHRAdmFycyA9IGxlZnQubm9kZXMuZmlsdGVyKHxufCBuIGlzYSBWYXJSZWZlcmVuY2UpXG5cdFx0XHQjIGNvbGxlY3QgdGhlIHZhcnMgZm9yIHR1cGxlIGZvciBlYXN5IGFjY2Vzc1xuXG5cdFx0XHQjIE5PVEUgY2FuIGltcHJvdmUuLiBzaG91bGQgcmF0aGVyIG1ha2UgdGhlIHdob2xlIGxlZnQgYmUgYSBWYXJCbG9jayBvciBUdXBsZVZhckJsb2NrXG5cdFx0XHQjIHAgXCJ0eXBlIGlzIHZhciAtLSBza2lwIHRoZSByZXN0XCJcblxuXHRcdHJpZ2h0LnRyYXZlcnNlXG5cdFx0bGVmdC50cmF2ZXJzZVxuXHRcdHNlbGZcblxuXHRkZWYganMgb1xuXHRcdCMgb25seSBmb3IgYWN0dWFsIGlubmVyIGV4cHJlc3Npb25zLCBvdGhlcndpc2UgY2FjaGUgdGhlIHdob2xlIGFycmF5LCBubz9cblx0XHR1bmxlc3MgcmlnaHQuaXNFeHByZXNzYWJsZVxuXHRcdFx0IyBwIFwiVHVwbGVBc3NpZ24uY29uc3VtZSEge3JpZ2h0fVwiLmJsdWVcblx0XHRcblx0XHRcdHJldHVybiByaWdodC5jb25zdW1lKHNlbGYpLmNcblxuXHRcdCMgcCBcIlRVUExFIHt0eXBlfVwiXG5cblx0XHQjIyMgYSxiLGMgPSBhcmd1bWVudHMgIyMjXG5cdFx0IyAtIGRpcmVjdC4gbm8gbWF0dGVyIGlmIGx2YWx1ZXMgYXJlIHZhcmlhYmxlcyBvciBub3QuIE1ha2UgZmFrZSBhcmd1bWVudHMgdXAgdG8gdGhlIHNhbWUgY291bnQgYXMgdHVwbGVcblxuXHRcdCMjIyBhLCpiLGIgPSBhcmd1bWVudHMgIyMjXG5cdFx0IyBOZWVkIHRvIGNvbnZlcnQgYXJndW1lbnRzIHRvIGFuIGFycmF5LiBJRiBhcmd1bWVudHMgaXMgbm90IHJlZmVyZW5jZWQgYW55d2hlcmUgZWxzZSBpbiBzY29wZSwgXG5cdFx0IyB3ZSBjYW4gZG8gdGhlIGFzc2lnbm1lbnQgZGlyZWN0bHkgd2hpbGUgcm9sbGluZyB0aHJvdWdoIGFyZ3VtZW50c1xuXG5cdFx0IyMjIGEsYiA9IGIsYSAjIyNcblx0XHQjIGlkZWFsbHkgd2Ugb25seSBuZWVkIHRvIGNhY2hlIHRoZSBmaXJzdCB2YWx1ZSAob3IgbiAtIDEpLCBhc3NpZ24gZGlyZWN0bHkgd2hlbiBwb3NzaWJsZS5cblxuXHRcdCMjIyBhLGIsYyA9IChtZXRob2QgfCBleHByZXNzaW9uKSAjIyNcblx0XHQjIGNvbnZlcnQgcmVzIGludG8gYXJyYXksIGFzc2lnbiBmcm9tIGFycmF5LiBDYW4gY2FjaGUgdGhlIHZhcmlhYmxlIHdoZW4gYXNzaWduaW5nIGZpcnN0IHZhbHVlXG5cblx0XHQjIEZpcnN0IHdlIG5lZWQgdG8gZmluZCBvdXQgd2hldGhlciB3ZSBhcmUgcmVxdWlyZWQgdG8gc3RvcmUgdGhlIHJlc3VsdCBpbiBhbiBhcnJheSBiZWZvcmUgYXNzaWduaW5nXG5cdFx0IyBJZiB0aGlzIG5lZWRzIHRvIGJlIGFuIGV4cHJlc3Npb24gKHJldHVybnM/LCB3ZSBuZWVkIHRvIGZhbGwgYmFjayB0byB0aGUgQ1Mtd2EpXG5cblx0XHR2YXIgYXN0ID0gQmxvY2submV3KFtdKVxuXHRcdHZhciBsZnQgPSBzZWxmLmxlZnRcblx0XHR2YXIgcmd0ID0gc2VsZi5yaWdodFxuXHRcdHZhciB0eXAgPSBzZWxmLnR5cGVcblx0XHR2YXIgdmlhID0gbnVsbFxuXG5cdFx0dmFyIGxpICAgPSAwXG5cdFx0dmFyIHJpICAgPSBsZnQuY291bnRcblx0XHR2YXIgbGxlbiA9IHJpXG5cblxuXHRcdCMgaWYgQHZhcnNcblx0XHQjIFx0cCBcInR1cGxlIGhhcyB7QHZhcnM6bGVuZ3RofSB2YXJzXCJcblxuXHRcdCMgaWYgd2UgaGF2ZSBhIHNwbGF0IG9uIHRoZSBsZWZ0IGl0IGlzIG11Y2ggbW9yZSBsaWtlbHkgdGhhdCB3ZSBuZWVkIHRvIHN0b3JlIHJpZ2h0XG5cdFx0IyBpbiBhIHRlbXBvcmFyeSBhcnJheSwgYnV0IGlmIHRoZSByaWdodCBzaWRlIGhhcyBhIGtub3duIGxlbmd0aCwgaXQgc2hvdWxkIHN0aWxsIG5vdCBiZSBuZWVkZWRcblx0XHR2YXIgbHNwbGF0ID0gbGZ0LmZpbHRlcih8dnwgdiBpc2EgU3BsYXQgKVswXVxuXG5cdFx0IyBpZiByaWdodCBpcyBhbiBhcnJheSB3aXRob3V0IGFueSBzcGxhdHMgKG9yIGlubmVyIHR1cGxlcz8pLCBub3JtYWxpemUgaXQgdG8gdHVwbGVcblx0XHRyZ3QgPSBUdXBsZS5uZXcocmd0Lm5vZGVzKSBpZiByZ3QgaXNhIEFyciAmJiAhcmd0LnNwbGF0XG5cdFx0dmFyIHJsZW4gPSByZ3QgaXNhIFR1cGxlID8gcmd0LmNvdW50IDogbnVsbFxuXG5cdFx0IyBpZiBhbnkgdmFsdWVzIGFyZSBzdGF0ZW1lbnRzIHdlIG5lZWQgdG8gaGFuZGxlIHRoaXMgYmVmb3JlIGNvbnRpbnVpbmdcblxuXHRcdCMjIyBhLGIsYyA9IDEwLDIwLGFyeSAjIyNcblx0XHQjIGlkZWFsbHkgd2Ugb25seSBuZWVkIHRvIGNhY2hlIHRoZSBmaXJzdCB2YWx1ZSAob3IgbiAtIDEpLCBhc3NpZ24gZGlyZWN0bHkgd2hlbiBwb3NzaWJsZS5cblx0XHQjIG9ubHkgaWYgdGhlIHZhcmlhYmxlcyBhcmUgbm90IHByZWRlZmluZWQgb3IgcHJlZGVjbGFyZWQgY2FuIGJlIHdlIGNlcnRhaW4gdGhhdCB3ZSBjYW4gZG8gaXQgd2l0aG91dCBjYWNoaW5nXG5cdFx0IyBpZiBybGVuICYmIHR5cCA9PSAndmFyJyAmJiAhbHNwbGF0XG5cdFx0IyBcdCMgdGhpcyBjYW4gYmUgZGFuZ2Vyb3VzIGluIGVkZ2VjYXNlcyB0aGF0IGFyZSB2ZXJ5IGhhcmQgdG8gZGV0ZWN0XG5cdFx0IyBcdCMgaWYgaXQgYmVjb21lcyBhbiBpc3N1ZSwgZmFsbCBiYWNrIHRvIHNpbXBsZXIgdmVyc2lvbnNcblx0XHQjIFx0IyBkb2VzIG5vdCBldmVuIG1hdHRlciBpZiB0aGVyZSBpcyBhIHNwbGF0P1xuXG5cdFx0IyBzcGVjaWFsIGNhc2UgZm9yIGFyZ3VtZW50cyghKVxuXHRcdGlmICFsc3BsYXQgJiYgcmd0ID09IEFSR1VNRU5UU1xuXG5cdFx0XHR2YXIgcGFycyA9IHNjb3BlX18ucGFyYW1zXG5cdFx0XHQjIHAgXCJzcGVjaWFsIGNhc2Ugd2l0aCBhcmd1bWVudHMge3BhcnN9XCJcblx0XHRcdCMgZm9yY2luZyB0aGUgYXJndW1lbnRzIHRvIGJlIG5hbWVkXG5cdFx0XHQjIHAgXCJnb3QgaGVyZT8/PyB7cGFyc31cIlxuXHRcdFx0bGZ0Lm1hcCBkbyB8bCxpfCBhc3QucHVzaCBPUCgnPScsbC5ub2RlLHBhcnMuYXQoaSx5ZXMpLnZpc2l0LnZhcmlhYmxlKSAjIHMucGFyYW1zLmF0KHZhbHVlIC0gMSx5ZXMpXG5cblx0XHRcblx0XHRlbGlmIHJsZW5cblx0XHRcdCMgd2UgaGF2ZSBzZXZlcmFsIGl0ZW1zIGluIHRoZSByaWdodCBwYXJ0LiB3aGF0IGFib3V0IHNwbGF0cyBoZXJlP1xuXG5cdFx0XHQjIHByZS1ldmFsdWF0ZSBydmFsdWVzIHRoYXQgbWlnaHQgYmUgcmVmZXJlbmNlIGZyb20gb3RoZXIgYXNzaWdubWVudHNcblx0XHRcdCMgd2UgbmVlZCB0byBjaGVjayBpZiB0aGUgcmlnaHRzaWRlIHZhbHVlcyBoYXMgbm8gc2lkZS1lZmZlY3RzLiBDYXVzZSBpZlxuXHRcdFx0IyB0aGV5IGRvbnQsIHdlIHJlYWxseSBkbyBub3QgbmVlZCB0ZW1wb3JhcnkgdmFyaWFibGVzLlxuXG5cdFx0XHQjIHNvbWUgb2YgdGhlc2Ugb3B0aW1pemF0aW9ucyBhcmUgcXVpdGUgcGV0dHkgLSBtYWtlcyB0aGluZ3MgbW9yZSBjb21wbGljYXRlZFxuXHRcdFx0IyBpbiB0aGUgY29tcGlsZXIgb25seSB0byBnZXQgYXJvdW5kIGFkZGluZyBhIGZldyB0ZW1wLXZhcmlhYmxlcyBoZXJlIGFuZCB0aGVyZVxuXG5cdFx0XHQjIHZhciBmaXJzdFVuc2FmZSA9IDBcblx0XHRcdCMgbGZ0Lm1hcCBkbyB8dixpfFxuXHRcdFx0IyBcdGlmIHYgaXNhIFZhclJlZmVyZW5jZVxuXHRcdFx0IyBcdFx0cCBcImxlZnQgc2lkZSB7aX0ge3Z9IHt2LnJlZm5yfVwiXG5cblx0XHRcdCMgcmd0Lm1hcCBkbyB8dixpfFxuXHRcdFx0IyBcdGlmIHYuaGFzU2lkZUVmZmVjdHNcblx0XHRcdCMgXHRcdCMgcmV0dXJuIGlmIGkgPT0gMCBvciAhdi5oYXNTaWRlRWZmZWN0c1xuXHRcdFx0IyBcdFx0IyByZXR1cm4gaWYgdiBpc2EgTnVtIHx8IHYgaXNhIFN0ciB8fCBpID09IDBcblx0XHRcdCMgXHRcdCMgd2UgY291bGQgZXhwbGljaXRseSBjcmVhdGUgYSB0ZW1wb3JhcnkgdmFyaWFibGUgYW5kIGFkZGluZyBub2RlcyBmb3IgYWNjZXNzaW5nIGV0Y1xuXHRcdFx0IyBcdFx0IyBidXQgdGhlIGJ1aWx0aW4gY2FjaGluZyBzaG91bGQgcmVhbGx5IHRha2UgY2FyZSBvZiB0aGlzIGZvciB1c1xuXHRcdFx0IyBcdFx0IyB3ZSBuZWVkIHRvIHJlYWxseSBmb3JjZSB0aGUgY2FjaGluZyB0aG91Z2ggLS0gc2luY2Ugd2UgbmVlZCBhIGNvcHkgb2YgaXQgZXZlbiBpZiBpdCBpcyBhIGxvY2FsXG5cdFx0XHQjIFx0XHQjIHdlIG5lZWQgdG8gcHJlZGVjbGFyZSB0aGUgdmFyaWFibGVzIGF0IHRoZSB0b3Agb2Ygc2NvcGUgaWYgdGhpcyBkb2VzIG5vdCB0YWtlIGNhcmUgb2YgaXRcblx0XHRcdCMgXHRcdFxuXHRcdFx0IyBcdFx0IyB0aGVzZSBhcmUgdGhlIGRlY2xhcmF0aW9ucyAtLSB3ZSBuZWVkIHRvIGFkZCB0aGVtIHNvbWV3aGVyZSBzbWFydFxuXHRcdFx0IyBcdFx0QHRlbXBvcmFyeS5wdXNoKHYpICMgbmVlZCBhIGdlbmVyYWxpemVkIHdheSB0byBkbyB0aGlzIHR5cGUgb2YgdGhpbmdcblx0XHRcdCMgXHRcdGFzdC5wdXNoKHYuY2FjaGUoZm9yY2U6IHllcywgdHlwZTogJ3N3YXAnLCBkZWNsYXJlZDogdHlwID09ICd2YXInKSlcblx0XHRcdCMgXHRcdCMgdGhleSBkbyBuZWVkIHRvIGJlIGRlY2xhcmVkLCBubz9cblxuXHRcdFx0IyBub3cgd2UgY2FuIGZyZWUgdGhlIGNhY2hlZCB2YXJpYWJsZXNcblx0XHRcdCMgYXN0Lm1hcCBkbyB8bnwgbi5kZWNhY2hlXG5cblx0XHRcdHZhciBwcmUgPSBbXVxuXHRcdFx0dmFyIHJlc3QgPSBbXVxuXG5cdFx0XHR2YXIgcGFpcnMgPSBsZnQubWFwIGRvIHxsLGl8XG5cdFx0XHRcdHZhciB2ID0gbnVsbFxuXHRcdFx0XHQjIGRldGVybWluZSBpZiB0aGlzIG5lZWRzIHRvIGJlIHByZWNhY2hlZD9cblx0XHRcdFx0IyBpZiBsIGlzYSBWYXJSZWZlcmVuY2Vcblx0XHRcdFx0IyBcdCMgdGhpcyBpcyB0aGUgZmlyc3QgdGltZSB0aGUgdmFyaWFibGUgaXMgcmVmZXJlbmNlZFxuXHRcdFx0XHQjIFx0IyBzaG91bGQgYWxzbyBjb3VudCBldmVuIGlmIGl0IGlzIHByZWRlY2xhcmVkIGF0IHRoZSB0b3Bcblx0XHRcdFx0IyBcdGlmIGwucmVmbnIgPT0gMFxuXG5cdFx0XHRcdGlmIGwgPT0gbHNwbGF0XG5cdFx0XHRcdFx0diA9IEFyZ0xpc3QubmV3KFtdKVxuXHRcdFx0XHRcdHZhciB0byA9IChybGVuIC0gKHJpIC0gaSkpXG5cdFx0XHRcdFx0IyBwIFwiYXNzaW5nIHNwbGF0IGF0IGluZGV4IHtpfSB0byBzbGljZSB7bGl9IC0ge3RvfVwiLmN5YW5cblx0XHRcdFx0XHR2LnB1c2gocmd0LmluZGV4KGxpKyspKSB3aGlsZSBsaSA8PSB0b1xuXHRcdFx0XHRcdHYgPSBBcnIubmV3KHYpXG5cdFx0XHRcdFx0IyBhc3QucHVzaCBPUCgnPScsbC5ub2RlLEFyci5uZXcodikpXG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHR2ID0gcmd0LmluZGV4KGxpKyspXG5cdFx0XHRcdFtsLm5vZGUsdl1cblxuXHRcdFx0XHQjIGlmIGwgaXNhIFZhclJlZmVyZW5jZSAmJiBsLnJlZm5yIFxuXHRcdFx0dmFyIGNsZWFuID0gdHJ1ZVxuXHRcdFx0XG5cdFx0XHRwYWlycy5tYXAgZG8gfHYsaXxcblx0XHRcdFx0dmFyIGwgPSB2WzBdXG5cdFx0XHRcdHZhciByID0gdlsxXVxuXG5cdFx0XHRcdGlmIGNsZWFuXG5cdFx0XHRcdFx0aWYgbCBpc2EgVmFyUmVmZXJlbmNlICYmIGwucmVmbnIgPT0gMFxuXHRcdFx0XHRcdFx0IyBzdGlsbCBjbGVhblxuXHRcdFx0XHRcdFx0Y2xlYW4gPSB5ZXNcblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRjbGVhbiA9IG5vXG5cdFx0XHRcdFx0XHQjIHAgXCJub3cgY2FjaGVcIlxuXHRcdFx0XHRcdFx0cGFpcnMuc2xpY2UoaSkubWFwIGRvIHxwYXJ0fFxuXHRcdFx0XHRcdFx0XHRpZiBwYXJ0WzFdLmhhc1NpZGVFZmZlY3RzXG5cdFx0XHRcdFx0XHRcdFx0QHRlbXBvcmFyeS5wdXNoKHBhcnRbMV0pICMgbmVlZCBhIGdlbmVyYWxpemVkIHdheSB0byBkbyB0aGlzIHR5cGUgb2YgdGhpbmdcblx0XHRcdFx0XHRcdFx0XHRhc3QucHVzaChwYXJ0WzFdLmNhY2hlKGZvcmNlOiB5ZXMsIHBvb2w6ICdzd2FwJywgZGVjbGFyZWQ6IHR5cCA9PSAndmFyJykpXG5cdFx0XHRcdFx0XHQjIHAgXCJmcm9tIHtpfSAtIGNhY2hlIGFsbCByZW1haW5pbmcgd2l0aCBzaWRlLWVmZmVjdHNcIlxuXG5cdFx0XHRcdCMgaWYgdGhlIHByZXZpb3VzIHZhbHVlIGluIGFzdCBpcyBhIHJlZmVyZW5jZSB0byBvdXIgdmFsdWUgLSB0aGUgY2FjaGluZyB3YXMgbm90IG5lZWRlZFxuXHRcdFx0XHRpZiBhc3QubGFzdCA9PSByXG5cdFx0XHRcdFx0ci5kZWNhY2hlXG5cdFx0XHRcdFx0IyBwIFwid2FzIGNhY2hlZCAtIG5vdCBuZWVkZWRcIlxuXHRcdFx0XHRcdCMgc2ltcGxlIGFzc2lnblxuXHRcdFx0XHRcdGFzdC5yZXBsYWNlKHIsT1AoJz0nLGwscikpXG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRhc3QucHVzaCBPUCgnPScsbCxyKVxuXG5cdFx0XHQjIFdBUk4gRklYTUUgSXMgdGhlcmUgbm90IGFuIGlzc3VlIHdpdGggVmFyQmxvY2sgdnMgbm90IGhlcmU/XG5cdFx0ZWxzZSBcblx0XHRcdCMgdGhpcyBpcyB3aGVyZSB3ZSBuZWVkIHRvIGNhY2hlIHRoZSByaWdodCBzaWRlIGJlZm9yZSBhc3NpZ25pbmdcblx0XHRcdCMgaWYgdGhlIHJpZ2h0IHNpZGUgaXMgYSBmb3IgbG9vcCwgd2UgQ09VTEQgdHJ5IHRvIGJlIGV4dHJhIGNsZXZlciwgYnV0XG5cdFx0XHQjIGZvciBub3cgaXQgaXMgbm90IHdvcnRoIHRoZSBhZGRlZCBjb21waWxlciBjb21wbGV4aXR5XG5cdFx0XHRcblx0XHRcdCMgaXRlci5jYWNoZShmb3JjZTogeWVzLCB0eXBlOiAnaXRlcicpXG5cdFx0XHR2YXIgdG9wID0gVmFyQmxvY2submV3XG5cdFx0XHR2YXIgaXRlciA9IHV0aWwuaXRlcmFibGUocmd0LCB5ZXMpXG5cdFx0XHQjIGNvdWxkIHNldCB0aGUgdmFycyBpbnNpZGUgLS0gbW9zdCBsaWtlbHlcblx0XHRcdGFzdC5wdXNoKHRvcClcblx0XHRcdHRvcC5wdXNoKGl0ZXIpXG5cblx0XHRcdGlmIGxzcGxhdFxuXHRcdFx0XHR2YXIgbGVuID0gdXRpbC5sZW4oaXRlciwgeWVzKVxuXHRcdFx0XHR2YXIgaWR4ID0gdXRpbC5jb3VudGVyKDAsIHllcylcblx0XHRcdFx0IyBjYWNoZSB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheVxuXHRcdFx0XHR0b3AucHVzaChsZW4pICMgcHJlYXNzaWduIHRoZSBsZW5ndGhcblx0XHRcdFx0IyBjYWNoZSBjb3VudGVyIHRvIGxvb3AgdGhyb3VnaFxuXHRcdFx0XHR0b3AucHVzaChpZHgpXG5cblx0XHRcdCMgb25seSBpZiB0aGUgYmxvY2sgaXMgdmFyaWFibGUgYmFzZWQsIG5vP1xuXHRcdFx0IyBhc3QucHVzaChibGsgPSBWYXJCbG9jay5uZXcpXG5cdFx0XHQjIGJsayA9IG51bGxcblx0XHRcdFxuXHRcdFx0dmFyIGJsa3R5cGUgPSB0eXAgPT0gJ3ZhcicgPyBWYXJCbG9jayA6IEJsb2NrXG5cdFx0XHR2YXIgYmxrID0gYmxrdHlwZS5uZXcoW10pXG5cdFx0XHQjIGJsayA9IHRvcCBpZiB0eXAgPT0gJ3Zhcidcblx0XHRcdGFzdC5wdXNoKGJsaylcblxuXHRcdFx0IyBpZiB0aGUgbHZhbHMgYXJlIG5vdCB2YXJpYWJsZXMgLSB3ZSBuZWVkIHRvIHByZWFzc2lnblxuXHRcdFx0IyBjYW4gYWxzbyB1c2Ugc2xpY2UgaGVyZSBmb3Igc2ltcGxpY2l0eSwgYnV0IHRyeSB3aXRoIHdoaWxlIG5vd1x0XHRcdFxuXHRcdFx0bGZ0Lm1hcCBkbyB8bCxpfFxuXHRcdFx0XHRpZiBsID09IGxzcGxhdFxuXHRcdFx0XHRcdHZhciBsdmFyID0gbC5ub2RlXG5cdFx0XHRcdFx0dmFyIHJlbSA9IGxsZW4gLSBpIC0gMSAjIHJlbWFpbmluZyBhZnRlciBzcGxhdFxuXG5cdFx0XHRcdFx0aWYgdHlwICE9ICd2YXInXG5cdFx0XHRcdFx0XHR2YXIgYXJyID0gdXRpbC5hcnJheShPUCgnLScsbGVuLCBudW1fXyhpICsgcmVtKSApLHllcylcblx0XHRcdFx0XHRcdHRvcC5wdXNoKGFycilcblx0XHRcdFx0XHRcdGx2YXIgPSBhcnIuY2FjaGV2YXJcblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRhc3QucHVzaChibGsgPSBibGt0eXBlLm5ldykgdW5sZXNzIGJsa1xuXHRcdFx0XHRcdFx0dmFyIGFyciA9IHV0aWwuYXJyYXkoIE9QKCctJyxsZW4sbnVtX18oaSArIHJlbSkgKSApXG5cdFx0XHRcdFx0XHRibGsucHVzaChPUCgnPScsbHZhcixhcnIpKVxuXG5cdFx0XHRcdFx0IyBpZiAhbHZhcjp2YXJpYWJsZSB8fCAhbHZhci52YXJpYWJsZSAjIGx2YXIgPSBcblx0XHRcdFx0XHQjIFx0dG9wLnB1c2goKVxuXHRcdFx0XHRcdCNcdHAgXCJoYXMgdmFyaWFibGUgLSBubyBuZWVkIHRvIGNyZWF0ZSBhIHRlbXBcIlxuXHRcdFx0XHRcdCMgYmxrLnB1c2goT1AoJz0nLGx2YXIsQXJyLm5ldyhbXSkpKSAjIGRvbnQgcHJlY2FsY3VsYXRlIHNpemUgbm93XG5cdFx0XHRcdFx0IyBtYXggPSB0byA9IChybGVuIC0gKGxsZW4gLSBpKSlcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQgXG5cdFx0XHRcdFx0dmFyIHRlc3QgPSByZW0gPyBPUCgnLScsbGVuLHJlbSkgOiBsZW5cblxuXHRcdFx0XHRcdHZhciBzZXQgPSBPUCgnPScsXG5cdFx0XHRcdFx0XHRPUCgnLicsbHZhcixPUCgnLScsaWR4LG51bV9fKGkpKSksXG5cdFx0XHRcdFx0XHRPUCgnLicsaXRlcixPUCgnKysnLGlkeCkpXG5cdFx0XHRcdFx0KVxuXG5cdFx0XHRcdFx0YXN0LnB1c2goV0hJTEUoT1AoJzwnLGlkeCx0ZXN0KSwgc2V0KSlcblxuXHRcdFx0XHRcdGlmIHR5cCAhPSAndmFyJ1xuXHRcdFx0XHRcdFx0YXN0LnB1c2goYmxrID0gQmxvY2submV3KSBcblx0XHRcdFx0XHRcdGJsay5wdXNoKE9QKCc9JyxsLm5vZGUsbHZhcikpXG5cdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0YmxrID0gbnVsbFxuXG5cdFx0XHRcdFx0IyBub3QgaWYgc3BsYXQgd2FzIGxhc3Q/XG5cdFx0XHRcdFx0IyBhc3QucHVzaChibGsgPSBWYXJCbG9jay5uZXcpXG5cblx0XHRcdFx0ZWxpZiBsc3BsYXRcblx0XHRcdFx0XHRhc3QucHVzaChibGsgPSBibGt0eXBlLm5ldykgdW5sZXNzIGJsa1xuXHRcdFx0XHRcdCMgd2UgY291bGQgY2FjaGUgdGhlIHJhdyBjb2RlIG9mIHRoaXMgbm9kZSBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlXG5cdFx0XHRcdFx0YmxrLnB1c2goT1AoJz0nLGwsT1AoJy4nLGl0ZXIsT1AoJysrJyxpZHgpKSkpXG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRhc3QucHVzaChibGsgPSBibGt0eXBlLm5ldykgdW5sZXNzIGJsa1xuXHRcdFx0XHRcdGJsay5wdXNoKE9QKCc9JyxsLE9QKCcuJyxpdGVyLG51bV9fKGkpICkpKVxuXG5cdFx0IyBpZiB3ZSBhcmUgaW4gYW4gZXhwcmVzc2lvbiB3ZSByZWFsbHkgbmVlZCB0byBcblx0XHRpZiBvLmlzRXhwcmVzc2lvbiBhbmQgQHZhcnNcblx0XHRcdCMgcCBcInR1cGxlIGlzIGV4cHJlc3Npb25cIiAjIHZhcmlhYmxlcyBNVVNUIGJlIGF1dG9kZWNsYXJlZCBvdXRzaWRlIG9mIHRoZSBleHByZXNzaW9uXG5cdFx0XHRmb3IgdiBpbiBAdmFyc1xuXHRcdFx0XHR2LnZhcmlhYmxlLmF1dG9kZWNsYXJlXG5cblx0XHRlbGlmIEB2YXJzXG5cdFx0XHRmb3IgdiBpbiBAdmFyc1xuXHRcdFx0XHQjIHAgXCJwcmVkZWNsYXJlIHZhcmlhYmxlIGJlZm9yZSBjb21waWxhdGlvblwiXG5cdFx0XHRcdHYudmFyaWFibGUucHJlZGVjbGFyZWRcblxuXHRcdCMgaXMgdGhlcmUgYW55IHJlYXNvbiB0byBtYWtlIGl0IGludG8gYW4gZXhwcmVzc2lvbj9cblx0XHRpZiBhc3QuaXNFeHByZXNzYWJsZSAjIE5PIVxuXHRcdFx0IyBwIFwiZXhwcmVzc1wiXG5cdFx0XHQjIGlmIHRoaXMgaXMgYW4gZXhwcmVzc2lvblxuXHRcdFx0dmFyIG91dCA9IGFzdC5jKGV4cHJlc3Npb246IHllcylcblx0XHRcdG91dCA9IFwie3R5cH0ge291dH1cIiBpZiB0eXAgYW5kICFvLmlzRXhwcmVzc2lvbiAjIG5vdCBpbiBleHByZXNzaW9uXG5cdFx0XHRyZXR1cm4gb3V0XG5cdFx0ZWxzZVxuXHRcdFx0dmFyIG91dCA9IGFzdC5jXG5cdFx0XHQjIGlmIHRoaXMgaXMgYSB2YXJibG9jayBcblx0XHRcdHJldHVybiBvdXRcblxuXG5cdGRlZiBjIG9cblx0XHR2YXIgb3V0ID0gc3VwZXIobylcblx0XHQjIHRoaXMgaXMgb25seSB1c2VkIGluIHR1cGxlIC0tIGJldHRlciB0byBsZXQgdGhlIHR1cGxlIGhhdiBhIHNlcGFyYXRlICNjXG5cdFx0aWYgQHRlbXBvcmFyeSAmJiBAdGVtcG9yYXJ5Omxlbmd0aFxuXHRcdFx0QHRlbXBvcmFyeS5tYXAgZG8gfHRlbXB8IHRlbXAuZGVjYWNoZVxuXHRcdHJldHVybiBvdXRcblxuXG5cbiMgSURFTlRJRklFUlNcblxuIyByZWFsbHkgbmVlZCB0byBjbGVhbiB0aGlzIHVwXG4jIERyb3AgdGhlIHRva2VuP1xuZXhwb3J0IGNsYXNzIElkZW50aWZpZXIgPCBOb2RlXG5cblx0cHJvcCBzYWZlY2hhaW5cblx0cHJvcCB2YWx1ZVxuXG5cdGRlZiBpbml0aWFsaXplIHZhbHVlXG5cdFx0QHZhbHVlID0gbG9hZCh2YWx1ZSlcblx0XHRAc3ltYm9sID0gbnVsbFxuXHRcdEBzZXR0ZXIgPSBudWxsXG5cblx0XHRpZiAoXCJcIiArIHZhbHVlKS5pbmRleE9mKFwiP1wiKSA+PSAwXG5cdFx0XHRAc2FmZWNoYWluID0geWVzXG5cdFx0IyBAc2FmZWNoYWluID0gKFwiXCIgKyB2YWx1ZSkuaW5kZXhPZihcIj9cIikgPj0gMFxuXHRcdHNlbGZcblxuXHRkZWYgcmVmZXJlbmNlcyB2YXJpYWJsZVxuXHRcdEB2YWx1ZS5AdmFyaWFibGUgPSB2YXJpYWJsZSBpZiBAdmFsdWVcblx0XHRzZWxmXG5cblx0ZGVmIHNvdXJjZU1hcE1hcmtlclxuXHRcdEB2YWx1ZS5zb3VyY2VNYXBNYXJrZXJcblxuXHRkZWYgbG9hZCB2XG5cdFx0cmV0dXJuICh2IGlzYSBJZGVudGlmaWVyID8gdi52YWx1ZSA6IHYpXG5cblx0ZGVmIHRyYXZlcnNlXG5cdFx0IyBOT0RFUy5wdXNoKHNlbGYpXG5cdFx0c2VsZlxuXG5cdGRlZiB2aXNpdFxuXHRcblx0XHRpZiBAdmFsdWUgaXNhIE5vZGVcblx0XHRcdCMgY29uc29sZS5sb2cgXCJJREVOVElGSUVSIFZBTFVFIElTIE5PREVcIlxuXHRcdFx0QHZhbHVlLnRyYXZlcnNlXG5cdFx0c2VsZlxuXG5cdGRlZiByZWdpb25cblx0XHRbQHZhbHVlLkBsb2MsQHZhbHVlLkBsb2MgKyBAdmFsdWUuQGxlbl1cblxuXHRkZWYgaXNWYWxpZElkZW50aWZpZXJcblx0XHR5ZXNcblx0XHRcblx0ZGVmIGlzUmVzZXJ2ZWRcblx0XHRAdmFsdWU6cmVzZXJ2ZWQgb3IgUkVTRVJWRURfVEVTVC50ZXN0KFN0cmluZyhAdmFsdWUpKVxuXG5cdGRlZiBzeW1ib2xcblx0XHQjIGNvbnNvbGUubG9nIFwiSWRlbnRpZmllciNzeW1ib2wge3ZhbHVlfVwiXG5cdFx0QHN5bWJvbCB8fD0gc3ltX18odmFsdWUpXG5cblx0ZGVmIHNldHRlclxuXHRcdCMgY29uc29sZS5sb2cgXCJJZGVudGlmaWVyI3NldHRlclwiXG5cdFx0QHNldHRlciB8fD0gaWYgdHJ1ZVxuXHRcdFx0dmFyIHRvayA9IFRva2VuLm5ldygnSURFTlRJRklFUicsc3ltX18oJ3NldC0nICsgQHZhbHVlKSxAdmFsdWUuQGxvYyBvciAtMSlcblx0XHRcdElkZW50aWZpZXIubmV3KHRvaylcblx0XHRcdCMgSWRlbnRpZmllci5uZXcoXCJzZXQte3N5bWJvbH1cIilcblxuXHRkZWYgdG9TdHJpbmdcblx0XHRTdHJpbmcoQHZhbHVlKVxuXG5cdGRlZiB0b0pTT05cblx0XHR0b1N0cmluZ1xuXG5cdGRlZiBhbGlhc1xuXHRcdHN5bV9fKEB2YWx1ZSlcblxuXHRkZWYganMgb1xuXHRcdHN5bWJvbFxuXG5cdGRlZiBjXG5cdFx0cmV0dXJuICcnICsgc3ltYm9sICMgbWFya19fKEB2YWx1ZSkgKyBcblxuXHRkZWYgZHVtcFxuXHRcdHsgbG9jOiByZWdpb24gfVxuXG5cdGRlZiBuYW1lcGF0aFxuXHRcdHRvU3RyaW5nXG5cdFx0XG5leHBvcnQgY2xhc3MgVGFnSWQgPCBJZGVudGlmaWVyXG5cblx0ZGVmIGluaXRpYWxpemUgdlxuXHRcdEB2YWx1ZSA9IHYgaXNhIElkZW50aWZpZXIgPyB2LnZhbHVlIDogdlxuXHRcdHNlbGZcblxuXHRkZWYgY1xuXHRcdFwiaWQkKCd7dmFsdWUuY30nKVwiXG5cdFx0XG4jIFRoaXMgaXMgbm90IGFuIGlkZW50aWZpZXIgLSBpdCBpcyByZWFsbHkgYSBzdHJpbmdcbiMgSXMgdGhpcyBub3QgYSBsaXRlcmFsP1xuXG4jIEZJWE1FIFJlbmFtZSB0byBJdmFyTGl0ZXJhbD8gb3Igc2ltcGx5IExpdGVyYWwgd2l0aCB0eXBlIEl2YXJcbmV4cG9ydCBjbGFzcyBJdmFyIDwgSWRlbnRpZmllclxuXG5cdGRlZiBpbml0aWFsaXplIHZcblx0XHRAdmFsdWUgPSB2IGlzYSBJZGVudGlmaWVyID8gdi52YWx1ZSA6IHZcblx0XHRzZWxmXG5cblx0ZGVmIG5hbWVcblx0XHRoZWxwZXJzLmNhbWVsQ2FzZShAdmFsdWUpLnJlcGxhY2UoL15ALywnJylcblx0XHQjIHZhbHVlLmMuY2FtZWxDYXNlLnJlcGxhY2UoL15ALywnJylcblxuXHRkZWYgYWxpYXNcblx0XHQnXycgKyBuYW1lXG5cblx0IyB0aGUgQCBzaG91bGQgcG9zc2libHkgYmUgZ29uZSBmcm9tIHRoZSBzdGFydD9cblx0ZGVmIGpzIG9cblx0XHQnXycgKyBuYW1lXG5cblx0ZGVmIGNcblx0XHQnXycgKyBoZWxwZXJzLmNhbWVsQ2FzZShAdmFsdWUpLnNsaWNlKDEpICMgLnJlcGxhY2UoL15ALywnJykgIyBtYXJrX18oQHZhbHVlKSArIFxuXG5cblxuIyBBbWJpZ3VvdXMgLSBXZSBuZWVkIHRvIGJlIGNvbnNpc3RlbnQgYWJvdXQgQ29uc3QgdnMgQ29uc3RBY2Nlc3NcbiMgQmVjb21lcyBtb3JlIGltcG9ydGFudCB3aGVuIHdlIGltcGxlbWVudCB0eXBlaW5mZXJlbmNlIGFuZCBjb2RlLWFuYWx5c2lzXG5leHBvcnQgY2xhc3MgQ29uc3QgPCBJZGVudGlmaWVyXG5cdFx0XG5cdGRlZiBzeW1ib2xcblx0XHQjIGNvbnNvbGUubG9nIFwiSWRlbnRpZmllciNzeW1ib2wge3ZhbHVlfVwiXG5cdFx0QHN5bWJvbCB8fD0gc3ltX18odmFsdWUpXG5cblx0ZGVmIGpzIG9cblx0XHRzeW1ib2xcblxuXHRkZWYgY1xuXHRcdG1hcmtfXyhAdmFsdWUpICsgc3ltYm9sXG5cbmV4cG9ydCBjbGFzcyBUYWdUeXBlSWRlbnRpZmllciA8IElkZW50aWZpZXJcblxuXHRwcm9wIG5hbWVcblx0cHJvcCBuc1xuXG5cdGRlZiBpbml0aWFsaXplIHZhbHVlXG5cdFx0QHZhbHVlID0gbG9hZCh2YWx1ZSlcblx0XHRzZWxmXG5cblx0ZGVmIGxvYWQgdmFsXG5cdFx0QHN0ciA9IChcIlwiICsgdmFsKVxuXHRcdHZhciBwYXJ0cyA9IEBzdHIuc3BsaXQoXCI6XCIpXG5cdFx0QHJhdyA9IHZhbFxuXHRcdEBuYW1lID0gcGFydHMucG9wXG5cdFx0QG5zID0gcGFydHMuc2hpZnQgIyBpZiBhbnk/XG5cdFx0cmV0dXJuIEBzdHJcblxuXHRkZWYganMgb1xuXHRcdHJldHVybiBcIkltYmEuVEFHUy57QHN0ci5yZXBsYWNlKFwiOlwiLFwiJFwiKX1cIlxuXG5cdGRlZiBjXG5cdFx0anNcblxuXHRkZWYgZnVuY1xuXHRcdHZhciBuYW1lID0gQG5hbWUucmVwbGFjZSgvLS9nLCdfJykucmVwbGFjZSgvXFwjLywnJylcblx0XHRuYW1lICs9IFwiJHtAbnMudG9Mb3dlckNhc2V9XCIgaWYgQG5zXG5cdFx0bmFtZVxuXG5cdGRlZiBzcGF3bmVyXG5cdFx0aWYgQG5zXG5cdFx0XHRcIntAbnMudG9VcHBlckNhc2V9LiR7QG5hbWUucmVwbGFjZSgvLS9nLCdfJyl9XCJcblx0XHRlbHNlXG5cdFx0XHRcIiR7QG5hbWUucmVwbGFjZSgvLS9nLCdfJyl9XCJcblxuXHRkZWYgaWRcblx0XHR2YXIgbSA9IEBzdHIubWF0Y2goL1xcIyhbXFx3XFwtXFxkXFxfXSspXFxiLylcblx0XHRtID8gbVsxXSA6IG51bGxcblx0XHRcblxuXHRkZWYgZmxhZ1xuXHRcdFwiX1wiICsgbmFtZS5yZXBsYWNlKC8tLS9nLCdfJykudG9Mb3dlckNhc2VcblxuXHRkZWYgc2VsXG5cdFx0XCIue2ZsYWd9XCIgIyArIG5hbWUucmVwbGFjZSgvLS9nLCdfJykudG9Mb3dlckNhc2VcblxuXHRkZWYgc3RyaW5nXG5cdFx0dmFsdWVcblxuXG5leHBvcnQgY2xhc3MgQXJndmFyIDwgVmFsdWVOb2RlXG5cblx0ZGVmIGNcblx0XHQjIE5FWFQgLS0gZ2xvYmFsLnBhcnNlSW50IG9yIE51bWJlci5wYXJzZUludCAoYmV0dGVyKVxuXHRcdHZhciB2ID0gcGFyc2VJbnQoU3RyaW5nKHZhbHVlKSlcblx0XHQjIEZJWE1FIE5vdCBuZWVkZWQgYW55bW9yZT8gSSB0aGluayB0aGUgbGV4ZXIgaGFuZGxlcyB0aGlzXG5cdFx0cmV0dXJuIFwiYXJndW1lbnRzXCIgaWYgdiA9PSAwXG5cblx0XHR2YXIgcyA9IHNjb3BlX19cblx0XHQjIHBhcmFtcyBuZWVkIHRvIGdvIHVwIHRvIHRoZSBjbG9zZXN0ZSBtZXRob2Qtc2NvcGVcblx0XHR2YXIgcGFyID0gcy5wYXJhbXMuYXQodiAtIDEseWVzKVxuXHRcdFwie2NfXyhwYXIubmFtZSl9XCIgIyBjXG5cblxuIyBDQUxMXG5cbmV4cG9ydCBjbGFzcyBDYWxsIDwgTm9kZVxuXG5cdHByb3AgY2FsbGVlXG5cdHByb3AgcmVjZWl2ZXJcblx0cHJvcCBhcmdzXG5cdHByb3AgYmxvY2tcblxuXHRkZWYgaW5pdGlhbGl6ZSBjYWxsZWUsIGFyZ3MsIG9wZXhpc3RzXG5cdFx0QHRyYXZlcnNlZCA9IG5vXG5cdFx0QGV4cHJlc3Npb24gPSBub1xuXHRcdEBwYXJlbnMgPSBub1xuXHRcdEBjYWNoZSA9IG51bGxcblx0XHRAcmVjZWl2ZXIgPSBudWxsXG5cdFx0QG9wZXhpc3RzID0gb3BleGlzdHNcblx0XHQjIHNvbWUgYXhpb21zIHRoYXQgc2hhcmUgdGhlIHNhbWUgc3ludGF4IGFzIGNhbGxzIHdpbGwgYmUgcmVkaXJlY3RlZCBmcm9tIGhlcmVcblx0XHRcblx0XHRpZiBjYWxsZWUgaXNhIFZhck9yQWNjZXNzXG5cdFx0XHR2YXIgc3RyID0gY2FsbGVlLnZhbHVlLnN5bWJvbFxuXHRcdFx0IyBwIFwiQ2FsbCBjYWxsZWUge2NhbGxlZX0gLSB7c3RyfVwiXG5cdFx0XHRpZiBzdHIgPT0gJ2V4dGVybidcblx0XHRcdFx0IyBwIFwicmV0dXJuaW5nIGV4dGVybiBpbnN0ZWFkIVwiXG5cdFx0XHRcdGNhbGxlZS52YWx1ZS52YWx1ZS5AdHlwZSA9ICdFWFRFUk4nXG5cdFx0XHRcdHJldHVybiBFeHRlcm5EZWNsYXJhdGlvbi5uZXcoYXJncylcblx0XHRcdGlmIHN0ciA9PSAndGFnJ1xuXHRcdFx0XHQjIGNvbnNvbGUubG9nIFwiRVJST1IgLSBhY2Nlc3MgYXJncyBieSBzb21lIG1ldGhvZFwiXG5cdFx0XHRcdHJldHVybiBUYWdXcmFwcGVyLm5ldyhhcmdzIGFuZCBhcmdzOmluZGV4ID8gYXJncy5pbmRleCgwKSA6IGFyZ3NbMF0pXG5cdFx0XHRpZiBzdHIgPT0gJ2V4cG9ydCdcblx0XHRcdFx0cmV0dXJuIEV4cG9ydFN0YXRlbWVudC5uZXcoYXJncylcblxuXHRcdEBjYWxsZWUgPSBjYWxsZWVcblx0XHRAYXJncyA9IGFyZ3Mgb3IgQXJnTGlzdC5uZXcoW10pXG5cblx0XHRpZiBhcmdzIGlzYSBBcnJheVxuXHRcdFx0QGFyZ3MgPSBBcmdMaXN0Lm5ldyhhcmdzKVxuXHRcdFx0IyBjb25zb2xlLmxvZyBcIkFSR1VNRU5UUyBJUyBBUlJBWSAtIGVycm9yIHthcmdzfVwiXG5cdFx0IyBwIFwiY2FsbCBvcGV4aXN0cyB7b3BleGlzdHN9XCJcblx0XHRzZWxmXG5cblx0ZGVmIHZpc2l0XG5cdFx0IyBjb25zb2xlLmxvZyBcInZpc2l0IGFyZ3Mge2FyZ3N9XCJcblx0XHRhcmdzLnRyYXZlcnNlXG5cdFx0Y2FsbGVlLnRyYXZlcnNlXG5cblx0XHQjIGlmIHRoZSBjYWxsZWUgaXMgYSBQcm9wZXJ0eUFjY2VzcyAtIGJldHRlciB0byBpbW1lZGlhdGVseSBjaGFuZ2UgaXRcblxuXHRcdEBibG9jayAmJiBAYmxvY2sudHJhdmVyc2UgXG5cblx0ZGVmIGFkZEJsb2NrIGJsb2NrXG5cdFx0dmFyIHBvcyA9IEBhcmdzLmZpbHRlcih8bixpfCBuID09ICcmJylbMF0gIyBXT1VMRCBCRSBUT0tFTiAtIENBUkVGVUxcblx0XHRwb3MgPyBhcmdzLnJlcGxhY2UocG9zLGJsb2NrKSA6IGFyZ3MucHVzaChibG9jaylcblx0XHRzZWxmXG5cblx0ZGVmIHJlY2VpdmVyXG5cdFx0QHJlY2VpdmVyIHx8PSAoY2FsbGVlIGlzYSBBY2Nlc3MgJiYgY2FsbGVlLmxlZnQgfHwgTlVMTClcblxuXHQjIGNoZWNrIGlmIGFsbCBhcmd1bWVudHMgYXJlIGV4cHJlc3Npb25zIC0gb3RoZXJ3aXNlIHdlIGhhdmUgYW4gaXNzdWVcblxuXHRkZWYgc2FmZWNoYWluXG5cdFx0Y2FsbGVlLnNhZmVjaGFpbiAjIHJlYWxseT9cblxuXHRkZWYganMgb1xuXHRcdHZhciBvcHQgPSBleHByZXNzaW9uOiB5ZXNcblx0XHR2YXIgcmVjID0gbnVsbFxuXHRcdCMgdmFyIGFyZ3MgPSBjb21wYWN0X18oYXJncykgIyByZWFsbHk/XG5cdFx0dmFyIGFyZ3MgPSBhcmdzXG5cblx0XHQjIGRyb3AgdGhpcz9cblxuXHRcdHZhciBzcGxhdCA9IGFyZ3Muc29tZSBkbyB8dnwgdiBpc2EgU3BsYXRcblxuXHRcdHZhciBvdXQgPSBudWxsXG5cdFx0dmFyIGxmdCA9IG51bGxcblx0XHR2YXIgcmd0ID0gbnVsbFxuXHRcdHZhciB3cmFwID0gbnVsbFxuXG5cdFx0dmFyIGNhbGxlZSA9IEBjYWxsZWUgPSBAY2FsbGVlLm5vZGUgIyBkcm9wIHRoZSB2YXIgb3IgYWNjZXNzP1xuXG5cdFx0IyBpZiBjYWxsZWUgaXNhIENhbGwgJiYgY2FsbGVlLnNhZmVjaGFpblxuXHRcdCNcdHllc1xuXG5cdFx0aWYgY2FsbGVlIGlzYSBBY2Nlc3Ncblx0XHRcdGxmdCA9IGNhbGxlZS5sZWZ0XG5cdFx0XHRyZ3QgPSBjYWxsZWUucmlnaHRcblxuXHRcdGlmIGNhbGxlZSBpc2EgU3VwZXIgb3IgY2FsbGVlIGlzYSBTdXBlckFjY2Vzc1xuXHRcdFx0QHJlY2VpdmVyID0gc2NvcGVfXy5jb250ZXh0XG5cdFx0XHQjIHJldHVybiBcInN1cGVyY2FsbFwiXG5cblx0XHQjIG5ldmVyIGNhbGwgdGhlIHByb3BlcnR5LWFjY2VzcyBkaXJlY3RseT9cblx0XHRpZiBjYWxsZWUgaXNhIFByb3BlcnR5QWNjZXNzICMgJiYgcmVjID0gY2FsbGVlLnJlY2VpdmVyXG5cdFx0XHQjIHAgXCJ1bndyYXBwaW5nIHByb3BlcnR5LWFjY2VzcyBpbiBjYWxsXCJcblx0XHRcdEByZWNlaXZlciA9IGNhbGxlZS5yZWNlaXZlclxuXHRcdFx0Y2FsbGVlID0gQGNhbGxlZSA9IEFjY2Vzcy5uZXcoY2FsbGVlLm9wLGNhbGxlZS5sZWZ0LGNhbGxlZS5yaWdodClcblx0XHRcdCMgcCBcImdvdCBoZXJlPyB7Y2FsbGVlfVwiXG5cdFx0XHQjIGNvbnNvbGUubG9nIFwidW53cmFwcGluZyB0aGUgcHJvcGVydHlBY2Nlc3NcIlxuXG5cdFx0aWYgY2FsbGVlLnNhZmVjaGFpblxuXHRcdFx0IyBwIFwiY2FsbGVlIGlzIHNhZmVjaGFpbmVkPyE/XCJcblx0XHRcdCMgaWYgbGZ0IGlzYSBDYWxsXG5cdFx0XHQjIGlmIGxmdCBpc2EgQ2FsbCAjIGNvdWxkIGJlIGEgcHJvcGVydHkgYWNjZXNzIGFzIHdlbGwgLSBpdCBpcyB0aGUgc2FtZT9cblx0XHRcdCMgaWYgaXQgaXMgYSBsb2NhbCB2YXIgYWNjZXNzIHdlIHNpbXBseSBjaGVjayBpZiBpdCBpcyBhIGZ1bmN0aW9uLCB0aGVuIGNhbGxcblx0XHRcdCMgYnV0IGl0IHNob3VsZCBiZSBzYWZlY2hhaW5lZCBvdXRzaWRlIGFzIHdlbGw/XG5cdFx0XHQjIGxmdC5jYWNoZSBpZiBsZnRcblx0XHRcdCMgdGhlIG91dGVyIHNhZmVjaGFpbiBzaG91bGQgbm90IGNhY2hlIHRoZSB3aG9sZSBjYWxsIC0gb25seSBhc2sgdG8gY2FjaGVcblx0XHRcdCMgdGhlIHJlc3VsdD8gLS0gY2hhaW4gb250b1xuXHRcdFx0IyBwIFwiQ2FsbCBzYWZlY2hhaW4ge2NhbGxlZX0ge2xmdH0ue3JndH1cIlxuXHRcdFx0dmFyIGlzZm4gPSBVdGlsLklzRnVuY3Rpb24ubmV3KFtjYWxsZWVdKVxuXHRcdFx0d3JhcCA9IFtcIntpc2ZuLmN9ICAmJiAgXCIsXCJcIl1cblx0XHRcdGNhbGxlZSA9IE9QKCcuJyxjYWxsZWUubGVmdCxjYWxsZWUucmlnaHQpXG5cdFx0XHQjIGNhbGxlZSBzaG91bGQgYWxyZWFkeSBiZSBjYWNoZWQgbm93IC0gXG5cblx0XHQjIHNob3VsZCBqdXN0IGZvcmNlIGV4cHJlc3Npb24gZnJvbSB0aGUgc3RhcnQsIG5vP1xuXHRcdGlmIHNwbGF0XG5cdFx0XHQjIGltcG9ydGFudCB0byB3cmFwIHRoZSBzaW5nbGUgdmFsdWUgaW4gYSB2YWx1ZSwgdG8ga2VlcCBpbXBsaWNpdCBjYWxsXG5cdFx0XHQjIHRoaXMgaXMgZHVlIHRvIHRoZSB3YXkgd2UgY2hlY2sgZm9yIGFuIG91dGVyIENhbGwgd2l0aG91dCBjaGVja2luZyBpZlxuXHRcdFx0IyB3ZSBhcmUgdGhlIHJlY2VpdmVyIChpbiBQcm9wZXJ0eUFjY2VzcykuIFNob3VsZCByYXRoZXIgd3JhcCBpbiBDYWxsQXJndW1lbnRzXG5cdFx0XHRsZXQgcmVjID0gcmVjZWl2ZXJcblx0XHRcdHZhciBhcnkgPSAoYXJncy5jb3VudCA9PSAxID8gVmFsdWVOb2RlLm5ldyhhcmdzLmZpcnN0LnZhbHVlKSA6IEFyci5uZXcoYXJncy5saXN0KSlcblxuXHRcdFx0cmVjLmNhY2hlICMgbmVlZCB0byBjYWNoZSB0aGUgY29udGV4dCBhcyBpdCB3aWxsIGJlIHJlZmVyZW5jZWQgaW4gYXBwbHlcblx0XHRcdG91dCA9IFwie2NhbGxlZS5jKGV4cHJlc3Npb246IHllcyl9LmFwcGx5KHtyZWMuY30se2FyeS5jKGV4cHJlc3Npb246IHllcyl9KVwiXG5cblx0XHRlbGlmIEByZWNlaXZlclxuXHRcdFx0IyBxdWljayB3b3JrYXJvdW5kXG5cdFx0XHRAcmVjZWl2ZXIuY2FjaGUgdW5sZXNzIEByZWNlaXZlciBpc2EgU2NvcGVDb250ZXh0XG5cdFx0XHRhcmdzLnVuc2hpZnQocmVjZWl2ZXIpXG5cdFx0XHQjIHNob3VsZCByYXRoZXIgcmV3cml0ZSB0byBhIG5ldyBjYWxsP1xuXHRcdFx0b3V0ID0gXCJ7Y2FsbGVlLmMoZXhwcmVzc2lvbjogeWVzKX0uY2FsbCh7YXJncy5jKGV4cHJlc3Npb246IHllcyl9KVwiXG5cblx0XHRlbHNlXG5cdFx0XHRvdXQgPSBcIntjYWxsZWUuYyhleHByZXNzaW9uOiB5ZXMpfSh7YXJncy5jKGV4cHJlc3Npb246IHllcyl9KVwiXG5cblx0XHRpZiB3cmFwXG5cdFx0XHQjIHdlIHNldCB0aGUgY2FjaGV2YXIgaW5zaWRlXG5cdFx0XHQjIHAgXCJzcGVjaWFsIGNhY2hpbmcgZm9yIGNhbGxcIlxuXHRcdFx0aWYgQGNhY2hlXG5cdFx0XHRcdEBjYWNoZTptYW51YWwgPSB5ZXMgXG5cdFx0XHRcdG91dCA9IFwiKHtjYWNoZXZhci5jfT17b3V0fSlcIlxuXG5cdFx0XHRvdXQgPSBbd3JhcFswXSxvdXQsd3JhcFsxXV0uam9pbihcIlwiKVxuXG5cdFx0cmV0dXJuIG91dFxuXG5cblxuXHRcdFxuZXhwb3J0IGNsYXNzIEltcGxpY2l0Q2FsbCA8IENhbGxcblxuXHRkZWYganMgb1xuXHRcdFwie2NhbGxlZS5jfSgpXCJcblxuZXhwb3J0IGNsYXNzIE5ldyA8IENhbGxcblxuXHRkZWYganMgb1xuXHRcdHZhciB0YXJnZXQgPSBjYWxsZWVcblxuXHRcdHdoaWxlIHRhcmdldCBpc2EgQWNjZXNzXG5cdFx0XHRsZXQgbGVmdCA9IHRhcmdldC5sZWZ0XG5cblx0XHRcdGlmIChsZWZ0IGlzYSBQcm9wZXJ0eUFjY2Vzcykgb3IgKGxlZnQgaXNhIFZhck9yQWNjZXNzKVxuXHRcdFx0XHRjYWxsZWUuQHBhcmVucyA9IHllc1xuXHRcdFx0XHRicmVha1xuXG5cdFx0XHR0YXJnZXQgPSBsZWZ0XG5cblx0XHR2YXIgb3V0ID0gXCJuZXcge2NhbGxlZS5jfVwiXG5cdFx0b3V0ICs9ICcoKScgdW5sZXNzIG8ucGFyZW50IGlzYSBDYWxsXG5cdFx0b3V0XG5cbmV4cG9ydCBjbGFzcyBTdXBlckNhbGwgPCBDYWxsXG5cblx0ZGVmIGpzIG9cblx0XHR2YXIgbSA9IG8ubWV0aG9kXG5cdFx0c2VsZi5yZWNlaXZlciA9IFNFTEZcblx0XHRzZWxmLmNhbGxlZSA9IFwie20udGFyZ2V0LmN9LnN1cGVyJC5wcm90b3R5cGUue20ubmFtZS5jfVwiXG5cdFx0c3VwZXJcblxuXG5cbmV4cG9ydCBjbGFzcyBFeHRlcm5EZWNsYXJhdGlvbiA8IExpc3ROb2RlXG5cblx0ZGVmIHZpc2l0XG5cblx0XHQjIHAgXCJ2aXNpdGluZyBleHRlcm5kZWNsYXJhdGlvblwiXG5cdFx0bm9kZXMgPSBtYXAgZG8gfGl0ZW18IGl0ZW0ubm9kZSAjIGRyb3AgdmFyIG9yIGFjY2VzcyByZWFsbHlcblx0XHQjIG9ubHkgaW4gZ2xvYmFsIHNjb3BlP1xuXHRcdHZhciByb290ID0gc2NvcGVfX1xuXHRcdGZvciBpdGVtIGluIG5vZGVzXG5cdFx0XHR2YXIgdmFyaWFibGUgPSByb290LnJlZ2lzdGVyIGl0ZW0uc3ltYm9sLCBpdGVtLCB0eXBlOiAnZ2xvYmFsJ1xuXHRcdFx0dmFyaWFibGUuYWRkUmVmZXJlbmNlKGl0ZW0pXG5cdFx0c2VsZlxuXG5cdGRlZiBjXG5cdFx0XCIvLyBleHRlcm5zXCJcdFx0XG5cdFx0XG5cbiMgRkxPV1xuXG5leHBvcnQgY2xhc3MgQ29udHJvbEZsb3cgPCBOb2RlXG5cblxuXG5leHBvcnQgY2xhc3MgQ29udHJvbEZsb3dTdGF0ZW1lbnQgPCBDb250cm9sRmxvd1xuXG5cdGRlZiBpc0V4cHJlc3NhYmxlXG5cdFx0bm9cblxuXG5cbmV4cG9ydCBjbGFzcyBJZiA8IENvbnRyb2xGbG93XG5cblxuXHRwcm9wIHRlc3Rcblx0cHJvcCBib2R5XG5cdHByb3AgYWx0XG5cdHByb3Agc2NvcGVcblxuXHRkZWYgc2VsZi50ZXJuYXJ5IGNvbmQsIGJvZHksIGFsdFxuXHRcdCMgcHJlZmVyIHRvIGNvbXBpbGUgaXQgdGhpcyB3YXkgYXMgd2VsbFxuXHRcdHZhciBvYmogPSBJZi5uZXcoY29uZCwgQmxvY2submV3KFtib2R5XSksIHR5cGU6ICc/Jylcblx0XHRvYmouYWRkRWxzZSBCbG9jay5uZXcoW2FsdF0pXG5cdFx0cmV0dXJuIG9ialxuXG5cdGRlZiBhZGRFbHNlIGFkZFxuXHRcdCMgcCBcImFkZCBlbHNlIVwiLGFkZFxuXHRcdGlmIGFsdCAmJiBhbHQgaXNhIElmXG5cdFx0XHQjIHAgJ2FkZCB0byB0aGUgaW5uZXIgZWxzZSghKScsYWRkXG5cdFx0XHRhbHQuYWRkRWxzZShhZGQpXG5cdFx0ZWxzZVxuXHRcdFx0c2VsZi5hbHQgPSBhZGRcblx0XHRzZWxmXG5cblxuXHRkZWYgaW5pdGlhbGl6ZSBjb25kLCBib2R5LCBvID0ge31cblx0XHRzZXR1cFxuXHRcdEB0ZXN0ID0gY29uZCAjIChvOnR5cGUgPT0gJ3VubGVzcycgPyBVbmFyeU9wLm5ldygnIScsY29uZCxudWxsKSA6IGNvbmQpXG5cdFx0QGJvZHkgPSBib2R5XG5cdFx0QGFsdCAgPSBudWxsXG5cdFx0QHR5cGUgPSBvOnR5cGVcblx0XHRpbnZlcnQgaWYgQHR5cGUgPT0gJ3VubGVzcydcblx0XHRAc2NvcGUgPSBJZlNjb3BlLm5ldyhzZWxmKVxuXHRcdHNlbGZcblxuXHRkZWYgaW52ZXJ0XG5cdFx0aWYgQHRlc3QgaXNhIENvbXBhcmlzb25PcFxuXHRcdFx0QHRlc3QgPSBAdGVzdC5pbnZlcnRcblx0XHRlbHNlXG5cdFx0XHRAdGVzdCA9IFVuYXJ5T3AubmV3KCchJyxAdGVzdCxudWxsKVxuXG5cdGRlZiB2aXNpdFxuXHRcdHZhciBhbHQgPSBhbHRcblxuXHRcdEBzY29wZS52aXNpdCBpZiBAc2NvcGVcblx0XHR0ZXN0LnRyYXZlcnNlIGlmIHRlc3Rcblx0XHRib2R5LnRyYXZlcnNlIGlmIGJvZHlcblxuXHRcdCMgc2hvdWxkIHNraXAgdGhlIHNjb3BlIGluIGFsdC5cblx0XHRpZiBhbHRcblx0XHRcdCMgcCBcInNjb3Bpbmcge1NUQUNLLnNjb3BlczpsZW5ndGh9XCJcblx0XHRcdFNUQUNLLnBvcChzZWxmKVxuXHRcdFx0YWx0LkBzY29wZSB8fD0gQmxvY2tTY29wZS5uZXcoYWx0KVxuXHRcdFx0YWx0LnRyYXZlcnNlXG5cdFx0XHRTVEFDSy5wdXNoKHNlbGYpXG5cblx0XHQjIGZvcmNlIGl0IGFzIGV4cHJlc3Npb24/XG5cdFx0dG9FeHByZXNzaW9uIGlmIEB0eXBlID09ICc/JyBhbmQgaXNFeHByZXNzYWJsZVxuXHRcdHNlbGZcblxuXG5cdGRlZiBqcyBvXG5cdFx0dmFyIGJvZHkgPSBib2R5XG5cdFx0IyB3b3VsZCBwb3NzaWJseSB3YW50IHRvIGxvb2sgdXAgLyBvdXQgXG5cdFx0dmFyIGJyYWNlID0gYnJhY2VzOiB5ZXMsIGluZGVudDogeWVzXG5cblx0XHR2YXIgY29uZCA9IHRlc3QuYyhleHByZXNzaW9uOiB5ZXMpICMgdGhlIGNvbmRpdGlvbiBpcyBhbHdheXMgYW4gZXhwcmVzc2lvblxuXG5cdFx0aWYgby5pc0V4cHJlc3Npb25cblx0XHRcdHZhciBjb2RlID0gYm9keS5jICMgKGJyYWNlczogeWVzKVxuXHRcdFx0Y29kZSA9ICcoJyArIGNvZGUgKyAnKScgIyBpZiBjb2RlLmluZGV4T2YoJywnKSA+PSAwXG5cdFx0XHQjIGlzIGV4cHJlc3Npb24hXG5cdFx0XHRpZiBhbHRcblx0XHRcdFx0IyBjb25zb2xlLmxvZyBcInR5cGUgb2YgdGVybmFyeSB7dGVzdH1cIlxuXHRcdFx0XHQjIGJlIHNhZmUgLSB3cmFwIGNvbmRpdGlvbiBhcyB3ZWxsXG5cdFx0XHRcdCMgYXNrIGZvciBwYXJlbnNcblx0XHRcdFx0cmV0dXJuIFwie2NvbmR9ID8ge2NvZGV9IDogKHthbHQuY30pXCJcblx0XHRcdGVsc2Vcblx0XHRcdFx0IyBhZ2FpbiAtIHdlIG5lZWQgYSBiZXR0ZXIgd2F5IHRvIGRlY2lkZSB3aGF0IG5lZWRzIHBhcmVuc1xuXHRcdFx0XHQjIG1heWJlIGJldHRlciBpZiB3ZSByZXdyaXRlIHRoaXMgdG8gYW4gT1AoJyYmJyksIGFuZCBwdXRcblx0XHRcdFx0IyB0aGUgcGFyZW5zIGxvZ2ljIHRoZXJlXG5cdFx0XHRcdCMgY29uZCBzaG91bGQgcG9zc2libHkgaGF2ZSBwYXJlbnMgLSBidXQgd2hlcmUgZG8gd2UgZGVjaWRlP1xuXHRcdFx0XHRpZiBAdGFndHJlZVxuXHRcdFx0XHRcdHJldHVybiBcIih7Y29uZH0pID8ge2NvZGV9IDogdm9pZCgwKVwiXHRcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHJldHVybiBcIih7Y29uZH0pICYmIHtjb2RlfVwiXG5cdFx0ZWxzZVxuXHRcdFx0IyBpZiB0aGVyZSBpcyBvbmx5IGEgc2luZ2xlIGl0ZW0gLSBhbmQgaXQgaXMgYW4gZXhwcmVzc2lvbj9cblx0XHRcdHZhciBjb2RlID0gbnVsbFxuXHRcdFx0IyBpZiBib2R5LmNvdW50ID09IDEgIyBkb250IGluZGVudCBieSBvdXJzZWx2ZXM/XG5cblx0XHRcdGlmIGJvZHkgaXNhIEJsb2NrIGFuZCBib2R5LmNvdW50ID09IDEgYW5kICEoYm9keS5maXJzdCBpc2EgTG9vcEZsb3dTdGF0ZW1lbnQpXG5cdFx0XHRcdCMgcCBcImJvZHkgdG8gYm9keSBmaXJzdCB7Ym9keS5maXJzdH1cIlxuXHRcdFx0XHRib2R5ID0gYm9keS5maXJzdFxuXG5cdFx0XHQjIGlmIGJvZHkuY291bnQgPT0gMVxuXHRcdFx0I1x0cCBcIm9uZSBpdGVtIG9ubHkhXCJcblx0XHRcdCNcdGJvZHkgPSBib2R5LmZpcnN0XG5cblx0XHRcdGNvZGUgPSBib2R5LmMoYnJhY2VzOiB5ZXMpICMgKGJyYWNlczogeWVzKVxuXG5cdFx0XHQjIGRvbid0IHdyYXAgaWYgaXQgaXMgb25seSBhIHNpbmdsZSBleHByZXNzaW9uP1xuXHRcdFx0dmFyIG91dCA9IFwie21hcmtfXyhAdHlwZSl9aWYgKHtjb25kfSkgXCIgKyBjb2RlICMgJyB7JyArIGNvZGUgKyAnfScgIyAneycgKyBjb2RlICsgJ30nXG5cdFx0XHRvdXQgKz0gXCIgZWxzZSB7YWx0LmMoYWx0IGlzYSBJZiA/IHt9IDogYnJhY2UpfVwiIGlmIGFsdFxuXHRcdFx0b3V0XG5cblx0ZGVmIHNvdXJjZU1hcE1hcmtlclxuXHRcdHNlbGZcblxuXHRkZWYgY29uc3VtZSBub2RlXG5cdFx0IyBwICdhc3NpZ25pZnkgaWY/ISdcblx0XHQjIGlmIGl0IGlzIHBvc3NpYmxlLCBjb252ZXJ0IGludG8gZXhwcmVzc2lvblxuXHRcdGlmIG5vZGUgaXNhIFRhZ1RyZWVcblx0XHRcdEBib2R5ID0gQGJvZHkuY29uc3VtZShub2RlKVxuXHRcdFx0QGFsdCA9IEBhbHQuY29uc3VtZShub2RlKSBpZiBAYWx0XG5cdFx0XHRAdGFndHJlZSA9IG5vZGVcblx0XHRcdHJldHVybiBzZWxmXG5cblx0XHQjIHNwZWNpYWwgY2FzZSBmb3IgSWYgY3JlYXRlZCBmcm9tIGNvbmRpdGlvbmFsIGFzc2lnbiBhcyB3ZWxsP1xuXHRcdCMgQHR5cGUgPT0gJz8nIGFuZCBcblx0XHQjIGlkZWFsbHkgd2UgZG9udCByZWFsbHkgd2FudCB0byBtYWtlIGFueSBleHByZXNzaW9uIGxpa2UgdGhpcyBieSBkZWZhdWx0XG5cdFx0dmFyIGlzUmV0ID0gbm9kZSBpc2EgUmV0dXJuXG5cblx0XHQjIG1pZ2h0IGhhdmUgYmVlbiBmb3JjZWQgdG8gZXhwcmVzc2lvbiBhbHJlYWR5XG5cdFx0IyBpZiBpdCB3YXMgb3JpZ2luYWxseSBhIHRlcm5hcnkgLSB3aHkgbm90XG5cdFx0aWYgQGV4cHJlc3Npb24gb3IgKCghaXNSZXQgb3IgQHR5cGUgPT0gJz8nKSBhbmQgaXNFeHByZXNzYWJsZSlcblx0XHRcdHRvRXhwcmVzc2lvbiAjIG1hcmsgYXMgZXhwcmVzc2lvbighKSAtIGlzIHRoaXMgbmVlZGVkP1xuXHRcdFx0cmV0dXJuIHN1cGVyKG5vZGUpXG5cdFx0ZWxzZVxuXHRcdFx0QGJvZHkgPSBAYm9keS5jb25zdW1lKG5vZGUpXG5cdFx0XHRAYWx0ID0gQGFsdC5jb25zdW1lKG5vZGUpIGlmIEBhbHRcblx0XHRzZWxmXG5cblxuXHRkZWYgaXNFeHByZXNzYWJsZVxuXHRcdCMgcHJvY2VzczpzdGRvdXQud3JpdGUgJ3gnXG5cdFx0dmFyIGV4cCA9IGJvZHkuaXNFeHByZXNzYWJsZSAmJiAoIWFsdCB8fCBhbHQuaXNFeHByZXNzYWJsZSlcblx0XHRyZXR1cm4gZXhwXG5cblxuXG5leHBvcnQgY2xhc3MgTG9vcCA8IFN0YXRlbWVudFxuXG5cblx0cHJvcCBzY29wZVxuXHRwcm9wIG9wdGlvbnNcblx0cHJvcCBib2R5XG5cdHByb3AgY2F0Y2hlclxuXG5cblx0ZGVmIGluaXRpYWxpemUgb3B0aW9ucyA9IHt9XG5cdFx0QHRyYXZlcnNlZCA9IG5vXG5cdFx0QG9wdGlvbnMgPSBvcHRpb25zXG5cdFx0QGJvZHkgPSBudWxsXG5cdFx0c2VsZlxuXG5cblx0ZGVmIHNldCBvYmpcblx0XHQjIHAgXCJjb25maWd1cmUgZm9yIVwiXG5cdFx0QG9wdGlvbnMgfHw9IHt9XG5cdFx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopXG5cdFx0Zm9yIGsgaW4ga2V5c1xuXHRcdFx0QG9wdGlvbnNba10gPSBvYmpba11cblx0XHRzZWxmXG5cblxuXHRkZWYgYWRkQm9keSBib2R5XG5cdFx0c2VsZi5ib2R5ID0gYmxrX18oYm9keSlcblx0XHRzZWxmXG5cblxuXHRkZWYgYyBvXG5cblx0XHR2YXIgcyA9IHN0YWNrXG5cdFx0dmFyIGN1cnIgPSBzLmN1cnJlbnRcblx0XHQjIHAgXCJMb29wLmMgLSB7aXNFeHByZXNzYWJsZX0ge3N0YWNrfSB7c3RhY2suaXNFeHByZXNzaW9ufVwiXG5cdFx0IyBwIFwic3RhY2sgaXMgZXhwcmVzc2lvbj8ge299IHtpc0V4cHJlc3Npb259XCJcblxuXG5cblx0XHRpZiBzdGFjay5pc0V4cHJlc3Npb24gb3IgaXNFeHByZXNzaW9uXG5cdFx0XHQjIHAgXCJ0aGUgc3RhY2sgaXMgYW4gZXhwcmVzc2lvbiBmb3IgbG9vcCBub3coISlcIlxuXHRcdFx0IyB3aGF0IHRoZSBpbm5lciBvbmUgc2hvdWxkIG5vdCBiZSBhbiBleHByZXNzaW9uIHRob3VnaD9cblx0XHRcdCMgdGhpcyB3aWxsIHJlc3V0IGluIGFuIGluZmluaXRlIGxvb3AsIG5vPyE/XG5cdFx0XHR2YXIgYXN0ID0gQ0FMTChGTihbXSxbc2VsZl0pLFtdKVxuXHRcdFx0cmV0dXJuIGFzdC5jIG9cblx0XHRcblx0XHRlbGlmIHN0YWNrLmN1cnJlbnQgaXNhIEJsb2NrIG9yIChzLnVwIGlzYSBCbG9jayBhbmQgcy5jdXJyZW50LkBjb25zdW1lciA9PSBzZWxmKVxuXHRcdFxuXHRcdFx0IyBwIFwid2hhdCBpcyB0aGUgY3VycmVudCBzdGFjayBvZiBsb29wPyB7c3RhY2suY3VycmVudH1cIlxuXHRcdFx0c3VwZXIuYyBvXG5cdFx0ZWxzZVxuXHRcdFx0IyBwIFwiU2hvdWxkIG5ldmVyIGdldCBoZXJlPyE/XCJcblx0XHRcdHZhciBhc3QgPSBDQUxMKEZOKFtdLFtzZWxmXSksW10pXG5cdFx0XHRyZXR1cm4gYXN0LmMgb1xuXHRcdFx0IyBuZWVkIHRvIHdyYXAgaW4gZnVuY3Rpb25cblxuXG5cbmV4cG9ydCBjbGFzcyBXaGlsZSA8IExvb3BcblxuXG5cdHByb3AgdGVzdFxuXG5cblx0ZGVmIGluaXRpYWxpemUgdGVzdCwgb3B0c1xuXHRcdEB0cmF2ZXJzZWQgPSBub1xuXHRcdEB0ZXN0ID0gdGVzdFxuXHRcdEBvcHRpb25zID0gb3B0cyBvciB7fVxuXHRcdEBzY29wZSA9IFdoaWxlU2NvcGUubmV3KHNlbGYpXG5cdFx0IyBzZXQob3B0cykgaWYgb3B0c1xuXHRcdCMgcCBcImludmVydCB0ZXN0IGZvciB3aGlsZT8ge0B0ZXN0fVwiXG5cdFx0aWYgb3B0aW9uKDppbnZlcnQpXG5cdFx0XHQjIFwiaW52ZXJ0IHRlc3QgZm9yIHdoaWxlIHtAdGVzdH1cIlxuXHRcdFx0QHRlc3QgPSB0ZXN0LmludmVydCBcblx0XHQjIGludmVydCB0aGUgdGVzdFxuXG5cblx0ZGVmIHZpc2l0XG5cdFx0c2NvcGUudmlzaXRcblx0XHR0ZXN0LnRyYXZlcnNlIGlmIHRlc3Rcblx0XHRib2R5LnRyYXZlcnNlIGlmIGJvZHlcblxuXG5cdCMgVE9ETyBCVUcgLS0gd2hlbiB3ZSBkZWNsYXJlIGEgdmFyIGxpa2U6IHdoaWxlIHZhciB5ID0gLi4uXG5cdCMgdGhlIHZhcmlhYmxlIHdpbGwgYmUgZGVjbGFyZWQgaW4gdGhlIFdoaWxlU2NvcGUgd2hpY2ggbmV2ZXJcblx0IyBmb3JjZS1kZWNsYXJlcyB0aGUgaW5uZXIgdmFyaWFibGVzIGluIHRoZSBzY29wZVxuXG5cdGRlZiBjb25zdW1lIG5vZGVcblx0XHQjIHAgXCJXaGlsZS5jb25zdW1lIHtub2RlfVwiLmN5YW5cblx0XHQjIFRoaXMgaXMgbmV2ZXIgZXhwcmVzc2FibGUsIGJ1dCBhdCBzb21lIHBvaW50XG5cdFx0IyB3ZSBtaWdodCB3YW50IHRvIHdyYXAgaXQgaW4gYSBmdW5jdGlvbiAobGlrZSBDUylcblx0XHRyZXR1cm4gc3VwZXIgaWYgaXNFeHByZXNzYWJsZVxuXG5cdFx0aWYgbm9kZSBpc2EgVGFnVHJlZVxuXHRcdFx0IyBXQVJOIHRoaXMgaXMgYSBoYWNrIHRvIGFsbG93IHJlZmVyZW5jZXMgY29taW5nIHRocm91Z2ggdGhlIHdyYXBwaW5nIHNjb3BlIFxuXHRcdFx0IyB3aWxsIHJlc3VsdCBpbiB1bm5lZWRlZCBzZWxmLWRlY2xhcmF0aW9ucyBhbmQgb3RoZXIgb2RkaXRpZXNcblx0XHRcdHNjb3BlLmNvbnRleHQucmVmZXJlbmNlXG5cdFx0XHRyZXR1cm4gQ0FMTChGTihbXSxbc2VsZl0pLFtdKVxuXG5cdFx0dmFyIHJldXNlID0gbm9cblx0XHQjIFdBUk4gT3B0aW1pemF0aW9uIC0gbWlnaHQgaGF2ZSB1bnRlbmRlZCBzaWRlLWVmZmVjdHNcblx0XHQjIGlmIHdlIGFyZSBhc3NpZ25pbmcgZGlyZWN0bHkgdG8gYSBsb2NhbCB2YXJpYWJsZSwgd2Ugc2ltcGx5XG5cdFx0IyB1c2Ugc2FpZCB2YXJpYWJsZSBmb3IgdGhlIGlubmVyIHJlc1xuXHRcdCMgaWYgcmV1c2Vcblx0XHQjIFx0cmVzdmFyID0gc2NvcGUuZGVjbGFyZShub2RlLmxlZnQubm9kZS52YXJpYWJsZSxBcnIubmV3KFtdKSxwcm94eTogeWVzKVxuXHRcdCMgXHRub2RlID0gbnVsbFxuXHRcdCMgXHRwIFwiY29uc3VtZSB2YXJpYWJsZSBkZWNsYXJhdG9yIT9cIi5jeWFuXG5cdFx0IyBlbHNlXG5cdFx0IyBkZWNsYXJlIHRoZSB2YXJpYWJsZSB3ZSB3aWxsIHVzZSB0byBzb2FrIHVwIHJlc3VsdHNcblx0XHQjIHAgXCJDcmVhdGluZyB2YWx1ZSB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIGxvb3BcIi5jeWFuXG5cdFx0IyBUT0RPIFVzZSBhIHNwZWNpYWwgdmFydHlwZSBmb3IgdGhpcz9cblx0XHR2YXIgcmVzdmFyID0gc2NvcGUuZGVjbGFyZSg6cmVzLEFyci5uZXcoW10pLHN5c3RlbTogeWVzKVxuXHRcdCMgV0hBVCAtLSBmaXggdGhpcyAtLVxuXHRcdEBjYXRjaGVyID0gUHVzaEFzc2lnbi5uZXcoXCJwdXNoXCIscmVzdmFyLG51bGwpICMgdGhlIHZhbHVlIGlzIG5vdCBwcmVzZXQgIyB3aGF0XG5cdFx0Ym9keS5jb25zdW1lKEBjYXRjaGVyKSAjIHNob3VsZCBzdGlsbCByZXR1cm4gdGhlIHNhbWUgYm9keVxuXG5cdFx0IyBzY29wZSB2YXJzIG11c3Qgbm90IGJlIGNvbXBpbGVkIGJlZm9yZSB0aGlzIC0tIHRoaXMgaXMgaW1wb3J0YW50XG5cdFx0dmFyIGFzdCA9IEJsb2NrLm5ldyhbc2VsZixyZXN2YXIuYWNjZXNzb3JdKSAjIHNob3VsZCBiZSB2YXJhY2Nlc3MgaW5zdGVhZD9cblx0XHRhc3QuY29uc3VtZShub2RlKVxuXHRcdCMgTk9URSBIZXJlIHdlIGNhbiBmaW5kIGEgd2F5IHRvIGtub3cgd2hldGVyIG9yIG5vdCB3ZSBldmVuIG5lZWQgdG8gXG5cdFx0IyByZXR1cm4gdGhlIHJlc3Zhci4gT2Z0ZW4gaXQgd2lsbCBub3QgYmUgbmVlZGVkXG5cdFx0IyBGSVhNRSB3aGF0IGhhcHBlbnMgaWYgdGhlcmUgaXMgbm8gbm9kZT8hP1xuXG5cblx0ZGVmIGpzIG9cblx0XHR2YXIgb3V0ID0gXCJ3aGlsZSAoe3Rlc3QuYyhleHByZXNzaW9uOiB5ZXMpfSlcIiArIGJvZHkuYyhicmFjZXM6IHllcywgaW5kZW50OiB5ZXMpICMgLndyYXBcblxuXHRcdGlmIHNjb3BlLnZhcnMuY291bnQgPiAwXG5cdFx0XHQjIHAgXCJ3aGlsZS1ibG9jayBoYXMgZGVjbGFyZWQgdmFyaWFibGVzKCEpXCJcblx0XHRcdHJldHVybiBbc2NvcGUudmFycy5jLG91dF1cblx0XHRvdXRcblxuXG5cbiMgVGhpcyBzaG91bGQgZGVmaW5lIGFuIG9wZW4gc2NvcGVcbiMgc2hvdWxkIHJhdGhlciBcbmV4cG9ydCBjbGFzcyBGb3IgPCBMb29wXG5cblxuXHRkZWYgaW5pdGlhbGl6ZSBvID0ge31cblx0XHRAdHJhdmVyc2VkID0gbm9cblx0XHRAb3B0aW9ucyA9IG9cblx0XHRAc2NvcGUgPSBGb3JTY29wZS5uZXcoc2VsZilcblx0XHRAY2F0Y2hlciA9IG51bGxcblxuXHRkZWYgdmlzaXRcblx0XHRzY29wZS52aXNpdFxuXHRcdG9wdGlvbnNbOnNvdXJjZV0udHJhdmVyc2UgIyB3aGF0IGFib3V0IGF3YWtlbmluZyB0aGUgdmFycyBoZXJlP1xuXHRcdGRlY2xhcmVcblx0XHQjIHNob3VsZCBiZSBhYmxlIHRvIHRvZ2dsZSB3aGV0aGVyIHRvIGtlZXAgdGhlIHJlc3VsdHMgaGVyZSBhbHJlYWR5KCEpXG5cblx0XHQjIGFkZCBndWFyZCB0byBib2R5XG5cdFx0aWYgb3B0aW9uczpndWFyZFxuXHRcdFx0dmFyIG9wID0gSUYob3B0aW9uczpndWFyZC5pbnZlcnQsQmxvY2sud3JhcChbQ29udGludWVTdGF0ZW1lbnQubmV3KFwiY29udGludWVcIildKSlcblx0XHRcdGJvZHkudW5zaGlmdChvcCxCUilcblxuXHRcdGJvZHkudHJhdmVyc2Vcblx0XHRcblx0ZGVmIGlzQmFyZSBzcmNcblx0XHRzcmMgYW5kIHNyYy5AdmFyaWFibGUgYW5kIHNyYy5AdmFyaWFibGUuQGlzQXJyYXlcblxuXHRkZWYgZGVjbGFyZVxuXHRcdHZhciBvID0gb3B0aW9uc1xuXHRcdHZhciBzY29wZSA9IHNjb3BlXG5cdFx0dmFyIHNyYyAgPSBvOnNvdXJjZVxuXHRcdHZhciB2YXJzID0gb1s6dmFyc10gPSB7fVxuXHRcdHZhciBvaSAgID0gbzppbmRleFxuXG5cdFx0dmFyIGJhcmUgPSBpc0JhcmUoc3JjKVxuXHRcdCMgcCBcInNvdXJjZSBpcyBhIHtzcmN9IC0ge2JhcmV9XCJcblx0XHQjIHZhciBpID0gdmFyczppbmRleCA9IG9pID8gc2NvcGUuZGVjbGFyZShvaSwwKSA6IHV0aWwuY291bnRlcigwLHllcykucHJlZGVjbGFyZVxuXG5cdFx0IyB3aGF0IGFib3V0IGEgcmFuZ2Ugd2hlcmUgd2UgYWxzbyBpbmNsdWRlIGFuIGluZGV4P1xuXHRcdGlmIHNyYyBpc2EgUmFuZ2Vcblx0XHRcdCMgcCBcInJhbmdlIGZvci1sb29wXCJcblxuXHRcdFx0IyByZWFsbHk/IGRlY2xhcmU/IFxuXHRcdFx0IyBhcmUgd2Ugc3VyZT8gX3JlYWxseV8/XG5cdFx0XHR2YXJzOmxlbiA9IHNjb3BlLmRlY2xhcmUoJ2xlbicsc3JjLnJpZ2h0KSAjIHV0aWwubGVuKG8seWVzKS5wcmVkZWNsYXJlXG5cdFx0XHQjIG1ha2UgdGhlIHNjb3BlIGJlIHRoZSBkZWNsYXJhdG9yXG5cdFx0XHQjIFRPRE8gd291bGQgbGlrZSB0byBiZSBhYmxlIHRvIGhhdmUgY291bnRlciBpbiByYW5nZSBhcyB3ZWxsXG5cdFx0XHR2YXJzOmluZGV4ID0gc2NvcGUucmVnaXN0ZXIobzpuYW1lLHNjb3BlLHR5cGU6ICdsZXQnLCBkZWNsYXJlZDogeWVzKVxuXHRcdFx0IyBwIFwicmVnaXN0ZXJlZCB7dmFyczppbmRleDpjb25zdHJ1Y3Rvcn1cIlxuXHRcdFx0IyBwIFwiaW5kZXgtdmFyIGlzIGRlY2xhcmVvZD8hPyEge3ZhcnM6aW5kZXguQGRlY2xhcmVkfVwiXG5cdFx0XHRzY29wZS52YXJzLnB1c2godmFyczppbmRleC5hc3NpZ25tZW50KHNyYy5sZWZ0KSlcblx0XHRcdCMgc2NvcGUuZGVjbGFyZShvcHRpb25zOm5hbWUsc3JjLmxlZnQpXG5cdFx0XHR2YXJzOnZhbHVlID0gdmFyczppbmRleFxuXHRcdGVsc2Vcblx0XHRcdCMgdmFyczp2YWx1ZSA9IHNjb3BlLmRlY2xhcmUob3B0aW9uczpuYW1lLG51bGwsbGV0OiB5ZXMpXG5cdFx0XHQjIHdlIGFyZSB1c2luZyBhdXRvbWF0aWMgY2FjaGluZyBmYXIgdG9vIG11Y2ggaGVyZVxuXG5cdFx0XHQjIHdlIHNob3VsZCBzaW1wbHkgY2hhbmdlIGhvdyBkZWNsYXJlIHdvcmtzXG5cdFx0XHR2YXIgaSA9IHZhcnM6aW5kZXggPSBvaSA/IHNjb3BlLmRlY2xhcmUob2ksMCx0eXBlOiAnbGV0JykgOiB1dGlsLmNvdW50ZXIoMCx5ZXMsc2NvcGUpLnByZWRlY2xhcmVcblxuXHRcdFx0dmFyczpzb3VyY2UgPSBiYXJlID8gc3JjIDogdXRpbC5pdGVyYWJsZShzcmMseWVzKS5wcmVkZWNsYXJlXG5cdFx0XHR2YXJzOmxlbiAgICA9IHV0aWwubGVuKHZhcnM6c291cmNlLHllcykucHJlZGVjbGFyZVxuXG5cdFx0XHR2YXJzOnZhbHVlID0gc2NvcGUuZGVjbGFyZShvOm5hbWUsbnVsbCx0eXBlOiAnbGV0Jylcblx0XHRcdHZhcnM6dmFsdWUuYWRkUmVmZXJlbmNlKG86bmFtZSkgIyBhZGRpbmcgcmVmZXJlbmNlIVxuXHRcdFx0aS5hZGRSZWZlcmVuY2Uob2kpIGlmIG9pXG5cblx0XHRyZXR1cm4gc2VsZlxuXG5cblx0ZGVmIGNvbnN1bWUgbm9kZVxuXG5cdFx0aWYgaXNFeHByZXNzYWJsZVxuXHRcdFx0cmV0dXJuIHN1cGVyIFxuXG5cdFx0IyBvdGhlciBjYXNlcyBhcyB3ZWxsLCBubz9cblx0XHRpZiBub2RlIGlzYSBUYWdUcmVlXG5cdFx0XHRzY29wZS5jb250ZXh0LnJlZmVyZW5jZVxuXHRcdFx0dmFyIHJlZiA9IG5vZGUucm9vdC5yZWZlcmVuY2Vcblx0XHRcdG5vZGUuQGxvb3AgPSBzZWxmXG5cblx0XHRcdCMgU2hvdWxkIG5vdCBiZSBjb25zdW1lZCB0aGUgc2FtZSB3YXlcblx0XHRcdGJvZHkuY29uc3VtZShub2RlKVxuXHRcdFx0bm9kZS5AbG9vcCA9IG51bGxcblx0XHRcdGxldCBmbiA9IExhbWJkYS5uZXcoW1BhcmFtLm5ldyhyZWYpXSxbc2VsZl0pXG5cdFx0XHRmbi5zY29wZS53cmFwKHNjb3BlKVxuXHRcdFx0IyBUT0RPIFNjb3BlIG9mIGdlbmVyYXRlZCBsYW1iZGEgc2hvdWxkIGJlIGFkZGVkIGludG8gc3RhY2sgZm9yXG5cdFx0XHQjIHZhcmlhYmxlIG5hbWluZyAvIHJlc29sdXRpb25cblx0XHRcdHJldHVybiBDQUxMKGZuLFtyZWZdKVxuXG5cblx0XHRpZiBAcmVzdmFyXG5cdFx0XHQjIHAgXCJhbHJlYWR5IGhhdmUgYSByZXN2YXIgLS0gY2hhbmdlIGNvbnN1bWU/IHtub2RlfVwiXG5cdFx0XHR2YXIgYXN0ID0gQmxvY2submV3KFtzZWxmLEJSLEByZXN2YXIuYWNjZXNzb3JdKVxuXHRcdFx0YXN0LmNvbnN1bWUobm9kZSlcblx0XHRcdHJldHVybiBhc3Rcblx0XHRcblx0XHQjIGlmIG5vZGUgaXNhIHJldHVybiAtLSBkbyBzb21ldGhpbmcgZWxzZVxuXG5cdFx0dmFyIHJlc3ZhciA9IG51bGxcblx0XHR2YXIgcmV1c2VhYmxlID0gbm8gIyBub2RlIGlzYSBBc3NpZ24gJiYgbm9kZS5sZWZ0Lm5vZGUgaXNhIExvY2FsVmFyQWNjZXNzXG5cdFx0dmFyIGFzc2lnbmVlID0gbnVsbFxuXHRcdCMgbWlnaHQgb25seSB3b3JrIGZvciBsb2NhbHM/XG5cdFx0aWYgbm9kZSBpc2EgQXNzaWduXG5cdFx0XHQjIHAgXCJub2RlIGlzYSBhc3NpZ24ge25vZGV9IHtub2RlLmxlZnR9XCJcblx0XHRcdGlmIHZhciByZWNlaXZlciA9IG5vZGUubGVmdFxuXHRcdFx0XHRpZiBhc3NpZ25lZSA9IHJlY2VpdmVyLkB2YXJpYWJsZVxuXHRcdFx0XHRcdCMgd2UgY2FuIG9ubHkgcHVsbCB0aGUgdmFyIHJlZmVyZW5jZSBpbnRvIHRoZSBzY29wZVxuXHRcdFx0XHRcdCMgaWYgd2Uga25vdyB0aGF0IHRoZSB2YXJpYWJsZSBpcyBkZWNsYXJlZCBpbiB0aGlzIHNjb3BlXG5cdFx0XHRcdFx0cmV1c2VhYmxlID0gKHJlY2VpdmVyIGlzYSBWYXJSZWZlcmVuY2UpXG5cblx0XHQjIHAgXCJyZXVzYWJsZT8hPyEge25vZGV9IHtub2RlfVwiXG5cblx0XHQjIFdBUk4gT3B0aW1pemF0aW9uIC0gbWlnaHQgaGF2ZSB1bnRlbmRlZCBzaWRlLWVmZmVjdHNcblx0XHQjIGlmIHdlIGFyZSBhc3NpZ25pbmcgZGlyZWN0bHkgdG8gYSBsb2NhbCB2YXJpYWJsZSwgd2Ugc2ltcGx5XG5cdFx0IyB1c2Ugc2FpZCB2YXJpYWJsZSBmb3IgdGhlIGlubmVyIHJlc1xuXHRcdGlmIHJldXNlYWJsZSBhbmQgYXNzaWduZWVcblx0XHRcdCMgaW5zdGVhZCBvZiBkZWNsYXJpbmcgaXQgaW4gdGhlIHNjb3BlIC0gd2h5IG5vdCBkZWNsYXJlIGl0IG91dHNpZGU/XG5cdFx0XHQjIGl0IG1pZ2h0IGFscmVhZHkgZXhpc3QgaW4gdGhlIG91dGVyIHNjb3BlIG5vP1xuXHRcdFx0IyBwIFwicmV1c2VhYmxlIHthc3NpZ25lZX0ge3Njb3BlfSB7c2NvcGUucGFyZW50Lmxvb2t1cChhc3NpZ25lZSl9XCJcblx0XHRcdCMgYXNzaWduZWUucmVzb2x2ZVxuXHRcdFx0IyBzaG91bGQgcHJvYmFibHkgaW5zdGVhZCBhbHRlciB0aGUgYXNzaWduLW5vZGUgdG8gc2V0IHZhbHVlIHRvIGEgYmxhbmsgYXJyYXlcblx0XHRcdCMgcmVzdmFyID0gc2NvcGUucGFyZW50LmRlY2xhcmUoYXNzaWduZWUsQXJyLm5ldyhbXSkscHJveHk6IHllcyxwb3M6IDApXG5cblx0XHRcdCMgdGhpcyB2YXJpYWJsZSBzaG91bGQgcmVhbGx5IG5vdCBiZSByZWRlY2xhcmVkIGluc2lkZSBoZXJlIGF0IGFsbFxuXHRcdFx0YXNzaWduZWUucmVzb2x2ZVxuXHRcdFx0IyByZXN2YXIgPSBAcmVzdmFyID0gc2NvcGUuZGVjbGFyZShhc3NpZ25lZSxBcnIubmV3KFtdKSxwcm94eTogeWVzKVxuXG5cdFx0XHQjIGRvbnQgZGVjbGFyZSBpdCAtIHNpbXBseSBwdXNoIGFuIGFzc2lnbiBpbnRvIHRoZSB2YXJkZWNsIG9mIHNjb3BlXG5cdFx0XHRzY29wZS52YXJzLnVuc2hpZnQoT1AoJz0nLGFzc2lnbmVlLEFyci5uZXcoW10pKSlcblx0XHRcdHJlc3ZhciA9IEByZXN2YXIgPSBhc3NpZ25lZVxuXG5cdFx0XHRub2RlLkBjb25zdW1lciA9IHNlbGZcblx0XHRcdG5vZGUgPSBudWxsXG5cblx0XHRcdCMgcCBcImNvbnN1bWUgdmFyaWFibGUgZGVjbGFyYXRvciE/XCIuY3lhblxuXHRcdGVsc2Vcblx0XHRcdCMgZGVjbGFyZSB0aGUgdmFyaWFibGUgd2Ugd2lsbCB1c2UgdG8gc29hayB1cCByZXN1bHRzXG5cdFx0XHQjIHAgXCJDcmVhdGluZyB2YWx1ZSB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIGxvb3BcIi5jeWFuXG5cdFx0XHQjIHdoYXQgYWJvdXQgYSBwb29sIGhlcmU/XG5cdFx0XHRyZXN2YXIgPSBAcmVzdmFyID0gc2NvcGUuZGVjbGFyZSg6cmVzLEFyci5uZXcoW10pLHN5c3RlbTogeWVzKVxuXG5cdFx0QGNhdGNoZXIgPSBQdXNoQXNzaWduLm5ldyhcInB1c2hcIixyZXN2YXIsbnVsbCkgIyB0aGUgdmFsdWUgaXMgbm90IHByZXNldFxuXHRcdGJvZHkuY29uc3VtZShAY2F0Y2hlcikgIyBzaG91bGQgc3RpbGwgcmV0dXJuIHRoZSBzYW1lIGJvZHlcblxuXG5cblx0XHRpZiBub2RlXG5cdFx0XHQjIHAgXCJyZXR1cm5pbmcgbmV3IGFzdCB3aGVyZSBMb29wIGlzIGZpcnN0XCJcblx0XHRcdHZhciBhc3QgPSBCbG9jay5uZXcoW3NlbGYsQlIscmVzdmFyLmFjY2Vzc29yLmNvbnN1bWUobm9kZSldKVxuXHRcdFx0cmV0dXJuIGFzdFxuXHRcdCMgdmFyIGFzdCA9IEJsb2NrLm5ldyhbc2VsZixCUixyZXN2YXIuYWNjZXNzb3JdKVxuXHRcdCMgYXN0LmNvbnN1bWUobm9kZSkgaWYgbm9kZVxuXHRcdCMgcmV0dXJuIGFzdFxuXHRcdCMgcCBcIkxvb3AgZGlkIGNvbnN1bWUgc3VjY2Vzc2Z1bGx5XCJcblx0XHRyZXR1cm4gc2VsZlxuXG5cdFx0IyB0aGlzIGlzIG5ldmVyIGFuIGV4cHJlc3Npb24gKGZvciBub3cgLS0gYnV0IHN0aWxsKVxuXHRcdCMgcmV0dXJuIGFzdFxuXG5cblx0ZGVmIGpzIG9cblx0XHR2YXIgdmFycyA9IG9wdGlvbnM6dmFyc1xuXHRcdHZhciBpID0gdmFyczppbmRleFxuXHRcdHZhciB2YWwgPSB2YXJzOnZhbHVlXG5cdFx0dmFyIGNvbmQgPSBPUCgnPCcsaSx2YXJzOmxlbilcblx0XHR2YXIgc3JjID0gb3B0aW9uczpzb3VyY2VcblxuXHRcdCMgcCBcInJlZmVyZW5jZXMgZm9yIHZhbHVlXCIsdmFsLnJlZmVyZW5jZXM6bGVuZ3RoXG5cblx0XHR2YXIgZmluYWwgPSBpZiBvcHRpb25zOnN0ZXBcblx0XHRcdE9QKCc9JyxpLE9QKCcrJyxpLG9wdGlvbnM6c3RlcCkpXG5cdFx0ZWxzZVxuXHRcdFx0T1AoJysrJyxpKVxuXG5cdFx0IyBpZiB0aGVyZSBhcmUgZmV3IHJlZmVyZW5jZXMgdG8gdGhlIHZhbHVlIC0gd2UgY2FuIGRyb3Bcblx0XHQjIHRoZSBhY3R1YWwgdmFyaWFibGUgYW5kIGluc3RlYWQgbWFrZSBpdCBwcm94eSB0aHJvdWdoIHRoZSBpbmRleFxuXHRcdGlmIHNyYyBpc2EgUmFuZ2Vcblx0XHRcdGNvbmQub3AgPSAnPD0nIGlmIHNyYy5pbmNsdXNpdmVcblx0XHRcblx0XHRlbGlmIHZhbC5yZWZjb3VudCA8IDMgYW5kIHZhbC5hc3NpZ25tZW50czpsZW5ndGggPT0gMFxuXHRcdFx0IyBwIFwicHJveHkgdGhlIHZhbHVlIHt2YWwuYXNzaWdubWVudHM6bGVuZ3RofVwiXG5cdFx0XHQjIHAgXCJzaG91bGQgcHJveHkgdmFsdWUtdmFyaWFibGUgaW5zdGVhZFwiXG5cdFx0XHR2YWwucHJveHkodmFyczpzb3VyY2UsaSlcblx0XHRlbHNlXG5cdFx0XHRib2R5LnVuc2hpZnQoT1AoJz0nLHZhbCxPUCgnLicsdmFyczpzb3VyY2UsaSkpLCBCUilcblx0XHRcdCMgYm9keS51bnNoaWZ0KGhlYWQpXG5cdFx0XHQjIFRPRE8gY2hlY2sgbGVuZ3RocyAtIGludGVsbGlnZW50bHkgZGVjaWRlIHdoZXRoZXIgdG8gYnJhY2UgYW5kIGluZGVudFxuXHRcdHZhciBoZWFkID0gXCJ7bWFya19fKG9wdGlvbnM6a2V5d29yZCl9Zm9yICh7c2NvcGUudmFycy5jfTsge2NvbmQuY307IHtmaW5hbC5jfSkgXCJcblx0XHRoZWFkICsgYm9keS5jKGJyYWNlczogeWVzLCBpbmRlbnQ6IHllcykgIyAud3JhcFxuXG5cblx0ZGVmIGhlYWRcblx0XHR2YXIgdmFycyA9IG9wdGlvbnM6dmFyc1xuXHRcdE9QKCc9Jyx2YXJzOnZhbHVlLE9QKCcuJyx2YXJzOnNvdXJjZSx2YXJzOmluZGV4KSlcblxuXG5cbmV4cG9ydCBjbGFzcyBGb3JJbiA8IEZvclxuXG5cblx0XHRcbmV4cG9ydCBjbGFzcyBGb3JPZiA8IEZvclxuXG5cdGRlZiBkZWNsYXJlXG5cdFx0dmFyIG8gPSBvcHRpb25zXG5cdFx0dmFyIHZhcnMgPSBvOnZhcnMgPSB7fVxuXG5cdFx0IyBzZWUgaWYgXG5cblx0XHQjIHAgXCJGb3JPZiBzb3VyY2UgaXNhIHtvOnNvdXJjZX1cIlxuXG5cdFx0IyBpZiBvOnNvdXJjZSBpcyBhIHZhcmlhYmxlIC0tIHJlZmVyIGRpcmVjdGx5ICMgdmFyaWFibGU/IGlzIHRoaXMgdGhlIGlzc3VlP1xuXHRcdCMgcCBzY29wZS5AdmFybWFwWydvJ10sIHNjb3BlLnBhcmVudC5AdmFybWFwWydvJ11cblxuXHRcdHZhciBzcmMgPSB2YXJzOnNvdXJjZSA9IG86c291cmNlLkB2YXJpYWJsZSB8fCBzY29wZS5kZWNsYXJlKCdvJyxvOnNvdXJjZSwgc3lzdGVtOiB0cnVlLCB0eXBlOiAnbGV0Jylcblx0XHR2YXIgdiA9IHZhcnM6dmFsdWUgPSBzY29wZS5kZWNsYXJlKG86aW5kZXgsbnVsbCxsZXQ6IHllcykgaWYgbzppbmRleFxuXG5cdFx0IyBwIFwiRm9yT2YgbzppbmRleCB7bzppbmRleH0gbzpuYW1lIHtvOm5hbWV9XCJcblx0XHQjIGlmIG86aW5kZXhcblx0XHRcblx0XHQjIHBvc3NpYmx5IHByb3h5IHRoZSBpbmRleC12YXJpYWJsZT9cblxuXHRcdGlmIG86b3duXG5cdFx0XHQjIHZhciBpID0gdmFyczppbmRleCA9IHNjb3BlLmRlY2xhcmUoJ2knLDAsc3lzdGVtOiB0cnVlLCB0eXBlOiAnbGV0JykgIyBtYXJrIGFzIGEgY291bnRlcj9cblx0XHRcdHZhciBpID0gdmFyczppbmRleCA9IHV0aWwuY291bnRlcigwLHllcyxzY29wZSkucHJlZGVjbGFyZVxuXHRcdFx0IyBzeXN0ZW12YXJpYWJsZSAtLSBzaG91bGQgbm90IHJlYWxseSBiZSBhZGRlZCB0byB0aGUgbWFwXG5cdFx0XHR2YXIga2V5cyA9IHZhcnM6a2V5cyA9IHNjb3BlLmRlY2xhcmUoJ2tleXMnLFV0aWwua2V5cyhzcmMuYWNjZXNzb3IpLHN5c3RlbTogeWVzLCB0eXBlOiAnbGV0JykgIyB0aGUgb3V0ZXIgb25lIHNob3VsZCByZXNvbHZlIGZpcnN0XG5cdFx0XHR2YXIgbCA9IHZhcnM6bGVuID0gc2NvcGUuZGVjbGFyZSgnbCcsVXRpbC5sZW4oa2V5cy5hY2Nlc3Nvciksc3lzdGVtOiB5ZXMsIHR5cGU6ICdsZXQnKVxuXHRcdFx0dmFyIGsgPSB2YXJzOmtleSA9IHNjb3BlLnJlZ2lzdGVyKG86bmFtZSxvOm5hbWUsdHlwZTogJ2xldCcpICMgc2NvcGUuZGVjbGFyZShvOm5hbWUsbnVsbCxzeXN0ZW06IHllcylcblx0XHRlbHNlXG5cdFx0XHQjIHdlIHNldCB0aGUgdmFyIC0tIHdoeSBldmVuIGRlY2xhcmUgaXRcblx0XHRcdCMgbm8gbmVlZCB0byBkZWNsYXJlIC0tIGl0IHdpbGwgZGVjbGFyZSBpdHNlbGYgaW4gdGhlIGxvb3AgLSBubz9cblx0XHRcdHZhciBrID0gdmFyczprZXkgPSBzY29wZS5yZWdpc3RlcihvOm5hbWUsbzpuYW1lLHR5cGU6ICdsZXQnKVxuXHRcdFxuXHRcdCMgVE9ETyB1c2UgdXRpbCAtIHdoeSBhZGQgcmVmZXJlbmNlcyBhbHJlYWR5PyBBaCAtLSB0aGlzIGlzIGZvciB0aGUgaGlnaGxpZ2h0aW5nXG5cdFx0di5hZGRSZWZlcmVuY2UobzppbmRleCkgaWYgdiBhbmQgbzppbmRleFxuXHRcdGsuYWRkUmVmZXJlbmNlKG86bmFtZSkgaWYgayBhbmQgbzpuYW1lXG5cblx0XHRzZWxmXG5cblx0ZGVmIGpzIG9cblx0XHR2YXIgdmFycyA9IG9wdGlvbnM6dmFyc1xuXG5cdFx0dmFyIG8gPSB2YXJzOnNvdXJjZVxuXHRcdHZhciBrID0gdmFyczprZXlcblx0XHR2YXIgdiA9IHZhcnM6dmFsdWVcblx0XHR2YXIgaSA9IHZhcnM6aW5kZXhcblxuXG5cdFx0aWYgdiBcblx0XHRcdCMgc2V0IHZhbHVlIGFzIHByb3h5IG9mIG9iamVjdFtrZXldXG5cdFx0XHQjIHBvc3NpYmx5IG1ha2UgaXQgYSByZWY/IHdoYXQgaXMgaGFwcGVuaW5nP1xuXHRcdFx0di5yZWZjb3VudCA8IDMgPyB2LnByb3h5KG8saykgOiBib2R5LnVuc2hpZnQoT1AoJz0nLHYsT1AoJy4nLG8saykpKVxuXG5cdFx0aWYgb3B0aW9uczpvd25cblxuXHRcdFx0aWYgay5yZWZjb3VudCA8IDMgIyBzaG91bGQgcHJvYmFibHkgYWRqdXN0IHRoZXNlXG5cdFx0XHRcdGsucHJveHkodmFyczprZXlzLGkpXG5cdFx0XHRlbHNlXG5cdFx0XHRcdGJvZHkudW5zaGlmdChPUCgnPScsayxPUCgnLicsdmFyczprZXlzLGkpKSlcblxuXHRcdFx0dmFyIGhlYWQgPSBcInttYXJrX18ob3B0aW9uczprZXl3b3JkKX1mb3IgKHtzY29wZS52YXJzLmN9OyB7T1AoJzwnLGksdmFyczpsZW4pLmN9OyB7T1AoJysrJyxpKS5jfSlcIlxuXHRcdFx0cmV0dXJuIGhlYWQgKyBib2R5LmMoaW5kZW50OiB5ZXMsIGJyYWNlczogeWVzKSAjIC53cmFwXG5cblx0XHR2YXIgY29kZSA9IGJvZHkuYyhicmFjZXM6IHllcywgaW5kZW50OiB5ZXMpXG5cdFx0IyBpdCBpcyByZWFsbHkgaW1wb3J0YW50IHRoYXQgdGhpcyBpcyBhIHRyZWF0ZWQgYXMgYSBzdGF0ZW1lbnRcblx0XHRzY29wZS52YXJzLmMgKyBcIjtcXG57bWFya19fKG9wdGlvbnM6a2V5d29yZCl9Zm9yICh2YXIge2suY30gaW4ge28uY30pXCIgKyBjb2RlXG5cblx0ZGVmIGhlYWRcblx0XHR2YXIgdiA9IG9wdGlvbnM6dmFyc1xuXG5cdFx0W1xuXHRcdFx0T1AoJz0nLHY6a2V5LE9QKCcuJyx2OmtleXMsdjppbmRleCkpXG5cdFx0XHRPUCgnPScsdjp2YWx1ZSxPUCgnLicsdjpzb3VyY2UsdjprZXkpKSBpZiB2OnZhbHVlXG5cdFx0XVxuXG4jIE5PIE5FRUQ/XG5leHBvcnQgY2xhc3MgQmVnaW4gPCBCbG9ja1xuXG5cblx0ZGVmIGluaXRpYWxpemUgYm9keVxuXHRcdEBub2RlcyA9IGJsa19fKGJvZHkpLm5vZGVzXG5cblxuXHRkZWYgc2hvdWxkUGFyZW50aGVzaXplXG5cdFx0aXNFeHByZXNzaW9uXG5cblxuXG5leHBvcnQgY2xhc3MgU3dpdGNoIDwgQ29udHJvbEZsb3dTdGF0ZW1lbnRcblxuXG5cdHByb3Agc291cmNlXG5cdHByb3AgY2FzZXNcblx0cHJvcCBmYWxsYmFja1xuXG5cblx0ZGVmIGluaXRpYWxpemUgYSxiLGNcblx0XHRAdHJhdmVyc2VkID0gbm9cblx0XHRAc291cmNlID0gYVxuXHRcdEBjYXNlcyA9IGJcblx0XHRAZmFsbGJhY2sgPSBjXG5cblxuXHRkZWYgdmlzaXRcblx0XHRjLnRyYXZlcnNlIGZvciBjIGluIGNhc2VzXG5cdFx0ZmFsbGJhY2sudmlzaXQgaWYgZmFsbGJhY2tcblx0XHRzb3VyY2UudmlzaXQgaWYgc291cmNlXG5cdFx0cmV0dXJuXG5cblxuXHRkZWYgY29uc3VtZSBub2RlXG5cdFx0IyBUT0RPIHdvcmsgaW5zaWRlIHRhZ3MgKGxpa2UgbG9vcHMpXG5cdFx0QGNhc2VzID0gQGNhc2VzLm1hcCh8aXRlbXwgaXRlbS5jb25zdW1lKG5vZGUpKVxuXHRcdEBmYWxsYmFjayA9IEBmYWxsYmFjay5jb25zdW1lKG5vZGUpIGlmIEBmYWxsYmFja1xuXHRcdHNlbGZcblxuXHRkZWYgYyBvXG5cdFx0aWYgc3RhY2suaXNFeHByZXNzaW9uIG9yIGlzRXhwcmVzc2lvblxuXHRcdFx0dmFyIGFzdCA9IENBTEwoRk4oW10sW3NlbGZdKSxbXSlcblx0XHRcdHJldHVybiBhc3QuYyBvXG5cblx0XHRzdXBlci5jKG8pXG5cblxuXHRkZWYganMgb1xuXHRcdHZhciBib2R5ID0gW11cblxuXHRcdGZvciBwYXJ0IGluIGNhc2VzXG5cdFx0XHRwYXJ0LmF1dG9icmVha1xuXHRcdFx0Ym9keS5wdXNoKHBhcnQpXG5cblx0XHRpZiBmYWxsYmFja1xuXHRcdFx0Ym9keS5wdXNoKFwiZGVmYXVsdDpcXG5cIiArIGZhbGxiYWNrLmMoaW5kZW50OiB5ZXMpKVxuXG5cdFx0XCJzd2l0Y2ggKHtzb3VyY2UuY30pIFwiICsgaGVscGVycy5icmFja2V0aXplKGNhcnlfXyhib2R5KS5qb2luKFwiXFxuXCIpLHllcylcblxuXG5cbmV4cG9ydCBjbGFzcyBTd2l0Y2hDYXNlIDwgQ29udHJvbEZsb3dTdGF0ZW1lbnRcblxuXG5cdHByb3AgdGVzdFxuXHRwcm9wIGJvZHlcblxuXG5cdGRlZiBpbml0aWFsaXplIHRlc3QsIGJvZHlcblx0XHRAdHJhdmVyc2VkID0gbm9cblx0XHRAdGVzdCA9IHRlc3Rcblx0XHRAYm9keSA9IGJsa19fKGJvZHkpXG5cblx0ZGVmIHZpc2l0XG5cdFx0Ym9keS50cmF2ZXJzZVxuXG5cblx0ZGVmIGNvbnN1bWUgbm9kZVxuXHRcdGJvZHkuY29uc3VtZShub2RlKVxuXHRcdHNlbGZcblxuXG5cdGRlZiBhdXRvYnJlYWtcblx0XHRib2R5LnB1c2goQnJlYWtTdGF0ZW1lbnQubmV3KSB1bmxlc3MgYm9keS5sYXN0IGlzYSBCcmVha1N0YXRlbWVudFxuXHRcdHNlbGZcblxuXG5cdGRlZiBqcyBvXG5cdFx0QHRlc3QgPSBbQHRlc3RdIHVubGVzcyBAdGVzdCBpc2EgQXJyYXkgXG5cdFx0dmFyIGNhc2VzID0gQHRlc3QubWFwIGRvIHxpdGVtfCBcImNhc2Uge2l0ZW0uY306XCJcblx0XHRjYXNlcy5qb2luKFwiXFxuXCIpICsgYm9keS5jKGluZGVudDogeWVzKSAjIC5pbmRlbnRcblxuXG5cbmV4cG9ydCBjbGFzcyBUcnkgPCBDb250cm9sRmxvd1N0YXRlbWVudFxuXG5cblx0cHJvcCBib2R5XG5cdCMgcHJvcCBuY2F0Y2hcblx0IyBwcm9wIG5maW5hbGx5XG5cblx0ZGVmIGluaXRpYWxpemUgYm9keSwgYywgZlxuXHRcdEB0cmF2ZXJzZWQgPSBub1xuXHRcdEBib2R5ID0gYmxrX18oYm9keSlcblx0XHRAY2F0Y2ggPSBjXG5cdFx0QGZpbmFsbHkgPSBmXG5cblxuXHRkZWYgY29uc3VtZSBub2RlXG5cdFx0QGJvZHkgPSBAYm9keS5jb25zdW1lKG5vZGUpXG5cdFx0QGNhdGNoID0gQGNhdGNoLmNvbnN1bWUobm9kZSkgaWYgQGNhdGNoXG5cdFx0QGZpbmFsbHkgPSBAZmluYWxseS5jb25zdW1lKG5vZGUpIGlmIEBmaW5hbGx5XG5cdFx0c2VsZlxuXG5cblx0ZGVmIHZpc2l0XG5cdFx0QGJvZHkudHJhdmVyc2Vcblx0XHRAY2F0Y2gudHJhdmVyc2UgaWYgQGNhdGNoXG5cdFx0QGZpbmFsbHkudHJhdmVyc2UgaWYgQGZpbmFsbHlcblx0XHQjIG5vIGJsb2NrcyAtIGFkZCBhbiBlbXB0eSBjYXRjaFxuXG5cblx0ZGVmIGpzIG9cblx0XHR2YXIgb3V0ID0gXCJ0cnkgXCIgKyBib2R5LmMoYnJhY2VzOiB5ZXMsIGluZGVudDogeWVzKVxuXHRcdG91dCArPSBcIiBcIiArIEBjYXRjaC5jIGlmIEBjYXRjaFxuXHRcdG91dCArPSBcIiBcIiArIEBmaW5hbGx5LmMgaWYgQGZpbmFsbHlcblxuXHRcdHVubGVzcyBAY2F0Y2ggb3IgQGZpbmFsbHlcblx0XHRcdG91dCArPSBcIiBjYXRjaCAoZSkgXFx7IFxcfVwiXG5cdFx0b3V0ICs9IFwiO1wiXG5cdFx0b3V0XG5cblxuXG5leHBvcnQgY2xhc3MgQ2F0Y2ggPCBDb250cm9sRmxvd1N0YXRlbWVudFxuXHRcblx0cHJvcCBib2R5XG5cblx0ZGVmIGluaXRpYWxpemUgYm9keSwgdmFybmFtZVxuXHRcdEB0cmF2ZXJzZWQgPSBub1xuXHRcdEBib2R5ID0gYmxrX18oYm9keSBvciBbXSlcblx0XHRAc2NvcGUgPSBDYXRjaFNjb3BlLm5ldyhzZWxmKVxuXHRcdEB2YXJuYW1lID0gdmFybmFtZVxuXHRcdHNlbGZcblxuXHRkZWYgY29uc3VtZSBub2RlXG5cdFx0QGJvZHkgPSBAYm9keS5jb25zdW1lKG5vZGUpXG5cdFx0c2VsZlxuXG5cblx0ZGVmIHZpc2l0XG5cdFx0QHNjb3BlLnZpc2l0XG5cdFx0QHZhcmlhYmxlID0gQHNjb3BlLnJlZ2lzdGVyKEB2YXJuYW1lLHNlbGYscG9vbDogJ2NhdGNodmFyJylcblx0XHRAYm9keS50cmF2ZXJzZVxuXG5cblx0ZGVmIGpzIG9cblx0XHQjIG9ubHkgaW5kZW50IGlmIGluZGVudGVkIGJ5IGRlZmF1bHQ/XG5cdFx0XCJjYXRjaCAoe0B2YXJpYWJsZS5jfSkgXCIgKyBAYm9keS5jKGJyYWNlczogeWVzLCBpbmRlbnQ6IHllcylcblxuXG4jIHJlcGVhdGluZyBteXNlbGYuLiBkb24ndCBkZWFsIHdpdGggaXQgdW50aWwgd2UgbW92ZSB0byBjb21wYWN0IHR1cGxlLWFyZ3NcbiMgZm9yIGFsbCBhc3Rub2Rlc1xuXG5cbmV4cG9ydCBjbGFzcyBGaW5hbGx5IDwgQ29udHJvbEZsb3dTdGF0ZW1lbnRcblxuXHRkZWYgaW5pdGlhbGl6ZSBib2R5XG5cdFx0QHRyYXZlcnNlZCA9IG5vXG5cdFx0QGJvZHkgPSBibGtfXyhib2R5IG9yIFtdKVxuXG5cblx0ZGVmIHZpc2l0XG5cdFx0QGJvZHkudHJhdmVyc2VcblxuXG5cdGRlZiBjb25zdW1lIG5vZGVcblx0XHQjIHN3YWxsb3cgc2lsZW50bHlcblx0XHRzZWxmXG5cblxuXHRkZWYganMgb1xuXHRcdFwiZmluYWxseSBcIiArIEBib2R5LmMoYnJhY2VzOiB5ZXMsIGluZGVudDogeWVzKVxuXG5cbiMgUkFOR0VcblxuZXhwb3J0IGNsYXNzIFJhbmdlIDwgT3BcblxuXHRkZWYgaW5jbHVzaXZlXG5cdFx0b3AgPT0gJy4uJ1xuXHRcdFxuXHRkZWYgY1xuXHRcdFwicmFuZ2VcIlxuXG5cbmV4cG9ydCBjbGFzcyBTcGxhdCA8IFZhbHVlTm9kZVxuXG5cdGRlZiBqcyBvXG5cdFx0dmFyIHBhciA9IHN0YWNrLnBhcmVudFxuXHRcdGlmIHBhciBpc2EgQXJnTGlzdCBvciBwYXIgaXNhIEFyclxuXHRcdFx0XCJbXS5zbGljZS5jYWxsKHt2YWx1ZS5jfSlcIlxuXHRcdGVsc2Vcblx0XHRcdHAgXCJ3aGF0IGlzIHRoZSBwYXJlbnQ/IHtwYXJ9XCJcblx0XHRcdFwiU1BMQVRcIlxuXG5cdGRlZiBub2RlXG5cdFx0dmFsdWVcblxuXG5cblxuXG4jIFRBR1NcblxuXG5UQUdfVFlQRVMgPSB7fVxuVEFHX0FUVFJTID0ge31cblxuXG5UQUdfVFlQRVMuSFRNTCA9IFwiYSBhYmJyIGFkZHJlc3MgYXJlYSBhcnRpY2xlIGFzaWRlIGF1ZGlvIGIgYmFzZSBiZGkgYmRvIGJpZyBibG9ja3F1b3RlIGJvZHkgYnIgXG5idXR0b24gY2FudmFzIGNhcHRpb24gY2l0ZSBjb2RlIGNvbCBjb2xncm91cCBkYXRhIGRhdGFsaXN0IGRkIGRlbCBkZXRhaWxzIGRmbiBcbmRpdiBkbCBkdCBlbSBlbWJlZCBmaWVsZHNldCBmaWdjYXB0aW9uIGZpZ3VyZSBmb290ZXIgZm9ybSBoMSBoMiBoMyBoNCBoNSBoNiBcbmhlYWQgaGVhZGVyIGhyIGh0bWwgaSBpZnJhbWUgaW1nIGlucHV0IGlucyBrYmQga2V5Z2VuIGxhYmVsIGxlZ2VuZCBsaSBsaW5rIFxubWFpbiBtYXAgbWFyayBtZW51IG1lbnVpdGVtIG1ldGEgbWV0ZXIgbmF2IG5vc2NyaXB0IG9iamVjdCBvbCBvcHRncm91cCBvcHRpb24gXG5vdXRwdXQgcCBwYXJhbSBwcmUgcHJvZ3Jlc3MgcSBycCBydCBydWJ5IHMgc2FtcCBzY3JpcHQgc2VjdGlvbiBzZWxlY3Qgc21hbGwgXG5zb3VyY2Ugc3BhbiBzdHJvbmcgc3R5bGUgc3ViIHN1bW1hcnkgc3VwIHRhYmxlIHRib2R5IHRkIHRleHRhcmVhIHRmb290IHRoIFxudGhlYWQgdGltZSB0aXRsZSB0ciB0cmFjayB1IHVsIHZhciB2aWRlbyB3YnJcIi5zcGxpdChcIiBcIilcblxuVEFHX1RZUEVTLlNWRyA9IFwiY2lyY2xlIGRlZnMgZWxsaXBzZSBnIGxpbmUgbGluZWFyR3JhZGllbnQgbWFzayBwYXRoIHBhdHRlcm4gcG9seWdvbiBwb2x5bGluZSBcbnJhZGlhbEdyYWRpZW50IHJlY3Qgc3RvcCBzdmcgdGV4dCB0c3BhblwiLnNwbGl0KFwiIFwiKVxuXG5UQUdfQVRUUlMuSFRNTCA9IFwiYWNjZXB0IGFjY2Vzc0tleSBhY3Rpb24gYWxsb3dGdWxsU2NyZWVuIGFsbG93VHJhbnNwYXJlbmN5IGFsdCBhc3luYyBcbmF1dG9Db21wbGV0ZSBhdXRvRm9jdXMgYXV0b1BsYXkgY2VsbFBhZGRpbmcgY2VsbFNwYWNpbmcgY2hhclNldCBjaGVja2VkIFxuY2xhc3NOYW1lIGNvbHMgY29sU3BhbiBjb250ZW50IGNvbnRlbnRFZGl0YWJsZSBjb250ZXh0TWVudSBjb250cm9scyBjb29yZHMgXG5jcm9zc09yaWdpbiBkYXRhIGRhdGVUaW1lIGRlZmVyIGRpciBkaXNhYmxlZCBkb3dubG9hZCBkcmFnZ2FibGUgZW5jVHlwZSBmb3JtIFxuZm9ybU5vVmFsaWRhdGUgZnJhbWVCb3JkZXIgaGVpZ2h0IGhpZGRlbiBocmVmIGhyZWZMYW5nIGh0bWxGb3IgaHR0cEVxdWl2IGljb24gXG5pZCBsYWJlbCBsYW5nIGxpc3QgbG9vcCBtYXggbWF4TGVuZ3RoIG1lZGlhR3JvdXAgbWV0aG9kIG1pbiBtdWx0aXBsZSBtdXRlZCBcbm5hbWUgbm9WYWxpZGF0ZSBwYXR0ZXJuIHBsYWNlaG9sZGVyIHBvc3RlciBwcmVsb2FkIHJhZGlvR3JvdXAgcmVhZE9ubHkgcmVsIFxucmVxdWlyZWQgcm9sZSByb3dzIHJvd1NwYW4gc2FuZGJveCBzY29wZSBzY3JvbGxMZWZ0IHNjcm9sbGluZyBzY3JvbGxUb3AgXG5zZWFtbGVzcyBzZWxlY3RlZCBzaGFwZSBzaXplIHNwYW4gc3BlbGxDaGVjayBzcmMgc3JjRG9jIHNyY1NldCBzdGFydCBzdGVwIFxuc3R5bGUgdGFiSW5kZXggdGFyZ2V0IHRpdGxlIHR5cGUgdXNlTWFwIHZhbHVlIHdpZHRoIHdtb2RlXCJcblxuVEFHX0FUVFJTLlNWRyA9IFwiY3ggY3kgZCBkeCBkeSBmaWxsIGZpbGxPcGFjaXR5IGZvbnRGYW1pbHkgZm9udFNpemUgZnggZnkgZ3JhZGllbnRUcmFuc2Zvcm0gXG5ncmFkaWVudFVuaXRzIG1hcmtlckVuZCBtYXJrZXJNaWQgbWFya2VyU3RhcnQgb2Zmc2V0IG9wYWNpdHkgXG5wYXR0ZXJuQ29udGVudFVuaXRzIHBhdHRlcm5Vbml0cyBwb2ludHMgcHJlc2VydmVBc3BlY3RSYXRpbyByIHJ4IHJ5IFxuc3ByZWFkTWV0aG9kIHN0b3BDb2xvciBzdG9wT3BhY2l0eSBzdHJva2Ugc3Ryb2tlRGFzaGFycmF5IHN0cm9rZUxpbmVjYXAgXG5zdHJva2VPcGFjaXR5IHN0cm9rZVdpZHRoIHRleHRBbmNob3IgdHJhbnNmb3JtIHZlcnNpb24gdmlld0JveCB4MSB4MiB4IHkxIHkyIHlcIlxuXG5cbmV4cG9ydCBjbGFzcyBUYWdEZXNjIDwgTm9kZVxuXG5cdGRlZiBpbml0aWFsaXplXG5cdFx0cCAnVGFnRGVzYyEhIScsJDBcblx0XHRzZWxmXG5cblx0ZGVmIGNsYXNzZXNcblx0XHRwICdUYWdEZXNjQ2xhc3NlcycsJDBcblx0XHRzZWxmXG5cbmV4cG9ydCBjbGFzcyBUYWcgPCBOb2RlXG5cblx0cHJvcCBwYXJ0c1xuXHRwcm9wIG9iamVjdFxuXHRwcm9wIHJlYWN0aXZlXG5cdHByb3AgcGFyZW50XG5cdHByb3AgdHJlZVxuXG5cdGRlZiBpbml0aWFsaXplIG8gPSB7fVxuXHRcdEB0cmF2ZXJzZWQgPSBub1xuXHRcdEBwYXJ0cyA9IFtdXG5cdFx0bzpjbGFzc2VzIHx8PSBbXVxuXHRcdG86YXR0cmlidXRlcyB8fD0gW11cblx0XHRvOmNsYXNzZXMgfHw9IFtdXG5cdFx0QG9wdGlvbnMgPSBvXG5cdFx0QHJlZmVyZW5jZSA9IG51bGxcblx0XHRAb2JqZWN0ID0gbnVsbFxuXHRcdEB0cmVlID0gbnVsbFxuXHRcdHNlbGZcblxuXHRkZWYgc2V0IG9ialxuXHRcdGZvciBvd24gayx2IG9mIG9ialxuXHRcdFx0aWYgayA9PSAnYXR0cmlidXRlcydcblx0XHRcdFx0IyBwIFwiYXR0cmlidXRzIVwiXG5cdFx0XHRcdGFkZEF0dHJpYnV0ZShhdHIpIGZvciBhdHIgaW4gdlxuXHRcdFx0XHRjb250aW51ZVxuXG5cdFx0XHRAb3B0aW9uc1trXSA9IHZcblx0XHRzZWxmXG5cblx0ZGVmIGFkZENsYXNzIG5vZGVcblx0XHR1bmxlc3Mgbm9kZSBpc2EgVGFnRmxhZ1xuXHRcdFx0bm9kZSA9IFRhZ0ZsYWcubmV3KG5vZGUpXG5cdFx0QG9wdGlvbnM6Y2xhc3Nlcy5wdXNoKG5vZGUpXG5cdFx0QHBhcnRzLnB1c2gobm9kZSlcblxuXHRcdCMgcCBcImFkZCBjbGFzcyEhIVwiXG5cdFx0c2VsZlxuXG5cdGRlZiBhZGRJbmRleCBub2RlXG5cdFx0QHBhcnRzLnB1c2gobm9kZSlcblx0XHRAb2JqZWN0ID0gbm9kZVxuXHRcdHNlbGZcblxuXHRkZWYgYWRkU3ltYm9sIG5vZGVcblx0XHQjIHAgXCJhZGRTeW1ib2wgdG8gdGhlIHRhZ1wiLG5vZGVcblx0XHRpZiBAcGFydHM6bGVuZ3RoID09IDBcblx0XHRcdEBwYXJ0cy5wdXNoKG5vZGUpXG5cdFx0XHRAb3B0aW9uczpucyA9IG5vZGVcblx0XHRzZWxmXG5cdFx0XG5cblx0ZGVmIGFkZEF0dHJpYnV0ZSBhdHJcblx0XHQjIHAgXCJhZGQgYXR0cmlidXRlISEhXCIsIGtleSwgdmFsdWVcblx0XHRAcGFydHMucHVzaChhdHIpICMgd2hhdD9cblx0XHRAb3B0aW9uczphdHRyaWJ1dGVzLnB1c2goYXRyKVxuXHRcdHNlbGZcblxuXHRkZWYgZW5jbG9zaW5nXG5cdFx0KEBvcHRpb25zOmNsb3NlIGFuZCBAb3B0aW9uczpjbG9zZS52YWx1ZSlcblxuXHRkZWYgdHlwZVxuXHRcdEBvcHRpb25zOnR5cGUgfHwgOmRpdlxuXG5cdGRlZiBjb25zdW1lIG5vZGVcblx0XHR2YXIgbyA9IEBvcHRpb25zXG5cblxuXHRcdGlmIG5vZGUgaXNhIFRhZ1RyZWVcblx0XHRcdCMgcCBcInRhZyBjb25zdW1lIHRhZ3RyZWU/IHtub2RlLnJlYWN0aXZlfVwiXG5cdFx0XHRwYXJlbnQgPSBub2RlLnJvb3Rcblx0XHRcdCMgbzp0cmVlUmVmID0gbm9kZS5uZXh0Q2FjaGVLZXlcblxuXHRcdFx0aWYgbm9kZS5AbG9vcFxuXHRcdFx0XHQjIGFsd2F0eXMgbWFrZSBpdGVtcyBpbiBsb29wIHJlYWN0aXZlXG5cdFx0XHRcdHJlYWN0aXZlID0gbm9kZS5yZWFjdGl2ZSBvciBvcHRpb24oOmtleSlcblx0XHRcdFx0b3B0aW9uKDpsb29wLG5vZGUuQGxvb3ApXG5cblx0XHRcdFx0aWYgb3B0aW9uKDppdmFyKVxuXHRcdFx0XHRcdHdhcm4gXCJUYWcgaW5zaWRlIGxvb3AgY2FuIG5vdCBoYXZlIGEgc3RhdGljIHJlZmVyZW5jZSB7b3B0aW9uKDppdmFyKX1cIiwgdHlwZTogJ2Vycm9yJywgdG9rZW46IG9wdGlvbig6aXZhcikudmFsdWVcblxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRyZWFjdGl2ZSA9IG5vZGUucmVhY3RpdmUgb3IgISFvcHRpb24oOml2YXIpXG5cdFx0XHRcblx0XHRcdHJldHVybiBzZWxmXG5cblx0XHRzdXBlclxuXG5cblx0ZGVmIHZpc2l0XG5cblx0XHR2YXIgbyA9IEBvcHRpb25zXG5cblx0XHRpZiBvOml2YXIgb3IgbzprZXlcblx0XHRcdHJlYWN0aXZlID0geWVzXG5cblx0XHR2YXIgdHlwID0gZW5jbG9zaW5nXG5cblx0XHQjIGxvb2sgZm9yIG91dGVyIHRhZyBoZXJlP1xuXG5cdFx0aWYgdHlwID09ICctPicgb3IgdHlwID09ICc9Pidcblx0XHRcdCMgY29uc29sZS5sb2cgXCJ0YWcgaXMgdGVtcGxhdGU/IT8ge3R5cH1cIlxuXHRcdFx0QHRyZWUgPSBUYWdUcmVlLm5ldyhzZWxmLG86Ym9keSwgcm9vdDogc2VsZiwgcmVhY3RpdmU6IHJlYWN0aXZlKVxuXHRcdFx0bzpib2R5ID0gVGFnRnJhZ21lbnRGdW5jLm5ldyhbXSxCbG9jay53cmFwKFtAdHJlZV0pKVxuXHRcdFx0IyBjb25zb2xlLmxvZyBcIm1hZGUgbyBib2R5IGEgZnVuY3Rpb24/XCJcblxuXHRcdG86a2V5LnRyYXZlcnNlIGlmIG86a2V5XG5cblx0XHRpZiBvOmJvZHlcblx0XHRcdG86Ym9keS50cmF2ZXJzZVxuXG5cdFx0IyBpZCBzaG91bGQgYWxzbyBiZSBhIHJlZ3VsYXIgcGFydFxuXHRcblx0XHRvOmlkLnRyYXZlcnNlIGlmIG86aWRcblx0XHRcblxuXHRcdGZvciBwYXJ0IGluIEBwYXJ0c1xuXHRcdFx0cGFydC50cmF2ZXJzZVxuXG5cdFx0IyBmb3IgYXRyIGluIEBvcHRpb25zOmF0dHJpYnV0ZXNcblx0XHQjIFx0YXRyLnRyYXZlcnNlXG5cblx0XHRzZWxmXG5cblx0ZGVmIHJlZmVyZW5jZVxuXHRcdEByZWZlcmVuY2UgfHw9IHNjb3BlX18uY2xvc3VyZS50ZW1wb3Jhcnkoc2VsZixwb29sOiAndGFnJykucmVzb2x2ZVxuXG5cdCMgc2hvdWxkIHRoaXMgbm90IGhhcHBlbiBpbiBqcz9cblx0IyBzaG91bGQgdGhpcyBub3QgaGFwcGVuIGluIGpzP1xuXHRkZWYganMgb1xuXHRcdCMgcCBKU09OLnN0cmluZ2lmeShAb3B0aW9ucylcblx0XHQjIHZhciBhdHRycyA9IFRhZ0F0dHJpYnV0ZXMubmV3KG86YXR0cmlidXRlcylcblx0XHQjIHAgXCJnb3QgaGVyZT9cIlxuXHRcdHZhciBvID0gQG9wdGlvbnNcblx0XHR2YXIgYSA9IHt9XG5cdFx0dmFyIGVuYyA9IGVuY2xvc2luZ1xuXG5cdFx0dmFyIHNldHVwID0gW11cblx0XHR2YXIgY2FsbHMgPSBbXVxuXHRcdHZhciBzdGF0aWNzID0gW11cblxuXHRcdHZhciBzY29wZSA9IHNjb3BlX19cblx0XHR2YXIgY29tbWl0ID0gXCJlbmRcIlxuXHRcdHZhciBjb250ZW50ID0gbzpib2R5XG5cblx0XHR2YXIgaXNTZWxmID0gdHlwZSBpc2EgU2VsZlxuXHRcdHZhciBib2R5U2V0dGVyID0gaXNTZWxmID8gXCJzZXRDaGlsZHJlblwiIDogXCJzZXRDb250ZW50XCJcblxuXHRcdCMgc2hvdWxkIG5vdCBjYWNoZSBzdGF0aWNzIGlmIHRoZSBub2RlIGl0c2VsZiBpcyBub3QgY2FjaGVkXG5cdFx0IyB0aGF0IHdvdWxkIG9ubHkgbWFuZ2xlIHRoZSBvcmRlciBpbiB3aGljaCB3ZSBzZXQgdGhlIHByb3BlcnRpZXNcblx0XHR2YXIgY2FjaGVTdGF0aWNzID0geWVzXG5cblx0XHRmb3IgYXRyIGluIG86YXR0cmlidXRlc1xuXHRcdFx0YVthdHIua2V5XSA9IGF0ci52YWx1ZSAjIC5wb3B1bGF0ZShvYmopXG5cblx0XHR2YXIgcXVvdGUgPSBkbyB8c3RyfCBoZWxwZXJzLnNpbmdsZXF1b3RlKHN0cilcblx0XHR2YXIgaWQgPSBvOmlkIGlzYSBOb2RlID8gbzppZC5jIDogKG86aWQgYW5kIHF1b3RlKG86aWQuYykpXG5cdFx0dmFyIHRyZWUgPSBAdHJlZSBvciBudWxsXG5cdFx0dmFyIHBhcmVudCA9IHNlbGYucGFyZW50XG5cdFx0IyB2YXIgcGFyVHJlZSA9IHBhcmVudCBhbmQgcGFyZW50LnRyZWVcblxuXG5cdFx0IyAgXCJzY29wZSBpc1wiLCAhIXNjb3BlXG5cdFx0IyBwIFwidHlwZSBpcyB7dHlwZX1cIlxuXHRcdHZhciBvdXQgPSBpZiBpc1NlbGZcblx0XHRcdGNvbW1pdCA9IFwic3luY2VkXCJcblx0XHRcdCMgcCBcImdvdCBoZXJlXCJcblx0XHRcdCMgc2V0dGluZyBjb3JyZWN0IGNvbnRleHQgZGlyZWN0bHlcblx0XHRcdHJlYWN0aXZlID0geWVzXG5cdFx0XHRAcmVmZXJlbmNlID0gc2NvcGUuY29udGV4dFxuXHRcdFx0c2NvcGUuY29udGV4dC5jXG5cdFx0ZWxzZVxuXHRcdFx0XCJ7bWFya19fKG86b3Blbil9e3Njb3BlLnRhZ0NvbnRleHRQYXRofS57dHlwZS5zcGF3bmVyfSgpXCJcblxuXHRcdGlmIG86aWRcblx0XHRcdHN0YXRpY3MucHVzaChcIi5zZXRJZCh7cXVvdGUobzppZCl9KVwiKVxuXHRcdCMgdGhpcyBpcyByZWFjdGl2ZSBpZiBpdCBoYXMgYW4gaXZhclxuXHRcdGlmIG86aXZhclxuXHRcdFx0cmVhY3RpdmUgPSB5ZXNcblx0XHRcdHN0YXRpY3MucHVzaChcIi5zZXRSZWYoe3F1b3RlKG86aXZhci5uYW1lKX0se3Njb3BlLmNvbnRleHQuY30pXCIpXG5cblx0XHRpZiBvOmJvZHkgaXNhIEZ1bmNcblx0XHRcdCMgY29uc29sZS5sb2cgXCJvOmJvZHkgaXNhIGZ1bmN0aW9uIVwiXG5cdFx0XHRib2R5U2V0dGVyID0gXCJzZXRUZW1wbGF0ZVwiXG5cblx0XHRlbGlmIG86Ym9keVxuXHRcdFx0aWYgbzpib2R5IGlzYSBBcmdMaXN0IGFuZCBvOmJvZHkuY291bnQgPT0gMSBhbmQgbzpib2R5LmZpcnN0LmlzU3RyaW5nXG5cdFx0XHRcdGJvZHlTZXR0ZXIgPSBcInNldFRleHRcIlxuXG5cdFx0XHRlbHNlXG5cdFx0XHRcdCMgd291bGQgcHJvYmFibHkgYmUgYmV0dGVyIHRvIGNvbnZlcnQgdG8gYSB0YWd0cmVlIGR1cmluZyB0aGUgaW5pdGlhbCB2aXNpdFxuXHRcdFx0XHR0cmVlID0gVGFnVHJlZS5uZXcoc2VsZiwgbzpib2R5LCByb290OiBzZWxmLCByZWFjdGl2ZTogcmVhY3RpdmUpXG5cdFx0XHRcdGNvbnRlbnQgPSB0cmVlXG5cdFx0XHRcdHNlbGYudHJlZSA9IHRyZWVcblxuXHRcdGlmIHRyZWVcblx0XHRcdCMgdGhpcyBpcyB0aGUgcG9pbnQgd2hlcmUgd2UgdHJhdmVyc2UgdGhlIGlubmVyIG5vZGVzIHdpdGggb3VyIHRyZWVcblx0XHRcdCMgc2hvdWxkIHJhdGhlciBoYXBwZW4gaW4gdmlzaXQgLSBsb25nIGJlZm9yZS5cblx0XHRcdHRyZWUucmVzb2x2ZVxuXG5cdFx0Zm9yIHBhcnQgaW4gQHBhcnRzXG5cdFx0XHR2YXIgcGpzXG5cdFx0XHR2YXIgcGNhY2hlID0gbm9cblxuXHRcdFx0aWYgcGFydCBpc2EgVGFnQXR0clxuXHRcdFx0XHR2YXIgYWtleSA9IFN0cmluZyhwYXJ0LmtleSlcblx0XHRcdFx0dmFyIGF2YWwgPSBwYXJ0LnZhbHVlXG5cdFx0XHRcdCMgcCBcInBhcnQgdmFsdWUge2F2YWx9IHthdmFsLmlzUHJpbWl0aXZlKHllcyl9XCJcblxuXHRcdFx0XHQjIHRoZSBhdHRyIHNob3VsZCBjb21waWxlIGl0c2VsZiBpbnN0ZWFkIC0tIHJlYWxseVxuXHRcdFx0XHRwY2FjaGUgPSBhdmFsLmlzUHJpbWl0aXZlXG5cblx0XHRcdFx0aWYgYWtleVswXSA9PSAnLicgIyBzaG91bGQgY2hlY2sgaW4gYSBiZXR0ZXIgd2F5XG5cdFx0XHRcdFx0cGNhY2hlID0gbm9cblx0XHRcdFx0XHRwanMgPSBcIi5mbGFnKHtxdW90ZShha2V5LnN1YnN0cigxKSl9LHthdmFsLmN9KVwiXG5cdFx0XHRcdGVsaWYgYWtleVswXSA9PSAnOidcblx0XHRcdFx0XHQjIG5lZWQgdG8gYW5hbHl6ZSB3aGV0aGVyIHRoaXMgaXMgc3RhdGljIG9yIG5vdFxuXHRcdFx0XHRcdHBqcyA9IFwiLnNldEhhbmRsZXIoe3F1b3RlKGFrZXkuc3Vic3RyKDEpKX0se2F2YWwuY30se3Njb3BlLmNvbnRleHQuY30pXCJcblx0XHRcdFx0ZWxpZiBha2V5LnN1YnN0cigwLDUpID09ICdkYXRhLSdcblx0XHRcdFx0XHRwanMgPSBcIi5kYXRhc2V0KCd7YWtleS5zbGljZSg1KX0nLHthdmFsLmN9KVwiXG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRwanMgPSBcIi57bWFya19fKHBhcnQua2V5KX17aGVscGVycy5zZXR0ZXJTeW0oYWtleSl9KHthdmFsLmN9KVwiXG5cblx0XHRcdGVsaWYgcGFydCBpc2EgVGFnRmxhZ1xuXHRcdFx0XHRwanMgPSBwYXJ0LmNcblx0XHRcdFx0cGNhY2hlID0geWVzXG5cblx0XHRcdGlmIHBqc1xuXHRcdFx0XHRjYWNoZVN0YXRpY3MgJiYgcGNhY2hlID8gc3RhdGljcy5wdXNoKHBqcykgOiBjYWxscy5wdXNoKHBqcylcblxuXG5cblx0XHRpZiBvYmplY3Rcblx0XHRcdGNhbGxzLnB1c2goXCIuc2V0T2JqZWN0KHtvYmplY3QuY30pXCIpXG5cblx0XHQjIHAgXCJ0YWd0cmVlIGlzIHN0YXRpYz8ge3RyZWUuc3RhdGljfVwiXG5cblx0XHQjIHdlIG5lZWQgdG8gdHJpZ2dlciBvdXIgb3duIHJlZmVyZW5jZSBiZWZvcmUgdGhlIGJvZHkgZG9lc1xuXHRcdCMgYnV0IHdlIGRvIG5vdCBuZWVkIGEgcmVmZXJlbmNlIGlmIHdlIGhhdmUgbm8gYm9keSAobm8gbm9kZXMgd2lsbCByZWZlciBpdClcblx0XHRpZiByZWFjdGl2ZSBhbmQgdHJlZSAjIGFuZCB0cmVlLmhhc1RhZ3Ncblx0XHRcdHJlZmVyZW5jZVxuXG5cdFx0aWYgcmVhY3RpdmUgYW5kIHBhcmVudCBhbmQgcGFyZW50LnRyZWVcblx0XHRcdG86dHJlZVJlZiA9IHBhcmVudC50cmVlLm5leHRDYWNoZUtleShzZWxmKVxuXG5cdFx0aWYgdmFyIGJvZHkgPSBjb250ZW50IGFuZCBjb250ZW50LmMoZXhwcmVzc2lvbjogeWVzKSAjIGZvcmNlIGl0IHRvIGJlIGFuIGV4cHJlc3Npb24sIG5vP1xuXHRcdFx0bGV0IHR5cCA9IDBcblxuXHRcdFx0aWYgdHJlZSBcblx0XHRcdFx0aWYgdHJlZS5zdGF0aWNcblx0XHRcdFx0XHR0eXAgPSAyXG5cdFx0XHRcdGVsaWYgcmVhY3RpdmUgb3IgdHJlZS5yZWFjdGl2ZVxuXHRcdFx0XHRcdGlmICF0cmVlLnNpbmdsZSBvciB0cmVlLnNpbmdsZSBpc2EgSWZcblx0XHRcdFx0XHRcdHR5cCA9IDFcblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHR0eXAgPSAzXG5cdFx0XHRcdFx0XHRcblxuXHRcdFx0aWYgYm9keVNldHRlciA9PSAnc2V0Q2hpbGRyZW4nIG9yIGJvZHlTZXR0ZXIgPT0gJ3NldENvbnRlbnQnXG5cdFx0XHRcdGNhbGxzLnB1c2ggXCIue2JvZHlTZXR0ZXJ9KHtib2R5fSx7dHlwfSlcIlxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRjYWxscy5wdXNoIFwiLntib2R5U2V0dGVyfSh7Ym9keX0pXCJcblxuXHRcdFx0IyBvdXQgKz0gXCIuYm9keSh7Ym9keX0pXCJcblxuXHRcdCMgaWYgbzphdHRyaWJ1dGVzOmxlbmd0aCAjIG9yIC0tIGFsd2F5cz9cblx0XHQjIGFkZHMgbG90cyBvZiBleHRyYSBjYWxscyAtIGJ1dCBva2F5IGZvciBub3dcblx0XHRjYWxscy5wdXNoIFwiLntjb21taXR9KClcIlxuXG5cdFx0aWYgc3RhdGljczpsZW5ndGhcblx0XHRcdG91dCA9IG91dCArIHN0YXRpY3Muam9pbihcIlwiKVxuXG5cdFxuXHRcdGlmIChvOml2YXIgb3IgbzprZXkgb3IgcmVhY3RpdmUpIGFuZCAhKHR5cGUgaXNhIFNlbGYpXG5cdFx0XHQjIGlmIHRoaXMgaXMgYW4gaXZhciwgd2Ugc2hvdWxkIHNldCB0aGUgcmVmZXJlbmNlIHJlbGF0aXZlXG5cdFx0XHQjIHRvIHRoZSBvdXRlciByZWZlcmVuY2UsIG9yIHBvc3NpYmx5IHJpZ2h0IG9uIGNvbnRleHQ/XG5cdFx0XHR2YXIgY3R4LCBrZXlcblx0XHRcdHZhciBwYXJ0cmVlID0gcGFyZW50IGFuZCBwYXJlbnQudHJlZVxuXHRcdFx0IyBjdHggPSAhbzppdmFyIGFuZCBwYXIgYW5kIHBhci5yZWZlcmVuY2Ugb3Igc2NvcGUuY29udGV4dFxuXHRcdFx0IyBrZXkgPSBvOml2YXIgb3IgdHJlZSBhbmQgdHJlZS5uZXh0Q2FjaGVLZXlcblxuXHRcdFx0aWYgbzprZXlcblx0XHRcdFx0IyBjbG9zZXN0IHRhZ1xuXHRcdFx0XHQjIFRPRE8gaWYgdGhlIGR5bmFtaWMga2V5IHN0YXJ0cyB3aXRoIGEgc3RhdGljIHN0cmluZyB3ZSBzaG91bGRcblx0XHRcdFx0IyBqdXN0IHByZXBlbmQgXyB0byB0aGUgc3RyaW5nIGluc3RlYWQgb2Ygd3JhcHBpbmcgaW4gT1Bcblx0XHRcdFx0Y3R4ID0gcGFyZW50IGFuZCBwYXJlbnQucmVmZXJlbmNlXG5cdFx0XHRcdGtleSA9IE9QKCcrJyxTdHIubmV3KFwiJ18nXCIpLG86a2V5KVxuXG5cdFx0XHRlbGlmIG86aXZhclxuXHRcdFx0XHRjdHggPSBzY29wZS5jb250ZXh0XG5cdFx0XHRcdGtleSA9IG86aXZhclxuXG5cdFx0XHRlbHNlXG5cdFx0XHRcdGN0eCA9IHBhcmVudCBhbmQgcGFyZW50LnJlZmVyZW5jZVxuXHRcdFx0XHQjIGN0eCA9IHBhcnRyZWUuY2FjaGVyXG5cdFx0XHRcdGtleSA9IG86dHJlZVJlZiBvciBwYXJ0cmVlIGFuZCBwYXJ0cmVlLm5leHRDYWNoZUtleVxuXHRcdFx0XHQjIGtleSA9IHRyZWUgYW5kIHRyZWUubmV4dENhY2hlS2V5XG5cdFx0XHRcdGlmIG86bG9vcFxuXHRcdFx0XHRcdGxldCBpZHggPSBvOmxvb3Aub3B0aW9uKDp2YXJzKVs6aW5kZXhdXG5cdFx0XHRcdFx0a2V5ID0gT1AoJysnLFwiJ1wiICsga2V5ICsgXCInXCIsaWR4KVxuXG5cblxuXHRcdFx0IyBuZWVkIHRoZSBjb250ZXh0IC0tIG1pZ2h0IGJlIGJldHRlciB0byByZXdyaXRlIGl0IGZvciByZWFsP1xuXHRcdFx0IyBwYXJzZSB0aGUgd2hvbGUgdGhpbmcgaW50byBjYWxscyBldGNcblx0XHRcdHZhciBhY2MgPSBPUCgnLicsY3R4LGtleSkuY1xuXG5cdFx0XHRpZiBAcmVmZXJlbmNlXG5cdFx0XHRcdG91dCA9IFwiKHtyZWZlcmVuY2UuY30gPSB7YWNjfT17YWNjfSB8fCB7b3V0fSlcIlxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRvdXQgPSBcIih7YWNjfSA9IHthY2N9IHx8IHtvdXR9KVwiXG5cblx0XHRyZXR1cm4gb3V0ICsgY2FsbHMuam9pbihcIlwiKVxuXG4jIFRoaXMgaXMgYSBoZWxwZXItbm9kZVxuIyBTaG91bGQgcHJvYmFibHkgdXNlIHRoZSBzYW1lIHR5cGUgb2YgbGlzdG5vZGUgZXZlcnl3aGVyZSAtIGFuZCBzaW1wbHkgZmxhZyB0aGUgdHlwZSBhcyBUYWdUcmVlIGluc3RlYWRcbmV4cG9ydCBjbGFzcyBUYWdUcmVlIDwgTGlzdE5vZGVcblx0XG5cdHByb3AgY291bnRlclxuXHRwcm9wIGNvbmRpdGlvbnNcblx0cHJvcCBibG9ja3Ncblx0cHJvcCBjYWNoZXJcblxuXHRkZWYgaW5pdGlhbGl6ZSBvd25lciwgbGlzdCwgb3B0aW9ucyA9IHt9XG5cdFx0QG93bmVyID0gb3duZXJcblx0XHRAbm9kZXMgPSBsb2FkKGxpc3QpXG5cdFx0QG9wdGlvbnMgPSBvcHRpb25zXG5cdFx0QGNvbmRpdGlvbnMgPSBbXVxuXHRcdEBibG9ja3MgPSBbc2VsZl1cblx0XHRAY291bnRlciA9IDBcblx0XHRzZWxmXG5cblx0ZGVmIHBhcmVudFxuXHRcdEBwYXJlbnQgfHw9IEBvd25lci5wYXJlbnRcblxuXHRkZWYgbmV4dENhY2hlS2V5XG5cdFx0dmFyIHJvb3QgPSBAb3duZXJcblxuXHRcdCMgaWYgd2Ugd2FudCB0byBjYWNoZSBldmVyeXRoaW5nIG9uIHJvb3Rcblx0XHR2YXIgbnVtID0gKytAY291bnRlclxuXHRcdHZhciBiYXNlID0gXCJBXCIuY2hhckNvZGVBdCgwKVxuXHRcdHZhciBzdHIgPSBcIlwiXG5cblx0XHR3aGlsZSB0cnVlXG5cdFx0XHRudW0gLT0gMVxuXHRcdFx0c3RyID0gU3RyaW5nLmZyb21DaGFyQ29kZShiYXNlICsgKG51bSAlIDI2KSkgKyBzdHJcblx0XHRcdG51bSA9IE1hdGguZmxvb3IobnVtIC8gMjYpXG5cdFx0XHRicmVhayB1bmxlc3MgbnVtID4gMFxuXG5cdFx0c3RyID0gKEBvd25lci50eXBlIGlzYSBTZWxmID8gXCIkXCIgOiBcIiQkXCIpICsgc3RyLnRvTG93ZXJDYXNlXG5cdFx0cmV0dXJuIHN0clxuXHRcdHJldHVybiBudW1cblxuXHRkZWYgbG9hZCBsaXN0XG5cdFx0aWYgbGlzdCBpc2EgTGlzdE5vZGVcblx0XHRcdCMgcCBcImlzIGEgbGlzdCBub2RlISEge2xpc3QuY291bnR9XCJcblx0XHRcdCMgd2Ugc3RpbGwgd2FudCB0aGUgaW5kZW50YXRpb24gaWYgd2UgYXJlIG5vdCBpbiBhIHRlbXBsYXRlXG5cdFx0XHQjIG9yLCByYXRoZXIgLSB3ZSB3YW50IHRoZSBibG9jayB0byBnZXQgdGhlIGluZGVudGF0aW9uIC0gbm90IHRoZSB0cmVlXG5cdFx0XHRAaW5kZW50YXRpb24gfHw9IGxpc3QuQGluZGVudGF0aW9uICMgaWYgbGlzdC5jb3VudCA+IDFcblx0XHRcdGxpc3Qubm9kZXNcblx0XHRlbHNlXG5cdFx0XHRjb21wYWN0X18obGlzdCBpc2EgQXJyYXkgPyBsaXN0IDogW2xpc3RdKVxuXG5cdGRlZiByb290XG5cdFx0b3B0aW9uKDpyb290KVxuXG5cdGRlZiByZWFjdGl2ZVxuXHRcdG9wdGlvbig6cmVhY3RpdmUpXG5cblx0ZGVmIHJlc29sdmVcblx0XHRyZW1hcCBkbyB8Y3wgYy5jb25zdW1lKHNlbGYpXG5cdFx0c2VsZlxuXG5cdGRlZiBzdGF0aWNcblx0XHQjIGV2ZXJ5IHJlYWwgbm9kZVxuXHRcdEBzdGF0aWMgPz0gZXZlcnkgZG8gfGN8IChjIGlzYSBUYWcgb3IgYyBpc2EgU3RyIG9yIGMgaXNhIE1ldGEpXG5cblx0ZGVmIHNpbmdsZVxuXHRcdEBzaW5nbGUgPz0gKHJlYWxDb3VudCA9PSAxID8gbGFzdCA6IG5vKVxuXG5cdGRlZiBoYXNUYWdzXG5cdFx0c29tZSBkbyB8Y3wgYyBpc2EgVGFnXG5cblx0ZGVmIGMgb1xuXHRcdCMgRklYTUUgVEVTVCB3aGF0IGFib3V0IGNvbW1lbnRzPz8/XG5cdFx0dmFyIHNpbmdsZSA9IHNpbmdsZVxuXG5cdFx0IyBubyBpbmRlbnRhdGlvbiBpZiB0aGlzIHNob3VsZCByZXR1cm5cblx0XHRpZiBzaW5nbGUgYW5kIFNUQUNLLmN1cnJlbnQgaXNhIFJldHVyblxuXHRcdFx0QGluZGVudGF0aW9uID0gbnVsbFxuXG5cdFx0dmFyIG91dCA9IHN1cGVyKG8pXG5cblx0XHRpZiAhc2luZ2xlIG9yIHNpbmdsZSBpc2EgSWZcblx0XHRcdFwiW3tvdXR9XVwiXG5cdFx0ZWxzZVxuXHRcdFx0b3V0XG5cbmV4cG9ydCBjbGFzcyBUYWdXcmFwcGVyIDwgVmFsdWVOb2RlXG5cblx0ZGVmIHZpc2l0XG5cdFx0aWYgdmFsdWUgaXNhIEFycmF5XG5cdFx0XHR2YWx1ZS5tYXAofHZ8IHYudHJhdmVyc2UpXG5cdFx0ZWxzZVxuXHRcdFx0dmFsdWUudHJhdmVyc2Vcblx0XHRzZWxmXG5cdFx0XG5cdGRlZiBjXG5cdFx0XCJ0YWckd3JhcCh7dmFsdWUuYyhleHByZXNzaW9uOiB5ZXMpfSlcIlxuXG5cbmV4cG9ydCBjbGFzcyBUYWdBdHRyaWJ1dGVzIDwgTGlzdE5vZGVcblxuXHRkZWYgZ2V0IG5hbWVcblx0XHRmb3Igbm9kZSBpbiBub2Rlc1xuXHRcdFx0cmV0dXJuIG5vZGUgaWYgbm9kZS5rZXkgPT0gbmFtZVxuXHRcdFxuXHRcdFxuZXhwb3J0IGNsYXNzIFRhZ0F0dHIgPCBOb2RlXG5cblx0cHJvcCBrZXlcblx0cHJvcCB2YWx1ZVxuXG5cdGRlZiB2aXNpdFxuXHRcdHZhbHVlLnRyYXZlcnNlIGlmIHZhbHVlXG5cdFx0c2VsZlxuXG5cdGRlZiBpbml0aWFsaXplIGssIHZcblx0XHQjIHAgXCJpbml0IFRhZ0F0dHJpYnV0ZVwiLCAkMFxuXHRcdEB0cmF2ZXJzZWQgPSBub1xuXHRcdEBrZXkgPSBrXG5cdFx0QHZhbHVlID0gdlxuXG5cdGRlZiBwb3B1bGF0ZSBvYmpcblx0XHRvYmouYWRkKGtleSwgdmFsdWUpXG5cdFx0c2VsZlxuXG5cdGRlZiBjXG5cdFx0XCJhdHRyaWJ1dGVcIlxuXG5cbmV4cG9ydCBjbGFzcyBUYWdGbGFnIDwgTm9kZVxuXG5cdHByb3AgdmFsdWVcblx0cHJvcCB0b2dnbGVyXG5cblx0ZGVmIGluaXRpYWxpemUgdmFsdWVcblx0XHRAdHJhdmVyc2VkID0gbm9cblx0XHRAdmFsdWUgPSB2YWx1ZVxuXHRcdHNlbGZcblxuXHRkZWYgdmlzaXRcblx0XHR1bmxlc3MgQHZhbHVlIGlzYSBTdHJpbmdcblx0XHRcdEB2YWx1ZS50cmF2ZXJzZVxuXHRcdHNlbGZcblxuXHRkZWYgY1xuXHRcdGlmIHZhbHVlIGlzYSBOb2RlXG5cdFx0XHRcIi5mbGFnKHt2YWx1ZS5jfSlcIlxuXHRcdGVsc2Vcblx0XHRcdFwiLmZsYWcoe2hlbHBlcnMuc2luZ2xlcXVvdGUodmFsdWUpfSlcIlxuXHRcdFxuXHRcdFxuXG5cblxuXG4jIFNFTEVDVE9SU1xuXG5cbmV4cG9ydCBjbGFzcyBTZWxlY3RvciA8IExpc3ROb2RlXG5cdFxuXHRkZWYgaW5pdGlhbGl6ZSBsaXN0LCBvcHRpb25zXG5cdFx0QG5vZGVzID0gbGlzdCBvciBbXVxuXHRcdEBvcHRpb25zID0gb3B0aW9uc1xuXHRcdFxuXHRkZWYgYWRkIHBhcnQsIHR5cFxuXHRcdCMgcCBcInNlbGVjdCBhZGQhXCIscGFydCx0eXBcblx0XHQjIG1hcmsgaWYgc3BlY2lhbD9cblx0XHRwdXNoKHBhcnQpXG5cdFx0c2VsZlxuXG5cdGRlZiBncm91cFxuXHRcdCMgY29uc29sZS5sb2cgXCJncm91cGVkIVwiXG5cdFx0IyBmb3Igbm93IHdlIHNpbXBseSBhZGQgYSBjb21tYVxuXHRcdCMgaG93IHdvdWxkIHRoaXMgd29yayBmb3IgZHN0P1xuXHRcdEBub2Rlcy5wdXNoKFNlbGVjdG9yR3JvdXAubmV3KFwiLFwiKSlcblx0XHRzZWxmXG5cblx0ZGVmIHF1ZXJ5XG5cdFx0dmFyIHN0ciA9IFwiXCJcblx0XHR2YXIgYXJ5ID0gW11cblxuXHRcdGZvciBpdGVtIGluIG5vZGVzXG5cdFx0XHR2YXIgdmFsID0gaXRlbS5jXG5cdFx0XHRpZiB2YWwgaXNhIFN0cmluZ1xuXHRcdFx0XHRzdHIgPSBcIntzdHJ9e3ZhbH1cIlxuXG5cdFx0XCIne3N0cn0nXCJcblxuXG5cdGRlZiBqcyBvXG5cdFx0dmFyIHR5cCA9IG9wdGlvbig6dHlwZSlcblx0XHR2YXIgcSA9IGNfXyhxdWVyeSlcblxuXHRcdGlmIHR5cCA9PSAnJSdcblx0XHRcdFwicSQoe3F9LHtvLnNjb3BlLmNvbnRleHQuYyhleHBsaWNpdDogeWVzKX0pXCIgIyBleHBsaWNpdCBjb250ZXh0XG5cdFx0ZWxpZiB0eXAgPT0gJyUlJ1xuXHRcdFx0XCJxJCQoe3F9LHtvLnNjb3BlLmNvbnRleHQuYyhleHBsaWNpdDogeWVzKX0pXCJcblx0XHRlbHNlIFxuXHRcdFx0XCJxe3R5cH0oe3F9KVwiXG5cblx0XHQjIHJldHVybiBcInt0eXB9IHtzY29wZWR9IC0ge2FsbH1cIlxuXHRcdFxuXG5leHBvcnQgY2xhc3MgU2VsZWN0b3JQYXJ0IDwgVmFsdWVOb2RlXG5cblx0ZGVmIGNcblx0XHRjX18oQHZhbHVlKVxuXHRcdCMgXCJ7dmFsdWUuY31cIlxuXG5leHBvcnQgY2xhc3MgU2VsZWN0b3JHcm91cCA8IFNlbGVjdG9yUGFydFxuXG5cdGRlZiBjXG5cdFx0XCIsXCJcblxuZXhwb3J0IGNsYXNzIFNlbGVjdG9yVHlwZSA8IFNlbGVjdG9yUGFydFxuXG5cdGRlZiBjXG5cdFx0IyBzdXBwb3J0XG5cdFx0IyBwIFwic2VsZWN0b3J0eXBlIHt2YWx1ZX1cIlxuXHRcdCMgdmFyIG91dCA9IHZhbHVlLmNcblx0XHR2YXIgbmFtZSA9IHZhbHVlLm5hbWVcblx0XG5cdFx0IyBhdCBsZWFzdCBiZSB2ZXJ5IGNvbnNlcnZhdGl2ZSBhYm91dCB3aGljaCB0YWdzIHdlXG5cdFx0IyBjYW4gZHJvcCB0aGUgdGFnIGZvcj9cblx0XHQjIG91dCBpbiBUQUdfVFlQRVMuSFRNTCA/IFxuXHRcdG5hbWUgaW4gVEFHX1RZUEVTLkhUTUwgPyBuYW1lIDogdmFsdWUuc2VsXG5cblxuZXhwb3J0IGNsYXNzIFNlbGVjdG9yVW5pdmVyc2FsIDwgU2VsZWN0b3JQYXJ0XG5cbmV4cG9ydCBjbGFzcyBTZWxlY3Rvck5hbWVzcGFjZSA8IFNlbGVjdG9yUGFydFxuXG5leHBvcnQgY2xhc3MgU2VsZWN0b3JDbGFzcyA8IFNlbGVjdG9yUGFydFxuXG5cdGRlZiBjXG5cdFx0aWYgQHZhbHVlIGlzYSBOb2RlXG5cdFx0XHRcIi4nK3tAdmFsdWUuY30rJ1wiXG5cdFx0ZWxzZVxuXHRcdFx0XCIue2NfXyhAdmFsdWUpfVwiXG5cbmV4cG9ydCBjbGFzcyBTZWxlY3RvcklkIDwgU2VsZWN0b3JQYXJ0XG5cblx0ZGVmIGNcblx0XHRpZiBAdmFsdWUgaXNhIE5vZGVcblx0XHRcdFwiIycre0B2YWx1ZS5jfSsnXCJcblx0XHRlbHNlXG5cdFx0XHRcIiN7Y19fKEB2YWx1ZSl9XCJcblxuZXhwb3J0IGNsYXNzIFNlbGVjdG9yQ29tYmluYXRvciA8IFNlbGVjdG9yUGFydFxuXG5cdGRlZiBjXG5cdFx0XCJ7Y19fKEB2YWx1ZSl9XCJcblxuZXhwb3J0IGNsYXNzIFNlbGVjdG9yUHNldWRvQ2xhc3MgPCBTZWxlY3RvclBhcnRcblxuZXhwb3J0IGNsYXNzIFNlbGVjdG9yQXR0cmlidXRlIDwgU2VsZWN0b3JQYXJ0XG5cblx0IyByZW1lbWJlciB0byB2aXNpdCBub2RlcyBpbnNpZGUgaGVyZT9cblx0ZGVmIGluaXRpYWxpemUgbGVmdCxvcCxyaWdodFxuXHRcdEBsZWZ0ID0gbGVmdFxuXHRcdEBvcCA9IG9wXG5cdFx0QHJpZ2h0ID0gQHZhbHVlID0gcmlnaHRcblxuXHRkZWYgY1xuXHRcdCMgVE9ETyBwb3NzaWJseSBzdXBwb3J0IC50b1NlbCBvciBzZWwkKHYpIGZvciBpdGVtcyBpbnNpZGUgcXVlcnlcblx0XHQjIGNvdWxkIGVhc2lseSBkbyBpdCB3aXRoIGEgaGVscGVyLWZ1bmN0aW9uIHRoYXQgaXMgYWRkZWQgdG8gdGhlIHRvcCBvZiB0aGUgZmlsZXNjb3BlXG5cdFx0aWYgQHJpZ2h0IGlzYSBTdHJcblx0XHRcdFwiW3tAbGVmdC5jfXtAb3B9e0ByaWdodC5jfV1cIlxuXHRcdGVsaWYgQHJpZ2h0XG5cdFx0XHQjIHRoaXMgaXMgbm90IGF0IGFsbCBnb29kXG5cdFx0XHRcIlt7QGxlZnQuY317QG9wfVxcXCInK3tjX18oQHJpZ2h0KX0rJ1xcXCJdXCJcblx0XHRlbHNlXG5cdFx0XHRcIlt7QGxlZnQuY31dXCJcblx0XHRcblx0XHRcdCMgLi4uXG5cdFx0XG5cblxuXG4jIERFRkVSXG5cbmV4cG9ydCBjbGFzcyBBd2FpdCA8IFZhbHVlTm9kZVxuXG5cdHByb3AgZnVuY1xuXG5cdGRlZiBqcyBvXG5cdFx0IyBpbnRyb2R1Y2UgYSB1dGlsIGhlcmUsIG5vP1xuXHRcdENBTEwoT1AoJy4nLFV0aWwuUHJvbWlzaWZ5Lm5ldyhbdmFsdWVdKSwndGhlbicpLFtmdW5jXSkuY1xuXHRcdCMgdmFsdWUuY1xuXHRcblx0ZGVmIHZpc2l0IG9cblx0XHQjIHRoaW5ncyBhcmUgbm93IHRyYXZlcnNlZCBpbiBhIHNvbWV3aGF0IGNoYW90aWMgb3JkZXIuIE5lZWQgdG8gdGlnaHRlblxuXHRcdCMgQ3JlYXRlIGF3YWl0IGZ1bmN0aW9uIC0gcHVzaCB0aGlzIHZhbHVlIHVwIHRvIGJsb2NrLCB0YWtlIHRoZSBvdXRlclxuXHRcdHZhbHVlLnRyYXZlcnNlXG5cblx0XHR2YXIgYmxvY2sgPSBvLnVwKEJsb2NrKSAjIG9yIHVwIHRvIHRoZSBjbG9zZXN0IEZVTkNUSU9OP1xuXHRcdHZhciBvdXRlciA9IG8ucmVsYXRpdmUoYmxvY2ssMSlcblx0XHR2YXIgcGFyID0gby5yZWxhdGl2ZShzZWxmLC0xKVxuXG5cdFx0IyBwIFwiQmxvY2sge2Jsb2NrfSB7b3V0ZXJ9IHtwYXJ9XCJcblxuXHRcdGZ1bmMgPSBBc3luY0Z1bmMubmV3KFtdLFtdKVxuXHRcdCMgbm93IHdlIG1vdmUgdGhpcyBub2RlIHVwIHRvIHRoZSBibG9ja1xuXHRcdGZ1bmMuYm9keS5ub2RlcyA9IGJsb2NrLmRlZmVycyhvdXRlcixzZWxmKVxuXG5cdFx0IyBpZiB0aGUgb3V0ZXIgaXMgYSB2YXItYXNzaWdubWVudCwgd2UgY2FuIHNpbXBseSBzZXQgdGhlIHBhcmFtc1xuXHRcdGlmIHBhciBpc2EgQXNzaWduXG5cdFx0XHRwYXIubGVmdC50cmF2ZXJzZVxuXHRcdFx0dmFyIGxmdCA9IHBhci5sZWZ0Lm5vZGVcblx0XHRcdCMgcCBcIkFzeW5jIGFzc2lnbm1lbnQge3Bhcn0ge2xmdH1cIlxuXHRcdFx0IyBDYW4gYmUgYSB0dXBsZSBhcyB3ZWxsLCBubz9cblx0XHRcdGlmIGxmdCBpc2EgVmFyUmVmZXJlbmNlXG5cdFx0XHRcdCMgdGhlIHBhcmFtIGlzIGFscmVhZHkgcmVnaXN0ZXJlZD9cblx0XHRcdFx0IyBzaG91bGQgbm90IGZvcmNlIHRoZSBuYW1lIGFscmVhZHk/P1xuXHRcdFx0XHQjIGJld2FyZSBvZiBidWdzXG5cdFx0XHRcdGZ1bmMucGFyYW1zLmF0KDAseWVzLGxmdC52YXJpYWJsZS5uYW1lKVxuXHRcdFx0ZWxpZiBsZnQgaXNhIFR1cGxlXG5cdFx0XHRcdCMgaWYgdGhpcyBhbiB1bmZhbmN5IHR1cGxlLCB3aXRoIG9ubHkgdmFyc1xuXHRcdFx0XHQjIHdlIGNhbiBqdXN0IHVzZSBhcmd1bWVudHNcblxuXHRcdFx0XHRpZiBwYXIudHlwZSA9PSAndmFyJyAmJiAhbGZ0Lmhhc1NwbGF0XG5cdFx0XHRcdFx0IyBwIFwiU0lNUExJRlkhIHtsZnQubm9kZXNbMF19XCJcblx0XHRcdFx0XHRsZnQubWFwIGRvIHxlbCxpfFxuXHRcdFx0XHRcdFx0ZnVuYy5wYXJhbXMuYXQoaSx5ZXMsZWwudmFsdWUpXG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHQjIG90aGVyd2lzZSwgZG8gdGhlIHdob2xlIHR1cGxlXG5cdFx0XHRcdFx0IyBtYWtlIHN1cmUgaXQgaXMgYSB2YXIgYXNzaWdubWVudD9cblx0XHRcdFx0XHRwYXIucmlnaHQgPSBBUkdVTUVOVFNcblx0XHRcdFx0XHRmdW5jLmJvZHkudW5zaGlmdChwYXIpXG5cdFx0XHRlbHNlXG5cdFx0XHRcdCMgcmVndWxhciBzZXR0ZXJzXG5cdFx0XHRcdHBhci5yaWdodCA9IGZ1bmMucGFyYW1zLmF0KDAseWVzKVxuXHRcdFx0XHRmdW5jLmJvZHkudW5zaGlmdChwYXIpXG5cdFx0XHRcdFxuXHRcdFx0XG5cblx0XHQjIElmIGl0IGlzIGFuIGFkdmFuY2UgdHVwbGUgb3Igc29tZXRoaW5nLCBpdCBzaG91bGQgYmUgcG9zc2libGUgdG9cblx0XHQjIGZlZWQgaW4gdGhlIHBhcmFtbGlzdCwgYW5kIGxldCB0aGUgdHVwbGUgaGFuZGxlIGl0IGFzIGlmIGl0IHdhcyBhbnlcblx0XHQjIG90aGVyIHZhbHVlXG5cblx0XHQjIENBU0UgSWYgdGhpcyBpcyBhIHR1cGxlIC8gbXVsdGlzZXQgd2l0aCBtb3JlIHRoYW4gb25lIGFzeW5jIHZhbHVlXG5cdFx0IyB3ZSBuZWVkIHRvIHRoaW5rIGRpZmZlcmVudGx5LlxuXG5cdFx0IyBub3cgd2UgbmVlZCB0byB2aXNpdCB0aGUgZnVuY3Rpb24gYXMgd2VsbFxuXHRcdGZ1bmMudHJhdmVyc2Vcblx0XHQjIHB1bGwgdGhlIG91dGVyIGluXG5cdFx0c2VsZlxuXG5leHBvcnQgY2xhc3MgQXN5bmNGdW5jIDwgRnVuY1xuXG5cdGRlZiBpbml0aWFsaXplIHBhcmFtcywgYm9keSwgbmFtZSwgdGFyZ2V0LCBvcHRpb25zXG5cdFx0c3VwZXIocGFyYW1zLGJvZHksbmFtZSx0YXJnZXQsb3B0aW9ucylcblxuXHRkZWYgc2NvcGV0eXBlIGRvIExhbWJkYVNjb3BlXG5cblx0IyBuZWVkIHRvIG92ZXJyaWRlLCBzaW5jZSB3ZSB3b250IGRvIGltcGxpY2l0IHJldHVybnNcblx0IyBkZWYganNcblx0IyBcdHZhciBjb2RlID0gc2NvcGUuY1xuXHQjIFx0cmV0dXJuIFwiZnVuY3Rpb24gKHtwYXJhbXMuY30pXCIgKyBjb2RlLndyYXBcblxuXG5cbiMgSU1QT1JUU1xuXG5leHBvcnQgY2xhc3MgSW1wb3J0U3RhdGVtZW50IDwgU3RhdGVtZW50XG5cblxuXHRwcm9wIG5zXG5cdHByb3AgaW1wb3J0c1xuXHRwcm9wIHNvdXJjZVxuXG5cblx0ZGVmIGluaXRpYWxpemUgaW1wb3J0cywgc291cmNlLCBuc1xuXHRcdEB0cmF2ZXJzZWQgPSBub1xuXHRcdEBpbXBvcnRzID0gaW1wb3J0c1xuXHRcdEBzb3VyY2UgPSBzb3VyY2Vcblx0XHRAbnMgPSBuc1xuXHRcdHNlbGZcblxuXHRkZWYgdmlzaXRcblx0XHRpZiBAbnNcblx0XHRcdEBuc3ZhciB8fD0gc2NvcGVfXy5yZWdpc3RlcihAbnMsc2VsZilcblx0XHRlbHNlXG5cdFx0XHR2YXIgc3JjID0gc291cmNlLmNcblx0XHRcdHZhciBtID0gc3JjLm1hdGNoKC8oXFx3KykoXFwuanN8aW1iYSk/W1xcXCJcXCddJC8pXG5cdFx0XHRAYWxpYXMgPSBtID8gbVsxXSArICckJyA6ICdtb2QkJ1xuXHRcdFxuXHRcdCMgc2hvdWxkIGFsc28gcmVnaXN0ZXIgdGhlIGltcG9ydGVkIGl0ZW1zLCBubz9cblx0XHRpZiBAaW1wb3J0c1xuXHRcdFx0dmFyIGRlYyA9IEBkZWNsYXJhdGlvbnMgPSBWYXJpYWJsZURlY2xhcmF0aW9uLm5ldyhbXSlcblxuXHRcdFx0aWYgQGltcG9ydHM6bGVuZ3RoID09IDFcblx0XHRcdFx0QGFsaWFzID0gQGltcG9ydHNbMF1cblx0XHRcdFx0ZGVjLmFkZChAYWxpYXMsT1AoJy4nLENBTEwoSWRlbnRpZmllci5uZXcoXCJyZXF1aXJlXCIpLFtzb3VyY2VdKSxAYWxpYXMpKVxuXHRcdFx0XHRkZWMudHJhdmVyc2Vcblx0XHRcdFx0cmV0dXJuIHNlbGZcblx0XHRcdFx0XG5cdFx0XHRcdCMgZGVjLmFkZChAYWxpYXMsQ0FMTChJZGVudGlmaWVyLm5ldyhcInJlcXVpcmVcIiksW3NvdXJjZV0pKVxuXG5cdFx0XHQjIHAgXCJJbXBvcnRTdGF0ZW1lbnQgaGFzIGltcG9ydHMge0BpbXBvcnRzOmxlbmd0aH1cIlxuXHRcdFx0IyBAZGVjbGFyYXRpb25zID0gVmFyaWFibGVEZWNsYXJhdGlvbi5uZXcoW10pXG5cdFx0XHRAbW9kdWxlZGVjbCA9IGRlYy5hZGQoQGFsaWFzLENBTEwoSWRlbnRpZmllci5uZXcoXCJyZXF1aXJlXCIpLFtzb3VyY2VdKSlcblx0XHRcdEBtb2R1bGVkZWNsLnRyYXZlcnNlXG5cblxuXHRcdFx0aWYgQGltcG9ydHM6bGVuZ3RoID4gMVxuXHRcdFx0XHRmb3IgaW1wIGluIEBpbXBvcnRzXG5cdFx0XHRcdFx0QGRlY2xhcmF0aW9ucy5hZGQoaW1wLE9QKCcuJyxAbW9kdWxlZGVjbC52YXJpYWJsZSxpbXApKVxuXG5cdFx0XHRkZWMudHJhdmVyc2Vcblx0XHRzZWxmXG5cblxuXHRkZWYganMgb1xuXG5cdFx0aWYgQGRlY2xhcmF0aW9uc1xuXHRcdFx0cmV0dXJuIEBkZWNsYXJhdGlvbnMuY1xuXG5cdFx0dmFyIHJlcSA9IENBTEwoSWRlbnRpZmllci5uZXcoXCJyZXF1aXJlXCIpLFtzb3VyY2VdKVxuXG5cdFx0aWYgQG5zXG5cdFx0XHQjIG11c3QgcmVnaXN0ZXIgbnMgYXMgYSByZWFsIHZhcmlhYmxlXG5cdFx0XHRyZXR1cm4gXCJ2YXIge0Buc3Zhci5jfSA9IHtyZXEuY31cIlxuXG5cdFx0aWYgQGltcG9ydHNcblxuXHRcdFx0dmFyIHNyYyA9IHNvdXJjZS5jXG5cdFx0XHR2YXIgYWxpYXMgPSBbXVxuXHRcdFx0dmFyIHZhcnMgPSBWYXJCbG9jay5uZXcoW10pXG5cblx0XHRcdGlmIHZhciBmbmFtZSA9IHNyYy5tYXRjaCgvKFxcdyspKFxcLmpzfGltYmEpP1tcXFwiXFwnXSQvKVxuXHRcdFx0XHRhbGlhcy5wdXNoKGZuYW1lWzFdKVxuXG5cdFx0XHQjIHZhciBhbGlhcyA9IHNyYy5tYXRjaCgvKFxcdyspKFxcLmpzfGltYmEpP1tcXFwiXFwnXSQvKVxuXHRcdFx0IyBwIFwic291cmNlIHR5cGUge3NvdXJjZX1cIlxuXHRcdFx0IyBjcmVhdGUgYSByZXF1aXJlIGZvciB0aGUgc291cmNlLCB3aXRoIGEgdGVtcG9yYXJ5IG5hbWU/XG5cdFx0XHR2YXIgb3V0ID0gW3JlcS5jYWNoZShuYW1lczogYWxpYXMpLmNdXG5cblx0XHRcdGZvciBpbXAgaW4gQGltcG9ydHNcblx0XHRcdFx0IyB3ZSBhbHNvIG5lZWQgdG8gcmVnaXN0ZXIgdGhlc2UgaW1wb3J0cyBhcyB2YXJpYWJsZXMsIG5vP1xuXHRcdFx0XHR2YXIgbyA9IE9QKCc9JyxpbXAsT1AoJy4nLHJlcSxpbXApKVxuXHRcdFx0XHRvdXQucHVzaChcInZhciB7by5jfVwiKVxuXG5cdFx0XHRyZXR1cm4gb3V0XG5cdFx0ZWxzZVxuXHRcdFx0cmV0dXJuIHJlcS5jXG5cblx0ZGVmIGNvbnN1bWUgbm9kZVxuXHRcdHJldHVybiBzZWxmXG5cblxuIyBFWFBPUlQgXG5cbmV4cG9ydCBjbGFzcyBFeHBvcnRTdGF0ZW1lbnQgPCBWYWx1ZU5vZGVcblxuXHRkZWYganMgb1xuXHRcdHZhciBub2RlcyA9IEB2YWx1ZS5tYXAgZG8gfGFyZ3wgXCJtb2R1bGUuZXhwb3J0cy57YXJnLmN9ID0ge2FyZy5jfVwiXG5cblx0XHRpZiBub2RlczpsZW5ndGggPiAxIGFuZCB1cCBpc2EgUmV0dXJuXG5cdFx0XHRyZXR1cm4gJ1snICsgbm9kZXMuam9pbignLCcpICsgJ10nXG5cblx0XHRlbHNlXG5cdFx0XHRyZXR1cm4gbm9kZXMuam9pbignO1xcbicpICsgJzsnXG5cblxuIyBVVElMU1xuXG5leHBvcnQgY2xhc3MgVXRpbCA8IE5vZGVcblxuXHRwcm9wIGFyZ3NcblxuXHRkZWYgaW5pdGlhbGl6ZSBhcmdzXG5cdFx0QGFyZ3MgPSBhcmdzXG5cdFx0XG5cdCMgdGhpcyBpcyBob3cgd2UgZGVhbCB3aXRoIGl0IG5vd1xuXHRkZWYgc2VsZi5leHRlbmQgYSxiXG5cdFx0VXRpbC5FeHRlbmQubmV3KFthLGJdKVxuXG5cdGRlZiBzZWxmLmNhbGxJbWJhIG1ldGgsIGFyZ3Ncblx0XHRDQUxMKE9QKCcuJyxDb25zdC5uZXcoXCJJbWJhXCIpLElkZW50aWZpZXIubmV3KG1ldGgpKSxhcmdzKVxuXG5cdGRlZiBzZWxmLnJlcGVhdCBzdHIsIHRpbWVzXG5cdFx0dmFyIHJlcyA9ICcnXG5cdFx0d2hpbGUgdGltZXMgPiAwXG5cdFx0XHRpZiB0aW1lcyAlIDIgPT0gMVxuXHRcdFx0XHRyZXMgKz0gc3RyXG5cdFx0XHRzdHIgKz0gc3RyXG5cdFx0XHR0aW1lcyA+Pj0gMVxuXHRcdHJldHVybiByZXNcblx0XHRcblx0XHRcblxuXHRkZWYgc2VsZi5rZXlzIG9ialxuXHRcdHZhciBsID0gQ29uc3QubmV3KFwiT2JqZWN0XCIpXG5cdFx0dmFyIHIgPSBJZGVudGlmaWVyLm5ldyhcImtleXNcIilcblx0XHRDQUxMKE9QKCcuJyxsLHIpLFtvYmpdKVxuXG5cdGRlZiBzZWxmLmxlbiBvYmosIGNhY2hlXG5cdFx0IyBwIFwiTEVOIEhFTFBFUlwiLmdyZWVuXG5cdFx0dmFyIHIgPSBJZGVudGlmaWVyLm5ldyhcImxlbmd0aFwiKVxuXHRcdHZhciBub2RlID0gT1AoJy4nLCBvYmosIHIpXG5cdFx0bm9kZS5jYWNoZShmb3JjZTogeWVzLCBwb29sOiAnbGVuJykgaWYgY2FjaGVcblx0XHRyZXR1cm4gbm9kZVxuXG5cdGRlZiBzZWxmLmluZGV4T2YgbGZ0LCByZ3Rcblx0XHR2YXIgbm9kZSA9IFV0aWwuSW5kZXhPZi5uZXcoW2xmdCxyZ3RdKVxuXHRcdCMgbm9kZS5jYWNoZShmb3JjZTogeWVzLCB0eXBlOiAnaXRlcicpIGlmIGNhY2hlXG5cdFx0cmV0dXJuIG5vZGVcblxuXHRkZWYgc2VsZi5zbGljZSBvYmosIGEsIGJcblx0XHR2YXIgc2xpY2UgPSBJZGVudGlmaWVyLm5ldyhcInNsaWNlXCIpXG5cdFx0Y29uc29sZS5sb2cgXCJzbGljZSB7YX0ge2J9XCJcblx0XHRyZXR1cm4gQ0FMTChPUCgnLicsb2JqLHNsaWNlKSxjb21wYWN0X18oW2EsYl0pKVxuXHRcblx0ZGVmIHNlbGYuaXRlcmFibGUgb2JqLCBjYWNoZVxuXHRcdHZhciBub2RlID0gVXRpbC5JdGVyYWJsZS5uZXcoW29ial0pXG5cdFx0bm9kZS5jYWNoZShmb3JjZTogeWVzLCBwb29sOiAnaXRlcicpIGlmIGNhY2hlXG5cdFx0cmV0dXJuIG5vZGVcblxuXG5cblx0ZGVmIHNlbGYudW5pb24gYSxiXG5cdFx0VXRpbC5Vbmlvbi5uZXcoW2EsYl0pXG5cdFx0IyBDQUxMKFVOSU9OLFthLGJdKVxuXG5cdGRlZiBzZWxmLmludGVyc2VjdCBhLGJcblx0XHRVdGlsLkludGVyc2VjdC5uZXcoW2EsYl0pXG5cdFx0IyBDQUxMKElOVEVSU0VDVCxbYSxiXSlcblxuXHRkZWYgc2VsZi5jb3VudGVyIHN0YXJ0LCBjYWNoZVxuXHRcdCMgc2hvdWxkIGl0IG5vdCByYXRoZXIgYmUgYSB2YXJpYWJsZT8hP1xuXHRcdHZhciBub2RlID0gTnVtLm5ldyhzdGFydCkgIyBtYWtlIHN1cmUgaXQgcmVhbGx5IGlzIGEgbnVtYmVyXG5cdFx0bm9kZS5jYWNoZShmb3JjZTogeWVzLCBwb29sOiAnY291bnRlcicpIGlmIGNhY2hlXG5cdFx0cmV0dXJuIG5vZGVcblxuXHRkZWYgc2VsZi5hcnJheSBzaXplLCBjYWNoZVxuXHRcdHZhciBub2RlID0gVXRpbC5BcnJheS5uZXcoW3NpemVdKVxuXHRcdG5vZGUuY2FjaGUoZm9yY2U6IHllcywgcG9vbDogJ2xpc3QnKSBpZiBjYWNoZVxuXHRcdHJldHVybiBub2RlXG5cblx0ZGVmIHNlbGYuZGVmaW5lVGFnIHR5cGUsIGN0b3IsIHN1cHJcblx0XHRDQUxMKFRBR0RFRixbdHlwZSxjdG9yLHN1cHJdKVxuXG5cblx0ZGVmIHNlbGYuZGVmaW5lQ2xhc3MgbmFtZSwgc3VwciwgaW5pdG9yXG5cdFx0Q0FMTChDTEFTU0RFRixbbmFtZSBvciBpbml0b3Isc3VwXSlcblxuXHRkZWYgaXNTdGFuZGFsb25lXG5cdFx0T1BUUzpzdGFuZGFsb25lICE9PSBub1xuXG5cdGRlZiBqcyBvXG5cdFx0XCJoZWxwZXJcIlxuXG4jIFRPRE8gRGVwcmVjYXRlIGFuZCByZW1vdmVcbmV4cG9ydCBjbGFzcyBVdGlsLlVuaW9uIDwgVXRpbFxuXG5cdGRlZiBoZWxwZXJcblx0XHQnJydcblx0XHRmdW5jdGlvbiB1bmlvbiQoYSxiKXtcblx0XHRcdGlmKGEgJiYgYS5fX3VuaW9uKSByZXR1cm4gYS5fX3VuaW9uKGIpO1xuXG5cdFx0XHR2YXIgdSA9IGEuc2xpY2UoMCk7XG5cdFx0XHRmb3IodmFyIGk9MCxsPWIubGVuZ3RoO2k8bDtpKyspIGlmKHUuaW5kZXhPZihiW2ldKSA9PSAtMSkgdS5wdXNoKGJbaV0pO1xuXHRcdFx0cmV0dXJuIHU7XG5cdFx0fTtcblxuXHRcdCcnJ1xuXG5cdGRlZiBqcyBvXG5cdFx0c2NvcGVfXy5yb290LmhlbHBlcihzZWxmLGhlbHBlcilcblx0XHQjIFdoZW4gdGhpcyBpcyB0cmlnZ2VyZWQsIHdlIG5lZWQgdG8gYWRkIGl0IHRvIHRoZSB0b3Agb2YgZmlsZT9cblx0XHRcInVuaW9uJCh7YXJncy5tYXAofHZ8IHYuYyApLmpvaW4oJywnKX0pXCJcblxuIyBUT0RPIERlcHJlY2F0ZSBhbmQgcmVtb3ZlXG5leHBvcnQgY2xhc3MgVXRpbC5JbnRlcnNlY3QgPCBVdGlsXG5cblx0ZGVmIGhlbHBlclxuXHRcdCcnJ1xuXHRcdGZ1bmN0aW9uIGludGVyc2VjdCQoYSxiKXtcblx0XHRcdGlmKGEgJiYgYS5fX2ludGVyc2VjdCkgcmV0dXJuIGEuX19pbnRlcnNlY3QoYik7XG5cdFx0XHR2YXIgcmVzID0gW107XG5cdFx0XHRmb3IodmFyIGk9MCwgbD1hLmxlbmd0aDsgaTxsOyBpKyspIHtcblx0XHRcdFx0dmFyIHYgPSBhW2ldO1xuXHRcdFx0XHRpZihiLmluZGV4T2YodikgIT0gLTEpIHJlcy5wdXNoKHYpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlcztcblx0XHR9O1xuXG5cdFx0JycnXG5cblx0ZGVmIGpzIG9cblx0XHQjIFdoZW4gdGhpcyBpcyB0cmlnZ2VyZWQsIHdlIG5lZWQgdG8gYWRkIGl0IHRvIHRoZSB0b3Agb2YgZmlsZT9cblx0XHRzY29wZV9fLnJvb3QuaGVscGVyKHNlbGYsaGVscGVyKVxuXHRcdFwiaW50ZXJzZWN0JCh7YXJncy5tYXAofHZ8IHYuYyApLmpvaW4oJywnKX0pXCJcblxuZXhwb3J0IGNsYXNzIFV0aWwuRXh0ZW5kIDwgVXRpbFxuXG5cdGRlZiBqcyBvXG5cdFx0IyBXaGVuIHRoaXMgaXMgdHJpZ2dlcmVkLCB3ZSBuZWVkIHRvIGFkZCBpdCB0byB0aGUgdG9wIG9mIGZpbGU/XG5cdFx0XCJleHRlbmQkKHtjb21wYWN0X18oY2FyeV9fKGFyZ3MpKS5qb2luKCcsJyl9KVwiXG5cbmV4cG9ydCBjbGFzcyBVdGlsLkluZGV4T2YgPCBVdGlsXG5cblx0ZGVmIGhlbHBlclxuXHRcdCcnJ1xuXHRcdGZ1bmN0aW9uIGlkeCQoYSxiKXtcblx0XHRcdHJldHVybiAoYiAmJiBiLmluZGV4T2YpID8gYi5pbmRleE9mKGEpIDogW10uaW5kZXhPZi5jYWxsKGEsYik7XG5cdFx0fTtcblxuXHRcdCcnJ1xuXG5cdGRlZiBqcyBvXG5cdFx0aWYgaXNTdGFuZGFsb25lXG5cdFx0XHRzY29wZV9fLnJvb3QuaGVscGVyKHNlbGYsaGVscGVyKVxuXHRcdFx0IyBXaGVuIHRoaXMgaXMgdHJpZ2dlcmVkLCB3ZSBuZWVkIHRvIGFkZCBpdCB0byB0aGUgdG9wIG9mIGZpbGU/XG5cdFx0XHRcImlkeCQoe2FyZ3MubWFwKHx2fCB2LmMgKS5qb2luKCcsJyl9KVwiXG5cdFx0ZWxzZVxuXHRcdFx0XCJJbWJhLmluZGV4T2Yoe2FyZ3MubWFwKHx2fCB2LmMgKS5qb2luKCcsJyl9KVwiXG5cdFx0XG5cbmV4cG9ydCBjbGFzcyBVdGlsLlN1YmNsYXNzIDwgVXRpbFxuXG5cdGRlZiBoZWxwZXJcblx0XHQjIHNob3VsZCBhbHNvIGNoZWNrIGlmIGl0IGlzIGEgcmVhbCBwcm9taXNlXG5cdFx0JycnXG5cdFx0Ly8gaGVscGVyIGZvciBzdWJjbGFzc2luZ1xuXHRcdGZ1bmN0aW9uIHN1YmNsYXNzJChvYmosc3VwKSB7XG5cdFx0XHRmb3IgKHZhciBrIGluIHN1cCkge1xuXHRcdFx0XHRpZiAoc3VwLmhhc093blByb3BlcnR5KGspKSBvYmpba10gPSBzdXBba107XG5cdFx0XHR9O1xuXHRcdFx0Ly8gb2JqLl9fc3VwZXJfXyA9IHN1cDtcblx0XHRcdG9iai5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cC5wcm90b3R5cGUpO1xuXHRcdFx0b2JqLl9fc3VwZXJfXyA9IG9iai5wcm90b3R5cGUuX19zdXBlcl9fID0gc3VwLnByb3RvdHlwZTtcblx0XHRcdG9iai5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IG9iai5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBvYmo7XG5cdFx0fTtcblxuXHRcdCcnJ1xuXG5cdGRlZiBqcyBvXG5cdFx0aWYgaXNTdGFuZGFsb25lXG5cdFx0XHQjIFdoZW4gdGhpcyBpcyB0cmlnZ2VyZWQsIHdlIG5lZWQgdG8gYWRkIGl0IHRvIHRoZSB0b3Agb2YgZmlsZT9cblx0XHRcdHNjb3BlX18ucm9vdC5oZWxwZXIoc2VsZixoZWxwZXIpXG5cdFx0XHRcInN1YmNsYXNzJCh7YXJncy5tYXAofHZ8IHYuYykuam9pbignLCcpfSk7XFxuXCJcblx0XHRlbHNlXG5cdFx0XHRcIkltYmEuc3ViY2xhc3Moe2FyZ3MubWFwKHx2fCB2LmMpLmpvaW4oJywnKX0pO1xcblwiXG5cbmV4cG9ydCBjbGFzcyBVdGlsLlByb21pc2lmeSA8IFV0aWxcblxuXHRkZWYgaGVscGVyXG5cdFx0IyBzaG91bGQgYWxzbyBjaGVjayBpZiBpdCBpcyBhIHJlYWwgcHJvbWlzZVxuXHRcdFwiZnVuY3Rpb24gcHJvbWlzZSQoYSlcXHsgcmV0dXJuIGEgaW5zdGFuY2VvZiBBcnJheSA/IFByb21pc2UuYWxsKGEpIDogKGEgJiYgYS50aGVuID8gYSA6IFByb21pc2UucmVzb2x2ZShhKSk7IFxcfVwiXG5cdFx0XG5cdGRlZiBqcyBvXG5cdFx0aWYgaXNTdGFuZGFsb25lXG5cdFx0XHQjIFdoZW4gdGhpcyBpcyB0cmlnZ2VyZWQsIHdlIG5lZWQgdG8gYWRkIGl0IHRvIHRoZSB0b3Agb2YgZmlsZT9cblx0XHRcdHNjb3BlX18ucm9vdC5oZWxwZXIoc2VsZixoZWxwZXIpXG5cdFx0XHRcInByb21pc2UkKHthcmdzLm1hcCh8dnwgdi5jKS5qb2luKCcsJyl9KVwiXG5cdFx0ZWxzZVxuXHRcdFx0XCJJbWJhLmF3YWl0KHthcmdzLm1hcCh8dnwgdi5jKS5qb2luKCcsJyl9KVwiXG5cdFx0XG4jIFRPRE8gZGVwcmVjYXRlZDogY2FuIHJlbW92ZVxuZXhwb3J0IGNsYXNzIFV0aWwuQ2xhc3MgPCBVdGlsXG5cblx0ZGVmIGpzIG9cblx0XHQjIFdoZW4gdGhpcyBpcyB0cmlnZ2VyZWQsIHdlIG5lZWQgdG8gYWRkIGl0IHRvIHRoZSB0b3Agb2YgZmlsZT9cblx0XHRcImNsYXNzJCh7YXJncy5tYXAofHZ8IHYuYykuam9pbignLCcpfSlcIlxuXG5leHBvcnQgY2xhc3MgVXRpbC5JdGVyYWJsZSA8IFV0aWxcblxuXHRkZWYgaGVscGVyXG5cdFx0IyBub3cgd2Ugd2FudCB0byBhbGxvdyBudWxsIHZhbHVlcyBhcyB3ZWxsIC0ganVzdCByZXR1cm4gYXMgZW1wdHkgY29sbGVjdGlvblxuXHRcdCMgc2hvdWxkIGJlIHRoZSBzYW1lIGZvciBmb3Igb3duIG9mIEkgZ3Vlc3Ncblx0XHRcImZ1bmN0aW9uIGl0ZXIkKGEpXFx7IHJldHVybiBhID8gKGEudG9BcnJheSA/IGEudG9BcnJheSgpIDogYSkgOiBbXTsgXFx9O1wiXG5cdFx0XG5cdGRlZiBqcyBvXG5cdFx0cmV0dXJuIGFyZ3NbMF0uYyBpZiBhcmdzWzBdIGlzYSBBcnIgIyBvciBpZiB3ZSBrbm93IGZvciBzdXJlIHRoYXQgaXQgaXMgYW4gYXJyYXlcblxuXHRcdGlmIGlzU3RhbmRhbG9uZVxuXHRcdFx0c2NvcGVfXy5yb290LmhlbHBlcihzZWxmLGhlbHBlcilcblx0XHRcdHJldHVybiBcIml0ZXIkKHthcmdzWzBdLmN9KVwiXG5cdFx0ZWxzZVxuXHRcdFx0cmV0dXJuIFwiSW1iYS5pdGVyYWJsZSh7YXJnc1swXS5jfSlcIlxuXHRcdFxuZXhwb3J0IGNsYXNzIFV0aWwuSXNGdW5jdGlvbiA8IFV0aWxcblxuXHRkZWYganMgb1xuXHRcdFwie2FyZ3NbMF0uY31cIlxuXG5leHBvcnQgY2xhc3MgVXRpbC5BcnJheSA8IFV0aWxcblxuXHRkZWYganMgb1xuXHRcdCMgV2hlbiB0aGlzIGlzIHRyaWdnZXJlZCwgd2UgbmVlZCB0byBhZGQgaXQgdG8gdGhlIHRvcCBvZiBmaWxlP1xuXHRcdFwibmV3IEFycmF5KHthcmdzLm1hcCh8dnwgdi5jKX0pXCJcblxuXG5cblxuY2xhc3MgRW50aXRpZXNcblxuXHRkZWYgaW5pdGlhbGl6ZSByb290XG5cdFx0QHJvb3QgPSByb290XG5cdFx0QG1hcCA9IHt9XG5cdFx0cmV0dXJuIHNlbGZcblxuXHRkZWYgYWRkIHBhdGgsIG9iamVjdFxuXHRcdEBtYXBbcGF0aF0gPSBvYmplY3Rcblx0XHRzZWxmXG5cblx0ZGVmIHJlZ2lzdGVyIGVudGl0eVxuXHRcdHZhciBwYXRoID0gZW50aXR5Lm5hbWVwYXRoXG5cdFx0QG1hcFtwYXRoXSB8fD0gZW50aXR5XG5cdFx0c2VsZlxuXG5cdGRlZiBwbGFpblxuXHRcdEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoQG1hcCkpXG5cblx0ZGVmIHRvSlNPTlxuXHRcdEBtYXBcblxuIyBTQ09QRVNcblxuIyBoYW5kbGVzIGxvY2FsIHZhcmlhYmxlcywgc2VsZiBldGMuIFNob3VsZCBjcmVhdGUgcmVmZXJlbmNlcyB0byBvdXRlciBzY29wZXNcbiMgd2hlbiBuZWVkZWQgZXRjLlxuXG4jIGFkZCBjbGFzcyBmb3IgYW5ub3RhdGlvbnMgLyByZWdpc3RlcmluZyBtZXRob2RzLCBldGM/XG4jIGNsYXNzIEludGVyZmFjZVxuXG4jIHNob3VsZCBtb3ZlIHRoZSB3aG9sZSBjb250ZXh0LXRoaW5naWUgcmlnaHQgaW50byBzY29wZVxuZXhwb3J0IGNsYXNzIFNjb3BlXG5cblx0cHJvcCBsZXZlbFxuXHRwcm9wIGNvbnRleHRcblx0cHJvcCBub2RlXG5cdHByb3AgcGFyZW50XG5cdHByb3AgdmFybWFwXG5cdHByb3AgdmFycG9vbFxuXHRwcm9wIHBhcmFtc1xuXHRwcm9wIGhlYWRcblx0cHJvcCB2YXJzXG5cdHByb3AgY291bnRlclxuXG5cdGRlZiBwXG5cdFx0aWYgU1RBQ0subG9nbGV2ZWwgPiAwXG5cdFx0XHRjb25zb2xlLmxvZygqYXJndW1lbnRzKVxuXHRcdHNlbGZcblxuXHRkZWYgc3RhY2tcblx0XHRTVEFDS1xuXG5cdGRlZiBpbml0aWFsaXplIG5vZGUsIHBhcmVudFxuXHRcdEBuciA9IFNUQUNLLmluY3IoJ3Njb3BlcycpXG5cdFx0QGhlYWQgPSBbXVxuXHRcdEBub2RlID0gbm9kZVxuXHRcdEBwYXJlbnQgPSBwYXJlbnRcblx0XHRAdmFycyA9IFZhcmlhYmxlRGVjbGFyYXRpb24ubmV3KFtdKVxuXHRcdEBtZXRhID0ge31cblx0XHRAYW5ub3RhdGlvbnMgPSBbXVxuXHRcdEBjbG9zdXJlID0gc2VsZlxuXHRcdEB2aXJ0dWFsID0gbm9cblx0XHRAY291bnRlciA9IDBcblx0XHRAdmFybWFwICA9IHt9XG5cdFx0QHZhcnBvb2wgPSBbXVxuXG5cdGRlZiBtZXRhIGtleSwgdmFsdWVcblx0XHRpZiB2YWx1ZSAhPSB1bmRlZmluZWRcblx0XHRcdEBtZXRhW2tleV0gPSB2YWx1ZVxuXHRcdFx0cmV0dXJuIHNlbGZcblx0XHRAbWV0YVtrZXldXG5cblx0ZGVmIG5hbWVwYXRoXG5cdFx0Jz8nXG5cblx0ZGVmIHRhZ0NvbnRleHRQYXRoXG5cdFx0IyBieXBhc3NpbmcgZm9yIG5vd1xuXHRcdEB0YWdDb250ZXh0UGF0aCB8fD0gXCJ0YWckXCIgIyBwYXJlbnQudGFnQ29udGV4dFBhdGhcblxuXHRkZWYgY29udGV4dFxuXHRcdEBjb250ZXh0IHx8PSBTY29wZUNvbnRleHQubmV3KHNlbGYpXG5cblx0ZGVmIHRyYXZlcnNlXG5cdFx0c2VsZlxuXG5cdGRlZiB2aXNpdFxuXHRcdHJldHVybiBzZWxmIGlmIEBwYXJlbnRcblx0XHQjIHAgXCJ2aXNpdGVkIHNjb3BlIVwiXG5cdFx0QHBhcmVudCA9IFNUQUNLLnNjb3BlKDEpICMgdGhlIHBhcmVudCBzY29wZVxuXHRcdEBsZXZlbCA9IFNUQUNLLnNjb3BlczpsZW5ndGggLSAxXG5cblx0XHQjIHAgXCJwYXJlbnQgaXNcIixAcGFyZW50XG5cdFx0U1RBQ0suYWRkU2NvcGUoc2VsZilcblx0XHRyb290LnNjb3Blcy5wdXNoKHNlbGYpXG5cdFx0c2VsZlxuXG5cdGRlZiB3cmFwIHNjb3BlXG5cdFx0QHBhcmVudCA9IHNjb3BlLkBwYXJlbnRcblx0XHRzY29wZS5AcGFyZW50ID0gc2VsZlxuXHRcdHNlbGZcblxuXHQjIGNhbGxlZCBmb3Igc2NvcGVzIHRoYXQgYXJlIG5vdCByZWFsIHNjb3BlcyBpbiBqc1xuXHQjIG11c3QgZW5zdXJlIHRoYXQgdGhlIGxvY2FsIHZhcmlhYmxlcyBpbnNpZGUgb2YgdGhlIHNjb3BlcyBkbyBub3Rcblx0IyBjb2xsaWRlIHdpdGggdmFyaWFibGVzIGluIG91dGVyIHNjb3BlcyAtLSByZW5hbWUgaWYgbmVlZGVkXG5cdGRlZiB2aXJ0dWFsaXplXG5cdFx0c2VsZlxuXG5cdGRlZiByb290XG5cdFx0dmFyIHNjb3BlID0gc2VsZlxuXHRcdHdoaWxlIHNjb3BlXG5cdFx0XHRyZXR1cm4gc2NvcGUgaWYgc2NvcGUgaXNhIFJvb3RTY29wZVxuXHRcdFx0c2NvcGUgPSBzY29wZS5wYXJlbnRcblx0XHRyZXR1cm4gbnVsbFxuXG5cdGRlZiByZWdpc3RlciBuYW1lLCBkZWNsID0gbnVsbCwgbyA9IHt9XG5cdFx0IyBGSVhNRSByZS1yZWdpc3RlcmluZyBhIHZhcmlhYmxlIHNob3VsZCByZWFsbHkgcmV0dXJuIHRoZSBleGlzdGluZyBvbmVcblx0XHQjIEFnYWluLCBoZXJlIHdlIHNob3VsZCBub3QgcmVhbGx5IGhhdmUgdG8gZGVhbCB3aXRoIHN5c3RlbS1nZW5lcmF0ZWQgdmFyc1xuXHRcdCMgQnV0IGFnYWluLCBpdCBpcyBpbXBvcnRhbnRcblxuXHRcdCMgcCBcInJlZ2lzdGVyaW5nIHtuYW1lfVwiXG5cdFx0bmFtZSA9IGhlbHBlcnMuc3ltYm9saXplKG5hbWUpXG5cblx0XHQjIGFsc28gbG9vayBhdCBvdXRlciBzY29wZXMgaWYgdGhpcyBpcyBub3QgY2xvc2VkP1xuXHRcdHZhciBleGlzdGluZyA9IEB2YXJtYXAuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgQHZhcm1hcFtuYW1lXVxuXHRcdHJldHVybiBleGlzdGluZyBpZiBleGlzdGluZ1xuXG5cdFx0dmFyIGl0ZW0gPSBWYXJpYWJsZS5uZXcoc2VsZixuYW1lLGRlY2wsbylcblx0XHQjIG5lZWQgdG8gY2hlY2sgZm9yIGR1cGxpY2F0ZXMsIGFuZCBoYW5kbGUgdGhpcyBncmFjZWZ1bGx5IC1cblx0XHQjIGdvaW5nIHRvIHJlZmFjdG9yIGxhdGVyXG5cdFx0QHZhcm1hcFtuYW1lXSA9IGl0ZW0gdW5sZXNzIG86c3lzdGVtICMgZG9udCBldmVuIGFkZCB0byB0aGUgdmFybWFwIGlmIGl0IGlzIGEgc3lzdmFyXG5cdFx0cmV0dXJuIGl0ZW1cblxuXHRkZWYgYW5ub3RhdGUgb2JqXG5cdFx0QGFubm90YXRpb25zLnB1c2gob2JqKVxuXHRcdHNlbGZcblxuXHQjIGp1c3QgbGlrZSByZWdpc3RlciwgYnV0IHdlIGF1dG9tYXRpY2FsbHkgXG5cdGRlZiBkZWNsYXJlIG5hbWUsIGluaXQgPSBudWxsLCBvID0ge31cblx0XHR2YXIgdmFyaWFibGUgPSByZWdpc3RlcihuYW1lLG51bGwsbylcblx0XHQjIFRPRE8gY3JlYXRlIHRoZSB2YXJpYWJsZWRlY2xhcmF0aW9uIGhlcmUgaW5zdGVhZD9cblx0XHQjIGlmIHRoaXMgaXMgYSBzeXN2YXIgd2UgbmVlZCBpdCB0byBiZSByZW5hbWVhYmxlXG5cdFx0dmFyIGRlYyA9IEB2YXJzLmFkZCh2YXJpYWJsZSxpbml0KVxuXHRcdHZhcmlhYmxlLmRlY2xhcmF0b3IgfHw9IGRlY1xuXHRcdHJldHVybiB2YXJpYWJsZVxuXG5cdFx0IyBwIFwiZGVjbGFyZSB2YXJpYWJsZSB7bmFtZX0ge299XCJcblx0XHQjIGlmIG5hbWUgaXNhIFZhcmlhYmxlXG5cdFx0IyBwIFwiU0NPUEUgZGVjbGFyZSB2YXJcIi5ncmVlblxuXHRcdG5hbWUgPSBoZWxwZXJzLnN5bWJvbGl6ZShuYW1lKVxuXHRcdCMgd2Ugd2lsbCBzZWUgaGVyZVxuXHRcdEB2YXJzLmFkZChuYW1lLGluaXQpICMgLmxhc3QgLS0gXG5cdFx0dmFyIGRlY2wgPSBAdmFycy5sYXN0ICMgYnVnKCEpXG5cdFx0dmFyIGl0ZW1cblx0XHQjIGl0ZW0gPSBWYXJpYWJsZS5uZXcoc2VsZixuYW1lLGRlY2wpXG5cblx0XHQjIGlmIG86c3lzdGVtXG5cdFx0IyBcdGl0ZW0gPSBTeXN0ZW1WYXJpYWJsZS5uZXcoc2VsZixuYW1lLGRlY2wsbylcblx0XHQjIFx0ZGVjbC52YXJpYWJsZSA9IGl0ZW1cblx0XHQjIGVsc2Vcblx0XHRpdGVtID0gVmFyaWFibGUubmV3KHNlbGYsbmFtZSxkZWNsLG8pXG5cdFx0ZGVjbC52YXJpYWJsZSA9IGl0ZW1cblx0XHRpdGVtLnJlc29sdmUgIyB3aHkgb24gZWFydGggc2hvdWxkIGl0IHJlc29sdmUgaW1tZWRpYXRlbHk/XG5cdFx0XG5cdFx0IyBkZWNsLnZhcmlhYmxlID0gaXRlbVxuXHRcdCMgaXRlbS5yZXNvbHZlICMgd2h5IG9uIGVhcnRoIHNob3VsZCBpdCByZXNvbHZlIGltbWVkaWF0ZWx5P1xuXHRcdHJldHVybiBpdGVtXG5cblx0XHQjIHNob3VsZCBiZSBwb3NzaWJsZSB0byBmb3JjZS1kZWNsYXJlIGZvciB0aGlzIHNjb3BlLCBubz9cblx0XHQjIGlmIHRoaXMgaXMgYSBzeXN0ZW0tdmFyaWFibGUgXG5cblx0IyBkZWNsYXJlcyBhIHZhcmlhYmxlIChoYXMgbm8gcmVhbCBkZWNsYXJhdGlvbiBiZWZvcmVoYW5kKVxuXG5cblx0IyB3aGF0IGFyZSB0aGUgZGlmZmVyZW5jZXMgaGVyZT8gb21qXG5cdCMgd2Ugb25seSBuZWVkIGEgdGVtcG9yYXJ5IHRoaW5nIHdpdGggZGVmYXVsdHMgLS0gdGhhdCBpcyBhbGxcblx0IyBjaGFuZ2UgdGhlc2UgdmFsdWVzLCBubz9cblx0ZGVmIHRlbXBvcmFyeSByZWZub2RlLCBvID0ge30sIG5hbWUgPSBudWxsXG5cblx0XHQjIHAgXCJyZWdpc3RlcmluZyB0ZW1wb3Jhcnkge3JlZm5vZGV9IHtuYW1lfVwiXG5cdFx0IyByZXVzZSB2YXJpYWJsZXMgLS0gaG1tXG5cdFx0aWYgbzpwb29sXG5cdFx0XHRmb3IgdiBpbiBAdmFycG9vbFxuXHRcdFx0XHRpZiB2LnBvb2wgPT0gbzpwb29sICYmIHYuZGVjbGFyYXRvciA9PSBudWxsXG5cdFx0XHRcdFx0cmV0dXJuIHYucmV1c2UocmVmbm9kZSlcblxuXHRcdCMgc2hvdWxkIG9ubHkgJ3JlZ2lzdGVyJyBhcyBhaGlkZGVuIHZhcmlhYmxlLCBubz9cblx0XHQjIGlmIHRoZXJlIGFyZSByZWFsIG5vZGVzIGluc2lkZSB0aGF0IHRyaWVzIHRvIHJlZmVyIHRvIHZhcnNcblx0XHQjIGRlZmluZWQgaW4gb3V0ZXIgc2NvcGVzLCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGV5IGFyZSBub3QgbmFtZWQgYWZ0ZXIgdGhpc1xuXHRcdHZhciBpdGVtID0gU3lzdGVtVmFyaWFibGUubmV3KHNlbGYsbmFtZSxyZWZub2RlLG8pXG5cdFx0QHZhcnBvb2wucHVzaChpdGVtKSAjIFdIQVQ/IEl0IHNob3VsZCBub3QgYmUgaW4gdGhlIHBvb2wgdW5sZXNzIGV4cGxpY2l0bHkgcHV0IHRoZXJlP1xuXHRcdEB2YXJzLnB1c2goaXRlbSkgIyBXQVJOIHZhcmlhYmxlcyBzaG91bGQgbm90IGdvIGRpcmVjdGx5IGludG8gYSBkZWNsYXJhdGlvbi1saXN0XG5cdFx0cmV0dXJuIGl0ZW1cblx0XHQjIHJldHVybiByZWdpc3RlcihuYW1lIHx8IFwiX19cIixudWxsLHN5c3RlbTogeWVzLCB0ZW1wb3Jhcnk6IHllcylcblxuXHRcblxuXHRkZWYgbG9va3VwIG5hbWVcblx0XHR2YXIgcmV0ID0gbnVsbFxuXHRcdG5hbWUgPSBoZWxwZXJzLnN5bWJvbGl6ZShuYW1lKVxuXHRcdGlmIEB2YXJtYXAuaGFzT3duUHJvcGVydHkobmFtZSlcblx0XHRcdHJldCA9IEB2YXJtYXBbbmFtZV0gXG5cdFx0ZWxzZVxuXHRcdFx0IyBsb29rIHVwIGFueSBwYXJlbnQgc2NvcGUgPz8gc2VlbXMgb2theVxuXHRcdFx0IyAhaXNDbG9zZWQgJiYgXG5cdFx0XHRyZXQgPSBwYXJlbnQgJiYgcGFyZW50Lmxvb2t1cChuYW1lKVxuXHRcdFx0IyBvciAtLSBub3QgYWxsIHNjb3BlcyBoYXZlIGEgcGFyZW50P1xuXHRcdFxuXHRcdCMgc2hvdWxkIHRoaXMgbm90IGhhcHBlbiBieSBpdHNlbGY/XG5cdFx0IyBpZiAhcmV0IGFuZCBcblx0XHQjXHRyZXQgPSBcblx0XHQjIHJldCB8fD0gKGcubG9va3VwKG5hbWUpIGlmIHZhciBnID0gcm9vdClcblx0XHQjIGcgPSByb290XG5cdFx0cmV0XG5cblx0ZGVmIGF1dG9kZWNsYXJlIHZhcmlhYmxlXG5cdFx0dmFycy5wdXNoKHZhcmlhYmxlKSAjIG9ubHkgaWYgaXQgZG9lcyBub3QgZXhpc3QgaGVyZSEhIVxuXG5cdGRlZiBmcmVlIHZhcmlhYmxlXG5cdFx0IyBwIFwiZnJlZSB2YXJpYWJsZVwiXG5cdFx0dmFyaWFibGUuZnJlZSAjIDpvd25lciA9IG51bGxcblx0XHQjIEB2YXJwb29sLnB1c2godmFyaWFibGUpXG5cdFx0c2VsZlxuXHRcblx0ZGVmIGlzQ2xvc2VkXG5cdFx0bm9cblxuXHRkZWYgY2xvc3VyZVxuXHRcdEBjbG9zdXJlXG5cblx0ZGVmIGZpbmFsaXplXG5cdFx0c2VsZlxuXG5cdGRlZiBrbGFzc1xuXHRcdHZhciBzY29wZSA9IHNlbGZcblx0XHR3aGlsZSBzY29wZVxuXHRcdFx0c2NvcGUgPSBzY29wZS5wYXJlbnRcblx0XHRcdHJldHVybiBzY29wZSBpZiBzY29wZSBpc2EgQ2xhc3NTY29wZVxuXHRcdHJldHVybiBudWxsXG5cblx0ZGVmIGhlYWRcblx0XHRbQHZhcnMsQHBhcmFtc11cblxuXHRkZWYgYyBvID0ge31cblx0XHRvOmV4cHJlc3Npb24gPSBub1xuXHRcdCMgbmVlZCB0byBmaXggdGhpc1xuXHRcdG5vZGUuYm9keS5oZWFkID0gaGVhZFxuXHRcdHZhciBib2R5ID0gbm9kZS5ib2R5LmMobylcblxuXHRcdCMgdmFyIGhlYWQgPSBbQHZhcnMsQHBhcmFtc10uYmxvY2suYyhleHByZXNzaW9uOiBubylcblx0XHQjIHAgXCJoZWFkIGZyb20gc2NvcGUgaXMgKHtoZWFkfSlcIlxuXHRcdCMgdmFyIG91dCA9IFtoZWFkIG9yIG51bGwsYm9keV0uZmxhdHRlbl9fLmNvbXBhY3Quam9pbihcIlxcblwiKVxuXHRcdCMgb3V0XG5cdFx0IyBvdXQgPSAneycgKyBvdXQgKyBcblxuXHRkZWYgcmVnaW9uXG5cdFx0bm9kZS5ib2R5LnJlZ2lvblxuXG5cdGRlZiBsb2Ncblx0XHRub2RlLmxvY1xuXG5cdGRlZiBkdW1wXG5cdFx0dmFyIHZhcnMgPSBPYmplY3Qua2V5cyhAdmFybWFwKS5tYXAgZG8gfGt8IFxuXHRcdFx0dmFyIHYgPSBAdmFybWFwW2tdXG5cdFx0XHR2LnJlZmVyZW5jZXM6bGVuZ3RoID8gZHVtcF9fKHYpIDogbnVsbFxuXG5cdFx0dmFyIGRlc2MgPSBcblx0XHRcdG5yOiBAbnJcblx0XHRcdHR5cGU6IHNlbGY6Y29uc3RydWN0b3I6bmFtZVxuXHRcdFx0bGV2ZWw6IChsZXZlbCBvciAwKVxuXHRcdFx0dmFyczogY29tcGFjdF9fKHZhcnMpXG5cdFx0XHRsb2M6IGxvY1xuXG5cdFx0cmV0dXJuIGRlc2NcblxuXHRkZWYgdG9KU09OXG5cdFx0ZHVtcFxuXG5cdGRlZiB0b1N0cmluZ1xuXHRcdFwie3NlbGY6Y29uc3RydWN0b3I6bmFtZX1cIlxuXHRcblxuIyBSb290U2NvcGUgaXMgd3Jvbmc/IFJhdGhlciBUb3BTY29wZSBvciBQcm9ncmFtU2NvcGVcbmV4cG9ydCBjbGFzcyBSb290U2NvcGUgPCBTY29wZVxuXG5cdHByb3Agd2FybmluZ3Ncblx0cHJvcCBzY29wZXNcblx0cHJvcCBlbnRpdGllc1xuXG5cdGRlZiBpbml0aWFsaXplXG5cdFx0c3VwZXJcblxuXHRcdHJlZ2lzdGVyICdnbG9iYWwnLCBzZWxmLCB0eXBlOiAnZ2xvYmFsJ1xuXHRcdHJlZ2lzdGVyICdtb2R1bGUnLCBzZWxmLCB0eXBlOiAnZ2xvYmFsJ1xuXHRcdHJlZ2lzdGVyICd3aW5kb3cnLCBzZWxmLCB0eXBlOiAnZ2xvYmFsJ1xuXHRcdHJlZ2lzdGVyICdkb2N1bWVudCcsIHNlbGYsIHR5cGU6ICdnbG9iYWwnXG5cdFx0cmVnaXN0ZXIgJ2V4cG9ydHMnLCBzZWxmLCB0eXBlOiAnZ2xvYmFsJ1xuXHRcdHJlZ2lzdGVyICdjb25zb2xlJywgc2VsZiwgdHlwZTogJ2dsb2JhbCdcblx0XHRyZWdpc3RlciAncHJvY2VzcycsIHNlbGYsIHR5cGU6ICdnbG9iYWwnXG5cdFx0cmVnaXN0ZXIgJ3BhcnNlSW50Jywgc2VsZiwgdHlwZTogJ2dsb2JhbCdcblx0XHRyZWdpc3RlciAncGFyc2VGbG9hdCcsIHNlbGYsIHR5cGU6ICdnbG9iYWwnXG5cdFx0cmVnaXN0ZXIgJ3NldFRpbWVvdXQnLCBzZWxmLCB0eXBlOiAnZ2xvYmFsJ1xuXHRcdHJlZ2lzdGVyICdzZXRJbnRlcnZhbCcsIHNlbGYsIHR5cGU6ICdnbG9iYWwnXG5cdFx0cmVnaXN0ZXIgJ2NsZWFyVGltZW91dCcsIHNlbGYsIHR5cGU6ICdnbG9iYWwnXG5cdFx0cmVnaXN0ZXIgJ2NsZWFySW50ZXJ2YWwnLCBzZWxmLCB0eXBlOiAnZ2xvYmFsJ1xuXHRcdHJlZ2lzdGVyICdfX2Rpcm5hbWUnLCBzZWxmLCB0eXBlOiAnZ2xvYmFsJ1xuXG5cdFx0IyBwcmVyZWdpc3RlciBnbG9iYWwgc3BlY2lhbCB2YXJpYWJsZXMgaGVyZVxuXHRcdEB3YXJuaW5ncyA9IFtdXG5cdFx0QHNjb3BlcyAgID0gW11cblx0XHRAaGVscGVycyAgPSBbXVxuXHRcdEBlbnRpdGllcyA9IEVudGl0aWVzLm5ldyhzZWxmKVxuXHRcdEBoZWFkID0gW0B2YXJzXVxuXG5cdGRlZiBjb250ZXh0XG5cdFx0QGNvbnRleHQgfHw9IFJvb3RTY29wZUNvbnRleHQubmV3KHNlbGYpXG5cblx0ZGVmIHRhZ0NvbnRleHRQYXRoXG5cdFx0QHRhZ0NvbnRleHRQYXRoIHx8PSBcInRhZyRcIlxuXG5cdGRlZiBsb29rdXAgbmFtZVxuXHRcdCMgcCBcImxvb2t1cCBmaWxlc2NvcGVcIlxuXHRcdG5hbWUgPSBoZWxwZXJzLnN5bWJvbGl6ZShuYW1lKVxuXHRcdEB2YXJtYXBbbmFtZV0gaWYgQHZhcm1hcC5oYXNPd25Qcm9wZXJ0eShuYW1lKVxuXG5cdGRlZiB2aXNpdFxuXHRcdFNUQUNLLmFkZFNjb3BlKHNlbGYpXG5cdFx0c2VsZlxuXG5cdGRlZiBoZWxwZXIgdHlwLCB2YWx1ZVxuXHRcdCMgbG9nIFwiYWRkIGhlbHBlclwiLHR5cCx2YWx1ZVxuXHRcdGlmIEBoZWxwZXJzLmluZGV4T2YodmFsdWUpID09IC0xXG5cdFx0XHRAaGVscGVycy5wdXNoKHZhbHVlKVxuXHRcdFx0QGhlYWQudW5zaGlmdCh2YWx1ZSlcblxuXHRcdHJldHVybiBzZWxmXG5cblx0ZGVmIGhlYWRcblx0XHRAaGVhZFxuXG5cdGRlZiB3YXJuIGRhdGFcblx0XHQjIGhhY2t5XG5cdFx0ZGF0YTpub2RlID0gbnVsbFxuXHRcdCMgcCBcIndhcm5pbmdcIixKU09OLnN0cmluZ2lmeShkYXRhKVxuXHRcdEB3YXJuaW5ncy5wdXNoKGRhdGEpXG5cdFx0c2VsZlxuXG5cdGRlZiBkdW1wXG5cdFx0dmFyIG9iaiA9IHt3YXJuaW5nczogZHVtcF9fKEB3YXJuaW5ncyl9XG5cblx0XHRpZiBPUFRTOmFuYWx5c2lzOnNjb3Blc1xuXHRcdFx0dmFyIHNjb3BlcyA9IEBzY29wZXMubWFwKHxzfCBzLmR1bXApXG5cdFx0XHRzY29wZXMudW5zaGlmdChzdXBlci5kdW1wKVxuXHRcdFx0b2JqOnNjb3BlcyA9IHNjb3BlcyBcblxuXHRcdGlmIE9QVFM6YW5hbHlzaXM6ZW50aXRpZXNcblx0XHRcdG9iajplbnRpdGllcyA9IEBlbnRpdGllc1xuXG5cdFx0cmV0dXJuIG9ialxuXHRcdFxuXG5leHBvcnQgY2xhc3MgQ2xhc3NTY29wZSA8IFNjb3BlXG5cblx0ZGVmIG5hbWVwYXRoXG5cdFx0QG5vZGUubmFtZXBhdGhcblx0XG5cblx0IyBjYWxsZWQgZm9yIHNjb3BlcyB0aGF0IGFyZSBub3QgcmVhbCBzY29wZXMgaW4ganNcblx0IyBtdXN0IGVuc3VyZSB0aGF0IHRoZSBsb2NhbCB2YXJpYWJsZXMgaW5zaWRlIG9mIHRoZSBzY29wZXMgZG8gbm90XG5cdCMgY29sbGlkZSB3aXRoIHZhcmlhYmxlcyBpbiBvdXRlciBzY29wZXMgLS0gcmVuYW1lIGlmIG5lZWRlZFxuXHRkZWYgdmlydHVhbGl6ZVxuXHRcdCMgY29uc29sZS5sb2cgXCJ2aXJ0dWFsaXppbmcgQ2xhc3NTY29wZVwiXG5cdFx0dmFyIHVwID0gcGFyZW50XG5cdFx0Zm9yIG93biBrLHYgb2YgQHZhcm1hcFxuXHRcdFx0dHJ1ZVxuXHRcdFx0di5yZXNvbHZlKHVwLHllcykgIyBmb3JjZSBuZXcgcmVzb2x2ZVxuXHRcdHNlbGZcblxuXHRkZWYgaXNDbG9zZWRcblx0XHR5ZXNcblxuZXhwb3J0IGNsYXNzIFRhZ1Njb3BlIDwgQ2xhc3NTY29wZVxuXG5leHBvcnQgY2xhc3MgQ2xvc3VyZVNjb3BlIDwgU2NvcGVcblxuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uU2NvcGUgPCBTY29wZVxuXG5leHBvcnQgY2xhc3MgTWV0aG9kU2NvcGUgPCBTY29wZVxuXHRcblxuXHRkZWYgaXNDbG9zZWRcblx0XHR5ZXNcblxuZXhwb3J0IGNsYXNzIExhbWJkYVNjb3BlIDwgU2NvcGVcblxuXHRkZWYgY29udGV4dFxuXG5cdFx0IyB3aGVuIGFjY2Vzc2luZyB0aGUgb3V0ZXIgY29udGV4dCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGl0IGlzIGNhY2hlZFxuXHRcdCMgc28gdGhpcyBpcyB3cm9uZyAtIGJ1dCB0ZW1wIG9rYXlcblx0XHRAY29udGV4dCB8fD0gcGFyZW50LmNvbnRleHQucmVmZXJlbmNlKHNlbGYpXG5cbmV4cG9ydCBjbGFzcyBGbG93U2NvcGUgPCBTY29wZVxuXG5cdCMgdGhlc2UgaGF2ZSBubyBwYXJhbXMgdGhlbXNlbHZlcywgcmVmZXIgdG8gb3V0ZXIgc2NvcGVzIC0tIGhqbW1cblx0ZGVmIHBhcmFtc1xuXHRcdEBwYXJlbnQucGFyYW1zIGlmIEBwYXJlbnRcblxuXHRkZWYgcmVnaXN0ZXIgbmFtZSwgZGVjbCA9IG51bGwsIG8gPSB7fVxuXHRcdGlmIG86dHlwZSAhPSAnbGV0JyBhbmQgKGNsb3N1cmUgIT0gc2VsZilcblx0XHRcdGlmIHZhciBmb3VuZCA9IGxvb2t1cChuYW1lKVxuXHRcdFx0XHQjIHAgXCJhbHJlYWR5IGZvdW5kIHZhcmlhYmxlIHtmb3VuZC50eXBlfVwiXG5cdFx0XHRcdGlmIGZvdW5kLnR5cGUgPT0gJ2xldCdcblx0XHRcdFx0XHRwIFwie25hbWV9IGFscmVhZHkgZXhpc3RzIGFzIGEgYmxvY2stdmFyaWFibGUge2RlY2x9XCJcblx0XHRcdFx0XHQjIFRPRE8gc2hvdWxkIHRocm93IGVycm9yIGluc3RlYWRcblx0XHRcdFx0XHRkZWNsLndhcm4gXCJWYXJpYWJsZSBhbHJlYWR5IGV4aXN0cyBpbiBibG9ja1wiIGlmIGRlY2xcblx0XHRcdFx0XHQjIHJvb3Qud2FybiBtZXNzYWdlOiBcIkhvbHkgc2hpdFwiXG5cdFx0XHRcdCMgaWYgZm91bmQuXG5cdFx0XHQjIHAgXCJGbG93U2NvcGUgcmVnaXN0ZXIgdmFyIC0tIGRvIGl0IHJpZ2h0IGluIHRoZSBvdXRlciBzY29wZVwiXG5cdFx0XHRjbG9zdXJlLnJlZ2lzdGVyKG5hbWUsZGVjbCxvKVxuXHRcdGVsc2Vcblx0XHRcdCMgcCBcIlJlZ2lzdGVyIGxvY2FsIHZhcmlhYmxlIGZvciBGbG93U2NvcGUge25hbWV9XCJcblx0XHRcdCMgbzpjbG9zdXJlID0gcGFyZW50XG5cdFx0XHQjIHAgXCJGbG93U2NvcGUgcmVnaXN0ZXJcIiwgYXJndW1lbnRzXG5cdFx0XHRzdXBlcihuYW1lLGRlY2wsbylcblxuXHQjIEZJWE1FIHNob3VsZCBvdmVycmlkZSB0ZW1wb3JhcnkgYXMgd2VsbFxuXG5cdGRlZiBhdXRvZGVjbGFyZSB2YXJpYWJsZVxuXHRcdHBhcmVudC5hdXRvZGVjbGFyZSh2YXJpYWJsZSlcblxuXHRkZWYgY2xvc3VyZVxuXHRcdCMgcmF0aGVyIGFsbCB0aGUgd2F5P1xuXHRcdEBwYXJlbnQuY2xvc3VyZSAjIHRoaXMgaXMgaW1wb3J0YW50P1xuXG5cdGRlZiBjb250ZXh0XG5cdFx0IyBpZiB3ZSBhcmUgd3JhcHBpbmcgaW4gYW4gZXhwcmVzc2lvbiAtIHdlIGRvIG5lZWQgdG8gYWRkIGEgcmVmZXJlbmNlXG5cdFx0IyBAcmVmZXJlbmNlZCA9IHllc1xuXHRcdHBhcmVudC5jb250ZXh0XG5cdFx0IyB1c3VhbGx5IC0gaWYgdGhlIHBhcmVudCBzY29wZSBpcyBhIGNsb3NlZCBzY29wZSB3ZSBkb250IHJlYWxseSBuZWVkXG5cdFx0IyB0byBmb3JjZSBhIHJlZmVyZW5jZVxuXHRcdCMgQGNvbnRleHQgfHw9IHBhcmVudC5jb250ZXh0LnJlZmVyZW5jZShzZWxmKVxuXG5leHBvcnQgY2xhc3MgQ2F0Y2hTY29wZSA8IEZsb3dTY29wZVxuXG5leHBvcnQgY2xhc3MgV2hpbGVTY29wZSA8IEZsb3dTY29wZVxuXG5cdGRlZiBhdXRvZGVjbGFyZSB2YXJpYWJsZVxuXHRcdHZhcnMucHVzaCh2YXJpYWJsZSlcblxuZXhwb3J0IGNsYXNzIEZvclNjb3BlIDwgRmxvd1Njb3BlXG5cdFxuXHRkZWYgYXV0b2RlY2xhcmUgdmFyaWFibGVcblx0XHR2YXJzLnB1c2godmFyaWFibGUpXG5cdFx0IyBwYXJlbnQuYXV0b2RlY2xhcmUodmFyaWFibGUpXG5cblx0IyBkZWYgY2xvc3VyZVxuXHQjIFx0c2VsZlxuXG5leHBvcnQgY2xhc3MgSWZTY29wZSA8IEZsb3dTY29wZVxuXG5cdGRlZiB0ZW1wb3JhcnkgcmVmbm9kZSwgbyA9IHt9LCBuYW1lID0gbnVsbFxuXHRcdHBhcmVudC50ZW1wb3JhcnkocmVmbm9kZSxvLG5hbWUpXG5cbmV4cG9ydCBjbGFzcyBCbG9ja1Njb3BlIDwgRmxvd1Njb3BlXG5cblx0ZGVmIHRlbXBvcmFyeSByZWZub2RlLCBvID0ge30sIG5hbWUgPSBudWxsXG5cdFx0cGFyZW50LnRlbXBvcmFyeShyZWZub2RlLG8sbmFtZSlcblxuXHRkZWYgcmVnaW9uXG5cdFx0bm9kZS5yZWdpb25cblxuIyBsaXZlcyBpbiBzY29wZSAtLSByZWFsbHkgYSBub2RlPz8/XG5leHBvcnQgY2xhc3MgVmFyaWFibGUgPCBOb2RlXG5cblx0cHJvcCBzY29wZVxuXHRwcm9wIG5hbWVcblx0cHJvcCBhbGlhc1xuXHRwcm9wIHR5cGVcblx0cHJvcCBvcHRpb25zXG5cdHByb3AgaW5pdGlhbGl6ZWRcblx0cHJvcCBkZWNsYXJlZFxuXHRwcm9wIGRlY2xhcmF0b3Jcblx0cHJvcCBhdXRvZGVjbGFyZVxuXHRwcm9wIHJlZmVyZW5jZXNcblx0cHJvcCBleHBvcnRcblxuXHRkZWYgcG9vbFxuXHRcdG51bGxcblxuXHRkZWYgaW5pdGlhbGl6ZSBzY29wZSwgbmFtZSwgZGVjbCwgb1xuXHRcdEByZWYgPSBTVEFDSy5AY291bnRlcisrXG5cdFx0QGMgPSBudWxsXG5cdFx0QHNjb3BlID0gc2NvcGVcblx0XHRAbmFtZSAgPSBuYW1lXG5cdFx0QGFsaWFzID0gbnVsbFxuXHRcdEBpbml0aWFsaXplZCAgICA9IHllc1xuXHRcdEBkZWNsYXJhdG9yICBcdD0gZGVjbFxuXHRcdEBhdXRvZGVjbGFyZSBcdD0gbm9cblx0XHRAZGVjbGFyZWRcdFx0PSBvIGFuZCBvOmRlY2xhcmVkIHx8IG5vXG5cdFx0QHJlc29sdmVkXHRcdD0gbm9cblx0XHRAb3B0aW9ucyBcdFx0PSBvIHx8IHt9XG5cdFx0QHR5cGVcdFx0XHQ9IG8gYW5kIG86dHlwZSB8fCAndmFyJyAjIHdoYXQgYWJvdXQgbGV0IGhlcmU9XG5cdFx0QGV4cG9ydFx0XHRcdD0gbm9cblx0XHRAcmVmZXJlbmNlcyBcdD0gW10gIyBvbmx5IG5lZWRlZCB3aGVuIHByb2ZpbGluZ1xuXHRcdEBhc3NpZ25tZW50cyBcdD0gW11cblx0XHRzZWxmXG5cblx0ZGVmIGNsb3N1cmVcblx0XHRAc2NvcGUuY2xvc3VyZVxuXG5cdGRlZiBhc3NpZ25tZW50c1xuXHRcdEBhc3NpZ25tZW50c1xuXG5cdCMgSGVyZSB3ZSBjYW4gY29sbGVjdCBsb3RzIG9mIHR5cGUtaW5mbyBhYm91dCB2YXJpYWJsZXNcblx0IyBhbmQgc2hvdyB3YXJuaW5ncyAvIGdpdmUgYWR2aWNlIGlmIHZhcmlhYmxlcyBhcmUgYW1iaWd1b3VzIGV0Y1xuXHRkZWYgYXNzaWduZWQgdmFsLCBzb3VyY2Vcblx0XHRAYXNzaWdubWVudHMucHVzaCh2YWwpXG5cdFx0IyBwIFwiVmFyaWFibGUgd2FzIGFzc2lnbmVkIHt2YWx9XCJcblx0XHRpZiB2YWwgaXNhIEFyclxuXHRcdFx0IyBqdXN0IGZvciB0ZXN0aW5nIHJlYWxseVxuXHRcdFx0QGlzQXJyYXkgPSB5ZXNcblx0XHRlbHNlXG5cdFx0XHRAaXNBcnJheSA9IG5vXG5cdFx0c2VsZlxuXG5cdGRlZiByZXNvbHZlIHNjb3BlID0gc2NvcGUsIGZvcmNlID0gbm9cblx0XHRyZXR1cm4gc2VsZiBpZiBAcmVzb2x2ZWQgYW5kICFmb3JjZVxuXG5cdFx0QHJlc29sdmVkID0geWVzXG5cdFx0dmFyIGNsb3N1cmUgPSBAc2NvcGUuY2xvc3VyZVxuXHRcdHZhciBpdGVtID0gc2NvcGUubG9va3VwKEBuYW1lKVxuXG5cdFx0IyBpZiB0aGlzIGlzIGEgbGV0LWRlZmluaXRpb24gaW5zaWRlIGEgdmlydHVhbCBzY29wZSB3ZSBkbyBuZWVkXG5cdFx0IyBcblx0XHRpZiBAc2NvcGUgIT0gY2xvc3VyZSBhbmQgQHR5cGUgPT0gJ2xldCcgIyBvciBpZiBpdCBpcyBhIHN5c3RlbS12YXJpYWJsZVxuXHRcdFx0IyBwIFwic2NvcGUgaXMgbm90IHRoZSBjbG9zdXJlIC0tIG5lZWQgdG8gcmVzb2x2ZSB7QG5hbWV9XCJcblx0XHRcdGl0ZW0gPSBjbG9zdXJlLmxvb2t1cChAbmFtZSlcblxuXHRcdFx0IyB3ZSBub3cgbmVlZCB0byBlbnN1cmUgdGhhdCB0aGlzIHZhcmlhYmxlIGlzIHVuaXF1ZSBpbnNpZGVcblx0XHRcdCMgdGhlIHdob2xlIGNsb3N1cmUuXG5cdFx0XHRzY29wZSA9IGNsb3N1cmVcblxuXHRcdCMgcCBcInNjb3BlIGlzIG5vdCB0aGUgY2xvc3VyZSAtLSBuZWVkIHRvIHJlc29sdmUge0BuYW1lfSB7QHR5cGV9XCJcblxuXHRcdGlmIGl0ZW0gPT0gc2VsZlxuXHRcdFx0c2NvcGUudmFybWFwW0BuYW1lXSA9IHNlbGZcblx0XHRcdHJldHVybiBzZWxmXG5cblx0XHQjIHAgXCJuZWVkIHRvIHJlc29sdmUhXCIuY3lhblxuXHRcdGVsaWYgaXRlbVxuXHRcdFx0IyBwIFwidmFyaWFibGUgYWxyZWFkeSBleGlzdHMge0BuYW1lfVwiXG5cblx0XHRcdCMgcG9zc2libHkgcmVkZWZpbmUgdGhpcyBpbnNpZGUsIHVzZSBpdCBvbmx5IGluIHRoaXMgc2NvcGVcblx0XHRcdCMgaWYgdGhlIGl0ZW0gaXMgZGVmaW5lZCBpbiBhbiBvdXRlciBzY29wZSAtIHdlIHJlc2VydmUgdGhlXG5cdFx0XHRpZiBpdGVtLnNjb3BlICE9IHNjb3BlICYmIChvcHRpb25zOmxldCBvciBAdHlwZSA9PSAnbGV0Jylcblx0XHRcdFx0IyBwIFwib3ZlcnJpZGUgdmFyaWFibGUgaW5zaWRlIHRoaXMgc2NvcGUge0BuYW1lfVwiXG5cdFx0XHRcdHNjb3BlLnZhcm1hcFtAbmFtZV0gPSBzZWxmXG5cblx0XHRcdCMgZGlmZmVyZW50IHJ1bGVzIGZvciBkaWZmZXJlbnQgdmFyaWFibGVzP1xuXHRcdFx0aWYgQG9wdGlvbnM6cHJveHlcblx0XHRcdFx0IyBwIFwiaXMgcHJveHkgLS0gbm8gbmVlZCB0byBjaGFuZ2UgbmFtZSEhISB7bmFtZX1cIi5jeWFuXG5cdFx0XHRcdHllc1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHR2YXIgaSA9IDBcblx0XHRcdFx0dmFyIG9yaWcgPSBAbmFtZVxuXHRcdFx0XHQjIGl0IGlzIHRoZSBjbG9zdXJlIHRoYXQgd2Ugc2hvdWxkIHVzZVxuXHRcdFx0XHR3aGlsZSBzY29wZS5sb29rdXAoQG5hbWUpXG5cdFx0XHRcdFx0QG5hbWUgPSBcIntvcmlnfXtpICs9IDF9XCJcblxuXHRcdCMgaW5lZmZpY2llbnQgZG91YmxlIHNldHRpbmdcblx0XHRzY29wZS52YXJtYXBbQG5hbWVdID0gc2VsZlxuXHRcdGNsb3N1cmUudmFybWFwW0BuYW1lXSA9IHNlbGZcblx0XHRyZXR1cm4gc2VsZlxuXHRcdCMgcCBcInJlc29sdmUgdmFyaWFibGVcIi5jeWFuXG5cblx0ZGVmIHJlZmVyZW5jZVxuXHRcdHNlbGZcblxuXHRkZWYgbm9kZVxuXHRcdHNlbGZcblxuXHRkZWYgdHJhdmVyc2Vcblx0XHQjIE5PREVTLnB1c2goc2VsZilcblx0XHRzZWxmXG5cblx0ZGVmIGZyZWUgcmVmXG5cdFx0IyBwIFwiZnJlZSB2YXJpYWJsZSFcIlxuXHRcdEBkZWNsYXJhdG9yID0gbnVsbFxuXHRcdHNlbGZcblxuXHRkZWYgcmV1c2UgcmVmXG5cdFx0QGRlY2xhcmF0b3IgPSByZWZcblx0XHRzZWxmXG5cblx0ZGVmIHByb3h5IHBhciwgaW5kZXhcblx0XHRAcHJveHkgPSBbcGFyLGluZGV4XVxuXHRcdHNlbGZcblxuXHRkZWYgcmVmY291bnRcblx0XHRAcmVmZXJlbmNlczpsZW5ndGhcblxuXHRkZWYgY1xuXHRcdHJldHVybiBAYyBpZiBAY1xuXHRcdCMgb3B0aW9ucyAtIHByb3h5Pz9cblx0XHRpZiBAcHJveHlcblx0XHRcdCMgcCBcInZhciBpcyBwcm94aWVkIVwiLEBwcm94eVxuXHRcdFx0QGMgPSBAcHJveHlbMF0uYyArICdbJyArIEBwcm94eVsxXS5jICsgJ10nXG5cdFx0ZWxzZVxuXHRcdFx0cmVzb2x2ZSB1bmxlc3MgQHJlc29sdmVkXG5cdFx0XHR2YXIgdiA9IChhbGlhcyBvciBuYW1lKVxuXHRcdFx0QGMgPSB0eXBlb2YgdiA9PSAnc3RyaW5nJyA/IHYgOiB2LmNcblx0XHRcdCMgYWxsb3cgY2VydGFpbiByZXNlcnZlZCB3b3Jkc1xuXHRcdFx0IyBzaG91bGQgd2FybiBvbiBvdGhlcnMgdGhvdWdoICghISEpXG5cdFx0XHQjIGlmIEBjID09ICduZXcnXG5cdFx0XHQjIFx0QGMgPSAnX25ldydcblx0XHRcdCMgXHQjIHNob3VsZCBoYXBwZW4gYXQgZWFybGllciBzdGFnZSB0b1xuXHRcdFx0IyBcdCMgZ2V0IGFyb3VuZCBuYW1pbmcgY29udmVudGlvbnNcblx0XHRcdEBjID0gXCJ7Y30kXCIgaWYgUkVTRVJWRURfUkVHRVgudGVzdChAYykgIyBAYy5tYXRjaCgvXihkZWZhdWx0KSQvKVxuXHRcdHJldHVybiBAY1xuXG5cdCMgdmFyaWFibGVzIHNob3VsZCBwcm9iYWJseSBpbmhlcml0IGZyb20gbm9kZSghKVxuXHRkZWYgY29uc3VtZSBub2RlXG5cdFx0IyBwIFwidmFyaWFibGUgYXNzaWduaWZ5ISEhXCJcblx0XHRyZXR1cm4gc2VsZlxuXG5cdCMgdGhpcyBzaG91bGQgb25seSBnZW5lcmF0ZSB0aGUgYWNjZXNzb3JzIC0gbm90IGRhZWwgd2l0aCByZWZlcmVuY2VzXG5cdGRlZiBhY2Nlc3NvciByZWZcblx0XHR2YXIgbm9kZSA9IExvY2FsVmFyQWNjZXNzLm5ldyhcIi5cIixudWxsLHNlbGYpICMgdGhpcyBpcyBqdXN0IHdyb25nIC4uIHNob3VsZCBub3QgYmUgYSByZWd1bGFyIGFjY2Vzc29yXG5cdFx0IyBAcmVmZXJlbmNlcy5wdXNoKFtyZWYsZWxdKSBpZiByZWYgIyB3ZWlyZCB0ZW1wIGZvcm1hdFxuXHRcdHJldHVybiBub2RlXG5cblx0ZGVmIGFzc2lnbm1lbnQgdmFsXG5cdFx0QXNzaWduLm5ldygnPScsc2VsZix2YWwpXG5cblx0ZGVmIGFkZFJlZmVyZW5jZSByZWZcblx0XHRpZiByZWYgaXNhIElkZW50aWZpZXJcblx0XHRcdHJlZi5yZWZlcmVuY2VzKHNlbGYpXG5cblx0XHRpZiByZWY6cmVnaW9uIGFuZCByZWYucmVnaW9uXG5cdFx0XHRAcmVmZXJlbmNlcy5wdXNoKHJlZilcblxuXHRcdCMgcCBcInJlZmVyZW5jZSBpcyB7cmVmOnJlZ2lvbiBhbmQgcmVmLnJlZ2lvbn1cIlxuXHRcdHNlbGZcblxuXHRkZWYgYXV0b2RlY2xhcmVcblx0XHRyZXR1cm4gc2VsZiBpZiBAZGVjbGFyZWRcblx0XHQjIHAgXCJ2YXJpYWJsZSBzaG91bGQgYXV0b2RlY2xhcmUoISkge25hbWV9XCJcblx0XHRAYXV0b2RlY2xhcmUgPSB5ZXNcblx0XHRzY29wZS5hdXRvZGVjbGFyZShzZWxmKVxuXHRcdEBkZWNsYXJlZCA9IHllc1xuXHRcdHNlbGZcblxuXHRkZWYgcHJlZGVjbGFyZWRcblx0XHRAZGVjbGFyZWQgPSB5ZXNcblx0XHRzZWxmXG5cdFx0XG5cblx0ZGVmIHRvU3RyaW5nXG5cdFx0U3RyaW5nKG5hbWUpXG5cblx0ZGVmIGR1bXAgdHlwXG5cdFx0dmFyIG5hbWUgPSBuYW1lXG5cdFx0cmV0dXJuIG51bGwgaWYgbmFtZVswXS5tYXRjaCgvW0EtWl0vKVxuXHRcdCMgY29uc29sZS5sb2cgXCJkdW1wIHZhcmlhYmxlIG9mIHR5cGUge3R5cGV9IC0ge25hbWV9XCJcblx0XHRyZXR1cm4ge1xuXHRcdFx0dHlwZTogdHlwZVxuXHRcdFx0bmFtZTogbmFtZVxuXHRcdFx0cmVmczogZHVtcF9fKEByZWZlcmVuY2VzLCB0eXApXG5cdFx0fVxuXG5cbmV4cG9ydCBjbGFzcyBTeXN0ZW1WYXJpYWJsZSA8IFZhcmlhYmxlXG5cdFxuXHRkZWYgcG9vbFxuXHRcdEBvcHRpb25zOnBvb2xcblx0XHRcblx0IyB3ZWlyZCBuYW1lIGZvciB0aGlzXG5cdGRlZiBwcmVkZWNsYXJlZFxuXHRcdCMgcCBcInJlbW92ZSB2YXIgZnJvbSBzY29wZSghKVwiXG5cdFx0c2NvcGUudmFycy5yZW1vdmUoc2VsZilcblx0XHRzZWxmXG5cdFxuXHRkZWYgcmVzb2x2ZVxuXHRcdHJldHVybiBzZWxmIGlmIEByZXNvbHZlZCB8fCBAbmFtZVxuXHRcdCMgcCBcIlJFU09MVkUgU1lTVEVNIFZBUklBQkxFXCIucmVkXG5cdFx0QHJlc29sdmVkID0geWVzXG5cdFx0IyB1bmxlc3MgQG5hbWVcblx0XHQjIGFkZHMgYSB2ZXJ5IHJhbmRvbSBpbml0aWFsIG5hbWVcblx0XHQjIHRoZSBhdXRvLW1hZ2ljYWwgZ29lcyBsYXN0LCBvciBhdCBsZWFzdCwgcG9zc2libHkgcmV1c2Ugb3RoZXIgbmFtZXNcblx0XHQjIFwiJHtNYXRoLmZsb29yKE1hdGgucmFuZG9tICogMTAwMCl9XCJcblxuXHRcdHZhciB0eXAgPSBAb3B0aW9uczpwb29sXG5cdFx0dmFyIG5hbWVzID0gW10uY29uY2F0KEBvcHRpb25zOm5hbWVzKVxuXHRcdHZhciBhbHQgPSBudWxsXG5cdFx0dmFyIG5vZGUgPSBudWxsXG5cblx0XHR2YXIgc2NvcGUgPSBzZWxmLnNjb3BlXG5cblx0XHRpZiB0eXAgPT0gJ3RhZydcblx0XHRcdHZhciBpID0gMFxuXHRcdFx0d2hpbGUgIUBuYW1lXG5cdFx0XHRcdHZhciBhbHQgPSBcInR7aSsrfVwiXG5cdFx0XHRcdEBuYW1lID0gYWx0IHVubGVzcyBzY29wZS5sb29rdXAoYWx0KVxuXG5cdFx0ZWxpZiB0eXAgPT0gJ2l0ZXInXG5cdFx0XHRuYW1lcyA9IFsnYXJ5X18nLCdhcnlfJywnY29sbCcsJ2FycmF5JywnaXRlbXMnLCdhcnknXVxuXG5cdFx0ZWxpZiB0eXAgPT0gJ3ZhbCdcblx0XHRcdG5hbWVzID0gWyd2XyddXG5cblx0XHRlbGlmIHR5cCA9PSAnYXJndW1lbnRzJ1xuXHRcdFx0bmFtZXMgPSBbJyRfJywnJDAnXVxuXG5cdFx0ZWxpZiB0eXAgPT0gJ2tleXBhcnMnXG5cdFx0XHRuYW1lcyA9IFsnb3B0cycsJ29wdGlvbnMnLCdwYXJzJ11cblxuXHRcdGVsaWYgdHlwID09ICdjb3VudGVyJ1xuXHRcdFx0bmFtZXMgPSBbJ2lfXycsJ2lfJywnaycsJ2onLCdpJ11cblxuXHRcdGVsaWYgdHlwID09ICdsZW4nXG5cdFx0XHRuYW1lcyA9IFsnbGVuX18nLCdsZW5fJywnbGVuJ11cblxuXHRcdGVsaWYgdHlwID09ICdsaXN0J1xuXHRcdFx0bmFtZXMgPSBbJ3RtcGxpc3RfJywndG1wbGlzdCcsJ3RtcCddXG5cdFx0IyBvciBpZiB0eXBlIHBsYWNlaG9sZGVyIC8gY2FjaGVyIChhZGQgMClcblxuXHRcdHdoaWxlICFAbmFtZSAmJiBhbHQgPSBuYW1lcy5wb3Bcblx0XHRcdEBuYW1lID0gYWx0IHVubGVzcyBzY29wZS5sb29rdXAoYWx0KVxuXG5cdFx0aWYgIUBuYW1lIGFuZCBAZGVjbGFyYXRvclxuXHRcdFx0aWYgbm9kZSA9IGRlY2xhcmF0b3Iubm9kZVxuXHRcdFx0XHRuYW1lcy5wdXNoKGFsaWFzICsgXCJfXCIpIGlmIHZhciBhbGlhcyA9IG5vZGUuYWxpYXNcblxuXHRcdHdoaWxlICFAbmFtZSAmJiBhbHQgPSBuYW1lcy5wb3Bcblx0XHRcdEBuYW1lID0gYWx0IHVubGVzcyBzY29wZS5sb29rdXAoYWx0KVxuXG5cdFx0IyBwIFwic3VnZ2VzdGVkIG5hbWVzIHtuYW1lcy5qb2luKFwiICwgXCIpfSB7bm9kZX1cIi5jeWFuXG5cdFx0IyAgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSAqIDEwMDApXG5cdFx0QG5hbWUgfHw9IFwiJHtzY29wZS5jb3VudGVyICs9IDF9XCJcblx0XHQjIHAgXCJuYW1lIGZvciB2YXJpYWJsZSBpcyB7QG5hbWV9XCJcblx0XHRzY29wZS52YXJtYXBbQG5hbWVdID0gc2VsZlxuXHRcdHNlbGZcblxuXHRkZWYgbmFtZVxuXHRcdHJlc29sdmVcblx0XHRAbmFtZVxuXG5cbmV4cG9ydCBjbGFzcyBTY29wZUNvbnRleHQgPCBOb2RlXG5cblx0cHJvcCBzY29wZVxuXHRwcm9wIHZhbHVlXG5cblx0ZGVmIGluaXRpYWxpemUgc2NvcGUsIHZhbHVlXG5cdFx0QHNjb3BlID0gc2NvcGVcblx0XHRAdmFsdWUgPSB2YWx1ZVxuXHRcdEByZWZlcmVuY2UgPSBudWxsXG5cdFx0c2VsZlxuXG5cdGRlZiBuYW1lcGF0aFxuXHRcdEBzY29wZS5uYW1lcGF0aFxuXG5cdCMgaW5zdGVhZCBvZiBhbGwgdGhlc2UgcmVmZXJlbmNlcyB3ZSBzaG91bGQgcHJvYmFibHlcblx0IyBqdXN0IHJlZ2lzdGVyIHdoZW4gaXQgaXMgYWNjZXNzZWQgLyBsb29rZWQgdXAgZnJvbVxuXHQjIGEgZGVlcGVyIGZ1bmN0aW9uLXNjb3BlLCBhbmQgd2hlbiBpdCBpcywgd2Ugc2hvdWxkXG5cdCMgcmVnaXN0ZXIgdGhlIHZhcmlhYmxlIGluIHNjb3BlLCBhbmQgdGhlbiBzdGFydCB0b1xuXHQjIHVzZSB0aGF0IGZvciBmdXJ0aGVyIHJlZmVyZW5jZXMuIE1pZ2h0IGNsZWFuIHRoaW5nc1xuXHQjIHVwIGZvciB0aGUgY2FzZXMgd2hlcmUgd2UgaGF2ZSB5ZXQgdG8gZGVjaWRlIHRoZVxuXHQjIG5hbWUgb2YgdGhlIHZhcmlhYmxlIGV0Yz9cblxuXHRkZWYgcmVmZXJlbmNlXG5cdFx0IyBwIFwicCByZWZlcmVuY2Uge1NUQUNLLnNjb3Bpbmd9XCJcblx0XHQjIHNob3VsZCBiZSBhIHNwZWNpYWwgY29udGV4dC12YXJpYWJsZSEhIVxuXHRcdEByZWZlcmVuY2UgfHw9IHNjb3BlLmRlY2xhcmUoXCJzZWxmXCIsVGhpcy5uZXcpXG5cblx0ZGVmIGNcblx0XHR2YXIgdmFsID0gQHZhbHVlIHx8IEByZWZlcmVuY2Vcblx0XHQodmFsID8gdmFsLmMgOiBcInRoaXNcIilcblxuXHRkZWYgY2FjaGVcblx0XHRzZWxmXG5cbmV4cG9ydCBjbGFzcyBSb290U2NvcGVDb250ZXh0IDwgU2NvcGVDb250ZXh0XG5cblx0IyBkZWYgcmVmZXJlbmNlIHNjb3BlXG5cdCMgXHRzZWxmXG5cblx0ZGVmIGMgb1xuXHRcdCMgcmV0dXJuIFwiXCIgaWYgbyBhbmQgbzpleHBsaWNpdFxuXHRcdHZhciB2YWwgPSBAdmFsdWUgfHwgQHJlZmVyZW5jZVxuXHRcdHJldHVybiAodmFsIGFuZCB2YWwgIT0gdGhpcykgPyB2YWwuYyA6IFwidGhpc1wiXG5cdFx0IyBzaG91bGQgYmUgdGhlIG90aGVyIHdheSBhcm91bmQsIG5vP1xuXHRcdCMgbyBhbmQgbzpleHBsaWNpdCA/IHN1cGVyIDogXCJcIlxuXHRcdFxuZXhwb3J0IGNsYXNzIFN1cGVyIDwgTm9kZVxuXG5cdGRlZiBjXG5cdFx0IyBuZWVkIHRvIGZpbmQgdGhlIHN0dWZmIGhlcmVcblx0XHQjIHRoaXMgaXMgcmVhbGx5IG5vdCB0aGF0IGdvb2Q4XG5cdFx0dmFyIG0gPSBTVEFDSy5tZXRob2Rcblx0XHR2YXIgb3V0ID0gbnVsbFxuXHRcdHZhciB1cCA9IFNUQUNLLmN1cnJlbnRcblx0XHR2YXIgZGVlcCA9IHVwIGlzYSBBY2Nlc3NcblxuXHRcdCMgVE9ETyBvcHRpbWl6YXRpb24gZm9yIGxhdGVyIC0gcHJvYmxlbWF0aWMgaWYgdGhlcmUgaXMgYSBkaWZmZXJlbnQgcmVmZXJlbmNlIGluIHRoZSBlbmRcblx0XHRpZiBmYWxzZSAmJiBtICYmIG0udHlwZSA9PSA6Y29uc3RydWN0b3Jcblx0XHRcdG91dCA9IFwie20udGFyZ2V0LmN9LnN1cGVyY2xhc3NcIlxuXHRcdFx0b3V0ICs9IFwiLmFwcGx5KHttLnNjb3BlLmNvbnRleHQuY30sYXJndW1lbnRzKVwiIHVubGVzcyBkZWVwXG5cdFx0ZWxzZVxuXHRcdFx0b3V0ID0gXCJ7bS50YXJnZXQuY30uX19zdXBlcl9fXCJcblx0XHRcdHVubGVzcyB1cCBpc2EgQWNjZXNzXG5cdFx0XHRcdG91dCArPSBcIi57Y19fKG0uc3VwZXJuYW1lKX1cIiBcblx0XHRcdFx0dW5sZXNzIHVwIGlzYSBDYWxsICMgYXV0b2NhbGw/XG5cdFx0XHRcdFx0b3V0ICs9IFwiLmFwcGx5KHttLnNjb3BlLmNvbnRleHQuY30sYXJndW1lbnRzKVwiIFxuXHRcdG91dFxuXG4jIGNvbnN0YW50c1xuXG5leHBvcnQgdmFyIEJSID0gTmV3bGluZS5uZXcoJ1xcbicpXG5leHBvcnQgdmFyIEJSMiA9IE5ld2xpbmUubmV3KCdcXG5cXG4nKVxuZXhwb3J0IHZhciBTRUxGID0gU2VsZi5uZXdcbmV4cG9ydCB2YXIgU1VQRVIgPSBTdXBlci5uZXdcblxuZXhwb3J0IHZhciBUUlVFID0gVHJ1ZS5uZXcoJ3RydWUnKVxuZXhwb3J0IHZhciBGQUxTRSA9IEZhbHNlLm5ldygnZmFsc2UnKVxuZXhwb3J0IHZhciBVTkRFRklORUQgPSBVbmRlZmluZWQubmV3XG5leHBvcnQgdmFyIE5JTCA9IE5pbC5uZXdcblxuZXhwb3J0IHZhciBBUkdVTUVOVFMgPSBBcmdzUmVmZXJlbmNlLm5ldygnYXJndW1lbnRzJylcbmV4cG9ydCB2YXIgRU1QVFkgPSAnJ1xuZXhwb3J0IHZhciBOVUxMID0gJ251bGwnXG5cbmV4cG9ydCB2YXIgUkVTRVJWRUQgPSBbJ2RlZmF1bHQnLCduYXRpdmUnLCdlbnVtJywnd2l0aCddXG5leHBvcnQgdmFyIFJFU0VSVkVEX1JFR0VYID0gL14oZGVmYXVsdHxuYXRpdmV8ZW51bXx3aXRofG5ld3xjaGFyKSQvXG5cbmV4cG9ydCB2YXIgVU5JT04gPSBDb25zdC5uZXcoJ3VuaW9uJCcpXG5leHBvcnQgdmFyIElOVEVSU0VDVCA9IENvbnN0Lm5ldygnaW50ZXJzZWN0JCcpXG5leHBvcnQgdmFyIENMQVNTREVGID0gQ29uc3QubmV3KCdpbWJhJGNsYXNzJylcbmV4cG9ydCB2YXIgVEFHREVGID0gQ29uc3QubmV3KCdJbWJhLlRBR1MuZGVmaW5lJylcbmV4cG9ydCB2YXIgTkVXVEFHID0gSWRlbnRpZmllci5uZXcoXCJ0YWckXCIpXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHNyYy9jb21waWxlci9ub2Rlcy5pbWJhXG4gKiovIiwiXG5pbXBvcnQgJ3BhdGgnIGFzIHBhdGhcbmltcG9ydCAnLi9oZWxwZXJzJyBhcyB1dGlsXG5cbmV4cG9ydCBjbGFzcyBTb3VyY2VNYXBcblxuXHRkZWYgc291cmNlXG5cdFx0QHNvdXJjZVxuXG5cdGRlZiBvcHRpb25zXG5cdFx0QHNvdXJjZVxuXG5cdGRlZiBpbml0aWFsaXplIHNvdXJjZVxuXHRcdEBzb3VyY2UgPSBzb3VyY2Vcblx0XHRAbWFwcyA9IFtdXG5cdFx0QG1hcCA9IFwiXCJcblx0XHRAanMgPSBcIlwiXG5cblx0ZGVmIGZpbGVuYW1lXG5cdFx0b3B0aW9uczpvcHRpb25zOmZpbGVuYW1lXG5cblx0ZGVmIHNvdXJjZUNvZGVcblx0XHRvcHRpb25zOm9wdGlvbnMuQHNvdXJjZVxuXG5cdGRlZiB0YXJnZXRQYXRoXG5cdFx0b3B0aW9uczpvcHRpb25zOnRhcmdldFBhdGhcblxuXHRkZWYgc291cmNlUGF0aFxuXHRcdG9wdGlvbnM6b3B0aW9uczpzb3VyY2VQYXRoXG5cblx0ZGVmIHNvdXJjZU5hbWVcblx0XHRwYXRoLmJhc2VuYW1lKHNvdXJjZVBhdGgpXG5cblx0ZGVmIHRhcmdldE5hbWVcblx0XHRwYXRoLmJhc2VuYW1lKHRhcmdldFBhdGgpXG5cdFx0XG5cblx0ZGVmIHNvdXJjZUZpbGVzXG5cdFx0W3NvdXJjZU5hbWVdXG5cblx0ZGVmIHBhcnNlXG5cdFx0dmFyIG1hdGNoZXIgPSAvXFwlXFwkKFxcZCopXFwkXFwlL1xuXHRcdHZhciByZXBsYWNlciA9IC9eKC4qPylcXCVcXCQoXFxkKilcXCRcXCUvXG5cdFx0dmFyIGxpbmVzID0gb3B0aW9uczpqcy5zcGxpdCgvXFxuL2cpICMgd2hhdCBhYm91dCBqcz9cblx0XHQjIHJldHVybiBzZWxmXG5cdFx0dmFyIGxvY21hcCA9IHV0aWwubG9jYXRpb25Ub0xpbmVDb2xNYXAoc291cmNlQ29kZSlcblx0XHRAbWFwcyA9IFtdXG5cblx0XHQjIGNvbnNvbGUubG9nIG9wdGlvbnM6anNcblx0XHRcblx0XHR2YXIgbWF0Y2hcblx0XHQjIHNwbGl0IHRoZSBjb2RlIGluIGxpbmVzLiBnbyB0aHJvdWdoIGVhY2ggbGluZSBcblx0XHQjIGdvIHRocm91Z2ggdGhlIGNvZGUgbG9va2luZyBmb3IgTE9DIG1hcmtlcnNcblx0XHQjIHJlbW92ZSBtYXJrZXJzIGFsb25nIHRoZSB3YXkgYW5kIGtlZXAgdHJhY2sgb2Zcblx0XHQjIGNvbnNvbGUubG9nIHNvdXJjZTpqc1xuXG5cdFx0Zm9yIGxpbmUsaSBpbiBsaW5lc1xuXHRcdFx0IyBjb3VsZCBzcGxpdCBvbiB0aGVzZT9cblx0XHRcdHZhciBjb2wgPSAwXG5cdFx0XHR2YXIgY2FyZXQgPSAwXG5cblx0XHRcdEBtYXBzW2ldID0gW11cblx0XHRcdHdoaWxlIGxpbmUubWF0Y2gobWF0Y2hlcilcblx0XHRcdFx0bGluZSA9IGxpbmUucmVwbGFjZShyZXBsYWNlcikgZG8gfG0scHJlLGxvY3xcblx0XHRcdFx0XHR2YXIgbGMgPSBsb2NtYXBbcGFyc2VJbnQobG9jKV1cblx0XHRcdFx0XHRjYXJldCA9IHByZTpsZW5ndGhcblx0XHRcdFx0XHR2YXIgbWFwcGluZyA9IFsgW2xjWzBdLGxjWzFdXSwgW2ksY2FyZXRdIF0gIyBzb3VyY2UgYW5kIG91dHB1dFxuXHRcdFx0XHRcdEBtYXBzW2ldLnB1c2gobWFwcGluZylcblx0XHRcdFx0XHRyZXR1cm4gcHJlXG5cdFx0XHRsaW5lc1tpXSA9IGxpbmVcblxuXHRcdFxuXHRcdHNvdXJjZTpqcyA9IGxpbmVzLmpvaW4oJ1xcbicpXG5cdFx0c2VsZlxuXG5cdGRlZiBnZW5lcmF0ZVxuXHRcdHBhcnNlXG5cblx0XHR2YXIgbGFzdENvbHVtbiAgICAgICAgPSAwXG5cdFx0dmFyIGxhc3RTb3VyY2VMaW5lICAgID0gMFxuXHRcdHZhciBsYXN0U291cmNlQ29sdW1uICA9IDBcblx0XHR2YXIgYnVmZmVyICAgICAgICAgICAgPSBcIlwiXG5cblx0XHRmb3IgbGluZSxsaW5lTnVtYmVyIGluIEBtYXBzXG5cdFx0XHRsYXN0Q29sdW1uID0gMFxuXG5cdFx0XHRmb3IgbWFwLG5yIGluIGxpbmVcblx0XHRcdFx0YnVmZmVyICs9ICcsJyB1bmxlc3MgbnIgPT0gMFxuXHRcdFx0XHR2YXIgc3JjID0gbWFwWzBdXG5cdFx0XHRcdHZhciBkZXN0ID0gbWFwWzFdXG5cdFx0XHRcdFxuXHRcdFx0XHRidWZmZXIgKz0gZW5jb2RlVmxxKGRlc3RbMV0gLSBsYXN0Q29sdW1uKVxuXHRcdFx0XHRsYXN0Q29sdW1uID0gZGVzdFsxXVxuXHRcdFx0XHQjIGFkZCBpbmRleFxuXHRcdFx0XHRidWZmZXIgKz0gZW5jb2RlVmxxKDApXG5cblx0XHRcdFx0IyBUaGUgc3RhcnRpbmcgbGluZSBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCByZWxhdGl2ZSB0byB0aGUgcHJldmlvdXMgc291cmNlIGxpbmUuXG5cdFx0XHRcdGJ1ZmZlciArPSBlbmNvZGVWbHEoc3JjWzBdIC0gbGFzdFNvdXJjZUxpbmUpXG5cdFx0XHRcdGxhc3RTb3VyY2VMaW5lID0gc3JjWzBdXG5cdFx0XHRcdCMgVGhlIHN0YXJ0aW5nIGNvbHVtbiBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCByZWxhdGl2ZSB0byB0aGUgcHJldmlvdXMgY29sdW1uLlxuXHRcdFx0XHRidWZmZXIgKz0gZW5jb2RlVmxxKHNyY1sxXSAtIGxhc3RTb3VyY2VDb2x1bW4pXG5cdFx0XHRcdGxhc3RTb3VyY2VDb2x1bW4gPSBzcmNbMV1cblxuXHRcdFx0YnVmZmVyICs9IFwiO1wiXG5cblxuXHRcdHZhciByZWwgPSBwYXRoLnJlbGF0aXZlKHBhdGguZGlybmFtZSh0YXJnZXRQYXRoKSxzb3VyY2VQYXRoKVxuXG5cdFx0dmFyIG1hcCA9XG5cdFx0XHR2ZXJzaW9uOiAzXG5cdFx0XHRmaWxlOiBzb3VyY2VOYW1lLnJlcGxhY2UoL1xcLmltYmEvLCcuanMnKSBvciAnJ1xuXHRcdFx0c291cmNlUm9vdDogb3B0aW9uczpzb3VyY2VSb290IG9yICcnXG5cdFx0XHRzb3VyY2VzOiAgICBbcmVsXVxuXHRcdFx0c291cmNlc0NvbnRlbnQ6IFtzb3VyY2VDb2RlXVxuXHRcdFx0bmFtZXM6ICAgICAgW11cblx0XHRcdG1hcHBpbmdzOiAgIGJ1ZmZlclxuXG5cdFx0IyBzb3VyY2U6c291cmNlbWFwID0gc291cmNlbWFwXG5cdFx0IyB2YXIgYmFzZTY0ID0gQnVmZmVyLm5ldyhKU09OLnN0cmluZ2lmeShtYXApKS50b1N0cmluZyhcImJhc2U2NFwiKVxuXHRcdCMgc291cmNlOmpzICs9IFwiXFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCx7YmFzZTY0fVwiXG5cdFx0cmV0dXJuIG1hcFxuXG5cdFZMUV9TSElGVCA9IDVcblx0VkxRX0NPTlRJTlVBVElPTl9CSVQgPSAxIDw8IFZMUV9TSElGVFxuXHRWTFFfVkFMVUVfTUFTSyA9IFZMUV9DT05USU5VQVRJT05fQklUIC0gMVxuXHRCQVNFNjRfQ0hBUlMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcblxuXHQjIGJvcnJvd2VkIGZyb20gQ29mZmVlU2NyaXB0XG5cdGRlZiBlbmNvZGVWbHEgdmFsdWVcblx0XHR2YXIgYW5zd2VyID0gJydcblx0XHQjIExlYXN0IHNpZ25pZmljYW50IGJpdCByZXByZXNlbnRzIHRoZSBzaWduLlxuXHRcdHZhciBzaWduQml0ID0gdmFsdWUgPCAwID8gMSA6IDBcblx0XHR2YXIgbmV4dENodW5rXG5cdFx0IyBUaGUgbmV4dCBiaXRzIGFyZSB0aGUgYWN0dWFsIHZhbHVlLlxuXHRcdHZhciB2YWx1ZVRvRW5jb2RlID0gKE1hdGguYWJzKHZhbHVlKSA8PCAxKSArIHNpZ25CaXRcblx0XHQjIE1ha2Ugc3VyZSB3ZSBlbmNvZGUgYXQgbGVhc3Qgb25lIGNoYXJhY3RlciwgZXZlbiBpZiB2YWx1ZVRvRW5jb2RlIGlzIDAuXG5cdFx0d2hpbGUgdmFsdWVUb0VuY29kZSBvciAhYW5zd2VyXG5cdFx0XHR2YXIgbmV4dENodW5rID0gdmFsdWVUb0VuY29kZSAmIFZMUV9WQUxVRV9NQVNLXG5cdFx0XHR2YWx1ZVRvRW5jb2RlID0gdmFsdWVUb0VuY29kZSA+PiBWTFFfU0hJRlRcblx0XHRcdGlmIHZhbHVlVG9FbmNvZGVcblx0XHRcdFx0bmV4dENodW5rIHw9IFZMUV9DT05USU5VQVRJT05fQklUXG5cblx0XHRcdGFuc3dlciArPSBlbmNvZGVCYXNlNjQobmV4dENodW5rKVxuXG5cdFx0YW5zd2VyXG5cblx0ZGVmIGVuY29kZUJhc2U2NCB2YWx1ZVxuXHRcdEJBU0U2NF9DSEFSU1t2YWx1ZV0gIyBvciB0aHJvdyBFcnJvci5uZXcoXCJDYW5ub3QgQmFzZTY0IGVuY29kZSB2YWx1ZToge3ZhbHVlfVwiKVxuXG5cdFx0XG5cdFx0XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogc3JjL2NvbXBpbGVyL3NvdXJjZW1hcC5pbWJhXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==