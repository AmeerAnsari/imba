var ImbaWorker =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		// externs;
		
		var ImbaParseError = __webpack_require__(1).ImbaParseError;
		
		var lexer = __webpack_require__(2);
		var rewriter = __webpack_require__(4);
		var parser = __webpack_require__(5).parser;
		var ast = __webpack_require__(8);
		
		// Instantiate a Lexer for our use here.
		var lex = new (lexer.Lexer)();
		var Rewriter = rewriter.Rewriter;
		
		parser.lexer = lex.jisonBridge();
		parser.yy = ast; // everything is exported right here now
		
		var api = {};
		
		api.tokenize = function (code,o){
			if(o === undefined) o = {};
			try {
				o._source = code;
				lex.reset();
				return lex.tokenize(code,o);
			} catch (err) {
				// makes no sense?
				throw err;
			};
		};
		
		api.parse = function (code,o){
			// code will never be an array in worker?
			if(o === undefined) o = {};
			var tokens = code instanceof Array ? (code) : (api.tokenize(code,o));
			
			try {
				o._source = code;
				o._tokens = tokens;
				return parser.parse(tokens);
			} catch (err) {
				if (o.filename) { err._filename = o.filename };
				throw err;
			};
		};
		
		
		api.compile = function (code,o){
			if(o === undefined) o = {};
			try {
				// console.log 'try compile'
				var ast = api.parse(code,o);
				var res = ast.compile(o);
				return {code: res.toString(),sourcemap: res.sourcemap};
			} catch (e) {
				// console.log 'compile error',e:message
				// normalize somewhere else
				if (!((e instanceof ImbaParseError))) {
					if (e.lexer) {
						e = new ImbaParseError(e,{tokens: e.lexer.tokens,pos: e.lexer.pos});
					} else {
						e = {message: e.message};
					};
				};
				
				if (e instanceof ImbaParseError) { e = e.toJSON() };
				
				return {error: e};
			};
		};
		
		api.analyze = function (code,o){
			if(o === undefined) o = {};
			var meta;
			try {
				var ast = this.parse(code,o);
				meta = ast.analyze({loglevel: 0});
			} catch (e) {
				// console.log "something wrong {e:message}"
				if (!((e instanceof ImbaParseError))) {
					if (e.lexer) {
						e = new ImbaParseError(e,{tokens: e.lexer.tokens,pos: e.lexer.pos});
					} else {
						e = {message: e.message};
					};
				};
				
				if (e instanceof ImbaParseError) { e = e.toJSON() };
				
				meta = {warnings: [e]};
			};
			return meta;
		};
		
		
		return onmessage = function onmessage(e){
			// console.log 'message to webworker'
			var params = e.data;
			var id = params.id;
			
			if (api[params[0]] instanceof Function) {
				var fn = api[params[0]];
				var result = fn.apply(api,params.slice(1));
				return postMessage({id: id,data: result});
			};
		};
		
		

	})()

/***/ },
/* 1 */
/***/ function(module, exports) {

	(function(){
		// helper for subclassing
		function subclass$(obj,sup) {
			for (var k in sup) {
				if (sup.hasOwnProperty(k)) obj[k] = sup[k];
			};
			// obj.__super__ = sup;
			obj.prototype = Object.create(sup.prototype);
			obj.__super__ = obj.prototype.__super__ = sup.prototype;
			obj.prototype.initialize = obj.prototype.constructor = obj;
		};
		
		// create separate error-types with all the logic
		
		function ImbaParseError(e,o){
			this.error = e;
			this.message = e.message;
			this.filename = e.filename;
			this.line = e.line;
			this._options = o || {};
			this;
		};
		
		subclass$(ImbaParseError,Error);
		exports.ImbaParseError = ImbaParseError; // export class 
		ImbaParseError.wrap = function (err){
			// what about the stacktrace?
			return new ImbaParseError(err);
		};
		
		ImbaParseError.prototype.set = function (opts){
			this._options || (this._options = {});
			for (var i = 0, keys = Object.keys(opts), l = keys.length; i < l; i++){
				this._options[keys[i]] = opts[keys[i]];
			};
			return this;
		};
		
		ImbaParseError.prototype.start = function (){
			var o = this._options;
			var idx = o.pos - 1;
			var tok = o.tokens && o.tokens[idx];
			while (tok && tok._loc == -1){
				tok = o.tokens[--idx];
			};
			return tok;
		};
		
		ImbaParseError.prototype.desc = function (){
			var o = this._options;
			var msg = this.message;
			if (o.token && o.token._loc == -1) {
				return 'Syntax Error';
			} else {
				return msg;
			};
		};
		
		ImbaParseError.prototype.loc = function (){
			var start_;
			return (start_ = this.start()) && start_.region  &&  start_.region();
		};
		
		ImbaParseError.prototype.toJSON = function (){
			var o = this._options;
			var tok = this.start();
			// var tok = o:tokens and o:tokens[o:pos - 1]
			// var loc = tok and [tok.@loc,tok.@loc + (tok.@len or tok.@value:length)] or [0,0]
			// , col: tok.@col, line: tok.@line
			// get the token itself?
			return {warn: true,message: this.desc(),loc: this.loc()};
		};
		return ImbaParseError;
	
	})()

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function idx$(a,b){
			return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
		};
		
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		// helper for subclassing
		function subclass$(obj,sup) {
			for (var k in sup) {
				if (sup.hasOwnProperty(k)) obj[k] = sup[k];
			};
			// obj.__super__ = sup;
			obj.prototype = Object.create(sup.prototype);
			obj.__super__ = obj.prototype.__super__ = sup.prototype;
			obj.prototype.initialize = obj.prototype.constructor = obj;
		};
		
		var ALL_KEYWORDS;
		
		var T = __webpack_require__(3);
		var Token = T.Token;
		
		var rw = __webpack_require__(4);
		var Rewriter = rw.Rewriter;
		var INVERSES = rw.INVERSES;
		
		var K = 0;
		
		var ERR = __webpack_require__(1);
		
		// Constants
		// ---------
		
		// Keywords that Imba shares in common with JavaScript.
		var JS_KEYWORDS = [
			'true','false','null','this',
			'delete','typeof','in','instanceof',
			'throw','break','continue','debugger',
			'if','else','switch','for','while','do','try','catch','finally',
			'class','extends','super','return'
		];
		
		// new can be used as a keyword in imba, since object initing is done through
		// MyObject.new. new is a very useful varname.
		
		// We want to treat return like any regular call for now
		// Must be careful to throw the exceptions in AST, since the parser
		// wont
		
		// Imba-only keywords. var should move to JS_Keywords
		// some words (like tokid) should be context-specific
		var IMBA_KEYWORDS = [
			'undefined','then','unless','until','loop','of','by',
			'when','def','tag','do','elif','begin','var','let','self','await','import'
		];
		
		var IMBA_CONTEXTUAL_KEYWORDS = ['extend','static','local','export','global','prop'];
		
		var IMBA_ALIAS_MAP = {
			'and': '&&',
			'or': '||',
			'is': '==',
			'isnt': '!=',
			'not': '!',
			'yes': 'true',
			'no': 'false',
			'isa': 'instanceof',
			'case': 'switch',
			'nil': 'null'
		};
		
		var IMBA_ALIASES = Object.keys(IMBA_ALIAS_MAP);
		IMBA_KEYWORDS = IMBA_KEYWORDS.concat(IMBA_ALIASES);
		
		// FixedArray for performance
		// var ALL_KEYWORDS = JS_KEYWORDS.concat(IMBA_KEYWORDS)
		module.exports.ALL_KEYWORDS = ALL_KEYWORDS = [
			'true','false','null','this',
			'delete','typeof','in','instanceof',
			'throw','break','continue','debugger',
			'if','else','switch','for','while','do','try','catch','finally',
			'class','extends','super','return',
			'undefined','then','unless','until','loop','of','by',
			'when','def','tag','do','elif','begin','var','let','self','await','import',
			'and','or','is','isnt','not','yes','no','isa','case','nil'
		];
		
		// The list of keywords that are reserved by JavaScript, but not used, or are
		// used by Imba internally. We throw an error when these are encountered,
		// to avoid having a JavaScript error at runtime.  # 'var', 'let', - not inside here
		var RESERVED = ['case','default','function','void','with','const','enum','native'];
		var STRICT_RESERVED = ['case','function','void','const'];
		
		// The superset of both JavaScript keywords and reserved words, none of which may
		// be used as identifiers or properties.
		var JS_FORBIDDEN = JS_KEYWORDS.concat(RESERVED);
		
		var METHOD_IDENTIFIER = /^((([\x23]?[\$A-Za-z_\x7f-\uffff][$\-\w\x7f-\uffff]*)([\=]?))|(<=>|\|(?![\|=])))/;
		// removed ~=|~| |&(?![&=])
		
		// Token matching regexes.
		// added hyphens to identifiers now - to test
		var IDENTIFIER = /^((\$|@@|@|\#)[\wA-Za-z_\-\x7f-\uffff][$\w\x7f-\uffff]*(\-[$\w\x7f-\uffff]+)*|[$A-Za-z_][$\w\x7f-\uffff]*(\-[$\w\x7f-\uffff]+)*)([^\n\S]*:(?![\*\=:$\w\x7f-\uffff]))?/;
		
		var OBJECT_KEY = /^((\$|@@|@|)[$A-Za-z_\x7f-\uffff\-][$\w\x7f-\uffff\-]*)([^\n\S\s]*:(?![\*\=:$\w\x7f-\uffff]))/;
		
		var TAG = /^(\<|%)(?=[A-Za-z\#\.\{\@\>])/;
		
		var TAG_TYPE = /^(\w[\w\d]*:)?(\w[\w\d]*)(-[\w\d]+)*/;
		var TAG_ID = /^#((\w[\w\d]*)(-[\w\d]+)*)/;
		
		var TAG_ATTR = /^([\.\:]?[\w\_]+([\-\:][\w]+)*)(\s)*\=/;
		
		var SELECTOR = /^([%\$]{1,2})([\(\w\#\.\[])/;
		var SELECTOR_PART = /^(\#|\.|:|::)?([\w]+(\-[\w]+)*)/;
		var SELECTOR_COMBINATOR = /^ (\+|\>|\~)*\s*(?=[\w\.\#\:\{\*\[])/;
		
		var SELECTOR_PSEUDO_CLASS = /^(::?)([\w]+(\-[\w]+)*)/;
		var SELECTOR_ATTR_OP = /^(\$=|\~=|\^=|\*=|\|=|=|\!=)/;
		var SELECTOR_ATTR = /^\[([\w\_\-]+)(\$=|\~=|\^=|\*=|\|=|=|\!=)/;
		
		var SYMBOL = /^\:((([\*\@$\w\x7f-\uffff]+)+([\-\\/\\\:][\w\x7f-\uffff]+)*)|==|\<=\>|\[\]|\[\]\=|\*|[\\/,\\])/;
		
		
		var NUMBER = /^0x[\da-f]+|^0b[01]+|^\d*\.?\d+(?:e[+-]?\d+)?/i;
		
		var HEREDOC = /^("""|''')([\s\S]*?)(?:\n[^\n\S]*)?\1/;
		
		var OPERATOR = /^(?:[-=]=>|===|->|!==|[-+*\/%<>&|^!?=]=|=<|>>>=?|([-+:])\1|([&|<>])\2=?|\?\.|\?\:|\.{2,3}|\*(?=[a-zA-Z\_]))/;
		
		// FIXME splat should only be allowed when the previous thing is spaced or inside call?
		
		var WHITESPACE = /^[^\n\S]+/;
		
		var COMMENT = /^###([^#][\s\S]*?)(?:###[^\n\S]*|(?:###)?$)/;
		// COMMENT    = /^###([^#][\s\S]*?)(?:###[^\n\S]*|(?:###)?$)|^(?:\s*(#\s.*|#\s*$))+/
		var INLINE_COMMENT = /^(\s*)(#[ \t\!](.*)|#[ \t]?(?=\n|$))+/;
		
		var CODE = /^[-=]=>/;
		
		var MULTI_DENT = /^(?:\n[^\n\S]*)+/;
		
		var SIMPLESTR = /^'[^\\']*(?:\\.[^\\']*)*'/;
		
		var JSTOKEN = /^`[^\\`]*(?:\\.[^\\`]*)*`/;
		
		// Regex-matching-regexes.
		var REGEX = /^(\/(?![\s=])[^[\/\n\\]*(?:(?:\\[\s\S]|\[[^\]\n\\]*(?:\\[\s\S][^\]\n\\]*)*])[^[\/\n\\]*)*\/)([imgy]{0,4})(?!\w)/;
		
		var HEREGEX = /^\/{3}([\s\S]+?)\/{3}([imgy]{0,4})(?!\w)/;
		
		var HEREGEX_OMIT = /\s+(?:#.*)?/g;
		
		// Token cleaning regexes.
		var MULTILINER = /\n/g;
		
		var HEREDOC_INDENT = /\n+([^\n\S]*)/g;
		
		var HEREDOC_ILLEGAL = /\*\//;
		
		// expensive?
		var LINE_CONTINUER = /^\s*(?:,|\??\.(?![.\d])|::)/;
		
		var TRAILING_SPACES = /\s+$/;
		
		var CONST_IDENTIFIER = /^[A-Z]/;
		
		var ARGVAR = /^\$\d$/;
		
		// Compound assignment tokens.
		var COMPOUND_ASSIGN = ['-=','+=','/=','*=','%=','||=','&&=','?=','<<=','>>=','>>>=','&=','^=','|=','=<'];
		
		// Unary tokens.
		var UNARY = ['!','~','NEW','TYPEOF','DELETE'];
		
		// Logical tokens.
		var LOGIC = ['&&','||','&','|','^'];
		
		// Bit-shifting tokens.
		var SHIFT = ['<<','>>','>>>'];
		
		// Comparison tokens.
		var COMPARE = ['===','!==','==','!=','<','>','<=','>=','===','!=='];
		
		// Overideable methods
		var OP_METHODS = ['<=>','<<','..'];
		
		// Mathematical tokens.
		var MATH = ['*','/','%','∪','∩','√'];
		
		// Relational tokens that are negatable with `not` prefix.
		var RELATION = ['IN','OF','INSTANCEOF','ISA'];
		
		// Boolean tokens.
		var BOOL = ['TRUE','FALSE','NULL','UNDEFINED'];
		
		// Our list is shorter, due to sans-parentheses method calls.
		var NOT_REGEX = ['NUMBER','REGEX','BOOL','TRUE','FALSE','++','--',']'];
		
		// If the previous token is not spaced, there are more preceding tokens that
		// force a division parse:
		var NOT_SPACED_REGEX = ['NUMBER','REGEX','BOOL','TRUE','FALSE','++','--',']',')','}','THIS','SELF','IDENTIFIER','STRING'];
		
		// Tokens which could legitimately be invoked or indexed. An opening
		// parentheses or bracket following these tokens will be recorded as the start
		// of a function invocation or indexing operation.
		// really?!
		
		var UNFINISHED = ['\\','.','?.','?:','UNARY','MATH','+','-','SHIFT','RELATION','COMPARE','LOGIC','COMPOUND_ASSIGN','THROW','EXTENDS'];
		
		// } should not be callable anymore!!! '}', '::',
		var CALLABLE = ['IDENTIFIER','STRING','REGEX',')',']','THIS','SUPER','TAG_END','IVAR','GVAR','SELF','CONST','NEW','ARGVAR','SYMBOL','RETURN'];
		// var INDEXABLE = CALLABLE.concat 'NUMBER', 'BOOL', 'TAG_SELECTOR', 'IDREF', 'ARGUMENTS','}' # are booleans indexable? really?
		// optimize for FixedArray
		var INDEXABLE = [
			'IDENTIFIER','STRING','REGEX',')',']','THIS','SUPER','TAG_END','IVAR','GVAR','SELF','CONST','NEW','ARGVAR','SYMBOL','RETURN',
			'NUMBER','BOOL','TAG_SELECTOR','IDREF','ARGUMENTS','}','TAG_TYPE'
		];
		
		var GLOBAL_IDENTIFIERS = ['global','exports','require'];
		
		// Tokens that, when immediately preceding a `WHEN`, indicate that the `WHEN`
		// occurs at the start of a line. We disambiguate these from trailing whens to
		// avoid an ambiguity in the grammar.
		var LINE_BREAK = ['INDENT','OUTDENT','TERMINATOR'];
		
		
		function LexerError(message,file,line){
			this.message = message;
			this.file = file;
			this.line = line;
			return this;
		};
		subclass$(LexerError,SyntaxError);
		exports.LexerError = LexerError; // export class 
		
		
		
		function last(array,back){
			if(back === undefined) back = 0;
			return array[array.length - back - 1];
		};
		
		function count(str,substr){
			return str.split(substr).length - 1;
		};
		
		function repeatString(str,times){
			var res = '';
			while (times > 0){
				if (times % 2 == 1) {
					res += str;
				};
				str += str;
				times >>= 1;
			};
			return res;
		};
		
		var tT = T.typ;
		var tV = T.val;
		var tTs = T.setTyp;
		var tVs = T.setVal;
		
		// The Lexer class reads a stream of Imba and divvies it up into tokidged
		// tokens. Some potential ambiguity in the grammar has been avoided by
		// pushing some extra smarts into the Lexer.
		
		// Based on the original lexer.coffee from CoffeeScript
		function Lexer(){
			this.reset();
			this;
		};
		
		exports.Lexer = Lexer; // export class 
		Lexer.prototype.reset = function (){
			this._code = null;
			this._chunk = null; // The remainder of the source code.
			this._opts = null;
			
			this._indent = 0; // The current indentation level.
			this._indebt = 0; // The over-indentation at the current level.
			this._outdebt = 0; // The under-outdentation at the current level.
			
			this._indents = []; // The stack of all current indentation levels.
			this._ends = []; // The stack for pairing up tokens.
			this._contexts = []; // suplements @ends
			this._scopes = [];
			this._nextScope = null; // the scope to add on the next indent
			// should rather make it like a statemachine that moves from CLASS_DEF to CLASS_BODY etc
			// Things should compile differently when you are in a CLASS_BODY than when in a DEF_BODY++
			
			this._indentStyle = null;
			
			this._tokens = []; // Stream of parsed tokens in the form `['TYPE', value, line]`.
			this._seenFor = false;
			this._loc = 0;
			this._locOffset = 0;
			
			this._end = null;
			this._char = null;
			this._bridge = null;
			this._last = null;
			this._lastTyp = '';
			this._lastVal = null;
			return this;
		};
		
		Lexer.prototype.jisonBridge = function (jison){
			return this._bridge = {
				lex: T.lex,
				setInput: function(tokens) {
					this.tokens = tokens;
					return this.pos = 0;
				},
				
				upcomingInput: function() { return ""; }
			};
		};
		
		
		Lexer.prototype.tokenize = function (code,o){
			
			if(o === undefined) o = {};
			if (code.length == 0) {
				return [];
			};
			
			if (!o.inline) {
				if (WHITESPACE.test(code)) {
					code = ("\n" + code);
					if (code.match(/^\s*$/g)) { return [] };
				};
				
				code = code.replace(/\r/g,'').replace(/[\t ]+$/g,'');
			};
			
			this._last = null;
			this._lastTyp = null;
			this._lastVal = null;
			
			this._code = code;
			this._opts = o;
			this._locOffset = o.loc || 0;
			
			o.indent || (o.indent = {style: null,size: null});
			// add a reference to the options object
			o._tokens = this._tokens;
			// what about col here?
			
			// @indent  = 0 # The current indentation level.
			// @indebt  = 0 # The over-indentation at the current level.
			// @outdebt = 0 # The under-outdentation at the current level.
			// @indents = [] # The stack of all current indentation levels.
			// @ends    = [] # The stack for pairing up tokens.
			// @tokens  = [] # Stream of parsed tokens in the form `['TYPE', value, line]`.
			// @char = nil
			
			if (o.profile) { console.time("tokenize:lexer") };
			this.parse(code);
			if (!o.inline) this.closeIndentation();
			if (!o.silent && this._ends.length) {
				this.error(("missing " + (this._ends.pop())));
			};
			
			if (o.profile) { console.timeEnd("tokenize:lexer") };
			if (o.rewrite == false || o.norewrite) { return this._tokens };
			return new Rewriter().rewrite(this._tokens,o);
		};
		
		Lexer.prototype.parse = function (code){
			var i = 0;
			var pi = 0;
			
			while (this._chunk = code.slice(i)){
				this._loc = this._locOffset + i;
				pi = (this._end == 'TAG' && this.tagDefContextToken()) || (this._inTag && this.tagContextToken()) || this.basicContext();
				i += pi;
			};
			
			return;
		};
		
		Lexer.prototype.basicContext = function (){
			return this.selectorToken() || this.symbolToken() || this.methodNameToken() || this.identifierToken() || this.whitespaceToken() || this.lineToken() || this.commentToken() || this.heredocToken() || this.tagToken() || this.stringToken() || this.numberToken() || this.regexToken() || this.jsToken() || this.literalToken() || 0;
		};
		
		Lexer.prototype.moveCaret = function (i){
			return this._loc += i;
		};
		
		Lexer.prototype.context = function (){
			return this._ends[this._ends.length - 1];
		};
		
		Lexer.prototype.inContext = function (key){
			var o = this._contexts[this._contexts.length - 1];
			return o && o[key];
		};
		
		Lexer.prototype.pushEnd = function (val){
			// console.log "pushing end",val
			this._ends.push(val);
			this._contexts.push(null);
			this._end = val;
			this.refreshScope();
			return this;
		};
		
		Lexer.prototype.popEnd = function (val){
			this._ends.pop();
			this._contexts.pop();
			this._end = this._ends[this._ends.length - 1];
			this.refreshScope();
			return this;
		};
		
		Lexer.prototype.refreshScope = function (){
			var ctx0 = this._ends[this._ends.length - 1];
			var ctx1 = this._ends[this._ends.length - 2];
			return this._inTag = ctx0 == 'TAG_END' || (ctx1 == 'TAG_END' && ctx0 == 'OUTDENT');
		};
		
		
		
		Lexer.prototype.queueScope = function (val){
			// console.log("pushing scope {val} - {@indents} {@indents:length}")
			// @scopes.push(val) # no no
			this._scopes[this._indents.length] = val;
			return this;
		};
		
		Lexer.prototype.popScope = function (val){
			this._scopes.pop();
			return this;
		};
		
		Lexer.prototype.getScope = function (){
			return this._scopes[this._indents.length - 1];
		};
		
		Lexer.prototype.scope = function (sym,opts){
			var len = this._ends.push(this._end = sym);
			this._contexts.push(opts || null);
			return sym;
		};
		
		
		Lexer.prototype.closeSelector = function (){
			if (this._end == '%') {
				this.token('SELECTOR_END','%',0);
				return this.pair('%');
			};
		};
		
		
		Lexer.prototype.openDef = function (){
			return this.pushEnd('DEF');
		};
		
		
		Lexer.prototype.closeDef = function (){
			if (this.context() == 'DEF') {
				var prev = last(this._tokens);
				// console.log "close def {prev}"
				// console.log('closeDef with last>',prev)
				if (tT(prev) == 'DEF_FRAGMENT') {
					true;
				} else if (tT(prev) == 'TERMINATOR') {
					// console.log "here?!??"
					var n = this._tokens.pop();
					// console.log n
					this.token('DEF_BODY','DEF_BODY',0);
					// token('TERMINATOR', '',0) unless n.@value.indexOf('//') >= 0
					this._tokens.push(n);
				} else {
					this.token('DEF_BODY','DEF_BODY',0);
				};
				
				this.pair('DEF');
			};
			return;
		};
		
		Lexer.prototype.tagContextToken = function (){
			var match;
			if (this._chunk[0] == '#') {
				// console.log('found id # in tagContextToken')
				this.token('#','#',1);
				return 1;
			};
			
			if (match = TAG_ATTR.exec(this._chunk)) {
				// console.log 'TAG_SDDSATTR IN tokid',match
				// var prev = last @tokens
				// if the prev is a terminator, we dont really need to care?
				if (this._lastTyp != 'TAG_NAME') {
					if (this._lastTyp == 'TERMINATOR') {
						// console.log('prev was terminator -- drop it?')
						true;
					} else {
						this.token(",",",");
					};
				};
				
				var l = match[0].length;
				
				this.token('TAG_ATTR',match[1],l - 1); // add to loc?
				this._loc += l - 1;
				this.token('=','=',1);
				return l;
			};
			return 0;
		};
		
		Lexer.prototype.tagDefContextToken = function (){
			// console.log "tagContextToken"
			var match;
			if (match = TAG_TYPE.exec(this._chunk)) {
				this.token('TAG_TYPE',match[0],match[0].length);
				return match[0].length;
			};
			
			if (match = TAG_ID.exec(this._chunk)) {
				var input = match[0];
				this.token('TAG_ID',input,input.length);
				return input.length;
			};
			
			return 0;
		};
		
		
		Lexer.prototype.tagToken = function (){
			var match, ary;
			if (!(match = TAG.exec(this._chunk))) { return 0 };
			var ary = iter$(match);var input = ary[0],type = ary[1],identifier = ary[2];
			
			if (type == '<') {
				this.token('TAG_START','<',1);
				this.pushEnd(INVERSES.TAG_START);
				
				if (match = TAG_TYPE.exec(this._chunk.substr(1,40))) {
					// special case should probably be handled in AST
					if (match[0] != 'self') {
						this.token('TAG_TYPE',match[0],match[0].length,1);
						return input.length + match[0].length;
					};
				};
				
				if (identifier) {
					if (identifier.substr(0,1) == '{') {
						return type.length;
					} else {
						this.token('TAG_NAME',input.substr(1),0);
					};
				};
			};
			
			return input.length;
		};
		
		
		Lexer.prototype.selectorToken = function (){
			var ary;
			var match;
			
			// special handling if we are in this context
			if (this._end == '%') {
				var chr = this._chunk.charAt(0);
				var open = this.inContext('open');
				
				// should add for +, ~ etc
				// should maybe rather look for the correct type of character?
				
				if (open && (chr == ' ' || chr == '\n' || chr == ',' || chr == '+' || chr == '~' || chr == ')' || chr == ']')) {
					// console.log "close this selector directly"
					this.token('SELECTOR_END','%',0);
					this.pair('%');
					return 0;
				};
				
				if (match = SELECTOR_COMBINATOR.exec(this._chunk)) {
					// spaces between? -- include the whole
					this.token('SELECTOR_COMBINATOR',match[1] || " ",match[0].length);
					return match[0].length;
				} else if (match = SELECTOR_PART.exec(this._chunk)) {
					var type = match[1];
					var id = match[2];
					
					switch (type) {
						case '.':
							tokid = 'SELECTOR_CLASS';break;
						
						case '#':
							tokid = 'SELECTOR_ID';break;
						
						case ':':
							tokid = 'SELECTOR_PSEUDO_CLASS';break;
						
						case '::':
							tokid = 'SELECTOR_PSEUDO_CLASS';break;
						
						default:
						
							var tokid = 'SELECTOR_TAG';
					
					};
					
					this.token(tokid,match[2],match[0].length);
					return match[0].length;
				} else if (chr == '[') {
					this.token('[','[',1);
					this.pushEnd(']');
					if (match = SELECTOR_ATTR.exec(this._chunk)) {
						// fuck this length shit
						var idoffset = match[0].indexOf(match[1]);
						var opoffset = match[0].indexOf(match[2]);
						this.token('IDENTIFIER',match[1],match[1].length,idoffset);
						this.token('SELECTOR_ATTR_OP',match[2],match[2].length,opoffset);
						return match[0].length;
					};
					return 1;
				} else if (chr == '|') {
					var tok = this._tokens[this._tokens.length - 1];
					tTs(tok,'SELECTOR_NS');
					// tok[0] = 'SELECTOR_NS' # FIX
					return 1;
				} else if (chr == ',') {
					this.token('SELECTOR_GROUP',',',1);
					return 1;
				} else if (chr == '*') {
					this.token('UNIVERSAL_SELECTOR','*',1);
					return 1;
				} else if (chr == ')') {
					this.pair('%');
					this.token('SELECTOR_END',')',1);
					return 1;
				} else if (idx$(chr,[')','}',']','']) >= 0) {
					this.pair('%');
					return 0;
				};
			};
			
			if (!(match = SELECTOR.exec(this._chunk))) { return 0 };
			var ary = iter$(match);var input = ary[0],id = ary[1],kind = ary[2];
			
			// this is a closed selector
			if (kind == '(') {
				// token '(','('
				this.token('SELECTOR_START',id,id.length + 1);
				// self.pushEnd(')') # are we so sure about this?
				this.pushEnd('%');
				
				// @ends.push ')'
				// @ends.push '%'
				return id.length + 1;
			} else if (id == '%') {
				// we are already scoped in on a selector
				if (this.context() == '%') { return 1 };
				this.token('SELECTOR_START',id,id.length);
				// this is a separate - scope. Full selector should rather be $, and keep the single selector as %
				
				this.scope('%',{open: true});
				// @ends.push '%'
				// make sure a terminator breaks out
				return id.length;
			} else {
				return 0;
			};
		};
		
		// is this really needed? Should be possible to
		// parse the identifiers and = etc i jison?
		// what is special about methodNameToken? really?
		Lexer.prototype.methodNameToken = function (){
			// we can optimize this by after a def simply
			// fetching all the way after the def until a space or (
			// and then add this to the def-token itself (as with fragment)
			if (this._chunk.charAt(0) == ' ') { return 0 };
			
			var match;
			
			if (this._end == ')') {
				var outerctx = this._ends[this._ends.length - 2];
				// weird assumption, no?
				// console.log 'context is inside!!!'
				if (outerctx == '%' && (match = TAG_ATTR.exec(this._chunk))) {
					this.token('TAG_ATTR_SET',match[1]);
					return match[0].length;
				};
			};
			
			if (!(match = METHOD_IDENTIFIER.exec(this._chunk))) {
				return 0;
			};
			// var prev = last @tokens
			var length = match[0].length;
			
			var id = match[0];
			var ltyp = this._lastTyp;
			var typ = 'IDENTIFIER';
			var pre = id.charAt(0);
			var space = false;
			
			var m4 = match[4]; // might be out of bounds? should rather check charAt
			// drop match 4??
			
			// should this not quit here in practically all cases?
			if (!((ltyp == '.' || ltyp == 'DEF') || (m4 == '!' || m4 == '?') || match[5])) {
				return 0;
			};
			
			// again, why?
			if (id == 'self' || id == 'this' || id == 'super') { // in ['SELF','THIS']
				return 0;
			};
			
			if (id == 'new') {
				typ = 'NEW';
			};
			
			if (id == '...' && [',','(','CALL_START','BLOCK_PARAM_START','PARAM_START'].indexOf(ltyp) >= 0) {
				return 0;
			};
			
			if (id == '|') {
				// hacky way to implement this
				// with new lexer we'll use { ... } instead, and assume object-context,
				// then go back and correct when we see the context is invalid
				if (ltyp == '(' || ltyp == 'CALL_START') {
					this.token('DO','DO',0);
					this.pushEnd('|');
					// @ends.push '|'
					this.token('BLOCK_PARAM_START',id,1);
					return length;
				} else if (ltyp == 'DO' || ltyp == '{') {
					// @ends.push '|'
					this.pushEnd('|');
					this.token('BLOCK_PARAM_START',id,1);
					return length;
				} else if (this._ends[this._ends.length - 1] == '|') {
					this.token('BLOCK_PARAM_END','|',1);
					this.pair('|');
					return length;
				} else {
					return 0;
				};
			};
			
			// whaat?
			// console.log("method identifier",id)
			if ((['&','^','<<','<<<','>>'].indexOf(id) >= 0 || (id == '|' && this.context() != '|'))) {
				return 0;
			};
			
			if (OP_METHODS.indexOf(id) >= 0) {
				space = true;
			};
			
			// not even anything we should use?!?
			if (pre == '@') {
				typ = 'IVAR';
			} else if (pre == '$') {
				true;
				// typ = 'GVAR'
			} else if (pre == '#') {
				typ = 'TAGID';
			} else if (CONST_IDENTIFIER.test(pre) || id == 'require' || id == 'global' || id == 'exports') {
				// really? seems very strange
				// console.log('global!!',typ,id)
				typ = 'CONST';
			};
			
			// what is this really for?
			if (match[5] && ['IDENTIFIER','CONST','GVAR','CVAR','IVAR','SELF','THIS',']','}',')','NUMBER','STRING','IDREF'].indexOf(ltyp) >= 0) {
				this.token('.','.',0);
			};
			
			this.token(typ,id,length);
			
			if (space) {
				this._last.spaced = true;
			};
			
			return length;
		};
		
		
		Lexer.prototype.inTag = function (){
			var len = this._ends.length;
			if (len > 0) {
				var ctx0 = this._ends[len - 1];
				var ctx1 = len > 1 ? (this._ends[len - 2]) : (ctx0);
				return ctx0 == 'TAG_END' || (ctx1 == 'TAG_END' && ctx0 == 'OUTDENT');
			};
			return false;
		};
		
		Lexer.prototype.isKeyword = function (id){
			if ((id == 'attr' || id == 'prop')) {
				var scop = this.getScope();
				var incls = scop == 'CLASS' || scop == 'TAG';
				// var scopes = @indents.map(|ind,i| @scopes[i] or 'NONE')
				// console.log "id is prop: {scopes.join(" -> ")} | {@indents.join(" -> ")}"
				if (incls) { return true };
			};
			
			return ALL_KEYWORDS.indexOf(id) >= 0;
		};
		
		// Matches identifying literals: variables, keywords, method names, etc.
		// Check to ensure that JavaScript reserved words aren't being used as
		// identifiers. Because Imba reserves a handful of keywords that are
		// allowed in JavaScript, we're careful not to tokid them as keywords when
		// referenced as property names here, so you can still do `jQuery.is()` even
		// though `is` means `===` otherwise.
		Lexer.prototype.identifierToken = function (){
			var ary;
			var match;
			
			var ctx0 = this._ends[this._ends.length - 1];
			var ctx1 = this._ends[this._ends.length - 2];
			var innerctx = ctx0;
			var typ;
			var reserved = false;
			
			var addLoc = false;
			var inTag = ctx0 == 'TAG_END' || (ctx1 == 'TAG_END' && ctx0 == 'OUTDENT');
			
			// console.log ctx1,ctx0
			
			if (inTag && (match = TAG_ATTR.exec(this._chunk))) {
				// console.log 'TAG_ATTR IN tokid',match
				// var prev = last @tokens
				// if the prev is a terminator, we dont really need to care?
				if (this._lastTyp != 'TAG_NAME') {
					if (this._lastTyp == 'TERMINATOR') {
						// console.log('prev was terminator -- drop it?')
						true;
					} else {
						this.token(",",",");
					};
				};
				
				var l = match[0].length;
				
				this.token('TAG_ATTR',match[1],l - 1); // add to loc?
				this._loc += l - 1;
				this.token('=','=',1);
				return l;
			};
			
			// see if this is a plain object-key
			// way too much logic going on here?
			// the ast should normalize whether keys
			// are accessable as keys or strings etc
			if (match = OBJECT_KEY.exec(this._chunk)) {
				var id = match[1];
				typ = 'IDENTIFIER';
				
				// FIXME loc of key includes colon
				// moveCaret(id:length)
				// console.log "ok"
				if (true) {
					// console.log "got here? {match}"
					this.token(typ,id,id.length);
					this.moveCaret(id.length);
					this.token(':',':',match[3].length);
					this.moveCaret(-id.length);
					// moveCaret(match[3]:length)
					return match[0].length;
				};
				
				// moveCaret(match[2]:length)
				// return 0
				// console.log match[3]:length
				this.token(typ,id,match[0].length);
				this.token(':',':',1);
				return match[0].length;
			};
			
			if (!(match = IDENTIFIER.exec(this._chunk))) {
				return 0;
			};
			
			var ary = iter$(match);var input = ary[0],id = ary[1],typ = ary[2],m3 = ary[3],m4 = ary[4],colon = ary[5];
			var idlen = id.length;
			
			// What is the logic here?
			if (id == 'own' && this.lastTokenType() == 'FOR') {
				this.token('OWN',id,id.length);
				return id.length;
			};
			
			var prev = last(this._tokens);
			var lastTyp = this._lastTyp;
			
			// should we force this to be an identifier even if it is a reserved word?
			// this should only happen for when part of object etc
			// will prev ever be @???
			var forcedIdentifier;
			
			// again
			forcedIdentifier = colon || lastTyp == '.' || lastTyp == '?.'; // in ['.', '?.'
			
			
			// temp hack! need to solve for other keywords etc as well
			// problem appears with ternary conditions.
			
			// well -- it should still be an indentifier if in object?
			// forcedIdentifier = no if id in ['undefined','break']
			
			if (colon && lastTyp == '?') { forcedIdentifier = false }; // for ternary
			
			// if we are not at the top level? -- hacky
			if (id == 'tag' && this._chunk.indexOf("tag(") == 0) { // @chunk.match(/^tokid\(/)
				forcedIdentifier = true;
			};
			
			var isKeyword = false;
			
			// console.log "match",match
			// console.log "typ is {typ}"
			// little reason to check for this right here? but I guess it is only a simple check
			if (typ == '$' && ARGVAR.test(id)) { // id.match(/^\$\d$/)
				// console.log "TYP $"
				if (id == '$0') {
					typ = 'ARGUMENTS';
				} else {
					typ = 'ARGVAR';
					id = id.substr(1);
				};
			} else if (typ == '@') {
				typ = 'IVAR';
				
				// id:reserved = yes if colon
			} else if (typ == '#') {
				// we are trying to move to generic tokens,
				// so we are starting to splitting up the symbols and the items
				// we'll see if that works
				typ = 'IDENTIFIER';
				this.token('#','#');
				id = id.substr(1);
			} else if (typ == '@@') {
				typ = 'CVAR';
			} else if (typ == '$' && !(colon)) {
				typ = 'IDENTIFIER';
				// typ = 'GVAR'
			} else if (CONST_IDENTIFIER.test(id) || id == 'require' || id == 'global' || id == 'exports') {
				// thous should really be handled by the ast instead
				typ = 'CONST';
			} else if (id == 'elif') {
				this.token('ELSE','elif',id.length);
				this.token('IF','if');
				return id.length;
			} else {
				typ = 'IDENTIFIER';
			};
			
			
			
			// this catches all 
			if (!(forcedIdentifier) && (isKeyword = this.isKeyword(id))) {
				// (id in JS_KEYWORDS or id in IMBA_KEYWORDS)
				typ = id.toUpperCase();
				addLoc = true;
				
				// clumsy - but testing performance
				if (typ == 'YES') {
					typ = 'TRUE';
				} else if (typ == 'NO') {
					typ = 'FALSE';
				} else if (typ == 'NIL') {
					typ = 'NULL';
				} else if (typ == 'VAR') {
					if (this._lastVal == 'export') {
						tTs(prev,'EXPORT');
					};
				} else if (typ == 'IF' || typ == 'ELSE' || typ == 'TRUE' || typ == 'FALSE' || typ == 'NULL') {
					true;
				} else if (typ == 'TAG') {
					this.pushEnd('TAG');
					// @ends.push('TAG')
				} else if (typ == 'DEF') {
					// should probably shift context and optimize this
					this.openDef();
				} else if (typ == 'DO') {
					if (this.context() == 'DEF') this.closeDef();
				} else if (typ == 'WHEN' && LINE_BREAK.indexOf(this.lastTokenType()) >= 0) {
					typ = 'LEADING_WHEN';
				} else if (typ == 'FOR') {
					this._seenFor = true;
				} else if (typ == 'UNLESS') {
					typ = 'IF'; // WARN
				} else if (UNARY.indexOf(typ) >= 0) {
					typ = 'UNARY';
				} else if (RELATION.indexOf(typ) >= 0) {
					if (typ != 'INSTANCEOF' && typ != 'ISA' && this._seenFor) {
						typ = 'FOR' + typ; // ?
						this._seenFor = false;
					} else {
						typ = 'RELATION';
						if (String(this.value()) == '!') {
							this._tokens.pop(); // is fucked up??!
							// WARN we need to keep the loc, no?
							id = '!' + id;
						};
					};
				};
			};
			
			if (id == 'super') {
				typ = 'SUPER';
			};
			
			// do we really want to check this here
			if (!(forcedIdentifier)) {
				// should already have dealt with this
				
				if (isKeyword && IMBA_ALIASES.indexOf(id) >= 0) { id = IMBA_ALIAS_MAP[id] };
				// these really should not go here?!?
				switch (id) {
					case '!':
						typ = 'UNARY';break;
					
					case '==':
					case '!=':
					case '===':
					case '!==':
						typ = 'COMPARE';break;
					
					case '&&':
					case '||':
						typ = 'LOGIC';break;
					
					case 'break':
					case 'continue':
					case 'debugger':
					case 'arguments':
						typ = id.toUpperCase();break;
				
				};
			};
			
			// prev = last @tokens
			var len = input.length;
			
			// should be strict about the order, check this manually instead
			if (typ == 'CLASS' || typ == 'DEF' || typ == 'TAG') {
				this.queueScope(typ);
				
				var i = this._tokens.length;
				
				while (i){
					prev = this._tokens[--i];
					var ctrl = "" + tV(prev);
					// console.log("ctrl is {ctrl}")
					// need to coerce to string because of stupid CS ===
					// console.log("prev is",prev[0],prev[1])
					if (idx$(ctrl,IMBA_CONTEXTUAL_KEYWORDS) >= 0) {
						tTs(prev,ctrl.toUpperCase());
						// prev[0] = ctrl.toUpperCase # FIX
					} else {
						break;
					};
				};
			} else if (typ == 'IF') {
				this.queueScope(typ);
			} else if (typ == 'IMPORT') {
				// could manually parse the whole ting here?
				this.pushEnd('IMPORT');
				// @ends.push 'IMPORT'
			} else if (id == 'from' && ctx0 == 'IMPORT') {
				typ = 'FROM';
				this.pair('IMPORT');
			} else if (id == 'as' && ctx0 == 'IMPORT') {
				typ = 'AS';
				this.pair('IMPORT');
			};
			
			if (typ == 'IDENTIFIER') {
				// see if previous was catch -- belongs in rewriter?
				if (lastTyp == 'CATCH') {
					typ = 'CATCH_VAR';
				};
			};
			
			if (colon) {
				this.token(typ,id,idlen);
				this.moveCaret(idlen);
				// console.log "add colon?"
				this.token(':',':',colon.length);
				this.moveCaret(-idlen);
			} else {
				this.token(typ,id,idlen);
			};
			
			return len;
		};
		
		// Matches numbers, including decimals, hex, and exponential notation.
		// Be careful not to interfere with ranges-in-progress.
		Lexer.prototype.numberToken = function (){
			var binaryLiteral;
			var match,number,lexedLength;
			
			if (!(match = NUMBER.exec(this._chunk))) { return 0 };
			
			number = match[0];
			lexedLength = number.length;
			
			if (binaryLiteral = /0b([01]+)/.exec(number)) {
				
				number = "" + parseInt(binaryLiteral[1],2);
			};
			
			var prev = last(this._tokens);
			
			if (match[0][0] == '.' && prev && !prev.spaced && ['IDENTIFIER',')','}',']','NUMBER'].indexOf(tT(prev)) >= 0) {
				// console.log "got here"
				this.token(".",".");
				number = number.substr(1);
			};
			
			
			this.token('NUMBER',number,lexedLength);
			return lexedLength;
		};
		
		Lexer.prototype.symbolToken = function (){
			var match,symbol,prev;
			
			if (!(match = SYMBOL.exec(this._chunk))) { return 0 };
			symbol = match[0].substr(1);
			prev = last(this._tokens);
			
			// is this a property-access?
			// should invert this -- only allow when prev IS .. 
			
			// : should be a token itself, with a specification of spacing (LR,R,L,NONE)
			
			// FIX
			if (prev && !prev.spaced && idx$(tT(prev),['(','{','[','.','CALL_START','INDEX_START',',','=','INDENT','TERMINATOR']) == -1) {
				this.token('.:',':',1);
				var sym = symbol.split(/[\:\\\/]/)[0]; // really?
				// token 'SYMBOL', "'#{symbol}'"
				this.token('IDENTIFIER',sym,sym.length,1);
				return (sym.length + 1);
			} else {
				// token 'SYMBOL', "'#{symbol}'"
				this.token('SYMBOL',symbol,match[0].length);
				return match[0].length;
			};
		};
		
		Lexer.prototype.escapeStr = function (str,heredoc,q){
			str = str.replace(MULTILINER,(heredoc ? ('\\n') : ('')));
			if (q) {
				var r = RegExp(("\\\\[" + q + "]"),"g");
				str = str.replace(r,q);
				str = str.replace(RegExp(("" + q),"g"),'\\$&');
			};
			return str;
			
			// str = str.replace(MULTILINER, '\\n')
			// str = str.replace(/\t/g, '\\t')
		};
		// Matches strings, including multi-line strings. Ensures that quotation marks
		// are balanced within the string's contents, and within nested interpolations.
		Lexer.prototype.stringToken = function (){
			var match,string;
			
			switch (this._chunk.charAt(0)) {
				case "'":
					if (!(match = SIMPLESTR.exec(this._chunk))) { return 0 };
					string = match[0];
					this.token('STRING',this.escapeStr(string),string.length);
					// token 'STRING', (string = match[0]).replace(MULTILINER, '\\\n'), string:length
					break;
				
				case '"':
					if (!(string = this.balancedString(this._chunk,'"'))) { return 0 };
					// what about tripe quoted strings?
					
					if (string.indexOf('{') >= 0) {
						var len = string.length;
						// if this has no interpolation?
						// we are now messing with locations - beware
						this.token('STRING_START',string.charAt(0),1);
						this.interpolateString(string.slice(1,-1));
						this.token('STRING_END',string.charAt(len - 1),1,string.length - 1);
					} else {
						len = string.length;
						// string = string.replace(MULTILINER, '\\\n')
						this.token('STRING',this.escapeStr(string),len);
					};
					break;
				
				default:
				
					return 0;
			
			};
			
			this.moveHead(string);
			return string.length;
		};
		
		// Matches heredocs, adjusting indentation to the correct level, as heredocs
		// preserve whitespace, but ignore indentation to the left.
		Lexer.prototype.heredocToken = function (){
			var match,heredoc,quote,doc;
			
			if (!(match = HEREDOC.exec(this._chunk))) { return 0 };
			
			heredoc = match[0];
			quote = heredoc.charAt(0);
			doc = this.sanitizeHeredoc(match[2],{quote: quote,indent: null});
			// console.log "found heredoc {match[0]:length} {doc:length}"
			
			if (quote == '"' && doc.indexOf('{') >= 0) {
				var open = match[1];
				// console.log doc.substr(0,3),match[1]
				this.token('STRING_START',open,open.length);
				this.interpolateString(doc,{heredoc: true,offset: open.length,quote: quote});
				this.token('STRING_END',open,open.length,heredoc.length - open.length);
			} else {
				this.token('STRING',this.makeString(doc,quote,true),0);
			};
			
			this.moveHead(heredoc);
			return heredoc.length;
		};
		
		// Matches and consumes comments.
		Lexer.prototype.commentToken = function (){
			var match,length,comment,indent,prev;
			
			var typ = 'HERECOMMENT';
			
			if (match = INLINE_COMMENT.exec(this._chunk)) { // .match(INLINE_COMMENT)
				// console.log "match inline comment"
				length = match[0].length;
				indent = match[1];
				comment = match[2];
				
				prev = last(this._tokens);
				var pt = prev && tT(prev);
				var note = '//' + comment.substr(1);
				
				if (this._last && this._last.spaced) {
					note = ' ' + note;
					// console.log "the previous node was SPACED"
				};
				// console.log "comment {note} - indent({indent}) - {length} {comment:length}"
				
				if ((pt && pt != 'INDENT' && pt != 'TERMINATOR') || !(pt)) {
					// console.log "skip comment"
					// token 'INLINECOMMENT', comment.substr(2)
					// console.log "adding as terminator"
					this.token('TERMINATOR',note,length); // + '\n'
				} else {
					// console.log "add comment ({note})"
					if (pt == 'TERMINATOR') {
						tVs(prev,tV(prev) + note);
						// prev[1] += note
					} else if (pt == 'INDENT') {
						// console.log "adding comment to INDENT: {note}" # why not add directly here?
						this.addLinebreaks(1,note);
					} else {
						// console.log "comment here"
						// should we ever get here?
						this.token(typ,comment.substr(2),length); // are we sure?
					};
				};
				
				return length; // disable now while compiling
			};
			
			// should use exec?
			if (!(match = COMMENT.exec(this._chunk))) { return 0 };
			
			comment = match[0];
			var here = match[1];
			
			if (here) {
				this.token('HERECOMMENT',this.sanitizeHeredoc(here,{herecomment: true,indent: Array(this._indent + 1).join(' ')}),comment.length);
				this.token('TERMINATOR','\n');
			} else {
				this.token('HERECOMMENT',comment,comment.length);
				this.token('TERMINATOR','\n'); // auto? really?
			};
			
			this.moveHead(comment);
			return comment.length;
		};
		
		// Matches JavaScript interpolated directly into the source via backticks.
		Lexer.prototype.jsToken = function (){
			var match,script;
			
			if (!(this._chunk.charAt(0) == '`' && (match = JSTOKEN.exec(this._chunk)))) { return 0 };
			this.token('JS',(script = match[0]).slice(1,-1));
			return script.length;
		};
		
		// Matches regular expression literals. Lexing regular expressions is difficult
		// to distinguish from division, so we borrow some basic heuristics from
		// JavaScript and Ruby.
		Lexer.prototype.regexToken = function (){
			var ary;
			var match,length,prev;
			
			if (this._chunk.charAt(0) != '/') { return 0 };
			if (match = HEREGEX.exec(this._chunk)) {
				length = this.heregexToken(match);
				this.moveHead(match[0]);
				return length;
			};
			
			prev = last(this._tokens);
			// FIX
			if (prev && (idx$(tT(prev),(prev.spaced ? (
				NOT_REGEX
			) : (
				NOT_SPACED_REGEX
			))) >= 0)) { return 0 };
			if (!(match = REGEX.exec(this._chunk))) { return 0 };
			var ary = iter$(match);var m = ary[0],regex = ary[1],flags = ary[2];
			
			// FIXME
			// if regex[..1] is '/*'
			//	error 'regular expressions cannot begin with `*`'
			
			if (regex == '//') {
				regex = '/(?:)/';
			};
			
			this.token('REGEX',("" + regex + flags),m.length);
			return m.length;
		};
		
		// Matches multiline extended regular expressions.
		// The escaping should rather happen in AST - possibly as an additional flag?
		Lexer.prototype.heregexToken = function (match){
			var ary;
			var ary = iter$(match);var heregex = ary[0],body = ary[1],flags = ary[2];
			
			if (0 > body.indexOf('#{')) {
				
				var re = body.replace(HEREGEX_OMIT,'').replace(/\//g,'\\/');
				
				if (re.match(/^\*/)) {
					this.error('regular expressions cannot begin with `*`');
				};
				
				this.token('REGEX',("/" + (re || '(?:)') + "/" + flags),heregex.length);
				return heregex.length;
			};
			
			// use more basic regex type
			
			this.token('CONST','RegExp');
			this._tokens.push(T.token('CALL_START','(',0));
			var tokens = [];
			
			for (var i = 0, items = iter$(this.interpolateString(body,{regex: true})), len = items.length, pair; i < len; i++) {
				
				pair = items[i];
				var tok = tT(pair); // FIX
				var value = tV(pair); // FIX
				
				if (tok == 'TOKENS') {
					// FIXME what is this?
					tokens.push.apply(tokens,value);
				} else {
					if (!(value)) {
						console.log("what??");
					};
					
					if (!(value = value.replace(HEREGEX_OMIT,''))) { continue; };
					
					value = value.replace(/\\/g,'\\\\');
					tokens.push(T.token('STRING',this.makeString(value,'"',true),0)); // FIX
				};
				
				tokens.push(T.token('+','+',0)); // FIX
			};
			
			tokens.pop();
			
			// FIX
			if (!(tokens[0] && tT(tokens[0]) == 'STRING')) {
				// FIX
				this._tokens.push(T.token('STRING','""'),T.token('+','+'));
			};
			
			this._tokens.push.apply(this._tokens,tokens); // what is this?
			// FIX
			
			if (flags) {
				this._tokens.push(T.token(',',',',0));
				this._tokens.push(T.token('STRING','"' + flags + '"',0));
			};
			
			this.token(')',')',0);
			
			return heregex.length;
		};
		
		// Matches newlines, indents, and outdents, and determines which is which.
		// If we can detect that the current line is continued onto the the next line,
		// then the newline is suppressed:
		//
		//     elements
		//       .each( ... )
		//       .map( ... )
		//
		// Keeps track of the level of indentation, because a single outdent token
		// can close multiple indents, so we need to know how far in we happen to be.
		Lexer.prototype.lineToken = function (){
			var match;
			
			if (!(match = MULTI_DENT.exec(this._chunk))) { return 0 };
			
			var indent = match[0];
			var brCount = this.moveHead(indent);
			
			this._seenFor = false;
			// reset column as well?
			
			var prev = last(this._tokens,1);
			var whitespace = indent.substr(indent.lastIndexOf('\n') + 1);
			var size = whitespace.length;
			var noNewlines = this.unfinished();
			
			if ((/^\n#\s/).test(this._chunk)) {
				this.addLinebreaks(1);
				return 0;
			};
			
			if (size > 0) {
				if (!this._indentStyle) {
					this._opts.indent = this._indentStyle = whitespace;
				};
				
				var indentSize = 0;
				var offset = 0;
				
				while (true){
					var idx = whitespace.indexOf(this._indentStyle,offset);
					if (idx == offset) {
						indentSize++;
						offset += this._indentStyle.length;
					} else if (offset == whitespace.length) {
						break;
					} else {
						// workaround to report correct location
						this._loc += indent.length - whitespace.length;
						this.token('INDENT',whitespace,whitespace.length);
						return this.error('inconsistent indentation');
					};
				};
				
				size = indentSize;
			};
			
			
			if (size - this._indebt == this._indent) {
				if (noNewlines) {
					this.suppressNewlines();
				} else {
					this.newlineToken(brCount);
				};
				return indent.length;
			};
			
			if (size > this._indent) {
				if (noNewlines) {
					this._indebt = size - this._indent;
					this.suppressNewlines();
					return indent.length;
				};
				
				if (this.inTag()) {
					// console.log "indent inside tokid?!?"
					// @indebt = size - @indent
					// suppressNewlines()
					return indent.length;
				};
				
				
				var diff = size - this._indent + this._outdebt;
				this.closeDef();
				
				var immediate = last(this._tokens);
				
				if (immediate && tT(immediate) == 'TERMINATOR') {
					tTs(immediate,'INDENT');
					immediate._meta || (immediate._meta = {pre: tV(immediate),post: ''});
					
					// should rather add to meta somehow?!?
					// tVs(immediate,tV(immediate) + '%|%') # crazy
				} else {
					this.token('INDENT',"" + diff,0);
				};
				
				// console.log "indenting", prev, last(@tokens,1)
				// if prev and prev[0] == 'TERMINATOR'
				//   console.log "terminator before indent??"
				
				// check for comments as well ?
				
				this._indents.push(diff);
				this.pushEnd('OUTDENT');
				// @ends.push 'OUTDENT'
				this._outdebt = this._indebt = 0;
				this.addLinebreaks(brCount);
			} else {
				this._indebt = 0;
				this.outdentToken(this._indent - size,noNewlines,brCount);
				this.addLinebreaks(brCount - 1);
				// console.log "outdent",noNewlines,tokid()
			};
			
			this._indent = size;
			return indent.length;
		};
		
		// Record an outdent token or multiple tokens, if we happen to be moving back
		// inwards past several recorded indents.
		Lexer.prototype.outdentToken = function (moveOut,noNewlines,newlineCount){
			// here we should also take care to pop / reset the scope-body
			// or context-type for indentation 
			var dent = 0;
			while (moveOut > 0){
				var len = this._indents.length - 1;
				if (this._indents[len] == undefined) {
					moveOut = 0;
				} else if (this._indents[len] == this._outdebt) {
					moveOut -= this._outdebt;
					this._outdebt = 0;
				} else if (this._indents[len] < this._outdebt) {
					this._outdebt -= this._indents[len];
					moveOut -= this._indents[len];
				} else {
					dent = this._indents.pop() - this._outdebt;
					moveOut -= dent;
					this._outdebt = 0;
					
					if (!(noNewlines)) { this.addLinebreaks(1) };
					
					this.pair('OUTDENT');
					this.token('OUTDENT',"" + dent,0);
				};
			};
			
			if (dent) { this._outdebt -= moveOut };
			
			while (this.lastTokenValue() == ';'){
				this._tokens.pop();
			};
			
			if (!(this.lastTokenType() == 'TERMINATOR' || noNewlines)) { this.token('TERMINATOR','\n',0) };
			
			// capping scopes so they dont hang around 
			this._scopes.length = this._indents.length;
			
			var ctx = this.context();
			if (ctx == '%' || ctx == 'TAG') { this.pair(ctx) }; // really?
			this.closeDef();
			return this;
		};
		
		// Matches and consumes non-meaningful whitespace. tokid the previous token
		// as being "spaced", because there are some cases where it makes a difference.
		Lexer.prototype.whitespaceToken = function (){
			var match,nline,prev;
			if (!((match = WHITESPACE.exec(this._chunk)) || (nline = this._chunk.charAt(0) == '\n'))) { return 0 };
			prev = last(this._tokens);
			
			// FIX - why oh why?
			if (prev) {
				if (match) {
					prev.spaced = true;
					return match[0].length;
				} else {
					prev.newLine = true;
					return 0;
				};
			};
		};
		
		Lexer.prototype.addNewline = function (){
			return this.token('TERMINATOR','\n');
		};
		
		Lexer.prototype.moveHead = function (str){
			var br = count(str,'\n');
			return br;
		};
		
		
		Lexer.prototype.addLinebreaks = function (count,raw){
			var br;
			
			if (!(raw) && count == 0) { return this }; // no terminators?
			
			var prev = this._last;
			
			if (!(raw)) {
				if (count == 1) {
					br = '\n';
				} else if (count == 2) {
					br = '\n\n';
				} else if (count == 3) {
					br = '\n\n\n';
				} else {
					br = repeatString('\n',count);
				};
			};
			// FIX
			if (prev) {
				var t = prev._type; // @lastTyp
				var v = tV(prev);
				
				// we really want to add this
				if (t == 'INDENT') {
					// TODO we want to add to the indent
					// console.log "add the comment to the indent -- pre? {raw} {br}"
					
					var meta = prev._meta || (prev._meta = {pre: '',post: ''});
					meta.post += (raw || br);
					// tVs(v + (raw or br))
					return this;
				} else if (t == 'TERMINATOR') {
					// console.log "already exists terminator {br} {raw}"
					tVs(prev,v + (raw || br));
					return this;
				};
			};
			
			this.token('TERMINATOR',br,0);
			return;
		};
		
		// Generate a newline token. Consecutive newlines get merged together.
		Lexer.prototype.newlineToken = function (lines){
			// console.log "newlineToken"
			while (this.lastTokenValue() == ';'){
				console.log("pop token",this._tokens[this._tokens.length - 1]);
				this._tokens.pop();
			};
			
			this.addLinebreaks(lines);
			
			var ctx = this.context();
			// WARN now import cannot go over multiple lines
			if (ctx == 'TAG' || ctx == 'IMPORT') { this.pair(ctx) };
			this.closeDef(); // close def -- really?
			return this;
		};
		
		// Use a `\` at a line-ending to suppress the newline.
		// The slash is removed here once its job is done.
		Lexer.prototype.suppressNewlines = function (){
			if (this.value() == '\\') { this._tokens.pop() };
			return this;
		};
		
		// We treat all other single characters as a token. E.g.: `( ) , . !`
		// Multi-character operators are also literal tokens, so that Jison can assign
		// the proper order of operations. There are some symbols that we tokid specially
		// here. `;` and newlines are both treated as a `TERMINATOR`, we distinguish
		// parentheses that indicate a method call from regular parentheses, and so on.
		Lexer.prototype.literalToken = function (){
			var match,value;
			if (match = OPERATOR.exec(this._chunk)) {
				value = match[0];
				if (CODE.test(value)) this.tagParameters();
			} else {
				value = this._chunk.charAt(0);
			};
			
			var end1 = this._ends[this._ends.length - 1];
			var end2 = this._ends[this._ends.length - 2];
			
			var inTag = end1 == 'TAG_END' || end1 == 'OUTDENT' && end2 == 'TAG_END';
			
			var tokid = value;
			var prev = last(this._tokens);
			var pt = prev && tT(prev);
			var pv = prev && tV(prev);
			var length = value.length;
			
			// is this needed?
			if (value == '=' && prev) {
				
				if (pv == '||' || pv == '&&') { // in ['||', '&&']
					tTs(prev,'COMPOUND_ASSIGN');
					tVs(prev,pv + '=');
					// prev[0] = 'COMPOUND_ASSIGN'
					// prev[1] += '='
					return value.length;
				};
			};
			
			if (value == ';') {
				this._seenFor = false;
				tokid = 'TERMINATOR';
			} else if (value == '(' && inTag && pt != '=' && prev.spaced) { // FIXed
				// console.log 'spaced before ( in tokid'
				// FIXME - should rather add a special token like TAG_PARAMS_START
				this.token(',',',');
			} else if (value == '->' && inTag) {
				tokid = 'TAG_END';
				this.pair('TAG_END');
			} else if (value == '/>' && inTag) {
				tokid = 'TAG_END';
				this.pair('TAG_END');
			} else if (value == '>' && inTag) {
				tokid = 'TAG_END';
				this.pair('TAG_END');
			} else if (value == '>' && this.context() == 'DEF') {
				// console.log('picked up >!!')
				tokid = 'DEF_FRAGMENT';
				
				// elif value is 'TERMINATOR' and end1 is '%' 
				// 	closeSelector()
			} else if (value == 'TERMINATOR' && end1 == 'DEF') {
				this.closeDef();
			} else if (value == '&' && this.context() == 'DEF') {
				// console.log("okay!")
				tokid = 'BLOCK_ARG';
				// change the next identifier instead?
			} else if (value == '*' && this._chunk.charAt(1).match(/[A-Za-z\_\@\[]/) && (prev.spaced || [',','(','[','{','|','\n','\t'].indexOf(pv) >= 0)) {
				tokid = "SPLAT";
			} else if (value == '√') {
				tokid = 'SQRT';
			} else if (value == 'ƒ') {
				tokid = 'FUNC';
			} else if (idx$(value,MATH) >= 0) {
				tokid = 'MATH';
			} else if (idx$(value,COMPARE) >= 0) {
				tokid = 'COMPARE';
			} else if (idx$(value,COMPOUND_ASSIGN) >= 0) {
				tokid = 'COMPOUND_ASSIGN';
			} else if (idx$(value,UNARY) >= 0) {
				tokid = 'UNARY';
			} else if (idx$(value,SHIFT) >= 0) {
				tokid = 'SHIFT';
			} else if (idx$(value,LOGIC) >= 0) {
				tokid = 'LOGIC'; // or value is '?' and prev?:spaced 
			} else if (prev && !prev.spaced) {
				// need a better way to do these
				if (value == '(' && end1 == '%') {
					tokid = 'TAG_ATTRS_START';
				} else if (value == '(' && idx$(pt,CALLABLE) >= 0) {
					// not using this ???
					// prev[0] = 'FUNC_EXIST' if prev[0] is '?'
					tokid = 'CALL_START';
				} else if (value == '[' && idx$(pt,INDEXABLE) >= 0) {
					tokid = 'INDEX_START';
					if (pt == '?') { tTs(prev,'INDEX_SOAK') };
					// prev[0] = 'INDEX_SOAK' if prev[0] == '?'
				};
			};
			
			switch (value) {
				case '(':
				case '{':
				case '[':
					this.pushEnd(INVERSES[value]);break;
				
				case ')':
				case '}':
				case ']':
					this.pair(value);break;
			
			};
			
			// hacky rule to try to allow for tuple-assignments in blocks
			// if value is ',' and prev[0] is 'IDENTIFIER' and @tokens[@tokens:length - 2][0] in ['TERMINATOR','INDENT']
			//   # token "TUPLE", "tuple" # should rather insert it somewhere else, no?
			//   console.log("found comma")
			
			this.token(tokid,value,value.length);
			return value.length;
		};
		
		// Token Manipulators
		// ------------------
		
		// Sanitize a heredoc or herecomment by
		// erasing all external indentation on the left-hand side.
		Lexer.prototype.sanitizeHeredoc = function (doc,options){
			var match;
			var indent = options.indent;
			var herecomment = options.herecomment;
			
			if (herecomment) {
				if (HEREDOC_ILLEGAL.test(doc)) {
					this.error("block comment cannot contain '*/' starting");
				};
				if (doc.indexOf('\n') <= 0) { return doc };
			} else {
				var length_;while (match = HEREDOC_INDENT.exec(doc)){
					var attempt = match[1];
					if (indent == null || 0 < (length_ = attempt.length) && length_ < indent.length) {
						indent = attempt;
					};
				};
			};
			
			if (indent) { doc = doc.replace(RegExp(("\\n" + indent),"g"),'\n') };
			if (!(herecomment)) { doc = doc.replace(/^\n/,'') };
			return doc;
		};
		
		// A source of ambiguity in our grammar used to be parameter lists in function
		// definitions versus argument lists in function calls. Walk backwards, tokidging
		// parameters specially in order to make things easier for the parser.
		Lexer.prototype.tagParameters = function (){
			var tok;
			if (this.lastTokenType() != ')') { return this };
			var stack = [];
			var tokens = this._tokens;
			var i = tokens.length;
			
			tTs(tokens[--i],'PARAM_END');
			
			while (tok = tokens[--i]){
				var t = tT(tok);
				switch (t) {
					case ')':
						stack.push(tok);
						break;
					
					case '(':
					case 'CALL_START':
						if (stack.length) {
							stack.pop();
						} else if (t == '(') {
							tTs(tok,'PARAM_START');
							return this;
						} else {
							return this;
						};
						break;
				
				};
			};
			
			return this;
		};
		
		// Close up all remaining open blocks at the end of the file.
		Lexer.prototype.closeIndentation = function (){
			// ctx = context
			// pair(ctx) if ctx in ['%','DEF']
			this.closeDef();
			this.closeSelector();
			return this.outdentToken(this._indent,false,0);
		};
		
		// Matches a balanced group such as a single or double-quoted string. Pass in
		// a series of delimiters, all of which must be nested correctly within the
		// contents of the string. This method allows us to have strings within
		// interpolations within strings, ad infinitum.
		Lexer.prototype.balancedString = function (str,end){
			var match,letter,prev;
			
			// console.log 'balancing string!', str, end
			var stack = [end];
			var i = 0;
			
			// could it not happen here?
			while (i < (str.length - 1)){
				i++;
				letter = str.charAt(i);
				switch (letter) {
					case '\\':
						i++;
						continue;
						break;
					
					case end:
						stack.pop();
						if (!stack.length) {
							var v = str.slice(0,i + 1);
							return v;
						};
						end = stack[stack.length - 1];
						continue;
						break;
				
				};
				
				if (end == '}' && (letter == '"' || letter == "'")) {
					stack.push(end = letter);
				} else if (end == '}' && letter == '/' && (match = (HEREGEX.exec(str.slice(i)) || REGEX.exec(str.slice(i))))) {
					i += match[0].length - 1;
				} else if (end == '}' && letter == '{') {
					stack.push(end = '}');
				} else if (end == '"' && letter == '{') {
					stack.push(end = '}');
				};
				prev = letter;
			};
			
			if (!this._opts.silent) { return this.error(("missing " + (stack.pop()) + ", starting")) };
		};
		
		// Expand variables and expressions inside double-quoted strings using
		// Ruby-like notation for substitution of arbitrary expressions.
		//
		//     "Hello #{name.capitalize()}."
		//
		// If it encounters an interpolation, this method will recursively create a
		// new Lexer, tokenize the interpolated contents, and merge them into the
		// token stream.
		Lexer.prototype.interpolateString = function (str,options){
			// console.log "interpolate string"
			if(options === undefined) options = {};
			var heredoc = options.heredoc;
			var quote = options.quote;
			var regex = options.regex;
			var prefix = options.prefix;
			
			var startLoc = this._loc;
			var tokens = [];
			var pi = 0;
			var i = -1;
			var locOffset = options.offset || 1;
			var strlen = str.length;
			var letter;
			var expr;
			
			var isInterpolated = false;
			// out of bounds
			while (letter = str.charAt(i += 1)){
				if (letter == '\\') {
					i += 1;
					continue;
				};
				
				if (!(str.charAt(i) == '{' && (expr = this.balancedString(str.slice(i),'}')))) {
					continue;
				};
				
				isInterpolated = true;
				
				// these have no real sense of location or anything?
				if (pi < i) {
					// this is the prefix-string - before any item
					var tok = new Token('NEOSTRING',this.escapeStr(str.slice(pi,i),heredoc,quote),this._loc + pi + locOffset,i - pi);
					// tok.@loc = @loc + pi
					// tok.@len = i - pi + 2
					tokens.push(tok);
				};
				
				tokens.push(new Token('{{','{',this._loc + i + locOffset,1));
				
				var inner = expr.slice(1,-1);
				// console.log 'inner is',inner
				// remove leading spaces 
				// need to keep track of how much whitespace we dropped from the start
				inner = inner.replace(/^[^\n\S]+/,'');
				
				if (inner.length) {
					// we need to remember the loc we start at
					// console.log('interpolate from loc',@loc,i)
					// really? why not just add to the stack??
					// what about the added 
					// should share with the selector no?
					// console.log "tokenize inner parts of string",inner
					var spaces = 0;
					var offset = this._loc + i + (expr.length - inner.length) - 1;
					// why create a whole new lexer? Should rather reuse one
					// much better to simply move into interpolation mode where
					// we continue parsing until we meet unpaired }
					var nested = new Lexer().tokenize(inner,{inline: true,rewrite: false,loc: offset + locOffset});
					// console.log nested.pop
					
					if (nested[0] && tT(nested[0]) == 'TERMINATOR') {
						nested.shift();
					};
					
					if (nested.length) {
						tokens.push.apply(tokens,nested); // T.token('TOKENS',nested,0)
					};
				};
				
				// should rather add the amount by which our lexer has moved?
				i += expr.length - 1;
				tokens.push(new Token('}}','}',this._loc + i + locOffset,1));
				pi = i + 1;
			};
			
			// adding the last part of the string here
			if (i >= pi && pi < str.length) {
				// set the length as well - or?
				// the string after?
				// console.log 'push neostring'
				tokens.push(new Token('NEOSTRING',this.escapeStr(str.slice(pi),heredoc,quote),this._loc + pi + locOffset,str.length - pi));
			};
			
			// console.log tokens:length
			if (regex) { return tokens };
			
			if (!tokens.length) { return this.token('NEOSTRING','""') };
			
			for (var j = 0, len = tokens.length; j < len; j++) {
				this._tokens.push(tokens[j]);
			};
			
			return tokens;
		};
		
		// Matches a balanced group such as a single or double-quoted string. Pass in
		// a series of delimiters, all of which must be nested correctly within the
		// contents of the string. This method allows us to have strings within
		// interpolations within strings, ad infinitum.
		Lexer.prototype.balancedSelector = function (str,end){
			var prev;
			var letter;
			var stack = [end];
			// FIXME
			for (var len = str.length, i = 1; i < len; i++) {
				switch (letter = str.charAt(i)) {
					case '\\':
						i++;
						continue;
						break;
					
					case end:
						stack.pop();
						if (!stack.length) {
							return str.slice(0,i + 1);
						};
						
						end = stack[stack.length - 1];
						continue;
						break;
				
				};
				if (end == '}' && letter == [')']) {
					stack.push(end = letter);
				} else if (end == '}' && letter == '{') {
					stack.push(end = '}');
				} else if (end == ')' && letter == '{') {
					stack.push(end = '}');
				};
				prev = letter; // what, why?
			};
			
			return this.error(("missing " + (stack.pop()) + ", starting"));
		};
		
		// Pairs up a closing token, ensuring that all listed pairs of tokens are
		// correctly balanced throughout the course of the token stream.
		Lexer.prototype.pair = function (tok){
			var wanted = last(this._ends);
			if (tok != wanted) {
				if ('OUTDENT' != wanted) { this.error(("unmatched " + tok)) };
				var size = last(this._indents);
				this._indent -= size;
				this.outdentToken(size,true,0);
				return this.pair(tok);
			};
			return this.popEnd();
		};
		
		
		// Helpers
		// -------
		
		// Add a token to the results, taking note of the line number.
		Lexer.prototype.token = function (id,value,len,offset){
			this._lastTyp = id;
			this._lastVal = value;
			var tok = this._last = new Token(id,value,this._loc + (offset || 0),len || 0);
			this._tokens.push(tok);
			return;
		};
		
		Lexer.prototype.lastTokenType = function (){
			var token = this._tokens[this._tokens.length - 1];
			return token ? (tT(token)) : ('NONE');
		};
		
		Lexer.prototype.lastTokenValue = function (){
			var token = this._tokens[this._tokens.length - 1];
			return token ? (token._value) : ('');
		};
		
		// Peek at a tokid in the current token stream.
		Lexer.prototype.tokid = function (index,val){
			var tok;
			if (tok = last(this._tokens,index)) {
				if (val) { tTs(tok,val) };
				return tT(tok);
				// tok.@type = tokid if tokid # why?
				// tok.@type
			} else {
				return null;
			};
		};
		
		// Peek at a value in the current token stream.
		Lexer.prototype.value = function (index,val){
			var tok;
			if (tok = last(this._tokens,index)) {
				if (val) { tVs(tok,val) };
				return tV(tok);
				// tok.@value = val if val # why?
				// tok.@value
			} else {
				return null;
			};
		};
		
		
		// Are we in the midst of an unfinished expression?
		Lexer.prototype.unfinished = function (){
			if (LINE_CONTINUER.test(this._chunk)) { return true };
			return UNFINISHED.indexOf(this._lastTyp) >= 0;
		};
		
		// var tokens = ['\\','.', '?.', 'UNARY', 'MATH', '+', '-', 'SHIFT', 'RELATION', 'COMPARE', 'LOGIC', 'COMPOUND_ASSIGN', 'THROW', 'EXTENDS']
		
		// Converts newlines for string literals.
		Lexer.prototype.escapeLines = function (str,heredoc){
			return str.replace(MULTILINER,(heredoc ? ('\\n') : ('')));
		};
		
		// Constructs a string token by escaping quotes and newlines.
		Lexer.prototype.makeString = function (body,quote,heredoc){
			if (!(body)) { return quote + quote };
			body = body.replace(/\\([\s\S])/g,function(match,contents) {
				return (contents == '\n' || contents == quote) ? (contents) : (match);
			});
			// Does not work now
			body = body.replace(RegExp(("" + quote),"g"),'\\$&');
			return quote + this.escapeLines(body,heredoc) + quote;
		};
		
		// Throws a syntax error on the current `@line`.
		Lexer.prototype.error = function (message,len){
			if ((typeof this._line=='number'||this._line instanceof Number)) { message = ("" + message + " on line " + (this._line)) };
			
			if (len) {
				message += (" [" + (this._loc) + ":" + (this._loc + len) + "]");
			};
			
			var err = new SyntaxError(message);
			err.line = this._line;
			// err:columnNumber
			err = new ERR.ImbaParseError(err,{tokens: this._tokens,pos: this._tokens.length});
			err.region = [this._loc,this._loc + (len || 0)];
			throw err;
		};
		return Lexer;
	
	})()

/***/ },
/* 3 */
/***/ function(module, exports) {

	(function(){
		var TOK, LBRACKET, RBRACKET, LPAREN, RPAREN, INDENT, OUTDENT;
		
		
		module.exports.TOK = TOK = {};
		var TTERMINATOR = TOK.TERMINATOR = 1;
		var TIDENTIFIER = TOK.IDENTIFIER = TOK.IVAR = 2;
		var CONST = TOK.CONST = 3;
		var VAR = TOK.VAR = 4;
		var IF = TOK.IF = 5;
		var ELSE = TOK.ELSE = 6;
		var DEF = TOK.DEF = 7;
		
		function Token(type,value,loc,len){
			this._type = type;
			this._value = value;
			this._loc = loc != null ? (loc) : (-1);
			this._len = len || 0;
			this._meta = null;
			this.generated = false;
			this.newLine = false;
			this.spaced = false;
			return this;
		};
		
		exports.Token = Token; // export class 
		Token.prototype.type = function (){
			return this._type;
		};
		
		Token.prototype.value = function (){
			return this._value;
		};
		
		Token.prototype.traverse = function (){
			return;
		};
		
		Token.prototype.c = function (){
			return "" + this._value;
		};
		
		Token.prototype.toString = function (){
			return this._value;
		};
		
		Token.prototype.charAt = function (i){
			return this._value.charAt(i);
		};
		
		Token.prototype.slice = function (i){
			return this._value.slice(i);
		};
		
		Token.prototype.region = function (){
			return [this._loc,this._loc + (this._len || this._value.length)];
		};
		
		Token.prototype.sourceMapMarker = function (){
			return this._loc == -1 ? (':') : (("%$" + (this._loc) + "$%"));
			// @col == -1 ? '' : "%%{@line}${@col}%%"
		};
		
		
		function lex(){
			var token = this.tokens[this.pos++];
			var ttag;
			
			if (token) {
				ttag = token._type;
				this.yytext = token;
			} else {
				ttag = '';
			};
			
			return ttag;
		}; exports.lex = lex;
		
		
		// export def token typ, val, line, col, len do Token.new(typ,val,line, col or 0, len or 0) # [null,typ,val,loc]
		function token(typ,val){
			return new Token(typ,val,-1,0);
		}; exports.token = token;
		
		function typ(tok){
			return tok._type;
		}; exports.typ = typ;
		function val(tok){
			return tok._value;
		}; exports.val = val; // tok[offset + 1]
		function line(tok){
			return tok._line;
		}; exports.line = line; // tok[offset + 2]
		function loc(tok){
			return tok._loc;
		}; exports.loc = loc; // tok[offset + 2]
		
		function setTyp(tok,v){
			return tok._type = v;
		}; exports.setTyp = setTyp;
		function setVal(tok,v){
			return tok._value = v;
		}; exports.setVal = setVal;
		function setLine(tok,v){
			return tok._line = v;
		}; exports.setLine = setLine;
		function setLoc(tok,v){
			return tok._loc = v;
		}; exports.setLoc = setLoc;
		
		
		module.exports.LBRACKET = LBRACKET = new Token('{','{',0,0,0);
		module.exports.RBRACKET = RBRACKET = new Token('}','}',0,0,0);
		
		module.exports.LPAREN = LPAREN = new Token('(','(',0,0,0);
		module.exports.RPAREN = RPAREN = new Token(')',')',0,0,0);
		
		LBRACKET.generated = true;
		RBRACKET.generated = true;
		LPAREN.generated = true;
		RPAREN.generated = true;
		
		module.exports.INDENT = INDENT = new Token('INDENT','2',0,0,0);
		return module.exports.OUTDENT = OUTDENT = new Token('OUTDENT','2',0,0,0);
	
	})()

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function idx$(a,b){
			return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
		};
		
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		var INVERSES, LINEBREAKS;
		
		// The Imba language has a good deal of optional syntax, implicit syntax,
		// and shorthand syntax. This can greatly complicate a grammar and bloat
		// the resulting parse table. Instead of making the parser handle it all, we take
		// a series of passes over the token stream, using this **Rewriter** to convert
		// shorthand into the unambiguous long form, add implicit indentation and
		// parentheses, and generally clean things up.
		
		var T = __webpack_require__(3);
		var Token = T.Token;
		
		// Based on the original rewriter.coffee from CoffeeScript
		function Rewriter(){ };
		
		exports.Rewriter = Rewriter; // export class 
		Rewriter.prototype.tokens = function (){
			return this._tokens;
		};
		
		// Helpful snippet for debugging:
		//     console.log (t[0] + '/' + t[1] for t in @tokens).join ' '
		// Rewrite the token stream in multiple passes, one logical filter at
		// a time. This could certainly be changed into a single pass through the
		// stream, with a big ol' efficient switch, but it's much nicer to work with
		// like this. The order of these passes matters -- indentation must be
		// corrected before implicit parentheses can be wrapped around blocks of code.
		Rewriter.prototype.rewrite = function (tokens,opts){
			var token;
			if(opts === undefined) opts = {};
			this._tokens = tokens;
			this._options = opts;
			
			// console.log "tokens in: " + tokens:length
			if (opts.profile) { console.time("tokenize:rewrite") };
			
			var i = 0;
			// flag empty methods
			while (token = tokens[i]){
				var next = tokens[i + 1];
				if (token._type == 'DEF_BODY' && next && next._type == 'TERMINATOR') {
					token._type = 'DEF_EMPTY';
				};
				i++;
			};
			
			this.step("ensureFirstLine");
			this.step("removeLeadingNewlines");
			this.step("removeMidExpressionNewlines");
			this.step("tagDefArguments");
			this.step("closeOpenCalls");
			this.step("closeOpenIndexes");
			this.step("closeOpenTags");
			this.step("closeOpenTagAttrLists");
			this.step("addImplicitIndentation");
			this.step("tagPostfixConditionals");
			this.step("addImplicitBraces");
			this.step("addImplicitParentheses");
			
			if (opts.profile) { console.timeEnd("tokenize:rewrite") };
			// console.log "tokens out: " + @tokens:length
			return this._tokens;
		};
		
		Rewriter.prototype.step = function (fn){
			if (this._options.profile) {
				console.log(("---- starting " + fn + " ---- "));
				console.time(fn);
			};
			
			this[fn]();
			
			if (this._options.profile) {
				console.timeEnd(fn);
				console.log("\n\n");
			};
			return;
		};
		
		// Rewrite the token stream, looking one token ahead and behind.
		// Allow the return value of the block to tell us how many tokens to move
		// forwards (or backwards) in the stream, to make sure we don't miss anything
		// as tokens are inserted and removed, and the stream changes length under
		// our feet.
		Rewriter.prototype.scanTokens = function (block){
			var token;
			var tokens = this._tokens;
			
			var i = 0;
			while (token = tokens[i]){
				i += block.call(this,token,i,tokens);
			};
			
			return true;
		};
		
		Rewriter.prototype.detectEnd = function (i,condition,action){
			var tokens = this._tokens;
			var levels = 0;
			var starts = [];
			var token;
			var t,v;
			
			while (token = tokens[i]){
				if (levels == 0 && condition.call(this,token,i,starts)) {
					return action.call(this,token,i);
				};
				if (!(token) || levels < 0) {
					return action.call(this,token,i - 1);
				};
				
				t = T.typ(token);
				
				if (EXPRESSION_START.indexOf(t) >= 0) {
					if (levels == 0) { starts.push(i) };
					levels += 1;
				} else if (EXPRESSION_END.indexOf(t) >= 0) {
					levels -= 1;
				};
				i += 1;
			};
			return i - 1;
		};
		
		Rewriter.prototype.ensureFirstLine = function (){
			var tok = this._tokens[0];
			
			if (T.typ(tok) == 'TERMINATOR') {
				// console.log "adding bodystart"
				this._tokens = [T.token('BODYSTART','BODYSTART')].concat(this._tokens);
				// T.setTyp(tok,'HEADER')
			};
			return;
		};
		
		// Leading newlines would introduce an ambiguity in the grammar, so we
		// dispatch them here.
		Rewriter.prototype.removeLeadingNewlines = function (){
			var at = 0;
			
			for (var i = 0, ary = iter$(this._tokens), len = ary.length; i < len; i++) {
				if (T.typ(ary[i]) != 'TERMINATOR') {
					at = i;break;
				};
			};
			
			if (at) { this._tokens.splice(0,at) };
			
			return;
		};
		
		// Some blocks occur in the middle of expressions -- when we're expecting
		// this, remove their trailing newlines.
		Rewriter.prototype.removeMidExpressionNewlines = function (){
			var self = this;
			return self.scanTokens(function(token,i,tokens) { // do |token,i,tokens|
				var next = self.tokenType(i + 1);
				
				if (!(T.typ(token) == 'TERMINATOR' && EXPRESSION_CLOSE.indexOf(next) >= 0)) { return 1 };
				if (next == 'OUTDENT') { return 1 };
				tokens.splice(i,1);
				return 0;
			});
		};
		
		
		Rewriter.prototype.tagDefArguments = function (){
			return true;
		};
		
		// The lexer has tagged the opening parenthesis of a method call. Match it with
		// its paired close. We have the mis-nested outdent case included here for
		// calls that close on the same line, just before their outdent.
		Rewriter.prototype.closeOpenCalls = function (){
			var self = this;
			var condition = function(token,i) {
				var t = T.typ(token);
				return (t == ')' || t == 'CALL_END') || t == 'OUTDENT' && self.tokenType(i - 1) == ')';
			};
			
			var action = function(token,i) {
				var t = T.typ(token);
				var tok = self._tokens[t == 'OUTDENT' ? (i - 1) : (i)];
				return T.setTyp(tok,'CALL_END');
			};
			
			return self.scanTokens(function(token,i) {
				if (T.typ(token) == 'CALL_START') { self.detectEnd(i + 1,condition,action) };
				return 1;
			});
		};
		
		// The lexer has tagged the opening parenthesis of an indexing operation call.
		// Match it with its paired close.
		Rewriter.prototype.closeOpenIndexes = function (){
			var self = this;
			var condition = function(token,i) { return idx$(T.typ(token),[']','INDEX_END']) >= 0; };
			var action = function(token,i) { return T.setTyp(token,'INDEX_END'); };
			
			return self.scanTokens(function(token,i) {
				if (T.typ(token) == 'INDEX_START') { self.detectEnd(i + 1,condition,action) };
				return 1;
			});
		};
		
		
		Rewriter.prototype.closeOpenTagAttrLists = function (){
			var self = this;
			var condition = function(token,i) { return idx$(T.typ(token),[')','TAG_ATTRS_END']) >= 0; };
			var action = function(token,i) { return T.setTyp(token,'TAG_ATTRS_END'); }; // 'TAG_ATTRS_END'
			
			return self.scanTokens(function(token,i) {
				if (T.typ(token) == 'TAG_ATTRS_START') { self.detectEnd(i + 1,condition,action) };
				return 1;
			});
		};
		
		// The lexer has tagged the opening parenthesis of an indexing operation call.
		// Match it with its paired close. Should be done in lexer directly
		Rewriter.prototype.closeOpenTags = function (){
			var self = this;
			var condition = function(token,i) { return idx$(T.typ(token),['>','TAG_END']) >= 0; };
			var action = function(token,i) { return T.setTyp(token,'TAG_END'); }; // token[0] = 'TAG_END'
			
			return self.scanTokens(function(token,i) {
				if (T.typ(token) == 'TAG_START') { self.detectEnd(i + 1,condition,action) };
				return 1;
			});
		};
		
		Rewriter.prototype.addImplicitCommas = function (){
			return;
		};
		
		Rewriter.prototype.addImplicitBlockCalls = function (){
			var token;
			var i = 1;
			var tokens = this._tokens;
			
			while (token = tokens[i]){
				var t = token._type;
				var v = token._value;
				// hmm
				if (t == 'DO' && (v == 'INDEX_END' || v == 'IDENTIFIER' || v == 'NEW')) {
					tokens.splice(i + 1,0,T.token('CALL_END',')'));
					tokens.splice(i + 1,0,T.token('CALL_START','('));
					i++;
				};
				i++;
			};
			
			return;
		};
		
		// Object literals may be written with implicit braces, for simple cases.
		// Insert the missing braces here, so that the parser doesn't have to.
		Rewriter.prototype.addImplicitBraces = function (){
			var self = this;
			var stack = [];
			var start = null;
			var startIndent = 0;
			var startIdx = null;
			
			var noBraceTag = ['CLASS','IF','UNLESS','TAG','WHILE','FOR','UNTIL','CATCH','FINALLY','MODULE','LEADING_WHEN'];
			var noBraceContext = ['IF','TERNARY','FOR'];
			
			var noBrace = false;
			
			var scope = function() {
				return stack[stack.length - 1] || [];
			};
			
			var action = function(token,i) {
				return self._tokens.splice(i,0,T.RBRACKET);
			};
			
			var open = function(token,i) {
				return self._tokens.splice(i,0,T.LBRACKET);
			};
			
			var close = function(token,i) {
				return self._tokens.splice(i,0,T.RBRACKET);
			};
			
			var stackToken = function(a,b) {
				return [a,b];
			};
			
			return self.scanTokens(function(token,i,tokens) {
				var type = T.typ(token);
				var v = T.val(token);
				var ctx = stack[stack.length - 1] || [];
				var idx;
				
				if (noBraceContext.indexOf(type) >= 0) {
					// console.log "found noBraceTag {type}"
					stack.push(stackToken(type,i));
					return 1;
				};
				
				if (v == '?') {
					// console.log('TERNARY OPERATOR!')
					stack.push(stackToken('TERNARY',i));
					return 1;
				};
				
				// no need to test for this here as well as in
				if (EXPRESSION_START.indexOf(type) >= 0) {
					if (type == 'INDENT' && noBraceContext.indexOf(ctx[0]) >= 0) {
						stack.pop();
					};
					
					// console.log('expression start',type,ctx[0])
					if (type == 'INDENT' && self.tokenType(i - 1) == '{') {
						// stack ?!? no token
						stack.push(stackToken('{',i)); // should not autogenerate another?
					} else {
						stack.push(stackToken(type,i));
					};
					return 1;
				};
				
				if (EXPRESSION_END.indexOf(type) >= 0) {
					// console.log "EXPRESSION_END at {type} - stack is {ctx[0]}"
					if (ctx[0] == 'TERNARY') { // FIX?
						stack.pop();
					};
					
					start = stack.pop();
					if (!(start)) {
						console.log("NO STACK!!");
					};
					start[2] = i;
					
					// seems like the stack should use tokens, no?)
					if (start[0] == '{' && start.generated) { //  # type != '}' # and start:generated
						close(token,i);
						return 1;
					};
					
					return 1;
				};
				
				// is this correct? same for if/class etc?
				if (ctx[0] == 'TERNARY' && (type == 'TERMINATOR' || type == 'OUTDENT')) {
					stack.pop();
					return 1;
				};
				
				if (noBraceContext.indexOf(ctx[0]) >= 0 && type == 'INDENT') {
					console.log("popping noBraceContext");
					stack.pop();
					return 1;
				};
				
				
				if (type == ',') {
					// automatically add an ending here if inside:generated scope?
					// it is important that this is:generated(!)
					if (ctx[0] == '{' && ctx.generated) {
						tokens.splice(i,0,T.RBRACKET);
						stack.pop();
						return 2;
					} else {
						return 1;
					};
					true;
				};
				
				// found a type
				if (type == ':' && ctx[0] != '{' && ctx[0] != 'TERNARY' && (noBraceContext.indexOf(ctx[0]) == -1)) {
					// could just check if the end was right before this?
					
					if (start && start[2] == i - 1) {
						// console.log('this expression was just ending before colon!')
						idx = start[1] - 1; // these are the stackTokens
					} else {
						// console.log "rewrite here? #{i}"
						idx = i - 2; // if start then start[1] - 1 else i - 2
						// idx = idx - 1 if tokenType(idx) is 'TERMINATOR'
					};
					
					while (self.tokenType(idx - 1) == 'HERECOMMENT'){
						idx -= 2;
					};
					
					var t0 = tokens[idx - 1];
					
					if (t0 && T.typ(t0) == '}' && t0.generated) {
						tokens.splice(idx - 1,1);
						var s = stackToken('{');
						s.generated = true;
						stack.push(s);
						return 0;
					} else if (t0 && T.typ(t0) == ',' && self.tokenType(idx - 2) == '}') {
						tokens.splice(idx - 2,1);
						s = stackToken('{');
						s.generated = true;
						stack.push(s);
						return 0;
					} else {
						s = stackToken('{');
						s.generated = true;
						stack.push(s);
						open(token,idx + 1);
						return 2;
					};
				};
				
				// we probably need to run through autocall first?!
				
				if (type == 'DO') { // and ctx:generated
					var prev = T.typ(tokens[i - 1]); // [0]
					if (['NUMBER','STRING','REGEX','SYMBOL',']','}',')','STRING_END'].indexOf(prev) >= 0) {
						
						var tok = T.token(',',',');
						tok.generated = true;
						tokens.splice(i,0,tok);
						
						if (ctx.generated) {
							close(token,i);
							stack.pop();
							return 2;
						};
					};
				};
				
				if ((type == 'TERMINATOR' || type == 'OUTDENT' || type == 'DEF_BODY') && ctx.generated) {
					close(token,i);
					stack.pop();
					return 2;
				};
				
				return 1;
			});
		};
		
		// Methods may be optionally called without parentheses, for simple cases.
		// Insert the implicit parentheses here, so that the parser doesn't have to
		// deal with them.
		// Practically everything will now be callable this way (every identifier)
		Rewriter.prototype.addImplicitParentheses = function (){
			
			var self = this, token;
			var noCallTag = ['CLASS','IF','UNLESS','TAG','WHILE','FOR','UNTIL','CATCH','FINALLY','MODULE','LEADING_WHEN'];
			
			var action = function(token,i) {
				return self._tokens.splice(i,0,T.token('CALL_END',')'));
			};
			
			// console.log "adding implicit parenthesis" # ,self:scanTokens
			var tokens = self._tokens;
			
			var noCall = false;
			var seenFor = false;
			var endCallAtTerminator = false;
			
			var i = 0;
			while (token = tokens[i]){
				
				// to handle cases like:
				// if a(do yes).test
				// 	yes
				// we need to keep a stack for balanced pairs
				// until then you must explicitly end the call like
				// if a(do yes).test()
				// 	yes
				
				var type = token._type;
				
				var prev = tokens[i - 1];
				var current = tokens[i];
				var next = tokens[i + 1];
				
				var pt = prev && prev._type;
				var nt = next && next._type;
				
				// if pt == 'WHEN'
				// Never make these tags implicitly call
				// should we not just remove these from IMPLICIT_FUNC?
				if ((pt == ')' || pt == ']') && type == 'INDENT') {
					noCall = true;
				};
				
				if (noCallTag.indexOf(pt) >= 0) {
					// console.log("seen nocall tag {pt} ({pt} {type} {nt})")
					endCallAtTerminator = true;
					noCall = true;
					if (pt == 'FOR') { seenFor = true };
				};
				
				
				var callObject = false;
				var callIndent = false;
				
				// [prev, current, next] = tokens[i - 1 .. i + 1]
				
				// check for comments
				// console.log "detect end??"
				if (!(noCall) && type == 'INDENT' && next) {
					var prevImpFunc = pt && IMPLICIT_FUNC.indexOf(pt) >= 0;
					var nextImpCall = nt && IMPLICIT_CALL.indexOf(nt) >= 0;
					callObject = ((next.generated && nt == '{') || nextImpCall) && prevImpFunc;
					callIndent = nextImpCall && prevImpFunc;
				};
				
				var seenSingle = false;
				var seenControl = false;
				// Hmm ?
				
				// this is not correct if this is inside a block,no?
				if ((type == 'TERMINATOR' || type == 'OUTDENT' || type == 'INDENT')) {
					endCallAtTerminator = false;
					noCall = false;
				};
				
				if (type == '?' && prev && !prev.spaced) { token.call = true };
				
				// where does fromThem come from?
				if (token.fromThen) {
					i += 1;continue;
				};
				// here we deal with :spaced and :newLine
				if (!(callObject || callIndent || (prev && prev.spaced) && (prev.call || IMPLICIT_FUNC.indexOf(pt) >= 0) && (IMPLICIT_CALL.indexOf(type) >= 0 || !(token.spaced || token.newLine) && IMPLICIT_UNSPACED_CALL.indexOf(type) >= 0))) {
					i += 1;continue;
				};
				
				
				tokens.splice(i,0,T.token('CALL_START','('));
				// console.log "added ( {prev}"
				var cond = function(token,i) {
					var type = T.typ(token);
					if (!(seenSingle) && token.fromThen) { return true };
					var ifelse = type == 'IF' || type == 'UNLESS' || type == 'ELSE';
					if (ifelse || type == 'CATCH') { seenSingle = true };
					if (ifelse || type == 'SWITCH' || type == 'TRY') { seenControl = true };
					var prev = self.tokenType(i - 1);
					
					if ((type == '.' || type == '?.' || type == '::') && prev == 'OUTDENT') { return true };
					if (endCallAtTerminator && (type == 'INDENT' || type == 'TERMINATOR')) { return true };
					if ((type == 'WHEN' || type == 'BY') && !(seenFor)) {
						// console.log "dont close implicit call outside for"
						return false;
					};
					
					var post = tokens[i + 1];
					var postTyp = post && T.typ(post);
					// WTF
					return !token.generated && prev != ',' && (IMPLICIT_END.indexOf(type) >= 0 || (type == 'INDENT' && !(seenControl)) || (type == 'DOS' && prev != '=')) && (type != 'INDENT' || (self.tokenType(i - 2) != 'CLASS' && IMPLICIT_BLOCK.indexOf(prev) == -1 && !(post && ((post.generated && postTyp == '{') || IMPLICIT_CALL.indexOf(postTyp) >= 0))));
				};
				
				// The action for detecting when the call should end
				// console.log "detect end??"
				self.detectEnd(i + 1,cond,action);
				if (T.typ(prev) == '?') { T.setTyp(prev,'FUNC_EXIST') };
				i += 2;
				// need to reset after a match
				endCallAtTerminator = false;
				noCall = false;
				seenFor = false;
			};
			
			
			return;
		};
		
		// Because our grammar is LALR(1), it can't handle some single-line
		// expressions that lack ending delimiters. The **Rewriter** adds the implicit
		// blocks, so it doesn't need to. ')' can close a single-line block,
		// but we need to make sure it's balanced.
		Rewriter.prototype.addImplicitIndentation = function (){
			
			
			var self = this, token;
			var i = 0;
			var tokens = self._tokens;
			while (token = tokens[i]){
				var type = T.typ(token);
				var next = self.tokenType(i + 1);
				
				// why are we removing terminators after then? should be able to handle
				if (type == 'TERMINATOR' && next == 'THEN') {
					tokens.splice(i,1);
					continue;
				};
				
				if (type == 'CATCH' && idx$(self.tokenType(i + 2),['OUTDENT','TERMINATOR','FINALLY']) >= 0) {
					tokens.splice.apply(tokens,[].concat([i + 2,0], [].slice.call(self.indentation(token))));
					i += 4;continue;
				};
				
				if (SINGLE_LINERS.indexOf(type) >= 0 && (next != 'INDENT' && next != 'BLOCK_PARAM_START') && !(type == 'ELSE' && next == 'IF') && type != 'ELIF') {
					
					var starter = type;
					
					var indent = T.token('INDENT','2');
					var outdent = T.OUTDENT;
					// var indent, outdent = indentation(token)
					if (starter == 'THEN') { indent.fromThen = true }; // setting special values for these -- cannot really reuse?
					indent.generated = true;
					// outdent:generated = true
					tokens.splice(i + 1,0,indent);
					
					var condition = function(token,i) {
						var t = T.typ(token);
						return T.val(token) != ';' && SINGLE_CLOSERS.indexOf(t) >= 0 && !(t == 'ELSE' && starter != 'IF' && starter != 'THEN');
					};
					
					var action = function(token,i) {
						var idx = self.tokenType(i - 1) == ',' ? (i - 1) : (i);
						return tokens.splice(idx,0,outdent);
					};
					
					self.detectEnd(i + 2,condition,action);
					if (type == 'THEN') { tokens.splice(i,1) };
				};
				
				i++;
			};
			
			return;
		};
		
		// Tag postfix conditionals as such, so that we can parse them with a
		// different precedence.
		Rewriter.prototype.tagPostfixConditionals = function (){
			var self = this;
			var condition = function(token,i) { return idx$(T.typ(token),['TERMINATOR','INDENT']) >= 0; };
			
			return self.scanTokens(function(token,i) {
				var typ = T.typ(token);
				if (!(typ == 'IF' || typ == 'FOR')) { return 1 };
				var original = token;
				self.detectEnd(i + 1,condition,function(token,i) {
					if (T.typ(token) != 'INDENT') { return T.setTyp(original,'POST_' + T.typ(original)) };
				});
				return 1;
			});
		};
		
		// Generate the indentation tokens, based on another token on the same line.
		Rewriter.prototype.indentation = function (token){
			return [T.token('INDENT','2'),T.token('OUTDENT','2')];
		};
		
		// Look up a type by token index.
		Rewriter.prototype.type = function (i){
			// if i < 0 then return null
			var tok = this._tokens[i];
			return tok && T.typ(tok);
			// if tok then tok[0] else null
		};
		
		Rewriter.prototype.tokenType = function (i){
			var tok = this._tokens[i];
			return tok && T.typ(tok);
			// return tok and tok[0]
		};
		
		// Constants
		// ---------
		
		// List of the token pairs that must be balanced.
		var BALANCED_PAIRS = [
			['(',')'],
			['[',']'],
			['{','}'],
			['{{','}}'],
			['INDENT','OUTDENT'],
			['CALL_START','CALL_END'],
			['PARAM_START','PARAM_END'],
			['INDEX_START','INDEX_END'],
			['TAG_START','TAG_END'],
			['TAG_PARAM_START','TAG_PARAM_END'],
			['TAG_ATTRS_START','TAG_ATTRS_END'],
			['BLOCK_PARAM_START','BLOCK_PARAM_END']
		];
		
		// The inverse mappings of `BALANCED_PAIRS` we're trying to fix up, so we can
		// look things up from either end.
		module.exports.INVERSES = INVERSES = {};
		
		// The tokens that signal the start/end of a balanced pair.
		// var EXPRESSION_START = []
		// var EXPRESSION_END   = []
		
		for (var i = 0, ary = iter$(BALANCED_PAIRS), len = ary.length, pair; i < len; i++) {
			pair = ary[i];
			var left = pair[0];
			var rite = pair[1];
			INVERSES[rite] = left;
			INVERSES[left] = rite;
		};
		
		var EXPRESSION_START = ['(','[','{','INDENT','CALL_START','PARAM_START','INDEX_START','TAG_PARAM_START','BLOCK_PARAM_START','STRING_START','{{','TAG_START'];
		var EXPRESSION_END = [')',']','}','OUTDENT','CALL_END','PARAM_END','INDEX_END','TAG_PARAM_END','BLOCK_PARAM_END','STRING_END','}}','TAG_END'];
		
		var IDENTIFIERS = ['IDENTIFIER','GVAR','IVAR','CVAR','CONST','ARGVAR'];
		
		// Tokens that indicate the close of a clause of an expression.
		var EXPRESSION_CLOSE = ['CATCH','WHEN','ELSE','FINALLY'].concat(EXPRESSION_END);
		
		// Tokens that, if followed by an `IMPLICIT_CALL`, indicate a function invocation.
		var IMPLICIT_FUNC = ['IDENTIFIER','SUPER','@','THIS','SELF','EVENT','TRIGGER','TAG_END','IVAR',
		'GVAR','CONST','ARGVAR','NEW','BREAK','CONTINUE','RETURN'];
		
		// If preceded by an `IMPLICIT_FUNC`, indicates a function invocation.
		var IMPLICIT_CALL = [
			'SELECTOR','IDENTIFIER','NUMBER','STRING','SYMBOL','JS','REGEX','NEW','PARAM_START','CLASS',
			'IF','UNLESS','TRY','SWITCH','THIS','BOOL','TRUE','FALSE','NULL','UNDEFINED','UNARY','SUPER','IVAR','GVAR','CONST','ARGVAR','SELF',
			'@','[','(','{','--','++','SELECTOR','TAG_START','TAGID','#','SELECTOR_START','IDREF','SPLAT','DO','BLOCK_ARG',
			'FOR','STRING_START','CONTINUE','BREAK'
		]; // '->', '=>', why does it not work with symbol?
		
		var IMPLICIT_INDENT_CALL = [
			'FOR'
		];
		// is not do an implicit call??
		
		var IMPLICIT_UNSPACED_CALL = ['+','-'];
		
		// Tokens indicating that the implicit call must enclose a block of expressions.
		var IMPLICIT_BLOCK = ['{','[',',','BLOCK_PARAM_END','DO']; // '->', '=>', 
		
		var CONDITIONAL_ASSIGN = ['||=','&&=','?=','&=','|='];
		var COMPOUND_ASSIGN = ['-=','+=','/=','*=','%=','||=','&&=','?=','<<=','>>=','>>>=','&=','^=','|='];
		var UNARY = ['!','~','NEW','TYPEOF','DELETE'];
		var LOGIC = ['&&','||','&','|','^'];
		
		// optimize for fixed arrays
		var NO_IMPLICIT_BLOCK_CALL = [
			'CALL_END','=','DEF_BODY','(','CALL_START',',',':','RETURN',
			'-=','+=','/=','*=','%=','||=','&&=','?=','<<=','>>=','>>>=','&=','^=','|='
		]; // .concat(COMPOUND_ASSIGN)
		
		
		// console.log NO_IMPLICIT_BLOCK_CALL:length
		// NO_IMPLICIT_BLOCK_CALL
		// IMPLICIT_COMMA = ['->', '=>', '{', '[', 'NUMBER', 'STRING', 'SYMBOL', 'IDENTIFIER','DO']
		
		var IMPLICIT_COMMA = ['DO'];
		
		// Tokens that always mark the end of an implicit call for single-liners.
		var IMPLICIT_END = ['POST_IF','POST_UNLESS','POST_FOR','WHILE','UNTIL','WHEN','BY','LOOP','TERMINATOR','DEF_BODY','DEF_FRAGMENT'];
		
		// Single-line flavors of block expressions that have unclosed endings.
		// The grammar can't disambiguate them, so we insert the implicit indentation.
		var SINGLE_LINERS = ['ELSE','TRY','FINALLY','THEN','BLOCK_PARAM_END','DO','BEGIN','CATCH_VAR']; // '->', '=>', really?
		var SINGLE_CLOSERS = ['TERMINATOR','CATCH','FINALLY','ELSE','OUTDENT','LEADING_WHEN'];
		
		// Tokens that end a line.
		return LINEBREAKS = ['TERMINATOR','INDENT','OUTDENT'];
	
	})()

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module, process) {/* parser generated by jison-fork */
	var parser = (function(){
	var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,4],$V1=[1,6],$V2=[1,32],$V3=[1,33],$V4=[1,34],$V5=[1,35],$V6=[1,75],$V7=[1,115],$V8=[1,128],$V9=[1,121],$Va=[1,122],$Vb=[1,123],$Vc=[1,120],$Vd=[1,124],$Ve=[1,131],$Vf=[1,114],$Vg=[1,132],$Vh=[1,80],$Vi=[1,81],$Vj=[1,82],$Vk=[1,83],$Vl=[1,84],$Vm=[1,85],$Vn=[1,86],$Vo=[1,73],$Vp=[1,118],$Vq=[1,95],$Vr=[1,91],$Vs=[1,88],$Vt=[1,71],$Vu=[1,65],$Vv=[1,66],$Vw=[1,111],$Vx=[1,90],$Vy=[1,87],$Vz=[1,28],$VA=[1,29],$VB=[1,96],$VC=[1,94],$VD=[1,112],$VE=[1,113],$VF=[1,126],$VG=[1,67],$VH=[1,68],$VI=[1,119],$VJ=[1,11],$VK=[1,127],$VL=[1,78],$VM=[1,37],$VN=[1,43],$VO=[1,110],$VP=[1,69],$VQ=[1,89],$VR=[1,125],$VS=[1,59],$VT=[1,74],$VU=[1,105],$VV=[1,106],$VW=[1,107],$VX=[1,129],$VY=[1,130],$VZ=[1,63],$V_=[1,104],$V$=[1,51],$V01=[1,52],$V11=[1,53],$V21=[1,54],$V31=[1,55],$V41=[1,56],$V51=[1,134],$V61=[1,6,11,137],$V71=[1,136],$V81=[1,6,11,14,137],$V91=[1,144],$Va1=[1,145],$Vb1=[1,147],$Vc1=[1,148],$Vd1=[1,141],$Ve1=[1,140],$Vf1=[1,142],$Vg1=[1,143],$Vh1=[1,146],$Vi1=[1,151],$Vj1=[1,6,10,11,14,22,71,90,97,106,112,126,135,137,147,171,200,201,212,213,214,219,220,229,238,239,242,243,246,247,248],$Vk1=[2,263],$Vl1=[1,158],$Vm1=[1,164],$Vn1=[1,162],$Vo1=[1,160],$Vp1=[1,161],$Vq1=[1,165],$Vr1=[1,163],$Vs1=[1,6,10,11,14,22,90,97,137],$Vt1=[1,6,11,14,137,212,214,219,220,238],$Vu1=[1,6,10,11,14,21,22,71,88,89,90,97,106,111,112,126,135,137,144,147,171,180,181,183,196,200,201,212,213,214,219,220,229,238,239,242,243,246,247,248],$Vv1=[2,231],$Vw1=[1,178],$Vx1=[1,176],$Vy1=[1,6,10,11,14,21,22,71,88,89,90,97,106,111,112,117,126,135,137,144,147,171,180,181,183,196,200,201,212,213,214,219,220,229,238,239,242,243,246,247,248],$Vz1=[2,227],$VA1=[6,14,53,54,88,91,106,111,113,116],$VB1=[1,212],$VC1=[1,217],$VD1=[1,6,10,11,14,21,22,71,88,89,90,97,106,111,112,117,126,135,137,144,147,171,180,181,183,196,200,201,212,213,214,219,220,229,238,239,242,243,244,245,246,247,248,249],$VE1=[1,227],$VF1=[1,224],$VG1=[1,229],$VH1=[6,10,14,90],$VI1=[2,244],$VJ1=[1,257],$VK1=[1,247],$VL1=[1,276],$VM1=[1,277],$VN1=[51,89],$VO1=[85,86,87,88,91,92,93,94,95,96,100,102],$VP1=[1,289],$VQ1=[1,6,10,11,14,21,22,53,54,71,88,89,90,91,97,106,111,112,113,116,117,126,135,137,144,147,171,180,181,183,196,200,201,212,213,214,219,220,229,238,239,242,243,244,245,246,247,248,249],$VR1=[1,295],$VS1=[51,89,96,225],$VT1=[1,6,10,11,14,21,22,67,69,70,71,88,89,90,97,106,111,112,126,135,137,144,147,171,180,181,183,196,200,201,212,213,214,219,220,229,238,239,242,243,246,247,248],$VU1=[1,6,10,11,14,21,22,71,88,89,90,97,106,111,112,126,135,137,144,147,171,180,181,183,196,200,201,207,208,212,213,214,219,220,229,232,234,237,238,239,242,243,246,247,248],$VV1=[51,53,54,58],$VW1=[1,326],$VX1=[1,327],$VY1=[1,6,10,11,14,22,71,90,97,106,112,135,137,147,200,201,212,213,214,219,220,229,238],$VZ1=[1,340],$V_1=[1,344],$V$1=[1,6,11,14,22,71,90,97,106,112,126,135,137,147,171,200,201,212,213,214,219,220,229,238,239,242,243,246,247,248],$V02=[6,14,106],$V12=[1,354],$V22=[1,6,10,11,14,21,22,71,89,90,97,106,112,126,135,137,147,171,200,201,212,213,214,219,220,229,238,239,242,243,246,247,248],$V32=[14,28],$V42=[1,6,11,14,28,137,212,214,219,220,238],$V52=[2,284],$V62=[1,6,10,11,14,21,22,71,88,89,90,97,106,111,112,117,126,135,137,144,147,171,180,181,183,196,200,201,212,213,214,219,220,227,228,229,238,239,242,243,244,245,246,247,248,249],$V72=[2,184],$V82=[1,369],$V92=[6,10,11,14,22,97],$Va2=[14,147],$Vb2=[2,186],$Vc2=[1,379],$Vd2=[1,380],$Ve2=[1,381],$Vf2=[1,385],$Vg2=[6,10,11,14,90],$Vh2=[6,10,11,14,90,135],$Vi2=[1,6,10,11,14,22,71,90,97,106,112,135,137,147,200,201,220,229,238],$Vj2=[1,6,10,11,14,22,71,90,97,106,112,135,137,147,200,201,213,220,229,238],$Vk2=[227,228],$Vl2=[14,227,228],$Vm2=[1,6,11,14,22,71,90,97,106,112,135,137,147,171,200,201,212,213,214,219,220,229,238,239,242,243,246,247,248],$Vn2=[88,91],$Vo2=[1,406],$Vp2=[1,407],$Vq2=[21,88,91,164,165],$Vr2=[1,6,10,11,14,22,71,90,97,106,112,126,135,137,147,171,200,201,212,213,214,219,220,229,238,239,242,243,247,248],$Vs2=[1,6,10,11,14,22,71,90,97,106,112,135,137,147,200,201,213,229],$Vt2=[19,20,23,24,26,32,51,53,54,56,58,60,62,64,66,73,74,75,76,77,78,79,80,83,89,91,96,103,112,122,123,124,130,136,143,144,151,152,154,156,157,158,175,184,185,188,193,194,197,198,204,210,212,214,216,219,220,230,236,240,241,242,243,244,245],$Vu2=[1,6,10,11,14,22,71,90,97,106,112,126,135,137,147,171,200,201,212,213,214,219,220,229,232,237,238,239,242,243,246,247,248],$Vv2=[11,232,234],$Vw2=[1,453],$Vx2=[2,185],$Vy2=[6,10,11],$Vz2=[1,461],$VA2=[14,22,147],$VB2=[1,469],$VC2=[1,6,10,11,14,22,71,90,97,106,112,135,137,147,200,201,212,214,219,220,229,238],$VD2=[51,58,89],$VE2=[14,22],$VF2=[1,492],$VG2=[10,14],$VH2=[1,542],$VI2=[6,10];
	var parser = {trace: function trace() { },
	yy: {},
	symbols_: {"error":2,"Root":3,"Body":4,"Block":5,"TERMINATOR":6,"BODYSTART":7,"Line":8,"Terminator":9,"INDENT":10,"OUTDENT":11,"Splat":12,"Expression":13,",":14,"Comment":15,"Statement":16,"Return":17,"Throw":18,"STATEMENT":19,"BREAK":20,"CALL_START":21,"CALL_END":22,"CONTINUE":23,"DEBUGGER":24,"ImportStatement":25,"IMPORT":26,"ImportArgList":27,"FROM":28,"ImportFrom":29,"AS":30,"ImportArg":31,"STRING":32,"VarIdentifier":33,"Await":34,"Value":35,"Code":36,"Operation":37,"Assign":38,"If":39,"Ternary":40,"Try":41,"While":42,"For":43,"Switch":44,"Class":45,"Module":46,"TagDeclaration":47,"Tag":48,"Property":49,"Identifier":50,"IDENTIFIER":51,"Ivar":52,"IVAR":53,"CVAR":54,"Gvar":55,"GVAR":56,"Const":57,"CONST":58,"Argvar":59,"ARGVAR":60,"Symbol":61,"SYMBOL":62,"AlphaNumeric":63,"NUMBER":64,"InterpolatedString":65,"STRING_START":66,"NEOSTRING":67,"Interpolation":68,"STRING_END":69,"{{":70,"}}":71,"Literal":72,"JS":73,"REGEX":74,"BOOL":75,"TRUE":76,"FALSE":77,"NULL":78,"UNDEFINED":79,"RETURN":80,"Arguments":81,"TagSelector":82,"SELECTOR_START":83,"TagSelectorType":84,"SELECTOR_NS":85,"SELECTOR_ID":86,"SELECTOR_CLASS":87,".":88,"{":89,"}":90,"#":91,"SELECTOR_COMBINATOR":92,"SELECTOR_PSEUDO_CLASS":93,"SELECTOR_GROUP":94,"UNIVERSAL_SELECTOR":95,"[":96,"]":97,"SELECTOR_ATTR_OP":98,"TagSelectorAttrValue":99,"SELECTOR_TAG":100,"Selector":101,"SELECTOR_END":102,"TAG_START":103,"TagOptions":104,"TagAttributes":105,"TAG_END":106,"TagBody":107,"TagTypeName":108,"Self":109,"TAG_TYPE":110,"INDEX_START":111,"INDEX_END":112,"@":113,"TagAttr":114,"OptComma":115,"TAG_ATTR":116,"=":117,"TagAttrValue":118,"ArgList":119,"TagTypeDef":120,"TagDeclarationBlock":121,"EXTEND":122,"LOCAL":123,"TAG":124,"TagType":125,"COMPARE":126,"TagDeclKeywords":127,"TAG_ID":128,"TagId":129,"IDREF":130,"Assignable":131,"Outdent":132,"AssignObj":133,"ObjAssignable":134,":":135,"(":136,")":137,"HERECOMMENT":138,"COMMENT":139,"Method":140,"Do":141,"Begin":142,"BEGIN":143,"DO":144,"BLOCK_PARAM_START":145,"ParamList":146,"BLOCK_PARAM_END":147,"PropType":148,"PropertyIdentifier":149,"Object":150,"PROP":151,"ATTR":152,"TupleAssign":153,"VAR":154,"MethodDeclaration":155,"GLOBAL":156,"EXPORT":157,"DEF":158,"MethodScope":159,"MethodScopeType":160,"MethodIdentifier":161,"MethodBody":162,"MethodReceiver":163,"DEF_BODY":164,"DEF_EMPTY":165,"This":166,"Param":167,"Array":168,"ParamVar":169,"SPLAT":170,"LOGIC":171,"BLOCK_ARG":172,"VarReference":173,"VarAssignable":174,"LET":175,"SimpleAssignable":176,"NEW":177,"Super":178,"SoakableOp":179,"?:":180,".:":181,"IndexValue":182,"?.":183,"SUPER":184,"AWAIT":185,"Parenthetical":186,"Range":187,"ARGUMENTS":188,"Invocation":189,"Slice":190,"AssignList":191,"ClassStart":192,"CLASS":193,"MODULE":194,"OptFuncExist":195,"FUNC_EXIST":196,"THIS":197,"SELF":198,"RangeDots":199,"..":200,"...":201,"Arg":202,"SimpleArgs":203,"TRY":204,"Catch":205,"Finally":206,"FINALLY":207,"CATCH":208,"CATCH_VAR":209,"THROW":210,"WhileSource":211,"WHILE":212,"WHEN":213,"UNTIL":214,"Loop":215,"LOOP":216,"ForBody":217,"ForKeyword":218,"FOR":219,"POST_FOR":220,"ForBlock":221,"ForStart":222,"ForSource":223,"ForVariables":224,"OWN":225,"ForValue":226,"FORIN":227,"FOROF":228,"BY":229,"SWITCH":230,"Whens":231,"ELSE":232,"When":233,"LEADING_WHEN":234,"IfBlock":235,"IF":236,"ELIF":237,"POST_IF":238,"?":239,"UNARY":240,"SQRT":241,"-":242,"+":243,"--":244,"++":245,"MATH":246,"SHIFT":247,"RELATION":248,"COMPOUND_ASSIGN":249,"$accept":0,"$end":1},
	terminals_: {2:"error",6:"TERMINATOR",7:"BODYSTART",10:"INDENT",11:"OUTDENT",14:",",19:"STATEMENT",20:"BREAK",21:"CALL_START",22:"CALL_END",23:"CONTINUE",24:"DEBUGGER",26:"IMPORT",28:"FROM",30:"AS",32:"STRING",51:"IDENTIFIER",53:"IVAR",54:"CVAR",56:"GVAR",58:"CONST",60:"ARGVAR",62:"SYMBOL",64:"NUMBER",66:"STRING_START",67:"NEOSTRING",69:"STRING_END",70:"{{",71:"}}",73:"JS",74:"REGEX",75:"BOOL",76:"TRUE",77:"FALSE",78:"NULL",79:"UNDEFINED",80:"RETURN",83:"SELECTOR_START",85:"SELECTOR_NS",86:"SELECTOR_ID",87:"SELECTOR_CLASS",88:".",89:"{",90:"}",91:"#",92:"SELECTOR_COMBINATOR",93:"SELECTOR_PSEUDO_CLASS",94:"SELECTOR_GROUP",95:"UNIVERSAL_SELECTOR",96:"[",97:"]",98:"SELECTOR_ATTR_OP",100:"SELECTOR_TAG",102:"SELECTOR_END",103:"TAG_START",106:"TAG_END",110:"TAG_TYPE",111:"INDEX_START",112:"INDEX_END",113:"@",116:"TAG_ATTR",117:"=",122:"EXTEND",123:"LOCAL",124:"TAG",126:"COMPARE",128:"TAG_ID",130:"IDREF",135:":",136:"(",137:")",138:"HERECOMMENT",139:"COMMENT",143:"BEGIN",144:"DO",145:"BLOCK_PARAM_START",147:"BLOCK_PARAM_END",151:"PROP",152:"ATTR",154:"VAR",156:"GLOBAL",157:"EXPORT",158:"DEF",164:"DEF_BODY",165:"DEF_EMPTY",170:"SPLAT",171:"LOGIC",172:"BLOCK_ARG",175:"LET",177:"NEW",180:"?:",181:".:",183:"?.",184:"SUPER",185:"AWAIT",188:"ARGUMENTS",193:"CLASS",194:"MODULE",196:"FUNC_EXIST",197:"THIS",198:"SELF",200:"..",201:"...",204:"TRY",207:"FINALLY",208:"CATCH",209:"CATCH_VAR",210:"THROW",212:"WHILE",213:"WHEN",214:"UNTIL",216:"LOOP",219:"FOR",220:"POST_FOR",225:"OWN",227:"FORIN",228:"FOROF",229:"BY",230:"SWITCH",232:"ELSE",234:"LEADING_WHEN",236:"IF",237:"ELIF",238:"POST_IF",239:"?",240:"UNARY",241:"SQRT",242:"-",243:"+",244:"--",245:"++",246:"MATH",247:"SHIFT",248:"RELATION",249:"COMPOUND_ASSIGN"},
	productions_: [0,[3,0],[3,1],[3,2],[4,1],[4,1],[4,3],[4,2],[9,1],[5,2],[5,3],[5,4],[8,1],[8,1],[8,3],[8,3],[8,1],[8,1],[16,1],[16,1],[16,1],[16,1],[16,4],[16,1],[16,4],[16,1],[16,1],[25,4],[25,4],[25,2],[29,1],[27,1],[27,3],[31,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[50,1],[52,1],[52,1],[55,1],[57,1],[59,1],[61,1],[63,1],[63,1],[63,1],[63,1],[65,1],[65,2],[65,2],[65,2],[68,2],[68,3],[72,1],[72,1],[72,1],[72,1],[72,1],[72,1],[72,1],[72,1],[17,2],[17,2],[17,1],[82,1],[82,2],[82,2],[82,2],[82,2],[82,5],[82,5],[82,2],[82,2],[82,2],[82,2],[82,4],[82,6],[84,1],[101,2],[99,1],[99,1],[99,3],[48,4],[48,5],[48,5],[108,1],[108,1],[108,1],[108,0],[104,1],[104,3],[104,4],[104,3],[104,5],[104,5],[104,3],[104,2],[104,5],[105,0],[105,1],[105,3],[105,4],[114,1],[114,3],[118,1],[107,3],[107,3],[120,1],[120,3],[47,1],[47,2],[47,2],[121,2],[121,3],[121,4],[121,5],[127,0],[127,1],[125,1],[125,1],[129,1],[129,2],[38,3],[38,5],[133,1],[133,3],[133,5],[133,1],[134,1],[134,1],[134,1],[134,1],[134,1],[134,3],[15,1],[15,1],[36,1],[36,1],[36,1],[142,2],[141,2],[141,5],[141,6],[49,3],[49,5],[49,2],[148,1],[148,1],[149,1],[149,3],[153,4],[140,1],[140,2],[140,2],[155,8],[155,5],[155,6],[155,3],[160,1],[160,1],[161,1],[161,1],[161,3],[162,2],[162,2],[162,1],[159,1],[159,1],[159,1],[159,1],[115,0],[115,1],[146,0],[146,1],[146,3],[167,1],[167,1],[167,1],[167,2],[167,2],[167,2],[167,3],[169,1],[12,2],[173,3],[173,2],[173,2],[173,3],[173,2],[33,1],[33,1],[174,1],[174,1],[174,1],[176,1],[176,1],[176,1],[176,1],[176,1],[176,1],[176,1],[176,3],[176,3],[176,3],[176,3],[176,3],[176,3],[176,3],[176,3],[176,4],[179,1],[179,1],[178,1],[131,1],[131,1],[131,1],[34,2],[35,1],[35,1],[35,1],[35,1],[35,1],[35,1],[35,1],[35,1],[35,1],[35,1],[182,1],[182,1],[150,4],[191,0],[191,1],[191,3],[191,4],[191,6],[45,1],[45,2],[45,2],[45,2],[45,2],[45,3],[192,2],[192,3],[192,4],[192,5],[46,2],[46,3],[189,3],[189,2],[195,0],[195,1],[81,2],[81,4],[166,1],[109,1],[168,2],[168,4],[199,1],[199,1],[187,5],[190,3],[190,2],[190,2],[119,1],[119,3],[119,4],[119,4],[119,6],[132,2],[132,1],[202,1],[202,1],[202,1],[202,1],[203,1],[203,3],[41,2],[41,3],[41,3],[41,4],[206,2],[205,3],[18,2],[186,3],[186,5],[211,2],[211,4],[211,2],[211,4],[42,2],[42,2],[42,2],[42,1],[215,2],[215,2],[43,2],[43,2],[43,2],[218,1],[218,1],[221,2],[217,2],[217,2],[222,2],[222,3],[226,1],[226,1],[226,1],[224,1],[224,3],[223,2],[223,2],[223,4],[223,4],[223,4],[223,6],[223,6],[44,5],[44,7],[44,4],[44,6],[231,1],[231,2],[233,3],[233,4],[235,3],[235,5],[235,4],[235,3],[39,1],[39,3],[39,3],[40,5],[37,2],[37,2],[37,2],[37,2],[37,2],[37,2],[37,2],[37,2],[37,3],[37,3],[37,3],[37,3],[37,3],[37,3],[37,3],[37,3],[37,5]],
	performAction: function performAction(self, yytext, yy, yystate /* action[1] */, $$ /* vstack */) {
	/* self == yyval */
	
	var $0 = $$.length - 1;
	switch (yystate) {
	case 1:
	return self.$ = new yy.Root([]);
	break;
	case 2:
	return self.$ = new yy.Root($$[$0]);
	break;
	case 3:
	return self.$ = $$[$0-1];
	break;
	case 4:
	self.$ = new yy.Block([]);
	break;
	case 5:
	self.$ = new yy.Block([$$[$0]]);
	break;
	case 6:
	self.$ = $$[$0-2].break($$[$0-1]).add($$[$0]);
	break;
	case 7:
	self.$ = $$[$0-1].break($$[$0]);
	break;
	case 8:
	self.$ = new yy.Terminator($$[$0]);
	break;
	case 9:
	self.$ = new yy.Block([]).indented($$[$0-1],$$[$0]);
	break;
	case 10: case 119:
	self.$ = $$[$0-1].indented($$[$0-2],$$[$0]);
	break;
	case 11:
	self.$ = $$[$0-1].prebreak($$[$0-2]).indented($$[$0-3],$$[$0]);
	break;
	case 12: case 13: case 16: case 17: case 18: case 19: case 26: case 30: case 33: case 34: case 35: case 36: case 37: case 38: case 39: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 48: case 49: case 59: case 60: case 67: case 93: case 94: case 99: case 118: case 123: case 130: case 141: case 142: case 143: case 144: case 145: case 146: case 150: case 151: case 152: case 160: case 161: case 162: case 165: case 174: case 175: case 177: case 180: case 181: case 182: case 183: case 184: case 185: case 196: case 203: case 204: case 205: case 206: case 207: case 208: case 210: case 211: case 212: case 213: case 227: case 228: case 229: case 231: case 232: case 233: case 234: case 235: case 237: case 238: case 239: case 240: case 249: case 283: case 284: case 285: case 286: case 287: case 288: case 306: case 312: case 313: case 319: case 335: case 343:
	self.$ = $$[$0];
	break;
	case 14: case 15:
	self.$ = $$[$0-2].addExpression($$[$0]);
	break;
	case 20: case 68:
	self.$ = new yy.Literal($$[$0]);
	break;
	case 21:
	self.$ = new yy.BreakStatement($$[$0]);
	break;
	case 22:
	self.$ = new yy.BreakStatement($$[$0-3],$$[$0-1]);
	break;
	case 23:
	self.$ = new yy.ContinueStatement($$[$0]);
	break;
	case 24:
	self.$ = new yy.ContinueStatement($$[$0-3],$$[$0-1]);
	break;
	case 25:
	self.$ = new yy.DebuggerStatement($$[$0]);
	break;
	case 27:
	self.$ = new yy.ImportStatement($$[$0-2],$$[$0]);
	break;
	case 28:
	self.$ = new yy.ImportStatement(null,$$[$0-2],$$[$0]);
	break;
	case 29:
	self.$ = new yy.ImportStatement(null,$$[$0]);
	break;
	case 31: case 113: case 187: case 322:
	self.$ = [$$[$0]];
	break;
	case 32: case 114: case 188:
	self.$ = $$[$0-2].concat($$[$0]);
	break;
	case 50:
	self.$ = new yy.Identifier($$[$0]);
	break;
	case 51: case 52:
	self.$ = new yy.Ivar($$[$0]);
	break;
	case 53:
	self.$ = new yy.Gvar($$[$0]);
	break;
	case 54:
	self.$ = new yy.Const($$[$0]);
	break;
	case 55:
	self.$ = new yy.Argvar($$[$0]);
	break;
	case 56:
	self.$ = new yy.Symbol($$[$0]);
	break;
	case 57:
	self.$ = new yy.Num($$[$0]);
	break;
	case 58:
	self.$ = new yy.Str($$[$0]);
	break;
	case 61:
	self.$ = new yy.InterpolatedString([],{open: $$[$0]});
	break;
	case 62:
	self.$ = $$[$0-1].add($$[$0]);
	break;
	case 63:
	self.$ = $$[$0] ? ($$[$0-1].add($$[$0])) : ($$[$0-1]);
	break;
	case 64:
	self.$ = $$[$0-1].option('close',$$[$0]);
	break;
	case 65:
	self.$ = null;
	break;
	case 66: case 92: case 95: case 120: case 147: case 163: case 176: case 282:
	self.$ = $$[$0-1];
	break;
	case 69:
	self.$ = new yy.RegExp($$[$0]);
	break;
	case 70:
	self.$ = new yy.Bool($$[$0]);
	break;
	case 71:
	self.$ = yy.TRUE;
	break;
	case 72:
	self.$ = yy.FALSE;
	break;
	case 73:
	self.$ = yy.NIL;
	break;
	case 74:
	self.$ = yy.UNDEFINED;
	break;
	case 75: case 76:
	self.$ = new yy.Return($$[$0]);
	break;
	case 77:
	self.$ = new yy.Return();
	break;
	case 78:
	self.$ = new yy.Selector([],{type: $$[$0]});
	break;
	case 79:
	self.$ = $$[$0-1].add(new yy.SelectorType($$[$0]),'tag');
	break;
	case 80:
	self.$ = $$[$0-1].add(new yy.SelectorNamespace($$[$0]),'ns');
	break;
	case 81:
	self.$ = $$[$0-1].add(new yy.SelectorId($$[$0]),'id');
	break;
	case 82:
	self.$ = $$[$0-1].add(new yy.SelectorClass($$[$0]),'class');
	break;
	case 83:
	self.$ = $$[$0-4].add(new yy.SelectorClass($$[$0-1]),'class');
	break;
	case 84:
	self.$ = $$[$0-4].add(new yy.SelectorId($$[$0-1]),'id');
	break;
	case 85:
	self.$ = $$[$0-1].add(new yy.SelectorCombinator($$[$0]),'sep');
	break;
	case 86:
	self.$ = $$[$0-1].add(new yy.SelectorPseudoClass($$[$0]),'pseudoclass');
	break;
	case 87:
	self.$ = $$[$0-1].group();
	break;
	case 88:
	self.$ = $$[$0-1].add(new yy.SelectorUniversal($$[$0]),'universal');
	break;
	case 89:
	self.$ = $$[$0-3].add(new yy.SelectorAttribute($$[$0-1]),'attr');
	break;
	case 90:
	self.$ = $$[$0-5].add(new yy.SelectorAttribute($$[$0-3],$$[$0-2],$$[$0-1]),'attr');
	break;
	case 91: case 100: case 101: case 132: case 133:
	self.$ = new yy.TagTypeIdentifier($$[$0]);
	break;
	case 96:
	self.$ = $$[$0-2].set({attributes: $$[$0-1],open: $$[$0-3],close: $$[$0]});
	break;
	case 97:
	self.$ = $$[$0-3].set({attributes: $$[$0-2],body: $$[$0],open: $$[$0-4],close: $$[$0-1]});
	break;
	case 98:
	self.$ = new yy.TagWrapper($$[$0-2],$$[$0-4],$$[$0]);
	break;
	case 102:
	self.$ = new yy.TagTypeIdentifier('div');
	break;
	case 103:
	self.$ = new yy.Tag({type: $$[$0]});
	break;
	case 104:
	self.$ = $$[$0-2].addSymbol($$[$0]);
	break;
	case 105:
	self.$ = $$[$0-3].addIndex($$[$0-1]);
	break;
	case 106:
	self.$ = $$[$0-2].addClass($$[$0]);
	break;
	case 107:
	self.$ = $$[$0-4].addClass($$[$0-1]);
	break;
	case 108:
	self.$ = $$[$0-4].set({key: $$[$0-1]});
	break;
	case 109:
	self.$ = $$[$0-2].set({id: $$[$0]});
	break;
	case 110:
	self.$ = $$[$0-1].set({ivar: $$[$0]});
	break;
	case 111:
	self.$ = $$[$0-4].set({id: $$[$0-1]});
	break;
	case 112: case 179: case 186:
	self.$ = [];
	break;
	case 115:
	self.$ = $$[$0-3].concat($$[$0]);
	break;
	case 116:
	self.$ = new yy.TagAttr($$[$0],$$[$0]);
	break;
	case 117:
	self.$ = new yy.TagAttr($$[$0-2],$$[$0],$$[$0-1]);
	break;
	case 121:
	self.$ = new yy.TagDesc($$[$0]);
	break;
	case 122:
	self.$ = $$[$0-2].classes($$[$0]);
	break;
	case 124:
	self.$ = $$[$0].set({extension: true});
	break;
	case 125:
	self.$ = $$[$0].set({local: true});
	break;
	case 126:
	self.$ = new yy.TagDeclaration($$[$0]).set({keyword: $$[$0-1]});
	break;
	case 127:
	self.$ = new yy.TagDeclaration($$[$0-1],null,$$[$0]).set({keyword: $$[$0-2]});
	break;
	case 128:
	self.$ = new yy.TagDeclaration($$[$0-2],$$[$0]).set({keyword: $$[$0-3]});
	break;
	case 129:
	self.$ = new yy.TagDeclaration($$[$0-3],$$[$0-1],$$[$0]).set({keyword: $$[$0-4]});
	break;
	case 131:
	self.$ = ['yy.extend'];
	break;
	case 134: case 135:
	self.$ = new yy.TagId($$[$0]);
	break;
	case 136:
	self.$ = new yy.Assign($$[$0-1],$$[$0-2],$$[$0]);
	break;
	case 137:
	self.$ = new yy.Assign($$[$0-3],$$[$0-4],$$[$0-1].indented($$[$0-2],$$[$0]));
	break;
	case 138:
	self.$ = new yy.ObjAttr($$[$0]);
	break;
	case 139:
	self.$ = new yy.ObjAttr($$[$0-2],$$[$0],'object');
	break;
	case 140:
	self.$ = new yy.ObjAttr($$[$0-4],$$[$0-1].indented($$[$0-2],$$[$0]),'object');
	break;
	case 148:
	self.$ = new yy.Comment($$[$0],true);
	break;
	case 149:
	self.$ = new yy.Comment($$[$0],false);
	break;
	case 153:
	self.$ = new yy.Begin($$[$0]);
	break;
	case 154:
	self.$ = new yy.Lambda([],$$[$0],null,null,{bound: true});
	break;
	case 155:
	self.$ = new yy.Lambda($$[$0-2],$$[$0],null,null,{bound: true});
	break;
	case 156:
	self.$ = new yy.Lambda($$[$0-3],$$[$0-1],null,null,{bound: true});
	break;
	case 157:
	self.$ = new yy.PropertyDeclaration($$[$0-1],$$[$0],$$[$0-2]);
	break;
	case 158:
	self.$ = new yy.PropertyDeclaration($$[$0-3],$$[$0-1],$$[$0-4]);
	break;
	case 159:
	self.$ = new yy.PropertyDeclaration($$[$0],null,$$[$0-1]);
	break;
	case 164:
	self.$ = $$[$0-3];
	break;
	case 166: case 252:
	self.$ = $$[$0].set({global: $$[$0-1]});
	break;
	case 167: case 202: case 253:
	self.$ = $$[$0].set({export: $$[$0-1]});
	break;
	case 168:
	self.$ = new yy.MethodDeclaration($$[$0-2],$$[$0],$$[$0-4],$$[$0-6],$$[$0-5]).set({def: $$[$0-7]});
	break;
	case 169:
	self.$ = new yy.MethodDeclaration([],$$[$0],$$[$0-1],$$[$0-3],$$[$0-2]).set({def: $$[$0-4]});
	break;
	case 170:
	self.$ = new yy.MethodDeclaration($$[$0-2],$$[$0],$$[$0-4],null).set({def: $$[$0-5]});
	break;
	case 171:
	self.$ = new yy.MethodDeclaration([],$$[$0],$$[$0-1],null).set({def: $$[$0-2]});
	break;
	case 172:
	self.$ = {static: true};
	break;
	case 173:
	self.$ = {};
	break;
	case 178:
	self.$ = $$[$0].body();
	break;
	case 189:
	self.$ = new yy.NamedParams($$[$0]);
	break;
	case 190:
	self.$ = new yy.ArrayParams($$[$0]);
	break;
	case 191:
	self.$ = new yy.RequiredParam($$[$0]);
	break;
	case 192:
	self.$ = new yy.SplatParam($$[$0],null,$$[$0-1]);
	break;
	case 193: case 194:
	self.$ = new yy.BlockParam($$[$0],null,$$[$0-1]);
	break;
	case 195:
	self.$ = new yy.OptionalParam($$[$0-2],$$[$0],$$[$0-1]);
	break;
	case 197:
	self.$ = yy.SPLAT($$[$0]);
	break;
	case 198: case 201:
	self.$ = yy.SPLAT(new yy.VarReference($$[$0],$$[$0-2]),$$[$0-1]);
	break;
	case 199: case 200:
	self.$ = new yy.VarReference($$[$0],$$[$0-1]);
	break;
	case 209:
	self.$ = new yy.IvarAccess('.',null,$$[$0]);
	break;
	case 214:
	self.$ = new yy.VarOrAccess($$[$0]);
	break;
	case 215:
	self.$ = new yy.New($$[$0-2]);
	break;
	case 216:
	self.$ = new yy.SuperAccess('.',$$[$0-2],$$[$0]);
	break;
	case 217:
	self.$ = new yy.PropertyAccess($$[$0-1],$$[$0-2],$$[$0]);
	break;
	case 218: case 219: case 220: case 222:
	self.$ = new yy.Access($$[$0-1],$$[$0-2],$$[$0]);
	break;
	case 221:
	self.$ = new yy.Access('.',$$[$0-2],new yy.Identifier($$[$0].value()));
	break;
	case 223:
	self.$ = new yy.IndexAccess('.',$$[$0-3],$$[$0-1]);
	break;
	case 226:
	self.$ = yy.SUPER;
	break;
	case 230:
	self.$ = new yy.Await($$[$0]).set({keyword: $$[$0-1]});
	break;
	case 236:
	self.$ = yy.ARGUMENTS;
	break;
	case 241:
	self.$ = new yy.Index($$[$0]);
	break;
	case 242:
	self.$ = new yy.Slice($$[$0]);
	break;
	case 243:
	self.$ = new yy.Obj($$[$0-2],$$[$0-3].generated);
	break;
	case 244:
	self.$ = new yy.AssignList([]);
	break;
	case 245:
	self.$ = new yy.AssignList([$$[$0]]);
	break;
	case 246: case 278:
	self.$ = $$[$0-2].add($$[$0]);
	break;
	case 247: case 279:
	self.$ = $$[$0-3].add($$[$0-1]).add($$[$0]);
	break;
	case 248:
	self.$ = $$[$0-5].concat($$[$0-2].indented($$[$0-3],$$[$0]));
	break;
	case 250:
	self.$ = $$[$0].set({extension: $$[$0-1]});
	break;
	case 251:
	self.$ = $$[$0].set({local: $$[$0-1]});
	break;
	case 254:
	self.$ = $$[$0].set({export: $$[$0-2],local: $$[$0-1]});
	break;
	case 255:
	self.$ = new yy.ClassDeclaration($$[$0],null,[]).set({keyword: $$[$0-1]});
	break;
	case 256:
	self.$ = new yy.ClassDeclaration($$[$0-1],null,$$[$0]).set({keyword: $$[$0-2]});
	break;
	case 257:
	self.$ = new yy.ClassDeclaration($$[$0-2],$$[$0],[]).set({keyword: $$[$0-3]});
	break;
	case 258:
	self.$ = new yy.ClassDeclaration($$[$0-3],$$[$0-1],$$[$0]).set({keyword: $$[$0-4]});
	break;
	case 259:
	self.$ = new yy.Module($$[$0]);
	break;
	case 260:
	self.$ = new yy.Module($$[$0-1],null,$$[$0]);
	break;
	case 261:
	self.$ = new yy.Call($$[$0-2],$$[$0],$$[$0-1]);
	break;
	case 262:
	self.$ = $$[$0-1].addBlock($$[$0]);
	break;
	case 263:
	self.$ = false;
	break;
	case 264:
	self.$ = true;
	break;
	case 265:
	self.$ = new yy.ArgList([]);
	break;
	case 266:
	self.$ = $$[$0-2];
	break;
	case 267:
	self.$ = new yy.This($$[$0]);
	break;
	case 268:
	self.$ = new yy.Self($$[$0]);
	break;
	case 269:
	self.$ = new yy.Arr(new yy.ArgList([]));
	break;
	case 270:
	self.$ = new yy.Arr($$[$0-2]);
	break;
	case 271:
	self.$ = '..';
	break;
	case 272:
	self.$ = '...';
	break;
	case 273:
	self.$ = yy.OP($$[$0-2],$$[$0-3],$$[$0-1]);
	break;
	case 274:
	self.$ = new yy.Range($$[$0-2],$$[$0],$$[$0-1]);
	break;
	case 275:
	self.$ = new yy.Range($$[$0-1],null,$$[$0]);
	break;
	case 276:
	self.$ = new yy.Range(null,$$[$0],$$[$0-1]);
	break;
	case 277:
	self.$ = new yy.ArgList([$$[$0]]);
	break;
	case 280:
	self.$ = $$[$0-2].indented($$[$0-3],$$[$0]);
	break;
	case 281:
	self.$ = $$[$0-5].concat($$[$0-2]);
	break;
	case 289:
	self.$ = [].concat($$[$0-2],$$[$0]);
	break;
	case 290:
	self.$ = new yy.Try($$[$0]);
	break;
	case 291:
	self.$ = new yy.Try($$[$0-1],$$[$0]);
	break;
	case 292:
	self.$ = new yy.Try($$[$0-1],null,$$[$0]);
	break;
	case 293:
	self.$ = new yy.Try($$[$0-2],$$[$0-1],$$[$0]);
	break;
	case 294:
	self.$ = new yy.Finally($$[$0]);
	break;
	case 295:
	self.$ = new yy.Catch($$[$0],$$[$0-1]);
	break;
	case 296:
	self.$ = new yy.Throw($$[$0]);
	break;
	case 297:
	self.$ = new yy.Parens($$[$0-1],$$[$0-2],$$[$0]);
	break;
	case 298:
	self.$ = new yy.Parens($$[$0-2],$$[$0-4],$$[$0]);
	break;
	case 299:
	self.$ = new yy.While($$[$0]);
	break;
	case 300:
	self.$ = new yy.While($$[$0-2],{guard: $$[$0]});
	break;
	case 301:
	self.$ = new yy.While($$[$0],{invert: true});
	break;
	case 302:
	self.$ = new yy.While($$[$0-2],{invert: true,guard: $$[$0]});
	break;
	case 303: case 311: case 314:
	self.$ = $$[$0-1].addBody($$[$0]);
	break;
	case 304: case 305:
	self.$ = $$[$0].addBody(yy.Block.wrap([$$[$0-1]]));
	break;
	case 307:
	self.$ = new yy.While(new yy.Literal('true')).addBody($$[$0]);
	break;
	case 308:
	self.$ = new yy.While(new yy.Literal('true')).addBody(yy.Block.wrap([$$[$0]]));
	break;
	case 309: case 310:
	self.$ = $$[$0].addBody([$$[$0-1]]);
	break;
	case 315:
	self.$ = {source: new yy.ValueNode($$[$0])};
	break;
	case 316:
	self.$ = $$[$0].configure({own: $$[$0-1].own,name: $$[$0-1][0],index: $$[$0-1][1],keyword: $$[$0-1].keyword});
	break;
	case 317:
	self.$ = ($$[$0].keyword = $$[$0-1]) && $$[$0];
	break;
	case 318:
	self.$ = ($$[$0].own = true) && ($$[$0].keyword = $$[$0-2]) && $$[$0];
	break;
	case 320: case 321:
	self.$ = new yy.ValueNode($$[$0]);
	break;
	case 323:
	self.$ = [$$[$0-2],$$[$0]];
	break;
	case 324:
	self.$ = new yy.ForIn({source: $$[$0]});
	break;
	case 325:
	self.$ = new yy.ForOf({source: $$[$0],object: true});
	break;
	case 326:
	self.$ = new yy.ForIn({source: $$[$0-2],guard: $$[$0]});
	break;
	case 327:
	self.$ = new yy.ForOf({source: $$[$0-2],guard: $$[$0],object: true});
	break;
	case 328:
	self.$ = new yy.ForIn({source: $$[$0-2],step: $$[$0]});
	break;
	case 329:
	self.$ = new yy.ForIn({source: $$[$0-4],guard: $$[$0-2],step: $$[$0]});
	break;
	case 330:
	self.$ = new yy.ForIn({source: $$[$0-4],step: $$[$0-2],guard: $$[$0]});
	break;
	case 331:
	self.$ = new yy.Switch($$[$0-3],$$[$0-1]);
	break;
	case 332:
	self.$ = new yy.Switch($$[$0-5],$$[$0-3],$$[$0-1]);
	break;
	case 333:
	self.$ = new yy.Switch(null,$$[$0-1]);
	break;
	case 334:
	self.$ = new yy.Switch(null,$$[$0-3],$$[$0-1]);
	break;
	case 336:
	self.$ = $$[$0-1].concat($$[$0]);
	break;
	case 337:
	self.$ = [new yy.SwitchCase($$[$0-1],$$[$0])];
	break;
	case 338:
	self.$ = [new yy.SwitchCase($$[$0-2],$$[$0-1])];
	break;
	case 339:
	self.$ = new yy.If($$[$0-1],$$[$0],{type: $$[$0-2]});
	break;
	case 340:
	self.$ = $$[$0-4].addElse(new yy.If($$[$0-1],$$[$0],{type: $$[$0-2]}));
	break;
	case 341:
	self.$ = $$[$0-3].addElse(new yy.If($$[$0-1],$$[$0],{type: $$[$0-2]}));
	break;
	case 342:
	self.$ = $$[$0-2].addElse($$[$0]);
	break;
	case 344:
	self.$ = new yy.If($$[$0],new yy.Block([$$[$0-2]]),{type: $$[$0-1],statement: true});
	break;
	case 345:
	self.$ = new yy.If($$[$0],new yy.Block([$$[$0-2]]),{type: $$[$0-1]});
	break;
	case 346:
	self.$ = yy.If.ternary($$[$0-4],$$[$0-2],$$[$0]);
	break;
	case 347: case 348:
	self.$ = yy.OP($$[$0-1],$$[$0]);
	break;
	case 349:
	self.$ = new yy.Op('-',$$[$0]);
	break;
	case 350:
	self.$ = new yy.Op('+',$$[$0]);
	break;
	case 351:
	self.$ = new yy.UnaryOp('--',null,$$[$0]);
	break;
	case 352:
	self.$ = new yy.UnaryOp('++',null,$$[$0]);
	break;
	case 353:
	self.$ = new yy.UnaryOp('--',$$[$0-1],null,true);
	break;
	case 354:
	self.$ = new yy.UnaryOp('++',$$[$0-1],null,true);
	break;
	case 355: case 356:
	self.$ = new yy.Op($$[$0-1],$$[$0-2],$$[$0]);
	break;
	case 357: case 358: case 359: case 360:
	self.$ = yy.OP($$[$0-1],$$[$0-2],$$[$0]);
	break;
	case 361:
	self.$ = (function () {
					if ($$[$0-1].charAt(0) == '!') {
						return yy.OP($$[$0-1].slice(1),$$[$0-2],$$[$0]).invert();
					} else {
						return yy.OP($$[$0-1],$$[$0-2],$$[$0]);
					};
				}());
	break;
	case 362:
	self.$ = yy.OP_COMPOUND($$[$0-1]._value,$$[$0-1],$$[$0-2],$$[$0]);
	break;
	case 363:
	self.$ = yy.OP_COMPOUND($$[$0-3]._value,$$[$0-4],$$[$0-1].indented($$[$0-2],$$[$0]));
	break;
	}
	},
	table: [{1:[2,1],3:1,4:2,5:3,7:$V0,8:5,10:$V1,12:7,13:8,15:9,16:10,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{1:[3]},{1:[2,2],6:$V51,9:133},{6:[1,135]},o($V61,[2,4]),o($V61,[2,5],{14:$V71}),{4:138,6:[1,139],7:$V0,8:5,11:[1,137],12:7,13:8,15:9,16:10,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($V81,[2,12]),o($V81,[2,13],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($V81,[2,16]),o($V81,[2,17],{218:108,222:109,211:152,217:153,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vi1}),{13:154,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vj1,[2,34]),o($Vj1,[2,35],{195:156,141:157,179:159,21:$Vk1,88:$Vl1,89:$Vm1,111:$Vn1,144:$VC,180:$Vo1,181:$Vp1,183:$Vq1,196:$Vr1}),o($Vj1,[2,36]),o($Vj1,[2,37]),o($Vj1,[2,38]),o($Vj1,[2,39]),o($Vj1,[2,40]),o($Vj1,[2,41]),o($Vj1,[2,42]),o($Vj1,[2,43]),o($Vj1,[2,44]),o($Vj1,[2,45]),o($Vj1,[2,46]),o($Vj1,[2,47]),o($Vj1,[2,48]),o($Vj1,[2,49]),o($Vs1,[2,148]),o($Vs1,[2,149]),o($Vt1,[2,18]),o($Vt1,[2,19]),o($Vt1,[2,20]),o($Vt1,[2,21],{21:[1,166]}),o($Vt1,[2,23],{21:[1,167]}),o($Vt1,[2,25]),o($Vt1,[2,26]),{13:168,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vu1,$Vv1,{117:[1,169]}),o($Vu1,[2,232]),o($Vu1,[2,233]),o($Vu1,[2,234]),o($Vu1,[2,235]),o($Vu1,[2,236]),o($Vu1,[2,237]),o($Vu1,[2,238]),o($Vu1,[2,239]),o($Vu1,[2,240]),o($Vj1,[2,150]),o($Vj1,[2,151]),o($Vj1,[2,152]),{13:170,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:171,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:172,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:173,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{32:$V7,35:175,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,82:92,83:$Vp,89:$Vw1,91:$Vr,96:$Vs,101:46,109:101,129:45,130:$Vx,131:177,136:$Vy,150:77,154:$VF,157:$Vx1,166:44,168:76,173:102,175:$VK,176:174,178:39,184:$VL,186:41,187:42,188:$VN,189:47,197:$VQ,198:$VR},{32:$V7,35:175,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,82:92,83:$Vp,89:$Vw1,91:$Vr,96:$Vs,101:46,109:101,129:45,130:$Vx,131:177,136:$Vy,150:77,154:$VF,157:$Vx1,166:44,168:76,173:102,175:$VK,176:179,178:39,184:$VL,186:41,187:42,188:$VN,189:47,197:$VQ,198:$VR},o($Vy1,$Vz1,{244:[1,180],245:[1,181],249:[1,182]}),o($Vj1,[2,343],{232:[1,183],237:[1,184]}),{5:185,10:$V1},{5:186,10:$V1},o($Vj1,[2,306]),{5:187,10:$V1},{10:[1,189],13:188,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vj1,[2,249]),{121:191,124:$Vw,192:190,193:$VO},{121:193,124:$Vw,192:192,193:$VO},{155:195,158:$VI,192:194,193:$VO},{123:[1,197],154:$VF,155:198,157:$Vx1,158:$VI,173:199,175:$VK,192:196,193:$VO},{32:$V7,35:175,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,82:92,83:$Vp,89:$Vw1,91:$Vr,96:$Vs,101:46,109:101,129:45,130:$Vx,131:177,136:$Vy,150:77,154:$VF,157:$Vx1,166:44,168:76,173:102,175:$VK,176:200,178:39,184:$VL,186:41,187:42,188:$VN,189:47,197:$VQ,198:$VR},o($Vj1,[2,123]),o($VA1,[2,102],{104:201,108:203,109:204,51:[1,205],89:[1,202],110:[1,206],198:$VR}),{50:208,51:$V8,89:[1,209],149:207},o($Vt1,[2,77],{34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,17:30,18:31,25:36,131:38,178:39,72:40,186:41,187:42,166:44,129:45,101:46,189:47,140:48,141:49,142:50,176:57,235:58,211:60,215:61,217:62,192:64,121:70,148:72,168:76,150:77,63:79,82:92,155:93,57:97,52:98,55:99,59:100,109:101,173:102,50:103,218:108,222:109,61:116,65:117,16:155,13:210,81:211,19:$V2,20:$V3,21:$VB1,23:$V4,24:$V5,26:$V6,32:$V7,51:$V8,53:$V9,54:$Va,56:$Vb,58:$Vc,60:$Vd,62:$Ve,64:$Vf,66:$Vg,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,83:$Vp,89:$Vq,91:$Vr,96:$Vs,103:$Vt,122:$Vu,123:$Vv,124:$Vw,130:$Vx,136:$Vy,143:$VB,144:$VC,151:$VD,152:$VE,154:$VF,156:$VG,157:$VH,158:$VI,175:$VK,184:$VL,185:$VM,188:$VN,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,216:$VW,230:$VZ,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41}),{13:213,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{27:214,29:215,31:216,32:$VC1,33:218,50:220,51:$V8,57:219,58:$Vc},o($Vy1,[2,228]),o($Vy1,[2,229]),o($VD1,[2,226]),o($Vu1,[2,67]),o($Vu1,[2,68]),o($Vu1,[2,69]),o($Vu1,[2,70]),o($Vu1,[2,71]),o($Vu1,[2,72]),o($Vu1,[2,73]),o($Vu1,[2,74]),{4:221,7:$V0,8:5,10:[1,222],12:7,13:8,15:9,16:10,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{10:$VE1,12:228,13:223,15:230,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,97:$VF1,101:46,103:$Vt,109:101,119:225,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,171:$VG1,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,202:226,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o([1,6,10,11,14,21,22,71,88,89,90,91,97,106,111,112,126,135,137,144,147,171,180,181,183,196,200,201,212,213,214,219,220,229,238,239,242,243,246,247,248],[2,267]),o($Vu1,[2,134]),{50:231,51:$V8},{84:233,85:[1,234],86:[1,235],87:[1,236],88:[1,237],91:[1,238],92:[1,239],93:[1,240],94:[1,241],95:[1,242],96:[1,243],100:[1,244],102:[1,232]},o($Vj1,[2,165]),{5:245,10:$V1,145:[1,246]},o($VH1,$VI1,{61:116,65:117,191:248,133:249,134:250,15:251,50:252,57:253,63:254,52:255,55:256,32:$V7,51:$V8,53:$V9,54:$Va,56:$Vb,58:$Vc,62:$Ve,64:$Vf,66:$Vg,136:$VJ1,138:$Vz,139:$VA,145:$VK1}),{5:258,10:$V1},o($VD1,[2,208]),o($VD1,[2,209]),o($VD1,[2,210]),o($VD1,[2,211]),o($VD1,[2,212]),o($VD1,[2,213]),o($VD1,[2,214]),{13:259,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:260,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:261,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{5:262,10:$V1,13:263,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{50:268,51:$V8,89:$Vw1,96:$Vs,150:270,168:269,187:264,224:265,225:[1,266],226:267},{223:271,227:[1,272],228:[1,273]},{32:$V7,35:175,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,82:92,83:$Vp,89:$Vw1,91:$Vr,96:$Vs,101:46,109:101,129:45,130:$Vx,131:177,136:$Vy,150:77,154:$VF,157:$Vx1,166:44,168:76,173:102,175:$VK,176:274,178:39,184:$VL,186:41,187:42,188:$VN,189:47,197:$VQ,198:$VR},{110:$VL1,125:275,128:$VM1},o($VN1,[2,160]),o($VN1,[2,161]),o($Vu1,[2,57]),o($Vu1,[2,58]),o($Vu1,[2,59]),o($Vu1,[2,60],{68:279,67:[1,278],69:[1,280],70:[1,281]}),o($VO1,[2,78]),{50:287,51:$V8,55:286,56:$Vb,57:288,58:$Vc,89:$VP1,109:285,159:282,161:283,166:284,197:$VQ,198:$VR},o([1,6,10,11,14,21,22,28,71,88,89,90,91,97,106,111,112,117,126,135,137,144,147,164,165,171,180,181,183,196,200,201,212,213,214,219,220,229,238,239,242,243,244,245,246,247,248,249],[2,54]),o($VQ1,[2,51]),o($VQ1,[2,52]),o([1,6,10,11,14,21,22,71,88,89,90,91,97,106,111,112,117,126,135,137,144,147,171,180,181,183,196,200,201,212,213,214,219,220,229,238,239,242,243,244,245,246,247,248,249],[2,53]),o($VD1,[2,55]),o($VQ1,[2,268]),{50:293,51:$V8,57:292,58:$Vc,96:$VR1,168:294,170:[1,290],174:291},{50:293,51:$V8,57:292,58:$Vc,96:$VR1,168:294,170:[1,297],174:296},o([1,6,10,11,14,21,22,28,71,88,89,90,91,97,98,106,111,112,117,126,135,137,144,147,164,165,171,180,181,183,196,200,201,212,213,214,219,220,227,228,229,238,239,242,243,244,245,246,247,248,249],[2,50]),o($VS1,[2,312]),o($VS1,[2,313]),o($VD1,[2,56]),o($VT1,[2,61]),o($V61,[2,7],{12:7,13:8,15:9,16:10,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,17:30,18:31,25:36,131:38,178:39,72:40,186:41,187:42,166:44,129:45,101:46,189:47,140:48,141:49,142:50,176:57,235:58,211:60,215:61,217:62,192:64,121:70,148:72,168:76,150:77,63:79,82:92,155:93,57:97,52:98,55:99,59:100,109:101,173:102,50:103,218:108,222:109,61:116,65:117,8:298,19:$V2,20:$V3,23:$V4,24:$V5,26:$V6,32:$V7,51:$V8,53:$V9,54:$Va,56:$Vb,58:$Vc,60:$Vd,62:$Ve,64:$Vf,66:$Vg,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,83:$Vp,89:$Vq,91:$Vr,96:$Vs,103:$Vt,122:$Vu,123:$Vv,124:$Vw,130:$Vx,136:$Vy,138:$Vz,139:$VA,143:$VB,144:$VC,151:$VD,152:$VE,154:$VF,156:$VG,157:$VH,158:$VI,170:$VJ,175:$VK,184:$VL,185:$VM,188:$VN,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,212:$VU,214:$VV,216:$VW,219:$VX,220:$VY,230:$VZ,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41}),o([1,6,11,19,20,23,24,26,32,51,53,54,56,58,60,62,64,66,73,74,75,76,77,78,79,80,83,89,91,96,103,122,123,124,130,136,137,138,139,143,144,151,152,154,156,157,158,170,171,175,184,185,188,193,194,197,198,204,210,212,214,216,219,220,230,236,240,241,242,243,244,245],[2,8]),{1:[2,3]},{12:300,13:299,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($VU1,[2,9]),{6:$V51,9:133,11:[1,301]},{4:302,7:$V0,8:5,12:7,13:8,15:9,16:10,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:303,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:304,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:305,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:306,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:307,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:308,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:309,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:310,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:311,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vj1,[2,305]),o($Vj1,[2,310]),{13:312,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vj1,[2,304]),o($Vj1,[2,309]),o([1,6,10,11,14,22,97,137],[2,197],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),{211:152,212:$VU,214:$VV,217:153,218:108,219:$VX,220:$VY,222:109,238:$Vi1},{21:$VB1,81:313},o($Vu1,[2,262]),o($VV1,[2,224],{178:315,61:316,62:$Ve,177:[1,314],184:$VL}),{50:317,51:$V8,52:318,53:$V9,54:$Va,57:319,58:$Vc},{50:320,51:$V8},{50:321,51:$V8},{13:323,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,182:322,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,190:324,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,199:325,200:$VW1,201:$VX1,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{21:[2,264]},{145:$VK1},o($VV1,[2,225]),{13:328,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:329,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($VY1,[2,230],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),{10:[1,331],13:330,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vj1,[2,347],{218:108,222:109,211:149,217:150}),o($Vj1,[2,348],{218:108,222:109,211:149,217:150}),o($Vj1,[2,349],{218:108,222:109,211:149,217:150}),o($Vj1,[2,350],{218:108,222:109,211:149,217:150}),o($Vj1,[2,351],{21:$Vz1,88:$Vz1,89:$Vz1,111:$Vz1,144:$Vz1,180:$Vz1,181:$Vz1,183:$Vz1,196:$Vz1}),{21:$Vk1,88:$Vl1,89:$Vm1,111:$Vn1,141:157,144:$VC,179:159,180:$Vo1,181:$Vp1,183:$Vq1,195:156,196:$Vr1},{154:$VF,157:$Vx1,173:199,175:$VK},o([21,88,89,111,144,180,181,183,196],$Vv1),o($VH1,$VI1,{61:116,65:117,191:248,133:249,134:250,15:251,50:252,57:253,63:254,52:255,55:256,32:$V7,51:$V8,53:$V9,54:$Va,56:$Vb,58:$Vc,62:$Ve,64:$Vf,66:$Vg,136:$VJ1,138:$Vz,139:$VA}),o($Vj1,[2,352],{21:$Vz1,88:$Vz1,89:$Vz1,111:$Vz1,144:$Vz1,180:$Vz1,181:$Vz1,183:$Vz1,196:$Vz1}),o($Vj1,[2,353]),o($Vj1,[2,354]),{10:[1,333],13:332,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{5:335,10:$V1,236:[1,334]},{13:336,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vj1,[2,290],{205:337,206:338,207:$VZ1,208:[1,339]}),o($Vj1,[2,303]),o($Vj1,[2,311]),{10:[1,341],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},{231:342,233:343,234:$V_1},o($Vj1,[2,250]),o($Vj1,[2,124]),o($Vj1,[2,251]),o($Vj1,[2,125]),o($Vj1,[2,252]),o($Vj1,[2,166]),o($Vj1,[2,253]),{192:345,193:$VO},o($Vj1,[2,167]),o($VD1,[2,202]),o($V$1,[2,259],{5:346,10:$V1,21:$Vz1,88:$Vz1,89:$Vz1,111:$Vz1,144:$Vz1,180:$Vz1,181:$Vz1,183:$Vz1,196:$Vz1}),o($V02,[2,112],{105:347,52:352,114:353,53:$V9,54:$Va,88:[1,348],91:[1,351],111:[1,349],113:[1,350],116:$V12}),{13:355,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($VA1,[2,103]),o($VA1,[2,99]),o($VA1,[2,100]),o($VA1,[2,101]),o($Vj1,[2,159],{150:356,21:[1,357],89:$Vw1}),o($V22,[2,162]),{13:358,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vt1,[2,75],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($Vt1,[2,76]),{10:$VE1,12:228,13:361,15:230,16:155,17:30,18:31,19:$V2,20:$V3,22:[1,359],23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,119:360,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,171:$VG1,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,202:226,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vt1,[2,296],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),{14:[1,363],28:[1,362]},o($Vt1,[2,29],{30:[1,364]}),o($V32,[2,31]),o([1,6,11,14,30,137,212,214,219,220,238],[2,30]),o($V42,[2,33]),o($V42,[2,203]),o($V42,[2,204]),{6:$V51,9:133,137:[1,365]},{4:366,7:$V0,8:5,12:7,13:8,15:9,16:10,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o([6,10,14,97],$V52,{218:108,222:109,211:149,217:150,199:367,126:$V91,171:$Va1,200:$VW1,201:$VX1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($V62,[2,269]),o([6,10,97],$V72,{115:368,14:$V82}),o($V92,[2,277]),{10:$VE1,12:228,13:361,15:230,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,119:370,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,171:$VG1,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,202:226,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($V92,[2,285]),o($V92,[2,286]),o($V92,[2,287]),o($Vu1,[2,135]),o($Vu1,[2,92]),o($VO1,[2,79]),o($VO1,[2,80]),o($VO1,[2,81]),o($VO1,[2,82]),{89:[1,371]},{89:[1,372]},o($VO1,[2,85]),o($VO1,[2,86]),o($VO1,[2,87]),o($VO1,[2,88]),{50:373,51:$V8},o($VO1,[2,91]),o($Vu1,[2,154]),o($Va2,$Vb2,{146:374,167:375,150:376,168:377,169:378,50:382,51:$V8,89:$Vw1,96:$VR1,170:$Vc2,171:$Vd2,172:$Ve2}),o($Va2,$Vb2,{167:375,150:376,168:377,169:378,50:382,146:383,51:$V8,89:$Vw1,96:$VR1,170:$Vc2,171:$Vd2,172:$Ve2}),o([6,10,90],$V72,{115:384,14:$Vf2}),o($Vg2,[2,245]),o($Vg2,[2,138],{135:[1,386]}),o($Vg2,[2,141]),o($Vh2,[2,142]),o($Vh2,[2,143]),o($Vh2,[2,144]),o($Vh2,[2,145]),o($Vh2,[2,146]),{13:387,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vj1,[2,153]),{5:388,10:$V1,126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($Vi2,[2,299],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,213:[1,389],214:$VV,219:$VX,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($Vi2,[2,301],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,213:[1,390],214:$VV,219:$VX,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($Vj1,[2,307]),o($Vj2,[2,308],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($Vj1,[2,315]),o($Vk2,[2,317]),{50:268,51:$V8,89:$Vw1,96:$VR1,150:270,168:269,224:391,226:267},o($Vk2,[2,322],{14:[1,392]}),o($Vl2,[2,319]),o($Vl2,[2,320]),o($Vl2,[2,321]),o($Vj1,[2,316]),{13:393,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:394,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vm2,[2,255],{5:395,10:$V1,21:$Vz1,88:$Vz1,89:$Vz1,111:$Vz1,144:$Vz1,180:$Vz1,181:$Vz1,183:$Vz1,196:$Vz1,126:[1,396]}),o($Vm2,[2,126],{5:397,10:$V1,126:[1,398]}),o($Vj1,[2,132]),o($Vj1,[2,133]),o($VT1,[2,62]),o($VT1,[2,63]),o($VT1,[2,64]),{13:400,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,71:[1,399],72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{88:[1,402],91:[1,403],160:401},o($Vn2,[2,180],{162:405,21:[1,404],164:$Vo2,165:$Vp2}),o($Vn2,[2,181]),o($Vn2,[2,182]),o($Vn2,[2,183]),o($Vq2,[2,174]),o($Vq2,[2,175]),{13:408,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{50:293,51:$V8,57:292,58:$Vc,96:$VR1,168:294,174:409},o($VD1,[2,199]),o($VD1,[2,205]),o($VD1,[2,206]),o($VD1,[2,207]),{10:$VE1,12:228,13:361,15:230,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,97:$VF1,101:46,103:$Vt,109:101,119:225,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,171:$VG1,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,202:226,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($VD1,[2,200]),{50:293,51:$V8,57:292,58:$Vc,96:$VR1,168:294,174:410},o($V61,[2,6],{14:$V71}),o($V81,[2,14],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($V81,[2,15]),o($VU1,[2,10]),{6:$V51,9:133,11:[1,411]},o($Vr2,[2,355],{218:108,222:109,211:149,217:150,246:$Vf1}),o($Vr2,[2,356],{218:108,222:109,211:149,217:150,246:$Vf1}),o($Vj1,[2,357],{218:108,222:109,211:149,217:150}),o([1,6,10,11,14,22,71,90,97,106,112,126,135,137,147,171,200,201,212,213,214,219,220,229,238,239,247,248],[2,358],{218:108,222:109,211:149,217:150,242:$Vd1,243:$Ve1,246:$Vf1}),o([1,6,10,11,14,22,71,90,97,106,112,126,135,137,147,171,200,201,212,213,214,219,220,229,238,239],[2,359],{218:108,222:109,211:149,217:150,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o([1,6,10,11,14,22,71,90,97,106,112,135,137,147,171,200,201,212,213,214,219,220,229,238,239],[2,360],{218:108,222:109,211:149,217:150,126:$V91,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o([1,6,10,11,14,22,71,90,97,106,112,126,135,137,147,171,200,201,212,213,214,219,220,229,238,239,248],[2,361],{218:108,222:109,211:149,217:150,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1}),o($Vs2,[2,345],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),{126:$V91,135:[1,412],171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($Vs2,[2,344],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($Vu1,[2,261]),o($VD1,[2,215]),o($VD1,[2,216]),o($VD1,[2,221]),o($VD1,[2,217]),o($VD1,[2,220]),o($VD1,[2,222]),o($VD1,[2,218]),o($VD1,[2,219]),{112:[1,413]},{112:[2,241],126:$V91,171:$Va1,199:414,200:$VW1,201:$VX1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},{112:[2,242]},{13:415,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vt2,[2,271]),o($Vt2,[2,272]),{22:[1,416],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},{22:[1,417],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($VY1,[2,136],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),{13:418,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($VY1,[2,362],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),{13:419,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:420,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vu2,[2,342]),{5:421,10:$V1,126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($Vj1,[2,291],{206:422,207:$VZ1}),o($Vj1,[2,292]),{209:[1,423]},{5:424,10:$V1},{231:425,233:343,234:$V_1},{11:[1,426],232:[1,427],233:428,234:$V_1},o($Vv2,[2,335]),{13:430,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,203:429,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vj1,[2,254]),o($Vj1,[2,260]),{6:$V72,14:[1,432],106:[1,431],115:433},{51:[1,435],62:[1,434],89:[1,436]},{13:437,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{89:[1,438]},{51:[1,439],89:[1,440]},o($VA1,[2,110]),o($V02,[2,113]),o($V02,[2,116],{117:[1,441]}),{90:[1,442],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($Vj1,[2,157]),{89:$Vw1,150:443},{90:[1,444],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($Vu1,[2,265]),o([6,10,22],$V72,{115:445,14:$V82}),o($V92,$V52,{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),{29:446,32:$VC1},{31:447,33:218,50:220,51:$V8,57:219,58:$Vc},{31:448,33:218,50:220,51:$V8,57:219,58:$Vc},o($Vu1,[2,297]),{6:$V51,9:133,11:[1,449]},{13:450,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{6:$V51,9:452,10:$Vw2,97:[1,451]},o([6,10,11,22,97],$Vx2,{34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,17:30,18:31,25:36,131:38,178:39,72:40,186:41,187:42,166:44,129:45,101:46,189:47,140:48,141:49,142:50,176:57,235:58,211:60,215:61,217:62,192:64,121:70,148:72,168:76,150:77,63:79,82:92,155:93,57:97,52:98,55:99,59:100,109:101,173:102,50:103,218:108,222:109,61:116,65:117,16:155,12:228,15:230,13:361,202:454,19:$V2,20:$V3,23:$V4,24:$V5,26:$V6,32:$V7,51:$V8,53:$V9,54:$Va,56:$Vb,58:$Vc,60:$Vd,62:$Ve,64:$Vf,66:$Vg,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,83:$Vp,89:$Vq,91:$Vr,96:$Vs,103:$Vt,122:$Vu,123:$Vv,124:$Vw,130:$Vx,136:$Vy,138:$Vz,139:$VA,143:$VB,144:$VC,151:$VD,152:$VE,154:$VF,156:$VG,157:$VH,158:$VI,170:$VJ,171:$VG1,175:$VK,184:$VL,185:$VM,188:$VN,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,212:$VU,214:$VV,216:$VW,219:$VX,220:$VY,230:$VZ,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41}),o($Vy2,$V72,{115:455,14:$V82}),{13:456,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:457,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{97:[1,458],98:[1,459]},{14:$Vz2,147:[1,460]},o($VA2,[2,187]),o($VA2,[2,189]),o($VA2,[2,190]),o($VA2,[2,191],{117:[1,462]}),{50:382,51:$V8,169:463},{50:382,51:$V8,169:464},{50:382,51:$V8,169:465},o([14,22,117,147],[2,196]),{14:$Vz2,147:[1,466]},{6:$V51,9:468,10:$VB2,90:[1,467]},o([6,10,11,90],$Vx2,{61:116,65:117,134:250,15:251,50:252,57:253,63:254,52:255,55:256,133:470,32:$V7,51:$V8,53:$V9,54:$Va,56:$Vb,58:$Vc,62:$Ve,64:$Vf,66:$Vg,136:$VJ1,138:$Vz,139:$VA}),{10:[1,472],13:471,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{126:$V91,137:[1,473],171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($Vu2,[2,339]),{13:474,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:475,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vk2,[2,318]),{50:268,51:$V8,89:$Vw1,96:$VR1,150:270,168:269,226:476},o([1,6,10,11,14,22,71,90,97,106,112,135,137,147,200,201,212,214,219,220,238],[2,324],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,213:[1,477],229:[1,478],239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($VC2,[2,325],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,213:[1,479],239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($Vj1,[2,256]),{13:480,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vj1,[2,127]),{110:$VL1,125:481,128:$VM1},o($VT1,[2,65]),{71:[1,482],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},{50:287,51:$V8,57:288,58:$Vc,89:$VP1,161:483},o($VD2,[2,172]),o($VD2,[2,173]),o($VE2,$Vb2,{167:375,150:376,168:377,169:378,50:382,146:484,51:$V8,89:$Vw1,96:$VR1,170:$Vc2,171:$Vd2,172:$Ve2}),o($Vj1,[2,171]),{5:485,10:$V1,89:$Vm1,141:486,144:$VC},o($Vj1,[2,179]),{90:[1,487],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($VD1,[2,198]),o($VD1,[2,201]),o($VU1,[2,11]),{13:488,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($VD1,[2,223]),{13:489,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,112:[2,275],121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{112:[2,276],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($Vt1,[2,22]),o($Vt1,[2,24]),{6:$V51,9:491,11:$VF2,126:$V91,132:490,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},{6:$V51,9:491,11:$VF2,126:$V91,132:493,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},{5:494,10:$V1,126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($Vu2,[2,341]),o($Vj1,[2,293]),{5:495,10:$V1},o($Vj1,[2,294]),{11:[1,496],232:[1,497],233:428,234:$V_1},o($Vj1,[2,333]),{5:498,10:$V1},o($Vv2,[2,336]),{5:499,10:$V1,14:[1,500]},o($VG2,[2,288],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($V$1,[2,96],{107:501,10:[1,502],21:[1,503]}),{6:$Vx2,114:504,116:$V12},{6:[1,505]},o($VA1,[2,104]),o($VA1,[2,106]),{13:506,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{112:[1,507],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},{13:508,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($VA1,[2,109]),{13:509,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:511,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,118:510,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{106:[1,512]},{22:[1,513]},o($V22,[2,163]),{6:$V51,9:452,10:$Vw2,22:[1,514]},o($Vt1,[2,27]),o($V32,[2,32]),o($Vt1,[2,28]),{137:[1,515]},{97:[1,516],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($V62,[2,270]),{12:228,13:361,15:230,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,171:$VG1,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,202:517,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{10:$VE1,12:228,13:361,15:230,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,119:518,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,171:$VG1,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,202:226,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($V92,[2,278]),{6:$V51,9:520,10:$Vw2,11:$VF2,132:519},{90:[1,521],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},{90:[1,522],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($VO1,[2,89]),{32:$V7,51:[1,524],61:116,62:$Ve,63:525,64:$Vf,65:117,66:$Vg,89:[1,526],99:523},{5:527,10:$V1},{50:382,51:$V8,89:$Vw1,96:$VR1,150:376,167:528,168:377,169:378,170:$Vc2,171:$Vd2,172:$Ve2},{13:529,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($VA2,[2,192]),o($VA2,[2,193]),o($VA2,[2,194]),{5:530,10:$V1},o([1,6,10,11,14,21,22,71,88,89,90,97,106,111,112,117,126,135,137,144,147,171,180,181,183,196,200,201,212,213,214,219,220,227,228,229,238,239,242,243,246,247,248],[2,243]),{15:251,32:$V7,50:252,51:$V8,52:255,53:$V9,54:$Va,55:256,56:$Vb,57:253,58:$Vc,61:116,62:$Ve,63:254,64:$Vf,65:117,66:$Vg,133:531,134:250,136:$VJ1,138:$Vz,139:$VA},o([6,10,11,14],$VI1,{61:116,65:117,133:249,134:250,15:251,50:252,57:253,63:254,52:255,55:256,191:532,32:$V7,51:$V8,53:$V9,54:$Va,56:$Vb,58:$Vc,62:$Ve,64:$Vf,66:$Vg,136:$VJ1,138:$Vz,139:$VA}),o($Vg2,[2,246]),o($Vg2,[2,139],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),{13:533,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vh2,[2,147]),o($Vj2,[2,300],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($Vj2,[2,302],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($Vk2,[2,323]),{13:534,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:535,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:536,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o([1,6,11,14,22,71,90,97,106,112,135,137,147,200,201,213,220,229,238],[2,257],{218:108,222:109,211:149,217:150,5:537,10:$V1,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($V$1,[2,128],{5:538,10:$V1}),o($VT1,[2,66]),{21:[1,539],162:540,164:$Vo2,165:$Vp2},{14:$Vz2,22:[1,541]},o($Vj1,[2,177]),o($Vj1,[2,178]),o($Vq2,[2,176]),o([1,6,10,11,14,22,71,90,97,106,112,135,137,147,200,201,212,213,214,219,220,229,238,239],[2,346],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),{112:[2,274],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($Vj1,[2,137]),{11:$VH2},o($Vj1,[2,283]),o($Vj1,[2,363]),o($Vu2,[2,340]),o([1,6,10,11,14,22,71,90,97,106,112,126,135,137,147,171,200,201,207,212,213,214,219,220,229,238,239,242,243,246,247,248],[2,295]),o($Vj1,[2,331]),{5:543,10:$V1},{11:[1,544]},o($Vv2,[2,337],{6:[1,545]}),{13:546,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vj1,[2,97]),{10:$VE1,12:228,13:361,15:230,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,119:547,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,171:$VG1,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,202:226,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{10:$VE1,12:228,13:361,15:230,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,119:548,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,171:$VG1,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,202:226,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($V02,[2,114]),{114:549,116:$V12},{90:[1,550],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($VA1,[2,105]),{90:[1,551],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},{90:[1,552],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($V02,[2,117]),o($V02,[2,118],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($Vj1,[2,98]),o($Vj1,[2,158]),o($Vu1,[2,266]),o($Vu1,[2,298]),o($Vu1,[2,273]),o($V92,[2,279]),o($Vy2,$V72,{115:553,14:$V82}),o($V92,[2,280]),{11:$VH2,12:228,13:361,15:230,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,171:$VG1,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,202:517,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($VO1,[2,83]),o($VO1,[2,84]),{97:[1,554]},{97:[2,93]},{97:[2,94]},{13:555,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vu1,[2,155]),o($VA2,[2,188]),o($VA2,[2,195],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),{90:[1,556]},o($Vg2,[2,247]),o($Vy2,$V72,{115:557,14:$Vf2}),{6:$V51,9:491,11:$VF2,126:$V91,132:558,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o([1,6,10,11,14,22,71,90,97,106,112,135,137,147,200,201,212,213,214,219,220,238],[2,326],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,229:[1,559],239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($VC2,[2,328],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,213:[1,560],239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($VY1,[2,327],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($Vj1,[2,258]),o($Vj1,[2,129]),o($VE2,$Vb2,{167:375,150:376,168:377,169:378,50:382,146:561,51:$V8,89:$Vw1,96:$VR1,170:$Vc2,171:$Vd2,172:$Ve2}),o($Vj1,[2,169]),{162:562,164:$Vo2,165:$Vp2},o($Vj1,[2,282]),{6:$V51,9:491,11:$VF2,132:563},o($Vj1,[2,334]),o($Vv2,[2,338]),o($VG2,[2,289],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($VI2,$V72,{115:565,11:[1,564],14:$V82}),o($VI2,$V72,{115:565,14:$V82,22:[1,566]}),o($V02,[2,115]),o($VA1,[2,107]),o($VA1,[2,108]),o($VA1,[2,111]),{6:$V51,9:520,10:$Vw2,11:$VF2,132:567},o($VO1,[2,90]),{90:[1,568],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($Vu1,[2,156]),{6:$V51,9:570,10:$VB2,11:$VF2,132:569},o($Vg2,[2,140]),{13:571,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:572,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{14:$Vz2,22:[1,573]},o($Vj1,[2,170]),o($Vj1,[2,332]),o($Vj1,[2,119]),{6:$V51,9:452,10:$Vw2},o($Vj1,[2,120]),o($V92,[2,281]),{97:[2,95]},o($Vg2,[2,248]),{11:$VH2,15:251,32:$V7,50:252,51:$V8,52:255,53:$V9,54:$Va,55:256,56:$Vb,57:253,58:$Vc,61:116,62:$Ve,63:254,64:$Vf,65:117,66:$Vg,133:531,134:250,136:$VJ1,138:$Vz,139:$VA},o($VY1,[2,329],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($VY1,[2,330],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),{162:574,164:$Vo2,165:$Vp2},o($Vj1,[2,168])],
	defaultActions: {135:[2,3],163:[2,264],324:[2,242],524:[2,93],525:[2,94],568:[2,95]},
	parseError: function parseError(str, hash) {
	    if (hash.recoverable) {
	        this.trace(str);
	    } else {
	        throw new Error(str);
	    }
	},
	parse: function parse(input) {
	
	    // For Imba we are going to drop most of the features that are not used
	    // Locations are provided by the tokens from the lexer directly - so drop yylloc
	    // We dont really need the shared state (it seems)
	
	    var self = this,
	        stack = [0],
	        tstack = [], // token stack
	        vstack = [null], // semantic value stack
	        table = this.table,
	        yytext = '',
	        yylineno = 0,
	        yyleng = 0,
	        recovering = 0,
	        TERROR = 2,
	        EOF = 1;
	
	    // var args = lstack.slice.call(arguments, 1);
	    //this.reductionCount = this.shiftCount = 0;
	
	    var lexer = Object.create(this.lexer);
	    var yy = this.yy;
	
	    lexer.setInput(input,yy);
	
	    if (typeof yy.parseError === 'function') {
	        this.parseError = yy.parseError;
	    } else {
	        this.parseError = Object.getPrototypeOf(this).parseError; // what?
	    }
	
	    function popStack (n) {
	        stack.length = stack.length - 2 * n;
	        vstack.length = vstack.length - n;
	    }
	
	    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
	
	    function handleError(){
	        var error_rule_depth;
	        var errStr = '';
	
	        // Return the rule stack depth where the nearest error rule can be found.
	        // Return FALSE when no error recovery rule was found.
	        // we have no rules now
	        function locateNearestErrorRecoveryRule(state) {
	            var stack_probe = stack.length - 1;
	            var depth = 0;
	
	            // try to recover from error
	            for(;;) {
	                // check for error recovery rule in this state
	                if ((TERROR.toString()) in table[state]) {
	                    return depth;
	                }
	                if (state === 0 || stack_probe < 2) {
	                    return false; // No suitable error recovery rule available.
	                }
	                stack_probe -= 2; // popStack(1): [symbol, action]
	                state = stack[stack_probe];
	                ++depth;
	            }
	        }
	
	        if (!recovering) {
	            // first see if there's any chance at hitting an error recovery rule:
	            error_rule_depth = locateNearestErrorRecoveryRule(state);
	
	            // Report error
	            expected = [];
	
	            var tsym = lexer.yytext;
	            var tok = self.terminals_[symbol] || symbol;
	            var tloc = tsym ? tsym._loc : -1;
	            var tpos = tloc != -1 ? "[" + tsym._loc + ":" + tsym._len + "]" : '[0:0]';
	
	            if (lexer.showPosition) {
	                errStr = 'Parse error at '+(tpos)+":\n"+lexer.showPosition()+"\nExpecting "+expected.join(', ') + ", got '" + (self.terminals_[symbol] || symbol)+ "'";
	            } else {
	                errStr = 'Parse error at '+(tpos)+": Unexpected " + (symbol == EOF ? "end of input" : ("'"+(tok)+"'"));
	            }
	
	            self.parseError(errStr, {
	                lexer: lexer,
	                text: lexer.match,
	                token: tok,
	                line: lexer.yylineno,
	                expected: expected,
	                recoverable: (error_rule_depth !== false)
	            });
	        } else if (preErrorSymbol !== EOF) {
	            error_rule_depth = locateNearestErrorRecoveryRule(state);
	        }
	
	        // just recovered from another error
	        if (recovering == 3) {
	            if (symbol === EOF || preErrorSymbol === EOF) {
	                throw new Error(errStr || 'Parsing halted while starting to recover from another error.');
	            }
	
	            // discard current lookahead and grab another
	            yytext = lexer.yytext;
	        }
	
	        // try to recover from error
	        if (error_rule_depth === false) {
	            throw new Error(errStr || 'Parsing halted. No suitable error recovery rule available.');
	        }
	        popStack(error_rule_depth);
	        preErrorSymbol = (symbol == TERROR ? null : symbol); // save the lookahead token
	        symbol = TERROR;         // insert generic error symbol as new lookahead
	        state = stack[stack.length-1];
	        action = table[state] && table[state][TERROR];
	        recovering = 3; // allow 3 real symbols to be shifted before reporting a new error
	    }
	
	
	    var __sym = this.symbols_;
	    var __prod = this.productions_;
	
	    while (true) {
	        // retreive state number from top of stack
	        state = stack[stack.length - 1];
	
	        if (symbol === null || typeof symbol == 'undefined') {
	            symbol = __sym[lexer.lex()] || EOF;
	        }
	        action = table[state] && table[state][symbol];
	
	_handle_error:
	        if (typeof action === 'undefined' || !action.length || !action[0]) {
	            handleError();
	        }
	
	        switch (action[0]) {
	            case 1: // shift
	                stack.push(symbol);
	                stack.push(action[1]); // push state
	                vstack.push(lexer.yytext);
	                
	                symbol = null;
	                if (!preErrorSymbol) { // normal execution/no error
	                    yytext = lexer.yytext;
	                    if (recovering > 0) {
	                        recovering--;
	                    }
	                } else {
	                    // error just occurred, resume old lookahead f/ before error
	                    symbol = preErrorSymbol;
	                    preErrorSymbol = null;
	                }
	                break;
	
	            case 2:
	                len = __prod[action[1]][1];
	                // perform semantic action
	                yyval.$ = vstack[vstack.length-len];
	                r = this.performAction(yyval, yytext, yy, action[1], vstack);
	                if (typeof r !== 'undefined') {
	                    return r;
	                }
	
	                while(len > 0) {
	                    stack.pop();
	                    stack.pop();
	                    vstack.pop();
	                    len--;
	                }
	
	                stack.push(__prod[action[1]][0]);
	                newState = table[stack[stack.length-2]][stack[stack.length-1]];
	                stack.push(newState);
	                vstack.push(yyval.$);
	                break;
	
	            case 3:
	                return true;
	        }
	    }
	
	    return true;
	}};
	
	function Parser () {
	  this.yy = {};
	}
	Parser.prototype = parser;parser.Parser = Parser;
	return new Parser;
	})();
	
	
	if (true) {
	exports.parser = parser;
	exports.Parser = parser.Parser;
	exports.parse = function () { return parser.parse.apply(parser, arguments); };
	// exports.main = function commonjsMain(args) {
	//     if (!args[1]) {
	//         console.log('Usage: '+args[0]+' FILE');
	//         process.exit(1);
	//     }
	//     var source = require('fs').readFileSync(require('path').normalize(args[1]), "utf8");
	//     return exports.parser.parse(source);
	// };
	if (typeof module !== 'undefined' && __webpack_require__.c[0] === module) {
	  exports.main(process.argv.slice(1));
	}
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)(module), __webpack_require__(7)))

/***/ },
/* 6 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 7 */
/***/ function(module, exports) {

	// shim for using process in browser
	
	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function idx$(a,b){
			return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
		};
		
		// helper for subclassing
		function subclass$(obj,sup) {
			for (var k in sup) {
				if (sup.hasOwnProperty(k)) obj[k] = sup[k];
			};
			// obj.__super__ = sup;
			obj.prototype = Object.create(sup.prototype);
			obj.__super__ = obj.prototype.__super__ = sup.prototype;
			obj.prototype.initialize = obj.prototype.constructor = obj;
		};
		
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		var AST, OP, OP_COMPOUND, NODES, SPLAT, STACK, K_IVAR, K_SYM, K_STR, K_PROP, BR, BR2, SELF, SUPER, TRUE, FALSE, UNDEFINED, NIL, ARGUMENTS, EMPTY, NULL, RESERVED, RESERVED_REGEX, UNION, INTERSECT, CLASSDEF, TAGDEF, NEWTAG;
		// TODO Create Expression - make all expressions inherit from these?
		
		// externs;
		
		var helpers = __webpack_require__(9);
		var ERR = __webpack_require__(1);
		var v8 = null; // require 'v8-natives'
		
		var T = __webpack_require__(3);
		var Token = T.Token;
		
		var SourceMap = __webpack_require__(10).SourceMap;
		
		module.exports.AST = AST = {};
		
		// Helpers for operators
		module.exports.OP = OP = function(op,l,r) {
			var o = String(op);
			// console.log "operator",o
			switch (o) {
				case '.':
					if ((typeof r=='string'||r instanceof String)) { r = new Identifier(r) };
					// r = r.value if r isa VarOrAccess
					return new Access(op,l,r);
					break;
				
				case '=':
					if (l instanceof Tuple) { return new TupleAssign(op,l,r) };
					return new Assign(op,l,r);
					break;
				
				case '?=':
				case '||=':
				case '&&=':
					return new ConditionalAssign(op,l,r);
					break;
				
				case '+=':
				case '-=':
				case '*=':
				case '/=':
				case '^=':
				case '%=':
					return new CompoundAssign(op,l,r);
					break;
				
				case '?.':
					if (r instanceof VarOrAccess) {
						// console.log "is var or access"
						r = r.value();
					};
					// depends on the right side - this is wrong
					return new PropertyAccess(op,l,r);
					break;
				
				case 'instanceof':
					return new InstanceOf(op,l,r);
					break;
				
				case 'in':
					return new In(op,l,r);
					break;
				
				case 'typeof':
					return new TypeOf(op,l,r);
					break;
				
				case 'delete':
					return new Delete(op,l,r);
					break;
				
				case '--':
				case '++':
				case '!':
				case '√':
					return new UnaryOp(op,l,r);
					break;
				
				case '>':
				case '<':
				case '>=':
				case '<=':
				case '==':
				case '===':
				case '!=':
				case '!==':
					return new ComparisonOp(op,l,r);
					break;
				
				case '∩':
				case '∪':
					return new MathOp(op,l,r);
					break;
				
				case '..':
				case '...':
					return new Range(op,l,r);
					break;
				
				default:
				
					return new Op(op,l,r);
			
			};
		};
		
		module.exports.OP_COMPOUND = OP_COMPOUND = function(sym,op,l,r) {
			// console.log "?. soak operator",sym
			if (sym == '?.') {
				console.log("?. soak operator");
				return null;
			};
			if (sym == '?=' || sym == '||=' || sym == '&&=') {
				return new ConditionalAssign(op,l,r);
			} else {
				return new CompoundAssign(op,l,r);
			};
		};
		
		var OPTS = {};
		var ROOT = null;
		
		module.exports.NODES = NODES = [];
		
		var LIT = function(val) {
			return new Literal(val);
		};
		
		var SYM = function(val) {
			return new Symbol(val);
		};
		
		var IF = function(cond,body,alt) {
			var node = new If(cond,body);
			if (alt) { node.addElse(alt) };
			return node;
		};
		
		var FN = function(pars,body) {
			return new Func(pars,body);
		};
		
		var CALL = function(callee,pars) {
			// possibly return instead(!)
			if(pars === undefined) pars = [];
			return new Call(callee,pars);
		};
		
		var CALLSELF = function(name,pars) {
			if(pars === undefined) pars = [];
			var ref = new Identifier(name);
			return new Call(OP('.',SELF,ref),pars);
		};
		
		var BLOCK = function() {
			return Block.wrap([].slice.call(arguments));
		};
		
		var WHILE = function(test,code) {
			return new While(test).addBody(code);
		};
		
		module.exports.SPLAT = SPLAT = function(value) {
			if (value instanceof Assign) {
				// p "WARN"
				value.setLeft(new Splat(value.left()));
				return value;
			} else {
				return new Splat(value);
				// not sure about this
			};
		};
		
		// OP.ASSIGNMENT = [ "=" , "+=" , "-=" , "*=" , "/=" , "%=", "<<=" , ">>=" , ">>>=", "|=" , "^=" , "&=" ]
		// OP.LOGICAL = [ "||" , "&&" ]
		// OP.UNARY = [ "++" , "--" ]
		
		var SEMICOLON_TEST = /;(\s*\/\/.*)?[\n\s\t]*$/;
		var RESERVED_TEST = /^(default|char)$/;
		
		// captures error from parser
		function parseError(str,o){
			// console.log 'parseError',o:token
			
			// find nearest token
			var err;
			
			if (o.lexer) {
				var token = o.lexer.yytext;
				// console.log o:lexer:pos,token.@loc
				err = new ERR.ImbaParseError({message: str},{
					pos: o.lexer.pos,
					tokens: o.lexer.tokens,
					token: o.lexer.yytext,
					meta: o
				});
				
				throw err;
				
				// should find the closest token with actual position
				// str = "[{token.@loc}:{token.@len || String(token):length}] {str}"
			};
			var e = new Error(str);
			e.lexer = o.lexer;
			e.options = o;
			throw e;
		}; exports.parseError = parseError;
		
		function c__(obj){
			return typeof obj == 'string' ? (obj) : (obj.c());
		};
		
		function mark__(tok){
			if (tok && (OPTS.sourceMapInline || OPTS.sourceMap) && tok.sourceMapMarker) {
				return tok.sourceMapMarker();
			} else {
				return '';
			};
		};
		
		function num__(num){
			return new Num(num);
		};
		
		function str__(str){
			// should pack in token?!?
			return new Str(str);
		};
		
		function blk__(obj){
			return obj instanceof Array ? (Block.wrap(obj)) : (obj);
		};
		
		function sym__(obj){
			// console.log "sym {obj}"
			return helpers.symbolize(String(obj));
		};
		
		function cary__(ary){
			return ary.map(function(v) { return typeof v == 'string' ? (v) : (v.c()); });
		};
		
		function dump__(obj,key){
			if (obj instanceof Array) {
				return obj.map(function(v) { return v && v.dump ? (v.dump(key)) : (v); });
			} else if (obj && obj.dump) {
				return obj.dump();
			};
		};
		
		function compact__(ary){
			if (ary instanceof ListNode) {
				return ary.compact();
			};
			
			return ary.filter(function(v) { return v != undefined && v != null; });
		};
		
		function reduce__(res,ary){
			for (var i = 0, items = iter$(ary), len = items.length, v; i < len; i++) {
				v = items[i];
				v instanceof Array ? (reduce__(res,v)) : (res.push(v));
			};
			return;
		};
		
		function flatten__(ary,compact){
			if(compact === undefined) compact = false;
			var out = [];
			for (var i = 0, items = iter$(ary), len = items.length, v; i < len; i++) {
				v = items[i];
				v instanceof Array ? (reduce__(out,v)) : (out.push(v));
			};
			return out;
		};
		
		AST.parse = function (str,opts){
			if(opts === undefined) opts = {};
			var indent = str.match(/\t+/)[0];
			// really? Require the compiler, not this
			return Imbac.parse(str,opts);
		};
		
		AST.inline = function (str,opts){
			if(opts === undefined) opts = {};
			return this.parse(str,opts).body();
		};
		
		AST.node = function (typ,pars){
			if (typ == 'call') {
				if (pars[0].c() == 'return') {
					pars[0] = 'tata';
				};
				return new Call(pars[0],pars[1],pars[2]);
			};
		};
		
		
		AST.escapeComments = function (str){
			if (!(str)) { return '' };
			return str;
		};
		
		function Indentation(a,b){
			this._open = a;
			this._close = b;
			this;
		};
		
		exports.Indentation = Indentation; // export class 
		Indentation.prototype.open = function(v){ return this._open; }
		Indentation.prototype.setOpen = function(v){ this._open = v; return this; };
		Indentation.prototype.close = function(v){ return this._close; }
		Indentation.prototype.setClose = function(v){ this._close = v; return this; };
		
		Indentation.prototype.isGenerated = function (){
			return this._open && this._open.generated;
		};
		
		Indentation.prototype.aloc = function (){
			return this._open && this._open._loc || 0;
		};
		
		Indentation.prototype.bloc = function (){
			return this._close && this._close._loc || 0;
		};
		
		// should rather parse and extract the comments, no?
		Indentation.prototype.wrap = function (str){
			// var pre, post
			
			// console.log "INDENT {@open and JSON.stringify(@open.@meta)}"
			// console.log "OUTDENT {@close}"
			// var ov = @open and @open.@value
			// if ov and ov:length > 1
			// 	console.log "value for indent",ov
			// 	if ov.indexOf('%|%')
			// 		pre = ov.substr
			var om = this._open && this._open._meta;
			var pre = om && om.pre || '';
			var post = om && om.post || '';
			var esc = AST.escapeComments;
			var out = this._close;
			
			// the first newline should not be indented?
			str = post.replace(/^\n/,'') + str;
			str = str.replace(/^/g,"\t").replace(/\n/g,"\n\t").replace(/\n\t$/g,"\n");
			
			str = pre + '\n' + str;
			if (out instanceof Terminator) { str += out.c() };
			if (str[str.length - 1] != '\n') { str = str + '\n' };
			return str;
		};
		
		var INDENT = new Indentation({},{});
		
		function Stash(){
			this._entities = [];
		};
		
		Stash.prototype.add = function (item){
			this._entities.unshift(item);
			return this;
		};
		
		Stash.prototype.pluck = function (item){
			var match = null;
			for (var i = 0, ary = iter$(this._entities), len = ary.length, entity; i < len; i++) {
				entity = ary[i];
				if (entity == item || (entity instanceof item)) {
					match = entity;
					this._entities.splice(i,1);
					return match;
				};
			};
			return null;
		};
		
		
		function Stack(){
			this.reset();
		};
		
		exports.Stack = Stack; // export class 
		Stack.prototype.loglevel = function(v){ return this._loglevel; }
		Stack.prototype.setLoglevel = function(v){ this._loglevel = v; return this; };
		Stack.prototype.nodes = function(v){ return this._nodes; }
		Stack.prototype.setNodes = function(v){ this._nodes = v; return this; };
		Stack.prototype.scopes = function(v){ return this._scopes; }
		Stack.prototype.setScopes = function(v){ this._scopes = v; return this; };
		
		Stack.prototype.reset = function (){
			this._nodes = [];
			this._scoping = [];
			this._scopes = []; // for analysis - should rename
			this._stash = new Stash(this);
			this._loglevel = 3;
			this._counter = 0;
			this._counters = {};
			return this;
		};
		
		Stack.prototype.incr = function (name){
			var $1;
			this._counters[($1 = name)] || (this._counters[$1] = 0);
			return this._counters[name] += 1;
		};
		
		Stack.prototype.stash = function (){
			return this._stash;
		};
		
		Stack.prototype.option = function (key){
			return this._options && this._options[key];
		};
		
		Stack.prototype.addScope = function (scope){
			this._scopes.push(scope);
			return this;
		};
		
		Stack.prototype.traverse = function (node){
			return this;
		};
		
		Stack.prototype.push = function (node){
			this._nodes.push(node);
			// not sure if we have already defined a scope?
			return this;
		};
		
		Stack.prototype.pop = function (node){
			this._nodes.pop(); // (node)
			return this;
		};
		
		Stack.prototype.parent = function (){
			return this._nodes[this._nodes.length - 2];
		};
		
		Stack.prototype.current = function (){
			return this._nodes[this._nodes.length - 1];
		};
		
		Stack.prototype.up = function (test){
			test || (test = function(v) { return !(v instanceof VarOrAccess); });
			
			if (test.prototype instanceof Node) {
				var typ = test;
				test = function(v) { return v instanceof typ; };
			};
			
			var i = this._nodes.length - 2; // key
			while (i >= 0){
				var node = this._nodes[i];
				if (test(node)) { return node };
				i -= 1;
			};
			return null;
		};
		
		Stack.prototype.relative = function (node,offset){
			if(offset === undefined) offset = 0;
			var idx = this._nodes.indexOf(node);
			return idx >= 0 ? (this._nodes[idx + offset]) : (null);
		};
		
		Stack.prototype.scope = function (lvl){
			if(lvl === undefined) lvl = 0;
			var i = this._nodes.length - 1 - lvl;
			while (i >= 0){
				var node = this._nodes[i];
				if (node._scope) { return node._scope };
				i -= 1;
			};
			return null;
		};
		
		Stack.prototype.scopes = function (){
			// include deeper scopes as well?
			var scopes = [];
			var i = this._nodes.length - 1;
			while (i >= 0){
				var node = this._nodes[i];
				if (node._scope) { scopes.push(node._scope) };
				i -= 1;
			};
			return scopes;
		};
		
		Stack.prototype.method = function (){
			return this.up(MethodDeclaration);
		};
		
		Stack.prototype.block = function (){
			return this.up(Block);
		};
		
		Stack.prototype.isExpression = function (){
			var i = this._nodes.length - 1;
			while (i >= 0){
				var node = this._nodes[i];
				// why are we not using isExpression here as well?
				if ((node instanceof Code) || (node instanceof Loop)) {
					return false;
				};
				if (node.isExpression()) {
					return true;
				};
				// probably not the right test - need to be more explicit
				i -= 1;
			};
			return false;
		};
		
		Stack.prototype.toString = function (){
			return ("Stack(" + this._nodes.join(" -> ") + ")");
		};
		
		Stack.prototype.scoping = function (){
			return this._nodes.filter(function(n) { return n._scope; }).map(function(n) { return n._scope; });
		};
		
		// Lots of globals -- really need to deal with one stack per file / context
		module.exports.STACK = STACK = new Stack();
		
		GLOBSTACK = STACK;
		
		// use a bitmask for these
		
		function Node(){
			this.setup();
			this;
		};
		
		exports.Node = Node; // export class 
		Node.prototype.o = function(v){ return this._o; }
		Node.prototype.setO = function(v){ this._o = v; return this; };
		Node.prototype.options = function(v){ return this._options; }
		Node.prototype.setOptions = function(v){ this._options = v; return this; };
		Node.prototype.traversed = function(v){ return this._traversed; }
		Node.prototype.setTraversed = function(v){ this._traversed = v; return this; };
		
		Node.prototype.safechain = function (){
			return false;
		};
		
		// def dom
		// 	var name = "ast_" + self:constructor:name.replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase
		// 	# p "try to get the dom-node for this ast-node",name
		// 	if Imba.TAGS[name]
		// 		var node = Imba.tag(name)
		// 		node.bind(self).build
		// 		return node
		// 	else
		// 		return "[{name}]"
		
		Node.prototype.p = function (){
			
			// allow controlling this from commandline
			if (STACK.loglevel() > 0) {
				console.log.apply(console,arguments);
			};
			return this;
		};
		
		Node.prototype.typeName = function (){
			return this.constructor.name;
		};
		
		Node.prototype.namepath = function (){
			return this.typeName();
		};
		
		Node.prototype.setup = function (){
			this._expression = false;
			this._traversed = false;
			this._parens = false;
			this._cache = null;
			this._value = null;
			return this;
		};
		
		Node.prototype.set = function (obj){
			// console.log "setting options {JSON.stringify(obj)}"
			this._options || (this._options = {});
			for (var i = 0, keys = Object.keys(obj), l = keys.length; i < l; i++){
				this._options[keys[i]] = obj[keys[i]];
			};
			return this;
		};
		
		// get and set
		Node.prototype.option = function (key,val){
			if (val != undefined) {
				// console.log "setting option {key} {val}"
				this._options || (this._options = {});
				this._options[key] = val;
				return this;
			};
			
			return this._options && this._options[key];
		};
		
		Node.prototype.configure = function (obj){
			return this.set(obj);
		};
		
		Node.prototype.region = function (){
			return [0,0];
		};
		
		Node.prototype.loc = function (){
			return [0,0];
		};
		
		Node.prototype.token = function (){
			return null;
		};
		
		Node.prototype.compile = function (){
			return this;
		};
		
		Node.prototype.visit = function (){
			return this;
		};
		
		Node.prototype.stack = function (){
			return STACK;
		};
		
		Node.prototype.isString = function (){
			return false;
		};
		
		Node.prototype.isPrimitive = function (deep){
			return false;
		};
		
		Node.prototype.isReserved = function (){
			return false;
		};
		
		// should rather do traversals
		// o = {}, up, key, index
		Node.prototype.traverse = function (){
			if (this._traversed) {
				return this;
			};
			// NODES.push(self)
			this._traversed = true;
			STACK.push(this);
			this.visit(STACK);
			STACK.pop(this);
			return this;
		};
		
		Node.prototype.inspect = function (){
			return {type: this.constructor.toString()};
		};
		
		Node.prototype.js = function (o){
			return "NODE";
		};
		
		Node.prototype.toString = function (){
			return ("" + (this.constructor.name));
		};
		
		// swallow might be better name
		Node.prototype.consume = function (node){
			if (node instanceof PushAssign) {
				return new PushAssign(node.op(),node.left(),this);
			};
			
			if (node instanceof Assign) {
				// p "consume assignment".cyan
				// node.right = self
				return OP(node.op(),node.left(),this);
			} else if (node instanceof Op) {
				return OP(node.op(),node.left(),this);
			} else if (node instanceof Return) {
				// p "consume return".cyan
				return new Return(this);
			};
			return this;
		};
		
		Node.prototype.toExpression = function (){
			this._expression = true;
			return this;
		};
		
		Node.prototype.forceExpression = function (){
			this._expression = true;
			return this;
		};
		
		Node.prototype.isExpressable = function (){
			return true;
		};
		
		Node.prototype.isExpression = function (){
			return this._expression || false;
		};
		
		Node.prototype.hasSideEffects = function (){
			return true;
		};
		
		Node.prototype.isUsed = function (){
			return true;
		};
		
		Node.prototype.shouldParenthesize = function (){
			return false;
		};
		
		Node.prototype.block = function (){
			return Block.wrap([this]);
		};
		
		Node.prototype.node = function (){
			return this;
		};
		
		Node.prototype.scope__ = function (){
			return STACK.scope();
		};
		
		Node.prototype.up = function (){
			return STACK.parent();
		};
		
		Node.prototype.util = function (){
			return Util;
		};
		
		Node.prototype.receiver = function (){
			return this;
		};
		
		Node.prototype.addExpression = function (expr){
			// might be better to nest this up after parsing is done?
			// p "addExpression {self} <- {expr}"
			var node = new ExpressionBlock([this]);
			return node.addExpression(expr);
		};
		
		
		Node.prototype.indented = function (a,b){
			
			if (a instanceof Indentation) {
				this._indentation = a;
				return this;
			};
			
			// this is a _BIG_ hack
			if (b instanceof Array) {
				this.add(b[0]);
				b = b[1];
			};
			
			// if indent and indent.match(/\:/)
			this._indentation || (this._indentation = a && b ? (new Indentation(a,b)) : (INDENT));
			return this;
		};
		
		Node.prototype.prebreak = function (term){
			// in options instead?
			// console.log "prebreak!!!!"
			// @prebreak = @prebreak or term
			if(term === undefined) term = '\n';
			return this;
		};
		
		Node.prototype.invert = function (){
			return OP('!',this);
		};
		
		Node.prototype.cache = function (o){
			if(o === undefined) o = {};
			this._cache = o;
			o.var = this.scope__().temporary(this,o);
			o.lookups = 0;
			return this;
		};
		
		Node.prototype.cachevar = function (){
			return this._cache && this._cache.var;
		};
		
		Node.prototype.decache = function (){
			if (this._cache) {
				this.cachevar().free();
				this._cache = null;
			};
			return this;
		};
		
		// is this without side-effects? hmm - what does it even do?
		Node.prototype.predeclare = function (){
			if (this._cache) {
				this.scope__().vars().swap(this._cache.var,this);
			};
			return this;
		};
		
		// the "name-suggestion" for nodes if they need to be cached
		Node.prototype.alias = function (){
			return null;
		};
		
		Node.prototype.warn = function (text,opts){
			if(opts === undefined) opts = {};
			opts.message = text;
			opts.loc || (opts.loc = this.loc());
			this.scope__().root().warn(opts);
			return this;
		};
		
		Node.prototype.c = function (o){
			var indent;
			var s = STACK;
			var ch = this._cache;
			if (ch && ch.cached) { return this.c_cached(ch) };
			
			s.push(this);
			if (o && o.expression) this.forceExpression();
			
			v8 && console.log(v8.hasFastObjectElements(this));
			
			if (o && o.indent) {
				this._indentation || (this._indentation = INDENT);
			};
			
			var out = this.js(s,o);
			
			// really? why not call this somewhere else?
			var paren = this.shouldParenthesize();
			
			if (indent = this._indentation) {
				out = indent.wrap(out,o);
			};
			
			// should move this somewhere else really
			if (paren) { out = ("(" + out + ")") };
			if (o && o.braces) {
				if (indent) {
					out = '{' + out + '}';
				} else {
					out = '{ ' + out + ' }';
				};
			};
			
			s.pop(this);
			
			if (ch = this._cache) {
				if (!ch.manual) { out = ("" + (ch.var.c()) + " = " + out) };
				var par = s.current();
				if ((par instanceof Access) || (par instanceof Op)) { out = '(' + out + ')' }; // others? # 
				ch.cached = true;
			};
			return out;
		};
		
		Node.prototype.c_cached = function (cache){
			cache.lookups++;
			if (cache.uses == cache.lookups) { cache.var.free() };
			return cache.var.c(); // recompile every time??
		};
		
		function ValueNode(value){
			this.setup();
			this._value = this.load(value);
		};
		
		subclass$(ValueNode,Node);
		exports.ValueNode = ValueNode; // export class 
		ValueNode.prototype.value = function(v){ return this._value; }
		ValueNode.prototype.setValue = function(v){ this._value = v; return this; };
		
		ValueNode.prototype.load = function (value){
			return value;
		};
		
		ValueNode.prototype.js = function (o){
			return typeof this._value == 'string' ? (this._value) : (this._value.c());
		};
		
		ValueNode.prototype.visit = function (){
			
			if (this._value instanceof Node) { this._value.traverse() }; //  && @value:traverse
			return this;
		};
		
		ValueNode.prototype.region = function (){
			return [this._value._loc,this._value._loc + this._value._len];
		};
		
		
		function Statement(){ return ValueNode.apply(this,arguments) };
		
		subclass$(Statement,ValueNode);
		exports.Statement = Statement; // export class 
		Statement.prototype.isExpressable = function (){
			return false;
		};
		
		
		function Meta(){ return ValueNode.apply(this,arguments) };
		
		subclass$(Meta,ValueNode);
		exports.Meta = Meta; // export class 
		Meta.prototype.isPrimitive = function (deep){
			return true;
		};
		
		function Comment(){ return Meta.apply(this,arguments) };
		
		subclass$(Comment,Meta);
		exports.Comment = Comment; // export class 
		Comment.prototype.visit = function (){
			// stack.stash.add(self)
			
			var block, next;
			if (block = this.up()) {
				var idx = block.indexOf(this) + 1;
				if (block.index(idx) instanceof Terminator) { idx += 1 };
				if (next = block.index(idx)) {
					next._desc = this;
				};
				
				// console.log "Next item after comment is {block.index(idx)}"
			};
			
			return this;
		};
		
		Comment.prototype.toDoc = function (){
			return helpers.normalizeIndentation("" + this._value._value);
		};
		
		Comment.prototype.toJSON = function (){
			return helpers.normalizeIndentation("" + this._value._value);
		};
		
		Comment.prototype.c = function (o){
			var v = this._value._value;
			// p @value.type
			if (o && o.expression || v.match(/\n/) || this._value.type() == 'HERECOMMENT') { // multiline?
				return ("/*" + v + "*/");
			} else {
				return ("// " + v);
			};
		};
		
		function Terminator(v){
			this._value = v;
			this;
		};
		
		subclass$(Terminator,Meta);
		exports.Terminator = Terminator; // export class 
		Terminator.prototype.traverse = function (){
			return this;
		};
		
		Terminator.prototype.c = function (){
			// TODO this can contain several newlines
			// for sourcemaps it would be nice to parse this
			// and fix it up mark__(@value) + 
			return this._value.c();
			// var v = value.replace(/\\n/g,'\n')
			// v # .split()
			// v.split("\n").map(|v| v ? " // {v}" : v).join("\n")
		};
		
		function Newline(v){
			this._traversed = false;
			this._value = v || '\n';
		};
		
		subclass$(Newline,Terminator);
		exports.Newline = Newline; // export class 
		Newline.prototype.c = function (){
			return c__(this._value);
		};
		
		
		// weird place?
		function Index(){ return ValueNode.apply(this,arguments) };
		
		subclass$(Index,ValueNode);
		exports.Index = Index; // export class 
		Index.prototype.js = function (o){
			return this._value.c();
		};
		
		function ListNode(list){
			this.setup();
			this._nodes = this.load(list || []);
			this._indentation = null;
		};
		
		// PERF acces @nodes directly?
		subclass$(ListNode,Node);
		exports.ListNode = ListNode; // export class 
		ListNode.prototype.nodes = function(v){ return this._nodes; }
		ListNode.prototype.setNodes = function(v){ this._nodes = v; return this; };
		
		ListNode.prototype.list = function (){
			return this._nodes;
		};
		
		ListNode.prototype.compact = function (){
			this._nodes = compact__(this._nodes);
			return this;
		};
		
		ListNode.prototype.load = function (list){
			return list;
		};
		
		ListNode.prototype.concat = function (other){
			// need to store indented content as well?
			this._nodes = this.nodes().concat(other instanceof Array ? (other) : (other.nodes()));
			return this;
		};
		
		ListNode.prototype.swap = function (item,other){
			var idx = this.indexOf(item);
			if (idx >= 0) { this.nodes()[idx] = other };
			return this;
		};
		
		ListNode.prototype.push = function (item){
			this._nodes.push(item);
			return this;
		};
		
		ListNode.prototype.pop = function (){
			var end = this._nodes.pop();
			return end;
		};
		
		ListNode.prototype.add = function (item){
			this._nodes.push(item);
			return this;
		};
		
		ListNode.prototype.unshift = function (item,br){
			if (br) { this._nodes.unshift(BR) };
			this._nodes.unshift(item);
			return this;
		};
		
		// test
		ListNode.prototype.slice = function (a,b){
			return new this.constructor(this._nodes.slice(a,b));
		};
		
		
		
		ListNode.prototype.break = function (br,pre){
			if(pre === undefined) pre = false;
			if (typeof br == 'string') { br = new Terminator(br) };
			pre ? (this.unshift(br)) : (this.push(br));
			return this;
		};
		
		ListNode.prototype.some = function (cb){
			for (var i = 0, ary = iter$(this._nodes), len = ary.length; i < len; i++) {
				if (cb(ary[i])) { return true };
			};
			return false;
		};
		
		ListNode.prototype.every = function (cb){
			for (var i = 0, ary = iter$(this._nodes), len = ary.length; i < len; i++) {
				if (!cb(ary[i])) { return false };
			};
			return true;
		};
		
		ListNode.prototype.filter = function (cb){
			return this._nodes.filter(cb);
		};
		
		ListNode.prototype.pluck = function (cb){
			var item = this.filter(cb)[0];
			if (item) { this.remove(item) };
			return item;
		};
		
		ListNode.prototype.indexOf = function (item){
			return this._nodes.indexOf(item);
		};
		
		ListNode.prototype.index = function (i){
			return this._nodes[i];
		};
		
		ListNode.prototype.remove = function (item){
			var idx = this._nodes.indexOf(item);
			if (idx >= 0) { this._nodes.splice(idx,1) };
			return this;
		};
		
		ListNode.prototype.removeAt = function (idx){
			var item = this._nodes[idx];
			if (idx >= 0) { this._nodes.splice(idx,1) };
			return item;
		};
		
		
		ListNode.prototype.replace = function (original,replacement){
			var idx = this._nodes.indexOf(original);
			if (idx >= 0) {
				if (replacement instanceof Array) {
					// p "replaceing with array of items"
					this._nodes.splice.apply(this._nodes,[].concat([idx,1], [].slice.call(replacement)));
				} else {
					this._nodes[idx] = replacement;
				};
			};
			return this;
		};
		
		ListNode.prototype.first = function (){
			return this._nodes[0];
		};
		
		ListNode.prototype.last = function (){
			var i = this._nodes.length;
			while (i){
				i = i - 1;
				var v = this._nodes[i];
				if (!((v instanceof Meta))) { return v };
			};
			return null;
		};
		
		ListNode.prototype.map = function (fn){
			return this._nodes.map(fn);
		};
		
		ListNode.prototype.forEach = function (fn){
			return this._nodes.forEach(fn);
		};
		
		ListNode.prototype.remap = function (fn){
			this._nodes = this.map(fn);
			return this;
		};
		
		ListNode.prototype.count = function (){
			return this._nodes.length;
		};
		
		ListNode.prototype.realCount = function (){
			var k = 0;
			for (var i = 0, ary = iter$(this._nodes), len = ary.length, node; i < len; i++) {
				node = ary[i];
				if (node && !(node instanceof Meta)) { k++ };
			};
			return k;
		};
		
		ListNode.prototype.visit = function (){
			for (var i = 0, ary = iter$(this._nodes), len = ary.length, node; i < len; i++) {
				node = ary[i];
				node && node.traverse();
			};
			return this;
		};
		
		ListNode.prototype.isExpressable = function (){
			for (var i = 0, ary = iter$(this.nodes()), len = ary.length, node; i < len; i++) {
				node = ary[i];
				if (node && !node.isExpressable()) { return false };
			};
			// return no unless nodes.every(|v| v.isExpressable )
			return true;
		};
		
		ListNode.prototype.toArray = function (){
			return this._nodes;
		};
		
		ListNode.prototype.delimiter = function (){
			return this._delimiter || ",";
		};
		
		ListNode.prototype.js = function (o,pars){
			if(!pars||pars.constructor !== Object) pars = {};
			var nodes = pars.nodes !== undefined ? pars.nodes : this._nodes;
			var delim = ',';
			var express = delim != ';';
			var last = this.last();
			
			var i = 0;
			var l = nodes.length;
			var str = "";
			
			for (var j = 0, ary = iter$(nodes), len = ary.length, arg; j < len; j++) {
				arg = ary[j];
				var part = typeof arg == 'string' ? (arg) : ((arg ? (arg.c({expression: express})) : ('')));
				str += part;
				if (part && (!(express) || arg != last) && !(arg instanceof Meta)) { str += delim };
			};
			
			return str;
		};
		
		ListNode.prototype.indented = function (a,b){
			if (a instanceof Indentation) {
				this._indentation = a;
				return this;
			};
			
			this._indentation || (this._indentation = a && b ? (new Indentation(a,b)) : (INDENT));
			return this;
		};
		
		
		function ArgList(){ return ListNode.apply(this,arguments) };
		
		subclass$(ArgList,ListNode);
		exports.ArgList = ArgList; // export class 
		
		
		//	def indented a,b
		//		if a isa Indentation
		//			@indentation = a
		//			return self
		//
		//		@indentation ||= a and b ? Indentation.new(a,b) : INDENT
		//		self
		
		// def hasSplat
		// 	@nodes.some do |v| v isa Splat
		// def delimiter
		// 	","
		
		
		function AssignList(){ return ArgList.apply(this,arguments) };
		
		subclass$(AssignList,ArgList);
		exports.AssignList = AssignList; // export class 
		AssignList.prototype.concat = function (other){
			if (this._nodes.length == 0 && (other instanceof AssignList)) {
				return other;
			} else {
				AssignList.__super__.concat.call(this,other);
			};
			// need to store indented content as well?
			// @nodes = nodes.concat(other isa Array ? other : other.nodes)
			return this;
		};
		
		
		function Block(list){
			this.setup();
			// @nodes = compact__(flatten__(list)) or []
			this._nodes = list || [];
			this._head = null;
			this._indentation = null;
		};
		
		subclass$(Block,ListNode);
		exports.Block = Block; // export class 
		Block.prototype.head = function(v){ return this._head; }
		Block.prototype.setHead = function(v){ this._head = v; return this; };
		
		Block.wrap = function (ary){
			if (!((ary instanceof Array))) {
				throw new SyntaxError("what");
			};
			return ary.length == 1 && (ary[0] instanceof Block) ? (ary[0]) : (new Block(ary));
		};
		
		Block.prototype.visit = function (){
			if (this._scope) { this._scope.visit() };
			
			for (var i = 0, ary = iter$(this._nodes), len = ary.length, node; i < len; i++) {
				node = ary[i];
				node && node.traverse();
			};
			return this;
		};
		
		Block.prototype.block = function (){
			return this;
		};
		
		// def indented a,b
		// 	@indentation ||= a and b ? Indentation.new(a,b) : INDENT
		// 	self
		
		Block.prototype.loc = function (){
			// rather indents, no?
			var opt, ind;
			if (opt = this.option('ends')) {
				// p "location is",opt
				var a = opt[0].loc();
				var b = opt[1].loc();
				
				if (!(a)) { this.p(("no loc for " + (opt[0]))) };
				if (!(b)) { this.p(("no loc for " + (opt[1]))) };
				
				return [a[0],b[1]];
			} else if (ind = this._indentation) {
				return [ind.aloc(),ind.bloc()];
			} else {
				return [0,0];
			};
		};
		
		// go through children and unwrap inner nodes
		Block.prototype.unwrap = function (){
			var ary = [];
			for (var i = 0, items = iter$(this.nodes()), len = items.length, node; i < len; i++) {
				node = items[i];
				if (node instanceof Block) {
					// p "unwrapping inner block"
					ary.push.apply(ary,node.unwrap());
				} else {
					ary.push(node);
				};
			};
			return ary;
		};
		
		Block.prototype.push = function (item){
			this._nodes.push(item);
			return this;
		};
		
		Block.prototype.add = function (item){
			this._nodes.push(item);
			return this;
		};
		
		// This is just to work as an inplace replacement of nodes.coffee
		// After things are working okay we'll do bigger refactorings
		Block.prototype.compile = function (o){
			if(o === undefined) o = {};
			var root = new Root(this,o);
			return root.compile(o);
		};
		
		
		// Not sure if we should create a separate block?
		Block.prototype.analyze = function (o){
			// p "analyzing block!!!",o
			if(o === undefined) o = {};
			return this;
		};
		
		Block.prototype.cpart = function (node){
			var out = typeof node == 'string' ? (node) : ((node ? (node.c()) : ("")));
			if (out == null || out == undefined || out == "") { return "" };
			
			if (out instanceof Array) {
				var str = "";
				var l = out.length;
				var i = 0;
				while (i < l){
					str += this.cpart(out[i++]);
				};
				return str;
			};
			
			var hasSemiColon = SEMICOLON_TEST.test(out);
			if (!(hasSemiColon || (node instanceof Meta))) { out += ";" };
			return out;
		};
		
		Block.prototype.js = function (o,opts){
			var ast = this._nodes;
			var l = ast.length;
			// really?
			var express = this.isExpression() || o.isExpression() || (this.option('express') && this.isExpressable());
			if (ast.length == 0) { return '' };
			
			if (express) {
				return Block.__super__.js.call(this,o,{nodes: ast});
			};
			
			var str = "";
			for (var i = 0, ary = iter$(ast), len = ary.length; i < len; i++) {
				str += this.cpart(ary[i]);
			};
			
			// now add the head items as well
			if (this._head && this._head.length > 0) {
				var prefix = "";
				for (var i = 0, ary = iter$(this._head), len = ary.length; i < len; i++) {
					var hv = this.cpart(ary[i]);
					if (hv) { prefix += hv + '\n' };
				};
				str = prefix + str;
			};
			return str;
		};
		
		
		// Should this create the function as well?
		Block.prototype.defers = function (original,replacement){
			var idx = this._nodes.indexOf(original);
			if (idx >= 0) { this._nodes[idx] = replacement };
			var rest = this._nodes.splice(idx + 1);
			return rest;
		};
		
		Block.prototype.expressions = function (){
			var expressions = [];
			for (var i = 0, ary = iter$(this.nodes()), len = ary.length, node; i < len; i++) {
				node = ary[i];
				if (!((node instanceof Terminator))) { expressions.push(node) };
			};
			return expressions;
		};
		
		
		Block.prototype.consume = function (node){
			var before;
			if (node instanceof TagTree) { // special case?!?
				this._nodes = this._nodes.map(function(child) {
					return child.consume(node);
				});
				
				var real = this.expressions();
				// FIXME should not include terminators and comments when counting
				// should only wrap the content in array (returning all parts)
				// for if/else blocks -- not loops
				
				// we need to compare the real length
				if (!node._loop && real.length > 1) {
					// p "lengths",@nodes:length,expressions:length
					var nr = node.blocks().push(this);
					var arr = new Arr(new ArgList(this._nodes));
					arr.indented(this._indentation);
					this._indentation = null;
					
					if (node.reactive()) {
						this._nodes = [Util.callImba("static",[arr,new Num(nr)])];
					} else {
						this._nodes = [arr];
					};
				};
				
				
				
				return this;
			};
			
			// can also return super if it is expressable, but should we really?
			if (before = this.last()) {
				var after = before.consume(node);
				if (after != before) {
					// p "replace node in block {before} -> {after}"
					if (after instanceof Block) {
						// p "replaced with block -- should basically add it instead?"
						after = after.nodes();
					};
					
					this.replace(before,after);
				};
			};
			// really?
			return this;
		};
		
		
		Block.prototype.isExpressable = function (){
			if (!this._nodes.every(function(v) { return v.isExpressable(); })) { return false };
			return true;
		};
		
		Block.prototype.isExpression = function (){
			
			return this.option('express') || this._expression;
		};
		
		
		// this is almost like the old VarDeclarations but without the values
		function VarBlock(){ return ListNode.apply(this,arguments) };
		
		subclass$(VarBlock,ListNode);
		exports.VarBlock = VarBlock; // export class 
		VarBlock.prototype.load = function (list){
			var first = list[0];
			
			if (first instanceof Assign) {
				this._type = first.left()._type;
			} else if (first instanceof VarReference) {
				this._type = first._type;
			};
			// p "here {list[0]} - {@type}"
			// @type = list[0] and list[0].type
			return list;
		};
		
		// TODO All these inner items should rather be straight up literals
		// or basic localvars - without any care whatsoever about adding var to the
		// beginning etc. 
		VarBlock.prototype.addExpression = function (expr){
			// p "VarBlock.addExpression {self} <- {expr}"
			
			if (expr instanceof Assign) {
				// make sure the left-side is a var-reference
				// this should be a different type of assign, no?
				if (expr.left() instanceof VarOrAccess) {
					expr.setLeft(new VarReference(expr.left().value(),this._type));
				};
				
				this.push(expr);
			} else if (expr instanceof Assign) {
				this.addExpression(expr.left()); // make sure this is a valid thing?
				// make this into a tuple instead
				// does not need to be a tuple?
				return new TupleAssign('=',new Tuple(this.nodes()),expr.right());
			} else if (expr instanceof VarOrAccess) {
				// this is really a VarReference
				this.push(new VarReference(expr.value(),this._type));
			} else if ((expr instanceof Splat) && (expr.node() instanceof VarOrAccess)) {
				// p "is a splat - only allowed in tuple-assignment"
				// what?
				expr.setValue(new VarReference(expr.node().value(),this._type));
				this.push(expr);
			} else {
				this.p(("VarBlock.addExpression " + this + " <- " + expr));
				throw "VarBlock does not allow non-variable expressions";
			};
			return this;
		};
		
		
		VarBlock.prototype.isExpressable = function (){
			// we would need to force-drop the variables, makes little sense
			// but, it could be, could just push the variables out?
			return false;
		};
		
		VarBlock.prototype.js = function (o){
			// p "VarBlock"
			// for n in @nodes
			// 	p "VarBlock child {n}"
			var code = compact__(flatten__(cary__(this.nodes())));
			code = code.filter(function(n) { return n != null && n != undefined && n != EMPTY; });
			var out = code.join(",");
			// we just need to trust that the variables have been autodeclared beforehand
			// if we are inside an expression
			if (!o.isExpression()) { out = "var " + out };
			return out;
		};
		
		
		VarBlock.prototype.consume = function (node){
			// It doesnt make much sense for a VarBlock to consume anything
			// it should probably return void for methods
			return this;
		};
		
		
		// Could inherit from valueNode
		function Parens(value,open,close){
			this.setup();
			this._open = open;
			this._close = close;
			this._value = this.load(value);
		};
		
		subclass$(Parens,ValueNode);
		exports.Parens = Parens; // export class 
		Parens.prototype.load = function (value){
			this._noparen = false;
			return (value instanceof Block) && value.count() == 1 ? (value.first()) : (value);
		};
		
		Parens.prototype.isString = function (){
			// checking if this is an interpolated string
			return this._open && String(this._open) == '("' || this.value().isString();
		};
		
		Parens.prototype.js = function (o){
			
			var par = this.up();
			var v = this._value;
			var str = null;
			
			if (v instanceof Func) { this._noparen = true };
			// p "compile parens {v} {v isa Block and v.count}"
			// p "Parens up {par} {o.isExpression}"
			if (par instanceof Block) {
				// is it worth it?
				if (!o.isExpression()) { this._noparen = true };
				str = v instanceof Array ? (cary__(v)) : (v.c({expression: o.isExpression()}));
			} else {
				str = v instanceof Array ? (cary__(v)) : (v.c({expression: true}));
			};
			
			// check if we really need parens here?
			return str;
		};
		
		Parens.prototype.set = function (obj){
			console.log(("Parens set " + JSON.stringify(obj)));
			return Parens.__super__.set.call(this,obj);
		};
		
		
		Parens.prototype.shouldParenthesize = function (){
			// no need to parenthesize if this is a line in a block
			if (this._noparen) { return false }; //  or par isa ArgList
			return true;
		};
		
		
		Parens.prototype.prebreak = function (br){
			Parens.__super__.prebreak.call(this,br);
			console.log("PREBREAK");
			if (this._value) { this._value.prebreak(br) };
			return this;
		};
		
		
		Parens.prototype.isExpressable = function (){
			return this._value.isExpressable();
		};
		
		Parens.prototype.consume = function (node){
			return this._value.consume(node);
		};
		
		
		// Could inherit from valueNode
		// an explicit expression-block (with parens) is somewhat different
		// can be used to return after an expression
		function ExpressionBlock(){ return ListNode.apply(this,arguments) };
		
		subclass$(ExpressionBlock,ListNode);
		exports.ExpressionBlock = ExpressionBlock; // export class 
		ExpressionBlock.prototype.c = function (){
			return this.map(function(item) { return item.c(); }).join(",");
		};
		
		ExpressionBlock.prototype.consume = function (node){
			return this.value().consume(node);
		};
		
		ExpressionBlock.prototype.addExpression = function (expr){
			// Need to take care of the splat here to.. hazzle
			if (expr.node() instanceof Assign) {
				// p "is assignment!"
				this.push(expr.left());
				// make this into a tuple instead
				// possibly fix this as well?!?
				return new TupleAssign('=',new Tuple(this.nodes()),expr.right());
			} else {
				this.push(expr);
			};
			return this;
		};
		
		
		
		// STATEMENTS
		
		function Return(v){
			this._traversed = false;
			this._value = (v instanceof ArgList) && v.count() == 1 ? (v.last()) : (v);
			// @prebreak = v and v.@prebreak
			// console.log "return?!? {v}",@prebreak
			// if v isa ArgList and v.count == 1
			return this;
		};
		
		subclass$(Return,Statement);
		exports.Return = Return; // export class 
		Return.prototype.value = function(v){ return this._value; }
		Return.prototype.setValue = function(v){ this._value = v; return this; };
		
		Return.prototype.visit = function (){
			if (this._value && this._value.traverse) { return this._value.traverse() };
		};
		
		Return.prototype.js = function (o){
			var v = this._value;
			
			if (v instanceof ArgList) {
				return ("return [" + v.c({expression: true}) + "]");
			} else if (v) {
				return ("return " + v.c({expression: true}));
			} else {
				return "return";
			};
		};
		
		Return.prototype.c = function (){
			if (!(this.value()) || this.value().isExpressable()) { return Return.__super__.c.apply(this,arguments) };
			// p "return must cascade into value".red
			return this.value().consume(this).c();
		};
		
		Return.prototype.consume = function (node){
			return this;
		};
		
		function ImplicitReturn(){ return Return.apply(this,arguments) };
		
		subclass$(ImplicitReturn,Return);
		exports.ImplicitReturn = ImplicitReturn; // export class 
		
		
		function GreedyReturn(){ return ImplicitReturn.apply(this,arguments) };
		
		subclass$(GreedyReturn,ImplicitReturn);
		exports.GreedyReturn = GreedyReturn; // export class 
		
		
		// cannot live inside an expression(!)
		function Throw(){ return Statement.apply(this,arguments) };
		
		subclass$(Throw,Statement);
		exports.Throw = Throw; // export class 
		Throw.prototype.js = function (o){
			return ("throw " + (this.value().c()));
		};
		
		Throw.prototype.consume = function (node){
			// ROADMAP should possibly consume to the value of throw and then throw?
			return this;
		};
		
		
		function LoopFlowStatement(lit,expr){
			this.setLiteral(lit);
			this.setExpression(expr); // && ArgList.new(expr) # really?
		};
		
		subclass$(LoopFlowStatement,Statement);
		exports.LoopFlowStatement = LoopFlowStatement; // export class 
		LoopFlowStatement.prototype.literal = function(v){ return this._literal; }
		LoopFlowStatement.prototype.setLiteral = function(v){ this._literal = v; return this; };
		LoopFlowStatement.prototype.expression = function(v){ return this._expression; }
		LoopFlowStatement.prototype.setExpression = function(v){ this._expression = v; return this; };
		
		LoopFlowStatement.prototype.visit = function (){
			if (this.expression()) { return this.expression().traverse() };
		};
		
		LoopFlowStatement.prototype.consume = function (node){
			// p "break/continue should consume?!"
			return this;
		};
		
		LoopFlowStatement.prototype.c = function (){
			if (!(this.expression())) { return LoopFlowStatement.__super__.c.apply(this,arguments) };
			// get up to the outer loop
			var _loop = STACK.up(Loop);
			// p "found loop?",_loop
			
			// need to fix the grammar for this. Right now it 
			// is like a fake call, but should only care about the first argument
			var expr = this.expression();
			
			if (_loop.catcher()) {
				expr = expr.consume(_loop.catcher());
				var copy = new this.constructor(this.literal());
				return new Block([expr,copy]).c();
			} else if (expr) {
				copy = new this.constructor(this.literal());
				return new Block([expr,copy]).c();
			} else {
				return LoopFlowStatement.__super__.c.apply(this,arguments);
			};
			// return "loopflow"
		};
		
		
		function BreakStatement(){ return LoopFlowStatement.apply(this,arguments) };
		
		subclass$(BreakStatement,LoopFlowStatement);
		exports.BreakStatement = BreakStatement; // export class 
		BreakStatement.prototype.js = function (o){
			return "break";
		};
		
		function ContinueStatement(){ return LoopFlowStatement.apply(this,arguments) };
		
		subclass$(ContinueStatement,LoopFlowStatement);
		exports.ContinueStatement = ContinueStatement; // export class 
		ContinueStatement.prototype.js = function (o){
			return "continue";
		};
		
		function DebuggerStatement(){ return Statement.apply(this,arguments) };
		
		subclass$(DebuggerStatement,Statement);
		exports.DebuggerStatement = DebuggerStatement; // export class 
		
		
		
		// PARAMS
		
		function Param(name,defaults,typ){
			// could have introduced bugs by moving back to identifier here
			this._traversed = false;
			this._name = name; // .value # this is an identifier(!)
			this._defaults = defaults;
			this._typ = typ;
			this._variable = null;
		};
		
		subclass$(Param,Node);
		exports.Param = Param; // export class 
		Param.prototype.name = function(v){ return this._name; }
		Param.prototype.setName = function(v){ this._name = v; return this; };
		Param.prototype.index = function(v){ return this._index; }
		Param.prototype.setIndex = function(v){ this._index = v; return this; };
		Param.prototype.defaults = function(v){ return this._defaults; }
		Param.prototype.setDefaults = function(v){ this._defaults = v; return this; };
		Param.prototype.splat = function(v){ return this._splat; }
		Param.prototype.setSplat = function(v){ this._splat = v; return this; };
		Param.prototype.variable = function(v){ return this._variable; }
		Param.prototype.setVariable = function(v){ this._variable = v; return this; };
		
		// what about object-params?
		
		Param.prototype.varname = function (){
			return this._variable ? (this._variable.c()) : (this.name());
		};
		
		Param.prototype.js = function (o){
			if (this._variable) { return this._variable.c() };
			
			if (this.defaults()) {
				// should not include any source-mapping here?
				return ("if(" + (this.name().c()) + " == null) " + (this.name().c()) + " = " + (this.defaults().c()));
			};
			// see if this is the initial declarator?
		};
		
		Param.prototype.visit = function (){
			var variable_, v_;
			if (this._defaults) { this._defaults.traverse() };
			(variable_ = this.variable()) || ((this.setVariable(v_ = this.scope__().register(this.name(),this)),v_));
			
			if (this._name instanceof Identifier) {
				// change type here?
				if (this._name._value) { this._name._value._type = "PARAMVAR" };
				this._name.references(this._variable);
				// console.log "got here!! {@name:constructor}"
				// @name.@token.@variable = @variable if @name.@token
			};
			
			return this;
		};
		
		Param.prototype.assignment = function (){
			return OP('=',this.variable().accessor(),this.defaults());
		};
		
		Param.prototype.isExpressable = function (){
			return !(this.defaults()) || this.defaults().isExpressable();
			// p "visiting param!!!"
		};
		
		Param.prototype.dump = function (){
			return {loc: this.loc()};
		};
		
		Param.prototype.loc = function (){
			return this._name && this._name.region();
		};
		
		Param.prototype.toJSON = function (){
			return {
				type: this.typeName(),
				name: this.name(),
				defaults: this.defaults()
			};
		};
		
		
		function SplatParam(){ return Param.apply(this,arguments) };
		
		subclass$(SplatParam,Param);
		exports.SplatParam = SplatParam; // export class 
		SplatParam.prototype.loc = function (){
			// hacky.. cannot know for sure that this is right?
			var r = this.name().region();
			return [r[0] - 1,r[1]];
		};
		
		function BlockParam(){ return Param.apply(this,arguments) };
		
		subclass$(BlockParam,Param);
		exports.BlockParam = BlockParam; // export class 
		BlockParam.prototype.c = function (){
			return "blockparam";
		};
		
		BlockParam.prototype.loc = function (){
			// hacky.. cannot know for sure that this is right?
			var r = this.name().region();
			return [r[0] - 1,r[1]];
		};
		
		
		function OptionalParam(){ return Param.apply(this,arguments) };
		
		subclass$(OptionalParam,Param);
		exports.OptionalParam = OptionalParam; // export class 
		
		
		function NamedParam(){ return Param.apply(this,arguments) };
		
		subclass$(NamedParam,Param);
		exports.NamedParam = NamedParam; // export class 
		
		
		function RequiredParam(){ return Param.apply(this,arguments) };
		
		subclass$(RequiredParam,Param);
		exports.RequiredParam = RequiredParam; // export class 
		
		
		function NamedParams(){ return ListNode.apply(this,arguments) };
		
		subclass$(NamedParams,ListNode);
		exports.NamedParams = NamedParams; // export class 
		NamedParams.prototype.index = function(v){ return this._index; }
		NamedParams.prototype.setIndex = function(v){ this._index = v; return this; };
		NamedParams.prototype.variable = function(v){ return this._variable; }
		NamedParams.prototype.setVariable = function(v){ this._variable = v; return this; };
		
		NamedParams.prototype.load = function (list){
			var load = function(k) { return new NamedParam(k.key(),k.value()); };
			return list instanceof Obj ? (list.value().map(load)) : (list);
		};
		
		NamedParams.prototype.visit = function (){
			var s = this.scope__();
			this._variable || (this._variable = s.temporary(this,{pool: 'keypars'}));
			this._variable.predeclared();
			
			// this is a listnode, which will automatically traverse
			// and visit all children
			NamedParams.__super__.visit.apply(this,arguments);
			// register the inner variables as well(!)
			return this;
		};
		
		
		NamedParams.prototype.varname = function (){
			return this.variable().c();
		};
		
		NamedParams.prototype.name = function (){
			return this.varname();
		};
		
		NamedParams.prototype.js = function (o){
			return "namedpar";
		};
		
		NamedParams.prototype.toJSON = function (){
			return {
				type: this.typeName(),
				nodes: this.filter(function(v) { return v instanceof NamedParam; })
			};
		};
		
		
		function IndexedParam(){ return Param.apply(this,arguments) };
		
		subclass$(IndexedParam,Param);
		exports.IndexedParam = IndexedParam; // export class 
		IndexedParam.prototype.parent = function(v){ return this._parent; }
		IndexedParam.prototype.setParent = function(v){ this._parent = v; return this; };
		IndexedParam.prototype.subindex = function(v){ return this._subindex; }
		IndexedParam.prototype.setSubindex = function(v){ this._subindex = v; return this; };
		
		IndexedParam.prototype.visit = function (){
			// p "VISIT PARAM {name}!"
			// ary.[-1] # possible
			// ary.(-1) # possible
			// str(/ok/,-1)
			// scope.register(@name,self)
			// BUG The defaults should probably be looked up like vars
			var variable_, v_;
			(variable_ = this.variable()) || ((this.setVariable(v_ = this.scope__().register(this.name(),this)),v_));
			this.variable().proxy(this.parent().variable(),this.subindex());
			return this;
		};
		
		
		function ArrayParams(){ return ListNode.apply(this,arguments) };
		
		subclass$(ArrayParams,ListNode);
		exports.ArrayParams = ArrayParams; // export class 
		ArrayParams.prototype.index = function(v){ return this._index; }
		ArrayParams.prototype.setIndex = function(v){ this._index = v; return this; };
		ArrayParams.prototype.variable = function(v){ return this._variable; }
		ArrayParams.prototype.setVariable = function(v){ this._variable = v; return this; };
		
		ArrayParams.prototype.visit = function (){
			var s = this.scope__();
			this._variable || (this._variable = s.temporary(this,{pool: 'keypars'}));
			this._variable.predeclared();
			
			// now when we loop through these inner params - we create the pars
			// with the correct name, but bind them to the parent
			return ArrayParams.__super__.visit.apply(this,arguments);
		};
		
		ArrayParams.prototype.name = function (){
			return this.variable().c();
		};
		
		ArrayParams.prototype.load = function (list){
			var self = this;
			if (!((list instanceof Arr))) { return null };
			// p "loading arrayparams"
			// try the basic first
			if (!list.splat()) {
				return list.value().map(function(v,i) {
					// must make sure the params are supported here
					// should really not parse any array at all(!)
					var name = v;
					if (v instanceof VarOrAccess) {
						// p "varoraccess {v.value}"
						// FIX?
						name = v.value().value();
						// this is accepted
					};
					return self.parse(name,v,i);
				});
			};
		};
		
		ArrayParams.prototype.parse = function (name,child,i){
			var param = new IndexedParam(name,null);
			
			param.setParent(this);
			param.setSubindex(i);
			return param;
		};
		
		ArrayParams.prototype.head = function (ast){
			// "arrayparams"
			return this;
		};
		
		function ParamList(){ return ListNode.apply(this,arguments) };
		
		subclass$(ParamList,ListNode);
		exports.ParamList = ParamList; // export class 
		ParamList.prototype.splat = function(v){ return this._splat; }
		ParamList.prototype.setSplat = function(v){ this._splat = v; return this; };
		ParamList.prototype.block = function(v){ return this._block; }
		ParamList.prototype.setBlock = function(v){ this._block = v; return this; };
		
		ParamList.prototype.at = function (index,force,name){
			if(force === undefined) force = false;
			if(name === undefined) name = null;
			if (force) {
				while (this.count() <= index){
					this.add(new Param(this.count() == index && name || ("_" + this.count())));
				};
				// need to visit at the same time, no?
			};
			return this.list()[index];
		};
		
		ParamList.prototype.metadata = function (){
			return this.filter(function(par) { return !(par instanceof Meta); });
		};
		
		ParamList.prototype.toJSON = function (){
			return this.metadata();
		};
		
		ParamList.prototype.visit = function (){
			this._splat = this.filter(function(par) { return par instanceof SplatParam; })[0];
			var blk = this.filter(function(par) { return par instanceof BlockParam; });
			
			if (blk.length > 1) {
				blk[1].warn("a method can only have one &block parameter");
			} else if (blk[0] && blk[0] != this.last()) {
				blk[0].warn("&block must be the last parameter of a method");
				// warn "&block must be the last parameter of a method", blk[0]
			};
			
			// add more warnings later(!)
			// should probably throw error as well to stop compilation
			
			// need to register the required-pars as variables
			return ParamList.__super__.visit.apply(this,arguments);
		};
		
		ParamList.prototype.js = function (o){
			if (this.count() == 0) { return EMPTY };
			if (o.parent() instanceof Block) { return this.head(o) };
			
			// items = map(|arg| arg.name.c ).compact
			// return null unless items[0]
			
			if (o.parent() instanceof Code) {
				// remove the splat, for sure.. need to handle the other items as well
				// this is messy with references to argvars etc etc. Fix
				var pars = this.nodes();
				// pars = filter(|arg| arg != @splat && !(arg isa BlockParam)) if @splat
				if (this._splat) { pars = this.filter(function(arg) { return (arg instanceof RequiredParam) || (arg instanceof OptionalParam); }) };
				return compact__(pars.map(function(arg) { return c__(arg.varname()); })).join(",");
			} else {
				throw "not implemented paramlist js";
				return "ta" + compact__(this.map(function(arg) { return arg.c(); })).join(",");
			};
		};
		
		ParamList.prototype.head = function (o){
			var reg = [];
			var opt = [];
			var blk = null;
			var splat = null;
			var named = null;
			var arys = [];
			var signature = [];
			var idx = 0;
			
			this.nodes().forEach(function(par,i) {
				par.setIndex(idx);
				if (par instanceof NamedParams) {
					signature.push('named');
					named = par;
				} else if (par instanceof OptionalParam) {
					signature.push('opt');
					opt.push(par);
				} else if (par instanceof BlockParam) {
					signature.push('blk');
					blk = par;
				} else if (par instanceof SplatParam) {
					signature.push('splat');
					splat = par;
					idx -= 1; // this should really be removed from the list, no?
				} else if (par instanceof ArrayParams) {
					arys.push(par);
					signature.push('ary');
				} else {
					signature.push('reg');
					reg.push(par);
				};
				return idx++;
			});
			
			if (named) {
				var namedvar = named.variable();
			};
			
			// var opt = nodes.filter(|n| n isa OptionalParam)
			// var blk = nodes.filter(|n| n isa BlockParam)[0]
			// var splat = nodes.filter(|n| n isa SplatParam)[0]
			
			// simple situation where we simply switch
			// can probably optimize by not looking at arguments at all
			var ast = [];
			var isFunc = function(js) { return ("typeof " + js + " == 'function'"); };
			
			// This is broken when dealing with iframes anc XSS scripting
			// but for now it is the best test for actual arguments
			// can also do constructor.name == 'Object'
			var isObj = function(js) { return ("" + js + ".constructor === Object"); };
			var isntObj = function(js) { return ("" + js + ".constructor !== Object"); };
			// should handle some common cases in a cleaner (less verbose) manner
			// does this work with default params after optional ones? Is that even worth anything?
			// this only works in one direction now, unlike TupleAssign
			
			// we dont really check the length etc now -- so it is buggy for lots of arguments
			
			// if we have optional params in the regular order etc we can go the easy route
			// slightly hacky now. Should refactor all of these to use the signature?
			if (!(named) && !(splat) && !(blk) && opt.length > 0 && signature.join(" ").match(/opt$/)) {
				for (var i = 0, len_ = opt.length, par; i < len_; i++) {
					par = opt[i];
					ast.push(("if(" + (par.name().c()) + " === undefined) " + (par.name().c()) + " = " + (par.defaults().c())));
				};
			} else if (named && !(splat) && !(blk) && opt.length == 0) { // and no block?!
				// different shorthands
				// if named
				ast.push(("if(!" + (namedvar.c()) + "||" + isntObj(namedvar.c()) + ") " + (namedvar.c()) + " = \{\}"));
			} else if (blk && opt.length == 1 && !(splat) && !(named)) {
				var op = opt[0];
				var opn = op.name().c();
				var bn = blk.name().c();
				ast.push(("if(" + bn + "==undefined && " + isFunc(opn) + ") " + bn + " = " + opn + "," + opn + " = " + (op.defaults().c())));
				ast.push(("if(" + opn + "==undefined) " + opn + " = " + (op.defaults().c())));
			} else if (blk && named && opt.length == 0 && !(splat)) {
				bn = blk.name().c();
				ast.push(("if(" + bn + "==undefined && " + isFunc(namedvar.c()) + ") " + bn + " = " + (namedvar.c()) + "," + (namedvar.c()) + " = \{\}"));
				ast.push(("else if(!" + (namedvar.c()) + "||" + isntObj(namedvar.c()) + ") " + (namedvar.c()) + " = \{\}"));
			} else if (opt.length > 0 || splat) { // && blk  # && !splat
				
				var argvar = this.scope__().temporary(this,{pool: 'arguments'}).predeclared().c();
				var len = this.scope__().temporary(this,{pool: 'counter'}).predeclared().c();
				
				var last = ("" + argvar + "[" + len + "-1]");
				var pop = ("" + argvar + "[--" + len + "]");
				ast.push(("var " + argvar + " = arguments, " + len + " = " + argvar + ".length"));
				
				if (blk) {
					bn = blk.name().c();
					if (splat) {
						ast.push(("var " + bn + " = " + isFunc(last) + " ? " + pop + " : null"));
					} else if (reg.length > 0) {
						// ast.push "// several regs really?"
						ast.push(("var " + bn + " = " + len + " > " + (reg.length) + " && " + isFunc(last) + " ? " + pop + " : null"));
					} else {
						ast.push(("var " + bn + " = " + isFunc(last) + " ? " + pop + " : null"));
					};
				};
				
				// if we have named params - look for them before splat
				// should probably loop through pars in the same order they were added
				// should it be prioritized above optional objects??
				if (named) {
					// should not include it when there is a splat?
					ast.push(("var " + (namedvar.c()) + " = " + last + "&&" + isObj(last) + " ? " + pop + " : \{\}"));
				};
				
				for (var i1 = 0, len_ = opt.length, par1; i1 < len_; i1++) {
					par1 = opt[i1];
					ast.push(("if(" + len + " < " + (par1.index() + 1) + ") " + (par1.name().c()) + " = " + (par1.defaults().c())));
				};
				
				// add the splat
				if (splat) {
					var sn = splat.name().c();
					var si = splat.index();
					
					if (si == 0) {
						ast.push(("var " + sn + " = new Array(" + len + ">" + si + " ? " + len + " : 0)"));
						ast.push(("while(" + len + ">" + si + ") " + sn + "[" + len + "-1] = " + pop));
					} else {
						ast.push(("var " + sn + " = new Array(" + len + ">" + si + " ? " + len + "-" + si + " : 0)"));
						ast.push(("while(" + len + ">" + si + ") " + sn + "[--" + len + " - " + si + "] = " + argvar + "[" + len + "]"));
					};
				};
				
				// if named
				// 	for k,i in named.nodes
				// 		# OP('.',namedvar) <- this is the right way, with invalid names etc
				// 		var op = OP('.',namedvar,k.key).c
				// 		ast.push "var {k.key.c} = {op} !== undefined ? {op} : {k.value.c}"
				
				// if named
				
				// return ast.join(";\n") + ";"
				// return "if({opt[0].name.c} instanceof Function) {blk.c} = {opt[0].c};"
			} else if (opt.length > 0) {
				for (var i2 = 0, len_ = opt.length, par2; i2 < len_; i2++) {
					par2 = opt[i2];
					ast.push(("if(" + (par2.name().c()) + " === undefined) " + (par2.name().c()) + " = " + (par2.defaults().c())));
				};
			};
			
			// now set stuff if named params(!)
			
			if (named) {
				for (var i3 = 0, ary = iter$(named.nodes()), len_ = ary.length, k; i3 < len_; i3++) {
					// console.log "named var {k.c}"
					k = ary[i3];
					op = OP('.',namedvar,k.c()).c();
					ast.push(("var " + (k.c()) + " = " + op + " !== undefined ? " + op + " : " + (k.defaults().c())));
				};
			};
			
			if (arys.length) {
				for (var i4 = 0, len_ = arys.length; i4 < len_; i4++) {
					// create tuples
					// p "adding arrayparams"
					arys[i4].head(o,ast,this);
					// ast.push v.c
				};
			};
			
			
			
			// if opt:length == 0
			return ast.length > 0 ? ((ast.join(";\n") + ";")) : (EMPTY);
		};
		
		
		// Legacy. Should move away from this?
		function VariableDeclaration(){ return ListNode.apply(this,arguments) };
		
		subclass$(VariableDeclaration,ListNode);
		exports.VariableDeclaration = VariableDeclaration; // export class 
		VariableDeclaration.prototype.kind = function(v){ return this._kind; }
		VariableDeclaration.prototype.setKind = function(v){ this._kind = v; return this; };
		
		// we want to register these variables in
		VariableDeclaration.prototype.add = function (name,init,pos){
			if(pos === undefined) pos = -1;
			var vardec = new VariableDeclarator(name,init);
			if (name instanceof Variable) { (vardec.setVariable(name),name) };
			pos == 0 ? (this.unshift(vardec)) : (this.push(vardec));
			return vardec;
			
			// TODO (target) << (node) rewrites to a caching push which returns node
		};
		
		// def remove item
		// 	if item isa Variable
		// 		map do |v,i|
		// 			if v.variable == item
		// 				p "found variable to remove"
		// 				super.remove(v)
		// 	else
		// 		super.remove(item)
		// 	self
		
		VariableDeclaration.prototype.load = function (list){
			// temporary solution!!!
			return list.map(function(par) { return new VariableDeclarator(par.name(),par.defaults(),par.splat()); });
		};
		
		VariableDeclaration.prototype.isExpressable = function (){
			return this.nodes().every(function(item) { return item.isExpressable(); });
		};
		
		VariableDeclaration.prototype.js = function (o){
			if (this.count() == 0) { return EMPTY };
			
			if (this.count() == 1 && !(this.isExpressable())) {
				// p "SHOULD ALTER VARDEC!!!".cyan
				this.first().variable().autodeclare();
				var node = this.first().assignment();
				return node.c();
			};
			
			// FIX PERFORMANCE
			var out = compact__(cary__(this.nodes())).join(", ");
			return out ? (("var " + out)) : ("");
			// "var " + compact__(cary__(nodes)).join(", ") + ""
		};
		
		function VariableDeclarator(){ return Param.apply(this,arguments) };
		
		subclass$(VariableDeclarator,Param);
		exports.VariableDeclarator = VariableDeclarator; // export class 
		VariableDeclarator.prototype.visit = function (){
			// even if we should traverse the defaults as if this variable does not exist
			// we need to preregister it and then activate it later
			var variable_, v_;
			(variable_ = this.variable()) || ((this.setVariable(v_ = this.scope__().register(this.name(),null)),v_));
			if (this.defaults()) { this.defaults().traverse() };
			// WARN what if it is already declared?
			this.variable().setDeclarator(this);
			this.variable().addReference(this.name());
			return this;
		};
		
		// needs to be linked up to the actual scoped variables, no?
		VariableDeclarator.prototype.js = function (o){
			if (this.variable()._proxy) { return null };
			
			var defs = this.defaults();
			// FIXME need to deal with var-defines within other statements etc
			// FIXME need better syntax for this
			if (defs != null && defs != undefined) {
				// console.log "defaults is {defaults}"
				if (defs instanceof Node) { defs = defs.c({expression: true}) };
				
				return ("" + (this.variable().c()) + " = " + defs);
			} else {
				return ("" + (this.variable().c()));
			};
		};
		
		VariableDeclarator.prototype.accessor = function (){
			return this;
		};
		
		
		// TODO clean up and refactor all the different representations of vars
		// VarName, VarReference, LocalVarAccess?
		function VarName(a,b){
			VarName.__super__.constructor.apply(this,arguments);
			this._splat = b;
		};
		
		subclass$(VarName,ValueNode);
		exports.VarName = VarName; // export class 
		VarName.prototype.variable = function(v){ return this._variable; }
		VarName.prototype.setVariable = function(v){ this._variable = v; return this; };
		VarName.prototype.splat = function(v){ return this._splat; }
		VarName.prototype.setSplat = function(v){ this._splat = v; return this; };
		
		VarName.prototype.visit = function (){
			// p "visiting varname(!)", value.c
			// should we not lookup instead?
			// FIXME p "register value {value.c}"
			var variable_, v_;
			(variable_ = this.variable()) || ((this.setVariable(v_ = this.scope__().register(this.value().c(),null)),v_));
			this.variable().setDeclarator(this);
			this.variable().addReference(this.value());
			return this;
		};
		
		VarName.prototype.js = function (o){
			return this.variable().c();
		};
		
		VarName.prototype.c = function (){
			return this.variable().c();
		};
		
		
		function VarList(t,l,r){
			this._traversed = false;
			this._type = this.type();
			this._left = l;
			this._right = r;
		};
		
		subclass$(VarList,Node);
		exports.VarList = VarList; // export class 
		VarList.prototype.type = function(v){ return this._type; }
		VarList.prototype.setType = function(v){ this._type = v; return this; }; // let / var / const
		VarList.prototype.left = function(v){ return this._left; }
		VarList.prototype.setLeft = function(v){ this._left = v; return this; };
		VarList.prototype.right = function(v){ return this._right; }
		VarList.prototype.setRight = function(v){ this._right = v; return this; };
		
		// format :type, :left, :right
		
		// should throw error if there are more values on right than left
		
		VarList.prototype.visit = function (){
			
			// we need to carefully traverse children in the right order
			// since we should be able to reference
			var r;
			for (var i = 0, ary = iter$(this.left()), len = ary.length; i < len; i++) {
				ary[i].traverse(); // this should really be a var-declaration
				if (r = this.right()[i]) { r.traverse() };
			};
			return this;
		};
		
		VarList.prototype.js = function (o){
			// for the regular items 
			var pairs = [];
			var ll = this.left().length;
			var rl = this.right().length;
			var v = null;
			
			// splatting here we come
			if (ll > 1 && rl == 1) {
				this.p("multiassign!");
				var r = this.right()[0];
				r.cache();
				for (var i = 0, ary = iter$(this.left()), len = ary.length, l; i < len; i++) {
					l = ary[i];
					if (l.splat()) {
						throw "not supported?";
						this.p("splat"); // FIX reimplement slice?
						if (i == ll - 1) {
							v = this.util().slice(r,i);
							this.p("last");
						} else {
							v = this.util().slice(r,i,-(ll - i) + 1);
						};
					} else {
						v = OP('.',r,num__(i));
					};
					
					pairs.push(OP('=',l,v));
				};
			} else {
				for (var i1 = 0, ary = iter$(this.left()), len = ary.length, l1; i1 < len; i1++) {
					l1 = ary[i1];
					r = this.right()[i1];
					pairs.push(r ? (OP('=',l1.variable().accessor(),r)) : (l1));
				};
			};
			
			return ("var " + (pairs.c()));
		};
		
		
		// CODE
		
		function Code(){ return Node.apply(this,arguments) };
		
		subclass$(Code,Node);
		exports.Code = Code; // export class 
		Code.prototype.head = function(v){ return this._head; }
		Code.prototype.setHead = function(v){ this._head = v; return this; };
		Code.prototype.body = function(v){ return this._body; }
		Code.prototype.setBody = function(v){ this._body = v; return this; };
		Code.prototype.scope = function(v){ return this._scope; }
		Code.prototype.setScope = function(v){ this._scope = v; return this; };
		Code.prototype.params = function(v){ return this._params; }
		Code.prototype.setParams = function(v){ this._params = v; return this; };
		
		Code.prototype.scopetype = function (){
			return Scope;
		};
		
		Code.prototype.visit = function (){
			if (this._scope) { this._scope.visit() };
			// @scope.parent = STACK.scope(1) if @scope
			return this;
		};
		
		
		// Rename to Program?
		function Root(body,opts){
			// p "create root!"
			this._traversed = false;
			this._body = blk__(body);
			this._scope = new RootScope(this,null);
			this._options = {};
		};
		
		subclass$(Root,Code);
		exports.Root = Root; // export class 
		Root.prototype.visit = function (){
			ROOT = STACK.ROOT = this._scope;
			this.scope().visit();
			return this.body().traverse();
		};
		
		Root.prototype.compile = function (o){
			STACK.reset(); // -- nested compilation does not work now
			OPTS = STACK._options = this._options = o || {};
			
			this.traverse();
			
			var out = this.c();
			var result = {
				js: out,
				ast: this,
				warnings: this.scope().warnings(),
				options: o,
				toString: function() { return this.js; }
			};
			if (o.sourceMapInline || o.sourceMap) {
				result.sourcemap = new SourceMap(result).generate();
			};
			
			return result;
		};
		
		Root.prototype.js = function (o){
			var out;
			if (this._options.bare) {
				out = this.scope().c();
			} else {
				this.body().consume(new ImplicitReturn());
				out = this.scope().c({indent: true});
				out = out.replace(/^\n?/,'\n');
				out = out.replace(/\n?$/,'\n\n');
				out = '(function(){' + out + '})()';
			};
			
			// find and replace shebangs
			var shebangs = [];
			out = out.replace(/^[ \t]*\/\/(\!.+)$/mg,function(m,shebang) {
				// p "found shebang {shebang}"
				shebang = shebang.replace(/\bimba\b/g,'node');
				shebangs.push(("#" + shebang + "\n"));
				return "";
			});
			
			out = shebangs.join('') + out;
			
			return out;
		};
		
		
		Root.prototype.analyze = function (pars){
			if(!pars||pars.constructor !== Object) pars = {};
			var loglevel = pars.loglevel !== undefined ? pars.loglevel : 0;
			var entities = pars.entities !== undefined ? pars.entities : false;
			var scopes = pars.scopes !== undefined ? pars.scopes : true;
			STACK.setLoglevel(loglevel);
			STACK._analyzing = true;
			ROOT = STACK.ROOT = this._scope;
			
			OPTS = {
				analysis: {
					entities: entities,
					scopes: scopes
				}
			};
			
			this.traverse();
			STACK._analyzing = false;
			
			return this.scope().dump();
		};
		
		Root.prototype.inspect = function (){
			return true;
		};
		
		function ClassDeclaration(name,superclass,body){
			// what about the namespace?
			this._traversed = false;
			this._name = name;
			this._superclass = superclass;
			this._scope = new ClassScope(this);
			this._body = blk__(body);
			this;
		};
		
		subclass$(ClassDeclaration,Code);
		exports.ClassDeclaration = ClassDeclaration; // export class 
		ClassDeclaration.prototype.name = function(v){ return this._name; }
		ClassDeclaration.prototype.setName = function(v){ this._name = v; return this; };
		ClassDeclaration.prototype.superclass = function(v){ return this._superclass; }
		ClassDeclaration.prototype.setSuperclass = function(v){ this._superclass = v; return this; };
		ClassDeclaration.prototype.initor = function(v){ return this._initor; }
		ClassDeclaration.prototype.setInitor = function(v){ this._initor = v; return this; };
		
		ClassDeclaration.prototype.consume = function (node){
			if (node instanceof Return) {
				this.option('return',true);
				return this;
			};
			return ClassDeclaration.__super__.consume.apply(this,arguments);
		};
		
		ClassDeclaration.prototype.namepath = function (){
			return this._namepath || (this._namepath = ("" + (this.name().c())));
		};
		
		ClassDeclaration.prototype.metadata = function (){
			var superclass_;
			return {
				type: 'class',
				namepath: this.namepath(),
				inherits: (superclass_ = this.superclass()) && superclass_.namepath  &&  superclass_.namepath(),
				path: this.name().c().toString(),
				desc: this._desc,
				loc: this.loc()
			};
		};
		
		ClassDeclaration.prototype.toJSON = function (){
			return this.metadata();
		};
		
		ClassDeclaration.prototype.visit = function (){
			// replace with some advanced lookup?
			ROOT.entities().add(this.namepath(),this);
			this.scope().visit();
			this.body().traverse();
			return this;
		};
		
		ClassDeclaration.prototype.js = function (o){
			this.scope().virtualize(); // is this always needed?
			this.scope().context().setValue(this.name());
			
			// should probably also warn about stuff etc
			if (this.option('extension')) {
				return this.body().c();
			};
			
			var head = [];
			var o = this._options || {};
			var cname = this.name() instanceof Access ? (this.name().right()) : (this.name());
			var namespaced = this.name() != cname;
			var initor = null;
			var sup = this.superclass();
			
			var bodyindex = -1;
			var spaces = this.body().filter(function(item) { return item instanceof Terminator; });
			var mark = mark__(this.option('keyword'));
			
			this.body().map(function(c,i) {
				if ((c instanceof MethodDeclaration) && c.type() == 'constructor') {
					return bodyindex = i;
				};
			});
			
			if (bodyindex >= 0) {
				initor = this.body().removeAt(bodyindex);
			};
			
			// var initor = body.pluck do |c| c isa MethodDeclaration && c.type == :constructor
			// compile the cname
			if (typeof cname != 'string') { cname = cname.c() };
			
			var cpath = typeof this.name() == 'string' ? (this.name()) : (this.name().c());
			
			if (!(initor)) {
				if (sup) {
					initor = ("" + mark + "function " + cname + "()\{ return " + (sup.c()) + ".apply(this,arguments) \};\n\n");
				} else {
					initor = ("" + mark + "function " + cname + "()") + '{ };\n\n';
				};
			} else {
				initor.setName(cname);
				initor = initor.c() + ';';
			};
			
			// if we are defining a class inside a namespace etc -- how should we set up the class?
			
			if (namespaced) {
				// should use Nodes to build this instead
				initor = ("" + cpath + " = " + initor); // OP('=',name,initor)
			};
			
			head.push(initor); // // @class {cname}\n
			
			if (bodyindex >= 0) {
				// add the space after initor?
				if (this.body().index(bodyindex) instanceof Terminator) {
					head.push(this.body().removeAt(bodyindex));
				};
			} else {
				// head.push(Terminator.new('\n\n'))
				true;
			};
			
			
			
			if (sup) {
				// console.log "deal with superclass!"
				// head.push("// extending the superclass\nimba$class({name.c},{sup.c});\n\n")
				head.push(new Util.Subclass([this.name(),sup]));
			};
			
			// only if it is not namespaced
			if (o.global && !(namespaced)) { // option(:global)
				head.push(("global." + cname + " = " + cpath + "; // global class \n"))
			};
			
			if (o.export && !(namespaced)) {
				head.push(("exports." + cname + " = " + cpath + "; // export class \n"))
			};
			
			// FIXME
			// if namespaced and (o:local or o:export)
			// 	console.log "namespaced classes are implicitly local/global depending on the namespace"
			
			if (this.option('return')) {
				this.body().push(("return " + cpath + ";"));
			};
			
			for (var i = 0, ary = iter$(head.reverse()), len = ary.length; i < len; i++) {
				this.body().unshift(ary[i]);
			};
			this.body()._indentation = null;
			var end = this.body().index(this.body().count() - 1);
			if ((end instanceof Terminator) && end.c().length == 1) { this.body().pop() };
			
			var out = this.body().c();
			
			return out;
		};
		
		
		function TagDeclaration(name,superclass,body){
			// what about the namespace?
			// @name = TagTypeRef.new(name)
			this._traversed = false;
			this._name = name;
			this._superclass = superclass;
			this._scope = new TagScope(this);
			this._body = blk__(body || []);
		};
		
		subclass$(TagDeclaration,Code);
		exports.TagDeclaration = TagDeclaration; // export class 
		TagDeclaration.prototype.name = function(v){ return this._name; }
		TagDeclaration.prototype.setName = function(v){ this._name = v; return this; };
		TagDeclaration.prototype.superclass = function(v){ return this._superclass; }
		TagDeclaration.prototype.setSuperclass = function(v){ this._superclass = v; return this; };
		TagDeclaration.prototype.initor = function(v){ return this._initor; }
		TagDeclaration.prototype.setInitor = function(v){ this._initor = v; return this; };
		
		TagDeclaration.prototype.namepath = function (){
			return ("<" + this.name() + ">");
		};
		
		TagDeclaration.prototype.toJSON = function (){
			return {
				type: 'tag',
				namepath: this.namepath(),
				inherits: this.superclass() ? (("<" + (this.superclass().name()) + ">")) : (null),
				loc: this.loc(),
				desc: this._desc
			};
		};
		
		TagDeclaration.prototype.visit = function (){
			ROOT.entities().register(this); // what if this is not local?
			
			for (var i = 0, ary = iter$(STACK.scopes()), len = ary.length, scope; i < len; i++) {
				scope = ary[i];
				if (i > 0 && (scope instanceof TagScope)) {
					// register inside here?
					scope.node().option('hasLocalTags',true);
					this.option('parent',scope.node());
					break;
					// console.log "tag is local!!!"
				};
			};
			// replace with some advanced lookup?
			this.scope().visit();
			return this.body().traverse();
		};
		
		TagDeclaration.prototype.id = function (){
			return this.name().id();
		};
		
		TagDeclaration.prototype.tagspace = function (){
			var ctx = this.scope().closure().tagContextPath();
			return this.name().ns() ? (("" + ctx + "." + (this.name().ns().toUpperCase()))) : (ctx);
		};
		
		TagDeclaration.prototype.js = function (o){
			this.scope().context().setValue(this._ctx = this.scope().declare('tag',null,{system: true}));
			
			var ns = this.name().ns();
			var mark = mark__(this.option('keyword'));
			
			var params = [helpers.singlequote(this.name().name())];
			var cbody = this.body().c();
			// var outbody = body.count ? ", function({@ctx.c})\{{cbody}\}" : ''
			
			if (this.superclass()) {
				// WARN what if the superclass has a namespace?
				params.push(helpers.singlequote(this.superclass().name()));
			};
			
			if (this.body().count()) {
				if (this.option('hasLocalTags')) {
					params.push(("function(" + (this._ctx.c()) + "," + (this.scope().closure().tagContextPath()) + ")\{" + cbody + "\}"));
				} else {
					params.push(("function(" + (this._ctx.c()) + ")\{" + cbody + "\}"));
				};
			};
			
			var meth = this.option('extension') ? ('extendTag') : ('defineTag');
			// return "{mark}{tagspace}.extendTag('{name.name}'{outbody})"
			
			// var sup = superclass and "," + helpers.singlequote(superclass.func) or ""
			
			// var out = if name.id
			//	"{mark}{tagspace}.defineSingleton('{name.name}'{sup}{outbody})"
			// else
			
			return ("" + mark + this.tagspace() + "." + meth + "(" + params.join(', ') + ")");
			
			// return out
		};
		
		function Func(params,body,name,target,o){
			// p "INIT Function!!",params,body,name
			var typ = this.scopetype();
			this._traversed = false;
			this._body = blk__(body);
			this._scope || (this._scope = (o && o.scope) || new typ(this));
			this._scope.setParams(this._params = new ParamList(params));
			this._name = name || '';
			this._target = target;
			this._options = o;
			this._type = 'function';
			this._variable = null;
			this;
		};
		
		subclass$(Func,Code);
		exports.Func = Func; // export class 
		Func.prototype.name = function(v){ return this._name; }
		Func.prototype.setName = function(v){ this._name = v; return this; };
		Func.prototype.params = function(v){ return this._params; }
		Func.prototype.setParams = function(v){ this._params = v; return this; };
		Func.prototype.target = function(v){ return this._target; }
		Func.prototype.setTarget = function(v){ this._target = v; return this; };
		Func.prototype.options = function(v){ return this._options; }
		Func.prototype.setOptions = function(v){ this._options = v; return this; };
		Func.prototype.type = function(v){ return this._type; }
		Func.prototype.setType = function(v){ this._type = v; return this; };
		Func.prototype.context = function(v){ return this._context; }
		Func.prototype.setContext = function(v){ this._context = v; return this; };
		
		Func.prototype.scopetype = function (){
			return FunctionScope;
		};
		
		Func.prototype.visit = function (){
			this.scope().visit();
			this._context = this.scope().parent();
			this._params.traverse();
			return this._body.traverse(); // so soon?
		};
		
		
		Func.prototype.js = function (o){
			if (!this.option('noreturn')) { this.body().consume(new ImplicitReturn()) };
			var ind = this.body()._indentation;
			// var s = ind and ind.@open
			// p "indent function? {body.@indentation} {s} {s:generated} {body.count}"
			if (ind && ind.isGenerated()) { this.body()._indentation = null };
			var code = this.scope().c({indent: (!(ind) || !ind.isGenerated()),braces: true});
			
			// args = params.map do |par| par.name
			// head = params.map do |par| par.c
			// code = [head,body.c(expression: no)].flatten__.compact.join("\n").wrap
			// FIXME creating the function-name this way is prone to create naming-collisions
			// will need to wrap the value in a FunctionName which takes care of looking up scope
			// and possibly dealing with it
			var name = typeof this._name == 'string' ? (this._name) : (this._name.c());
			name = name ? (' ' + name.replace(/\./g,'_')) : ('');
			var out = ("function" + name + "(" + (this.params().c()) + ") ") + code;
			if (this.option('eval')) { out = ("(" + out + ")()") };
			return out;
		};
		
		Func.prototype.shouldParenthesize = function (par){
			if(par === undefined) par = this.up();
			return (par instanceof Call) && par.callee() == this;
			// if up as a call? Only if we are 
		};
		
		function Lambda(){ return Func.apply(this,arguments) };
		
		subclass$(Lambda,Func);
		exports.Lambda = Lambda; // export class 
		Lambda.prototype.scopetype = function (){
			return LambdaScope;
		};
		
		function TagFragmentFunc(){ return Func.apply(this,arguments) };
		
		subclass$(TagFragmentFunc,Func);
		exports.TagFragmentFunc = TagFragmentFunc; // export class 
		
		
		// MethodDeclaration
		// Create a shared body?
		
		function MethodDeclaration(){ return Func.apply(this,arguments) };
		
		subclass$(MethodDeclaration,Func);
		exports.MethodDeclaration = MethodDeclaration; // export class 
		MethodDeclaration.prototype.variable = function(v){ return this._variable; }
		MethodDeclaration.prototype.setVariable = function(v){ this._variable = v; return this; };
		
		MethodDeclaration.prototype.scopetype = function (){
			return MethodScope;
		};
		
		MethodDeclaration.prototype.consume = function (node){
			if (node instanceof Return) {
				this.option('return',true);
				return this;
			};
			return MethodDeclaration.__super__.consume.apply(this,arguments);
		};
		
		MethodDeclaration.prototype.metadata = function (){
			return {
				type: "method",
				name: "" + this.name(),
				namepath: this.namepath(),
				params: this._params.metadata(),
				desc: this._desc,
				scopenr: this.scope()._nr,
				loc: this.loc()
			};
		};
		
		MethodDeclaration.prototype.loc = function (){
			var d;
			if (d = this.option('def')) {
				return [d._loc,this.body().loc()[1]];
			} else {
				return [0,0];
			};
		};
		
		
		MethodDeclaration.prototype.toJSON = function (){
			return this.metadata();
		};
		
		MethodDeclaration.prototype.namepath = function (){
			if (this._namepath) { return this._namepath };
			
			var name = String(this.name());
			var sep = (this.option('static') ? ('.') : ('#'));
			if (this.target()) {
				return this._namepath = this._target.namepath() + sep + name;
			} else {
				return this._namepath = '&' + name;
			};
		};
		
		MethodDeclaration.prototype.visit = function (){
			// @desc = stack.stash.pluck(Comment)
			// @desc = stack.stash.pluck(Comment)
			// prebreak # make sure this has a break?
			this.scope().visit();
			
			if (String(this.name()) == 'initialize') {
				this.setType('constructor');
			};
			
			if (this.option('greedy')) {
				this.warn("deprecated");
				// set(greedy: true)
				// p "BODY EXPRESSIONS!! This is a fragment"
				var tree = new TagTree();
				this._body = this.body().consume(tree);
				// body.nodes = [Arr.new(body.nodes)]
			};
			
			this._context = this.scope().parent().closure();
			this._params.traverse();
			
			if (this.target() instanceof Self) {
				this._target = this._context.context();
				this.set({static: true});
			};
			
			if (this.context() instanceof ClassScope) {
				this.context().annotate(this);
				this._target || (this._target = this.context().context());
				// register as class-method?
				// should register for this
				// console.log "context is classscope {@name}"
			};
			
			if (!this._target) {
				// should not be registered on the outermost closure?
				this._variable = this.context().register(this.name(),this,{type: 'meth'});
			};
			
			ROOT.entities().add(this.namepath(),this);
			this._body.traverse(); // so soon?
			return this;
		};
		
		MethodDeclaration.prototype.supername = function (){
			return this.type() == 'constructor' ? (this.type()) : (this.name());
		};
		
		
		// FIXME export global etc are NOT valid for methods inside any other scope than
		// the outermost scope (root)
		
		MethodDeclaration.prototype.js = function (o){
			// FIXME Do this in the grammar - remnants of old implementation
			if (!(this.type() == 'constructor' || this.option('noreturn'))) {
				if (this.option('greedy')) {
					// haaack
					this.body().consume(new GreedyReturn());
				} else {
					this.body().consume(new ImplicitReturn());
				};
			};
			
			var code = this.scope().c({indent: true,braces: true});
			
			// same for Func -- should generalize
			var name = typeof this._name == 'string' ? (this._name) : (this._name.c());
			name = name.replace(/\./g,'_');
			
			// var name = self.name.c.replace(/\./g,'_') # WHAT?
			var foot = [];
			
			var left = "";
			var func = ("(" + (this.params().c()) + ")") + code; // .wrap
			var target = this.target();
			var decl = !this.option('global') && !this.option('export');
			
			if (target instanceof ScopeContext) {
				// the target is a scope context
				target = null;
			};
			
			var ctx = this.context();
			var out = "";
			var mark = mark__(this.option('def'));
			// if ctx 
			
			var fname = sym__(this.name());
			// console.log "symbolize {self.name} -- {fname}"
			var fdecl = fname; // decl ? fname : ''
			
			if ((ctx instanceof ClassScope) && !(target)) {
				if (this.type() == 'constructor') {
					out = ("" + mark + "function " + fname + func);
				} else if (this.option('static')) {
					out = ("" + mark + (ctx.context().c()) + "." + fname + " = function " + func);
				} else {
					out = ("" + mark + (ctx.context().c()) + ".prototype." + fname + " = function " + func);
				};
			} else if ((ctx instanceof RootScope) && !(target)) {
				// register method as a root-function, but with auto-call? hmm
				// should probably set using variable directly instead, no?
				out = ("" + mark + "function " + fdecl + func);
			} else if (target && this.option('static')) {
				out = ("" + mark + (target.c()) + "." + fname + " = function " + func);
			} else if (target) {
				out = ("" + mark + (target.c()) + ".prototype." + fname + " = function " + func);
			} else {
				out = ("" + mark + "function " + fdecl + func);
			};
			
			if (this.option('global')) {
				out = ("" + fname + " = " + out);
			};
			
			if (this.option('export')) {
				out = ("" + out + "; exports." + fname + " = " + fname + ";");
				if (this.option('return')) { out = ("" + out + "; return " + fname + ";") };
			} else if (this.option('return')) {
				out = ("return " + out);
			};
			
			return out;
		};
		
		
		function TagFragmentDeclaration(){ return MethodDeclaration.apply(this,arguments) };
		
		subclass$(TagFragmentDeclaration,MethodDeclaration);
		exports.TagFragmentDeclaration = TagFragmentDeclaration; // export class 
		
		
		
		function PropertyDeclaration(name,options,token){
			this._token = token;
			this._traversed = false;
			this._name = name;
			this._options = options || new Obj(new AssignList());
		};
		
		subclass$(PropertyDeclaration,Node);
		exports.PropertyDeclaration = PropertyDeclaration; // export class 
		var propTemplate = '${headers}\n${path}.${getter} = function(v){ return ${get}; }\n${path}.${setter} = function(v){ ${set}; return this; }\n${init}';
		
		var propWatchTemplate = '${headers}\n${path}.${getter} = function(v){ return ${get}; }\n${path}.${setter} = function(v){\n	var a = this.${getter}();\n	if(v != a) { ${set}; }\n	if(v != a) { ${ondirty} }\n	return this;\n}\n${init}';
		
		PropertyDeclaration.prototype.name = function(v){ return this._name; }
		PropertyDeclaration.prototype.setName = function(v){ this._name = v; return this; };
		PropertyDeclaration.prototype.options = function(v){ return this._options; }
		PropertyDeclaration.prototype.setOptions = function(v){ this._options = v; return this; };
		
		PropertyDeclaration.prototype.visit = function (){
			this._options.traverse();
			return this;
		};
		
		// This will soon support bindings / listeners etc, much more
		// advanced generated code based on options passed in.
		PropertyDeclaration.prototype.c = function (){
			var o = this.options();
			var ast = "";
			var key = this.name().js();
			var scope = STACK.scope();
			
			var addDesc = o.keys().length;
			
			var pars = o.hash();
			
			var isAttr = (this._token && String(this._token) == 'attr') || o.key('attr');
			
			var js = {
				key: key,
				getter: key,
				setter: sym__(("set-" + key)),
				scope: ("" + (scope.context().c())),
				path: '${scope}.prototype',
				set: ("this._" + key + " = v"),
				get: ("this._" + key),
				init: "",
				headers: "",
				ondirty: ""
			};
			
			
			if (pars.inline) {
				if ((pars.inline instanceof Bool) && !pars.inline.truthy()) {
					o.remove('inline');
					// p "dont make attr inline(!)"
					return ("Imba." + (this._token) + "(" + (js.scope) + ",'" + (this.name().value()) + "'," + (o.c()) + ")").replace(',{})',')');
				};
				
				// p "pars inline?!? {pars:inline}", typeof pars:inline
			};
			
			var tpl = propTemplate;
			
			o.add('name',new Symbol(key));
			
			if (pars.watch) {
				// p "watch is a property {pars:watch}"
				if (!((pars.watch instanceof Bool) && !pars.watch.truthy())) { tpl = propWatchTemplate };
				var wfn = ("" + key + "DidSet");
				
				if (pars.watch instanceof Symbol) {
					wfn = pars.watch;
				} else if (pars.watch instanceof Bool) {
					o.key('watch').setValue(new Symbol(("" + key + "DidSet")));
				};
				
				var fn = OP('.',new This(),wfn);
				js.ondirty = OP('&&',fn,CALL(fn,['v','a',("this.__" + key)])).c();
			};
			
			if (pars.observe) {
				if (pars.observe instanceof Bool) {
					o.key('observe').setValue(new Symbol(("" + key + "DidEmit")));
				};
				
				tpl = propWatchTemplate;
				js.ondirty = ("Imba.observeProperty(this,'" + key + "'," + (o.key('observe').value().c()) + ",v,a);") + (js.ondirty || '');
				// OP('&&',fn,CALL(fn,['v','a',"this.__{key}"])).c
			};
			
			if ((this._token && String(this._token) == 'attr') || o.key('dom') || o.key('attr')) {
				var attrKey = o.key('dom') instanceof Str ? (o.key('dom')) : (this.name().value());
				// need to make sure o has a key for attr then - so that the delegate can know?
				js.set = ("this.setAttribute('" + attrKey + "',v)");
				js.get = ("this.getAttribute('" + attrKey + "')");
			} else if (o.key('delegate')) {
				// if we have a delegate
				js.set = ("v = this.__" + key + ".delegate.set(this,'" + key + "',v,this.__" + key + ")");
				js.get = ("this.__" + key + ".delegate.get(this,'" + key + "',this.__" + key + ")");
			};
			
			
			
			if (pars.default) {
				if (o.key('dom')) {
					// FIXME go through class-method setAttribute instead
					js.init = ("" + (js.scope) + ".dom().setAttribute('" + key + "'," + (pars.default.c()) + ");");
				} else {
					// if this is not a primitive - it MUST be included in the
					// getter / setter instead
					js.init = ("" + (js.scope) + ".prototype._" + key + " = " + (pars.default.c()) + ";");
				};
			};
			
			if (o.key('chainable')) {
				js.get = ("v !== undefined ? (this." + (js.setter) + "(v),this) : " + (js.get));
			};
			
			
			js.options = o.c();
			
			if (addDesc) {
				js.headers = ("" + (js.path) + ".__" + (js.getter) + " = " + (js.options) + ";");
			};
			
			var reg = /\$\{(\w+)\}/gm;
			// var tpl = o.key(:watch) ? propWatchTemplate : propTemplate
			var out = tpl.replace(reg,function(m,a) { return js[a]; });
			// run another time for nesting. hacky
			out = out.replace(reg,function(m,a) { return js[a]; });
			// out = out.replace(/\n\s*$/,'')
			out = out.replace(/^\s+|\s+$/g,'');
			
			// if o.key(:v)
			return out;
		};
		
		
		
		// Literals should probably not inherit from the same parent
		// as arrays, tuples, objects would be better off inheriting
		// from listnode.
		
		function Literal(v){
			this._traversed = false;
			this._expression = true;
			this._cache = null;
			this._raw = null;
			this._value = v;
		};
		
		subclass$(Literal,ValueNode);
		exports.Literal = Literal; // export class 
		Literal.prototype.toString = function (){
			return "" + this.value();
		};
		
		Literal.prototype.hasSideEffects = function (){
			return false;
		};
		
		
		function Bool(v){
			this._value = v;
			this._raw = String(v) == "true" ? (true) : (false);
		};
		
		subclass$(Bool,Literal);
		exports.Bool = Bool; // export class 
		Bool.prototype.cache = function (){
			return this;
		};
		
		Bool.prototype.isPrimitive = function (){
			return true;
		};
		
		Bool.prototype.truthy = function (){
			// p "bool is truthy? {value}"
			return String(this.value()) == "true";
			// yes
		};
		
		Bool.prototype.js = function (o){
			return String(this._value);
		};
		
		Bool.prototype.c = function (){
			STACK._counter += 1;
			// undefined should not be a bool
			return String(this._value);
			// @raw ? "true" : "false"
		};
		
		Bool.prototype.toJSON = function (){
			return {type: 'Bool',value: this._value};
		};
		
		function Undefined(){ return Literal.apply(this,arguments) };
		
		subclass$(Undefined,Literal);
		exports.Undefined = Undefined; // export class 
		Undefined.prototype.isPrimitive = function (){
			return true;
		};
		
		Undefined.prototype.c = function (){
			return mark__(this._value) + "undefined";
		};
		
		function Nil(){ return Literal.apply(this,arguments) };
		
		subclass$(Nil,Literal);
		exports.Nil = Nil; // export class 
		Nil.prototype.isPrimitive = function (){
			return true;
		};
		
		Nil.prototype.c = function (){
			return mark__(this._value) + "null";
		};
		
		function True(){ return Bool.apply(this,arguments) };
		
		subclass$(True,Bool);
		exports.True = True; // export class 
		True.prototype.raw = function (){
			return true;
		};
		
		True.prototype.c = function (){
			return mark__(this._value) + "true";
		};
		
		function False(){ return Bool.apply(this,arguments) };
		
		subclass$(False,Bool);
		exports.False = False; // export class 
		False.prototype.raw = function (){
			return false;
		};
		
		False.prototype.c = function (){
			return mark__(this._value) + "false";
		};
		
		function Num(v){
			this._traversed = false;
			this._value = v;
		};
		
		subclass$(Num,Literal);
		exports.Num = Num; // export class 
		Num.prototype.toString = function (){
			return String(this._value);
		};
		
		Num.prototype.isPrimitive = function (deep){
			return true;
		};
		
		Num.prototype.shouldParenthesize = function (par){
			if(par === undefined) par = this.up();
			return (par instanceof Access) && par.left() == this;
		};
		
		Num.prototype.js = function (o){
			var num = String(this._value);
			// console.log "compiled num to {num}"
			return num;
		};
		
		Num.prototype.c = function (o){
			if (this._cache) { return Num.__super__.c.call(this,o) };
			var js = String(this._value);
			var par = STACK.current();
			var paren = (par instanceof Access) && par.left() == this;
			// only if this is the right part of teh acces
			// console.log "should paren?? {shouldParenthesize}"
			return paren ? (("(" + mark__(this._value)) + js + ")") : ((mark__(this._value) + js));
			// @cache ? super(o) : String(@value)
		};
		
		Num.prototype.cache = function (o){
			// p "cache num",o
			if (!(o && (o.cache || o.pool))) { return this };
			return Num.__super__.cache.call(this,o);
		};
		
		Num.prototype.raw = function (){
			// really?
			return JSON.parse(String(this.value()));
		};
		
		Num.prototype.toJSON = function (){
			return {type: this.typeName(),value: this.raw()};
		};
		
		// should be quoted no?
		// what about strings in object-literals?
		// we want to be able to see if the values are allowed
		function Str(v){
			this._traversed = false;
			this._expression = true;
			this._cache = null;
			this._value = v;
			// should grab the actual value immediately?
		};
		
		subclass$(Str,Literal);
		exports.Str = Str; // export class 
		Str.prototype.isString = function (){
			return true;
		};
		
		Str.prototype.isPrimitive = function (deep){
			return true;
		};
		
		Str.prototype.raw = function (){
			// JSON.parse requires double-quoted strings,
			// while eval also allows single quotes. 
			// NEXT eval is not accessible like this
			// WARNING TODO be careful! - should clean up
			
			return this._raw || (this._raw = String(this.value()).slice(1,-1)); // incredibly stupid solution
		};
		
		Str.prototype.isValidIdentifier = function (){
			// there are also some values we cannot use
			return this.raw().match(/^[a-zA-Z\$\_]+[\d\w\$\_]*$/) ? (true) : (false);
		};
		
		Str.prototype.js = function (o){
			return String(this._value);
		};
		
		Str.prototype.c = function (o){
			return this._cache ? (Str.__super__.c.call(this,o)) : (String(this._value));
		};
		
		
		function Interpolation(){ return ValueNode.apply(this,arguments) };
		
		subclass$(Interpolation,ValueNode);
		exports.Interpolation = Interpolation; // export class 
		
		
		// Currently not used - it would be better to use this
		// for real interpolated strings though, than to break
		// them up into their parts before parsing
		function InterpolatedString(nodes,o){
			if(o === undefined) o = {};
			this._nodes = nodes;
			this._options = o;
			this;
		};
		
		subclass$(InterpolatedString,Node);
		exports.InterpolatedString = InterpolatedString; // export class 
		InterpolatedString.prototype.add = function (part){
			if (part) { this._nodes.push(part) };
			return this;
		};
		
		InterpolatedString.prototype.visit = function (){
			for (var i = 0, ary = iter$(this._nodes), len = ary.length; i < len; i++) {
				ary[i].traverse();
			};
			return this;
		};
		
		InterpolatedString.prototype.escapeString = function (str){
			// var idx = 0
			// var len = str:length
			// var chr
			// while chr = str[idx++]
			return str = str.replace(/\n/g,'\\\n');
		};
		
		InterpolatedString.prototype.js = function (o){
			// creating the string
			var self = this;
			var parts = [];
			var str = '(';
			
			self._nodes.map(function(part,i) {
				if ((part instanceof Token) && part._type == 'NEOSTRING') {
					// esca
					return parts.push('"' + self.escapeString(part._value) + '"');
				} else if (part) {
					if (i == 0) {
						// force first part to be string
						parts.push('""');
					};
					part._parens = true;
					return parts.push(part.c({expression: true}));
				};
			});
			
			str += parts.join(" + ");
			str += ')';
			return str;
		};
		
		
		function Tuple(){ return ListNode.apply(this,arguments) };
		
		subclass$(Tuple,ListNode);
		exports.Tuple = Tuple; // export class 
		Tuple.prototype.c = function (){
			// compiles as an array
			return new Arr(this.nodes()).c();
		};
		
		Tuple.prototype.hasSplat = function (){
			return this.filter(function(v) { return v instanceof Splat; })[0];
		};
		
		Tuple.prototype.consume = function (node){
			if (this.count() == 1) {
				return this.first().consume(node);
			} else {
				throw "multituple cannot consume";
			};
		};
		
		
		// Because we've dropped the Str-wrapper it is kinda difficult
		function Symbol(){ return Literal.apply(this,arguments) };
		
		subclass$(Symbol,Literal);
		exports.Symbol = Symbol; // export class 
		Symbol.prototype.isValidIdentifier = function (){
			return this.raw().match(/^[a-zA-Z\$\_]+[\d\w\$\_]*$/) ? (true) : (false);
		};
		
		Symbol.prototype.isPrimitive = function (deep){
			return true;
		};
		
		Symbol.prototype.raw = function (){
			return this._raw || (this._raw = sym__(this.value()));
		};
		
		Symbol.prototype.js = function (o){
			return ("'" + sym__(this.value()) + "'");
		};
		
		function RegExp(){ return Literal.apply(this,arguments) };
		
		subclass$(RegExp,Literal);
		exports.RegExp = RegExp; // export class 
		RegExp.prototype.isPrimitive = function (){
			return true;
		};
		
		// def toString
		// 	"" + value
		;
		
		// Should inherit from ListNode - would simplify
		function Arr(){ return Literal.apply(this,arguments) };
		
		subclass$(Arr,Literal);
		exports.Arr = Arr; // export class 
		Arr.prototype.load = function (value){
			return value instanceof Array ? (new ArgList(value)) : (value);
		};
		
		Arr.prototype.push = function (item){
			this.value().push(item);
			return this;
		};
		
		Arr.prototype.count = function (){
			return this.value().length;
		};
		
		Arr.prototype.nodes = function (){
			var val = this.value();
			return val instanceof Array ? (val) : (val.nodes());
		};
		
		Arr.prototype.splat = function (){
			return this.value().some(function(v) { return v instanceof Splat; });
		};
		
		Arr.prototype.visit = function (){
			if (this._value && this._value.traverse) { this._value.traverse() };
			return this;
		};
		
		Arr.prototype.isPrimitive = function (deep){
			return !this.value().some(function(v) { return !v.isPrimitive(true); });
		};
		
		Arr.prototype.js = function (o){
			
			var val = this._value;
			if (!(val)) { return "[]" };
			
			var splat = this.splat();
			var nodes = val instanceof Array ? (val) : (val.nodes());
			// p "value of array isa {@value}"
			
			// for v in @value
			// 	break splat = yes if v isa Splat
			// var splat = value.some(|v| v isa Splat)
			
			if (splat) {
				// "SPLATTED ARRAY!"
				// if we know for certain that the splats are arrays we can drop the slice?
				// p "array is splat?!?"
				var slices = [];
				var group = null;
				
				for (var i = 0, ary = iter$(nodes), len = ary.length, v; i < len; i++) {
					v = ary[i];
					if (v instanceof Splat) {
						slices.push(v);
						group = null;
					} else {
						if (!(group)) { slices.push(group = new Arr([])) };
						group.push(v);
					};
				};
				
				return ("[].concat(" + cary__(slices).join(", ") + ")");
			} else {
				// very temporary. need a more generic way to prettify code
				// should depend on the length of the inner items etc
				// if @indented or option(:indent) or value.@indented
				//	"[\n{value.c.join(",\n").indent}\n]"
				var out = val instanceof Array ? (cary__(val)) : (val.c());
				return ("[" + out + "]");
			};
		};
		
		Arr.prototype.hasSideEffects = function (){
			return this.value().some(function(v) { return v.hasSideEffects(); });
		};
		
		Arr.prototype.toString = function (){
			return "Arr";
		};
		
		Arr.prototype.indented = function (a,b){
			this._value.indented(a,b);
			return this;
		};
		
		Arr.wrap = function (val){
			return new Arr(val);
		};
		
		// should not be cklassified as a literal?
		function Obj(){ return Literal.apply(this,arguments) };
		
		subclass$(Obj,Literal);
		exports.Obj = Obj; // export class 
		Obj.prototype.load = function (value){
			return value instanceof Array ? (new AssignList(value)) : (value);
		};
		
		Obj.prototype.visit = function (){
			if (this._value) { this._value.traverse() };
			// for v in value
			// 	v.traverse
			return this;
		};
		
		Obj.prototype.js = function (o){
			var dyn = this.value().filter(function(v) { return (v instanceof ObjAttr) && ((v.key() instanceof Op) || (v.key() instanceof InterpolatedString)); });
			
			if (dyn.length > 0) {
				var idx = this.value().indexOf(dyn[0]);
				// p "dynamic keys! {dyn}"
				// create a temp variable
				
				var tmp = this.scope__().temporary(this);
				// set the temporary object to the same
				var first = this.value().slice(0,idx);
				var obj = new Obj(first);
				var ast = [OP('=',tmp,obj)];
				
				this.value().slice(idx).forEach(function(atr) {
					return ast.push(OP('=',OP('.',tmp,atr.key()),atr.value()));
				});
				ast.push(tmp); // access the tmp at in the last part
				return new Parens(ast).c();
			};
			
			// for objects with expression-keys we need to think differently
			return '{' + this.value().c() + '}';
		};
		
		Obj.prototype.add = function (k,v){
			if ((typeof k=='string'||k instanceof String)) { k = new Identifier(k) };
			var kv = new ObjAttr(k,v);
			this.value().push(kv);
			return kv;
		};
		
		Obj.prototype.remove = function (key){
			for (var i = 0, ary = iter$(this.value()), len = ary.length, k; i < len; i++) {
				k = ary[i];
				if (k.key().symbol() == key) { this.value().remove(k) };
			};
			return this;
		};
		
		Obj.prototype.keys = function (){
			return Object.keys(this.hash());
		};
		
		Obj.prototype.hash = function (){
			var hash = {};
			for (var i = 0, ary = iter$(this.value()), len = ary.length, k; i < len; i++) {
				k = ary[i];
				if (k instanceof ObjAttr) { hash[k.key().symbol()] = k.value() };
			};
			return hash;
			// return k if k.key.symbol == key
		};
		
		// add method for finding properties etc?
		Obj.prototype.key = function (key){
			for (var i = 0, ary = iter$(this.value()), len = ary.length, k; i < len; i++) {
				k = ary[i];
				if ((k instanceof ObjAttr) && k.key().symbol() == key) { return k };
			};
			return null;
		};
		
		Obj.prototype.indented = function (a,b){
			this._value.indented(a,b);
			return this;
		};
		
		Obj.prototype.hasSideEffects = function (){
			return this.value().some(function(v) { return v.hasSideEffects(); });
		};
		
		// for converting a real object into an ast-representation
		Obj.wrap = function (obj){
			var attrs = [];
			for (var v, i = 0, keys = Object.keys(obj), l = keys.length; i < l; i++){
				v = obj[keys[i]];if (v instanceof Array) {
					v = Arr.wrap(v);
				} else if (v.constructor == Object) {
					v = Obj.wrap(v);
				};
				attrs.push(new ObjAttr(keys[i],v));
			};
			return new Obj(attrs);
		};
		
		Obj.prototype.toString = function (){
			return "Obj";
		};
		
		function ObjAttr(key,value){
			this._traversed = false;
			this._key = key;
			this._value = value;
			this._dynamic = (key instanceof Op);
			this;
		};
		
		subclass$(ObjAttr,Node);
		exports.ObjAttr = ObjAttr; // export class 
		ObjAttr.prototype.key = function(v){ return this._key; }
		ObjAttr.prototype.setKey = function(v){ this._key = v; return this; };
		ObjAttr.prototype.value = function(v){ return this._value; }
		ObjAttr.prototype.setValue = function(v){ this._value = v; return this; };
		ObjAttr.prototype.options = function(v){ return this._options; }
		ObjAttr.prototype.setOptions = function(v){ this._options = v; return this; };
		
		ObjAttr.prototype.visit = function (){
			// should probably traverse key as well, unless it is a dead simple identifier
			this.key().traverse();
			return this.value().traverse();
		};
		
		ObjAttr.prototype.js = function (o){
			var k = this.key().isReserved() ? (("'" + (this.key().c()) + "'")) : (this.key().c());
			return ("" + k + ": " + (this.value().c()));
		};
		
		ObjAttr.prototype.hasSideEffects = function (){
			return true;
		};
		
		
		
		function ArgsReference(){ return Node.apply(this,arguments) };
		
		subclass$(ArgsReference,Node);
		exports.ArgsReference = ArgsReference; // export class 
		ArgsReference.prototype.c = function (){
			return "arguments";
		};
		
		// should be a separate Context or something
		function Self(scope){
			this._scope = scope;
		};
		
		subclass$(Self,Literal);
		exports.Self = Self; // export class 
		Self.prototype.scope = function(v){ return this._scope; }
		Self.prototype.setScope = function(v){ this._scope = v; return this; };
		
		Self.prototype.cache = function (){
			return this;
		};
		
		Self.prototype.reference = function (){
			return this;
		};
		
		Self.prototype.c = function (){
			var s = this.scope__();
			return s ? (s.context().c()) : ("this");
		};
		
		function ImplicitSelf(){ return Self.apply(this,arguments) };
		
		subclass$(ImplicitSelf,Self);
		exports.ImplicitSelf = ImplicitSelf; // export class 
		
		
		function This(){ return Self.apply(this,arguments) };
		
		subclass$(This,Self);
		exports.This = This; // export class 
		This.prototype.cache = function (){
			return this;
		};
		
		This.prototype.reference = function (){
			// p "referencing this"
			return this;
		};
		
		This.prototype.c = function (){
			return "this";
		};
		
		
		
		
		// OPERATORS
		
		function Op(o,l,r){
			// set expression yes, no?
			this._expression = false;
			this._traversed = false;
			this._parens = false;
			this._cache = null;
			this._invert = false;
			this._opToken = o;
			this._op = o && o._value || o;
			this._left = l;
			this._right = r;
			return this;
		};
		
		subclass$(Op,Node);
		exports.Op = Op; // export class 
		Op.prototype.op = function(v){ return this._op; }
		Op.prototype.setOp = function(v){ this._op = v; return this; };
		Op.prototype.left = function(v){ return this._left; }
		Op.prototype.setLeft = function(v){ this._left = v; return this; };
		Op.prototype.right = function(v){ return this._right; }
		Op.prototype.setRight = function(v){ this._right = v; return this; };
		
		Op.prototype.visit = function (){
			if (this._right) { this._right.traverse() };
			if (this._left) { this._left.traverse() };
			return this;
		};
		
		Op.prototype.isExpressable = function (){
			// what if right is a string?!?
			return !(this.right()) || this.right().isExpressable();
		};
		
		Op.prototype.js = function (o){
			var out = null;
			var op = this._op;
			
			var l = this._left;
			var r = this._right;
			
			if (l instanceof Node) { l = l.c() };
			if (r instanceof Node) { r = r.c() };
			
			if (l && r) {
				out = ("" + l + " " + mark__(this._opToken) + op + " " + r);
			} else if (l) {
				out = ("" + mark__(this._opToken) + op + l);
			};
			// out = out.parenthesize if up isa Op # really?
			return out;
		};
		
		Op.prototype.shouldParenthesize = function (){
			return this._parens;
			// option(:parens)
		};
		
		Op.prototype.precedence = function (){
			return 10;
		};
		
		Op.prototype.consume = function (node){
			// p 'assignify if?!'
			// if it is possible, convert into expression
			if (node instanceof TagTree) {
				if (this._left) { this._left.consume(node) };
				if (this._right) { this._right.consume(node) };
				// @body = @body.consume(node)
				// @alt = @alt.consume(node) if @alt
				return this;
			};
			// p "Op.consume {node}".cyan
			if (this.isExpressable()) { return Op.__super__.consume.apply(this,arguments) };
			
			// TODO can rather use global caching?
			var tmpvar = this.scope__().declare('tmp',null,{system: true});
			var clone = OP(this.op(),this.left(),null);
			var ast = this.right().consume(clone);
			if (node) { ast.consume(node) };
			return ast;
		};
		
		function ComparisonOp(){ return Op.apply(this,arguments) };
		
		subclass$(ComparisonOp,Op);
		exports.ComparisonOp = ComparisonOp; // export class 
		ComparisonOp.prototype.invert = function (){
			// are there other comparison ops?
			// what about a chain?
			var op = this._op;
			var pairs = ["==","!=","===","!==",">","<=","<",">="];
			var idx = pairs.indexOf(op);
			idx += (idx % 2 ? (-1) : (1));
			
			// p "invert {@op}"
			// p "inverted comparison(!) {idx} {op} -> {pairs[idx]}"
			this.setOp(pairs[idx]);
			this._invert = !this._invert;
			return this;
		};
		
		ComparisonOp.prototype.c = function (){
			if (this.left() instanceof ComparisonOp) {
				this.left().right().cache();
				return OP('&&',this.left(),OP(this.op(),this.left().right(),this.right())).c();
			} else {
				return ComparisonOp.__super__.c.apply(this,arguments);
			};
		};
		
		ComparisonOp.prototype.js = function (o){
			var op = this._op;
			var l = this._left;
			var r = this._right;
			
			if (l instanceof Node) { l = l.c() };
			if (r instanceof Node) { r = r.c() };
			return ("" + l + " " + mark__(this._opToken) + op + " " + r);
		};
		
		
		function MathOp(){ return Op.apply(this,arguments) };
		
		subclass$(MathOp,Op);
		exports.MathOp = MathOp; // export class 
		MathOp.prototype.c = function (){
			if (this.op() == '∪') {
				return this.util().union(this.left(),this.right()).c();
			} else if (this.op() == '∩') {
				return this.util().intersect(this.left(),this.right()).c();
			};
		};
		
		
		function UnaryOp(){ return Op.apply(this,arguments) };
		
		subclass$(UnaryOp,Op);
		exports.UnaryOp = UnaryOp; // export class 
		UnaryOp.prototype.invert = function (){
			if (this.op() == '!') {
				return this.left();
			} else {
				return UnaryOp.__super__.invert.apply(this,arguments); // regular invert
			};
		};
		
		UnaryOp.prototype.js = function (o){
			var l = this._left;
			var r = this._right;
			// all of this could really be done i a much
			// cleaner way.
			// l.set(parens: yes) if l # are we really sure about this?
			// r.set(parens: yes) if r
			
			if (this.op() == '!') {
				// l.@parens = yes
				var str = l.c();
				var paren = l.shouldParenthesize(this);
				// p "check for parens in !: {str} {l} {l.@parens} {l.shouldParenthesize(self)}"
				// FIXME this is a very hacky workaround. Need to handle all this
				// in the child instead, problems arise due to automatic caching
				if (!(str.match(/^\!?([\w\.]+)$/) || (l instanceof Parens) || paren || (l instanceof Access) || (l instanceof Call))) { str = '(' + str + ')' };
				// l.set(parens: yes) # sure?
				return ("" + this.op() + str);
			} else if (this.op() == '√') {
				return ("Math.sqrt(" + (l.c()) + ")");
			} else if (this.left()) {
				return ("" + (l.c()) + this.op());
			} else {
				return ("" + this.op() + (r.c()));
			};
		};
		
		UnaryOp.prototype.normalize = function (){
			if (this.op() == '!' || this.op() == '√') { return this };
			var node = (this.left() || this.right()).node();
			// for property-accessors we need to rewrite the ast
			if (!((node instanceof PropertyAccess))) { return this };
			
			// ask to cache the path
			if ((node instanceof Access) && node.left()) { node.left().cache() };
			
			var num = new Num(1);
			var ast = OP('=',node,OP(this.op()[0],node,num));
			if (this.left()) { ast = OP(this.op()[0] == '-' ? ('+') : ('-'),ast,num) };
			
			return ast;
		};
		
		UnaryOp.prototype.consume = function (node){
			var norm = this.normalize();
			return norm == this ? (UnaryOp.__super__.consume.apply(this,arguments)) : (norm.consume(node));
		};
		
		UnaryOp.prototype.c = function (){
			var norm = this.normalize();
			return norm == this ? (UnaryOp.__super__.c.apply(this,arguments)) : (norm.c());
		};
		
		function InstanceOf(){ return Op.apply(this,arguments) };
		
		subclass$(InstanceOf,Op);
		exports.InstanceOf = InstanceOf; // export class 
		InstanceOf.prototype.js = function (o){
			// fix checks for String and Number
			// p right.inspect
			
			if (this.right() instanceof Const) {
				// WARN otherwise - what do we do? does not work with dynamic
				// classes etc? Should probably send to utility function isa$
				var name = c__(this.right().value());
				var obj = this.left().node();
				// TODO also check for primitive-constructor
				if (idx$(name,['String','Number','Boolean']) >= 0) {
					if (!((obj instanceof LocalVarAccess))) {
						obj.cache();
					};
					// need a double check for these (cache left) - possibly
					return ("(typeof " + (obj.c()) + "=='" + (name.toLowerCase()) + "'||" + (obj.c()) + " instanceof " + name + ")");
					
					// convert
				};
			};
			var out = ("" + (this.left().c()) + " " + this.op() + " " + (this.right().c()));
			
			// should this not happen in #c?
			if (o.parent() instanceof Op) { out = helpers.parenthesize(out) };
			return out;
		};
		
		function TypeOf(){ return Op.apply(this,arguments) };
		
		subclass$(TypeOf,Op);
		exports.TypeOf = TypeOf; // export class 
		TypeOf.prototype.js = function (o){
			return ("typeof " + (this.left().c()));
		};
		
		function Delete(){ return Op.apply(this,arguments) };
		
		subclass$(Delete,Op);
		exports.Delete = Delete; // export class 
		Delete.prototype.js = function (o){
			// TODO this will execute calls several times if the path is not directly to an object
			// need to cache the receiver
			var l = this.left();
			var tmp = this.scope__().temporary(this,{pool: 'val'});
			var o = OP('=',tmp,l);
			// FIXME
			return ("(" + (o.c()) + ",delete " + (l.c()) + ", " + (tmp.c()) + ")"); // oh well
			// var ast = [OP('=',tmp,left),"delete {left.c}",tmp]
			// should parenthesize directly no?
			// ast.c
		};
		
		Delete.prototype.shouldParenthesize = function (){
			return true;
		};
		
		function In(){ return Op.apply(this,arguments) };
		
		subclass$(In,Op);
		exports.In = In; // export class 
		In.prototype.invert = function (){
			this._invert = !this._invert;
			return this;
		};
		
		In.prototype.js = function (o){
			var cond = this._invert ? ("== -1") : (">= 0");
			var idx = Util.indexOf(this.left(),this.right());
			return ("" + (idx.c()) + " " + cond);
		};
		
		
		
		
		
		
		
		// ACCESS
		
		module.exports.K_IVAR = K_IVAR = 1;
		module.exports.K_SYM = K_SYM = 2;
		module.exports.K_STR = K_STR = 3;
		module.exports.K_PROP = K_PROP = 4;
		
		function Access(o,l,r){
			// set expression yes, no?
			this._expression = false;
			this._traversed = false;
			this._parens = false;
			this._cache = null;
			this._invert = false;
			this._op = o && o._value || o;
			this._left = l;
			this._right = r;
			return this;
		};
		
		subclass$(Access,Op);
		exports.Access = Access; // export class 
		Access.prototype.clone = function (left,right){
			var ctor = this.constructor;
			return new ctor(this.op(),left,right);
		};
		
		Access.prototype.js = function (o){
			var r;
			var raw = null;
			var rgt = this.right();
			var ctx = (this.left() || this.scope__().context());
			var pre = "";
			var mark = '';
			
			// if safechain
			//	p "Access is safechained {rgt.c}"
			
			
			if (rgt instanceof Num) {
				return ctx.c() + "[" + rgt.c() + "]";
			};
			
			// is this right? Should not the index compile the brackets
			// or value is a symbol -- should be the same, no?
			if ((rgt instanceof Index) && ((rgt.value() instanceof Str) || (rgt.value() instanceof Symbol))) {
				rgt = rgt.value();
			};
			
			// TODO do the identifier-validation in a central place instead
			if ((rgt instanceof Str) && rgt.isValidIdentifier()) {
				raw = rgt.raw();
			} else if ((rgt instanceof Symbol) && rgt.isValidIdentifier()) {
				raw = rgt.raw();
			} else if ((rgt instanceof Identifier) && rgt.isValidIdentifier()) {
				mark = mark__(rgt._value);
				raw = rgt.c();
			};
			
			if (this.safechain() && ctx) {
				ctx.cache({force: true});
				pre = ctx.c() + " && ";
			};
			
			// really?
			// var ctx = (left || scope__.context)
			var out = raw ? (
				// see if it needs quoting
				// need to check to see if it is legal
				ctx ? (("" + (ctx.c()) + "." + mark + raw)) : (raw)
			) : (
				r = rgt instanceof Node ? (rgt.c({expression: true})) : (rgt),
				("" + (ctx.c()) + "[" + r + "]")
			);
			
			// if safechain and ctx
			// 	out = "{ctx.c} && {out}"
			
			return pre + out;
		};
		
		Access.prototype.visit = function (){
			if (this.left()) { this.left().traverse() };
			if (this.right()) { this.right().traverse() };
			return;
		};
		
		Access.prototype.isExpressable = function (){
			return true;
		};
		
		Access.prototype.alias = function (){
			return this.right() instanceof Identifier ? (this.right().alias()) : (Access.__super__.alias.call(this));
		};
		
		Access.prototype.safechain = function (){
			// right.safechain
			return String(this._op) == '?.' || String(this._op) == '?:';
		};
		
		Access.prototype.cache = function (o){
			return ((this.right() instanceof Ivar) && !(this.left())) ? (this) : (Access.__super__.cache.call(this,o));
		};
		
		
		
		// Should change this to just refer directly to the variable? Or VarReference
		function LocalVarAccess(){ return Access.apply(this,arguments) };
		
		subclass$(LocalVarAccess,Access);
		exports.LocalVarAccess = LocalVarAccess; // export class 
		LocalVarAccess.prototype.safechain = function(v){ return this._safechain; }
		LocalVarAccess.prototype.setSafechain = function(v){ this._safechain = v; return this; };
		
		LocalVarAccess.prototype.js = function (o){
			if ((this.right() instanceof Variable) && this.right().type() == 'meth') {
				if (!((this.up() instanceof Call))) { return ("" + (this.right().c()) + "()") };
			};
			
			return this.right().c();
		};
		
		LocalVarAccess.prototype.variable = function (){
			return this.right();
		};
		
		LocalVarAccess.prototype.cache = function (o){
			if(o === undefined) o = {};
			if (o.force) { LocalVarAccess.__super__.cache.call(this,o) };
			return this;
		};
		
		LocalVarAccess.prototype.alias = function (){
			return this.variable()._alias || LocalVarAccess.__super__.alias.call(this);
		};
		
		
		function GlobalVarAccess(){ return ValueNode.apply(this,arguments) };
		
		subclass$(GlobalVarAccess,ValueNode);
		exports.GlobalVarAccess = GlobalVarAccess; // export class 
		GlobalVarAccess.prototype.js = function (o){
			return this.value().c();
		};
		
		
		function ObjectAccess(){ return Access.apply(this,arguments) };
		
		subclass$(ObjectAccess,Access);
		exports.ObjectAccess = ObjectAccess; // export class 
		
		
		
		function PropertyAccess(o,l,r){
			this._traversed = false;
			this._invert = false;
			this._parens = false;
			this._expression = false; // yes?
			this._cache = null;
			this._op = o;
			this._left = l;
			this._right = r;
			return this;
		};
		
		subclass$(PropertyAccess,Access);
		exports.PropertyAccess = PropertyAccess; // export class 
		PropertyAccess.prototype.visit = function (){
			if (this._right) { this._right.traverse() };
			if (this._left) { this._left.traverse() };
			return this;
		};
		
		// right in c we should possibly override
		// to create a call and regular access instead
		
		PropertyAccess.prototype.js = function (o){
			
			var rec;
			if (rec = this.receiver()) {
				// p "converting to call"
				var ast = CALL(OP('.',this.left(),this.right()),[]); // convert to ArgList or null
				ast.setReceiver(rec);
				return ast.c();
			};
			
			var up = this.up();
			
			if (!((up instanceof Call))) {
				// p "convert to call instead"
				ast = CALL(new Access(this.op(),this.left(),this.right()),[]);
				return ast.c();
			};
			
			// really need to fix this - for sure
			// should be possible for the function to remove this this instead?
			var js = ("" + PropertyAccess.__super__.js.call(this,o));
			
			if (!((up instanceof Call) || (up instanceof Util.IsFunction))) {
				// p "Called"
				js += "()";
			};
			
			return js;
		};
		
		
		PropertyAccess.prototype.receiver = function (){
			if ((this.left() instanceof SuperAccess) || (this.left() instanceof Super)) {
				return SELF;
			} else {
				return null;
			};
		};
		
		
		function IvarAccess(){ return Access.apply(this,arguments) };
		
		subclass$(IvarAccess,Access);
		exports.IvarAccess = IvarAccess; // export class 
		IvarAccess.prototype.cache = function (){
			// WARN hmm, this is not right... when accessing on another object it will need to be cached
			return this;
		};
		
		
		function ConstAccess(){ return Access.apply(this,arguments) };
		
		subclass$(ConstAccess,Access);
		exports.ConstAccess = ConstAccess; // export class 
		
		
		
		function IndexAccess(){ return Access.apply(this,arguments) };
		
		subclass$(IndexAccess,Access);
		exports.IndexAccess = IndexAccess; // export class 
		IndexAccess.prototype.cache = function (o){
			if(o === undefined) o = {};
			if (o.force) { return IndexAccess.__super__.cache.apply(this,arguments) };
			this.right().cache();
			return this;
		};
		
		
		function SuperAccess(){ return Access.apply(this,arguments) };
		
		subclass$(SuperAccess,Access);
		exports.SuperAccess = SuperAccess; // export class 
		SuperAccess.prototype.js = function (o){
			var m = o.method();
			var up = o.parent();
			var deep = (o.parent() instanceof Access);
			
			var out = ("" + (this.left().c()) + ".__super__");
			
			if (!((up instanceof Access))) {
				out += ("." + (m.supername().c()));
				if (!((up instanceof Call))) { // autocall?
					out += (".apply(" + (m.scope().context().c()) + ",arguments)");
				};
			};
			
			return out;
		};
		
		SuperAccess.prototype.receiver = function (){
			return SELF;
		};
		
		
		function VarOrAccess(value){
			// should rather call up to valuenode?
			this._traversed = false;
			this._parens = false;
			this._value = value;
			this._identifier = value;
			this._token = value._value;
			this._variable = null;
			this;
		};
		
		// Shortcircuit traverse so that it is not added to the stack?!
		subclass$(VarOrAccess,ValueNode);
		exports.VarOrAccess = VarOrAccess; // export class 
		VarOrAccess.prototype.visit = function (){
			// @identifier = value # this is not a real identifier?
			// console.log "VarOrAccess {@identifier}"
			// p "visit {self}"
			
			
			var scope = this.scope__();
			
			var variable = scope.lookup(this.value());
			
			// does not really need to have a declarator already? -- tricky
			if (variable && variable.declarator()) {
				// var decl = variable.declarator
				
				// if the variable is not initialized just yet and we are
				// in the same scope - we should not treat this as a var-lookup
				// ie.  var x = x would resolve to var x = this.x() if x
				// was not previously defined
				
				// should do this even if we are not in the same scope?
				// we only need to be in the same closure(!)
				
				if (variable._initialized || (scope.closure() != variable.scope().closure())) {
					this._variable = variable;
					variable.addReference(this);
					this._value = variable; // variable.accessor(self)
					this._token._variable = variable;
					return this;
				};
				
				// p "var is not yet initialized!"
				// p "declarator for var {decl.@declared}"
				// FIX
				// @value.safechain = safechain
			};
			
			// TODO deprecate and remove
			if (this.value().symbol().indexOf('$') >= 0) {
				// big hack - should disable
				// major hack here, no?
				// console.log "GlobalVarAccess"
				this._value = new GlobalVarAccess(this.value());
				return this;
			};
			
			// really? what about just mimicking the two diffrent instead?
			// Should we not return a call directly instead?
			this._value = new PropertyAccess(".",scope.context(),this.value());
			// mark the scope / context -- so we can show correct implicit
			this._token._meta = {type: 'ACCESS'};
			// @value.traverse # nah
			return this;
		};
		
		VarOrAccess.prototype.c = function (){
			return mark__(this._token) + (this._variable ? (VarOrAccess.__super__.c.call(this)) : (this.value().c()));
		};
		
		VarOrAccess.prototype.js = function (o){
			
			var v;
			if (v = this._variable) {
				var out = v.c();
				if (v._type == 'meth' && !(o.up() instanceof Call)) { out += "()" };
				return out;
			};
			return "NONO";
		};
		
		VarOrAccess.prototype.node = function (){
			return this._variable ? (this) : (this.value());
		};
		
		VarOrAccess.prototype.symbol = function (){
			return this._identifier.symbol();
			// value and value.symbol
		};
		
		VarOrAccess.prototype.cache = function (o){
			if(o === undefined) o = {};
			return this._variable ? ((o.force && VarOrAccess.__super__.cache.call(this,o))) : (this.value().cache(o));
			// should we really cache this?
			// value.cache(o)
		};
		
		VarOrAccess.prototype.decache = function (){
			this._variable ? (VarOrAccess.__super__.decache.call(this)) : (this.value().decache());
			return this;
		};
		
		VarOrAccess.prototype.dom = function (){
			return this.value().dom();
		};
		
		VarOrAccess.prototype.safechain = function (){
			return this._identifier.safechain();
		};
		
		VarOrAccess.prototype.dump = function (){
			return {loc: this.loc()};
		};
		
		VarOrAccess.prototype.loc = function (){
			var loc = this._identifier.region();
			return loc || [0,0];
		};
		
		VarOrAccess.prototype.region = function (){
			return this._identifier.region();
		};
		
		VarOrAccess.prototype.toString = function (){
			return ("VarOrAccess(" + this.value() + ")");
		};
		
		VarOrAccess.prototype.toJSON = function (){
			return {type: this.typeName(),value: this._identifier.toString()};
		};
		
		//	def js
		//		if right isa Variable and right.type == 'meth'
		//			return "{right.c}()" unless up isa Call
		//
		//		right.c
		//
		//	def variable
		//		right
		//
		//	def cache o = {}
		//		super if o:force
		//		self
		//
		//	def alias
		//		variable.@alias or super # if resolved?
		//
		
		function VarReference(value,type){
			if (value instanceof VarOrAccess) {
				value = value.value();
			};
			// for now - this can happen
			VarReference.__super__.constructor.call(this,value);
			this._export = false;
			this._type = type && String(type);
			this._variable = null;
			this._declared = true; // just testing now
		};
		
		
		subclass$(VarReference,ValueNode);
		exports.VarReference = VarReference; // export class 
		VarReference.prototype.variable = function(v){ return this._variable; }
		VarReference.prototype.setVariable = function(v){ this._variable = v; return this; };
		VarReference.prototype.declared = function(v){ return this._declared; }
		VarReference.prototype.setDeclared = function(v){ this._declared = v; return this; };
		VarReference.prototype.type = function(v){ return this._type; }
		VarReference.prototype.setType = function(v){ this._type = v; return this; };
		
		VarReference.prototype.loc = function (){
			// p "loc for VarReference {@value:constructor} {@value.@value:constructor} {@value.region}"
			return this._value.region();
		};
		
		VarReference.prototype.set = function (o){
			// hack - workaround for hidden classes perf
			if (o.export) { this._export = true };
			return this;
		};
		
		VarReference.prototype.js = function (o){
			// experimental fix
			
			// what about resolving?
			var ref = this._variable;
			var out = ("" + mark__(this._value) + (ref.c()));
			
			// p "VarReference {out} - {o.up} {o.up == self}\n{o}"
			
			if (ref && !ref._declared) { // .option(:declared)
				if (o.up(VarBlock)) { // up varblock??
					ref._declared = true;
					
					// ref.set(declared: yes)
				} else if (o.isExpression() || this._export) { // why?
					// p "autodeclare"
					ref.autodeclare();
				} else {
					out = ("var " + out);
					ref._declared = true;
					// ref.set(declared: yes)
				};
			};
			
			// need to think the export through -- like registering somehow
			// should register in scope - export on analysis++
			if (this._export) {
				out = ("module.exports." + (ref.c()) + " = " + (ref.c()));
			};
			
			return out;
		};
		
		VarReference.prototype.declare = function (){
			return this;
		};
		
		VarReference.prototype.consume = function (node){
			// really? the consumed node dissappear?
			this._variable && this._variable.autodeclare();
			return this;
		};
		
		VarReference.prototype.visit = function (){
			
			// console.log "value type for VarReference {@value} {@value.@loc} {@value:constructor}"
			
			// should be possible to have a VarReference without a name as well? for a system-variable
			// name should not set this way.
			// p "varname {value} {value:constructor}"
			var name = this.value().c();
			// p "visit vardecl {name} {value}"
			
			// what about looking up? - on register we want to mark
			var v = this._variable || (this._variable = this.scope__().register(name,this,{type: this._type}));
			// FIXME -- should not simply override the declarator here(!)
			
			if (!v.declarator()) {
				v.setDeclarator(this);
			};
			
			if (this._value) { v.addReference(this._value) }; // is this the first reference?
			
			// only needed when analyzing?
			this._value._value._variable = v;
			return this;
		};
		
		VarReference.prototype.refnr = function (){
			return this.variable().references().indexOf(this.value());
		};
		
		// convert this into a list of references
		VarReference.prototype.addExpression = function (expr){
			
			return new VarBlock([this]).addExpression(expr);
		};
		
		
		// ASSIGN
		
		function Assign(o,l,r){
			
			// workaround until we complete transition from lua-style assignments
			// to always use explicit tuples - then we can move assignments out etc
			// this will not be needed after we remove support for var a,b,c = 1,2,3
			if ((l instanceof VarReference) && (l.value() instanceof Arr)) {
				// converting all nodes to var-references ?
				// do we need to keep it in a varblock at all?
				var vars = l.value().nodes().map(function(v) {
					// what about inner tuples etc?
					// keep the splats -- clumsy but true
					var v_;
					if (v instanceof Splat) {
						// p "value is a splat!!"
						if (!((v.value() instanceof VarReference))) { (v.setValue(v_ = new VarReference(v.value(),l.type())),v_) };
					} else if (v instanceof VarReference) {
						true;
					} else {
						// what about retaining location?
						// v = v.value if v isa VarOrAccess
						v = new VarReference(v,l.type());
					};
					
					return v;
					
					// v isa VarReference ? v : VarReference.new(v)
				});
				return new TupleAssign(o,new Tuple(vars),r);
			};
			
			if (l instanceof Arr) {
				return new TupleAssign(o,new Tuple(l.nodes()),r);
				// p "left is array in assign - in init"
			};
			
			
			// set expression yes, no?
			this._expression = false;
			this._traversed = false;
			this._parens = false;
			this._cache = null;
			this._invert = false;
			this._opToken = o;
			this._op = o && o._value || o;
			this._left = l;
			this._right = r;
			return this;
		};
		
		subclass$(Assign,Op);
		exports.Assign = Assign; // export class 
		Assign.prototype.isExpressable = function (){
			return !(this.right()) || this.right().isExpressable();
		};
		
		Assign.prototype.isUsed = function (){
			// really?
			// if up is a block in general this should not be used -- since it should already have received implicit self?
			if (this.up() instanceof Block) { // && up.last != self
				return false;
			};
			return true;
		};
		
		// FIXME optimize
		Assign.prototype.visit = function (){
			var l = this._left;
			var r = this._right;
			
			// WARNING - slightly undefined
			// MARK THE STACK
			if (l) { l.traverse() };
			
			var lvar = (l instanceof VarReference) && l.variable();
			
			// how does this work with constants that are really var references?
			// should work when things are not described as well - but this is for testing
			// but if it refers to something else 
			if (!(lvar) && this._desc) {
				// entities should be able to extract the needed info instead
				ROOT.entities().add(l.namepath(),{namepath: l.namepath(),type: r.typeName(),desc: this._desc});
			};
			
			// this should probably be done in a different manner
			if (lvar && lvar.declarator() == l) {
				lvar._initialized = false;
				if (r) { r.traverse() };
				lvar._initialized = true;
			} else {
				if (r) { r.traverse() };
			};
			
			if ((l instanceof VarReference) || l._variable) {
				l._variable.assigned(r,this);
			};
			
			return this;
		};
		
		Assign.prototype.c = function (o){
			if (!this.right().isExpressable()) {
				// p "Assign#c right is not expressable "
				return this.right().consume(this).c(o);
			};
			// testing this
			return Assign.__super__.c.call(this,o);
		};
		
		Assign.prototype.js = function (o){
			if (!this.right().isExpressable()) {
				this.p("Assign#js right is not expressable ");
				// here this should be go out of the stack(!)
				// it should already be consumed?
				return this.right().consume(this).c();
			};
			
			// p "assign left {left:contrstru}"
			var l = this.left().node();
			var r = this.right();
			
			// We are setting self(!)
			// TODO document functionality
			if (l instanceof Self) {
				var ctx = this.scope__().context();
				l = ctx.reference();
			};
			
			
			if (l instanceof PropertyAccess) {
				var ast = CALL(OP('.',l.left(),l.right().setter()),[this.right()]);
				ast.setReceiver(l.receiver());
				
				if (this.isUsed()) {
					// p "Assign is used {stack}"
					// dont cache it again if it is already cached(!)
					if (!this.right().cachevar()) { this.right().cache({pool: 'val',uses: 1}) }; // 
					// this is only when used.. should be more clever about it
					ast = new Parens(blk__([ast,this.right()]));
				};
				
				// should check the up-value no?
				return ast.c({expression: true});
			};
			
			// if l isa VarReference
			// 	p "assign var-ref"
			// 	l.@variable.assigned(r)
			
			// FIXME -- does not always need to be an expression?
			// p "typeof op {@opToken and @opToken:constructor}"
			var out = ("" + (l.c()) + " " + mark__(this._opToken) + this.op() + " " + this.right().c({expression: true}));
			
			return out;
		};
		
		// FIXME op is a token? _FIX_
		// this (and similar cases) is broken when called from
		// another position in the stack, since 'up' is dynamic
		// should maybe freeze up?
		Assign.prototype.shouldParenthesize = function (par){
			if(par === undefined) par = this.up();
			return this._parens || (par instanceof Op) && par.op() != '=';
		};
		
		Assign.prototype.consume = function (node){
			if (this.isExpressable()) {
				this.forceExpression();
				return Assign.__super__.consume.call(this,node);
			};
			
			var ast = this.right().consume(this);
			return ast.consume(node);
		};
		
		// more workaround during transition away from a,b,c = 1,2,3 style assign
		Assign.prototype.addExpression = function (expr){
			var typ = ExpressionBlock;
			if (this._left && (this._left instanceof VarReference)) {
				typ = VarBlock;
			};
			// might be better to nest this up after parsing is done?
			// p "Assign.addExpression {self} <- {expr}"
			var node = new typ([this]);
			return node.addExpression(expr);
		};
		
		
		function PushAssign(){ return Assign.apply(this,arguments) };
		
		subclass$(PushAssign,Assign);
		exports.PushAssign = PushAssign; // export class 
		PushAssign.prototype.js = function (o){
			return ("" + (this.left().c()) + ".push(" + (this.right().c()) + ")");
		};
		
		PushAssign.prototype.consume = function (node){
			return this;
		};
		
		
		function ConditionalAssign(){ return Assign.apply(this,arguments) };
		
		subclass$(ConditionalAssign,Assign);
		exports.ConditionalAssign = ConditionalAssign; // export class 
		ConditionalAssign.prototype.consume = function (node){
			return this.normalize().consume(node);
		};
		
		ConditionalAssign.prototype.normalize = function (){
			var l = this.left().node();
			var ls = l;
			
			if (l instanceof Access) {
				// p "conditional-assign {l} {l.left} {l.right}"
				if (l.left()) {
					// p "cache l.left {l.left:constructor}̋"
					l.left().cache();
				};
				ls = l.clone(l.left(),l.right()); // this should still be cached?
				if (l instanceof PropertyAccess) { l.cache() }; // correct now, to a certain degree
				if (l instanceof IndexAccess) {
					// p "cache the right side of indexAccess!!! {l.right}"
					l.right().cache();
				};
				
				// we should only cache the value itself if it is dynamic?
				// l.cache # cache the value as well -- we cannot use this in assigns them
			};
			
			// some ops are less messy
			// need op to support consume then?
			var expr = this.right().isExpressable();
			var ast = null;
			// here we should use ast = if ...
			if (expr && this.op() == '||=') {
				ast = OP('||',l,OP('=',ls,this.right()));
			} else if (expr && this.op() == '&&=') {
				ast = OP('&&',l,OP('=',ls,this.right()));
			} else {
				ast = IF(this.condition(),OP('=',ls,this.right()),l); // do we need a scope for these?
				ast.setScope(null);
				// drop the scope
				// touch scope -- should probably visit the whole thing?
				// ast.scope.visit
			};
			if (ast.isExpressable()) { ast.toExpression() };
			return ast;
		};
		
		
		ConditionalAssign.prototype.c = function (){
			// WARN what if we return the same?
			return this.normalize().c();
		};
		
		ConditionalAssign.prototype.condition = function (){
			
			// use switch instead to cache op access
			if (this.op() == '?=') {
				return OP('==',this.left(),NULL);
			} else if (this.op() == '||=') {
				return OP('!',this.left());
			} else if (this.op() == '&&=') {
				return this.left();
			} else if (this.op() == '!?=') {
				return OP('!=',this.left(),NULL);
			} else {
				return this.left();
			};
		};
		
		ConditionalAssign.prototype.js = function (o){
			// p "ConditionalAssign.js".red
			var ast = IF(this.condition(),OP('=',this.left(),this.right()),this.left());
			ast.setScope(null); // not sure about this
			if (ast.isExpressable()) { ast.toExpression() }; // forced expression already
			return ast.c();
		};
		
		function CompoundAssign(){ return Assign.apply(this,arguments) };
		
		subclass$(CompoundAssign,Assign);
		exports.CompoundAssign = CompoundAssign; // export class 
		CompoundAssign.prototype.consume = function (node){
			if (this.isExpressable()) { return CompoundAssign.__super__.consume.apply(this,arguments) };
			
			var ast = this.normalize();
			if (ast != this) { return ast.consume(node) };
			
			ast = this.right().consume(this);
			return ast.consume(node);
		};
		
		CompoundAssign.prototype.normalize = function (){
			var ln = this.left().node();
			// we dont need to change this at all
			if (!((ln instanceof PropertyAccess))) {
				return this;
			};
			
			if (ln instanceof Access) {
				// left might be zero?!?!
				if (ln.left()) { ln.left().cache() };
			};
			// TODO FIXME we want to cache the context of the assignment
			// p "normalize compound assign {left}"
			var ast = OP('=',this.left(),OP(this.op()[0],this.left(),this.right()));
			if (ast.isExpressable()) { ast.toExpression() };
			
			return ast;
		};
		
		CompoundAssign.prototype.c = function (){
			var ast = this.normalize();
			if (ast == this) { return CompoundAssign.__super__.c.apply(this,arguments) };
			
			// otherwise it is important that we actually replace this node in the outer block
			// whenever we normalize and override c it is important that we can pass on caching
			// etc -- otherwise there WILL be issues.
			var up = STACK.current();
			if (up instanceof Block) {
				// p "parent is block, should replace!"
				// an alternative would be to just pass
				up.replace(this,ast);
			};
			return ast.c();
		};
		
		
		function AsyncAssign(){ return Assign.apply(this,arguments) };
		
		subclass$(AsyncAssign,Assign);
		exports.AsyncAssign = AsyncAssign; // export class 
		
		
		
		function TupleAssign(a,b,c){
			this._traversed = false;
			this._op = a;
			this._left = b;
			this._right = c;
			this._temporary = [];
		};
		
		subclass$(TupleAssign,Assign);
		exports.TupleAssign = TupleAssign; // export class 
		TupleAssign.prototype.op = function(v){ return this._op; }
		TupleAssign.prototype.setOp = function(v){ this._op = v; return this; };
		TupleAssign.prototype.left = function(v){ return this._left; }
		TupleAssign.prototype.setLeft = function(v){ this._left = v; return this; };
		TupleAssign.prototype.right = function(v){ return this._right; }
		TupleAssign.prototype.setRight = function(v){ this._right = v; return this; };
		TupleAssign.prototype.type = function(v){ return this._type; }
		TupleAssign.prototype.setType = function(v){ this._type = v; return this; };
		
		TupleAssign.prototype.isExpressable = function (){
			return this.right().isExpressable();
		};
		
		TupleAssign.prototype.addExpression = function (expr){
			if (this.right() instanceof Tuple) {
				this.right().push(expr);
			} else {
				// p "making child become a tuple?"
				this.setRight(new Tuple([this.right(),expr]));
			};
			
			return this;
		};
		
		TupleAssign.prototype.visit = function (){
			// if the first left-value is a var-reference, then
			// all the variables should be declared as variables.
			// but if we have complex items in the other list - it does become much harder
			
			// if the first is a var-reference, they should all be(!) .. or splats?
			// this is really a hacky wao to do it though
			if (this.left().first().node() instanceof VarReference) {
				this.setType('var');
				// should possibly allow real vars as well, no?
				this._vars = this.left().nodes().filter(function(n) { return n instanceof VarReference; });
				// collect the vars for tuple for easy access
				
				// NOTE can improve.. should rather make the whole left be a VarBlock or TupleVarBlock
				// p "type is var -- skip the rest"
			};
			
			this.right().traverse();
			this.left().traverse();
			return this;
		};
		
		TupleAssign.prototype.js = function (o){
			// only for actual inner expressions, otherwise cache the whole array, no?
			var self = this;
			if (!self.right().isExpressable()) {
				// p "TupleAssign.consume! {right}".blue
				
				return self.right().consume(self).c();
			};
			
			// p "TUPLE {type}"
			
			/* a,b,c = arguments */
			
			// - direct. no matter if lvalues are variables or not. Make fake arguments up to the same count as tuple
			
			/* a,*b,b = arguments */
			
			// Need to convert arguments to an array. IF arguments is not referenced anywhere else in scope, 
			// we can do the assignment directly while rolling through arguments
			
			/* a,b = b,a */
			
			// ideally we only need to cache the first value (or n - 1), assign directly when possible.
			
			/* a,b,c = (method | expression) */
			
			// convert res into array, assign from array. Can cache the variable when assigning first value
			
			// First we need to find out whether we are required to store the result in an array before assigning
			// If this needs to be an expression (returns?, we need to fall back to the CS-wa)
			
			var ast = new Block([]);
			var lft = self.left();
			var rgt = self.right();
			var typ = self.type();
			var via = null;
			
			var li = 0;
			var ri = lft.count();
			var llen = ri;
			
			
			// if @vars
			// 	p "tuple has {@vars:length} vars"
			
			// if we have a splat on the left it is much more likely that we need to store right
			// in a temporary array, but if the right side has a known length, it should still not be needed
			var lsplat = lft.filter(function(v) { return v instanceof Splat; })[0];
			
			// if right is an array without any splats (or inner tuples?), normalize it to tuple
			if ((rgt instanceof Arr) && !rgt.splat()) { rgt = new Tuple(rgt.nodes()) };
			var rlen = rgt instanceof Tuple ? (rgt.count()) : (null);
			
			// if any values are statements we need to handle this before continuing
			
			/* a,b,c = 10,20,ary */
			
			// ideally we only need to cache the first value (or n - 1), assign directly when possible.
			// only if the variables are not predefined or predeclared can be we certain that we can do it without caching
			// if rlen && typ == 'var' && !lsplat
			// 	# this can be dangerous in edgecases that are very hard to detect
			// 	# if it becomes an issue, fall back to simpler versions
			// 	# does not even matter if there is a splat?
			
			// special case for arguments(!)
			if (!(lsplat) && rgt == ARGUMENTS) {
				
				var pars = self.scope__().params();
				// p "special case with arguments {pars}"
				// forcing the arguments to be named
				// p "got here??? {pars}"
				lft.map(function(l,i) { return ast.push(OP('=',l.node(),pars.at(i,true).visit().variable())); }); // s.params.at(value - 1,yes)
			} else if (rlen) {
				// we have several items in the right part. what about splats here?
				
				// pre-evaluate rvalues that might be reference from other assignments
				// we need to check if the rightside values has no side-effects. Cause if
				// they dont, we really do not need temporary variables.
				
				// some of these optimizations are quite petty - makes things more complicated
				// in the compiler only to get around adding a few temp-variables here and there
				
				// var firstUnsafe = 0
				// lft.map do |v,i|
				// 	if v isa VarReference
				// 		p "left side {i} {v} {v.refnr}"
				
				// rgt.map do |v,i|
				// 	if v.hasSideEffects
				// 		# return if i == 0 or !v.hasSideEffects
				// 		# return if v isa Num || v isa Str || i == 0
				// 		# we could explicitly create a temporary variable and adding nodes for accessing etc
				// 		# but the builtin caching should really take care of this for us
				// 		# we need to really force the caching though -- since we need a copy of it even if it is a local
				// 		# we need to predeclare the variables at the top of scope if this does not take care of it
				// 		
				// 		# these are the declarations -- we need to add them somewhere smart
				// 		@temporary.push(v) # need a generalized way to do this type of thing
				// 		ast.push(v.cache(force: yes, type: 'swap', declared: typ == 'var'))
				// 		# they do need to be declared, no?
				
				// now we can free the cached variables
				// ast.map do |n| n.decache
				
				var pre = [];
				var rest = [];
				
				var pairs = lft.map(function(l,i) {
					var v = null;
					// determine if this needs to be precached?
					// if l isa VarReference
					// 	# this is the first time the variable is referenced
					// 	# should also count even if it is predeclared at the top
					// 	if l.refnr == 0
					
					if (l == lsplat) {
						v = new ArgList([]);
						var to = (rlen - (ri - i));
						// p "assing splat at index {i} to slice {li} - {to}".cyan
						while (li <= to){
							v.push(rgt.index(li++));
						};
						v = new Arr(v);
						// ast.push OP('=',l.node,Arr.new(v))
					} else {
						v = rgt.index(li++);
					};
					return [l.node(),v];
					
					// if l isa VarReference && l.refnr 
				});
				var clean = true;
				
				pairs.map(function(v,i) {
					var l = v[0];
					var r = v[1];
					
					if (clean) {
						if ((l instanceof VarReference) && l.refnr() == 0) {
							// still clean
							clean = true;
						} else {
							clean = false;
							// p "now cache"
							pairs.slice(i).map(function(part) {
								if (part[1].hasSideEffects()) {
									self._temporary.push(part[1]); // need a generalized way to do this type of thing
									return ast.push(part[1].cache({force: true,pool: 'swap',declared: typ == 'var'}));
								};
							});
							// p "from {i} - cache all remaining with side-effects"
						};
					};
					
					// if the previous value in ast is a reference to our value - the caching was not needed
					if (ast.last() == r) {
						r.decache();
						// p "was cached - not needed"
						// simple assign
						return ast.replace(r,OP('=',l,r));
					} else {
						return ast.push(OP('=',l,r));
					};
				});
				
				// WARN FIXME Is there not an issue with VarBlock vs not here?
			} else {
				// this is where we need to cache the right side before assigning
				// if the right side is a for loop, we COULD try to be extra clever, but
				// for now it is not worth the added compiler complexity
				
				// iter.cache(force: yes, type: 'iter')
				var top = new VarBlock();
				var iter = self.util().iterable(rgt,true);
				// could set the vars inside -- most likely
				ast.push(top);
				top.push(iter);
				
				if (lsplat) {
					var len = self.util().len(iter,true);
					var idx = self.util().counter(0,true);
					// cache the length of the array
					top.push(len); // preassign the length
					// cache counter to loop through
					top.push(idx);
				};
				
				// only if the block is variable based, no?
				// ast.push(blk = VarBlock.new)
				// blk = null
				
				var blktype = typ == 'var' ? (VarBlock) : (Block);
				var blk = new blktype([]);
				// blk = top if typ == 'var'
				ast.push(blk);
				
				// if the lvals are not variables - we need to preassign
				// can also use slice here for simplicity, but try with while now			
				lft.map(function(l,i) {
					if (l == lsplat) {
						var lvar = l.node();
						var rem = llen - i - 1; // remaining after splat
						
						if (typ != 'var') {
							var arr = self.util().array(OP('-',len,num__(i + rem)),true);
							top.push(arr);
							lvar = arr.cachevar();
						} else {
							if (!(blk)) { ast.push(blk = new blktype()) };
							arr = self.util().array(OP('-',len,num__(i + rem)));
							blk.push(OP('=',lvar,arr));
						};
						
						// if !lvar:variable || !lvar.variable # lvar = 
						// 	top.push()
						//	p "has variable - no need to create a temp"
						// blk.push(OP('=',lvar,Arr.new([]))) # dont precalculate size now
						// max = to = (rlen - (llen - i))
						
						
						var test = rem ? (OP('-',len,rem)) : (len);
						
						var set = OP('=',OP('.',lvar,OP('-',idx,num__(i))),
						OP('.',iter,OP('++',idx)));
						
						ast.push(WHILE(OP('<',idx,test),set));
						
						if (typ != 'var') {
							ast.push(blk = new Block());
							return blk.push(OP('=',l.node(),lvar));
						} else {
							return blk = null;
						};
						
						// not if splat was last?
						// ast.push(blk = VarBlock.new)
					} else if (lsplat) {
						if (!(blk)) { ast.push(blk = new blktype()) };
						// we could cache the raw code of this node for better performance
						return blk.push(OP('=',l,OP('.',iter,OP('++',idx))));
					} else {
						if (!(blk)) { ast.push(blk = new blktype()) };
						return blk.push(OP('=',l,OP('.',iter,num__(i))));
					};
				});
			};
			
			// if we are in an expression we really need to 
			if (o.isExpression() && self._vars) {
				// p "tuple is expression" # variables MUST be autodeclared outside of the expression
				for (var i = 0, ary = iter$(self._vars), len_ = ary.length; i < len_; i++) {
					ary[i].variable().autodeclare();
				};
			} else if (self._vars) {
				for (var i = 0, ary = iter$(self._vars), len_ = ary.length; i < len_; i++) {
					// p "predeclare variable before compilation"
					ary[i].variable().predeclared();
				};
			};
			
			// is there any reason to make it into an expression?
			if (ast.isExpressable()) { // NO!
				// p "express"
				// if this is an expression
				var out = ast.c({expression: true});
				if (typ && !o.isExpression()) { out = ("" + typ + " " + out) }; // not in expression
				return out;
			} else {
				out = ast.c();
				// if this is a varblock 
				return out;
			};
		};
		
		
		TupleAssign.prototype.c = function (o){
			var out = TupleAssign.__super__.c.call(this,o);
			// this is only used in tuple -- better to let the tuple hav a separate #c
			if (this._temporary && this._temporary.length) {
				this._temporary.map(function(temp) { return temp.decache(); });
			};
			return out;
		};
		
		
		
		// IDENTIFIERS
		
		// really need to clean this up
		// Drop the token?
		function Identifier(value){
			this._value = this.load(value);
			this._symbol = null;
			this._setter = null;
			
			if (("" + value).indexOf("?") >= 0) {
				this._safechain = true;
			};
			// @safechain = ("" + value).indexOf("?") >= 0
			this;
		};
		
		subclass$(Identifier,Node);
		exports.Identifier = Identifier; // export class 
		Identifier.prototype.safechain = function(v){ return this._safechain; }
		Identifier.prototype.setSafechain = function(v){ this._safechain = v; return this; };
		Identifier.prototype.value = function(v){ return this._value; }
		Identifier.prototype.setValue = function(v){ this._value = v; return this; };
		
		Identifier.prototype.references = function (variable){
			if (this._value) { this._value._variable = variable };
			return this;
		};
		
		Identifier.prototype.sourceMapMarker = function (){
			return this._value.sourceMapMarker();
		};
		
		Identifier.prototype.load = function (v){
			return (v instanceof Identifier ? (v.value()) : (v));
		};
		
		Identifier.prototype.traverse = function (){
			// NODES.push(self)
			return this;
		};
		
		Identifier.prototype.visit = function (){
			
			if (this._value instanceof Node) {
				// console.log "IDENTIFIER VALUE IS NODE"
				this._value.traverse();
			};
			return this;
		};
		
		Identifier.prototype.region = function (){
			return [this._value._loc,this._value._loc + this._value._len];
		};
		
		Identifier.prototype.isValidIdentifier = function (){
			return true;
		};
		
		Identifier.prototype.isReserved = function (){
			return this._value.reserved || RESERVED_TEST.test(String(this._value));
		};
		
		Identifier.prototype.symbol = function (){
			// console.log "Identifier#symbol {value}"
			return this._symbol || (this._symbol = sym__(this.value()));
		};
		
		Identifier.prototype.setter = function (){
			// console.log "Identifier#setter"
			var tok;
			return this._setter || (this._setter = (true) && (
				tok = new Token('IDENTIFIER',sym__('set-' + this._value),this._value._loc || -1),
				new Identifier(tok)
				// Identifier.new("set-{symbol}")
			));
		};
		
		Identifier.prototype.toString = function (){
			return String(this._value);
		};
		
		Identifier.prototype.toJSON = function (){
			return this.toString();
		};
		
		Identifier.prototype.alias = function (){
			return sym__(this._value);
		};
		
		Identifier.prototype.js = function (o){
			return this.symbol();
		};
		
		Identifier.prototype.c = function (){
			return '' + this.symbol(); // mark__(@value) + 
		};
		
		Identifier.prototype.dump = function (){
			return {loc: this.region()};
		};
		
		Identifier.prototype.namepath = function (){
			return this.toString();
		};
		
		function TagId(v){
			this._value = v instanceof Identifier ? (v.value()) : (v);
			this;
		};
		
		subclass$(TagId,Identifier);
		exports.TagId = TagId; // export class 
		TagId.prototype.c = function (){
			return ("id$('" + (this.value().c()) + "')");
		};
		
		// This is not an identifier - it is really a string
		// Is this not a literal?
		
		// FIXME Rename to IvarLiteral? or simply Literal with type Ivar
		function Ivar(v){
			this._value = v instanceof Identifier ? (v.value()) : (v);
			this;
		};
		
		subclass$(Ivar,Identifier);
		exports.Ivar = Ivar; // export class 
		Ivar.prototype.name = function (){
			return helpers.camelCase(this._value).replace(/^@/,'');
			// value.c.camelCase.replace(/^@/,'')
		};
		
		Ivar.prototype.alias = function (){
			return '_' + this.name();
		};
		
		// the @ should possibly be gone from the start?
		Ivar.prototype.js = function (o){
			return '_' + this.name();
		};
		
		Ivar.prototype.c = function (){
			return '_' + helpers.camelCase(this._value).slice(1); // .replace(/^@/,'') # mark__(@value) + 
		};
		
		
		
		// Ambiguous - We need to be consistent about Const vs ConstAccess
		// Becomes more important when we implement typeinference and code-analysis
		function Const(){ return Identifier.apply(this,arguments) };
		
		subclass$(Const,Identifier);
		exports.Const = Const; // export class 
		Const.prototype.symbol = function (){
			// console.log "Identifier#symbol {value}"
			return this._symbol || (this._symbol = sym__(this.value()));
		};
		
		Const.prototype.js = function (o){
			return this.symbol();
		};
		
		Const.prototype.c = function (){
			return mark__(this._value) + this.symbol();
		};
		
		function TagTypeIdentifier(value){
			this._value = this.load(value);
			this;
		};
		
		subclass$(TagTypeIdentifier,Identifier);
		exports.TagTypeIdentifier = TagTypeIdentifier; // export class 
		TagTypeIdentifier.prototype.name = function(v){ return this._name; }
		TagTypeIdentifier.prototype.setName = function(v){ this._name = v; return this; };
		TagTypeIdentifier.prototype.ns = function(v){ return this._ns; }
		TagTypeIdentifier.prototype.setNs = function(v){ this._ns = v; return this; };
		
		TagTypeIdentifier.prototype.load = function (val){
			this._str = ("" + val);
			var parts = this._str.split(":");
			this._raw = val;
			this._name = parts.pop();
			this._ns = parts.shift(); // if any?
			return this._str;
		};
		
		TagTypeIdentifier.prototype.js = function (o){
			return ("Imba.TAGS." + this._str.replace(":","$"));
		};
		
		TagTypeIdentifier.prototype.c = function (){
			return this.js();
		};
		
		TagTypeIdentifier.prototype.func = function (){
			var name = this._name.replace(/-/g,'_').replace(/\#/,'');
			if (this._ns) { name += ("$" + (this._ns.toLowerCase())) };
			return name;
		};
		
		TagTypeIdentifier.prototype.spawner = function (){
			if (this._ns) {
				return ("" + (this._ns.toUpperCase()) + ".$" + this._name.replace(/-/g,'_'));
			} else {
				return ("$" + this._name.replace(/-/g,'_'));
			};
		};
		
		TagTypeIdentifier.prototype.id = function (){
			var m = this._str.match(/\#([\w\-\d\_]+)\b/);
			return m ? (m[1]) : (null);
		};
		
		
		TagTypeIdentifier.prototype.flag = function (){
			return "_" + this.name().replace(/--/g,'_').toLowerCase();
		};
		
		TagTypeIdentifier.prototype.sel = function (){
			return ("." + this.flag()); // + name.replace(/-/g,'_').toLowerCase
		};
		
		TagTypeIdentifier.prototype.string = function (){
			return this.value();
		};
		
		
		function Argvar(){ return ValueNode.apply(this,arguments) };
		
		subclass$(Argvar,ValueNode);
		exports.Argvar = Argvar; // export class 
		Argvar.prototype.c = function (){
			// NEXT -- global.parseInt or Number.parseInt (better)
			var v = parseInt(String(this.value()));
			// FIXME Not needed anymore? I think the lexer handles this
			if (v == 0) { return "arguments" };
			
			var s = this.scope__();
			// params need to go up to the closeste method-scope
			var par = s.params().at(v - 1,true);
			return ("" + c__(par.name())); // c
		};
		
		
		// CALL
		
		function Call(callee,args,opexists){
			this._traversed = false;
			this._expression = false;
			this._parens = false;
			this._cache = null;
			this._receiver = null;
			this._opexists = opexists;
			// some axioms that share the same syntax as calls will be redirected from here
			
			if (callee instanceof VarOrAccess) {
				var str = callee.value().symbol();
				// p "Call callee {callee} - {str}"
				if (str == 'extern') {
					// p "returning extern instead!"
					callee.value().value()._type = 'EXTERN';
					return new ExternDeclaration(args);
				};
				if (str == 'tag') {
					// console.log "ERROR - access args by some method"
					return new TagWrapper(args && args.index ? (args.index(0)) : (args[0]));
				};
				if (str == 'export') {
					return new ExportStatement(args);
				};
			};
			
			this._callee = callee;
			this._args = args || new ArgList([]);
			
			if (args instanceof Array) {
				this._args = new ArgList(args);
				// console.log "ARGUMENTS IS ARRAY - error {args}"
			};
			// p "call opexists {opexists}"
			this;
		};
		
		subclass$(Call,Node);
		exports.Call = Call; // export class 
		Call.prototype.callee = function(v){ return this._callee; }
		Call.prototype.setCallee = function(v){ this._callee = v; return this; };
		Call.prototype.receiver = function(v){ return this._receiver; }
		Call.prototype.setReceiver = function(v){ this._receiver = v; return this; };
		Call.prototype.args = function(v){ return this._args; }
		Call.prototype.setArgs = function(v){ this._args = v; return this; };
		Call.prototype.block = function(v){ return this._block; }
		Call.prototype.setBlock = function(v){ this._block = v; return this; };
		
		Call.prototype.visit = function (){
			// console.log "visit args {args}"
			this.args().traverse();
			this.callee().traverse();
			
			// if the callee is a PropertyAccess - better to immediately change it
			
			return this._block && this._block.traverse();
		};
		
		Call.prototype.addBlock = function (block){
			var pos = this._args.filter(function(n,i) { return n == '&'; })[0]; // WOULD BE TOKEN - CAREFUL
			pos ? (this.args().replace(pos,block)) : (this.args().push(block));
			return this;
		};
		
		Call.prototype.receiver = function (){
			return this._receiver || (this._receiver = ((this.callee() instanceof Access) && this.callee().left() || NULL));
		};
		
		// check if all arguments are expressions - otherwise we have an issue
		
		Call.prototype.safechain = function (){
			return this.callee().safechain(); // really?
		};
		
		Call.prototype.js = function (o){
			var opt = {expression: true};
			var rec = null;
			// var args = compact__(args) # really?
			var args = this.args();
			
			// drop this?
			
			var splat = args.some(function(v) { return v instanceof Splat; });
			
			var out = null;
			var lft = null;
			var rgt = null;
			var wrap = null;
			
			var callee = this._callee = this._callee.node(); // drop the var or access?
			
			// if callee isa Call && callee.safechain
			//	yes
			
			if (callee instanceof Access) {
				lft = callee.left();
				rgt = callee.right();
			};
			
			if ((callee instanceof Super) || (callee instanceof SuperAccess)) {
				this._receiver = this.scope__().context();
				// return "supercall"
			};
			
			// never call the property-access directly?
			if (callee instanceof PropertyAccess) { // && rec = callee.receiver
				// p "unwrapping property-access in call"
				this._receiver = callee.receiver();
				callee = this._callee = new Access(callee.op(),callee.left(),callee.right());
				// p "got here? {callee}"
				// console.log "unwrapping the propertyAccess"
			};
			
			if (callee.safechain()) {
				// p "callee is safechained?!?"
				// if lft isa Call
				// if lft isa Call # could be a property access as well - it is the same?
				// if it is a local var access we simply check if it is a function, then call
				// but it should be safechained outside as well?
				// lft.cache if lft
				// the outer safechain should not cache the whole call - only ask to cache
				// the result? -- chain onto
				// p "Call safechain {callee} {lft}.{rgt}"
				var isfn = new Util.IsFunction([callee]);
				wrap = [("" + (isfn.c()) + "  &&  "),""];
				callee = OP('.',callee.left(),callee.right());
				// callee should already be cached now - 
			};
			
			// should just force expression from the start, no?
			if (splat) {
				// important to wrap the single value in a value, to keep implicit call
				// this is due to the way we check for an outer Call without checking if
				// we are the receiver (in PropertyAccess). Should rather wrap in CallArguments
				var rec1 = this.receiver();
				var ary = (args.count() == 1 ? (new ValueNode(args.first().value())) : (new Arr(args.list())));
				
				rec1.cache(); // need to cache the context as it will be referenced in apply
				out = ("" + callee.c({expression: true}) + ".apply(" + (rec1.c()) + "," + ary.c({expression: true}) + ")");
			} else if (this._receiver) {
				// quick workaround
				if (!((this._receiver instanceof ScopeContext))) { this._receiver.cache() };
				args.unshift(this.receiver());
				// should rather rewrite to a new call?
				out = ("" + callee.c({expression: true}) + ".call(" + args.c({expression: true}) + ")");
			} else {
				out = ("" + callee.c({expression: true}) + "(" + args.c({expression: true}) + ")");
			};
			
			if (wrap) {
				// we set the cachevar inside
				// p "special caching for call"
				if (this._cache) {
					this._cache.manual = true;
					out = ("(" + (this.cachevar().c()) + "=" + out + ")");
				};
				
				out = [wrap[0],out,wrap[1]].join("");
			};
			
			return out;
		};
		
		
		
		
		function ImplicitCall(){ return Call.apply(this,arguments) };
		
		subclass$(ImplicitCall,Call);
		exports.ImplicitCall = ImplicitCall; // export class 
		ImplicitCall.prototype.js = function (o){
			return ("" + (this.callee().c()) + "()");
		};
		
		function New(){ return Call.apply(this,arguments) };
		
		subclass$(New,Call);
		exports.New = New; // export class 
		New.prototype.js = function (o){
			var target = this.callee();
			
			while (target instanceof Access){
				var left = target.left();
				
				if ((left instanceof PropertyAccess) || (left instanceof VarOrAccess)) {
					this.callee()._parens = true;
					break;
				};
				
				target = left;
			};
			
			var out = ("new " + (this.callee().c()));
			if (!((o.parent() instanceof Call))) { out += '()' };
			return out;
		};
		
		function SuperCall(){ return Call.apply(this,arguments) };
		
		subclass$(SuperCall,Call);
		exports.SuperCall = SuperCall; // export class 
		SuperCall.prototype.js = function (o){
			var m = o.method();
			this.setReceiver(SELF);
			this.setCallee(("" + (m.target().c()) + ".super$.prototype." + (m.name().c())));
			return SuperCall.__super__.js.apply(this,arguments);
		};
		
		
		
		function ExternDeclaration(){ return ListNode.apply(this,arguments) };
		
		subclass$(ExternDeclaration,ListNode);
		exports.ExternDeclaration = ExternDeclaration; // export class 
		ExternDeclaration.prototype.visit = function (){
			
			// p "visiting externdeclaration"
			this.setNodes(this.map(function(item) { return item.node(); })); // drop var or access really
			// only in global scope?
			var root = this.scope__();
			for (var i = 0, ary = iter$(this.nodes()), len = ary.length, item; i < len; i++) {
				item = ary[i];
				var variable = root.register(item.symbol(),item,{type: 'global'});
				variable.addReference(item);
			};
			return this;
		};
		
		ExternDeclaration.prototype.c = function (){
			return "// externs";
		};
		
		
		// FLOW
		
		function ControlFlow(){ return Node.apply(this,arguments) };
		
		subclass$(ControlFlow,Node);
		exports.ControlFlow = ControlFlow; // export class 
		
		
		
		
		function ControlFlowStatement(){ return ControlFlow.apply(this,arguments) };
		
		subclass$(ControlFlowStatement,ControlFlow);
		exports.ControlFlowStatement = ControlFlowStatement; // export class 
		ControlFlowStatement.prototype.isExpressable = function (){
			return false;
		};
		
		
		
		function If(cond,body,o){
			if(o === undefined) o = {};
			this.setup();
			this._test = cond; // (o:type == 'unless' ? UnaryOp.new('!',cond,null) : cond)
			this._body = body;
			this._alt = null;
			this._type = o.type;
			if (this._type == 'unless') this.invert();
			this._scope = new IfScope(this);
			this;
		};
		
		subclass$(If,ControlFlow);
		exports.If = If; // export class 
		If.prototype.test = function(v){ return this._test; }
		If.prototype.setTest = function(v){ this._test = v; return this; };
		If.prototype.body = function(v){ return this._body; }
		If.prototype.setBody = function(v){ this._body = v; return this; };
		If.prototype.alt = function(v){ return this._alt; }
		If.prototype.setAlt = function(v){ this._alt = v; return this; };
		If.prototype.scope = function(v){ return this._scope; }
		If.prototype.setScope = function(v){ this._scope = v; return this; };
		
		If.ternary = function (cond,body,alt){
			// prefer to compile it this way as well
			var obj = new If(cond,new Block([body]),{type: '?'});
			obj.addElse(new Block([alt]));
			return obj;
		};
		
		If.prototype.addElse = function (add){
			// p "add else!",add
			if (this.alt() && (this.alt() instanceof If)) {
				// p 'add to the inner else(!)',add
				this.alt().addElse(add);
			} else {
				this.setAlt(add);
			};
			return this;
		};
		
		
		If.prototype.invert = function (){
			if (this._test instanceof ComparisonOp) {
				return this._test = this._test.invert();
			} else {
				return this._test = new UnaryOp('!',this._test,null);
			};
		};
		
		If.prototype.visit = function (){
			var alt = this.alt();
			
			if (this._scope) { this._scope.visit() };
			if (this.test()) { this.test().traverse() };
			if (this.body()) { this.body().traverse() };
			
			// should skip the scope in alt.
			if (alt) {
				// p "scoping {STACK.scopes:length}"
				STACK.pop(this);
				alt._scope || (alt._scope = new BlockScope(alt));
				alt.traverse();
				STACK.push(this);
			};
			
			// force it as expression?
			if (this._type == '?' && this.isExpressable()) this.toExpression();
			return this;
		};
		
		
		If.prototype.js = function (o){
			var body = this.body();
			// would possibly want to look up / out 
			var brace = {braces: true,indent: true};
			
			var cond = this.test().c({expression: true}); // the condition is always an expression
			
			if (o.isExpression()) {
				var code = body.c(); // (braces: yes)
				code = '(' + code + ')'; // if code.indexOf(',') >= 0
				// is expression!
				if (this.alt()) {
					// console.log "type of ternary {test}"
					// be safe - wrap condition as well
					// ask for parens
					return ("" + cond + " ? " + code + " : (" + (this.alt().c()) + ")");
				} else {
					// again - we need a better way to decide what needs parens
					// maybe better if we rewrite this to an OP('&&'), and put
					// the parens logic there
					// cond should possibly have parens - but where do we decide?
					if (this._tagtree) {
						return ("(" + cond + ") ? " + code + " : void(0)");
					} else {
						return ("(" + cond + ") && " + code);
					};
				};
			} else {
				// if there is only a single item - and it is an expression?
				code = null;
				// if body.count == 1 # dont indent by ourselves?
				
				if ((body instanceof Block) && body.count() == 1 && !(body.first() instanceof LoopFlowStatement)) {
					// p "body to body first {body.first}"
					body = body.first();
				};
				
				// if body.count == 1
				//	p "one item only!"
				//	body = body.first
				
				code = body.c({braces: true}); // (braces: yes)
				
				// don't wrap if it is only a single expression?
				var out = ("" + mark__(this._type) + "if (" + cond + ") ") + code; // ' {' + code + '}' # '{' + code + '}'
				if (this.alt()) { out += (" else " + this.alt().c(this.alt() instanceof If ? ({}) : (brace))) };
				return out;
			};
		};
		
		If.prototype.sourceMapMarker = function (){
			return this;
		};
		
		If.prototype.consume = function (node){
			// p 'assignify if?!'
			// if it is possible, convert into expression
			if (node instanceof TagTree) {
				this._body = this._body.consume(node);
				if (this._alt) { this._alt = this._alt.consume(node) };
				this._tagtree = node;
				return this;
			};
			
			// special case for If created from conditional assign as well?
			// @type == '?' and 
			// ideally we dont really want to make any expression like this by default
			var isRet = (node instanceof Return);
			
			// might have been forced to expression already
			// if it was originally a ternary - why not
			if (this._expression || ((!(isRet) || this._type == '?') && this.isExpressable())) {
				this.toExpression(); // mark as expression(!) - is this needed?
				return If.__super__.consume.call(this,node);
			} else {
				this._body = this._body.consume(node);
				if (this._alt) { this._alt = this._alt.consume(node) };
			};
			return this;
		};
		
		
		If.prototype.isExpressable = function (){
			// process:stdout.write 'x'
			var exp = this.body().isExpressable() && (!(this.alt()) || this.alt().isExpressable());
			return exp;
		};
		
		
		
		function Loop(options){
			if(options === undefined) options = {};
			this._traversed = false;
			this._options = options;
			this._body = null;
			this;
		};
		
		
		subclass$(Loop,Statement);
		exports.Loop = Loop; // export class 
		Loop.prototype.scope = function(v){ return this._scope; }
		Loop.prototype.setScope = function(v){ this._scope = v; return this; };
		Loop.prototype.options = function(v){ return this._options; }
		Loop.prototype.setOptions = function(v){ this._options = v; return this; };
		Loop.prototype.body = function(v){ return this._body; }
		Loop.prototype.setBody = function(v){ this._body = v; return this; };
		Loop.prototype.catcher = function(v){ return this._catcher; }
		Loop.prototype.setCatcher = function(v){ this._catcher = v; return this; };
		
		
		Loop.prototype.set = function (obj){
			// p "configure for!"
			this._options || (this._options = {});
			var keys = Object.keys(obj);
			for (var i = 0, ary = iter$(keys), len = ary.length, k; i < len; i++) {
				k = ary[i];
				this._options[k] = obj[k];
			};
			return this;
		};
		
		
		Loop.prototype.addBody = function (body){
			this.setBody(blk__(body));
			return this;
		};
		
		
		Loop.prototype.c = function (o){
			
			var s = this.stack();
			var curr = s.current();
			// p "Loop.c - {isExpressable} {stack} {stack.isExpression}"
			// p "stack is expression? {o} {isExpression}"
			
			
			
			if (this.stack().isExpression() || this.isExpression()) {
				// p "the stack is an expression for loop now(!)"
				// what the inner one should not be an expression though?
				// this will resut in an infinite loop, no?!?
				var ast = CALL(FN([],[this]),[]);
				return ast.c(o);
			} else if ((this.stack().current() instanceof Block) || ((s.up() instanceof Block) && s.current()._consumer == this)) {
				
				// p "what is the current stack of loop? {stack.current}"
				return Loop.__super__.c.call(this,o);
			} else {
				// p "Should never get here?!?"
				ast = CALL(FN([],[this]),[]);
				return ast.c(o);
				// need to wrap in function
			};
		};
		
		
		
		function While(test,opts){
			this._traversed = false;
			this._test = test;
			this._options = opts || {};
			this._scope = new WhileScope(this);
			// set(opts) if opts
			// p "invert test for while? {@test}"
			if (this.option('invert')) {
				// "invert test for while {@test}"
				this._test = test.invert();
			};
			// invert the test
		};
		
		
		subclass$(While,Loop);
		exports.While = While; // export class 
		While.prototype.test = function(v){ return this._test; }
		While.prototype.setTest = function(v){ this._test = v; return this; };
		
		
		While.prototype.visit = function (){
			this.scope().visit();
			if (this.test()) { this.test().traverse() };
			if (this.body()) { return this.body().traverse() };
		};
		
		
		// TODO BUG -- when we declare a var like: while var y = ...
		// the variable will be declared in the WhileScope which never
		// force-declares the inner variables in the scope
		
		While.prototype.consume = function (node){
			// p "While.consume {node}".cyan
			// This is never expressable, but at some point
			// we might want to wrap it in a function (like CS)
			if (this.isExpressable()) { return While.__super__.consume.apply(this,arguments) };
			
			if (node instanceof TagTree) {
				// WARN this is a hack to allow references coming through the wrapping scope 
				// will result in unneeded self-declarations and other oddities
				this.scope().context().reference();
				return CALL(FN([],[this]),[]);
			};
			
			var reuse = false;
			// WARN Optimization - might have untended side-effects
			// if we are assigning directly to a local variable, we simply
			// use said variable for the inner res
			// if reuse
			// 	resvar = scope.declare(node.left.node.variable,Arr.new([]),proxy: yes)
			// 	node = null
			// 	p "consume variable declarator!?".cyan
			// else
			// declare the variable we will use to soak up results
			// p "Creating value to store the result of loop".cyan
			// TODO Use a special vartype for this?
			var resvar = this.scope().declare('res',new Arr([]),{system: true});
			// WHAT -- fix this --
			this._catcher = new PushAssign("push",resvar,null); // the value is not preset # what
			this.body().consume(this._catcher); // should still return the same body
			
			// scope vars must not be compiled before this -- this is important
			var ast = new Block([this,resvar.accessor()]); // should be varaccess instead?
			return ast.consume(node);
			// NOTE Here we can find a way to know wheter or not we even need to 
			// return the resvar. Often it will not be needed
			// FIXME what happens if there is no node?!?
		};
		
		
		While.prototype.js = function (o){
			var out = ("while (" + this.test().c({expression: true}) + ")") + this.body().c({braces: true,indent: true}); // .wrap
			
			if (this.scope().vars().count() > 0) {
				// p "while-block has declared variables(!)"
				return [this.scope().vars().c(),out];
			};
			return out;
		};
		
		
		
		// This should define an open scope
		// should rather 
		function For(o){
			if(o === undefined) o = {};
			this._traversed = false;
			this._options = o;
			this._scope = new ForScope(this);
			this._catcher = null;
		};
		
		subclass$(For,Loop);
		exports.For = For; // export class 
		For.prototype.visit = function (){
			this.scope().visit();
			this.options().source.traverse(); // what about awakening the vars here?
			this.declare();
			// should be able to toggle whether to keep the results here already(!)
			
			// add guard to body
			if (this.options().guard) {
				var op = IF(this.options().guard.invert(),Block.wrap([new ContinueStatement("continue")]));
				this.body().unshift(op,BR);
			};
			
			return this.body().traverse();
		};
		
		For.prototype.isBare = function (src){
			return src && src._variable && src._variable._isArray;
		};
		
		For.prototype.declare = function (){
			var o = this.options();
			var scope = this.scope();
			var src = o.source;
			var vars = o.vars = {};
			var oi = o.index;
			
			var bare = this.isBare(src);
			// p "source is a {src} - {bare}"
			// var i = vars:index = oi ? scope.declare(oi,0) : util.counter(0,yes).predeclare
			
			// what about a range where we also include an index?
			if (src instanceof Range) {
				// p "range for-loop"
				
				// really? declare? 
				// are we sure? _really_?
				vars.len = scope.declare('len',src.right()); // util.len(o,yes).predeclare
				// make the scope be the declarator
				// TODO would like to be able to have counter in range as well
				vars.index = scope.register(o.name,scope,{type: 'let',declared: true});
				// p "registered {vars:index:constructor}"
				// p "index-var is declareod?!?! {vars:index.@declared}"
				scope.vars().push(vars.index.assignment(src.left()));
				// scope.declare(options:name,src.left)
				vars.value = vars.index;
			} else {
				// vars:value = scope.declare(options:name,null,let: yes)
				// we are using automatic caching far too much here
				
				// we should simply change how declare works
				var i = vars.index = oi ? (scope.declare(oi,0,{type: 'let'})) : (this.util().counter(0,true,scope).predeclare());
				
				vars.source = bare ? (src) : (this.util().iterable(src,true).predeclare());
				vars.len = this.util().len(vars.source,true).predeclare();
				
				vars.value = scope.declare(o.name,null,{type: 'let'});
				vars.value.addReference(o.name); // adding reference!
				if (oi) { i.addReference(oi) };
			};
			
			return this;
		};
		
		
		For.prototype.consume = function (node){
			
			var receiver;
			if (this.isExpressable()) {
				return For.__super__.consume.apply(this,arguments);
			};
			
			// other cases as well, no?
			if (node instanceof TagTree) {
				this.scope().context().reference();
				var ref = node.root().reference();
				node._loop = this;
				
				// Should not be consumed the same way
				this.body().consume(node);
				node._loop = null;
				var fn = new Lambda([new Param(ref)],[this]);
				fn.scope().wrap(this.scope());
				// TODO Scope of generated lambda should be added into stack for
				// variable naming / resolution
				return CALL(fn,[ref]);
			};
			
			
			if (this._resvar) {
				// p "already have a resvar -- change consume? {node}"
				var ast = new Block([this,BR,this._resvar.accessor()]);
				ast.consume(node);
				return ast;
			};
			
			// if node isa return -- do something else
			
			var resvar = null;
			var reuseable = false; // node isa Assign && node.left.node isa LocalVarAccess
			var assignee = null;
			// might only work for locals?
			if (node instanceof Assign) {
				// p "node isa assign {node} {node.left}"
				if (receiver = node.left()) {
					if (assignee = receiver._variable) {
						// we can only pull the var reference into the scope
						// if we know that the variable is declared in this scope
						reuseable = (receiver instanceof VarReference);
					};
				};
			};
			
			// p "reusable?!?! {node} {node}"
			
			// WARN Optimization - might have untended side-effects
			// if we are assigning directly to a local variable, we simply
			// use said variable for the inner res
			if (reuseable && assignee) {
				// instead of declaring it in the scope - why not declare it outside?
				// it might already exist in the outer scope no?
				// p "reuseable {assignee} {scope} {scope.parent.lookup(assignee)}"
				// assignee.resolve
				// should probably instead alter the assign-node to set value to a blank array
				// resvar = scope.parent.declare(assignee,Arr.new([]),proxy: yes,pos: 0)
				
				// this variable should really not be redeclared inside here at all
				assignee.resolve();
				// resvar = @resvar = scope.declare(assignee,Arr.new([]),proxy: yes)
				
				// dont declare it - simply push an assign into the vardecl of scope
				this.scope().vars().unshift(OP('=',assignee,new Arr([])));
				resvar = this._resvar = assignee;
				
				node._consumer = this;
				node = null;
				
				// p "consume variable declarator!?".cyan
			} else {
				// declare the variable we will use to soak up results
				// p "Creating value to store the result of loop".cyan
				// what about a pool here?
				resvar = this._resvar = this.scope().declare('res',new Arr([]),{system: true});
			};
			
			this._catcher = new PushAssign("push",resvar,null); // the value is not preset
			this.body().consume(this._catcher); // should still return the same body
			
			
			
			if (node) {
				// p "returning new ast where Loop is first"
				ast = new Block([this,BR,resvar.accessor().consume(node)]);
				return ast;
			};
			// var ast = Block.new([self,BR,resvar.accessor])
			// ast.consume(node) if node
			// return ast
			// p "Loop did consume successfully"
			return this;
			
			// this is never an expression (for now -- but still)
			// return ast
		};
		
		
		For.prototype.js = function (o){
			var v_;
			var vars = this.options().vars;
			var i = vars.index;
			var val = vars.value;
			var cond = OP('<',i,vars.len);
			var src = this.options().source;
			
			// p "references for value",val.references:length
			
			var final = this.options().step ? (
				OP('=',i,OP('+',i,this.options().step))
			) : (
				OP('++',i)
			);
			
			// if there are few references to the value - we can drop
			// the actual variable and instead make it proxy through the index
			if (src instanceof Range) {
				if (src.inclusive()) { (cond.setOp(v_ = '<='),v_) };
			} else if (val.refcount() < 3 && val.assignments().length == 0) {
				// p "proxy the value {val.assignments:length}"
				// p "should proxy value-variable instead"
				val.proxy(vars.source,i);
			} else {
				this.body().unshift(OP('=',val,OP('.',vars.source,i)),BR);
				// body.unshift(head)
				// TODO check lengths - intelligently decide whether to brace and indent
			};
			var head = ("" + mark__(this.options().keyword) + "for (" + (this.scope().vars().c()) + "; " + (cond.c()) + "; " + (final.c()) + ") ");
			return head + this.body().c({braces: true,indent: true}); // .wrap
		};
		
		
		For.prototype.head = function (){
			var vars = this.options().vars;
			return OP('=',vars.value,OP('.',vars.source,vars.index));
		};
		
		
		
		function ForIn(){ return For.apply(this,arguments) };
		
		subclass$(ForIn,For);
		exports.ForIn = ForIn; // export class 
		
		
		
		
		function ForOf(){ return For.apply(this,arguments) };
		
		subclass$(ForOf,For);
		exports.ForOf = ForOf; // export class 
		ForOf.prototype.declare = function (){
			var o = this.options();
			var vars = o.vars = {};
			
			// see if 
			
			// p "ForOf source isa {o:source}"
			
			// if o:source is a variable -- refer directly # variable? is this the issue?
			// p scope.@varmap['o'], scope.parent.@varmap['o']
			
			var src = vars.source = o.source._variable || this.scope().declare('o',o.source,{system: true,type: 'let'});
			if (o.index) { var v = vars.value = this.scope().declare(o.index,null,{let: true}) };
			
			// p "ForOf o:index {o:index} o:name {o:name}"
			// if o:index
			
			// possibly proxy the index-variable?
			
			if (o.own) {
				// var i = vars:index = scope.declare('i',0,system: true, type: 'let') # mark as a counter?
				var i = vars.index = this.util().counter(0,true,this.scope()).predeclare();
				// systemvariable -- should not really be added to the map
				var keys = vars.keys = this.scope().declare('keys',Util.keys(src.accessor()),{system: true,type: 'let'}); // the outer one should resolve first
				var l = vars.len = this.scope().declare('l',Util.len(keys.accessor()),{system: true,type: 'let'});
				var k = vars.key = this.scope().register(o.name,o.name,{type: 'let'}); // scope.declare(o:name,null,system: yes)
			} else {
				// we set the var -- why even declare it
				// no need to declare -- it will declare itself in the loop - no?
				k = vars.key = this.scope().register(o.name,o.name,{type: 'let'});
			};
			
			// TODO use util - why add references already? Ah -- this is for the highlighting
			if (v && o.index) { v.addReference(o.index) };
			if (k && o.name) { k.addReference(o.name) };
			
			return this;
		};
		
		ForOf.prototype.js = function (o){
			var vars = this.options().vars;
			
			var o = vars.source;
			var k = vars.key;
			var v = vars.value;
			var i = vars.index;
			
			
			if (v) {
				// set value as proxy of object[key]
				// possibly make it a ref? what is happening?
				v.refcount() < 3 ? (v.proxy(o,k)) : (this.body().unshift(OP('=',v,OP('.',o,k))));
			};
			
			if (this.options().own) {
				
				if (k.refcount() < 3) { // should probably adjust these
					k.proxy(vars.keys,i);
				} else {
					this.body().unshift(OP('=',k,OP('.',vars.keys,i)));
				};
				
				var head = ("" + mark__(this.options().keyword) + "for (" + (this.scope().vars().c()) + "; " + (OP('<',i,vars.len).c()) + "; " + (OP('++',i).c()) + ")");
				return head + this.body().c({indent: true,braces: true}); // .wrap
			};
			
			var code = this.body().c({braces: true,indent: true});
			// it is really important that this is a treated as a statement
			return this.scope().vars().c() + (";\n" + mark__(this.options().keyword) + "for (var " + (k.c()) + " in " + (o.c()) + ")") + code;
		};
		
		ForOf.prototype.head = function (){
			var v = this.options().vars;
			
			return [
				OP('=',v.key,OP('.',v.keys,v.index)),
				(v.value) && (OP('=',v.value,OP('.',v.source,v.key)))
			];
		};
		
		// NO NEED?
		function Begin(body){
			this._nodes = blk__(body).nodes();
		};
		
		
		subclass$(Begin,Block);
		exports.Begin = Begin; // export class 
		Begin.prototype.shouldParenthesize = function (){
			return this.isExpression();
		};
		
		
		
		function Switch(a,b,c){
			this._traversed = false;
			this._source = a;
			this._cases = b;
			this._fallback = c;
		};
		
		
		subclass$(Switch,ControlFlowStatement);
		exports.Switch = Switch; // export class 
		Switch.prototype.source = function(v){ return this._source; }
		Switch.prototype.setSource = function(v){ this._source = v; return this; };
		Switch.prototype.cases = function(v){ return this._cases; }
		Switch.prototype.setCases = function(v){ this._cases = v; return this; };
		Switch.prototype.fallback = function(v){ return this._fallback; }
		Switch.prototype.setFallback = function(v){ this._fallback = v; return this; };
		
		
		Switch.prototype.visit = function (){
			for (var i = 0, ary = iter$(this.cases()), len = ary.length; i < len; i++) {
				ary[i].traverse();
			};
			if (this.fallback()) { this.fallback().visit() };
			if (this.source()) { this.source().visit() };
			return;
		};
		
		
		Switch.prototype.consume = function (node){
			// TODO work inside tags (like loops)
			this._cases = this._cases.map(function(item) { return item.consume(node); });
			if (this._fallback) { this._fallback = this._fallback.consume(node) };
			return this;
		};
		
		Switch.prototype.c = function (o){
			if (this.stack().isExpression() || this.isExpression()) {
				var ast = CALL(FN([],[this]),[]);
				return ast.c(o);
			};
			
			return Switch.__super__.c.call(this,o);
		};
		
		
		Switch.prototype.js = function (o){
			var body = [];
			
			for (var i = 0, ary = iter$(this.cases()), len = ary.length, part; i < len; i++) {
				part = ary[i];
				part.autobreak();
				body.push(part);
			};
			
			if (this.fallback()) {
				body.push("default:\n" + this.fallback().c({indent: true}));
			};
			
			return ("switch (" + (this.source().c()) + ") ") + helpers.bracketize(cary__(body).join("\n"),true);
		};
		
		
		
		function SwitchCase(test,body){
			this._traversed = false;
			this._test = test;
			this._body = blk__(body);
		};
		
		subclass$(SwitchCase,ControlFlowStatement);
		exports.SwitchCase = SwitchCase; // export class 
		SwitchCase.prototype.test = function(v){ return this._test; }
		SwitchCase.prototype.setTest = function(v){ this._test = v; return this; };
		SwitchCase.prototype.body = function(v){ return this._body; }
		SwitchCase.prototype.setBody = function(v){ this._body = v; return this; };
		
		
		SwitchCase.prototype.visit = function (){
			return this.body().traverse();
		};
		
		
		SwitchCase.prototype.consume = function (node){
			this.body().consume(node);
			return this;
		};
		
		
		SwitchCase.prototype.autobreak = function (){
			if (!((this.body().last() instanceof BreakStatement))) { this.body().push(new BreakStatement()) };
			return this;
		};
		
		
		SwitchCase.prototype.js = function (o){
			if (!((this._test instanceof Array))) { this._test = [this._test] };
			var cases = this._test.map(function(item) { return ("case " + (item.c()) + ":"); });
			return cases.join("\n") + this.body().c({indent: true}); // .indent
		};
		
		
		
		function Try(body,c,f){
			this._traversed = false;
			this._body = blk__(body);
			this._catch = c;
			this._finally = f;
		};
		
		
		subclass$(Try,ControlFlowStatement);
		exports.Try = Try; // export class 
		Try.prototype.body = function(v){ return this._body; }
		Try.prototype.setBody = function(v){ this._body = v; return this; };
		// prop ncatch
		// prop nfinally
		
		Try.prototype.consume = function (node){
			this._body = this._body.consume(node);
			if (this._catch) { this._catch = this._catch.consume(node) };
			if (this._finally) { this._finally = this._finally.consume(node) };
			return this;
		};
		
		
		Try.prototype.visit = function (){
			this._body.traverse();
			if (this._catch) { this._catch.traverse() };
			if (this._finally) { return this._finally.traverse() };
			// no blocks - add an empty catch
		};
		
		
		Try.prototype.js = function (o){
			var out = "try " + this.body().c({braces: true,indent: true});
			if (this._catch) { out += " " + this._catch.c() };
			if (this._finally) { out += " " + this._finally.c() };
			
			if (!(this._catch || this._finally)) {
				out += (" catch (e) \{ \}");
			};
			out += ";";
			return out;
		};
		
		
		
		function Catch(body,varname){
			this._traversed = false;
			this._body = blk__(body || []);
			this._scope = new CatchScope(this);
			this._varname = varname;
			this;
		};
		
		subclass$(Catch,ControlFlowStatement);
		exports.Catch = Catch; // export class 
		Catch.prototype.body = function(v){ return this._body; }
		Catch.prototype.setBody = function(v){ this._body = v; return this; };
		
		Catch.prototype.consume = function (node){
			this._body = this._body.consume(node);
			return this;
		};
		
		
		Catch.prototype.visit = function (){
			this._scope.visit();
			this._variable = this._scope.register(this._varname,this,{pool: 'catchvar'});
			return this._body.traverse();
		};
		
		
		Catch.prototype.js = function (o){
			// only indent if indented by default?
			return ("catch (" + (this._variable.c()) + ") ") + this._body.c({braces: true,indent: true});
		};
		
		
		// repeating myself.. don't deal with it until we move to compact tuple-args
		// for all astnodes
		
		
		function Finally(body){
			this._traversed = false;
			this._body = blk__(body || []);
		};
		
		
		subclass$(Finally,ControlFlowStatement);
		exports.Finally = Finally; // export class 
		Finally.prototype.visit = function (){
			return this._body.traverse();
		};
		
		
		Finally.prototype.consume = function (node){
			// swallow silently
			return this;
		};
		
		
		Finally.prototype.js = function (o){
			return "finally " + this._body.c({braces: true,indent: true});
		};
		
		
		// RANGE
		
		function Range(){ return Op.apply(this,arguments) };
		
		subclass$(Range,Op);
		exports.Range = Range; // export class 
		Range.prototype.inclusive = function (){
			return this.op() == '..';
		};
		
		Range.prototype.c = function (){
			return "range";
		};
		
		
		function Splat(){ return ValueNode.apply(this,arguments) };
		
		subclass$(Splat,ValueNode);
		exports.Splat = Splat; // export class 
		Splat.prototype.js = function (o){
			var par = this.stack().parent();
			if ((par instanceof ArgList) || (par instanceof Arr)) {
				return ("[].slice.call(" + (this.value().c()) + ")");
			} else {
				this.p(("what is the parent? " + par));
				return "SPLAT";
			};
		};
		
		Splat.prototype.node = function (){
			return this.value();
		};
		
		
		
		
		
		// TAGS
		
		
		TAG_TYPES = {};
		TAG_ATTRS = {};
		
		
		TAG_TYPES.HTML = "a abbr address area article aside audio b base bdi bdo big blockquote body br button canvas caption cite code col colgroup data datalist dd del details dfn div dl dt em embed fieldset figcaption figure footer form h1 h2 h3 h4 h5 h6 head header hr html i iframe img input ins kbd keygen label legend li link main map mark menu menuitem meta meter nav noscript object ol optgroup option output p param pre progress q rp rt ruby s samp script section select small source span strong style sub summary sup table tbody td textarea tfoot th thead time title tr track u ul var video wbr".split(" ");
		
		TAG_TYPES.SVG = "circle defs ellipse g line linearGradient mask path pattern polygon polyline radialGradient rect stop svg text tspan".split(" ");
		
		TAG_ATTRS.HTML = "accept accessKey action allowFullScreen allowTransparency alt async autoComplete autoFocus autoPlay cellPadding cellSpacing charSet checked className cols colSpan content contentEditable contextMenu controls coords crossOrigin data dateTime defer dir disabled download draggable encType form formNoValidate frameBorder height hidden href hrefLang htmlFor httpEquiv icon id label lang list loop max maxLength mediaGroup method min multiple muted name noValidate pattern placeholder poster preload radioGroup readOnly rel required role rows rowSpan sandbox scope scrollLeft scrolling scrollTop seamless selected shape size span spellCheck src srcDoc srcSet start step style tabIndex target title type useMap value width wmode";
		
		TAG_ATTRS.SVG = "cx cy d dx dy fill fillOpacity fontFamily fontSize fx fy gradientTransform gradientUnits markerEnd markerMid markerStart offset opacity patternContentUnits patternUnits points preserveAspectRatio r rx ry spreadMethod stopColor stopOpacity stroke strokeDasharray strokeLinecap strokeOpacity strokeWidth textAnchor transform version viewBox x1 x2 x y1 y2 y";
		
		
		function TagDesc(){
			this.p('TagDesc!!!',arguments);
			this;
		};
		
		subclass$(TagDesc,Node);
		exports.TagDesc = TagDesc; // export class 
		TagDesc.prototype.classes = function (){
			this.p('TagDescClasses',arguments);
			return this;
		};
		
		function Tag(o){
			if(o === undefined) o = {};
			this._traversed = false;
			this._parts = [];
			o.classes || (o.classes = []);
			o.attributes || (o.attributes = []);
			o.classes || (o.classes = []);
			this._options = o;
			this._reference = null;
			this._object = null;
			this._tree = null;
			this;
		};
		
		subclass$(Tag,Node);
		exports.Tag = Tag; // export class 
		Tag.prototype.parts = function(v){ return this._parts; }
		Tag.prototype.setParts = function(v){ this._parts = v; return this; };
		Tag.prototype.object = function(v){ return this._object; }
		Tag.prototype.setObject = function(v){ this._object = v; return this; };
		Tag.prototype.reactive = function(v){ return this._reactive; }
		Tag.prototype.setReactive = function(v){ this._reactive = v; return this; };
		Tag.prototype.parent = function(v){ return this._parent; }
		Tag.prototype.setParent = function(v){ this._parent = v; return this; };
		Tag.prototype.tree = function(v){ return this._tree; }
		Tag.prototype.setTree = function(v){ this._tree = v; return this; };
		
		Tag.prototype.set = function (obj){
			for (var v, i = 0, keys = Object.keys(obj), l = keys.length; i < l; i++){
				k = keys[i];v = obj[k];if (k == 'attributes') {
					// p "attributs!"
					for (var j = 0, ary = iter$(v), len = ary.length; j < len; j++) {
						this.addAttribute(ary[j]);
					};
					continue;
				};
				
				this._options[k] = v;
			};
			return this;
		};
		
		Tag.prototype.addClass = function (node){
			if (!((node instanceof TagFlag))) {
				node = new TagFlag(node);
			};
			this._options.classes.push(node);
			this._parts.push(node);
			
			// p "add class!!!"
			return this;
		};
		
		Tag.prototype.addIndex = function (node){
			this._parts.push(node);
			this._object = node;
			return this;
		};
		
		Tag.prototype.addSymbol = function (node){
			// p "addSymbol to the tag",node
			if (this._parts.length == 0) {
				this._parts.push(node);
				this._options.ns = node;
			};
			return this;
		};
		
		
		Tag.prototype.addAttribute = function (atr){
			// p "add attribute!!!", key, value
			this._parts.push(atr); // what?
			this._options.attributes.push(atr);
			return this;
		};
		
		Tag.prototype.enclosing = function (){
			return this._options.close && this._options.close.value();
		};
		
		Tag.prototype.type = function (){
			return this._options.type || 'div';
		};
		
		Tag.prototype.consume = function (node){
			var o = this._options;
			
			
			if (node instanceof TagTree) {
				// p "tag consume tagtree? {node.reactive}"
				this.setParent(node.root());
				// o:treeRef = node.nextCacheKey
				
				if (node._loop) {
					// alwatys make items in loop reactive
					this.setReactive(node.reactive() || this.option('key'));
					this.option('loop',node._loop);
					
					if (this.option('ivar')) {
						this.warn(("Tag inside loop can not have a static reference " + this.option('ivar')),{type: 'error',token: this.option('ivar').value()});
					};
				} else {
					this.setReactive(node.reactive() || !(!this.option('ivar')));
				};
				
				return this;
			};
			
			return Tag.__super__.consume.apply(this,arguments);
		};
		
		
		Tag.prototype.visit = function (){
			
			var o = this._options;
			
			if (o.ivar || o.key) {
				this.setReactive(true);
			};
			
			var typ = this.enclosing();
			
			// look for outer tag here?
			
			if (typ == '->' || typ == '=>') {
				// console.log "tag is template?!? {typ}"
				this._tree = new TagTree(this,o.body,{root: this,reactive: this.reactive()});
				o.body = new TagFragmentFunc([],Block.wrap([this._tree]));
				// console.log "made o body a function?"
			};
			
			if (o.key) { o.key.traverse() };
			
			if (o.body) {
				o.body.traverse();
			};
			
			// id should also be a regular part
			
			if (o.id) { o.id.traverse() };
			
			
			for (var i = 0, ary = iter$(this._parts), len = ary.length; i < len; i++) {
				ary[i].traverse();
			};
			
			// for atr in @options:attributes
			// 	atr.traverse
			
			return this;
		};
		
		Tag.prototype.reference = function (){
			return this._reference || (this._reference = this.scope__().closure().temporary(this,{pool: 'tag'}).resolve());
		};
		
		// should this not happen in js?
		// should this not happen in js?
		Tag.prototype.js = function (o){
			// p JSON.stringify(@options)
			// var attrs = TagAttributes.new(o:attributes)
			// p "got here?"
			var body;
			var o = this._options;
			var a = {};
			var enc = this.enclosing();
			
			var setup = [];
			var calls = [];
			var statics = [];
			
			var scope = this.scope__();
			var commit = "end";
			var content = o.body;
			
			var isSelf = (this.type() instanceof Self);
			var bodySetter = isSelf ? ("setChildren") : ("setContent");
			
			// should not cache statics if the node itself is not cached
			// that would only mangle the order in which we set the properties
			var cacheStatics = true;
			
			for (var i = 0, ary = iter$(o.attributes), len = ary.length, atr; i < len; i++) {
				atr = ary[i];
				a[atr.key()] = atr.value(); // .populate(obj)
			};
			
			var quote = function(str) { return helpers.singlequote(str); };
			var id = o.id instanceof Node ? (o.id.c()) : ((o.id && quote(o.id.c())));
			var tree = this._tree || null;
			var parent = this.parent();
			// var parTree = parent and parent.tree
			
			
			//  "scope is", !!scope
			// p "type is {type}"
			var out = isSelf ? (
				commit = "synced",
				// p "got here"
				// setting correct context directly
				this.setReactive(true),
				this._reference = scope.context(),
				scope.context().c()
			) : (
				("" + mark__(o.open) + (scope.tagContextPath()) + "." + (this.type().spawner()) + "()")
			);
			
			if (o.id) {
				statics.push((".setId(" + quote(o.id) + ")"));
			};
			// this is reactive if it has an ivar
			if (o.ivar) {
				this.setReactive(true);
				statics.push((".setRef(" + quote(o.ivar.name()) + "," + (scope.context().c()) + ")"));
			};
			
			if (o.body instanceof Func) {
				// console.log "o:body isa function!"
				bodySetter = "setTemplate";
			} else if (o.body) {
				if ((o.body instanceof ArgList) && o.body.count() == 1 && o.body.first().isString()) {
					bodySetter = "setText";
				} else {
					// would probably be better to convert to a tagtree during the initial visit
					tree = new TagTree(this,o.body,{root: this,reactive: this.reactive()});
					content = tree;
					this.setTree(tree);
				};
			};
			
			if (tree) {
				// this is the point where we traverse the inner nodes with our tree
				// should rather happen in visit - long before.
				tree.resolve();
			};
			
			for (var i = 0, ary = iter$(this._parts), len = ary.length, part; i < len; i++) {
				part = ary[i];
				var pjs;
				var pcache = false;
				
				if (part instanceof TagAttr) {
					var akey = String(part.key());
					var aval = part.value();
					// p "part value {aval} {aval.isPrimitive(yes)}"
					
					// the attr should compile itself instead -- really
					pcache = aval.isPrimitive();
					
					if (akey[0] == '.') { // should check in a better way
						pcache = false;
						pjs = (".flag(" + quote(akey.substr(1)) + "," + (aval.c()) + ")");
					} else if (akey[0] == ':') {
						// need to analyze whether this is static or not
						pjs = (".setHandler(" + quote(akey.substr(1)) + "," + (aval.c()) + "," + (scope.context().c()) + ")");
					} else if (akey.substr(0,5) == 'data-') {
						pjs = (".dataset('" + akey.slice(5) + "'," + (aval.c()) + ")");
					} else {
						pjs = ("." + mark__(part.key()) + helpers.setterSym(akey) + "(" + (aval.c()) + ")");
					};
				} else if (part instanceof TagFlag) {
					pjs = part.c();
					pcache = true;
				};
				
				if (pjs) {
					cacheStatics && pcache ? (statics.push(pjs)) : (calls.push(pjs));
				};
			};
			
			
			
			if (this.object()) {
				calls.push((".setObject(" + (this.object().c()) + ")"));
			};
			
			// p "tagtree is static? {tree.static}"
			
			// we need to trigger our own reference before the body does
			// but we do not need a reference if we have no body (no nodes will refer it)
			if (this.reactive() && tree) { // and tree.hasTags
				this.reference();
			};
			
			if (this.reactive() && parent && parent.tree()) {
				o.treeRef = parent.tree().nextCacheKey(this);
			};
			
			if (body = content && content.c({expression: true})) { // force it to be an expression, no?
				var typ = 0;
				
				if (tree) {
					if (tree.static()) {
						typ = 2;
					} else if (this.reactive() || tree.reactive()) {
						if (!tree.single() || (tree.single() instanceof If)) {
							typ = 1;
						} else {
							typ = 3;
						};
					};
				};
				
				
				if (bodySetter == 'setChildren' || bodySetter == 'setContent') {
					calls.push(("." + bodySetter + "(" + body + "," + typ + ")"));
				} else {
					calls.push(("." + bodySetter + "(" + body + ")"));
				};
				
				// out += ".body({body})"
			};
			
			// if o:attributes:length # or -- always?
			// adds lots of extra calls - but okay for now
			calls.push(("." + commit + "()"));
			
			if (statics.length) {
				out = out + statics.join("");
			};
			
			
			if ((o.ivar || o.key || this.reactive()) && !(this.type() instanceof Self)) {
				// if this is an ivar, we should set the reference relative
				// to the outer reference, or possibly right on context?
				var ctx,key;
				var partree = parent && parent.tree();
				// ctx = !o:ivar and par and par.reference or scope.context
				// key = o:ivar or tree and tree.nextCacheKey
				
				if (o.key) {
					// closest tag
					// TODO if the dynamic key starts with a static string we should
					// just prepend _ to the string instead of wrapping in OP
					ctx = parent && parent.reference();
					key = OP('+',new Str("'_'"),o.key);
				} else if (o.ivar) {
					ctx = scope.context();
					key = o.ivar;
				} else {
					ctx = parent && parent.reference();
					// ctx = partree.cacher
					key = o.treeRef || partree && partree.nextCacheKey();
					// key = tree and tree.nextCacheKey
					if (o.loop) {
						var idx = o.loop.option('vars').index;
						key = OP('+',"'" + key + "'",idx);
					};
				};
				
				
				
				// need the context -- might be better to rewrite it for real?
				// parse the whole thing into calls etc
				var acc = OP('.',ctx,key).c();
				
				if (this._reference) {
					out = ("(" + (this.reference().c()) + " = " + acc + "=" + acc + " || " + out + ")");
				} else {
					out = ("(" + acc + " = " + acc + " || " + out + ")");
				};
			};
			
			return out + calls.join("");
		};
		
		// This is a helper-node
		// Should probably use the same type of listnode everywhere - and simply flag the type as TagTree instead
		function TagTree(owner,list,options){
			if(options === undefined) options = {};
			this._owner = owner;
			this._nodes = this.load(list);
			this._options = options;
			this._conditions = [];
			this._blocks = [this];
			this._counter = 0;
			this;
		};
		
		subclass$(TagTree,ListNode);
		exports.TagTree = TagTree; // export class 
		TagTree.prototype.counter = function(v){ return this._counter; }
		TagTree.prototype.setCounter = function(v){ this._counter = v; return this; };
		TagTree.prototype.conditions = function(v){ return this._conditions; }
		TagTree.prototype.setConditions = function(v){ this._conditions = v; return this; };
		TagTree.prototype.blocks = function(v){ return this._blocks; }
		TagTree.prototype.setBlocks = function(v){ this._blocks = v; return this; };
		TagTree.prototype.cacher = function(v){ return this._cacher; }
		TagTree.prototype.setCacher = function(v){ this._cacher = v; return this; };
		
		TagTree.prototype.parent = function (){
			return this._parent || (this._parent = this._owner.parent());
		};
		
		TagTree.prototype.nextCacheKey = function (){
			var root = this._owner;
			
			// if we want to cache everything on root
			var num = ++this._counter;
			var base = "A".charCodeAt(0);
			var str = "";
			
			while (true){
				num -= 1;
				str = String.fromCharCode(base + (num % 26)) + str;
				num = Math.floor(num / 26);
				if (num <= 0) { break; };
			};
			
			str = (this._owner.type() instanceof Self ? ("$") : ("$$")) + str.toLowerCase();
			return str;
			return num;
		};
		
		TagTree.prototype.load = function (list){
			if (list instanceof ListNode) {
				// p "is a list node!! {list.count}"
				// we still want the indentation if we are not in a template
				// or, rather - we want the block to get the indentation - not the tree
				this._indentation || (this._indentation = list._indentation); // if list.count > 1
				return list.nodes();
			} else {
				return compact__(list instanceof Array ? (list) : ([list]));
			};
		};
		
		TagTree.prototype.root = function (){
			return this.option('root');
		};
		
		TagTree.prototype.reactive = function (){
			return this.option('reactive');
		};
		
		TagTree.prototype.resolve = function (){
			var self = this;
			this.remap(function(c) { return c.consume(self); });
			return self;
		};
		
		TagTree.prototype.static = function (){
			// every real node
			return this._static == null ? (this._static = this.every(function(c) { return (c instanceof Tag) || (c instanceof Str) || (c instanceof Meta); })) : (this._static);
		};
		
		TagTree.prototype.single = function (){
			return this._single == null ? (this._single = (this.realCount() == 1 ? (this.last()) : (false))) : (this._single);
		};
		
		TagTree.prototype.hasTags = function (){
			return this.some(function(c) { return c instanceof Tag; });
		};
		
		TagTree.prototype.c = function (o){
			// FIXME TEST what about comments???
			var single = this.single();
			
			// no indentation if this should return
			if (single && (STACK.current() instanceof Return)) {
				this._indentation = null;
			};
			
			var out = TagTree.__super__.c.call(this,o);
			
			if (!(single) || (single instanceof If)) {
				return ("[" + out + "]");
			} else {
				return out;
			};
		};
		
		function TagWrapper(){ return ValueNode.apply(this,arguments) };
		
		subclass$(TagWrapper,ValueNode);
		exports.TagWrapper = TagWrapper; // export class 
		TagWrapper.prototype.visit = function (){
			if (this.value() instanceof Array) {
				this.value().map(function(v) { return v.traverse(); });
			} else {
				this.value().traverse();
			};
			return this;
		};
		
		TagWrapper.prototype.c = function (){
			return ("tag$wrap(" + this.value().c({expression: true}) + ")");
		};
		
		
		function TagAttributes(){ return ListNode.apply(this,arguments) };
		
		subclass$(TagAttributes,ListNode);
		exports.TagAttributes = TagAttributes; // export class 
		TagAttributes.prototype.get = function (name){
			for (var i = 0, ary = iter$(this.nodes()), len = ary.length, node, res = []; i < len; i++) {
				node = ary[i];
				if (node.key() == name) { return node };
			};
			return res;
		};
		
		
		function TagAttr(k,v){
			// p "init TagAttribute", $0
			this._traversed = false;
			this._key = k;
			this._value = v;
		};
		
		subclass$(TagAttr,Node);
		exports.TagAttr = TagAttr; // export class 
		TagAttr.prototype.key = function(v){ return this._key; }
		TagAttr.prototype.setKey = function(v){ this._key = v; return this; };
		TagAttr.prototype.value = function(v){ return this._value; }
		TagAttr.prototype.setValue = function(v){ this._value = v; return this; };
		
		TagAttr.prototype.visit = function (){
			if (this.value()) { this.value().traverse() };
			return this;
		};
		
		TagAttr.prototype.populate = function (obj){
			obj.add(this.key(),this.value());
			return this;
		};
		
		TagAttr.prototype.c = function (){
			return "attribute";
		};
		
		
		function TagFlag(value){
			this._traversed = false;
			this._value = value;
			this;
		};
		
		subclass$(TagFlag,Node);
		exports.TagFlag = TagFlag; // export class 
		TagFlag.prototype.value = function(v){ return this._value; }
		TagFlag.prototype.setValue = function(v){ this._value = v; return this; };
		TagFlag.prototype.toggler = function(v){ return this._toggler; }
		TagFlag.prototype.setToggler = function(v){ this._toggler = v; return this; };
		
		TagFlag.prototype.visit = function (){
			if (!((typeof this._value=='string'||this._value instanceof String))) {
				this._value.traverse();
			};
			return this;
		};
		
		TagFlag.prototype.c = function (){
			if (this.value() instanceof Node) {
				return (".flag(" + (this.value().c()) + ")");
			} else {
				return (".flag(" + helpers.singlequote(this.value()) + ")");
			};
		};
		
		
		
		
		
		
		// SELECTORS
		
		
		function Selector(list,options){
			this._nodes = list || [];
			this._options = options;
		};
		
		subclass$(Selector,ListNode);
		exports.Selector = Selector; // export class 
		Selector.prototype.add = function (part,typ){
			// p "select add!",part,typ
			// mark if special?
			this.push(part);
			return this;
		};
		
		Selector.prototype.group = function (){
			// console.log "grouped!"
			// for now we simply add a comma
			// how would this work for dst?
			this._nodes.push(new SelectorGroup(","));
			return this;
		};
		
		Selector.prototype.query = function (){
			var str = "";
			var ary = [];
			
			for (var i = 0, items = iter$(this.nodes()), len = items.length; i < len; i++) {
				var val = items[i].c();
				if ((typeof val=='string'||val instanceof String)) {
					str = ("" + str + val);
				};
			};
			
			return ("'" + str + "'");
		};
		
		
		Selector.prototype.js = function (o){
			var typ = this.option('type');
			var q = c__(this.query());
			
			if (typ == '%') {
				return ("q$(" + q + "," + o.scope().context().c({explicit: true}) + ")"); // explicit context
			} else if (typ == '%%') {
				return ("q$$(" + q + "," + o.scope().context().c({explicit: true}) + ")");
			} else {
				return ("q" + typ + "(" + q + ")");
			};
			
			// return "{typ} {scoped} - {all}"
		};
		
		
		function SelectorPart(){ return ValueNode.apply(this,arguments) };
		
		subclass$(SelectorPart,ValueNode);
		exports.SelectorPart = SelectorPart; // export class 
		SelectorPart.prototype.c = function (){
			return c__(this._value);
			// "{value.c}"
		};
		
		function SelectorGroup(){ return SelectorPart.apply(this,arguments) };
		
		subclass$(SelectorGroup,SelectorPart);
		exports.SelectorGroup = SelectorGroup; // export class 
		SelectorGroup.prototype.c = function (){
			return ",";
		};
		
		function SelectorType(){ return SelectorPart.apply(this,arguments) };
		
		subclass$(SelectorType,SelectorPart);
		exports.SelectorType = SelectorType; // export class 
		SelectorType.prototype.c = function (){
			// support
			// p "selectortype {value}"
			// var out = value.c
			var name = this.value().name();
			
			// at least be very conservative about which tags we
			// can drop the tag for?
			// out in TAG_TYPES.HTML ? 
			return idx$(name,TAG_TYPES.HTML) >= 0 ? (name) : (this.value().sel());
		};
		
		
		function SelectorUniversal(){ return SelectorPart.apply(this,arguments) };
		
		subclass$(SelectorUniversal,SelectorPart);
		exports.SelectorUniversal = SelectorUniversal; // export class 
		
		
		function SelectorNamespace(){ return SelectorPart.apply(this,arguments) };
		
		subclass$(SelectorNamespace,SelectorPart);
		exports.SelectorNamespace = SelectorNamespace; // export class 
		
		
		function SelectorClass(){ return SelectorPart.apply(this,arguments) };
		
		subclass$(SelectorClass,SelectorPart);
		exports.SelectorClass = SelectorClass; // export class 
		SelectorClass.prototype.c = function (){
			if (this._value instanceof Node) {
				return (".'+" + (this._value.c()) + "+'");
			} else {
				return ("." + c__(this._value));
			};
		};
		
		function SelectorId(){ return SelectorPart.apply(this,arguments) };
		
		subclass$(SelectorId,SelectorPart);
		exports.SelectorId = SelectorId; // export class 
		SelectorId.prototype.c = function (){
			if (this._value instanceof Node) {
				return ("#'+" + (this._value.c()) + "+'");
			} else {
				return ("#" + c__(this._value));
			};
		};
		
		function SelectorCombinator(){ return SelectorPart.apply(this,arguments) };
		
		subclass$(SelectorCombinator,SelectorPart);
		exports.SelectorCombinator = SelectorCombinator; // export class 
		SelectorCombinator.prototype.c = function (){
			return ("" + c__(this._value));
		};
		
		function SelectorPseudoClass(){ return SelectorPart.apply(this,arguments) };
		
		subclass$(SelectorPseudoClass,SelectorPart);
		exports.SelectorPseudoClass = SelectorPseudoClass; // export class 
		
		
		function SelectorAttribute(left,op,right){
			this._left = left;
			this._op = op;
			this._right = this._value = right;
		};
		
		subclass$(SelectorAttribute,SelectorPart);
		exports.SelectorAttribute = SelectorAttribute; // export class 
		SelectorAttribute.prototype.c = function (){
			// TODO possibly support .toSel or sel$(v) for items inside query
			// could easily do it with a helper-function that is added to the top of the filescope
			if (this._right instanceof Str) {
				return ("[" + (this._left.c()) + (this._op) + (this._right.c()) + "]");
			} else if (this._right) {
				// this is not at all good
				return ("[" + (this._left.c()) + (this._op) + "\"'+" + c__(this._right) + "+'\"]");
			} else {
				return ("[" + (this._left.c()) + "]");
				
				// ...
			};
		};
		
		
		
		
		// DEFER
		
		function Await(){ return ValueNode.apply(this,arguments) };
		
		subclass$(Await,ValueNode);
		exports.Await = Await; // export class 
		Await.prototype.func = function(v){ return this._func; }
		Await.prototype.setFunc = function(v){ this._func = v; return this; };
		
		Await.prototype.js = function (o){
			// introduce a util here, no?
			return CALL(OP('.',new Util.Promisify([this.value()]),'then'),[this.func()]).c();
			// value.c
		};
		
		Await.prototype.visit = function (o){
			// things are now traversed in a somewhat chaotic order. Need to tighten
			// Create await function - push this value up to block, take the outer
			var self = this;
			self.value().traverse();
			
			var block = o.up(Block); // or up to the closest FUNCTION?
			var outer = o.relative(block,1);
			var par = o.relative(self,-1);
			
			// p "Block {block} {outer} {par}"
			
			self.setFunc(new AsyncFunc([],[]));
			// now we move this node up to the block
			self.func().body().setNodes(block.defers(outer,self));
			
			// if the outer is a var-assignment, we can simply set the params
			if (par instanceof Assign) {
				par.left().traverse();
				var lft = par.left().node();
				// p "Async assignment {par} {lft}"
				// Can be a tuple as well, no?
				if (lft instanceof VarReference) {
					// the param is already registered?
					// should not force the name already??
					// beware of bugs
					self.func().params().at(0,true,lft.variable().name());
				} else if (lft instanceof Tuple) {
					// if this an unfancy tuple, with only vars
					// we can just use arguments
					
					if (par.type() == 'var' && !lft.hasSplat()) {
						// p "SIMPLIFY! {lft.nodes[0]}"
						lft.map(function(el,i) {
							return self.func().params().at(i,true,el.value());
						});
					} else {
						// otherwise, do the whole tuple
						// make sure it is a var assignment?
						par.setRight(ARGUMENTS);
						self.func().body().unshift(par);
					};
				} else {
					// regular setters
					par.setRight(self.func().params().at(0,true));
					self.func().body().unshift(par);
				};
			};
			
			
			
			// If it is an advance tuple or something, it should be possible to
			// feed in the paramlist, and let the tuple handle it as if it was any
			// other value
			
			// CASE If this is a tuple / multiset with more than one async value
			// we need to think differently.
			
			// now we need to visit the function as well
			self.func().traverse();
			// pull the outer in
			return self;
		};
		
		function AsyncFunc(params,body,name,target,options){
			AsyncFunc.__super__.constructor.call(this,params,body,name,target,options);
		};
		
		subclass$(AsyncFunc,Func);
		exports.AsyncFunc = AsyncFunc; // export class 
		AsyncFunc.prototype.scopetype = function (){
			return LambdaScope;
		};
		
		// need to override, since we wont do implicit returns
		// def js
		// 	var code = scope.c
		// 	return "function ({params.c})" + code.wrap
		;
		
		
		
		// IMPORTS
		
		function ImportStatement(imports,source,ns){
			this._traversed = false;
			this._imports = imports;
			this._source = source;
			this._ns = ns;
			this;
		};
		
		subclass$(ImportStatement,Statement);
		exports.ImportStatement = ImportStatement; // export class 
		ImportStatement.prototype.ns = function(v){ return this._ns; }
		ImportStatement.prototype.setNs = function(v){ this._ns = v; return this; };
		ImportStatement.prototype.imports = function(v){ return this._imports; }
		ImportStatement.prototype.setImports = function(v){ this._imports = v; return this; };
		ImportStatement.prototype.source = function(v){ return this._source; }
		ImportStatement.prototype.setSource = function(v){ this._source = v; return this; };
		
		
		ImportStatement.prototype.visit = function (){
			if (this._ns) {
				this._nsvar || (this._nsvar = this.scope__().register(this._ns,this));
			} else {
				var src = this.source().c();
				var m = src.match(/(\w+)(\.js|imba)?[\"\']$/);
				this._alias = m ? (m[1] + '$') : ('mod$');
			};
			
			// should also register the imported items, no?
			if (this._imports) {
				var dec = this._declarations = new VariableDeclaration([]);
				
				if (this._imports.length == 1) {
					this._alias = this._imports[0];
					dec.add(this._alias,OP('.',CALL(new Identifier("require"),[this.source()]),this._alias));
					dec.traverse();
					return this;
					
					// dec.add(@alias,CALL(Identifier.new("require"),[source]))
				};
				
				// p "ImportStatement has imports {@imports:length}"
				// @declarations = VariableDeclaration.new([])
				this._moduledecl = dec.add(this._alias,CALL(new Identifier("require"),[this.source()]));
				this._moduledecl.traverse();
				
				
				if (this._imports.length > 1) {
					for (var i = 0, ary = iter$(this._imports), len = ary.length, imp; i < len; i++) {
						imp = ary[i];
						this._declarations.add(imp,OP('.',this._moduledecl.variable(),imp));
					};
				};
				
				dec.traverse();
			};
			return this;
		};
		
		
		ImportStatement.prototype.js = function (o){
			
			var fname;
			if (this._declarations) {
				return this._declarations.c();
			};
			
			var req = CALL(new Identifier("require"),[this.source()]);
			
			if (this._ns) {
				// must register ns as a real variable
				return ("var " + (this._nsvar.c()) + " = " + (req.c()));
			};
			
			if (this._imports) {
				
				var src = this.source().c();
				var alias = [];
				var vars = new VarBlock([]);
				
				if (fname = src.match(/(\w+)(\.js|imba)?[\"\']$/)) {
					alias.push(fname[1]);
				};
				
				// var alias = src.match(/(\w+)(\.js|imba)?[\"\']$/)
				// p "source type {source}"
				// create a require for the source, with a temporary name?
				var out = [req.cache({names: alias}).c()];
				
				for (var i = 0, ary = iter$(this._imports), len = ary.length, imp; i < len; i++) {
					// we also need to register these imports as variables, no?
					imp = ary[i];
					var o = OP('=',imp,OP('.',req,imp));
					out.push(("var " + (o.c())));
				};
				
				return out;
			} else {
				return req.c();
			};
		};
		
		ImportStatement.prototype.consume = function (node){
			return this;
		};
		
		
		// EXPORT 
		
		function ExportStatement(){ return ValueNode.apply(this,arguments) };
		
		subclass$(ExportStatement,ValueNode);
		exports.ExportStatement = ExportStatement; // export class 
		ExportStatement.prototype.js = function (o){
			var nodes = this._value.map(function(arg) { return ("module.exports." + (arg.c()) + " = " + (arg.c())); });
			
			if (nodes.length > 1 && (this.up() instanceof Return)) {
				return '[' + nodes.join(',') + ']';
			} else {
				return nodes.join(';\n') + ';';
			};
		};
		
		
		// UTILS
		
		function Util(args){
			this._args = args;
		};
		
		// this is how we deal with it now
		subclass$(Util,Node);
		exports.Util = Util; // export class 
		Util.prototype.args = function(v){ return this._args; }
		Util.prototype.setArgs = function(v){ this._args = v; return this; };
		
		Util.extend = function (a,b){
			return new Util.Extend([a,b]);
		};
		
		Util.callImba = function (meth,args){
			return CALL(OP('.',new Const("Imba"),new Identifier(meth)),args);
		};
		
		Util.repeat = function (str,times){
			var res = '';
			while (times > 0){
				if (times % 2 == 1) {
					res += str;
				};
				str += str;
				times >>= 1;
			};
			return res;
		};
		
		
		
		Util.keys = function (obj){
			var l = new Const("Object");
			var r = new Identifier("keys");
			return CALL(OP('.',l,r),[obj]);
		};
		
		Util.len = function (obj,cache){
			// p "LEN HELPER".green
			var r = new Identifier("length");
			var node = OP('.',obj,r);
			if (cache) { node.cache({force: true,pool: 'len'}) };
			return node;
		};
		
		Util.indexOf = function (lft,rgt){
			var node = new Util.IndexOf([lft,rgt]);
			// node.cache(force: yes, type: 'iter') if cache
			return node;
		};
		
		Util.slice = function (obj,a,b){
			var slice = new Identifier("slice");
			console.log(("slice " + a + " " + b));
			return CALL(OP('.',obj,slice),compact__([a,b]));
		};
		
		Util.iterable = function (obj,cache){
			var node = new Util.Iterable([obj]);
			if (cache) { node.cache({force: true,pool: 'iter'}) };
			return node;
		};
		
		
		
		Util.union = function (a,b){
			return new Util.Union([a,b]);
			// CALL(UNION,[a,b])
		};
		
		Util.intersect = function (a,b){
			return new Util.Intersect([a,b]);
			// CALL(INTERSECT,[a,b])
		};
		
		Util.counter = function (start,cache){
			// should it not rather be a variable?!?
			var node = new Num(start); // make sure it really is a number
			if (cache) { node.cache({force: true,pool: 'counter'}) };
			return node;
		};
		
		Util.array = function (size,cache){
			var node = new Util.Array([size]);
			if (cache) { node.cache({force: true,pool: 'list'}) };
			return node;
		};
		
		Util.defineTag = function (type,ctor,supr){
			return CALL(TAGDEF,[type,ctor,supr]);
		};
		
		
		Util.defineClass = function (name,supr,initor){
			return CALL(CLASSDEF,[name || initor,this.sup()]);
		};
		
		Util.prototype.isStandalone = function (){
			return OPTS.standalone !== false;
		};
		
		Util.prototype.js = function (o){
			return "helper";
		};
		
		// TODO Deprecate and remove
		Util.Union = function Union(){ return Util.apply(this,arguments) };
		
		subclass$(Util.Union,Util);
		Util.Union.prototype.helper = function (){
			return 'function union$(a,b){\n	if(a && a.__union) return a.__union(b);\n\n	var u = a.slice(0);\n	for(var i=0,l=b.length;i<l;i++) if(u.indexOf(b[i]) == -1) u.push(b[i]);\n	return u;\n};\n';
		};
		
		Util.Union.prototype.js = function (o){
			this.scope__().root().helper(this,this.helper());
			// When this is triggered, we need to add it to the top of file?
			return ("union$(" + this.args().map(function(v) { return v.c(); }).join(',') + ")");
		};
		
		// TODO Deprecate and remove
		Util.Intersect = function Intersect(){ return Util.apply(this,arguments) };
		
		subclass$(Util.Intersect,Util);
		Util.Intersect.prototype.helper = function (){
			return 'function intersect$(a,b){\n	if(a && a.__intersect) return a.__intersect(b);\n	var res = [];\n	for(var i=0, l=a.length; i<l; i++) {\n		var v = a[i];\n		if(b.indexOf(v) != -1) res.push(v);\n	}\n	return res;\n};\n';
		};
		
		Util.Intersect.prototype.js = function (o){
			// When this is triggered, we need to add it to the top of file?
			this.scope__().root().helper(this,this.helper());
			return ("intersect$(" + this.args().map(function(v) { return v.c(); }).join(',') + ")");
		};
		
		Util.Extend = function Extend(){ return Util.apply(this,arguments) };
		
		subclass$(Util.Extend,Util);
		Util.Extend.prototype.js = function (o){
			// When this is triggered, we need to add it to the top of file?
			return ("extend$(" + compact__(cary__(this.args())).join(',') + ")");
		};
		
		Util.IndexOf = function IndexOf(){ return Util.apply(this,arguments) };
		
		subclass$(Util.IndexOf,Util);
		Util.IndexOf.prototype.helper = function (){
			return 'function idx$(a,b){\n	return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);\n};\n';
		};
		
		Util.IndexOf.prototype.js = function (o){
			if (this.isStandalone()) {
				this.scope__().root().helper(this,this.helper());
				// When this is triggered, we need to add it to the top of file?
				return ("idx$(" + this.args().map(function(v) { return v.c(); }).join(',') + ")");
			} else {
				return ("Imba.indexOf(" + this.args().map(function(v) { return v.c(); }).join(',') + ")");
			};
		};
		
		
		Util.Subclass = function Subclass(){ return Util.apply(this,arguments) };
		
		subclass$(Util.Subclass,Util);
		Util.Subclass.prototype.helper = function (){
			// should also check if it is a real promise
			return '// helper for subclassing\nfunction subclass$(obj,sup) {\n	for (var k in sup) {\n		if (sup.hasOwnProperty(k)) obj[k] = sup[k];\n	};\n	// obj.__super__ = sup;\n	obj.prototype = Object.create(sup.prototype);\n	obj.__super__ = obj.prototype.__super__ = sup.prototype;\n	obj.prototype.initialize = obj.prototype.constructor = obj;\n};\n';
		};
		
		Util.Subclass.prototype.js = function (o){
			if (this.isStandalone()) {
				// When this is triggered, we need to add it to the top of file?
				this.scope__().root().helper(this,this.helper());
				return ("subclass$(" + this.args().map(function(v) { return v.c(); }).join(',') + ");\n");
			} else {
				return ("Imba.subclass(" + this.args().map(function(v) { return v.c(); }).join(',') + ");\n");
			};
		};
		
		Util.Promisify = function Promisify(){ return Util.apply(this,arguments) };
		
		subclass$(Util.Promisify,Util);
		Util.Promisify.prototype.helper = function (){
			// should also check if it is a real promise
			return ("function promise$(a)\{ return a instanceof Array ? Promise.all(a) : (a && a.then ? a : Promise.resolve(a)); \}");
		};
		
		Util.Promisify.prototype.js = function (o){
			if (this.isStandalone()) {
				// When this is triggered, we need to add it to the top of file?
				this.scope__().root().helper(this,this.helper());
				return ("promise$(" + this.args().map(function(v) { return v.c(); }).join(',') + ")");
			} else {
				return ("Imba.await(" + this.args().map(function(v) { return v.c(); }).join(',') + ")");
			};
		};
		
		// TODO deprecated: can remove
		Util.Class = function Class(){ return Util.apply(this,arguments) };
		
		subclass$(Util.Class,Util);
		Util.Class.prototype.js = function (o){
			// When this is triggered, we need to add it to the top of file?
			return ("class$(" + this.args().map(function(v) { return v.c(); }).join(',') + ")");
		};
		
		Util.Iterable = function Iterable(){ return Util.apply(this,arguments) };
		
		subclass$(Util.Iterable,Util);
		Util.Iterable.prototype.helper = function (){
			// now we want to allow null values as well - just return as empty collection
			// should be the same for for own of I guess
			return ("function iter$(a)\{ return a ? (a.toArray ? a.toArray() : a) : []; \};");
		};
		
		Util.Iterable.prototype.js = function (o){
			if (this.args()[0] instanceof Arr) { return this.args()[0].c() }; // or if we know for sure that it is an array
			
			if (this.isStandalone()) {
				this.scope__().root().helper(this,this.helper());
				return ("iter$(" + (this.args()[0].c()) + ")");
			} else {
				return ("Imba.iterable(" + (this.args()[0].c()) + ")");
			};
		};
		
		Util.IsFunction = function IsFunction(){ return Util.apply(this,arguments) };
		
		subclass$(Util.IsFunction,Util);
		Util.IsFunction.prototype.js = function (o){
			return ("" + (this.args()[0].c()));
		};
		
		Util.Array = function Array(){ return Util.apply(this,arguments) };
		
		subclass$(Util.Array,Util);
		Util.Array.prototype.js = function (o){
			// When this is triggered, we need to add it to the top of file?
			return ("new Array(" + this.args().map(function(v) { return v.c(); }) + ")");
		};
		
		
		
		
		function Entities(root){
			this._root = root;
			this._map = {};
			return this;
		};
		
		Entities.prototype.add = function (path,object){
			this._map[path] = object;
			return this;
		};
		
		Entities.prototype.register = function (entity){
			var $1;
			var path = entity.namepath();
			this._map[($1 = path)] || (this._map[$1] = entity);
			return this;
		};
		
		Entities.prototype.plain = function (){
			return JSON.parse(JSON.stringify(this._map));
		};
		
		Entities.prototype.toJSON = function (){
			return this._map;
		};
		
		// SCOPES
		
		// handles local variables, self etc. Should create references to outer scopes
		// when needed etc.
		
		// add class for annotations / registering methods, etc?
		// class Interface
		
		// should move the whole context-thingie right into scope
		function Scope(node,parent){
			this._nr = STACK.incr('scopes');
			this._head = [];
			this._node = node;
			this._parent = parent;
			this._vars = new VariableDeclaration([]);
			this._meta = {};
			this._annotations = [];
			this._closure = this;
			this._virtual = false;
			this._counter = 0;
			this._varmap = {};
			this._varpool = [];
		};
		
		exports.Scope = Scope; // export class 
		Scope.prototype.level = function(v){ return this._level; }
		Scope.prototype.setLevel = function(v){ this._level = v; return this; };
		Scope.prototype.context = function(v){ return this._context; }
		Scope.prototype.setContext = function(v){ this._context = v; return this; };
		Scope.prototype.node = function(v){ return this._node; }
		Scope.prototype.setNode = function(v){ this._node = v; return this; };
		Scope.prototype.parent = function(v){ return this._parent; }
		Scope.prototype.setParent = function(v){ this._parent = v; return this; };
		Scope.prototype.varmap = function(v){ return this._varmap; }
		Scope.prototype.setVarmap = function(v){ this._varmap = v; return this; };
		Scope.prototype.varpool = function(v){ return this._varpool; }
		Scope.prototype.setVarpool = function(v){ this._varpool = v; return this; };
		Scope.prototype.params = function(v){ return this._params; }
		Scope.prototype.setParams = function(v){ this._params = v; return this; };
		Scope.prototype.head = function(v){ return this._head; }
		Scope.prototype.setHead = function(v){ this._head = v; return this; };
		Scope.prototype.vars = function(v){ return this._vars; }
		Scope.prototype.setVars = function(v){ this._vars = v; return this; };
		Scope.prototype.counter = function(v){ return this._counter; }
		Scope.prototype.setCounter = function(v){ this._counter = v; return this; };
		
		Scope.prototype.p = function (){
			if (STACK.loglevel() > 0) {
				console.log.apply(console,arguments);
			};
			return this;
		};
		
		Scope.prototype.stack = function (){
			return STACK;
		};
		
		Scope.prototype.meta = function (key,value){
			if (value != undefined) {
				this._meta[key] = value;
				return this;
			};
			return this._meta[key];
		};
		
		Scope.prototype.namepath = function (){
			return '?';
		};
		
		Scope.prototype.tagContextPath = function (){
			// bypassing for now
			return this._tagContextPath || (this._tagContextPath = "tag$"); // parent.tagContextPath
		};
		
		Scope.prototype.context = function (){
			return this._context || (this._context = new ScopeContext(this));
		};
		
		Scope.prototype.traverse = function (){
			return this;
		};
		
		Scope.prototype.visit = function (){
			if (this._parent) { return this };
			// p "visited scope!"
			this._parent = STACK.scope(1); // the parent scope
			this._level = STACK.scopes().length - 1;
			
			// p "parent is",@parent
			STACK.addScope(this);
			this.root().scopes().push(this);
			return this;
		};
		
		Scope.prototype.wrap = function (scope){
			this._parent = scope._parent;
			scope._parent = this;
			return this;
		};
		
		// called for scopes that are not real scopes in js
		// must ensure that the local variables inside of the scopes do not
		// collide with variables in outer scopes -- rename if needed
		Scope.prototype.virtualize = function (){
			return this;
		};
		
		Scope.prototype.root = function (){
			var scope = this;
			while (scope){
				if (scope instanceof RootScope) { return scope };
				scope = scope.parent();
			};
			return null;
		};
		
		Scope.prototype.register = function (name,decl,o){
			// FIXME re-registering a variable should really return the existing one
			// Again, here we should not really have to deal with system-generated vars
			// But again, it is important
			
			// p "registering {name}"
			if(decl === undefined) decl = null;
			if(o === undefined) o = {};
			name = helpers.symbolize(name);
			
			// also look at outer scopes if this is not closed?
			var existing = this._varmap.hasOwnProperty(name) && this._varmap[name];
			if (existing) { return existing };
			
			var item = new Variable(this,name,decl,o);
			// need to check for duplicates, and handle this gracefully -
			// going to refactor later
			if (!o.system) { this._varmap[name] = item }; // dont even add to the varmap if it is a sysvar
			return item;
		};
		
		Scope.prototype.annotate = function (obj){
			this._annotations.push(obj);
			return this;
		};
		
		// just like register, but we automatically 
		Scope.prototype.declare = function (name,init,o){
			var declarator_;
			if(init === undefined) init = null;
			if(o === undefined) o = {};
			var variable = this.register(name,null,o);
			// TODO create the variabledeclaration here instead?
			// if this is a sysvar we need it to be renameable
			var dec = this._vars.add(variable,init);
			(declarator_ = variable.declarator()) || ((variable.setDeclarator(dec),dec));
			return variable;
			
			// p "declare variable {name} {o}"
			// if name isa Variable
			// p "SCOPE declare var".green
			name = helpers.symbolize(name);
			// we will see here
			this._vars.add(name,init); // .last -- 
			var decl = this._vars.last(); // bug(!)
			var item;
			// item = Variable.new(self,name,decl)
			
			// if o:system
			// 	item = SystemVariable.new(self,name,decl,o)
			// 	decl.variable = item
			// else
			item = new Variable(this,name,decl,o);
			decl.setVariable(item);
			item.resolve(); // why on earth should it resolve immediately?
			
			// decl.variable = item
			// item.resolve # why on earth should it resolve immediately?
			return item;
			
			// should be possible to force-declare for this scope, no?
			// if this is a system-variable 
		};
		
		// declares a variable (has no real declaration beforehand)
		
		
		// what are the differences here? omj
		// we only need a temporary thing with defaults -- that is all
		// change these values, no?
		Scope.prototype.temporary = function (refnode,o,name){
			
			// p "registering temporary {refnode} {name}"
			// reuse variables -- hmm
			if(o === undefined) o = {};
			if(name === undefined) name = null;
			if (o.pool) {
				for (var i = 0, ary = iter$(this._varpool), len = ary.length, v; i < len; i++) {
					v = ary[i];
					if (v.pool() == o.pool && v.declarator() == null) {
						return v.reuse(refnode);
					};
				};
			};
			
			// should only 'register' as ahidden variable, no?
			// if there are real nodes inside that tries to refer to vars
			// defined in outer scopes, we need to make sure they are not named after this
			var item = new SystemVariable(this,name,refnode,o);
			this._varpool.push(item); // WHAT? It should not be in the pool unless explicitly put there?
			this._vars.push(item); // WARN variables should not go directly into a declaration-list
			return item;
			// return register(name || "__",null,system: yes, temporary: yes)
		};
		
		
		
		Scope.prototype.lookup = function (name){
			var ret = null;
			name = helpers.symbolize(name);
			if (this._varmap.hasOwnProperty(name)) {
				ret = this._varmap[name];
			} else {
				// look up any parent scope ?? seems okay
				// !isClosed && 
				ret = this.parent() && this.parent().lookup(name);
				// or -- not all scopes have a parent?
			};
			
			// should this not happen by itself?
			// if !ret and 
			//	ret = 
			// ret ||= (g.lookup(name) if var g = root)
			// g = root
			return ret;
		};
		
		Scope.prototype.autodeclare = function (variable){
			return this.vars().push(variable); // only if it does not exist here!!!
		};
		
		Scope.prototype.free = function (variable){
			// p "free variable"
			variable.free(); // :owner = null
			// @varpool.push(variable)
			return this;
		};
		
		Scope.prototype.isClosed = function (){
			return false;
		};
		
		Scope.prototype.closure = function (){
			return this._closure;
		};
		
		Scope.prototype.finalize = function (){
			return this;
		};
		
		Scope.prototype.klass = function (){
			var scope = this;
			while (scope){
				scope = scope.parent();
				if (scope instanceof ClassScope) { return scope };
			};
			return null;
		};
		
		Scope.prototype.head = function (){
			return [this._vars,this._params];
		};
		
		Scope.prototype.c = function (o){
			var body;
			if(o === undefined) o = {};
			o.expression = false;
			// need to fix this
			this.node().body().setHead(this.head());
			return body = this.node().body().c(o);
			
			// var head = [@vars,@params].block.c(expression: no)
			// p "head from scope is ({head})"
			// var out = [head or null,body].flatten__.compact.join("\n")
			// out
			// out = '{' + out + 
		};
		
		Scope.prototype.region = function (){
			return this.node().body().region();
		};
		
		Scope.prototype.loc = function (){
			return this.node().loc();
		};
		
		Scope.prototype.dump = function (){
			var self = this;
			var vars = Object.keys(this._varmap).map(function(k) {
				var v = self._varmap[k];
				return v.references().length ? (dump__(v)) : (null);
			});
			
			var desc = {
				nr: self._nr,
				type: self.constructor.name,
				level: (self.level() || 0),
				vars: compact__(vars),
				loc: self.loc()
			};
			
			return desc;
		};
		
		Scope.prototype.toJSON = function (){
			return this.dump();
		};
		
		Scope.prototype.toString = function (){
			return ("" + (this.constructor.name));
		};
		
		
		// RootScope is wrong? Rather TopScope or ProgramScope
		function RootScope(){
			RootScope.__super__.constructor.apply(this,arguments);
			
			this.register('global',this,{type: 'global'});
			this.register('module',this,{type: 'global'});
			this.register('window',this,{type: 'global'});
			this.register('document',this,{type: 'global'});
			this.register('exports',this,{type: 'global'});
			this.register('console',this,{type: 'global'});
			this.register('process',this,{type: 'global'});
			this.register('parseInt',this,{type: 'global'});
			this.register('parseFloat',this,{type: 'global'});
			this.register('setTimeout',this,{type: 'global'});
			this.register('setInterval',this,{type: 'global'});
			this.register('clearTimeout',this,{type: 'global'});
			this.register('clearInterval',this,{type: 'global'});
			this.register('__dirname',this,{type: 'global'});
			
			// preregister global special variables here
			this._warnings = [];
			this._scopes = [];
			this._helpers = [];
			this._entities = new Entities(this);
			this._head = [this._vars];
		};
		
		subclass$(RootScope,Scope);
		exports.RootScope = RootScope; // export class 
		RootScope.prototype.warnings = function(v){ return this._warnings; }
		RootScope.prototype.setWarnings = function(v){ this._warnings = v; return this; };
		RootScope.prototype.scopes = function(v){ return this._scopes; }
		RootScope.prototype.setScopes = function(v){ this._scopes = v; return this; };
		RootScope.prototype.entities = function(v){ return this._entities; }
		RootScope.prototype.setEntities = function(v){ this._entities = v; return this; };
		
		RootScope.prototype.context = function (){
			return this._context || (this._context = new RootScopeContext(this));
		};
		
		RootScope.prototype.tagContextPath = function (){
			return this._tagContextPath || (this._tagContextPath = "tag$");
		};
		
		RootScope.prototype.lookup = function (name){
			// p "lookup filescope"
			name = helpers.symbolize(name);
			if (this._varmap.hasOwnProperty(name)) { return this._varmap[name] };
		};
		
		RootScope.prototype.visit = function (){
			STACK.addScope(this);
			return this;
		};
		
		RootScope.prototype.helper = function (typ,value){
			// log "add helper",typ,value
			if (this._helpers.indexOf(value) == -1) {
				this._helpers.push(value);
				this._head.unshift(value);
			};
			
			return this;
		};
		
		RootScope.prototype.head = function (){
			return this._head;
		};
		
		RootScope.prototype.warn = function (data){
			// hacky
			data.node = null;
			// p "warning",JSON.stringify(data)
			this._warnings.push(data);
			return this;
		};
		
		RootScope.prototype.dump = function (){
			var obj = {warnings: dump__(this._warnings)};
			
			if (OPTS.analysis.scopes) {
				var scopes = this._scopes.map(function(s) { return s.dump(); });
				scopes.unshift(RootScope.__super__.dump.call(this));
				obj.scopes = scopes;
			};
			
			if (OPTS.analysis.entities) {
				obj.entities = this._entities;
			};
			
			return obj;
		};
		
		
		function ClassScope(){ return Scope.apply(this,arguments) };
		
		subclass$(ClassScope,Scope);
		exports.ClassScope = ClassScope; // export class 
		ClassScope.prototype.namepath = function (){
			return this._node.namepath();
		};
		
		
		// called for scopes that are not real scopes in js
		// must ensure that the local variables inside of the scopes do not
		// collide with variables in outer scopes -- rename if needed
		ClassScope.prototype.virtualize = function (){
			// console.log "virtualizing ClassScope"
			var up = this.parent();
			for (var o = this._varmap, i = 0, keys = Object.keys(o), l = keys.length; i < l; i++){
				true;
				o[keys[i]].resolve(up,true); // force new resolve
			};
			return this;
		};
		
		ClassScope.prototype.isClosed = function (){
			return true;
		};
		
		function TagScope(){ return ClassScope.apply(this,arguments) };
		
		subclass$(TagScope,ClassScope);
		exports.TagScope = TagScope; // export class 
		
		
		function ClosureScope(){ return Scope.apply(this,arguments) };
		
		subclass$(ClosureScope,Scope);
		exports.ClosureScope = ClosureScope; // export class 
		
		
		function FunctionScope(){ return Scope.apply(this,arguments) };
		
		subclass$(FunctionScope,Scope);
		exports.FunctionScope = FunctionScope; // export class 
		
		
		function MethodScope(){ return Scope.apply(this,arguments) };
		
		subclass$(MethodScope,Scope);
		exports.MethodScope = MethodScope; // export class 
		MethodScope.prototype.isClosed = function (){
			return true;
		};
		
		function LambdaScope(){ return Scope.apply(this,arguments) };
		
		subclass$(LambdaScope,Scope);
		exports.LambdaScope = LambdaScope; // export class 
		LambdaScope.prototype.context = function (){
			
			// when accessing the outer context we need to make sure that it is cached
			// so this is wrong - but temp okay
			return this._context || (this._context = this.parent().context().reference(this));
		};
		
		function FlowScope(){ return Scope.apply(this,arguments) };
		
		subclass$(FlowScope,Scope);
		exports.FlowScope = FlowScope; // export class 
		FlowScope.prototype.params = function (){
			if (this._parent) { return this._parent.params() };
		};
		
		FlowScope.prototype.register = function (name,decl,o){
			var found;
			if(decl === undefined) decl = null;
			if(o === undefined) o = {};
			if (o.type != 'let' && (this.closure() != this)) {
				if (found = this.lookup(name)) {
					// p "already found variable {found.type}"
					if (found.type() == 'let') {
						this.p(("" + name + " already exists as a block-variable " + decl));
						// TODO should throw error instead
						if (decl) { decl.warn("Variable already exists in block") };
						// root.warn message: "Holy shit"
					};
					// if found.
				};
				// p "FlowScope register var -- do it right in the outer scope"
				return this.closure().register(name,decl,o);
			} else {
				// p "Register local variable for FlowScope {name}"
				// o:closure = parent
				// p "FlowScope register", arguments
				return FlowScope.__super__.register.call(this,name,decl,o);
			};
		};
		
		// FIXME should override temporary as well
		
		FlowScope.prototype.autodeclare = function (variable){
			return this.parent().autodeclare(variable);
		};
		
		FlowScope.prototype.closure = function (){
			// rather all the way?
			return this._parent.closure(); // this is important?
		};
		
		FlowScope.prototype.context = function (){
			// if we are wrapping in an expression - we do need to add a reference
			// @referenced = yes
			return this.parent().context();
			// usually - if the parent scope is a closed scope we dont really need
			// to force a reference
			// @context ||= parent.context.reference(self)
		};
		
		function CatchScope(){ return FlowScope.apply(this,arguments) };
		
		subclass$(CatchScope,FlowScope);
		exports.CatchScope = CatchScope; // export class 
		
		
		function WhileScope(){ return FlowScope.apply(this,arguments) };
		
		subclass$(WhileScope,FlowScope);
		exports.WhileScope = WhileScope; // export class 
		WhileScope.prototype.autodeclare = function (variable){
			return this.vars().push(variable);
		};
		
		function ForScope(){ return FlowScope.apply(this,arguments) };
		
		subclass$(ForScope,FlowScope);
		exports.ForScope = ForScope; // export class 
		ForScope.prototype.autodeclare = function (variable){
			return this.vars().push(variable);
			// parent.autodeclare(variable)
		};
		
		// def closure
		// 	self
		;
		
		function IfScope(){ return FlowScope.apply(this,arguments) };
		
		subclass$(IfScope,FlowScope);
		exports.IfScope = IfScope; // export class 
		IfScope.prototype.temporary = function (refnode,o,name){
			if(o === undefined) o = {};
			if(name === undefined) name = null;
			return this.parent().temporary(refnode,o,name);
		};
		
		function BlockScope(){ return FlowScope.apply(this,arguments) };
		
		subclass$(BlockScope,FlowScope);
		exports.BlockScope = BlockScope; // export class 
		BlockScope.prototype.temporary = function (refnode,o,name){
			if(o === undefined) o = {};
			if(name === undefined) name = null;
			return this.parent().temporary(refnode,o,name);
		};
		
		BlockScope.prototype.region = function (){
			return this.node().region();
		};
		
		// lives in scope -- really a node???
		function Variable(scope,name,decl,o){
			this._ref = STACK._counter++;
			this._c = null;
			this._scope = scope;
			this._name = name;
			this._alias = null;
			this._initialized = true;
			this._declarator = decl;
			this._autodeclare = false;
			this._declared = o && o.declared || false;
			this._resolved = false;
			this._options = o || {};
			this._type = o && o.type || 'var'; // what about let here=
			this._export = false;
			this._references = []; // only needed when profiling
			this._assignments = [];
			this;
		};
		
		subclass$(Variable,Node);
		exports.Variable = Variable; // export class 
		Variable.prototype.scope = function(v){ return this._scope; }
		Variable.prototype.setScope = function(v){ this._scope = v; return this; };
		Variable.prototype.name = function(v){ return this._name; }
		Variable.prototype.setName = function(v){ this._name = v; return this; };
		Variable.prototype.alias = function(v){ return this._alias; }
		Variable.prototype.setAlias = function(v){ this._alias = v; return this; };
		Variable.prototype.type = function(v){ return this._type; }
		Variable.prototype.setType = function(v){ this._type = v; return this; };
		Variable.prototype.options = function(v){ return this._options; }
		Variable.prototype.setOptions = function(v){ this._options = v; return this; };
		Variable.prototype.initialized = function(v){ return this._initialized; }
		Variable.prototype.setInitialized = function(v){ this._initialized = v; return this; };
		Variable.prototype.declared = function(v){ return this._declared; }
		Variable.prototype.setDeclared = function(v){ this._declared = v; return this; };
		Variable.prototype.declarator = function(v){ return this._declarator; }
		Variable.prototype.setDeclarator = function(v){ this._declarator = v; return this; };
		Variable.prototype.autodeclare = function(v){ return this._autodeclare; }
		Variable.prototype.setAutodeclare = function(v){ this._autodeclare = v; return this; };
		Variable.prototype.references = function(v){ return this._references; }
		Variable.prototype.setReferences = function(v){ this._references = v; return this; };
		Variable.prototype.export = function(v){ return this._export; }
		Variable.prototype.setExport = function(v){ this._export = v; return this; };
		
		Variable.prototype.pool = function (){
			return null;
		};
		
		Variable.prototype.closure = function (){
			return this._scope.closure();
		};
		
		Variable.prototype.assignments = function (){
			return this._assignments;
		};
		
		// Here we can collect lots of type-info about variables
		// and show warnings / give advice if variables are ambiguous etc
		Variable.prototype.assigned = function (val,source){
			this._assignments.push(val);
			// p "Variable was assigned {val}"
			if (val instanceof Arr) {
				// just for testing really
				this._isArray = true;
			} else {
				this._isArray = false;
			};
			return this;
		};
		
		Variable.prototype.resolve = function (scope,force){
			if(scope === undefined) scope = this.scope();
			if(force === undefined) force = false;
			if (this._resolved && !(force)) { return this };
			
			this._resolved = true;
			var closure = this._scope.closure();
			var item = scope.lookup(this._name);
			
			// if this is a let-definition inside a virtual scope we do need
			// 
			if (this._scope != closure && this._type == 'let') { // or if it is a system-variable
				// p "scope is not the closure -- need to resolve {@name}"
				item = closure.lookup(this._name);
				
				// we now need to ensure that this variable is unique inside
				// the whole closure.
				scope = closure;
			};
			
			// p "scope is not the closure -- need to resolve {@name} {@type}"
			
			if (item == this) {
				scope.varmap()[this._name] = this;
				return this;
			} else if (item) {
				// p "variable already exists {@name}"
				
				// possibly redefine this inside, use it only in this scope
				// if the item is defined in an outer scope - we reserve the
				if (item.scope() != scope && (this.options().let || this._type == 'let')) {
					// p "override variable inside this scope {@name}"
					scope.varmap()[this._name] = this;
				};
				
				// different rules for different variables?
				if (this._options.proxy) {
					// p "is proxy -- no need to change name!!! {name}".cyan
					true;
				} else {
					var i = 0;
					var orig = this._name;
					// it is the closure that we should use
					while (scope.lookup(this._name)){
						this._name = ("" + orig + (i += 1));
					};
				};
			};
			
			// inefficient double setting
			scope.varmap()[this._name] = this;
			closure.varmap()[this._name] = this;
			return this;
			// p "resolve variable".cyan
		};
		
		Variable.prototype.reference = function (){
			return this;
		};
		
		Variable.prototype.node = function (){
			return this;
		};
		
		Variable.prototype.traverse = function (){
			// NODES.push(self)
			return this;
		};
		
		Variable.prototype.free = function (ref){
			// p "free variable!"
			this._declarator = null;
			return this;
		};
		
		Variable.prototype.reuse = function (ref){
			this._declarator = ref;
			return this;
		};
		
		Variable.prototype.proxy = function (par,index){
			this._proxy = [par,index];
			return this;
		};
		
		Variable.prototype.refcount = function (){
			return this._references.length;
		};
		
		Variable.prototype.c = function (){
			if (this._c) { return this._c };
			// options - proxy??
			if (this._proxy) {
				// p "var is proxied!",@proxy
				this._c = this._proxy[0].c() + '[' + this._proxy[1].c() + ']';
			} else {
				if (!this._resolved) this.resolve();
				var v = (this.alias() || this.name());
				this._c = typeof v == 'string' ? (v) : (v.c());
				// allow certain reserved words
				// should warn on others though (!!!)
				// if @c == 'new'
				// 	@c = '_new'
				// 	# should happen at earlier stage to
				// 	# get around naming conventions
				if (RESERVED_REGEX.test(this._c)) { this._c = ("" + this.c() + "$") }; // @c.match(/^(default)$/)
			};
			return this._c;
		};
		
		// variables should probably inherit from node(!)
		Variable.prototype.consume = function (node){
			// p "variable assignify!!!"
			return this;
		};
		
		// this should only generate the accessors - not dael with references
		Variable.prototype.accessor = function (ref){
			var node = new LocalVarAccess(".",null,this); // this is just wrong .. should not be a regular accessor
			// @references.push([ref,el]) if ref # weird temp format
			return node;
		};
		
		Variable.prototype.assignment = function (val){
			return new Assign('=',this,val);
		};
		
		Variable.prototype.addReference = function (ref){
			if (ref instanceof Identifier) {
				ref.references(this);
			};
			
			if (ref.region && ref.region()) {
				this._references.push(ref);
			};
			
			// p "reference is {ref:region and ref.region}"
			return this;
		};
		
		Variable.prototype.autodeclare = function (){
			if (this._declared) { return this };
			// p "variable should autodeclare(!) {name}"
			this._autodeclare = true;
			this.scope().autodeclare(this);
			this._declared = true;
			return this;
		};
		
		Variable.prototype.predeclared = function (){
			this._declared = true;
			return this;
		};
		
		
		Variable.prototype.toString = function (){
			return String(this.name());
		};
		
		Variable.prototype.dump = function (typ){
			var name = this.name();
			if (name[0].match(/[A-Z]/)) { return null };
			// console.log "dump variable of type {type} - {name}"
			return {
				type: this.type(),
				name: name,
				refs: dump__(this._references,typ)
			};
		};
		
		
		function SystemVariable(){ return Variable.apply(this,arguments) };
		
		subclass$(SystemVariable,Variable);
		exports.SystemVariable = SystemVariable; // export class 
		SystemVariable.prototype.pool = function (){
			return this._options.pool;
		};
		
		// weird name for this
		SystemVariable.prototype.predeclared = function (){
			// p "remove var from scope(!)"
			this.scope().vars().remove(this);
			return this;
		};
		
		SystemVariable.prototype.resolve = function (){
			var alias, v_;
			if (this._resolved || this._name) { return this };
			// p "RESOLVE SYSTEM VARIABLE".red
			this._resolved = true;
			// unless @name
			// adds a very random initial name
			// the auto-magical goes last, or at least, possibly reuse other names
			// "${Math.floor(Math.random * 1000)}"
			
			var typ = this._options.pool;
			var names = [].concat(this._options.names);
			var alt = null;
			var node = null;
			
			var scope = this.scope();
			
			if (typ == 'tag') {
				var i = 0;
				while (!this._name){
					alt = ("t" + (i++));
					if (!scope.lookup(alt)) { this._name = alt };
				};
			} else if (typ == 'iter') {
				names = ['ary__','ary_','coll','array','items','ary'];
			} else if (typ == 'val') {
				names = ['v_'];
			} else if (typ == 'arguments') {
				names = ['$_','$0'];
			} else if (typ == 'keypars') {
				names = ['opts','options','pars'];
			} else if (typ == 'counter') {
				names = ['i__','i_','k','j','i'];
			} else if (typ == 'len') {
				names = ['len__','len_','len'];
			} else if (typ == 'list') {
				names = ['tmplist_','tmplist','tmp'];
			};
			// or if type placeholder / cacher (add 0)
			
			while (!this._name && (alt = names.pop())){
				if (!scope.lookup(alt)) { this._name = alt };
			};
			
			if (!this._name && this._declarator) {
				if (node = this.declarator().node()) {
					if (alias = node.alias()) { names.push(alias + "_") };
				};
			};
			
			while (!this._name && (alt = names.pop())){
				if (!scope.lookup(alt)) { this._name = alt };
			};
			
			// p "suggested names {names.join(" , ")} {node}".cyan
			//  Math.floor(Math.random * 1000)
			this._name || (this._name = ("$" + (scope.setCounter(v_ = scope.counter() + 1),v_)));
			// p "name for variable is {@name}"
			scope.varmap()[this._name] = this;
			return this;
		};
		
		SystemVariable.prototype.name = function (){
			this.resolve();
			return this._name;
		};
		
		
		function ScopeContext(scope,value){
			this._scope = scope;
			this._value = value;
			this._reference = null;
			this;
		};
		
		subclass$(ScopeContext,Node);
		exports.ScopeContext = ScopeContext; // export class 
		ScopeContext.prototype.scope = function(v){ return this._scope; }
		ScopeContext.prototype.setScope = function(v){ this._scope = v; return this; };
		ScopeContext.prototype.value = function(v){ return this._value; }
		ScopeContext.prototype.setValue = function(v){ this._value = v; return this; };
		
		ScopeContext.prototype.namepath = function (){
			return this._scope.namepath();
		};
		
		// instead of all these references we should probably
		// just register when it is accessed / looked up from
		// a deeper function-scope, and when it is, we should
		// register the variable in scope, and then start to
		// use that for further references. Might clean things
		// up for the cases where we have yet to decide the
		// name of the variable etc?
		
		ScopeContext.prototype.reference = function (){
			// p "p reference {STACK.scoping}"
			// should be a special context-variable!!!
			return this._reference || (this._reference = this.scope().declare("self",new This()));
		};
		
		ScopeContext.prototype.c = function (){
			var val = this._value || this._reference;
			return val ? (val.c()) : ("this");
		};
		
		ScopeContext.prototype.cache = function (){
			return this;
		};
		
		function RootScopeContext(){ return ScopeContext.apply(this,arguments) };
		
		subclass$(RootScopeContext,ScopeContext);
		exports.RootScopeContext = RootScopeContext; // export class 
		RootScopeContext.prototype.c = function (o){
			// return "" if o and o:explicit
			var val = this._value || this._reference;
			return (val && val != this) ? (val.c()) : ("this");
			// should be the other way around, no?
			// o and o:explicit ? super : ""
		};
		
		function Super(){ return Node.apply(this,arguments) };
		
		subclass$(Super,Node);
		exports.Super = Super; // export class 
		Super.prototype.c = function (){
			// need to find the stuff here
			// this is really not that good8
			var m = STACK.method();
			var out = null;
			var up = STACK.current();
			var deep = (up instanceof Access);
			
			// TODO optimization for later - problematic if there is a different reference in the end
			if (false) {
				out = ("" + (m.target().c()) + ".superclass");
				if (!(deep)) { out += (".apply(" + (m.scope().context().c()) + ",arguments)") };
			} else {
				out = ("" + (m.target().c()) + ".__super__");
				if (!((up instanceof Access))) {
					out += ("." + c__(m.supername()));
					if (!((up instanceof Call))) { // autocall?
						out += (".apply(" + (m.scope().context().c()) + ",arguments)");
					};
				};
			};
			return out;
		};
		
		// constants
		
		module.exports.BR = BR = new Newline('\n');
		module.exports.BR2 = BR2 = new Newline('\n\n');
		module.exports.SELF = SELF = new Self();
		module.exports.SUPER = SUPER = new Super();
		
		module.exports.TRUE = TRUE = new True('true');
		module.exports.FALSE = FALSE = new False('false');
		module.exports.UNDEFINED = UNDEFINED = new Undefined();
		module.exports.NIL = NIL = new Nil();
		
		module.exports.ARGUMENTS = ARGUMENTS = new ArgsReference('arguments');
		module.exports.EMPTY = EMPTY = '';
		module.exports.NULL = NULL = 'null';
		
		module.exports.RESERVED = RESERVED = ['default','native','enum','with'];
		module.exports.RESERVED_REGEX = RESERVED_REGEX = /^(default|native|enum|with|new|char)$/;
		
		module.exports.UNION = UNION = new Const('union$');
		module.exports.INTERSECT = INTERSECT = new Const('intersect$');
		module.exports.CLASSDEF = CLASSDEF = new Const('imba$class');
		module.exports.TAGDEF = TAGDEF = new Const('Imba.TAGS.define');
		return module.exports.NEWTAG = NEWTAG = new Identifier("tag$");
		
		
		
		
		
		
		
		
		
		

	})()

/***/ },
/* 9 */
/***/ function(module, exports) {

	(function(){
		
		function brace(str){
			var lines = str.match(/\n/);
			// what about indentation?
			
			if (lines) {
				return '{' + str + '\n}';
			} else {
				return '{\n' + str + '\n}';
			};
		}; exports.brace = brace;
		
		function normalizeIndentation(str){
			var m;
			var reg = /\n+([^\n\S]*)/g;
			var ind = null;
			
			var length_;while (m = reg.exec(str)){
				var attempt = m[1];
				if (ind == null || 0 < (length_ = attempt.length) && length_ < ind.length) {
					ind = attempt;
				};
			};
			
			if (ind) { str = str.replace(RegExp(("\\n" + ind),"g"),'\n') };
			return str;
		}; exports.normalizeIndentation = normalizeIndentation;
		
		
		function flatten(arr){
			var out = [];
			arr.forEach(function(v) { return v instanceof Array ? (out.push.apply(out,flatten(v))) : (out.push(v)); });
			return out;
		}; exports.flatten = flatten;
		
		
		function pascalCase(str){
			return str.replace(/(^|[\-\_\s])(\w)/g,function(m,v,l) { return l.toUpperCase(); });
		}; exports.pascalCase = pascalCase;
		
		function camelCase(str){
			str = String(str);
			// should add shortcut out
			return str.replace(/([\-\_\s])(\w)/g,function(m,v,l) { return l.toUpperCase(); });
		}; exports.camelCase = camelCase;
		
		function snakeCase(str){
			var str = str.replace(/([\-\s])(\w)/g,'_');
			return str.replace(/()([A-Z])/g,"_$1",function(m,v,l) { return l.toUpperCase(); });
		}; exports.snakeCase = snakeCase;
		
		function setterSym(sym){
			return camelCase(("set-" + sym));
		}; exports.setterSym = setterSym;
		
		function quote(str){
			return '"' + str + '"';
		}; exports.quote = quote;
		
		function singlequote(str){
			return "'" + str + "'";
		}; exports.singlequote = singlequote;
		
		function symbolize(str){
			str = String(str);
			var end = str.charAt(str.length - 1);
			
			if (end == '=') {
				str = 'set' + str[0].toUpperCase() + str.slice(1,-1);
			};
			
			if (str.indexOf("-") >= 0) {
				str = str.replace(/([\-\s])(\w)/g,function(m,v,l) { return l.toUpperCase(); });
			};
			
			return str;
		}; exports.symbolize = symbolize;
		
		
		function indent(str){
			return String(str).replace(/^/g,"\t").replace(/\n/g,"\n\t").replace(/\n\t$/g,"\n");
		}; exports.indent = indent;
		
		function bracketize(str,ind){
			if(ind === undefined) ind = true;
			if (ind) { str = "\n" + indent(str) + "\n" };
			return '{' + str + '}';
		}; exports.bracketize = bracketize;
		
		function parenthesize(str){
			return '(' + String(str) + ')';
		}; exports.parenthesize = parenthesize;
		
		function locationToLineColMap(code){
			var lines = code.split(/\n/g);
			var map = [];
			
			var chr;
			var loc = 0;
			var col = 0;
			var line = 0;
			
			while (chr = code[loc]){
				map[loc] = [line,col];
				
				if (chr == '\n') {
					line++;
					col = 0;
				} else {
					col++;
				};
				
				loc++;
			};
			
			return map;
		}; exports.locationToLineColMap = locationToLineColMap;
		
		function markLineColForTokens(tokens,code){
			return this;
		}; exports.markLineColForTokens = markLineColForTokens;; return markLineColForTokens;

	})()

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		
		var path = __webpack_require__(11);
		var util = __webpack_require__(9);
		
		function SourceMap(source){
			this._source = source;
			this._maps = [];
			this._map = "";
			this._js = "";
		};
		
		exports.SourceMap = SourceMap; // export class 
		SourceMap.prototype.source = function (){
			return this._source;
		};
		
		SourceMap.prototype.options = function (){
			return this._source;
		};
		
		SourceMap.prototype.filename = function (){
			return this.options().options.filename;
		};
		
		SourceMap.prototype.sourceCode = function (){
			return this.options().options._source;
		};
		
		SourceMap.prototype.targetPath = function (){
			return this.options().options.targetPath;
		};
		
		SourceMap.prototype.sourcePath = function (){
			return this.options().options.sourcePath;
		};
		
		SourceMap.prototype.sourceName = function (){
			return path.basename(this.sourcePath());
		};
		
		SourceMap.prototype.targetName = function (){
			return path.basename(this.targetPath());
		};
		
		
		SourceMap.prototype.sourceFiles = function (){
			return [this.sourceName()];
		};
		
		SourceMap.prototype.parse = function (){
			var self = this;
			var matcher = /\%\$(\d*)\$\%/;
			var replacer = /^(.*?)\%\$(\d*)\$\%/;
			var lines = this.options().js.split(/\n/g); // what about js?
			// return self
			var locmap = util.locationToLineColMap(this.sourceCode());
			this._maps = [];
			
			// console.log options:js
			
			var match;
			// split the code in lines. go through each line 
			// go through the code looking for LOC markers
			// remove markers along the way and keep track of
			// console.log source:js
			
			for (var i = 0, ary = iter$(lines), len = ary.length, line; i < len; i++) {
				// could split on these?
				line = ary[i];
				var col = 0;
				var caret = 0;
				
				this._maps[i] = [];
				while (line.match(matcher)){
					line = line.replace(replacer,function(m,pre,loc) {
						var lc = locmap[parseInt(loc)];
						caret = pre.length;
						var mapping = [[lc[0],lc[1]],[i,caret]]; // source and output
						self._maps[i].push(mapping);
						return pre;
					});
				};
				lines[i] = line;
			};
			
			
			self.source().js = lines.join('\n');
			return self;
		};
		
		SourceMap.prototype.generate = function (){
			this.parse();
			
			var lastColumn = 0;
			var lastSourceLine = 0;
			var lastSourceColumn = 0;
			var buffer = "";
			
			for (var lineNumber = 0, ary = iter$(this._maps), len = ary.length; lineNumber < len; lineNumber++) {
				lastColumn = 0;
				
				for (var nr = 0, items = iter$(ary[lineNumber]), len_ = items.length, map1; nr < len_; nr++) {
					map1 = items[nr];
					if (nr != 0) { buffer += ',' };
					var src = map1[0];
					var dest = map1[1];
					
					buffer += this.encodeVlq(dest[1] - lastColumn);
					lastColumn = dest[1];
					// add index
					buffer += this.encodeVlq(0);
					
					// The starting line in the original source, relative to the previous source line.
					buffer += this.encodeVlq(src[0] - lastSourceLine);
					lastSourceLine = src[0];
					// The starting column in the original source, relative to the previous column.
					buffer += this.encodeVlq(src[1] - lastSourceColumn);
					lastSourceColumn = src[1];
				};
				
				buffer += ";";
			};
			
			
			var rel = path.relative(path.dirname(this.targetPath()),this.sourcePath());
			
			var map = {
				version: 3,
				file: this.sourceName().replace(/\.imba/,'.js') || '',
				sourceRoot: this.options().sourceRoot || '',
				sources: [rel],
				sourcesContent: [this.sourceCode()],
				names: [],
				mappings: buffer
			};
			
			// source:sourcemap = sourcemap
			// var base64 = Buffer.new(JSON.stringify(map)).toString("base64")
			// source:js += "\n//# sourceMappingURL=data:application/json;base64,{base64}"
			return map;
		};
		
		VLQ_SHIFT = 5;
		VLQ_CONTINUATION_BIT = 1 << VLQ_SHIFT;
		VLQ_VALUE_MASK = VLQ_CONTINUATION_BIT - 1;
		BASE64_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
		
		// borrowed from CoffeeScript
		SourceMap.prototype.encodeVlq = function (value){
			var answer = '';
			// Least significant bit represents the sign.
			var signBit = value < 0 ? (1) : (0);
			var nextChunk;
			// The next bits are the actual value.
			var valueToEncode = (Math.abs(value) << 1) + signBit;
			// Make sure we encode at least one character, even if valueToEncode is 0.
			while (valueToEncode || !(answer)){
				nextChunk = valueToEncode & VLQ_VALUE_MASK;
				valueToEncode = valueToEncode >> VLQ_SHIFT;
				if (valueToEncode) {
					nextChunk |= VLQ_CONTINUATION_BIT;
				};
				
				answer += this.encodeBase64(nextChunk);
			};
			
			return answer;
		};
		
		SourceMap.prototype.encodeBase64 = function (value){
			return BASE64_CHARS[value]; // or throw Error.new("Cannot Base64 encode value: {value}")
		};
		return SourceMap;
		
		

	})()

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// resolves . and .. elements in a path array with directory names there
	// must be no slashes, empty elements, or device names (c:\) in the array
	// (so also no leading and trailing slashes - it does not distinguish
	// relative and absolute paths)
	function normalizeArray(parts, allowAboveRoot) {
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = parts.length - 1; i >= 0; i--) {
	    var last = parts[i];
	    if (last === '.') {
	      parts.splice(i, 1);
	    } else if (last === '..') {
	      parts.splice(i, 1);
	      up++;
	    } else if (up) {
	      parts.splice(i, 1);
	      up--;
	    }
	  }
	
	  // if the path is allowed to go above the root, restore leading ..s
	  if (allowAboveRoot) {
	    for (; up--; up) {
	      parts.unshift('..');
	    }
	  }
	
	  return parts;
	}
	
	// Split a filename into [root, dir, basename, ext], unix version
	// 'root' is just a slash, or nothing.
	var splitPathRe =
	    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
	var splitPath = function(filename) {
	  return splitPathRe.exec(filename).slice(1);
	};
	
	// path.resolve([from ...], to)
	// posix version
	exports.resolve = function() {
	  var resolvedPath = '',
	      resolvedAbsolute = false;
	
	  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
	    var path = (i >= 0) ? arguments[i] : process.cwd();
	
	    // Skip empty and invalid entries
	    if (typeof path !== 'string') {
	      throw new TypeError('Arguments to path.resolve must be strings');
	    } else if (!path) {
	      continue;
	    }
	
	    resolvedPath = path + '/' + resolvedPath;
	    resolvedAbsolute = path.charAt(0) === '/';
	  }
	
	  // At this point the path should be resolved to a full absolute path, but
	  // handle relative paths to be safe (might happen when process.cwd() fails)
	
	  // Normalize the path
	  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
	    return !!p;
	  }), !resolvedAbsolute).join('/');
	
	  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
	};
	
	// path.normalize(path)
	// posix version
	exports.normalize = function(path) {
	  var isAbsolute = exports.isAbsolute(path),
	      trailingSlash = substr(path, -1) === '/';
	
	  // Normalize the path
	  path = normalizeArray(filter(path.split('/'), function(p) {
	    return !!p;
	  }), !isAbsolute).join('/');
	
	  if (!path && !isAbsolute) {
	    path = '.';
	  }
	  if (path && trailingSlash) {
	    path += '/';
	  }
	
	  return (isAbsolute ? '/' : '') + path;
	};
	
	// posix version
	exports.isAbsolute = function(path) {
	  return path.charAt(0) === '/';
	};
	
	// posix version
	exports.join = function() {
	  var paths = Array.prototype.slice.call(arguments, 0);
	  return exports.normalize(filter(paths, function(p, index) {
	    if (typeof p !== 'string') {
	      throw new TypeError('Arguments to path.join must be strings');
	    }
	    return p;
	  }).join('/'));
	};
	
	
	// path.relative(from, to)
	// posix version
	exports.relative = function(from, to) {
	  from = exports.resolve(from).substr(1);
	  to = exports.resolve(to).substr(1);
	
	  function trim(arr) {
	    var start = 0;
	    for (; start < arr.length; start++) {
	      if (arr[start] !== '') break;
	    }
	
	    var end = arr.length - 1;
	    for (; end >= 0; end--) {
	      if (arr[end] !== '') break;
	    }
	
	    if (start > end) return [];
	    return arr.slice(start, end - start + 1);
	  }
	
	  var fromParts = trim(from.split('/'));
	  var toParts = trim(to.split('/'));
	
	  var length = Math.min(fromParts.length, toParts.length);
	  var samePartsLength = length;
	  for (var i = 0; i < length; i++) {
	    if (fromParts[i] !== toParts[i]) {
	      samePartsLength = i;
	      break;
	    }
	  }
	
	  var outputParts = [];
	  for (var i = samePartsLength; i < fromParts.length; i++) {
	    outputParts.push('..');
	  }
	
	  outputParts = outputParts.concat(toParts.slice(samePartsLength));
	
	  return outputParts.join('/');
	};
	
	exports.sep = '/';
	exports.delimiter = ':';
	
	exports.dirname = function(path) {
	  var result = splitPath(path),
	      root = result[0],
	      dir = result[1];
	
	  if (!root && !dir) {
	    // No dirname whatsoever
	    return '.';
	  }
	
	  if (dir) {
	    // It has a dirname, strip trailing slash
	    dir = dir.substr(0, dir.length - 1);
	  }
	
	  return root + dir;
	};
	
	
	exports.basename = function(path, ext) {
	  var f = splitPath(path)[2];
	  // TODO: make this comparison case-insensitive on windows?
	  if (ext && f.substr(-1 * ext.length) === ext) {
	    f = f.substr(0, f.length - ext.length);
	  }
	  return f;
	};
	
	
	exports.extname = function(path) {
	  return splitPath(path)[3];
	};
	
	function filter (xs, f) {
	    if (xs.filter) return xs.filter(f);
	    var res = [];
	    for (var i = 0; i < xs.length; i++) {
	        if (f(xs[i], i, xs)) res.push(xs[i]);
	    }
	    return res;
	}
	
	// String.prototype.substr - negative index don't work in IE8
	var substr = 'ab'.substr(-1) === 'b'
	    ? function (str, start, len) { return str.substr(start, len) }
	    : function (str, start, len) {
	        if (start < 0) start = str.length + start;
	        return str.substr(start, len);
	    }
	;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYWEwOTE0ODA4MjQ4YjQxZjYxNDEiLCJ3ZWJwYWNrOi8vL3NyYy9jb21waWxlci93b3JrZXIuaW1iYSIsIndlYnBhY2s6Ly8vc3JjL2NvbXBpbGVyL2Vycm9ycy5pbWJhIiwid2VicGFjazovLy9zcmMvY29tcGlsZXIvbGV4ZXIuaW1iYSIsIndlYnBhY2s6Ly8vc3JjL2NvbXBpbGVyL3Rva2VuLmltYmEiLCJ3ZWJwYWNrOi8vL3NyYy9jb21waWxlci9yZXdyaXRlci5pbWJhIiwid2VicGFjazovLy8uL2xpYi9jb21waWxlci9wYXJzZXIuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL34vbm9kZS1saWJzLWJyb3dzZXIvfi9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy9jb21waWxlci9ub2Rlcy5pbWJhIiwid2VicGFjazovLy9zcmMvY29tcGlsZXIvaGVscGVycy5pbWJhIiwid2VicGFjazovLy9zcmMvY29tcGlsZXIvc291cmNlbWFwLmltYmEiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9+L25vZGUtbGlicy1icm93c2VyL34vcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs4Q0NwQ087O01BRUgsTUFBTSxFQUFFO01BQ1IsU0FBUyxFQUFFO01BQ1gsT0FBTyxFQUFFO01BQ1QsSUFBSSxFQUFFOzs7TUFHTixJQUFJLE9BQUUsTUFBTTtNQUNaLFNBQVMsRUFBRSxTQUFTOztF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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9kaXN0L2ltYmFjLndvcmtlci5kZXYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHdlYnBhY2svYm9vdHN0cmFwIGFhMDkxNDgwODI0OGI0MWY2MTQxXG4gKiovIiwiZXh0ZXJuIHBvc3RNZXNzYWdlXG5cbmltcG9ydCBJbWJhUGFyc2VFcnJvciBmcm9tICcuL2Vycm9ycydcblxudmFyIGxleGVyID0gcmVxdWlyZSAnLi9sZXhlcidcbnZhciByZXdyaXRlciA9IHJlcXVpcmUgJy4vcmV3cml0ZXInXG52YXIgcGFyc2VyID0gcmVxdWlyZSgnLi4vLi4vbGliL2NvbXBpbGVyL3BhcnNlcicpWydwYXJzZXInXVxudmFyIGFzdCA9IHJlcXVpcmUgJy4vbm9kZXMnXG5cbiMgSW5zdGFudGlhdGUgYSBMZXhlciBmb3Igb3VyIHVzZSBoZXJlLlxudmFyIGxleCA9IGxleGVyLkxleGVyLm5ld1xudmFyIFJld3JpdGVyID0gcmV3cml0ZXIuUmV3cml0ZXJcblxucGFyc2VyOmxleGVyID0gbGV4Lmppc29uQnJpZGdlXG5wYXJzZXI6eXkgPSBhc3QgIyBldmVyeXRoaW5nIGlzIGV4cG9ydGVkIHJpZ2h0IGhlcmUgbm93XG5cbnZhciBhcGkgPSB7fVxuXG5kZWYgYXBpLnRva2VuaXplIGNvZGUsIG8gPSB7fVxuXHR0cnlcblx0XHRvLkBzb3VyY2UgPSBjb2RlXG5cdFx0bGV4LnJlc2V0XG5cdFx0bGV4LnRva2VuaXplIGNvZGUsIG9cblx0Y2F0Y2ggZXJyXG5cdFx0IyBtYWtlcyBubyBzZW5zZT9cblx0XHR0aHJvdyBlcnJcblxuZGVmIGFwaS5wYXJzZSBjb2RlLCBvID0ge31cblx0IyBjb2RlIHdpbGwgbmV2ZXIgYmUgYW4gYXJyYXkgaW4gd29ya2VyP1xuXHR2YXIgdG9rZW5zID0gY29kZSBpc2EgQXJyYXkgPyBjb2RlIDogYXBpLnRva2VuaXplKGNvZGUsbylcblxuXHR0cnlcblx0XHRvLkBzb3VyY2UgPSBjb2RlXG5cdFx0by5AdG9rZW5zID0gdG9rZW5zXG5cdFx0cmV0dXJuIHBhcnNlci5wYXJzZSh0b2tlbnMpXG5cblx0Y2F0Y2ggZXJyXG5cdFx0ZXJyOl9maWxlbmFtZSA9IG86ZmlsZW5hbWUgaWYgbzpmaWxlbmFtZVxuXHRcdHRocm93IGVyclxuXG5cbmRlZiBhcGkuY29tcGlsZSBjb2RlLCBvID0ge31cblx0dHJ5XG5cdFx0IyBjb25zb2xlLmxvZyAndHJ5IGNvbXBpbGUnXG5cdFx0dmFyIGFzdCA9IGFwaS5wYXJzZShjb2RlLG8pXG5cdFx0dmFyIHJlcyA9IGFzdC5jb21waWxlKG8pXG5cdFx0cmV0dXJuIHtjb2RlOiByZXMudG9TdHJpbmcsIHNvdXJjZW1hcDogcmVzOnNvdXJjZW1hcH1cblxuXHRjYXRjaCBlXG5cdFx0IyBjb25zb2xlLmxvZyAnY29tcGlsZSBlcnJvcicsZTptZXNzYWdlXG5cdFx0IyBub3JtYWxpemUgc29tZXdoZXJlIGVsc2Vcblx0XHR1bmxlc3MgZSBpc2EgSW1iYVBhcnNlRXJyb3Jcblx0XHRcdGlmIGU6bGV4ZXJcblx0XHRcdFx0ZSA9IEltYmFQYXJzZUVycm9yLm5ldyhlLCB0b2tlbnM6IGU6bGV4ZXI6dG9rZW5zLCBwb3M6IGU6bGV4ZXI6cG9zKVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRlID0ge21lc3NhZ2U6IGU6bWVzc2FnZX1cblxuXHRcdGUgPSBlLnRvSlNPTiBpZiBlIGlzYSBJbWJhUGFyc2VFcnJvclxuXG5cdFx0cmV0dXJuIHtlcnJvcjogZX1cblxuZGVmIGFwaS5hbmFseXplIGNvZGUsIG8gPSB7fVxuXHR2YXIgbWV0YVxuXHR0cnlcblx0XHR2YXIgYXN0ID0gcGFyc2UoY29kZSxvKVxuXHRcdG1ldGEgPSBhc3QuYW5hbHl6ZShsb2dsZXZlbDogMClcblx0Y2F0Y2ggZVxuXHRcdCMgY29uc29sZS5sb2cgXCJzb21ldGhpbmcgd3Jvbmcge2U6bWVzc2FnZX1cIlxuXHRcdHVubGVzcyBlIGlzYSBJbWJhUGFyc2VFcnJvclxuXHRcdFx0aWYgZTpsZXhlclxuXHRcdFx0XHRlID0gSW1iYVBhcnNlRXJyb3IubmV3KGUsIHRva2VuczogZTpsZXhlcjp0b2tlbnMsIHBvczogZTpsZXhlcjpwb3MpXG5cdFx0XHRlbHNlXG5cdFx0XHRcdGUgPSB7bWVzc2FnZTogZTptZXNzYWdlfVxuXG5cdFx0ZSA9IGUudG9KU09OIGlmIGUgaXNhIEltYmFQYXJzZUVycm9yXG5cdFx0XG5cdFx0bWV0YSA9IHt3YXJuaW5nczogW2VdfVxuXHRyZXR1cm4gbWV0YVxuXG5cbmdsb2JhbCBkZWYgb25tZXNzYWdlIGVcblx0IyBjb25zb2xlLmxvZyAnbWVzc2FnZSB0byB3ZWJ3b3JrZXInXG5cdHZhciBwYXJhbXMgPSBlOmRhdGFcblx0dmFyIGlkID0gcGFyYW1zOmlkXG5cblx0aWYgYXBpW3BhcmFtc1swXV0gaXNhIEZ1bmN0aW9uXG5cdFx0bGV0IGZuID0gYXBpW3BhcmFtc1swXV1cblx0XHR2YXIgcmVzdWx0ID0gZm4uYXBwbHkoYXBpLHBhcmFtcy5zbGljZSgxKSlcblx0XHRwb3N0TWVzc2FnZShpZDogaWQsIGRhdGE6IHJlc3VsdClcblxuXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBzcmMvY29tcGlsZXIvd29ya2VyLmltYmFcbiAqKi8iLCIjIGNyZWF0ZSBzZXBhcmF0ZSBlcnJvci10eXBlcyB3aXRoIGFsbCB0aGUgbG9naWNcblxuZXhwb3J0IGNsYXNzIEltYmFQYXJzZUVycm9yIDwgRXJyb3Jcblx0XG5cdGRlZiBzZWxmLndyYXAgZXJyXG5cdFx0IyB3aGF0IGFib3V0IHRoZSBzdGFja3RyYWNlP1xuXHRcdEltYmFQYXJzZUVycm9yLm5ldyhlcnIpXG5cblx0ZGVmIGluaXRpYWxpemUgZSxvXG5cdFx0dGhpczplcnJvciA9IGVcblx0XHR0aGlzOm1lc3NhZ2UgPSBlOm1lc3NhZ2Vcblx0XHR0aGlzOmZpbGVuYW1lID0gZTpmaWxlbmFtZVxuXHRcdHRoaXM6bGluZSA9IGU6bGluZVxuXHRcdEBvcHRpb25zID0gbyBvciB7fVxuXHRcdHNlbGZcblxuXHRkZWYgc2V0IG9wdHNcblx0XHRAb3B0aW9ucyB8fD0ge31cblx0XHRmb3Igb3duIGssdiBvZiBvcHRzXG5cdFx0XHRAb3B0aW9uc1trXSA9IHZcblx0XHRzZWxmXG5cblx0ZGVmIHN0YXJ0XG5cdFx0dmFyIG8gPSBAb3B0aW9uc1xuXHRcdHZhciBpZHggPSBvOnBvcyAtIDFcblx0XHR2YXIgdG9rID0gbzp0b2tlbnMgYW5kIG86dG9rZW5zW2lkeF1cblx0XHR0b2sgPSBvOnRva2Vuc1stLWlkeF0gd2hpbGUgdG9rIGFuZCB0b2suQGxvYyA9PSAtMVxuXHRcdHJldHVybiB0b2tcblxuXHRkZWYgZGVzY1xuXHRcdHZhciBvID0gQG9wdGlvbnNcblx0XHRsZXQgbXNnID0gc2VsZjptZXNzYWdlXG5cdFx0aWYgbzp0b2tlbiBhbmQgbzp0b2tlbi5AbG9jID09IC0xXG5cdFx0XHQnU3ludGF4IEVycm9yJ1xuXHRcdGVsc2Vcblx0XHRcdG1zZ1xuXHRcblx0ZGVmIGxvY1xuXHRcdHN0YXJ0Py5yZWdpb25cblxuXHRkZWYgdG9KU09OXG5cdFx0dmFyIG8gPSBAb3B0aW9uc1xuXHRcdHZhciB0b2sgPSBzdGFydFxuXHRcdCMgdmFyIHRvayA9IG86dG9rZW5zIGFuZCBvOnRva2Vuc1tvOnBvcyAtIDFdXG5cdFx0IyB2YXIgbG9jID0gdG9rIGFuZCBbdG9rLkBsb2MsdG9rLkBsb2MgKyAodG9rLkBsZW4gb3IgdG9rLkB2YWx1ZTpsZW5ndGgpXSBvciBbMCwwXVxuXHRcdCMgLCBjb2w6IHRvay5AY29sLCBsaW5lOiB0b2suQGxpbmVcblx0XHQjIGdldCB0aGUgdG9rZW4gaXRzZWxmP1xuXHRcdHJldHVybiB7d2FybjogeWVzLCBtZXNzYWdlOiBkZXNjLCBsb2M6IGxvY31cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHNyYy9jb21waWxlci9lcnJvcnMuaW1iYVxuICoqLyIsIlxudmFyIFQgPSByZXF1aXJlICcuL3Rva2VuJ1xudmFyIFRva2VuID0gVC5Ub2tlblxuXG52YXIgcncgPSByZXF1aXJlICcuL3Jld3JpdGVyJ1xudmFyIFJld3JpdGVyID0gcncuUmV3cml0ZXJcbnZhciBJTlZFUlNFUyA9IHJ3LklOVkVSU0VTXG5cbnZhciBLID0gMFxuXG52YXIgRVJSID0gcmVxdWlyZSAnLi9lcnJvcnMnXG5cbiMgQ29uc3RhbnRzXG4jIC0tLS0tLS0tLVxuXG4jIEtleXdvcmRzIHRoYXQgSW1iYSBzaGFyZXMgaW4gY29tbW9uIHdpdGggSmF2YVNjcmlwdC5cbnZhciBKU19LRVlXT1JEUyA9IFtcblx0J3RydWUnLCAnZmFsc2UnLCAnbnVsbCcsICd0aGlzJ1xuXHQnZGVsZXRlJywgJ3R5cGVvZicsICdpbicsICdpbnN0YW5jZW9mJ1xuXHQndGhyb3cnLCAnYnJlYWsnLCAnY29udGludWUnLCAnZGVidWdnZXInXG5cdCdpZicsICdlbHNlJywgJ3N3aXRjaCcsICdmb3InLCAnd2hpbGUnLCAnZG8nLCAndHJ5JywgJ2NhdGNoJywgJ2ZpbmFsbHknXG5cdCdjbGFzcycsICdleHRlbmRzJywgJ3N1cGVyJywgJ3JldHVybidcbl1cblxuIyBuZXcgY2FuIGJlIHVzZWQgYXMgYSBrZXl3b3JkIGluIGltYmEsIHNpbmNlIG9iamVjdCBpbml0aW5nIGlzIGRvbmUgdGhyb3VnaFxuIyBNeU9iamVjdC5uZXcuIG5ldyBpcyBhIHZlcnkgdXNlZnVsIHZhcm5hbWUuXG5cbiMgV2Ugd2FudCB0byB0cmVhdCByZXR1cm4gbGlrZSBhbnkgcmVndWxhciBjYWxsIGZvciBub3dcbiMgTXVzdCBiZSBjYXJlZnVsIHRvIHRocm93IHRoZSBleGNlcHRpb25zIGluIEFTVCwgc2luY2UgdGhlIHBhcnNlclxuIyB3b250XG5cbiMgSW1iYS1vbmx5IGtleXdvcmRzLiB2YXIgc2hvdWxkIG1vdmUgdG8gSlNfS2V5d29yZHNcbiMgc29tZSB3b3JkcyAobGlrZSB0b2tpZCkgc2hvdWxkIGJlIGNvbnRleHQtc3BlY2lmaWNcbnZhciBJTUJBX0tFWVdPUkRTID0gW1xuXHQndW5kZWZpbmVkJywgJ3RoZW4nLCAndW5sZXNzJywgJ3VudGlsJywgJ2xvb3AnLCAnb2YnLCAnYnknLFxuXHQnd2hlbicsJ2RlZicsJ3RhZycsJ2RvJywnZWxpZicsJ2JlZ2luJywndmFyJywnbGV0Jywnc2VsZicsJ2F3YWl0JywnaW1wb3J0J1xuXVxuXG52YXIgSU1CQV9DT05URVhUVUFMX0tFWVdPUkRTID0gWydleHRlbmQnLCdzdGF0aWMnLCdsb2NhbCcsJ2V4cG9ydCcsJ2dsb2JhbCcsJ3Byb3AnXVxuXG52YXIgSU1CQV9BTElBU19NQVAgPVxuXHQnYW5kJyAgOiAnJiYnXG5cdCdvcicgICA6ICd8fCdcblx0J2lzJyAgIDogJz09J1xuXHQnaXNudCcgOiAnIT0nXG5cdCdub3QnICA6ICchJ1xuXHQneWVzJyAgOiAndHJ1ZSdcblx0J25vJyAgIDogJ2ZhbHNlJ1xuXHQnaXNhJyAgOiAnaW5zdGFuY2VvZidcblx0J2Nhc2UnIDogJ3N3aXRjaCdcblx0J25pbCcgIDogJ251bGwnXG5cbnZhciBJTUJBX0FMSUFTRVMgID0gT2JqZWN0LmtleXMoSU1CQV9BTElBU19NQVApXG5JTUJBX0tFWVdPUkRTID0gSU1CQV9LRVlXT1JEUy5jb25jYXQoSU1CQV9BTElBU0VTKVxuXG4jIEZpeGVkQXJyYXkgZm9yIHBlcmZvcm1hbmNlXG4jIHZhciBBTExfS0VZV09SRFMgPSBKU19LRVlXT1JEUy5jb25jYXQoSU1CQV9LRVlXT1JEUylcbmV4cG9ydCB2YXIgQUxMX0tFWVdPUkRTID0gW1xuXHQndHJ1ZScsICdmYWxzZScsICdudWxsJywgJ3RoaXMnLFxuXHQnZGVsZXRlJywgJ3R5cGVvZicsICdpbicsICdpbnN0YW5jZW9mJyxcblx0J3Rocm93JywgJ2JyZWFrJywgJ2NvbnRpbnVlJywgJ2RlYnVnZ2VyJyxcblx0J2lmJywgJ2Vsc2UnLCAnc3dpdGNoJywgJ2ZvcicsICd3aGlsZScsICdkbycsICd0cnknLCAnY2F0Y2gnLCAnZmluYWxseScsXG5cdCdjbGFzcycsICdleHRlbmRzJywgJ3N1cGVyJywgJ3JldHVybicsXG5cdCd1bmRlZmluZWQnLCAndGhlbicsICd1bmxlc3MnLCAndW50aWwnLCAnbG9vcCcsICdvZicsICdieScsXG5cdCd3aGVuJywnZGVmJywndGFnJywnZG8nLCdlbGlmJywnYmVnaW4nLCd2YXInLCdsZXQnLCdzZWxmJywnYXdhaXQnLCdpbXBvcnQnLFxuXHQnYW5kJywnb3InLCdpcycsJ2lzbnQnLCdub3QnLCd5ZXMnLCdubycsJ2lzYScsJ2Nhc2UnLCduaWwnXG5dXG5cbiMgVGhlIGxpc3Qgb2Yga2V5d29yZHMgdGhhdCBhcmUgcmVzZXJ2ZWQgYnkgSmF2YVNjcmlwdCwgYnV0IG5vdCB1c2VkLCBvciBhcmVcbiMgdXNlZCBieSBJbWJhIGludGVybmFsbHkuIFdlIHRocm93IGFuIGVycm9yIHdoZW4gdGhlc2UgYXJlIGVuY291bnRlcmVkLFxuIyB0byBhdm9pZCBoYXZpbmcgYSBKYXZhU2NyaXB0IGVycm9yIGF0IHJ1bnRpbWUuICAjICd2YXInLCAnbGV0JywgLSBub3QgaW5zaWRlIGhlcmVcbnZhciBSRVNFUlZFRCA9IFsnY2FzZScsICdkZWZhdWx0JywgJ2Z1bmN0aW9uJywgJ3ZvaWQnLCAnd2l0aCcsICdjb25zdCcsICdlbnVtJywgJ25hdGl2ZSddXG52YXIgU1RSSUNUX1JFU0VSVkVEID0gWydjYXNlJywnZnVuY3Rpb24nLCd2b2lkJywnY29uc3QnXVxuXG4jIFRoZSBzdXBlcnNldCBvZiBib3RoIEphdmFTY3JpcHQga2V5d29yZHMgYW5kIHJlc2VydmVkIHdvcmRzLCBub25lIG9mIHdoaWNoIG1heVxuIyBiZSB1c2VkIGFzIGlkZW50aWZpZXJzIG9yIHByb3BlcnRpZXMuXG52YXIgSlNfRk9SQklEREVOID0gSlNfS0VZV09SRFMuY29uY2F0IFJFU0VSVkVEXG5cbnZhciBNRVRIT0RfSURFTlRJRklFUiA9IC8vLyBeXG5cdCggXG5cdFx0KChbXFx4MjNdP1tcXCRBLVphLXpfXFx4N2YtXFx1ZmZmZl1bJFxcLVxcd1xceDdmLVxcdWZmZmZdKikoW1xcPV0/KSkgfCBcblx0XHQoPD0+fFxcfCg/IVtcXHw9XSkpXG5cdClcbi8vL1xuIyByZW1vdmVkIH49fH58IHwmKD8hWyY9XSlcblxuIyBUb2tlbiBtYXRjaGluZyByZWdleGVzLlxuIyBhZGRlZCBoeXBoZW5zIHRvIGlkZW50aWZpZXJzIG5vdyAtIHRvIHRlc3RcbnZhciBJREVOVElGSUVSID0gLy8vIF5cblx0KFxuXHRcdChcXCR8QEB8QHxcXCMpW1xcd0EtWmEtel9cXC1cXHg3Zi1cXHVmZmZmXVskXFx3XFx4N2YtXFx1ZmZmZl0qIChcXC1bJFxcd1xceDdmLVxcdWZmZmZdKykqIHxcblx0XHRbJEEtWmEtel9dWyRcXHdcXHg3Zi1cXHVmZmZmXSogKFxcLVskXFx3XFx4N2YtXFx1ZmZmZl0rKSpcblx0KVxuXHQoIFteXFxuXFxTXSogOiAoPyFbXFwqXFw9OiRcXHdcXHg3Zi1cXHVmZmZmXSkgKT8gICMgSXMgdGhpcyBhIHByb3BlcnR5IG5hbWU/XG4vLy9cblxudmFyIE9CSkVDVF9LRVkgPSAvLy8gXlxuXHQoIChcXCR8QEB8QHwpWyRBLVphLXpfXFx4N2YtXFx1ZmZmZlxcLV1bJFxcd1xceDdmLVxcdWZmZmZcXC1dKilcblx0KCBbXlxcblxcU1xcc10qIDogKD8hW1xcKlxcPTokXFx3XFx4N2YtXFx1ZmZmZl0pICkgICMgSXMgdGhpcyBhIHByb3BlcnR5IG5hbWU/XG4vLy9cblxudmFyIFRBRyA9IC8vLyBeXG5cdChcXDx8JSkoPz1bQS1aYS16XFwjXFwuXFx7XFxAXFw+XSlcbi8vL1xuXG52YXIgVEFHX1RZUEUgPSAvXihcXHdbXFx3XFxkXSo6KT8oXFx3W1xcd1xcZF0qKSgtW1xcd1xcZF0rKSovXG52YXIgVEFHX0lEID0gL14jKChcXHdbXFx3XFxkXSopKC1bXFx3XFxkXSspKikvXG5cbnZhciBUQUdfQVRUUiA9IC9eKFtcXC5cXDpdP1tcXHdcXF9dKyhbXFwtXFw6XVtcXHddKykqKShcXHMpKlxcPS9cblxudmFyIFNFTEVDVE9SID0gL14oWyVcXCRdezEsMn0pKFtcXChcXHdcXCNcXC5cXFtdKS9cbnZhciBTRUxFQ1RPUl9QQVJUID0gL14oXFwjfFxcLnw6fDo6KT8oW1xcd10rKFxcLVtcXHddKykqKS9cbnZhciBTRUxFQ1RPUl9DT01CSU5BVE9SID0gL14gKFxcK3xcXD58XFx+KSpcXHMqKD89W1xcd1xcLlxcI1xcOlxce1xcKlxcW10pL1xuXG52YXIgU0VMRUNUT1JfUFNFVURPX0NMQVNTID0gL14oOjo/KShbXFx3XSsoXFwtW1xcd10rKSopL1xudmFyIFNFTEVDVE9SX0FUVFJfT1AgPSAvXihcXCQ9fFxcfj18XFxePXxcXCo9fFxcfD18PXxcXCE9KS9cbnZhciBTRUxFQ1RPUl9BVFRSID0gL15cXFsoW1xcd1xcX1xcLV0rKShcXCQ9fFxcfj18XFxePXxcXCo9fFxcfD18PXxcXCE9KS9cblxudmFyIFNZTUJPTCA9IC8vL15cblx0XFw6KFxuXHRcdChcblx0XHRcdChbXFwqXFxAJFxcd1xceDdmLVxcdWZmZmZdKykrKFtcXC1cXC9cXFxcXFw6XVtcXHdcXHg3Zi1cXHVmZmZmXSspKlxuXHRcdCl8PT18XFw8PVxcPnxcXFtcXF18XFxbXFxdXFw9fFxcKnxbXFwvLFxcXFxdXG5cdClcbi8vL1xuXG5cbnZhciBOVU1CRVIgPSAvLy9cblx0XiAweFtcXGRhLWZdKyB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIyBoZXhcblx0XiAwYlswMV0rIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIGJpbmFyeVxuXHReIFxcZCpcXC4/XFxkKyAoPzplWystXT9cXGQrKT8gICMgZGVjaW1hbFxuLy8vaVxuXG52YXIgSEVSRURPQyA9IC8vLyBeIChcIlwiXCJ8JycnKSAoW1xcc1xcU10qPykgKD86XFxuW15cXG5cXFNdKik/IFxcMSAvLy9cblxudmFyIE9QRVJBVE9SID0gLy8vIF4gKFxuXHQ/OiBbLT1dPT4gICAgICAgICAgICAgIyBmdW5jdGlvbiAtIHdoYXRcblx0IHwgPT09XG5cdCB8IC0+XG5cdCB8ICE9PVxuXHQgfCBbLSsqLyU8PiZ8XiE/PV09ICAjIGNvbXBvdW5kIGFzc2lnbiAvIGNvbXBhcmVcblx0IHwgPTxcblx0IHwgPj4+PT8gICAgICAgICAgICAgIyB6ZXJvLWZpbGwgcmlnaHQgc2hpZnRcblx0IHwgKFstKzpdKVxcMSAgICAgICAgICMgZG91Ymxlc1xuXHQgfCAoWyZ8PD5dKVxcMj0/ICAgICAgIyBsb2dpYyAvIHNoaWZ0XG5cdCB8IFxcP1xcLiAgICAgICAgICAgICAgIyBzb2FrIGFjY2Vzc1xuXHQgfCBcXD9cXDogICAgICAgICAgICAgICMgc29hayBzeW1ib2xcblx0IHwgXFwuezIsM30gICAgICAgICAgICMgcmFuZ2Ugb3Igc3BsYXRcblx0IHwgXFwqKD89W2EtekEtWlxcX10pICAgIyBzcGxhdCAtLSBcbikgLy8vXG5cbiMgRklYTUUgc3BsYXQgc2hvdWxkIG9ubHkgYmUgYWxsb3dlZCB3aGVuIHRoZSBwcmV2aW91cyB0aGluZyBpcyBzcGFjZWQgb3IgaW5zaWRlIGNhbGw/XG5cbnZhciBXSElURVNQQUNFID0gL15bXlxcblxcU10rL1xuXG52YXIgQ09NTUVOVCAgICA9IC9eIyMjKFteI11bXFxzXFxTXSo/KSg/OiMjI1teXFxuXFxTXSp8KD86IyMjKT8kKS9cbiMgQ09NTUVOVCAgICA9IC9eIyMjKFteI11bXFxzXFxTXSo/KSg/OiMjI1teXFxuXFxTXSp8KD86IyMjKT8kKXxeKD86XFxzKigjXFxzLip8I1xccyokKSkrL1xudmFyIElOTElORV9DT01NRU5UID0gL14oXFxzKikoI1sgXFx0XFwhXSguKil8I1sgXFx0XT8oPz1cXG58JCkpKy9cblxudmFyIENPREUgICAgICAgPSAvXlstPV09Pi9cblxudmFyIE1VTFRJX0RFTlQgPSAvXig/OlxcblteXFxuXFxTXSopKy9cblxudmFyIFNJTVBMRVNUUiAgPSAvXidbXlxcXFwnXSooPzpcXFxcLlteXFxcXCddKikqJy9cblxudmFyIEpTVE9LRU4gICAgPSAvXmBbXlxcXFxgXSooPzpcXFxcLlteXFxcXGBdKikqYC9cblxuIyBSZWdleC1tYXRjaGluZy1yZWdleGVzLlxudmFyIFJFR0VYID0gLy8vIF5cblx0KC8gKD8hIFtcXHM9XSApICAgIyBkaXNhbGxvdyBsZWFkaW5nIHdoaXRlc3BhY2Ugb3IgZXF1YWxzIHNpZ25zXG5cdFteIFsgLyBcXG4gXFxcXCBdKiAgIyBldmVyeSBvdGhlciB0aGluZ1xuXHQoPzpcblx0XHQoPzogXFxcXFtcXHNcXFNdICAgIyBhbnl0aGluZyBlc2NhcGVkXG5cdFx0XHR8IFxcWyAgICAgICAgICMgY2hhcmFjdGVyIGNsYXNzXG5cdFx0XHRcdFx0IFteIFxcXSBcXG4gXFxcXCBdKlxuXHRcdFx0XHRcdCAoPzogXFxcXFtcXHNcXFNdIFteIFxcXSBcXG4gXFxcXCBdKiApKlxuXHRcdFx0XHQgXVxuXHRcdCkgW14gWyAvIFxcbiBcXFxcIF0qXG5cdCkqXG5cdC8pIChbaW1neV17MCw0fSkgKD8hXFx3KVxuLy8vXG5cbnZhciBIRVJFR0VYICAgICAgPSAvLy8gXiAvezN9IChbXFxzXFxTXSs/KSAvezN9IChbaW1neV17MCw0fSkgKD8hXFx3KSAvLy9cblxudmFyIEhFUkVHRVhfT01JVCA9IC9cXHMrKD86Iy4qKT8vZ1xuXG4jIFRva2VuIGNsZWFuaW5nIHJlZ2V4ZXMuXG52YXIgTVVMVElMSU5FUiAgICAgID0gL1xcbi9nXG5cbnZhciBIRVJFRE9DX0lOREVOVCAgPSAvXFxuKyhbXlxcblxcU10qKS9nXG5cbnZhciBIRVJFRE9DX0lMTEVHQUwgPSAvXFwqXFwvL1xuXG4jIGV4cGVuc2l2ZT9cbnZhciBMSU5FX0NPTlRJTlVFUiAgPSAvLy8gXiBcXHMqICg/OiAsIHwgXFw/P1xcLig/IVsuXFxkXSkgfCA6OiApIC8vL1xuXG52YXIgVFJBSUxJTkdfU1BBQ0VTID0gL1xccyskL1xuXG52YXIgQ09OU1RfSURFTlRJRklFUiA9IC9eW0EtWl0vXG5cbnZhciBBUkdWQVIgPSAvXlxcJFxcZCQvXG5cbiMgQ29tcG91bmQgYXNzaWdubWVudCB0b2tlbnMuXG52YXIgQ09NUE9VTkRfQVNTSUdOID0gWyAnLT0nLCAnKz0nLCAnLz0nLCAnKj0nLCAnJT0nLCAnfHw9JywgJyYmPScsICc/PScsICc8PD0nLCAnPj49JywgJz4+Pj0nLCAnJj0nLCAnXj0nLCAnfD0nLCc9PCddXG5cbiMgVW5hcnkgdG9rZW5zLlxudmFyIFVOQVJZID0gWychJywgJ34nLCAnTkVXJywgJ1RZUEVPRicsICdERUxFVEUnXVxuXG4jIExvZ2ljYWwgdG9rZW5zLlxudmFyIExPR0lDICAgPSBbJyYmJywgJ3x8JywgJyYnLCAnfCcsICdeJ11cblxuIyBCaXQtc2hpZnRpbmcgdG9rZW5zLlxudmFyIFNISUZUICAgPSBbJzw8JywgJz4+JywgJz4+PiddXG5cbiMgQ29tcGFyaXNvbiB0b2tlbnMuXG52YXIgQ09NUEFSRSA9IFsnPT09JywgJyE9PScsICc9PScsICchPScsICc8JywgJz4nLCAnPD0nLCAnPj0nLCc9PT0nLCchPT0nXVxuXG4jIE92ZXJpZGVhYmxlIG1ldGhvZHNcbnZhciBPUF9NRVRIT0RTID0gWyc8PT4nLCc8PCcsJy4uJ11cblxuIyBNYXRoZW1hdGljYWwgdG9rZW5zLlxudmFyIE1BVEggPSBbJyonLCAnLycsICclJywgJ+KIqicsICfiiKknLCfiiJonXVxuXG4jIFJlbGF0aW9uYWwgdG9rZW5zIHRoYXQgYXJlIG5lZ2F0YWJsZSB3aXRoIGBub3RgIHByZWZpeC5cbnZhciBSRUxBVElPTiA9IFsnSU4nLCAnT0YnLCAnSU5TVEFOQ0VPRicsJ0lTQSddXG5cbiMgQm9vbGVhbiB0b2tlbnMuXG52YXIgQk9PTCA9IFsnVFJVRScsICdGQUxTRScsICdOVUxMJywgJ1VOREVGSU5FRCddXG5cbiMgT3VyIGxpc3QgaXMgc2hvcnRlciwgZHVlIHRvIHNhbnMtcGFyZW50aGVzZXMgbWV0aG9kIGNhbGxzLlxudmFyIE5PVF9SRUdFWCA9IFsnTlVNQkVSJywgJ1JFR0VYJywgJ0JPT0wnLCAnVFJVRScsICdGQUxTRScsICcrKycsICctLScsICddJ11cblxuIyBJZiB0aGUgcHJldmlvdXMgdG9rZW4gaXMgbm90IHNwYWNlZCwgdGhlcmUgYXJlIG1vcmUgcHJlY2VkaW5nIHRva2VucyB0aGF0XG4jIGZvcmNlIGEgZGl2aXNpb24gcGFyc2U6XG52YXIgTk9UX1NQQUNFRF9SRUdFWCA9IFsnTlVNQkVSJywgJ1JFR0VYJywgJ0JPT0wnLCAnVFJVRScsICdGQUxTRScsICcrKycsICctLScsICddJywnKScsICd9JywgJ1RISVMnLCAnU0VMRicgLCAnSURFTlRJRklFUicsICdTVFJJTkcnXVxuXG4jIFRva2VucyB3aGljaCBjb3VsZCBsZWdpdGltYXRlbHkgYmUgaW52b2tlZCBvciBpbmRleGVkLiBBbiBvcGVuaW5nXG4jIHBhcmVudGhlc2VzIG9yIGJyYWNrZXQgZm9sbG93aW5nIHRoZXNlIHRva2VucyB3aWxsIGJlIHJlY29yZGVkIGFzIHRoZSBzdGFydFxuIyBvZiBhIGZ1bmN0aW9uIGludm9jYXRpb24gb3IgaW5kZXhpbmcgb3BlcmF0aW9uLlxuIyByZWFsbHk/IVxuXG52YXIgVU5GSU5JU0hFRCA9IFsnXFxcXCcsJy4nLCAnPy4nLCAnPzonLCAnVU5BUlknLCAnTUFUSCcsICcrJywgJy0nLCAnU0hJRlQnLCAnUkVMQVRJT04nLCAnQ09NUEFSRScsICdMT0dJQycsICdDT01QT1VORF9BU1NJR04nLCAnVEhST1cnLCAnRVhURU5EUyddXG5cbiMgfSBzaG91bGQgbm90IGJlIGNhbGxhYmxlIGFueW1vcmUhISEgJ30nLCAnOjonLFxudmFyIENBTExBQkxFICA9IFsnSURFTlRJRklFUicsICdTVFJJTkcnLCAnUkVHRVgnLCAnKScsICddJywgJ1RISVMnLCAnU1VQRVInLCAnVEFHX0VORCcsICdJVkFSJywgJ0dWQVInLCdTRUxGJywnQ09OU1QnLCdORVcnLCdBUkdWQVInLCdTWU1CT0wnLCdSRVRVUk4nXVxuIyB2YXIgSU5ERVhBQkxFID0gQ0FMTEFCTEUuY29uY2F0ICdOVU1CRVInLCAnQk9PTCcsICdUQUdfU0VMRUNUT1InLCAnSURSRUYnLCAnQVJHVU1FTlRTJywnfScgIyBhcmUgYm9vbGVhbnMgaW5kZXhhYmxlPyByZWFsbHk/XG4jIG9wdGltaXplIGZvciBGaXhlZEFycmF5XG52YXIgSU5ERVhBQkxFID0gW1xuXHQnSURFTlRJRklFUicsICdTVFJJTkcnLCAnUkVHRVgnLCAnKScsICddJywgJ1RISVMnLCAnU1VQRVInLCAnVEFHX0VORCcsICdJVkFSJywgJ0dWQVInLCdTRUxGJywnQ09OU1QnLCdORVcnLCdBUkdWQVInLCdTWU1CT0wnLCdSRVRVUk4nXG5cdCdOVU1CRVInLCAnQk9PTCcsICdUQUdfU0VMRUNUT1InLCAnSURSRUYnLCAnQVJHVU1FTlRTJywnfScsJ1RBR19UWVBFJ1xuXVxuXG52YXIgR0xPQkFMX0lERU5USUZJRVJTID0gWydnbG9iYWwnLCdleHBvcnRzJywncmVxdWlyZSddXG5cbiMgVG9rZW5zIHRoYXQsIHdoZW4gaW1tZWRpYXRlbHkgcHJlY2VkaW5nIGEgYFdIRU5gLCBpbmRpY2F0ZSB0aGF0IHRoZSBgV0hFTmBcbiMgb2NjdXJzIGF0IHRoZSBzdGFydCBvZiBhIGxpbmUuIFdlIGRpc2FtYmlndWF0ZSB0aGVzZSBmcm9tIHRyYWlsaW5nIHdoZW5zIHRvXG4jIGF2b2lkIGFuIGFtYmlndWl0eSBpbiB0aGUgZ3JhbW1hci5cbnZhciBMSU5FX0JSRUFLID0gWydJTkRFTlQnLCAnT1VUREVOVCcsICdURVJNSU5BVE9SJ11cblxuXG5leHBvcnQgY2xhc3MgTGV4ZXJFcnJvciA8IFN5bnRheEVycm9yXG5cdFxuXHRkZWYgaW5pdGlhbGl6ZSBtZXNzYWdlLCBmaWxlLCBsaW5lXG5cdFx0c2VsZjptZXNzYWdlID0gbWVzc2FnZVxuXHRcdHNlbGY6ZmlsZSA9IGZpbGVcblx0XHRzZWxmOmxpbmUgPSBsaW5lXG5cdFx0cmV0dXJuIHNlbGZcblxuXG5kZWYgbGFzdCBhcnJheSwgYmFjayA9IDBcblx0YXJyYXlbYXJyYXk6bGVuZ3RoIC0gYmFjayAtIDFdXG5cbmRlZiBjb3VudCBzdHIsIHN1YnN0clxuXHRyZXR1cm4gc3RyLnNwbGl0KHN1YnN0cik6bGVuZ3RoIC0gMVxuXHRcbmRlZiByZXBlYXRTdHJpbmcgc3RyLCB0aW1lc1xuXHR2YXIgcmVzID0gJydcblx0d2hpbGUgdGltZXMgPiAwXG5cdFx0aWYgdGltZXMgJSAyID09IDFcblx0XHRcdHJlcyArPSBzdHJcblx0XHRzdHIgKz0gc3RyXG5cdFx0dGltZXMgPj49IDFcblx0cmV0dXJuIHJlc1xuXG52YXIgdFQgID0gVDp0eXBcbnZhciB0ViAgPSBUOnZhbFxudmFyIHRUcyA9IFQ6c2V0VHlwXG52YXIgdFZzID0gVDpzZXRWYWxcblxuIyBUaGUgTGV4ZXIgY2xhc3MgcmVhZHMgYSBzdHJlYW0gb2YgSW1iYSBhbmQgZGl2dmllcyBpdCB1cCBpbnRvIHRva2lkZ2VkXG4jIHRva2Vucy4gU29tZSBwb3RlbnRpYWwgYW1iaWd1aXR5IGluIHRoZSBncmFtbWFyIGhhcyBiZWVuIGF2b2lkZWQgYnlcbiMgcHVzaGluZyBzb21lIGV4dHJhIHNtYXJ0cyBpbnRvIHRoZSBMZXhlci5cblxuIyBCYXNlZCBvbiB0aGUgb3JpZ2luYWwgbGV4ZXIuY29mZmVlIGZyb20gQ29mZmVlU2NyaXB0XG5leHBvcnQgY2xhc3MgTGV4ZXJcblxuXHRkZWYgaW5pdGlhbGl6ZVxuXHRcdHJlc2V0XG5cdFx0c2VsZlxuXG5cdGRlZiByZXNldFxuXHRcdEBjb2RlICAgID0gbnVsbFxuXHRcdEBjaHVuayAgID0gbnVsbCAgICAgICAgICAgIyBUaGUgcmVtYWluZGVyIG9mIHRoZSBzb3VyY2UgY29kZS5cblx0XHRAb3B0cyAgICA9IG51bGxcblx0XHRcblx0XHRAaW5kZW50ICA9IDAgICAgICAgICAgICAgICMgVGhlIGN1cnJlbnQgaW5kZW50YXRpb24gbGV2ZWwuXG5cdFx0QGluZGVidCAgPSAwICAgICAgICAgICAgICAjIFRoZSBvdmVyLWluZGVudGF0aW9uIGF0IHRoZSBjdXJyZW50IGxldmVsLlxuXHRcdEBvdXRkZWJ0ID0gMCAgICAgICAgICAgICAgIyBUaGUgdW5kZXItb3V0ZGVudGF0aW9uIGF0IHRoZSBjdXJyZW50IGxldmVsLlxuXG5cdFx0QGluZGVudHMgID0gW10gICAgICAgICAgICAgIyBUaGUgc3RhY2sgb2YgYWxsIGN1cnJlbnQgaW5kZW50YXRpb24gbGV2ZWxzLlxuXHRcdEBlbmRzICAgICA9IFtdICMgVGhlIHN0YWNrIGZvciBwYWlyaW5nIHVwIHRva2Vucy5cblx0XHRAY29udGV4dHMgPSBbXSAjIHN1cGxlbWVudHMgQGVuZHNcblx0XHRAc2NvcGVzICAgPSBbXVxuXHRcdEBuZXh0U2NvcGUgPSBudWxsICMgdGhlIHNjb3BlIHRvIGFkZCBvbiB0aGUgbmV4dCBpbmRlbnRcblx0XHQjIHNob3VsZCByYXRoZXIgbWFrZSBpdCBsaWtlIGEgc3RhdGVtYWNoaW5lIHRoYXQgbW92ZXMgZnJvbSBDTEFTU19ERUYgdG8gQ0xBU1NfQk9EWSBldGNcblx0XHQjIFRoaW5ncyBzaG91bGQgY29tcGlsZSBkaWZmZXJlbnRseSB3aGVuIHlvdSBhcmUgaW4gYSBDTEFTU19CT0RZIHRoYW4gd2hlbiBpbiBhIERFRl9CT0RZKytcblxuXHRcdEBpbmRlbnRTdHlsZSA9IG51bGxcblxuXHRcdEB0b2tlbnMgID0gW10gICAgICAgICAgICAgIyBTdHJlYW0gb2YgcGFyc2VkIHRva2VucyBpbiB0aGUgZm9ybSBgWydUWVBFJywgdmFsdWUsIGxpbmVdYC5cblx0XHRAc2VlbkZvciA9IG5vXG5cdFx0QGxvYyA9IDBcblx0XHRAbG9jT2Zmc2V0ID0gMFxuXG5cdFx0QGVuZCAgICAgPSBudWxsXG5cdFx0QGNoYXIgXHQgPSBudWxsXG5cdFx0QGJyaWRnZSAgPSBudWxsXG5cdFx0QGxhc3QgICAgPSBudWxsXG5cdFx0QGxhc3RUeXAgPSAnJ1xuXHRcdEBsYXN0VmFsID0gbnVsbFxuXHRcdHNlbGZcblxuXHRkZWYgamlzb25CcmlkZ2Ugamlzb25cblx0XHRAYnJpZGdlID0ge1xuXHRcdFx0bGV4OiBUOmxleFxuXHRcdFx0c2V0SW5wdXQ6IGRvIHx0b2tlbnN8XG5cdFx0XHRcdHRoaXM6dG9rZW5zID0gdG9rZW5zXG5cdFx0XHRcdHRoaXM6cG9zID0gMFxuXG5cdFx0XHR1cGNvbWluZ0lucHV0OiBkbyBcIlwiXG5cdFx0fVxuXG5cblx0ZGVmIHRva2VuaXplIGNvZGUsIG8gPSB7fVxuXG5cdFx0aWYgY29kZTpsZW5ndGggPT0gMFxuXHRcdFx0cmV0dXJuIFtdXG5cblx0XHR1bmxlc3MgbzppbmxpbmVcblx0XHRcdGlmIFdISVRFU1BBQ0UudGVzdChjb2RlKVxuXHRcdFx0XHRjb2RlID0gXCJcXG57Y29kZX1cIlxuXHRcdFx0XHRyZXR1cm4gW10gaWYgY29kZS5tYXRjaCgvXlxccyokL2cpXG5cblx0XHRcdGNvZGUgPSBjb2RlLnJlcGxhY2UoL1xcci9nLCAnJykucmVwbGFjZSAvW1xcdCBdKyQvZywgJydcblxuXHRcdEBsYXN0ICAgID0gbnVsbFxuXHRcdEBsYXN0VHlwID0gbnVsbFxuXHRcdEBsYXN0VmFsID0gbnVsbFxuXG5cdFx0QGNvZGUgICAgPSBjb2RlXG5cdFx0QG9wdHMgICAgPSBvXG5cdFx0QGxvY09mZnNldCA9IG86bG9jIG9yIDBcblxuXHRcdG86aW5kZW50IHx8PSB7c3R5bGU6IG51bGwsIHNpemU6IG51bGx9XG5cdFx0IyBhZGQgYSByZWZlcmVuY2UgdG8gdGhlIG9wdGlvbnMgb2JqZWN0XG5cdFx0by5AdG9rZW5zID0gQHRva2VucyBcblx0XHQjIHdoYXQgYWJvdXQgY29sIGhlcmU/XG5cblx0XHQjIEBpbmRlbnQgID0gMCAjIFRoZSBjdXJyZW50IGluZGVudGF0aW9uIGxldmVsLlxuXHRcdCMgQGluZGVidCAgPSAwICMgVGhlIG92ZXItaW5kZW50YXRpb24gYXQgdGhlIGN1cnJlbnQgbGV2ZWwuXG5cdFx0IyBAb3V0ZGVidCA9IDAgIyBUaGUgdW5kZXItb3V0ZGVudGF0aW9uIGF0IHRoZSBjdXJyZW50IGxldmVsLlxuXHRcdCMgQGluZGVudHMgPSBbXSAjIFRoZSBzdGFjayBvZiBhbGwgY3VycmVudCBpbmRlbnRhdGlvbiBsZXZlbHMuXG5cdFx0IyBAZW5kcyAgICA9IFtdICMgVGhlIHN0YWNrIGZvciBwYWlyaW5nIHVwIHRva2Vucy5cblx0XHQjIEB0b2tlbnMgID0gW10gIyBTdHJlYW0gb2YgcGFyc2VkIHRva2VucyBpbiB0aGUgZm9ybSBgWydUWVBFJywgdmFsdWUsIGxpbmVdYC5cblx0XHQjIEBjaGFyID0gbmlsXG5cdFx0XG5cdFx0Y29uc29sZS50aW1lKFwidG9rZW5pemU6bGV4ZXJcIikgaWYgbzpwcm9maWxlXG5cdFx0cGFyc2UoY29kZSlcblx0XHRjbG9zZUluZGVudGF0aW9uIHVubGVzcyBvOmlubGluZVxuXHRcdGlmICFvOnNpbGVudCBhbmQgQGVuZHM6bGVuZ3RoXG5cdFx0XHRlcnJvciBcIm1pc3Npbmcge0BlbmRzLnBvcH1cIlxuXG5cdFx0Y29uc29sZS50aW1lRW5kKFwidG9rZW5pemU6bGV4ZXJcIikgaWYgbzpwcm9maWxlXG5cdFx0cmV0dXJuIEB0b2tlbnMgaWYgbzpyZXdyaXRlID09IG5vIG9yIG86bm9yZXdyaXRlXG5cdFx0cmV0dXJuIFJld3JpdGVyLm5ldy5yZXdyaXRlKEB0b2tlbnMsIG8pXG5cblx0ZGVmIHBhcnNlIGNvZGVcblx0XHR2YXIgaSA9IDBcblx0XHR2YXIgcGkgPSAwXG5cblx0XHR3aGlsZSBAY2h1bmsgPSBjb2RlLnNsaWNlKGkpXG5cdFx0XHRAbG9jID0gQGxvY09mZnNldCArIGlcblx0XHRcdHBpID0gKEBlbmQgPT0gJ1RBRycgYW5kIHRhZ0RlZkNvbnRleHRUb2tlbikgfHwgKEBpblRhZyBhbmQgdGFnQ29udGV4dFRva2VuKSB8fCBiYXNpY0NvbnRleHRcblx0XHRcdGkgKz0gcGlcblxuXHRcdHJldHVyblxuXG5cdGRlZiBiYXNpY0NvbnRleHRcblx0XHRyZXR1cm4gc2VsZWN0b3JUb2tlbiB8fCBzeW1ib2xUb2tlbiB8fCBtZXRob2ROYW1lVG9rZW4gfHwgaWRlbnRpZmllclRva2VuIHx8IHdoaXRlc3BhY2VUb2tlbiB8fCBsaW5lVG9rZW4gfHwgY29tbWVudFRva2VuIHx8IGhlcmVkb2NUb2tlbiB8fCB0YWdUb2tlbiB8fCBzdHJpbmdUb2tlbiB8fCBudW1iZXJUb2tlbiB8fCByZWdleFRva2VuIHx8IGpzVG9rZW4gfHwgbGl0ZXJhbFRva2VuIHx8IDBcblxuXHRkZWYgbW92ZUNhcmV0IGlcblx0XHRAbG9jICs9IGlcblxuXHRkZWYgY29udGV4dFxuXHRcdEBlbmRzW0BlbmRzOmxlbmd0aCAtIDFdXG5cblx0ZGVmIGluQ29udGV4dCBrZXlcblx0XHR2YXIgbyA9IEBjb250ZXh0c1tAY29udGV4dHM6bGVuZ3RoIC0gMV1cblx0XHRyZXR1cm4gbyBhbmQgb1trZXldXG5cblx0ZGVmIHB1c2hFbmQgdmFsXG5cdFx0IyBjb25zb2xlLmxvZyBcInB1c2hpbmcgZW5kXCIsdmFsXG5cdFx0QGVuZHMucHVzaCh2YWwpXG5cdFx0QGNvbnRleHRzLnB1c2gobmlsKVxuXHRcdEBlbmQgPSB2YWxcblx0XHRyZWZyZXNoU2NvcGVcblx0XHRzZWxmXG5cblx0ZGVmIHBvcEVuZCB2YWxcblx0XHRAZW5kcy5wb3Bcblx0XHRAY29udGV4dHMucG9wXG5cdFx0QGVuZCA9IEBlbmRzW0BlbmRzOmxlbmd0aCAtIDFdXG5cdFx0cmVmcmVzaFNjb3BlXG5cdFx0c2VsZlxuXG5cdGRlZiByZWZyZXNoU2NvcGVcblx0XHR2YXIgY3R4MCA9IEBlbmRzW0BlbmRzOmxlbmd0aCAtIDFdXG5cdFx0dmFyIGN0eDEgPSBAZW5kc1tAZW5kczpsZW5ndGggLSAyXVxuXHRcdEBpblRhZyA9IGN0eDAgPT0gJ1RBR19FTkQnIG9yIChjdHgxID09ICdUQUdfRU5EJyBhbmQgY3R4MCA9PSAnT1VUREVOVCcpXG5cblx0XHRcblxuXHRkZWYgcXVldWVTY29wZSB2YWxcblx0XHQjIGNvbnNvbGUubG9nKFwicHVzaGluZyBzY29wZSB7dmFsfSAtIHtAaW5kZW50c30ge0BpbmRlbnRzOmxlbmd0aH1cIilcblx0XHQjIEBzY29wZXMucHVzaCh2YWwpICMgbm8gbm9cblx0XHRAc2NvcGVzW0BpbmRlbnRzOmxlbmd0aF0gPSB2YWxcblx0XHRzZWxmXG5cblx0ZGVmIHBvcFNjb3BlIHZhbFxuXHRcdEBzY29wZXMucG9wXG5cdFx0c2VsZlxuXG5cdGRlZiBnZXRTY29wZVxuXHRcdEBzY29wZXNbQGluZGVudHM6bGVuZ3RoIC0gMV1cblx0XHRcblx0ZGVmIHNjb3BlIHN5bSwgb3B0c1xuXHRcdHZhciBsZW4gPSBAZW5kcy5wdXNoKEBlbmQgPSBzeW0pXG5cdFx0QGNvbnRleHRzLnB1c2gob3B0cyBvciBuaWwpXG5cdFx0cmV0dXJuIHN5bVxuXHRcblxuXHRkZWYgY2xvc2VTZWxlY3RvclxuXHRcdGlmIEBlbmQgPT0gJyUnXG5cdFx0XHR0b2tlbignU0VMRUNUT1JfRU5EJywnJScsMClcblx0XHRcdHBhaXIoJyUnKVxuXHRcblxuXHRkZWYgb3BlbkRlZlxuXHRcdHB1c2hFbmQoJ0RFRicpXG5cblxuXHRkZWYgY2xvc2VEZWZcblx0XHRpZiBjb250ZXh0IGlzICdERUYnXG5cdFx0XHR2YXIgcHJldiA9IGxhc3QoQHRva2Vucylcblx0XHRcdCMgY29uc29sZS5sb2cgXCJjbG9zZSBkZWYge3ByZXZ9XCJcblx0XHRcdCMgY29uc29sZS5sb2coJ2Nsb3NlRGVmIHdpdGggbGFzdD4nLHByZXYpXG5cdFx0XHRpZiB0VChwcmV2KSA9PSAnREVGX0ZSQUdNRU5UJ1xuXHRcdFx0XHR0cnVlXG5cdFx0XHRlbGlmIHRUKHByZXYpID09ICdURVJNSU5BVE9SJ1xuXHRcdFx0XHQjIGNvbnNvbGUubG9nIFwiaGVyZT8hPz9cIlxuXHRcdFx0XHRsZXQgbiA9IEB0b2tlbnMucG9wXG5cdFx0XHRcdCMgY29uc29sZS5sb2cgblxuXHRcdFx0XHR0b2tlbignREVGX0JPRFknLCAnREVGX0JPRFknLDApXG5cdFx0XHRcdCMgdG9rZW4oJ1RFUk1JTkFUT1InLCAnJywwKSB1bmxlc3Mgbi5AdmFsdWUuaW5kZXhPZignLy8nKSA+PSAwXG5cdFx0XHRcdEB0b2tlbnMucHVzaChuKVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHR0b2tlbignREVGX0JPRFknLCAnREVGX0JPRFknLDApXG5cblx0XHRcdHBhaXIoJ0RFRicpXG5cdFx0cmV0dXJuXG5cblx0ZGVmIHRhZ0NvbnRleHRUb2tlblxuXHRcdGlmIEBjaHVua1swXSA9PSAnIydcblx0XHRcdCMgY29uc29sZS5sb2coJ2ZvdW5kIGlkICMgaW4gdGFnQ29udGV4dFRva2VuJylcblx0XHRcdHRva2VuKCcjJywnIycsMSlcblx0XHRcdHJldHVybiAxXG5cblx0XHRpZiB2YXIgbWF0Y2ggPSBUQUdfQVRUUi5leGVjKEBjaHVuaylcblx0XHRcdCMgY29uc29sZS5sb2cgJ1RBR19TRERTQVRUUiBJTiB0b2tpZCcsbWF0Y2hcblx0XHRcdCMgdmFyIHByZXYgPSBsYXN0IEB0b2tlbnNcblx0XHRcdCMgaWYgdGhlIHByZXYgaXMgYSB0ZXJtaW5hdG9yLCB3ZSBkb250IHJlYWxseSBuZWVkIHRvIGNhcmU/XG5cdFx0XHRpZiBAbGFzdFR5cCAhPSAnVEFHX05BTUUnXG5cdFx0XHRcdGlmIEBsYXN0VHlwID09ICdURVJNSU5BVE9SJ1xuXHRcdFx0XHRcdCMgY29uc29sZS5sb2coJ3ByZXYgd2FzIHRlcm1pbmF0b3IgLS0gZHJvcCBpdD8nKVxuXHRcdFx0XHRcdHRydWVcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHRva2VuKFwiLFwiLCBcIixcIilcblxuXHRcdFx0dmFyIGwgPSBtYXRjaFswXTpsZW5ndGhcblxuXHRcdFx0dG9rZW4gJ1RBR19BVFRSJyxtYXRjaFsxXSxsIC0gMSAgIyBhZGQgdG8gbG9jP1xuXHRcdFx0QGxvYyArPSBsIC0gMVxuXHRcdFx0dG9rZW4gJz0nLCc9JywxXG5cdFx0XHRyZXR1cm4gbFxuXHRcdHJldHVybiAwXG5cblx0ZGVmIHRhZ0RlZkNvbnRleHRUb2tlblxuXHRcdCMgY29uc29sZS5sb2cgXCJ0YWdDb250ZXh0VG9rZW5cIlxuXHRcdGlmIHZhciBtYXRjaCA9IFRBR19UWVBFLmV4ZWMoQGNodW5rKVxuXHRcdFx0dG9rZW4gJ1RBR19UWVBFJywgbWF0Y2hbMF0sIG1hdGNoWzBdOmxlbmd0aFxuXHRcdFx0cmV0dXJuIG1hdGNoWzBdOmxlbmd0aFxuXG5cdFx0aWYgdmFyIG1hdGNoID0gVEFHX0lELmV4ZWMoQGNodW5rKVxuXHRcdFx0dmFyIGlucHV0ID0gbWF0Y2hbMF1cblx0XHRcdHRva2VuICdUQUdfSUQnLCBpbnB1dCwgaW5wdXQ6bGVuZ3RoXG5cdFx0XHRyZXR1cm4gaW5wdXQ6bGVuZ3RoXG5cblx0XHRyZXR1cm4gMFxuXG5cblx0ZGVmIHRhZ1Rva2VuXG5cdFx0cmV0dXJuIDAgdW5sZXNzIHZhciBtYXRjaCA9IFRBRy5leGVjKEBjaHVuaylcblx0XHR2YXIgW2lucHV0LCB0eXBlLCBpZGVudGlmaWVyXSA9IG1hdGNoXG5cblx0XHRpZiB0eXBlID09ICc8J1xuXHRcdFx0dG9rZW4oJ1RBR19TVEFSVCcsICc8JywxKVxuXHRcdFx0cHVzaEVuZChJTlZFUlNFU1snVEFHX1NUQVJUJ10pXG5cblx0XHRcdGlmIG1hdGNoID0gVEFHX1RZUEUuZXhlYyhAY2h1bmsuc3Vic3RyKDEsNDApKVxuXHRcdFx0XHQjIHNwZWNpYWwgY2FzZSBzaG91bGQgcHJvYmFibHkgYmUgaGFuZGxlZCBpbiBBU1Rcblx0XHRcdFx0aWYgbWF0Y2hbMF0gIT0gJ3NlbGYnXG5cdFx0XHRcdFx0dG9rZW4oJ1RBR19UWVBFJyxtYXRjaFswXSxtYXRjaFswXTpsZW5ndGgsMSlcblx0XHRcdFx0XHRyZXR1cm4gaW5wdXQ6bGVuZ3RoICsgbWF0Y2hbMF06bGVuZ3RoXG5cblx0XHRcdGlmIGlkZW50aWZpZXJcblx0XHRcdFx0aWYgaWRlbnRpZmllci5zdWJzdHIoMCwxKSA9PSAneydcblx0XHRcdFx0XHRyZXR1cm4gdHlwZTpsZW5ndGhcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHRva2VuKCdUQUdfTkFNRScsIGlucHV0LnN1YnN0cigxKSwwKVxuXG5cdFx0cmV0dXJuIGlucHV0Omxlbmd0aFxuXG5cblx0ZGVmIHNlbGVjdG9yVG9rZW5cblx0XHR2YXIgbWF0Y2hcblxuXHRcdCMgc3BlY2lhbCBoYW5kbGluZyBpZiB3ZSBhcmUgaW4gdGhpcyBjb250ZXh0XG5cdFx0aWYgQGVuZCA9PSAnJSdcblx0XHRcdHZhciBjaHIgPSBAY2h1bmsuY2hhckF0KDApXG5cdFx0XHR2YXIgb3BlbiA9IGluQ29udGV4dCgnb3BlbicpXG5cblx0XHRcdCMgc2hvdWxkIGFkZCBmb3IgKywgfiBldGNcblx0XHRcdCMgc2hvdWxkIG1heWJlIHJhdGhlciBsb29rIGZvciB0aGUgY29ycmVjdCB0eXBlIG9mIGNoYXJhY3Rlcj9cblx0XHRcblx0XHRcdGlmIG9wZW4gYW5kIChjaHIgPT0gJyAnIG9yIGNociA9PSAnXFxuJyBvciBjaHIgPT0gJywnIG9yIGNociA9PSAnKycgb3IgY2hyID09ICd+JyBvciBjaHIgPT0gJyknIG9yIGNociA9PSAnXScpXG5cdFx0XHRcdCMgY29uc29sZS5sb2cgXCJjbG9zZSB0aGlzIHNlbGVjdG9yIGRpcmVjdGx5XCJcblx0XHRcdFx0dG9rZW4oJ1NFTEVDVE9SX0VORCcsJyUnLDApXG5cdFx0XHRcdHBhaXIgJyUnXG5cdFx0XHRcdHJldHVybiAwXG5cblx0XHRcdGlmIG1hdGNoID0gU0VMRUNUT1JfQ09NQklOQVRPUi5leGVjKEBjaHVuaylcblx0XHRcdFx0IyBzcGFjZXMgYmV0d2Vlbj8gLS0gaW5jbHVkZSB0aGUgd2hvbGVcblx0XHRcdFx0dG9rZW4gJ1NFTEVDVE9SX0NPTUJJTkFUT1InLCBtYXRjaFsxXSB8fCBcIiBcIiwgbWF0Y2hbMF06bGVuZ3RoXG5cdFx0XHRcdHJldHVybiBtYXRjaFswXTpsZW5ndGhcblx0XHRcdFxuXHRcdFx0ZWxpZiBtYXRjaCA9IFNFTEVDVE9SX1BBUlQuZXhlYyhAY2h1bmspXG5cdFx0XHRcdHZhciB0eXBlID0gbWF0Y2hbMV1cblx0XHRcdFx0dmFyIGlkID0gbWF0Y2hbMl1cblxuXHRcdFx0XHR2YXIgdG9raWQgPSBzd2l0Y2ggdHlwZVxuXHRcdFx0XHRcdHdoZW4gJy4nIHRoZW4gJ1NFTEVDVE9SX0NMQVNTJ1xuXHRcdFx0XHRcdHdoZW4gJyMnIHRoZW4gJ1NFTEVDVE9SX0lEJ1xuXHRcdFx0XHRcdHdoZW4gJzonIHRoZW4gJ1NFTEVDVE9SX1BTRVVET19DTEFTUydcblx0XHRcdFx0XHR3aGVuICc6OicgdGhlbiAnU0VMRUNUT1JfUFNFVURPX0NMQVNTJ1xuXHRcdFx0XHRcdGVsc2UgJ1NFTEVDVE9SX1RBRydcblxuXHRcdFx0XHR0b2tlbiB0b2tpZCwgbWF0Y2hbMl0sIG1hdGNoWzBdOmxlbmd0aFxuXHRcdFx0XHRyZXR1cm4gbWF0Y2hbMF06bGVuZ3RoXG5cblx0XHRcdCMgZWxpZiBtYXRjaCA9IFNFTEVDVE9SX1BTRVVET19DTEFTUy5leGVjKEBjaHVuaylcblx0XHRcdCMgIHRva2VuIHRva2lkLCBtYXRjaFsyXVxuXHRcdFx0IyAgcmV0dXJuIG1hdGNoWzBdOmxlbmd0aFxuXHRcdFx0XG5cdFx0XHRlbGlmIGNociA9PSAnWydcblx0XHRcdFx0dG9rZW4oJ1snLCdbJywxKVxuXHRcdFx0XHRzZWxmLnB1c2hFbmQoJ10nKVxuXHRcdFx0XHRpZiBtYXRjaCA9IFNFTEVDVE9SX0FUVFIuZXhlYyhAY2h1bmspXG5cdFx0XHRcdFx0IyBmdWNrIHRoaXMgbGVuZ3RoIHNoaXRcblx0XHRcdFx0XHR2YXIgaWRvZmZzZXQgPSBtYXRjaFswXS5pbmRleE9mKG1hdGNoWzFdKVxuXHRcdFx0XHRcdHZhciBvcG9mZnNldCA9IG1hdGNoWzBdLmluZGV4T2YobWF0Y2hbMl0pXG5cdFx0XHRcdFx0dG9rZW4oJ0lERU5USUZJRVInLCBtYXRjaFsxXSwgbWF0Y2hbMV06bGVuZ3RoLCBpZG9mZnNldClcblx0XHRcdFx0XHR0b2tlbignU0VMRUNUT1JfQVRUUl9PUCcsIG1hdGNoWzJdLCBtYXRjaFsyXTpsZW5ndGgsIG9wb2Zmc2V0KVxuXHRcdFx0XHRcdHJldHVybiBtYXRjaFswXTpsZW5ndGhcblx0XHRcdFx0cmV0dXJuIDFcblxuXHRcdFx0ZWxpZiBjaHIgPT0gJ3wnXG5cdFx0XHRcdHZhciB0b2sgPSBAdG9rZW5zW0B0b2tlbnM6bGVuZ3RoIC0gMV1cblx0XHRcdFx0dFRzKHRvaywnU0VMRUNUT1JfTlMnKVxuXHRcdFx0XHQjIHRva1swXSA9ICdTRUxFQ1RPUl9OUycgIyBGSVhcblx0XHRcdFx0cmV0dXJuIDFcblxuXHRcdFx0ZWxpZiBjaHIgPT0gJywnXG5cdFx0XHRcdHRva2VuKCdTRUxFQ1RPUl9HUk9VUCcsJywnLDEpXG5cdFx0XHRcdHJldHVybiAxXG5cdFx0XHRlbGlmIGNociA9PSAnKidcblx0XHRcdFx0dG9rZW4oJ1VOSVZFUlNBTF9TRUxFQ1RPUicsJyonLDEpXG5cdFx0XHRcdHJldHVybiAxXG5cdFx0XHRcblx0XHRcdGVsaWYgY2hyID09ICcpJ1xuXHRcdFx0XHRwYWlyICclJ1xuXHRcdFx0XHR0b2tlbignU0VMRUNUT1JfRU5EJywnKScsMSlcblx0XHRcdFx0cmV0dXJuIDFcblxuXHRcdFx0ZWxpZiBjaHIgaW4gWycpJywnfScsJ10nLCcnXVxuXHRcdFx0XHRwYWlyICclJ1xuXHRcdFx0XHRyZXR1cm4gMFxuXG5cdFx0cmV0dXJuIDAgdW5sZXNzIG1hdGNoID0gU0VMRUNUT1IuZXhlYyhAY2h1bmspXG5cdFx0dmFyIFtpbnB1dCwgaWQsIGtpbmRdID0gbWF0Y2hcblxuXHRcdCMgdGhpcyBpcyBhIGNsb3NlZCBzZWxlY3RvclxuXHRcdGlmIGtpbmQgPT0gJygnXG5cdFx0XHQjIHRva2VuICcoJywnKCdcblx0XHRcdHRva2VuICdTRUxFQ1RPUl9TVEFSVCcsIGlkLCBpZDpsZW5ndGggKyAxXG5cdFx0XHQjIHNlbGYucHVzaEVuZCgnKScpICMgYXJlIHdlIHNvIHN1cmUgYWJvdXQgdGhpcz9cblx0XHRcdHNlbGYucHVzaEVuZCgnJScpXG5cblx0XHRcdCMgQGVuZHMucHVzaCAnKSdcblx0XHRcdCMgQGVuZHMucHVzaCAnJSdcblx0XHRcdHJldHVybiBpZDpsZW5ndGggKyAxXG5cblx0XHRlbGlmIGlkID09ICclJ1xuXHRcdFx0IyB3ZSBhcmUgYWxyZWFkeSBzY29wZWQgaW4gb24gYSBzZWxlY3RvclxuXHRcdFx0cmV0dXJuIDEgaWYgY29udGV4dCA9PSAnJSdcblx0XHRcdHRva2VuICdTRUxFQ1RPUl9TVEFSVCcsIGlkLCBpZDpsZW5ndGhcblx0XHRcdCMgdGhpcyBpcyBhIHNlcGFyYXRlIC0gc2NvcGUuIEZ1bGwgc2VsZWN0b3Igc2hvdWxkIHJhdGhlciBiZSAkLCBhbmQga2VlcCB0aGUgc2luZ2xlIHNlbGVjdG9yIGFzICVcblx0XHRcblx0XHRcdHNjb3BlKCclJywgb3BlbjogeWVzKVxuXHRcdFx0IyBAZW5kcy5wdXNoICclJ1xuXHRcdFx0IyBtYWtlIHN1cmUgYSB0ZXJtaW5hdG9yIGJyZWFrcyBvdXRcblx0XHRcdHJldHVybiBpZDpsZW5ndGhcblx0XHRlbHNlXG5cdFx0XHRyZXR1cm4gMFxuXHRcblx0IyBpcyB0aGlzIHJlYWxseSBuZWVkZWQ/IFNob3VsZCBiZSBwb3NzaWJsZSB0b1xuXHQjIHBhcnNlIHRoZSBpZGVudGlmaWVycyBhbmQgPSBldGMgaSBqaXNvbj9cblx0IyB3aGF0IGlzIHNwZWNpYWwgYWJvdXQgbWV0aG9kTmFtZVRva2VuPyByZWFsbHk/XG5cdGRlZiBtZXRob2ROYW1lVG9rZW5cblx0XHQjIHdlIGNhbiBvcHRpbWl6ZSB0aGlzIGJ5IGFmdGVyIGEgZGVmIHNpbXBseVxuXHRcdCMgZmV0Y2hpbmcgYWxsIHRoZSB3YXkgYWZ0ZXIgdGhlIGRlZiB1bnRpbCBhIHNwYWNlIG9yIChcblx0XHQjIGFuZCB0aGVuIGFkZCB0aGlzIHRvIHRoZSBkZWYtdG9rZW4gaXRzZWxmIChhcyB3aXRoIGZyYWdtZW50KVxuXHRcdHJldHVybiAwIGlmIEBjaHVuay5jaGFyQXQoMCkgPT0gJyAnXG5cblx0XHR2YXIgbWF0Y2hcblxuXHRcdGlmIEBlbmQgPT0gJyknXG5cdFx0XHR2YXIgb3V0ZXJjdHggPSBAZW5kc1tAZW5kczpsZW5ndGggLSAyXVxuXHRcdFx0IyB3ZWlyZCBhc3N1bXB0aW9uLCBubz9cblx0XHRcdCMgY29uc29sZS5sb2cgJ2NvbnRleHQgaXMgaW5zaWRlISEhJ1xuXHRcdFx0aWYgb3V0ZXJjdHggPT0gJyUnIGFuZCBtYXRjaCA9IFRBR19BVFRSLmV4ZWMoQGNodW5rKVxuXHRcdFx0XHR0b2tlbignVEFHX0FUVFJfU0VUJyxtYXRjaFsxXSlcblx0XHRcdFx0cmV0dXJuIG1hdGNoWzBdOmxlbmd0aFxuXG5cdFx0dW5sZXNzIG1hdGNoID0gTUVUSE9EX0lERU5USUZJRVIuZXhlYyhAY2h1bmspXG5cdFx0XHRyZXR1cm4gMFx0XHRcdFxuXHRcdCMgdmFyIHByZXYgPSBsYXN0IEB0b2tlbnNcblx0XHR2YXIgbGVuZ3RoID0gbWF0Y2hbMF06bGVuZ3RoXG5cdFx0XG5cdFx0dmFyIGlkID0gbWF0Y2hbMF1cblx0XHR2YXIgbHR5cCA9IEBsYXN0VHlwXG5cdFx0dmFyIHR5cCA9ICdJREVOVElGSUVSJ1xuXHRcdHZhciBwcmUgPSBpZC5jaGFyQXQoMClcblx0XHR2YXIgc3BhY2UgPSBub1xuXG5cdFx0dmFyIG00ID0gbWF0Y2hbNF0gIyBtaWdodCBiZSBvdXQgb2YgYm91bmRzPyBzaG91bGQgcmF0aGVyIGNoZWNrIGNoYXJBdFxuXHRcdCMgZHJvcCBtYXRjaCA0Pz9cblxuXHRcdCMgc2hvdWxkIHRoaXMgbm90IHF1aXQgaGVyZSBpbiBwcmFjdGljYWxseSBhbGwgY2FzZXM/XG5cdFx0dW5sZXNzIChsdHlwID09ICcuJyBvciBsdHlwID09ICdERUYnKSBvciAobTQgPT0gJyEnIG9yIG00ID09ICc/Jykgb3IgbWF0Y2hbNV1cblx0XHRcdHJldHVybiAwXG5cblx0XHQjIGFnYWluLCB3aHk/XG5cdFx0aWYgaWQgPT0gJ3NlbGYnIG9yIGlkID09ICd0aGlzJyBvciBpZCA9PSAnc3VwZXInICMgaW4gWydTRUxGJywnVEhJUyddXG5cdFx0XHRyZXR1cm4gMFxuXG5cdFx0aWYgaWQgPT0gJ25ldydcblx0XHRcdHR5cCA9ICdORVcnXG5cblx0XHRpZiBpZCA9PSAnLi4uJyBhbmQgWycsJywnKCcsJ0NBTExfU1RBUlQnLCdCTE9DS19QQVJBTV9TVEFSVCcsJ1BBUkFNX1NUQVJUJ10uaW5kZXhPZihsdHlwKSA+PSAwXG5cdFx0XHRyZXR1cm4gMFxuXG5cdFx0aWYgaWQgPT0gJ3wnXG5cdFx0XHQjIGhhY2t5IHdheSB0byBpbXBsZW1lbnQgdGhpc1xuXHRcdFx0IyB3aXRoIG5ldyBsZXhlciB3ZSdsbCB1c2UgeyAuLi4gfSBpbnN0ZWFkLCBhbmQgYXNzdW1lIG9iamVjdC1jb250ZXh0LFxuXHRcdFx0IyB0aGVuIGdvIGJhY2sgYW5kIGNvcnJlY3Qgd2hlbiB3ZSBzZWUgdGhlIGNvbnRleHQgaXMgaW52YWxpZFxuXHRcdFx0aWYgbHR5cCA9PSAnKCcgb3IgbHR5cCA9PSAnQ0FMTF9TVEFSVCdcblx0XHRcdFx0dG9rZW4oJ0RPJywgJ0RPJywwKVxuXHRcdFx0XHRzZWxmLnB1c2hFbmQoJ3wnKVxuXHRcdFx0XHQjIEBlbmRzLnB1c2ggJ3wnXG5cdFx0XHRcdHRva2VuKCdCTE9DS19QQVJBTV9TVEFSVCcsIGlkLDEpXG5cdFx0XHRcdHJldHVybiBsZW5ndGhcblxuXHRcdFx0ZWxpZiBsdHlwID09ICdETycgb3IgbHR5cCA9PSAneydcblx0XHRcdFx0IyBAZW5kcy5wdXNoICd8J1xuXHRcdFx0XHRzZWxmLnB1c2hFbmQoJ3wnKVxuXHRcdFx0XHR0b2tlbignQkxPQ0tfUEFSQU1fU1RBUlQnLCBpZCwxKVxuXHRcdFx0XHRyZXR1cm4gbGVuZ3RoXG5cdFx0XHRcdFxuXHRcdFx0ZWxpZiBAZW5kc1tAZW5kczpsZW5ndGggLSAxXSA9PSAnfCdcblx0XHRcdFx0dG9rZW4oJ0JMT0NLX1BBUkFNX0VORCcsICd8JywxKVxuXHRcdFx0XHRwYWlyICd8J1xuXHRcdFx0XHRyZXR1cm4gbGVuZ3RoXG5cdFx0XHRlbHNlXG5cdFx0XHRcdHJldHVybiAwXG5cblx0XHQjIHdoYWF0P1xuXHRcdCMgY29uc29sZS5sb2coXCJtZXRob2QgaWRlbnRpZmllclwiLGlkKVxuXHRcdGlmIChbJyYnLCdeJywnPDwnLCc8PDwnLCc+PiddLmluZGV4T2YoaWQpID49IDAgb3IgKGlkID09ICd8JyBhbmQgY29udGV4dCAhPSAnfCcpKVxuXHRcdFx0cmV0dXJuIDBcblxuXHRcdGlmIE9QX01FVEhPRFMuaW5kZXhPZihpZCkgPj0gMFxuXHRcdFx0c3BhY2UgPSB5ZXNcblxuXHRcdCMgbm90IGV2ZW4gYW55dGhpbmcgd2Ugc2hvdWxkIHVzZT8hP1xuXHRcdGlmIHByZSA9PSAnQCdcblx0XHRcdHR5cCA9ICdJVkFSJ1xuXG5cdFx0ZWxpZiBwcmUgPT0gJyQnXG5cdFx0XHR5ZXNcblx0XHRcdCMgdHlwID0gJ0dWQVInXG5cblxuXHRcdGVsaWYgcHJlID09ICcjJ1xuXHRcdFx0dHlwID0gJ1RBR0lEJ1xuXG5cdFx0ZWxpZiBDT05TVF9JREVOVElGSUVSLnRlc3QocHJlKSBvciBpZCA9PSAncmVxdWlyZScgb3IgaWQgPT0gJ2dsb2JhbCcgb3IgaWQgPT0gJ2V4cG9ydHMnXG5cdFx0XHQjIHJlYWxseT8gc2VlbXMgdmVyeSBzdHJhbmdlXG5cdFx0XHQjIGNvbnNvbGUubG9nKCdnbG9iYWwhIScsdHlwLGlkKVxuXHRcdFx0dHlwID0gJ0NPTlNUJ1xuXHRcdFxuXHRcdCMgd2hhdCBpcyB0aGlzIHJlYWxseSBmb3I/XG5cdFx0aWYgbWF0Y2hbNV0gYW5kIFsnSURFTlRJRklFUicsJ0NPTlNUJywnR1ZBUicsJ0NWQVInLCdJVkFSJywnU0VMRicsJ1RISVMnLCddJywnfScsJyknLCdOVU1CRVInLCdTVFJJTkcnLCdJRFJFRiddLmluZGV4T2YobHR5cCkgPj0gMFxuXHRcdFx0dG9rZW4oJy4nLCcuJywwKVxuXHRcblx0XHR0b2tlbih0eXAsIGlkLCBsZW5ndGgpXG5cblx0XHRpZiBzcGFjZVxuXHRcdFx0QGxhc3Q6c3BhY2VkID0geWVzXG5cblx0XHRyZXR1cm4gbGVuZ3RoXG5cblxuXHRkZWYgaW5UYWdcblx0XHR2YXIgbGVuID0gQGVuZHM6bGVuZ3RoXG5cdFx0aWYgbGVuID4gMFxuXHRcdFx0dmFyIGN0eDAgPSBAZW5kc1tsZW4gLSAxXVxuXHRcdFx0dmFyIGN0eDEgPSBsZW4gPiAxID8gQGVuZHNbbGVuIC0gMl0gOiBjdHgwXG5cdFx0XHRyZXR1cm4gY3R4MCA9PSAnVEFHX0VORCcgb3IgKGN0eDEgPT0gJ1RBR19FTkQnIGFuZCBjdHgwID09ICdPVVRERU5UJylcblx0XHRyZXR1cm4gZmFsc2VcblxuXHRkZWYgaXNLZXl3b3JkIGlkXG5cdFx0aWYgKGlkID09ICdhdHRyJyBvciBpZCA9PSAncHJvcCcpXG5cdFx0XHR2YXIgc2NvcCA9IGdldFNjb3BlXG5cdFx0XHR2YXIgaW5jbHMgPSBzY29wID09ICdDTEFTUycgb3Igc2NvcCA9PSAnVEFHJ1xuXHRcdFx0IyB2YXIgc2NvcGVzID0gQGluZGVudHMubWFwKHxpbmQsaXwgQHNjb3Blc1tpXSBvciAnTk9ORScpXG5cdFx0XHQjIGNvbnNvbGUubG9nIFwiaWQgaXMgcHJvcDoge3Njb3Blcy5qb2luKFwiIC0+IFwiKX0gfCB7QGluZGVudHMuam9pbihcIiAtPiBcIil9XCJcblx0XHRcdHJldHVybiB0cnVlIGlmIGluY2xzXG5cblx0XHRBTExfS0VZV09SRFMuaW5kZXhPZihpZCkgPj0gMFxuXG5cdCMgTWF0Y2hlcyBpZGVudGlmeWluZyBsaXRlcmFsczogdmFyaWFibGVzLCBrZXl3b3JkcywgbWV0aG9kIG5hbWVzLCBldGMuXG5cdCMgQ2hlY2sgdG8gZW5zdXJlIHRoYXQgSmF2YVNjcmlwdCByZXNlcnZlZCB3b3JkcyBhcmVuJ3QgYmVpbmcgdXNlZCBhc1xuXHQjIGlkZW50aWZpZXJzLiBCZWNhdXNlIEltYmEgcmVzZXJ2ZXMgYSBoYW5kZnVsIG9mIGtleXdvcmRzIHRoYXQgYXJlXG5cdCMgYWxsb3dlZCBpbiBKYXZhU2NyaXB0LCB3ZSdyZSBjYXJlZnVsIG5vdCB0byB0b2tpZCB0aGVtIGFzIGtleXdvcmRzIHdoZW5cblx0IyByZWZlcmVuY2VkIGFzIHByb3BlcnR5IG5hbWVzIGhlcmUsIHNvIHlvdSBjYW4gc3RpbGwgZG8gYGpRdWVyeS5pcygpYCBldmVuXG5cdCMgdGhvdWdoIGBpc2AgbWVhbnMgYD09PWAgb3RoZXJ3aXNlLlxuXHRkZWYgaWRlbnRpZmllclRva2VuXG5cdFx0dmFyIG1hdGNoXG5cblx0XHR2YXIgY3R4MCA9IEBlbmRzW0BlbmRzOmxlbmd0aCAtIDFdXG5cdFx0dmFyIGN0eDEgPSBAZW5kc1tAZW5kczpsZW5ndGggLSAyXVxuXHRcdHZhciBpbm5lcmN0eCA9IGN0eDBcblx0XHR2YXIgdHlwXG5cdFx0dmFyIHJlc2VydmVkID0gbm9cblxuXHRcdHZhciBhZGRMb2MgPSBmYWxzZVxuXHRcdHZhciBpblRhZyA9IGN0eDAgPT0gJ1RBR19FTkQnIG9yIChjdHgxID09ICdUQUdfRU5EJyBhbmQgY3R4MCA9PSAnT1VUREVOVCcpXG5cblx0XHQjIGNvbnNvbGUubG9nIGN0eDEsY3R4MFxuXHRcblx0XHRpZiBpblRhZyAmJiBtYXRjaCA9IFRBR19BVFRSLmV4ZWMoQGNodW5rKVxuXHRcdFx0IyBjb25zb2xlLmxvZyAnVEFHX0FUVFIgSU4gdG9raWQnLG1hdGNoXG5cdFx0XHQjIHZhciBwcmV2ID0gbGFzdCBAdG9rZW5zXG5cdFx0XHQjIGlmIHRoZSBwcmV2IGlzIGEgdGVybWluYXRvciwgd2UgZG9udCByZWFsbHkgbmVlZCB0byBjYXJlP1xuXHRcdFx0aWYgQGxhc3RUeXAgIT0gJ1RBR19OQU1FJ1xuXHRcdFx0XHRpZiBAbGFzdFR5cCA9PSAnVEVSTUlOQVRPUidcblx0XHRcdFx0XHQjIGNvbnNvbGUubG9nKCdwcmV2IHdhcyB0ZXJtaW5hdG9yIC0tIGRyb3AgaXQ/Jylcblx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHR0b2tlbihcIixcIiwgXCIsXCIpXG5cblx0XHRcdHZhciBsID0gbWF0Y2hbMF06bGVuZ3RoXG5cblx0XHRcdHRva2VuICdUQUdfQVRUUicsbWF0Y2hbMV0sbCAtIDEgICMgYWRkIHRvIGxvYz9cblx0XHRcdEBsb2MgKz0gbCAtIDFcblx0XHRcdHRva2VuICc9JywnPScsMVxuXHRcdFx0cmV0dXJuIGxcblxuXHRcdCMgc2VlIGlmIHRoaXMgaXMgYSBwbGFpbiBvYmplY3Qta2V5XG5cdFx0IyB3YXkgdG9vIG11Y2ggbG9naWMgZ29pbmcgb24gaGVyZT9cblx0XHQjIHRoZSBhc3Qgc2hvdWxkIG5vcm1hbGl6ZSB3aGV0aGVyIGtleXNcblx0XHQjIGFyZSBhY2Nlc3NhYmxlIGFzIGtleXMgb3Igc3RyaW5ncyBldGNcblx0XHRpZiBtYXRjaCA9IE9CSkVDVF9LRVkuZXhlYyhAY2h1bmspXG5cdFx0XHR2YXIgaWQgPSBtYXRjaFsxXVxuXHRcdFx0dmFyIHR5cCA9ICdJREVOVElGSUVSJ1xuXG5cdFx0XHQjIEZJWE1FIGxvYyBvZiBrZXkgaW5jbHVkZXMgY29sb25cblx0XHRcdCMgbW92ZUNhcmV0KGlkOmxlbmd0aClcblx0XHRcdCMgY29uc29sZS5sb2cgXCJva1wiXG5cdFx0XHRpZiB0cnVlXG5cdFx0XHRcdCMgY29uc29sZS5sb2cgXCJnb3QgaGVyZT8ge21hdGNofVwiXG5cdFx0XHRcdHRva2VuKHR5cCwgaWQsIGlkOmxlbmd0aClcblx0XHRcdFx0bW92ZUNhcmV0KGlkOmxlbmd0aClcblx0XHRcdFx0dG9rZW4gJzonLCAnOicsIG1hdGNoWzNdOmxlbmd0aFxuXHRcdFx0XHRtb3ZlQ2FyZXQoLWlkOmxlbmd0aClcblx0XHRcdFx0IyBtb3ZlQ2FyZXQobWF0Y2hbM106bGVuZ3RoKVxuXHRcdFx0XHRyZXR1cm4gbWF0Y2hbMF06bGVuZ3RoXG5cblx0XHRcdCMgbW92ZUNhcmV0KG1hdGNoWzJdOmxlbmd0aClcblx0XHRcdCMgcmV0dXJuIDBcblx0XHRcdCMgY29uc29sZS5sb2cgbWF0Y2hbM106bGVuZ3RoXG5cdFx0XHR0b2tlbiB0eXAsIGlkLCBtYXRjaFswXTpsZW5ndGhcblx0XHRcdHRva2VuICc6JywgJzonLDFcblx0XHRcdHJldHVybiBtYXRjaFswXTpsZW5ndGhcblxuXHRcdHVubGVzcyBtYXRjaCA9IElERU5USUZJRVIuZXhlYyhAY2h1bmspXG5cdFx0XHRyZXR1cm4gMFxuXG5cdFx0dmFyIFtpbnB1dCwgaWQsIHR5cCwgbTMsIG00LCBjb2xvbl0gPSBtYXRjaFxuXHRcdHZhciBpZGxlbiA9IGlkOmxlbmd0aFxuXG5cdFx0IyBXaGF0IGlzIHRoZSBsb2dpYyBoZXJlP1xuXHRcdGlmIGlkIGlzICdvd24nIGFuZCBsYXN0VG9rZW5UeXBlID09ICdGT1InXG5cdFx0XHR0b2tlbiAnT1dOJywgaWQsIGlkOmxlbmd0aFxuXHRcdFx0cmV0dXJuIGlkOmxlbmd0aFxuXG5cdFx0dmFyIHByZXYgPSBsYXN0KEB0b2tlbnMpXG5cdFx0dmFyIGxhc3RUeXAgPSBAbGFzdFR5cFxuXG5cdFx0IyBzaG91bGQgd2UgZm9yY2UgdGhpcyB0byBiZSBhbiBpZGVudGlmaWVyIGV2ZW4gaWYgaXQgaXMgYSByZXNlcnZlZCB3b3JkP1xuXHRcdCMgdGhpcyBzaG91bGQgb25seSBoYXBwZW4gZm9yIHdoZW4gcGFydCBvZiBvYmplY3QgZXRjXG5cdFx0IyB3aWxsIHByZXYgZXZlciBiZSBAPz8/XG5cdFx0dmFyIGZvcmNlZElkZW50aWZpZXJcblxuXHRcdCMgYWdhaW5cblx0XHRmb3JjZWRJZGVudGlmaWVyID0gY29sb24gfHwgbGFzdFR5cCA9PSAnLicgb3IgbGFzdFR5cCA9PSAnPy4nICMgaW4gWycuJywgJz8uJ1xuXG5cblx0XHQjIHRlbXAgaGFjayEgbmVlZCB0byBzb2x2ZSBmb3Igb3RoZXIga2V5d29yZHMgZXRjIGFzIHdlbGxcblx0XHQjIHByb2JsZW0gYXBwZWFycyB3aXRoIHRlcm5hcnkgY29uZGl0aW9ucy5cblxuXHRcdCMgd2VsbCAtLSBpdCBzaG91bGQgc3RpbGwgYmUgYW4gaW5kZW50aWZpZXIgaWYgaW4gb2JqZWN0P1xuXHRcdCMgZm9yY2VkSWRlbnRpZmllciA9IG5vIGlmIGlkIGluIFsndW5kZWZpbmVkJywnYnJlYWsnXVxuXG5cdFx0Zm9yY2VkSWRlbnRpZmllciA9IG5vIGlmIGNvbG9uIGFuZCBsYXN0VHlwID09ICc/JyAjIGZvciB0ZXJuYXJ5XG5cblx0XHQjIGlmIHdlIGFyZSBub3QgYXQgdGhlIHRvcCBsZXZlbD8gLS0gaGFja3lcblx0XHRpZiBpZCA9PSAndGFnJyBhbmQgQGNodW5rLmluZGV4T2YoXCJ0YWcoXCIpID09IDAgIyBAY2h1bmsubWF0Y2goL150b2tpZFxcKC8pXG5cdFx0XHRmb3JjZWRJZGVudGlmaWVyID0geWVzXG5cblx0XHR2YXIgaXNLZXl3b3JkID0gbm9cblxuXHRcdCMgY29uc29sZS5sb2cgXCJtYXRjaFwiLG1hdGNoXG5cdFx0IyBjb25zb2xlLmxvZyBcInR5cCBpcyB7dHlwfVwiXG5cdFx0IyBsaXR0bGUgcmVhc29uIHRvIGNoZWNrIGZvciB0aGlzIHJpZ2h0IGhlcmU/IGJ1dCBJIGd1ZXNzIGl0IGlzIG9ubHkgYSBzaW1wbGUgY2hlY2tcblx0XHRpZiB0eXAgPT0gJyQnIGFuZCBBUkdWQVIudGVzdChpZCkgIyBpZC5tYXRjaCgvXlxcJFxcZCQvKVxuXHRcdFx0IyBjb25zb2xlLmxvZyBcIlRZUCAkXCJcblx0XHRcdGlmIGlkID09ICckMCdcblx0XHRcdFx0dHlwID0gJ0FSR1VNRU5UUydcblx0XHRcdGVsc2Vcblx0XHRcdFx0dHlwID0gJ0FSR1ZBUidcblx0XHRcdFx0aWQgPSBpZC5zdWJzdHIoMSlcblxuXHRcdGVsaWYgdHlwID09ICdAJ1xuXHRcdFx0dHlwID0gJ0lWQVInXG5cblx0XHRcdCMgaWQ6cmVzZXJ2ZWQgPSB5ZXMgaWYgY29sb25cblx0XHRlbGlmIHR5cCA9PSAnIydcblx0XHRcdCMgd2UgYXJlIHRyeWluZyB0byBtb3ZlIHRvIGdlbmVyaWMgdG9rZW5zLFxuXHRcdFx0IyBzbyB3ZSBhcmUgc3RhcnRpbmcgdG8gc3BsaXR0aW5nIHVwIHRoZSBzeW1ib2xzIGFuZCB0aGUgaXRlbXNcblx0XHRcdCMgd2UnbGwgc2VlIGlmIHRoYXQgd29ya3Ncblx0XHRcdHR5cCA9ICdJREVOVElGSUVSJ1xuXHRcdFx0dG9rZW4gJyMnLCAnIydcblx0XHRcdGlkID0gaWQuc3Vic3RyKDEpXG5cblx0XHRlbGlmIHR5cCA9PSAnQEAnXG5cdFx0XHR0eXAgPSAnQ1ZBUidcblxuXHRcdGVsaWYgdHlwID09ICckJyBhbmQgIWNvbG9uXG5cdFx0XHR0eXAgPSAnSURFTlRJRklFUidcblx0XHRcdCMgdHlwID0gJ0dWQVInXG5cblx0XHRlbGlmIENPTlNUX0lERU5USUZJRVIudGVzdChpZCkgb3IgaWQgPT0gJ3JlcXVpcmUnIG9yIGlkID09ICdnbG9iYWwnIG9yIGlkID09ICdleHBvcnRzJ1xuXHRcdFx0IyB0aG91cyBzaG91bGQgcmVhbGx5IGJlIGhhbmRsZWQgYnkgdGhlIGFzdCBpbnN0ZWFkXG5cdFx0XHR0eXAgPSAnQ09OU1QnXG5cblx0XHRlbGlmIGlkID09ICdlbGlmJ1xuXHRcdFx0dG9rZW4gJ0VMU0UnLCAnZWxpZicsIGlkOmxlbmd0aFxuXHRcdFx0dG9rZW4gJ0lGJywgJ2lmJ1xuXHRcdFx0cmV0dXJuIGlkOmxlbmd0aFxuXG5cdFx0ZWxzZVxuXHRcdFx0dHlwID0gJ0lERU5USUZJRVInXG5cblxuXG5cdFx0IyB0aGlzIGNhdGNoZXMgYWxsIFxuXHRcdGlmICFmb3JjZWRJZGVudGlmaWVyIGFuZCBpc0tleXdvcmQgPSBzZWxmLmlzS2V5d29yZChpZClcblx0XHRcdCMgKGlkIGluIEpTX0tFWVdPUkRTIG9yIGlkIGluIElNQkFfS0VZV09SRFMpXG5cdFx0XHR0eXAgPSBpZC50b1VwcGVyQ2FzZVxuXHRcdFx0YWRkTG9jID0gdHJ1ZVxuXG5cdFx0XHQjIGNsdW1zeSAtIGJ1dCB0ZXN0aW5nIHBlcmZvcm1hbmNlXG5cdFx0XHRpZiB0eXAgPT0gJ1lFUydcblx0XHRcdFx0dHlwID0gJ1RSVUUnXG5cdFx0XHRlbGlmIHR5cCA9PSAnTk8nXG5cdFx0XHRcdHR5cCA9ICdGQUxTRSdcblx0XHRcdGVsaWYgdHlwID09ICdOSUwnXG5cdFx0XHRcdHR5cCA9ICdOVUxMJ1xuXG5cdFx0XHRlbGlmIHR5cCA9PSAnVkFSJ1xuXHRcdFx0XHRpZiBAbGFzdFZhbCA9PSAnZXhwb3J0J1xuXHRcdFx0XHRcdHRUcyhwcmV2LCdFWFBPUlQnKVxuXG5cdFx0XHQjIHNraXBwaW5nIFxuXHRcdFx0ZWxpZiB0eXAgPT0gJ0lGJyBvciB0eXAgPT0gJ0VMU0UnIG9yIHR5cCA9PSAnVFJVRScgb3IgdHlwID09ICdGQUxTRScgb3IgdHlwID09ICdOVUxMJ1xuXHRcdFx0XHR0cnVlXG5cdFx0XHRlbGlmIHR5cCA9PSAnVEFHJ1xuXHRcdFx0XHRzZWxmLnB1c2hFbmQoJ1RBRycpXG5cdFx0XHRcdCMgQGVuZHMucHVzaCgnVEFHJylcblx0XHRcdCMgRklYTUUgQGVuZHMgaXMgbm90IHVzZWQgdGhlIHdheSBpdCBpcyBzdXBwb3NlZCB0by4uXG5cdFx0XHQjIHdoYXQgd2Ugd2FudCBpcyBhIGNvbnRleHQtc3RhY2tcblx0XHRcdGVsaWYgdHlwID09ICdERUYnXG5cdFx0XHRcdCMgc2hvdWxkIHByb2JhYmx5IHNoaWZ0IGNvbnRleHQgYW5kIG9wdGltaXplIHRoaXNcblx0XHRcdFx0b3BlbkRlZlxuXG5cdFx0XHRlbGlmIHR5cCA9PSAnRE8nXG5cdFx0XHRcdGNsb3NlRGVmIGlmIGNvbnRleHQgPT0gJ0RFRidcblxuXHRcdFx0ZWxpZiB0eXAgaXMgJ1dIRU4nIGFuZCBMSU5FX0JSRUFLLmluZGV4T2YobGFzdFRva2VuVHlwZSkgPj0gMFxuXHRcdFx0XHR0eXAgPSAnTEVBRElOR19XSEVOJ1xuXG5cdFx0XHRlbGlmIHR5cCBpcyAnRk9SJ1xuXHRcdFx0XHRAc2VlbkZvciA9IHllc1xuXG5cdFx0XHRlbGlmIHR5cCBpcyAnVU5MRVNTJ1xuXHRcdFx0XHR0eXAgPSAnSUYnICMgV0FSTlxuXG5cdFx0XHRlbGlmIFVOQVJZLmluZGV4T2YodHlwKSA+PSAwXG5cdFx0XHRcdHR5cCA9ICdVTkFSWSdcblxuXHRcdFx0ZWxpZiBSRUxBVElPTi5pbmRleE9mKHR5cCkgPj0gMFxuXHRcdFx0XHRpZiB0eXAgIT0gJ0lOU1RBTkNFT0YnIGFuZCB0eXAgIT0gJ0lTQScgYW5kIEBzZWVuRm9yXG5cdFx0XHRcdFx0dHlwID0gJ0ZPUicgKyB0eXAgIyA/XG5cdFx0XHRcdFx0QHNlZW5Gb3IgPSBub1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0dHlwID0gJ1JFTEFUSU9OJ1xuXHRcdFx0XHRcdGlmIFN0cmluZyh2YWx1ZSkgPT0gJyEnXG5cdFx0XHRcdFx0XHRAdG9rZW5zLnBvcCAjIGlzIGZ1Y2tlZCB1cD8/IVxuXHRcdFx0XHRcdFx0IyBXQVJOIHdlIG5lZWQgdG8ga2VlcCB0aGUgbG9jLCBubz9cblx0XHRcdFx0XHRcdGlkID0gJyEnICsgaWRcblxuXHRcdGlmIGlkID09ICdzdXBlcidcblx0XHRcdHR5cCA9ICdTVVBFUidcblxuXHRcdCMgZG8gd2UgcmVhbGx5IHdhbnQgdG8gY2hlY2sgdGhpcyBoZXJlXG5cdFx0aWYgIWZvcmNlZElkZW50aWZpZXJcblx0XHRcdCMgc2hvdWxkIGFscmVhZHkgaGF2ZSBkZWFsdCB3aXRoIHRoaXNcblxuXHRcdFx0aWQgPSBJTUJBX0FMSUFTX01BUFtpZF0gaWYgaXNLZXl3b3JkIGFuZCBJTUJBX0FMSUFTRVMuaW5kZXhPZihpZCkgPj0gMFxuXHRcdFx0IyB0aGVzZSByZWFsbHkgc2hvdWxkIG5vdCBnbyBoZXJlPyE/XG5cdFx0XHRzd2l0Y2ggaWRcblx0XHRcdFx0d2hlbiAnIScgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbiB0eXAgPSAnVU5BUlknXG5cdFx0XHRcdHdoZW4gJz09JywgJyE9JywgJz09PScsICchPT0nICAgICAgICAgICAgIHRoZW4gdHlwID0gJ0NPTVBBUkUnXG5cdFx0XHRcdHdoZW4gJyYmJywgJ3x8JyAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZW4gdHlwID0gJ0xPR0lDJ1xuXHRcdFx0XHR3aGVuICdicmVhaycsICdjb250aW51ZScsICdkZWJ1Z2dlcicsJ2FyZ3VtZW50cycgdGhlbiB0eXAgPSBpZC50b1VwcGVyQ2FzZVxuXHRcdFx0XHQjIHdoZW4gJ3RydWUnLCAnZmFsc2UnLCAnbnVsbCcsICd1bmRlZmluZWQnIHRoZW4gdHlwID0gJ0JPT0wnXG5cdFx0XHRcdCMgcmVhbGx5P1xuXG5cdFx0IyBwcmV2ID0gbGFzdCBAdG9rZW5zXG5cdFx0dmFyIGxlbiA9IGlucHV0Omxlbmd0aFxuXG5cdFx0IyBzaG91bGQgYmUgc3RyaWN0IGFib3V0IHRoZSBvcmRlciwgY2hlY2sgdGhpcyBtYW51YWxseSBpbnN0ZWFkXG5cdFx0aWYgdHlwID09ICdDTEFTUycgb3IgdHlwID09ICdERUYnIG9yIHR5cCA9PSAnVEFHJ1xuXHRcdFx0cXVldWVTY29wZSh0eXApXG5cblx0XHRcdHZhciBpID0gQHRva2VuczpsZW5ndGhcblxuXHRcdFx0d2hpbGUgaVxuXHRcdFx0XHR2YXIgcHJldiA9IEB0b2tlbnNbLS1pXVxuXHRcdFx0XHR2YXIgY3RybCA9IFwiXCIgKyB0VihwcmV2KVxuXHRcdFx0XHQjIGNvbnNvbGUubG9nKFwiY3RybCBpcyB7Y3RybH1cIilcblx0XHRcdFx0IyBuZWVkIHRvIGNvZXJjZSB0byBzdHJpbmcgYmVjYXVzZSBvZiBzdHVwaWQgQ1MgPT09XG5cdFx0XHRcdCMgY29uc29sZS5sb2coXCJwcmV2IGlzXCIscHJldlswXSxwcmV2WzFdKVxuXHRcdFx0XHRpZiBjdHJsIGluIElNQkFfQ09OVEVYVFVBTF9LRVlXT1JEU1xuXHRcdFx0XHRcdHRUcyhwcmV2LGN0cmwudG9VcHBlckNhc2UpXG5cdFx0XHRcdFx0IyBwcmV2WzBdID0gY3RybC50b1VwcGVyQ2FzZSAjIEZJWFxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0YnJlYWtcblxuXHRcdGVsaWYgdHlwID09ICdJRidcblx0XHRcdHF1ZXVlU2NvcGUodHlwKVxuXG5cdFx0ZWxpZiB0eXAgPT0gJ0lNUE9SVCdcblx0XHRcdCMgY291bGQgbWFudWFsbHkgcGFyc2UgdGhlIHdob2xlIHRpbmcgaGVyZT9cblx0XHRcdHB1c2hFbmQoJ0lNUE9SVCcpXG5cdFx0XHQjIEBlbmRzLnB1c2ggJ0lNUE9SVCdcblxuXHRcdGVsaWYgaWQgPT0gJ2Zyb20nIGFuZCBjdHgwID09ICdJTVBPUlQnXG5cdFx0XHR0eXAgPSAnRlJPTSdcblx0XHRcdHBhaXIgJ0lNUE9SVCdcblxuXHRcdCMgd2lsbCBiZSBtdWNoIGNsZWFuZXIgd2l0aCB0aGUgbmV3IGhhbmRtYWRlIGNvbWJpbmVkIGxleGVyK3BhcnNlclxuXHRcdCMgZm9yIG5vdyB3ZSBuZWVkIHRvIGRvIHNvbWUgdGVzdGluZ1xuXHRcdGVsaWYgaWQgPT0gJ2FzJyBhbmQgY3R4MCA9PSAnSU1QT1JUJ1xuXHRcdFx0dHlwID0gJ0FTJ1xuXHRcdFx0cGFpciAnSU1QT1JUJ1xuXG5cdFx0aWYgdHlwID09ICdJREVOVElGSUVSJ1xuXHRcdFx0IyBzZWUgaWYgcHJldmlvdXMgd2FzIGNhdGNoIC0tIGJlbG9uZ3MgaW4gcmV3cml0ZXI/XG5cdFx0XHRpZiBsYXN0VHlwID09ICdDQVRDSCdcblx0XHRcdFx0dHlwID0gJ0NBVENIX1ZBUidcblx0XHRcblx0XHRpZiBjb2xvblxuXHRcdFx0dG9rZW4odHlwLCBpZCwgaWRsZW4pXG5cdFx0XHRtb3ZlQ2FyZXQoaWRsZW4pXG5cdFx0XHQjIGNvbnNvbGUubG9nIFwiYWRkIGNvbG9uP1wiXG5cdFx0XHR0b2tlbignOicsICc6Jyxjb2xvbjpsZW5ndGgpXG5cdFx0XHRtb3ZlQ2FyZXQoLWlkbGVuKVxuXHRcdGVsc2Vcblx0XHRcdHRva2VuKHR5cCwgaWQsIGlkbGVuKVxuXG5cdFx0cmV0dXJuIGxlblxuXG5cdCMgTWF0Y2hlcyBudW1iZXJzLCBpbmNsdWRpbmcgZGVjaW1hbHMsIGhleCwgYW5kIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxuXHQjIEJlIGNhcmVmdWwgbm90IHRvIGludGVyZmVyZSB3aXRoIHJhbmdlcy1pbi1wcm9ncmVzcy5cblx0ZGVmIG51bWJlclRva2VuXG5cdFx0dmFyIG1hdGNoLCBudW1iZXIsIGxleGVkTGVuZ3RoXG5cblx0XHRyZXR1cm4gMCB1bmxlc3MgbWF0Y2ggPSBOVU1CRVIuZXhlYyhAY2h1bmspXG5cblx0XHRudW1iZXIgPSBtYXRjaFswXVxuXHRcdGxleGVkTGVuZ3RoID0gbnVtYmVyOmxlbmd0aFxuXG5cdFx0aWYgdmFyIGJpbmFyeUxpdGVyYWwgPSAvMGIoWzAxXSspLy5leGVjKG51bWJlcilcblx0XHRcdFxuXHRcdFx0bnVtYmVyID0gXCJcIiArIHBhcnNlSW50KGJpbmFyeUxpdGVyYWxbMV0sIDIpXG5cblx0XHR2YXIgcHJldiA9IGxhc3QoQHRva2VucylcblxuXHRcdGlmIG1hdGNoWzBdWzBdID09ICcuJyAmJiBwcmV2ICYmICFwcmV2OnNwYWNlZCAmJiBbJ0lERU5USUZJRVInLCcpJywnfScsJ10nLCdOVU1CRVInXS5pbmRleE9mKHRUKHByZXYpKSA+PSAwXG5cdFx0XHQjIGNvbnNvbGUubG9nIFwiZ290IGhlcmVcIlxuXHRcdFx0dG9rZW4gXCIuXCIsXCIuXCJcblx0XHRcdG51bWJlciA9IG51bWJlci5zdWJzdHIoMSlcblx0XHRcblxuXHRcdHRva2VuKCdOVU1CRVInLG51bWJlcixsZXhlZExlbmd0aClcblx0XHRyZXR1cm4gbGV4ZWRMZW5ndGhcblx0XG5cdGRlZiBzeW1ib2xUb2tlblxuXHRcdHZhciBtYXRjaCwgc3ltYm9sLCBwcmV2XG5cblx0XHRyZXR1cm4gMCB1bmxlc3MgbWF0Y2ggPSBTWU1CT0wuZXhlYyhAY2h1bmspXG5cdFx0c3ltYm9sID0gbWF0Y2hbMF0uc3Vic3RyKDEpXG5cdFx0cHJldiA9IGxhc3QoQHRva2VucylcblxuXHRcdCMgaXMgdGhpcyBhIHByb3BlcnR5LWFjY2Vzcz9cblx0XHQjIHNob3VsZCBpbnZlcnQgdGhpcyAtLSBvbmx5IGFsbG93IHdoZW4gcHJldiBJUyAuLiBcblx0XG5cdFx0IyA6IHNob3VsZCBiZSBhIHRva2VuIGl0c2VsZiwgd2l0aCBhIHNwZWNpZmljYXRpb24gb2Ygc3BhY2luZyAoTFIsUixMLE5PTkUpXG5cblx0XHQjIEZJWFxuXHRcdGlmIHByZXYgYW5kICFwcmV2OnNwYWNlZCBhbmQgdFQocHJldikgbm90IGluIFsnKCcsJ3snLCdbJywnLicsJ0NBTExfU1RBUlQnLCdJTkRFWF9TVEFSVCcsJywnLCc9JywnSU5ERU5UJywnVEVSTUlOQVRPUiddXG5cdFx0XHR0b2tlbiAnLjonLCc6JywgMVxuXHRcdFx0dmFyIHN5bSA9IHN5bWJvbC5zcGxpdCgvW1xcOlxcXFxcXC9dLylbMF0gIyByZWFsbHk/XG5cdFx0XHQjIHRva2VuICdTWU1CT0wnLCBcIicje3N5bWJvbH0nXCJcblx0XHRcdHRva2VuICdJREVOVElGSUVSJywgc3ltLCBzeW06bGVuZ3RoLCAxXG5cdFx0XHRyZXR1cm4gKHN5bTpsZW5ndGggKyAxKVxuXHRcdGVsc2Vcblx0XHRcdCMgdG9rZW4gJ1NZTUJPTCcsIFwiJyN7c3ltYm9sfSdcIlxuXHRcdFx0dG9rZW4gJ1NZTUJPTCcsIHN5bWJvbCwgbWF0Y2hbMF06bGVuZ3RoXG5cdFx0XHRtYXRjaFswXTpsZW5ndGhcblxuXHRkZWYgZXNjYXBlU3RyIHN0ciwgaGVyZWRvYywgcVxuXHRcdHN0ciA9IHN0ci5yZXBsYWNlIE1VTFRJTElORVIsIChoZXJlZG9jID8gJ1xcXFxuJyA6ICcnKVxuXHRcdGlmIHFcblx0XHRcdHZhciByID0gUmVnRXhwKFwiXFxcXFxcXFxbe3F9XVwiLFwiZ1wiKVxuXHRcdFx0c3RyID0gc3RyLnJlcGxhY2UocixxKVxuXHRcdFx0c3RyID0gc3RyLnJlcGxhY2UgUmVnRXhwKFwie3F9XCIsXCJnXCIpLCAnXFxcXCQmJ1xuXHRcdHJldHVybiBzdHJcblxuXHRcdCMgc3RyID0gc3RyLnJlcGxhY2UoTVVMVElMSU5FUiwgJ1xcXFxuJylcblx0XHQjIHN0ciA9IHN0ci5yZXBsYWNlKC9cXHQvZywgJ1xcXFx0Jylcblx0IyBNYXRjaGVzIHN0cmluZ3MsIGluY2x1ZGluZyBtdWx0aS1saW5lIHN0cmluZ3MuIEVuc3VyZXMgdGhhdCBxdW90YXRpb24gbWFya3Ncblx0IyBhcmUgYmFsYW5jZWQgd2l0aGluIHRoZSBzdHJpbmcncyBjb250ZW50cywgYW5kIHdpdGhpbiBuZXN0ZWQgaW50ZXJwb2xhdGlvbnMuXG5cdGRlZiBzdHJpbmdUb2tlblxuXHRcdHZhciBtYXRjaCwgc3RyaW5nXG5cblx0XHRzd2l0Y2ggQGNodW5rLmNoYXJBdCgwKVxuXHRcdFx0d2hlbiBcIidcIlxuXHRcdFx0XHRyZXR1cm4gMCB1bmxlc3MgbWF0Y2ggPSBTSU1QTEVTVFIuZXhlYyhAY2h1bmspXG5cdFx0XHRcdHN0cmluZyA9IG1hdGNoWzBdXG5cdFx0XHRcdHRva2VuICdTVFJJTkcnLCBlc2NhcGVTdHIoc3RyaW5nKSwgc3RyaW5nOmxlbmd0aFxuXHRcdFx0XHQjIHRva2VuICdTVFJJTkcnLCAoc3RyaW5nID0gbWF0Y2hbMF0pLnJlcGxhY2UoTVVMVElMSU5FUiwgJ1xcXFxcXG4nKSwgc3RyaW5nOmxlbmd0aFxuXG5cdFx0XHR3aGVuICdcIidcblx0XHRcdFx0cmV0dXJuIDAgdW5sZXNzIHN0cmluZyA9IGJhbGFuY2VkU3RyaW5nKEBjaHVuaywgJ1wiJylcblx0XHRcdFx0IyB3aGF0IGFib3V0IHRyaXBlIHF1b3RlZCBzdHJpbmdzP1xuXG5cdFx0XHRcdGlmIHN0cmluZy5pbmRleE9mKCd7JykgPj0gMFxuXHRcdFx0XHRcdHZhciBsZW4gPSBzdHJpbmc6bGVuZ3RoXG5cdFx0XHRcdFx0IyBpZiB0aGlzIGhhcyBubyBpbnRlcnBvbGF0aW9uP1xuXHRcdFx0XHRcdCMgd2UgYXJlIG5vdyBtZXNzaW5nIHdpdGggbG9jYXRpb25zIC0gYmV3YXJlXG5cdFx0XHRcdFx0dG9rZW4gJ1NUUklOR19TVEFSVCcsIHN0cmluZy5jaGFyQXQoMCksIDFcblx0XHRcdFx0XHRpbnRlcnBvbGF0ZVN0cmluZyhzdHJpbmcuc2xpY2UgMSwgLTEpXG5cdFx0XHRcdFx0dG9rZW4gJ1NUUklOR19FTkQnLCBzdHJpbmcuY2hhckF0KGxlbiAtIDEpLCAxLCBzdHJpbmc6bGVuZ3RoIC0gMVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0dmFyIGxlbiA9IHN0cmluZzpsZW5ndGhcblx0XHRcdFx0XHQjIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKE1VTFRJTElORVIsICdcXFxcXFxuJylcblx0XHRcdFx0XHR0b2tlbiAnU1RSSU5HJywgZXNjYXBlU3RyKHN0cmluZyksIGxlblxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRyZXR1cm4gMFxuXG5cdFx0bW92ZUhlYWQoc3RyaW5nKVxuXHRcdHJldHVybiBzdHJpbmc6bGVuZ3RoXG5cblx0IyBNYXRjaGVzIGhlcmVkb2NzLCBhZGp1c3RpbmcgaW5kZW50YXRpb24gdG8gdGhlIGNvcnJlY3QgbGV2ZWwsIGFzIGhlcmVkb2NzXG5cdCMgcHJlc2VydmUgd2hpdGVzcGFjZSwgYnV0IGlnbm9yZSBpbmRlbnRhdGlvbiB0byB0aGUgbGVmdC5cblx0ZGVmIGhlcmVkb2NUb2tlblxuXHRcdHZhciBtYXRjaCwgaGVyZWRvYywgcXVvdGUsIGRvY1xuXG5cdFx0cmV0dXJuIDAgdW5sZXNzIG1hdGNoID0gSEVSRURPQy5leGVjKEBjaHVuaylcblxuXHRcdGhlcmVkb2MgPSBtYXRjaFswXVxuXHRcdHF1b3RlID0gaGVyZWRvYy5jaGFyQXQgMFxuXHRcdGRvYyA9IHNhbml0aXplSGVyZWRvYyhtYXRjaFsyXSwgcXVvdGU6IHF1b3RlLCBpbmRlbnQ6IG51bGwpXG5cdFx0IyBjb25zb2xlLmxvZyBcImZvdW5kIGhlcmVkb2Mge21hdGNoWzBdOmxlbmd0aH0ge2RvYzpsZW5ndGh9XCJcblxuXHRcdGlmIHF1b3RlID09ICdcIicgJiYgZG9jLmluZGV4T2YoJ3snKSA+PSAwXG5cdFx0XHR2YXIgb3BlbiA9IG1hdGNoWzFdXG5cdFx0XHQjIGNvbnNvbGUubG9nIGRvYy5zdWJzdHIoMCwzKSxtYXRjaFsxXVxuXHRcdFx0dG9rZW4gJ1NUUklOR19TVEFSVCcsIG9wZW4sIG9wZW46bGVuZ3RoXG5cdFx0XHRpbnRlcnBvbGF0ZVN0cmluZyhkb2MsIGhlcmVkb2M6IHllcywgb2Zmc2V0OiBvcGVuOmxlbmd0aCwgcXVvdGU6IHF1b3RlKVxuXHRcdFx0dG9rZW4gJ1NUUklOR19FTkQnLCBvcGVuLCBvcGVuOmxlbmd0aCwgaGVyZWRvYzpsZW5ndGggLSBvcGVuOmxlbmd0aFxuXHRcdGVsc2Vcblx0XHRcdHRva2VuKCdTVFJJTkcnLCBtYWtlU3RyaW5nKGRvYywgcXVvdGUsIHllcyksIDApXG5cblx0XHRtb3ZlSGVhZChoZXJlZG9jKVxuXHRcdHJldHVybiBoZXJlZG9jOmxlbmd0aFxuXG5cdCMgTWF0Y2hlcyBhbmQgY29uc3VtZXMgY29tbWVudHMuXG5cdGRlZiBjb21tZW50VG9rZW5cblx0XHR2YXIgbWF0Y2gsIGxlbmd0aCwgY29tbWVudCwgaW5kZW50LCBwcmV2XG5cblx0XHR2YXIgdHlwID0gJ0hFUkVDT01NRU5UJ1xuXG5cdFx0aWYgbWF0Y2ggPSBJTkxJTkVfQ09NTUVOVC5leGVjKEBjaHVuaykgIyAubWF0Y2goSU5MSU5FX0NPTU1FTlQpXG5cdFx0XHQjIGNvbnNvbGUubG9nIFwibWF0Y2ggaW5saW5lIGNvbW1lbnRcIlxuXHRcdFx0bGVuZ3RoID0gbWF0Y2hbMF06bGVuZ3RoXG5cdFx0XHRpbmRlbnQgPSBtYXRjaFsxXVxuXHRcdFx0Y29tbWVudCA9IG1hdGNoWzJdXG5cblx0XHRcdHByZXYgPSBsYXN0KEB0b2tlbnMpXG5cdFx0XHR2YXIgcHQgPSBwcmV2IGFuZCB0VChwcmV2KVxuXHRcdFx0dmFyIG5vdGUgPSAnLy8nICsgY29tbWVudC5zdWJzdHIoMSlcblxuXHRcdFx0aWYgQGxhc3QgYW5kIEBsYXN0OnNwYWNlZFxuXHRcdFx0XHRub3RlID0gJyAnICsgbm90ZVxuXHRcdFx0XHQjIGNvbnNvbGUubG9nIFwidGhlIHByZXZpb3VzIG5vZGUgd2FzIFNQQUNFRFwiXG5cdFx0XHQjIGNvbnNvbGUubG9nIFwiY29tbWVudCB7bm90ZX0gLSBpbmRlbnQoe2luZGVudH0pIC0ge2xlbmd0aH0ge2NvbW1lbnQ6bGVuZ3RofVwiXG5cblx0XHRcdGlmIChwdCBhbmQgcHQgIT0gJ0lOREVOVCcgYW5kIHB0ICE9ICdURVJNSU5BVE9SJykgb3IgIXB0XG5cdFx0XHRcdCMgY29uc29sZS5sb2cgXCJza2lwIGNvbW1lbnRcIlxuXHRcdFx0XHQjIHRva2VuICdJTkxJTkVDT01NRU5UJywgY29tbWVudC5zdWJzdHIoMilcblx0XHRcdFx0IyBjb25zb2xlLmxvZyBcImFkZGluZyBhcyB0ZXJtaW5hdG9yXCJcblx0XHRcdFx0dG9rZW4oJ1RFUk1JTkFUT1InLCBub3RlLCBsZW5ndGgpICMgKyAnXFxuJ1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHQjIGNvbnNvbGUubG9nIFwiYWRkIGNvbW1lbnQgKHtub3RlfSlcIlxuXHRcdFx0XHRpZiBwdCA9PSAnVEVSTUlOQVRPUidcblx0XHRcdFx0XHR0VnMocHJldix0VihwcmV2KSArIG5vdGUpXG5cdFx0XHRcdFx0IyBwcmV2WzFdICs9IG5vdGVcblx0XHRcdFx0ZWxpZiBwdCA9PSAnSU5ERU5UJ1xuXHRcdFx0XHRcdCMgY29uc29sZS5sb2cgXCJhZGRpbmcgY29tbWVudCB0byBJTkRFTlQ6IHtub3RlfVwiICMgd2h5IG5vdCBhZGQgZGlyZWN0bHkgaGVyZT9cblx0XHRcdFx0XHRhZGRMaW5lYnJlYWtzKDEsbm90ZSlcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdCMgY29uc29sZS5sb2cgXCJjb21tZW50IGhlcmVcIlxuXHRcdFx0XHRcdCMgc2hvdWxkIHdlIGV2ZXIgZ2V0IGhlcmU/XG5cdFx0XHRcdFx0dG9rZW4odHlwLCBjb21tZW50LnN1YnN0cigyKSwgbGVuZ3RoKSAjIGFyZSB3ZSBzdXJlP1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gbGVuZ3RoICMgZGlzYWJsZSBub3cgd2hpbGUgY29tcGlsaW5nXG5cblx0XHQjIHNob3VsZCB1c2UgZXhlYz9cblx0XHRyZXR1cm4gMCB1bmxlc3MgbWF0Y2ggPSBDT01NRU5ULmV4ZWMoQGNodW5rKVxuXG5cdFx0dmFyIGNvbW1lbnQgPSBtYXRjaFswXVxuXHRcdHZhciBoZXJlID0gbWF0Y2hbMV1cblxuXHRcdGlmIGhlcmVcblx0XHRcdHRva2VuICdIRVJFQ09NTUVOVCcsIHNhbml0aXplSGVyZWRvYyhoZXJlLCBoZXJlY29tbWVudDogdHJ1ZSwgaW5kZW50OiBBcnJheShAaW5kZW50ICsgMSkuam9pbignICcpKSwgY29tbWVudDpsZW5ndGhcblx0XHRcdHRva2VuICdURVJNSU5BVE9SJywgJ1xcbidcblx0XHRlbHNlXG5cdFx0XHR0b2tlbiAnSEVSRUNPTU1FTlQnLCBjb21tZW50LCBjb21tZW50Omxlbmd0aFxuXHRcdFx0dG9rZW4gJ1RFUk1JTkFUT1InLCAnXFxuJyAjIGF1dG8/IHJlYWxseT9cblxuXHRcdG1vdmVIZWFkKGNvbW1lbnQpXG5cdFx0cmV0dXJuIGNvbW1lbnQ6bGVuZ3RoXG5cblx0IyBNYXRjaGVzIEphdmFTY3JpcHQgaW50ZXJwb2xhdGVkIGRpcmVjdGx5IGludG8gdGhlIHNvdXJjZSB2aWEgYmFja3RpY2tzLlxuXHRkZWYganNUb2tlblxuXHRcdHZhciBtYXRjaCwgc2NyaXB0XG5cblx0XHRyZXR1cm4gMCB1bmxlc3MgQGNodW5rLmNoYXJBdCgwKSBpcyAnYCcgYW5kIG1hdGNoID0gSlNUT0tFTi5leGVjKEBjaHVuaylcblx0XHR0b2tlbiAnSlMnLCAoc2NyaXB0ID0gbWF0Y2hbMF0pLnNsaWNlIDEsIC0xXG5cdFx0c2NyaXB0Omxlbmd0aFxuXG5cdCMgTWF0Y2hlcyByZWd1bGFyIGV4cHJlc3Npb24gbGl0ZXJhbHMuIExleGluZyByZWd1bGFyIGV4cHJlc3Npb25zIGlzIGRpZmZpY3VsdFxuXHQjIHRvIGRpc3Rpbmd1aXNoIGZyb20gZGl2aXNpb24sIHNvIHdlIGJvcnJvdyBzb21lIGJhc2ljIGhldXJpc3RpY3MgZnJvbVxuXHQjIEphdmFTY3JpcHQgYW5kIFJ1YnkuXG5cdGRlZiByZWdleFRva2VuXG5cdFx0dmFyIG1hdGNoLCBsZW5ndGgsIHByZXZcblxuXHRcdHJldHVybiAwIGlmIEBjaHVuay5jaGFyQXQoMCkgaXNudCAnLydcblx0XHRpZiBtYXRjaCA9IEhFUkVHRVguZXhlYyhAY2h1bmspXG5cdFx0XHRsZW5ndGggPSBoZXJlZ2V4VG9rZW4obWF0Y2gpXG5cdFx0XHRtb3ZlSGVhZChtYXRjaFswXSlcblx0XHRcdHJldHVybiBsZW5ndGhcblxuXHRcdHByZXYgPSBsYXN0IEB0b2tlbnNcblx0XHQjIEZJWFxuXHRcdHJldHVybiAwIGlmIHByZXYgYW5kICh0VChwcmV2KSBpbiAoaWYgcHJldjpzcGFjZWQgdGhlbiBOT1RfUkVHRVggZWxzZSBOT1RfU1BBQ0VEX1JFR0VYKSlcblx0XHRyZXR1cm4gMCB1bmxlc3MgbWF0Y2ggPSBSRUdFWC5leGVjKEBjaHVuaylcblx0XHR2YXIgW20sIHJlZ2V4LCBmbGFnc10gPSBtYXRjaFxuXG5cdFx0IyBGSVhNRVxuXHRcdCMgaWYgcmVnZXhbLi4xXSBpcyAnLyonXG5cdFx0I1x0ZXJyb3IgJ3JlZ3VsYXIgZXhwcmVzc2lvbnMgY2Fubm90IGJlZ2luIHdpdGggYCpgJ1xuXG5cdFx0aWYgcmVnZXggPT0gJy8vJ1xuXHRcdFx0cmVnZXggPSAnLyg/OikvJ1xuXG5cdFx0dG9rZW4gJ1JFR0VYJywgXCJ7cmVnZXh9e2ZsYWdzfVwiLCBtOmxlbmd0aFxuXHRcdG06bGVuZ3RoXG5cblx0IyBNYXRjaGVzIG11bHRpbGluZSBleHRlbmRlZCByZWd1bGFyIGV4cHJlc3Npb25zLlxuXHQjIFRoZSBlc2NhcGluZyBzaG91bGQgcmF0aGVyIGhhcHBlbiBpbiBBU1QgLSBwb3NzaWJseSBhcyBhbiBhZGRpdGlvbmFsIGZsYWc/XG5cdGRlZiBoZXJlZ2V4VG9rZW4gbWF0Y2hcblx0XHR2YXIgW2hlcmVnZXgsIGJvZHksIGZsYWdzXSA9IG1hdGNoXG5cblx0XHRpZiAwID4gYm9keS5pbmRleE9mKCcjeycpXG5cblx0XHRcdHZhciByZSA9IGJvZHkucmVwbGFjZShIRVJFR0VYX09NSVQsICcnKS5yZXBsYWNlKC9cXC8vZywgJ1xcXFwvJylcblxuXHRcdFx0aWYgcmUubWF0Y2goL15cXCovKVxuXHRcdFx0XHRlcnJvciAncmVndWxhciBleHByZXNzaW9ucyBjYW5ub3QgYmVnaW4gd2l0aCBgKmAnXG5cblx0XHRcdHRva2VuICdSRUdFWCcsIFwiL3sgcmUgb3IgJyg/OiknIH0ve2ZsYWdzfVwiLCBoZXJlZ2V4Omxlbmd0aFxuXHRcdFx0cmV0dXJuIGhlcmVnZXg6bGVuZ3RoXG5cblx0XHQjIHVzZSBtb3JlIGJhc2ljIHJlZ2V4IHR5cGVcblxuXHRcdHRva2VuICdDT05TVCcsICdSZWdFeHAnXG5cdFx0QHRva2Vucy5wdXNoIFQudG9rZW4oJ0NBTExfU1RBUlQnLCAnKCcsMClcblx0XHR2YXIgdG9rZW5zID0gW11cblxuXHRcdGZvciBwYWlyIGluIGludGVycG9sYXRlU3RyaW5nKGJvZHksIHJlZ2V4OiB5ZXMpXG5cblx0XHRcdHZhciB0b2sgPSB0VChwYWlyKSAjIEZJWFxuXHRcdFx0dmFyIHZhbHVlID0gdFYocGFpcikgIyBGSVhcblxuXHRcdFx0aWYgdG9rID09ICdUT0tFTlMnXG5cdFx0XHRcdCMgRklYTUUgd2hhdCBpcyB0aGlzP1xuXHRcdFx0XHR0b2tlbnMucHVzaCAqdmFsdWVcblx0XHRcdGVsc2Vcblx0XHRcdFx0aWYgIXZhbHVlXG5cdFx0XHRcdFx0Y29uc29sZS5sb2cgXCJ3aGF0Pz9cIlxuXG5cdFx0XHRcdGNvbnRpbnVlIHVubGVzcyB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoSEVSRUdFWF9PTUlULCAnJylcblxuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlLnJlcGxhY2UgL1xcXFwvZywgJ1xcXFxcXFxcJ1xuXHRcdFx0XHR0b2tlbnMucHVzaCBULnRva2VuKCdTVFJJTkcnLCBtYWtlU3RyaW5nKHZhbHVlLCAnXCInLCB5ZXMpLCAwKSAjIEZJWFxuXG5cdFx0XHR0b2tlbnMucHVzaCBULnRva2VuKCcrJywgJysnLCAwKSAjIEZJWFxuXG5cdFx0dG9rZW5zLnBvcFxuXG5cdFx0IyBGSVhcblx0XHR1bmxlc3MgdG9rZW5zWzBdIGFuZCB0VCh0b2tlbnNbMF0pIGlzICdTVFJJTkcnXG5cdFx0XHQjIEZJWFxuXHRcdFx0QHRva2Vucy5wdXNoIFQudG9rZW4oJ1NUUklORycsICdcIlwiJyksIFQudG9rZW4oJysnLCAnKycpXG5cblx0XHRAdG9rZW5zLnB1c2ggKnRva2VucyAjIHdoYXQgaXMgdGhpcz9cblx0XHQjIEZJWFxuXG5cdFx0aWYgZmxhZ3Ncblx0XHRcdEB0b2tlbnMucHVzaChULnRva2VuKCcsJywgJywnLCAwKSlcblx0XHRcdEB0b2tlbnMucHVzaChULnRva2VuKCdTVFJJTkcnLCAnXCInICsgZmxhZ3MgKyAnXCInLCAwKSlcblxuXHRcdHRva2VuKCcpJywgJyknLDApXG5cblx0XHRyZXR1cm4gaGVyZWdleDpsZW5ndGhcblxuXHQjIE1hdGNoZXMgbmV3bGluZXMsIGluZGVudHMsIGFuZCBvdXRkZW50cywgYW5kIGRldGVybWluZXMgd2hpY2ggaXMgd2hpY2guXG5cdCMgSWYgd2UgY2FuIGRldGVjdCB0aGF0IHRoZSBjdXJyZW50IGxpbmUgaXMgY29udGludWVkIG9udG8gdGhlIHRoZSBuZXh0IGxpbmUsXG5cdCMgdGhlbiB0aGUgbmV3bGluZSBpcyBzdXBwcmVzc2VkOlxuXHQjXG5cdCMgICAgIGVsZW1lbnRzXG5cdCMgICAgICAgLmVhY2goIC4uLiApXG5cdCMgICAgICAgLm1hcCggLi4uIClcblx0I1xuXHQjIEtlZXBzIHRyYWNrIG9mIHRoZSBsZXZlbCBvZiBpbmRlbnRhdGlvbiwgYmVjYXVzZSBhIHNpbmdsZSBvdXRkZW50IHRva2VuXG5cdCMgY2FuIGNsb3NlIG11bHRpcGxlIGluZGVudHMsIHNvIHdlIG5lZWQgdG8ga25vdyBob3cgZmFyIGluIHdlIGhhcHBlbiB0byBiZS5cblx0ZGVmIGxpbmVUb2tlblxuXHRcdHZhciBtYXRjaFxuXG5cdFx0cmV0dXJuIDAgdW5sZXNzIG1hdGNoID0gTVVMVElfREVOVC5leGVjKEBjaHVuaylcblxuXHRcdHZhciBpbmRlbnQgPSBtYXRjaFswXVxuXHRcdHZhciBickNvdW50ID0gbW92ZUhlYWQoaW5kZW50KVxuXG5cdFx0QHNlZW5Gb3IgPSBub1xuXHRcdCMgcmVzZXQgY29sdW1uIGFzIHdlbGw/XG5cblx0XHR2YXIgcHJldiA9IGxhc3QgQHRva2VucywgMVxuXHRcdGxldCB3aGl0ZXNwYWNlID0gaW5kZW50LnN1YnN0cihpbmRlbnQubGFzdEluZGV4T2YoJ1xcbicpICsgMSlcblx0XHR2YXIgc2l6ZSA9IHdoaXRlc3BhY2U6bGVuZ3RoXG5cdFx0dmFyIG5vTmV3bGluZXMgPSBzZWxmLnVuZmluaXNoZWRcblxuXHRcdGlmICgvXlxcbiNcXHMvKS50ZXN0KEBjaHVuaylcblx0XHRcdGFkZExpbmVicmVha3MoMSlcblx0XHRcdHJldHVybiAwXG5cblx0XHRpZiBzaXplID4gMFxuXHRcdFx0dW5sZXNzIEBpbmRlbnRTdHlsZVxuXHRcdFx0XHRAb3B0czppbmRlbnQgPSBAaW5kZW50U3R5bGUgPSB3aGl0ZXNwYWNlXG5cblx0XHRcdGxldCBpbmRlbnRTaXplID0gMFxuXHRcdFx0bGV0IG9mZnNldCA9IDBcblxuXHRcdFx0d2hpbGUgdHJ1ZVxuXHRcdFx0XHRsZXQgaWR4ID0gd2hpdGVzcGFjZS5pbmRleE9mKEBpbmRlbnRTdHlsZSxvZmZzZXQpXG5cdFx0XHRcdGlmIGlkeCA9PSBvZmZzZXRcblx0XHRcdFx0XHRpbmRlbnRTaXplKytcblx0XHRcdFx0XHRvZmZzZXQgKz0gQGluZGVudFN0eWxlWydsZW5ndGgnXVxuXHRcdFx0XHRlbGlmIG9mZnNldCA9PSB3aGl0ZXNwYWNlOmxlbmd0aFxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHQjIHdvcmthcm91bmQgdG8gcmVwb3J0IGNvcnJlY3QgbG9jYXRpb25cblx0XHRcdFx0XHRAbG9jICs9IGluZGVudDpsZW5ndGggLSB3aGl0ZXNwYWNlOmxlbmd0aFxuXHRcdFx0XHRcdHRva2VuKCdJTkRFTlQnLCB3aGl0ZXNwYWNlLHdoaXRlc3BhY2U6bGVuZ3RoKVxuXHRcdFx0XHRcdHJldHVybiBlcnJvcignaW5jb25zaXN0ZW50IGluZGVudGF0aW9uJylcblxuXHRcdFx0c2l6ZSA9IGluZGVudFNpemVcblxuXG5cdFx0aWYgc2l6ZSAtIEBpbmRlYnQgaXMgQGluZGVudFxuXHRcdFx0aWYgbm9OZXdsaW5lc1xuXHRcdFx0XHRzdXBwcmVzc05ld2xpbmVzKClcblx0XHRcdGVsc2Vcblx0XHRcdFx0bmV3bGluZVRva2VuKGJyQ291bnQpXG5cdFx0XHRyZXR1cm4gaW5kZW50Omxlbmd0aFxuXG5cdFx0aWYgc2l6ZSA+IEBpbmRlbnRcblx0XHRcdGlmIG5vTmV3bGluZXNcblx0XHRcdFx0QGluZGVidCA9IHNpemUgLSBAaW5kZW50XG5cdFx0XHRcdHN1cHByZXNzTmV3bGluZXNcblx0XHRcdFx0cmV0dXJuIGluZGVudDpsZW5ndGhcblxuXHRcdFx0aWYgaW5UYWcoKVxuXHRcdFx0XHQjIGNvbnNvbGUubG9nIFwiaW5kZW50IGluc2lkZSB0b2tpZD8hP1wiXG5cdFx0XHRcdCMgQGluZGVidCA9IHNpemUgLSBAaW5kZW50XG5cdFx0XHRcdCMgc3VwcHJlc3NOZXdsaW5lcygpXG5cdFx0XHRcdHJldHVybiBpbmRlbnQ6bGVuZ3RoXG5cblxuXHRcdFx0dmFyIGRpZmYgPSBzaXplIC0gQGluZGVudCArIEBvdXRkZWJ0XG5cdFx0XHRjbG9zZURlZigpXG5cblx0XHRcdHZhciBpbW1lZGlhdGUgPSBsYXN0KEB0b2tlbnMpXG5cblx0XHRcdGlmIGltbWVkaWF0ZSBhbmQgdFQoaW1tZWRpYXRlKSA9PSAnVEVSTUlOQVRPUidcblx0XHRcdFx0dFRzKGltbWVkaWF0ZSwnSU5ERU5UJylcblx0XHRcdFx0aW1tZWRpYXRlLkBtZXRhIHx8PSB7cHJlOiB0VihpbW1lZGlhdGUpLCBwb3N0OiAnJ31cblxuXHRcdFx0XHQjIHNob3VsZCByYXRoZXIgYWRkIHRvIG1ldGEgc29tZWhvdz8hP1xuXHRcdFx0XHQjIHRWcyhpbW1lZGlhdGUsdFYoaW1tZWRpYXRlKSArICclfCUnKSAjIGNyYXp5XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHRva2VuKCdJTkRFTlQnLCBcIlwiICsgZGlmZiwwKVxuXG5cdFx0XHQjIGNvbnNvbGUubG9nIFwiaW5kZW50aW5nXCIsIHByZXYsIGxhc3QoQHRva2VucywxKVxuXHRcdFx0IyBpZiBwcmV2IGFuZCBwcmV2WzBdID09ICdURVJNSU5BVE9SJ1xuXHRcdFx0IyAgIGNvbnNvbGUubG9nIFwidGVybWluYXRvciBiZWZvcmUgaW5kZW50Pz9cIlxuXG5cdFx0XHQjIGNoZWNrIGZvciBjb21tZW50cyBhcyB3ZWxsID9cblxuXHRcdFx0QGluZGVudHMucHVzaCBkaWZmXG5cdFx0XHRwdXNoRW5kKCdPVVRERU5UJylcblx0XHRcdCMgQGVuZHMucHVzaCAnT1VUREVOVCdcblx0XHRcdEBvdXRkZWJ0ID0gQGluZGVidCA9IDBcblx0XHRcdGFkZExpbmVicmVha3MoYnJDb3VudClcblx0XHRlbHNlXG5cdFx0XHRAaW5kZWJ0ID0gMFxuXHRcdFx0b3V0ZGVudFRva2VuKEBpbmRlbnQgLSBzaXplLCBub05ld2xpbmVzLCBickNvdW50KVxuXHRcdFx0YWRkTGluZWJyZWFrcyhickNvdW50IC0gMSlcblx0XHRcdCMgY29uc29sZS5sb2cgXCJvdXRkZW50XCIsbm9OZXdsaW5lcyx0b2tpZCgpXG5cblx0XHRAaW5kZW50ID0gc2l6ZVxuXHRcdHJldHVybiBpbmRlbnQ6bGVuZ3RoXG5cblx0IyBSZWNvcmQgYW4gb3V0ZGVudCB0b2tlbiBvciBtdWx0aXBsZSB0b2tlbnMsIGlmIHdlIGhhcHBlbiB0byBiZSBtb3ZpbmcgYmFja1xuXHQjIGlud2FyZHMgcGFzdCBzZXZlcmFsIHJlY29yZGVkIGluZGVudHMuXG5cdGRlZiBvdXRkZW50VG9rZW4gbW92ZU91dCwgbm9OZXdsaW5lcywgbmV3bGluZUNvdW50XG5cdFx0IyBoZXJlIHdlIHNob3VsZCBhbHNvIHRha2UgY2FyZSB0byBwb3AgLyByZXNldCB0aGUgc2NvcGUtYm9keVxuXHRcdCMgb3IgY29udGV4dC10eXBlIGZvciBpbmRlbnRhdGlvbiBcblx0XHR2YXIgZGVudCA9IDBcblx0XHR3aGlsZSBtb3ZlT3V0ID4gMFxuXHRcdFx0dmFyIGxlbiA9IEBpbmRlbnRzOmxlbmd0aCAtIDFcblx0XHRcdGlmIEBpbmRlbnRzW2xlbl0gaXMgdW5kZWZpbmVkXG5cdFx0XHRcdG1vdmVPdXQgPSAwXG5cdFx0XHRlbGlmIEBpbmRlbnRzW2xlbl0gaXMgQG91dGRlYnRcblx0XHRcdFx0bW92ZU91dCAtPSBAb3V0ZGVidFxuXHRcdFx0XHRAb3V0ZGVidCA9IDBcblx0XHRcdGVsaWYgQGluZGVudHNbbGVuXSA8IEBvdXRkZWJ0XG5cdFx0XHRcdEBvdXRkZWJ0IC09IEBpbmRlbnRzW2xlbl1cblx0XHRcdFx0bW92ZU91dCAgLT0gQGluZGVudHNbbGVuXVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRkZW50ID0gQGluZGVudHMucG9wIC0gQG91dGRlYnRcblx0XHRcdFx0bW92ZU91dCAtPSBkZW50XG5cdFx0XHRcdEBvdXRkZWJ0ID0gMFxuXG5cdFx0XHRcdGFkZExpbmVicmVha3MoMSkgdW5sZXNzIG5vTmV3bGluZXNcblxuXHRcdFx0XHRwYWlyICdPVVRERU5UJ1xuXHRcdFx0XHR0b2tlbignT1VUREVOVCcsIFwiXCIgKyBkZW50LCAwKVxuXG5cdFx0QG91dGRlYnQgLT0gbW92ZU91dCBpZiBkZW50XG5cblx0XHRAdG9rZW5zLnBvcCB3aGlsZSBsYXN0VG9rZW5WYWx1ZSA9PSAnOydcblxuXHRcdHRva2VuKCdURVJNSU5BVE9SJywnXFxuJywwKSB1bmxlc3MgbGFzdFRva2VuVHlwZSA9PSAnVEVSTUlOQVRPUicgb3Igbm9OZXdsaW5lc1xuXG5cdFx0IyBjYXBwaW5nIHNjb3BlcyBzbyB0aGV5IGRvbnQgaGFuZyBhcm91bmQgXG5cdFx0QHNjb3BlczpsZW5ndGggPSBAaW5kZW50czpsZW5ndGhcblxuXHRcdHZhciBjdHggPSBjb250ZXh0XG5cdFx0cGFpcihjdHgpIGlmIGN0eCA9PSAnJScgb3IgY3R4ID09ICdUQUcnICMgcmVhbGx5P1xuXHRcdGNsb3NlRGVmXG5cdFx0cmV0dXJuIHRoaXNcblxuXHQjIE1hdGNoZXMgYW5kIGNvbnN1bWVzIG5vbi1tZWFuaW5nZnVsIHdoaXRlc3BhY2UuIHRva2lkIHRoZSBwcmV2aW91cyB0b2tlblxuXHQjIGFzIGJlaW5nIFwic3BhY2VkXCIsIGJlY2F1c2UgdGhlcmUgYXJlIHNvbWUgY2FzZXMgd2hlcmUgaXQgbWFrZXMgYSBkaWZmZXJlbmNlLlxuXHRkZWYgd2hpdGVzcGFjZVRva2VuXG5cdFx0dmFyIG1hdGNoLCBubGluZSwgcHJldlxuXHRcdHJldHVybiAwIHVubGVzcyAobWF0Y2ggPSBXSElURVNQQUNFLmV4ZWMoQGNodW5rKSkgfHwgKG5saW5lID0gQGNodW5rLmNoYXJBdCgwKSBpcyAnXFxuJylcblx0XHRwcmV2ID0gbGFzdCBAdG9rZW5zXG5cblx0XHQjIEZJWCAtIHdoeSBvaCB3aHk/XG5cdFx0aWYgcHJldlxuXHRcdFx0aWYgbWF0Y2hcblx0XHRcdFx0cHJldjpzcGFjZWQgPSB5ZXNcblx0XHRcdFx0cmV0dXJuIG1hdGNoWzBdOmxlbmd0aFxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRwcmV2Om5ld0xpbmUgPSB5ZXNcblx0XHRcdFx0cmV0dXJuIDBcblxuXHRkZWYgYWRkTmV3bGluZVxuXHRcdHRva2VuICdURVJNSU5BVE9SJywgJ1xcbidcblxuXHRkZWYgbW92ZUhlYWQgc3RyXG5cdFx0dmFyIGJyID0gY291bnQoc3RyLCdcXG4nKVxuXHRcdHJldHVybiBiclxuXHRcdFxuXG5cdGRlZiBhZGRMaW5lYnJlYWtzIGNvdW50LCByYXdcblx0XHR2YXIgYnJcblxuXHRcdHJldHVybiB0aGlzIGlmICFyYXcgYW5kIGNvdW50ID09IDAgIyBubyB0ZXJtaW5hdG9ycz9cblxuXHRcdHZhciBwcmV2ID0gQGxhc3RcblxuXHRcdGlmICFyYXdcblx0XHRcdGlmIGNvdW50ID09IDFcblx0XHRcdFx0YnIgPSAnXFxuJ1xuXHRcdFx0ZWxpZiBjb3VudCA9PSAyXG5cdFx0XHRcdGJyID0gJ1xcblxcbidcblx0XHRcdGVsaWYgY291bnQgPT0gM1xuXHRcdFx0XHRiciA9ICdcXG5cXG5cXG4nXG5cdFx0XHRlbHNlXG5cdFx0XHRcdGJyID0gcmVwZWF0U3RyaW5nKCdcXG4nLGNvdW50KVxuXHRcdCMgRklYXG5cdFx0aWYgcHJldlxuXHRcdFx0dmFyIHQgPSBwcmV2LkB0eXBlICMgQGxhc3RUeXBcblx0XHRcdHZhciB2ID0gdFYocHJldilcblxuXHRcdFx0IyB3ZSByZWFsbHkgd2FudCB0byBhZGQgdGhpc1xuXHRcdFx0aWYgdCA9PSAnSU5ERU5UJ1xuXHRcdFx0XHQjIFRPRE8gd2Ugd2FudCB0byBhZGQgdG8gdGhlIGluZGVudFxuXHRcdFx0XHQjIGNvbnNvbGUubG9nIFwiYWRkIHRoZSBjb21tZW50IHRvIHRoZSBpbmRlbnQgLS0gcHJlPyB7cmF3fSB7YnJ9XCJcblx0XHRcdFxuXHRcdFx0XHR2YXIgbWV0YSA9IHByZXYuQG1ldGEgfHw9IHtwcmU6ICcnLCBwb3N0OiAnJ31cblx0XHRcdFx0bWV0YTpwb3N0ICs9IChyYXcgb3IgYnIpXG5cdFx0XHRcdCMgdFZzKHYgKyAocmF3IG9yIGJyKSlcblx0XHRcdFx0cmV0dXJuIHRoaXNcblxuXHRcdFx0ZWxpZiB0ID09ICdURVJNSU5BVE9SJ1xuXHRcdFx0XHQjIGNvbnNvbGUubG9nIFwiYWxyZWFkeSBleGlzdHMgdGVybWluYXRvciB7YnJ9IHtyYXd9XCJcblx0XHRcdFx0dFZzKHByZXYsdiArIChyYXcgb3IgYnIpKVxuXHRcdFx0XHRyZXR1cm4gdGhpc1xuXHRcdFxuXHRcdHRva2VuKCdURVJNSU5BVE9SJywgYnIsIDApXG5cdFx0cmV0dXJuXG5cblx0IyBHZW5lcmF0ZSBhIG5ld2xpbmUgdG9rZW4uIENvbnNlY3V0aXZlIG5ld2xpbmVzIGdldCBtZXJnZWQgdG9nZXRoZXIuXG5cdGRlZiBuZXdsaW5lVG9rZW4gbGluZXNcblx0XHQjIGNvbnNvbGUubG9nIFwibmV3bGluZVRva2VuXCJcblx0XHR3aGlsZSBsYXN0VG9rZW5WYWx1ZSgpID09ICc7J1xuXHRcdFx0Y29uc29sZS5sb2cgXCJwb3AgdG9rZW5cIixAdG9rZW5zW0B0b2tlbnM6bGVuZ3RoIC0gMV1cblx0XHRcdEB0b2tlbnMucG9wXG5cblx0XHRhZGRMaW5lYnJlYWtzKGxpbmVzKVxuXG5cdFx0dmFyIGN0eCA9IGNvbnRleHRcblx0XHQjIFdBUk4gbm93IGltcG9ydCBjYW5ub3QgZ28gb3ZlciBtdWx0aXBsZSBsaW5lc1xuXHRcdHBhaXIoY3R4KSBpZiBjdHggPT0gJ1RBRycgb3IgY3R4ID09ICdJTVBPUlQnXG5cdFx0Y2xvc2VEZWYoKSAgIyBjbG9zZSBkZWYgLS0gcmVhbGx5P1xuXHRcdHRoaXNcblxuXHQjIFVzZSBhIGBcXGAgYXQgYSBsaW5lLWVuZGluZyB0byBzdXBwcmVzcyB0aGUgbmV3bGluZS5cblx0IyBUaGUgc2xhc2ggaXMgcmVtb3ZlZCBoZXJlIG9uY2UgaXRzIGpvYiBpcyBkb25lLlxuXHRkZWYgc3VwcHJlc3NOZXdsaW5lc1xuXHRcdEB0b2tlbnMucG9wIGlmIHZhbHVlKCkgaXMgJ1xcXFwnXG5cdFx0dGhpc1xuXG5cdCMgV2UgdHJlYXQgYWxsIG90aGVyIHNpbmdsZSBjaGFyYWN0ZXJzIGFzIGEgdG9rZW4uIEUuZy46IGAoICkgLCAuICFgXG5cdCMgTXVsdGktY2hhcmFjdGVyIG9wZXJhdG9ycyBhcmUgYWxzbyBsaXRlcmFsIHRva2Vucywgc28gdGhhdCBKaXNvbiBjYW4gYXNzaWduXG5cdCMgdGhlIHByb3BlciBvcmRlciBvZiBvcGVyYXRpb25zLiBUaGVyZSBhcmUgc29tZSBzeW1ib2xzIHRoYXQgd2UgdG9raWQgc3BlY2lhbGx5XG5cdCMgaGVyZS4gYDtgIGFuZCBuZXdsaW5lcyBhcmUgYm90aCB0cmVhdGVkIGFzIGEgYFRFUk1JTkFUT1JgLCB3ZSBkaXN0aW5ndWlzaFxuXHQjIHBhcmVudGhlc2VzIHRoYXQgaW5kaWNhdGUgYSBtZXRob2QgY2FsbCBmcm9tIHJlZ3VsYXIgcGFyZW50aGVzZXMsIGFuZCBzbyBvbi5cblx0ZGVmIGxpdGVyYWxUb2tlblxuXHRcdHZhciBtYXRjaCwgdmFsdWVcblx0XHRpZiBtYXRjaCA9IE9QRVJBVE9SLmV4ZWMoQGNodW5rKVxuXHRcdFx0dmFsdWUgPSBtYXRjaFswXVxuXHRcdFx0dGFnUGFyYW1ldGVycyBpZiBDT0RFLnRlc3QodmFsdWUpXG5cdFx0ZWxzZVxuXHRcdFx0dmFsdWUgPSBAY2h1bmsuY2hhckF0KDApXG5cdFx0XG5cdFx0dmFyIGVuZDEgPSBAZW5kc1tAZW5kczpsZW5ndGggLSAxXVxuXHRcdHZhciBlbmQyID0gQGVuZHNbQGVuZHM6bGVuZ3RoIC0gMl1cblxuXHRcdHZhciBpblRhZyA9IGVuZDEgPT0gJ1RBR19FTkQnIG9yIGVuZDEgID09ICdPVVRERU5UJyBhbmQgZW5kMiA9PSAnVEFHX0VORCdcblxuXHRcdHZhciB0b2tpZCA9IHZhbHVlXG5cdFx0dmFyIHByZXYgID0gbGFzdCBAdG9rZW5zXG5cdFx0dmFyIHB0ID0gcHJldiBhbmQgdFQocHJldilcblx0XHR2YXIgcHYgPSBwcmV2IGFuZCB0VihwcmV2KVxuXHRcdHZhciBsZW5ndGggPSB2YWx1ZTpsZW5ndGhcblxuXHRcdCMgaXMgdGhpcyBuZWVkZWQ/XG5cdFx0aWYgdmFsdWUgPT0gJz0nIGFuZCBwcmV2XG5cblx0XHRcdGlmIHB2ID09ICd8fCcgb3IgcHYgPT0gJyYmJyAjIGluIFsnfHwnLCAnJiYnXVxuXHRcdFx0XHR0VHMocHJldiwnQ09NUE9VTkRfQVNTSUdOJylcblx0XHRcdFx0dFZzKHByZXYscHYgKyAnPScpXG5cdFx0XHRcdCMgcHJldlswXSA9ICdDT01QT1VORF9BU1NJR04nXG5cdFx0XHRcdCMgcHJldlsxXSArPSAnPSdcblx0XHRcdFx0cmV0dXJuIHZhbHVlOmxlbmd0aFxuXG5cdFx0aWYgdmFsdWUgaXMgJzsnICAgICAgICAgICAgIFxuXHRcdFx0QHNlZW5Gb3IgPSBub1xuXHRcdFx0dG9raWQgPSAnVEVSTUlOQVRPUidcblxuXHRcdGVsaWYgdmFsdWUgaXMgJygnIGFuZCBpblRhZyBhbmQgcHQgIT0gJz0nIGFuZCBwcmV2OnNwYWNlZCAjIEZJWGVkXG5cdFx0XHQjIGNvbnNvbGUubG9nICdzcGFjZWQgYmVmb3JlICggaW4gdG9raWQnXG5cdFx0XHQjIEZJWE1FIC0gc2hvdWxkIHJhdGhlciBhZGQgYSBzcGVjaWFsIHRva2VuIGxpa2UgVEFHX1BBUkFNU19TVEFSVFxuXHRcdFx0dG9rZW4gJywnLCcsJ1xuXG5cdFx0ZWxpZiB2YWx1ZSBpcyAnLT4nIGFuZCBpblRhZ1xuXHRcdFx0dG9raWQgPSAnVEFHX0VORCdcblx0XHRcdHBhaXIgJ1RBR19FTkQnXG5cblx0XHRlbGlmIHZhbHVlIGlzICcvPicgYW5kIGluVGFnXG5cdFx0XHR0b2tpZCA9ICdUQUdfRU5EJ1xuXHRcdFx0cGFpciAnVEFHX0VORCdcblxuXHRcdGVsaWYgdmFsdWUgaXMgJz4nIGFuZCBpblRhZ1xuXHRcdFx0dG9raWQgPSAnVEFHX0VORCdcblx0XHRcdHBhaXIgJ1RBR19FTkQnXG5cblx0XHQjIHRoaXMgaXMgYSB0b2tpZC1tZXRob2Rcblx0XHRlbGlmIHZhbHVlIGlzICc+JyBhbmQgY29udGV4dCA9PSAnREVGJ1xuXHRcdFx0IyBjb25zb2xlLmxvZygncGlja2VkIHVwID4hIScpXG5cdFx0XHR0b2tpZCA9ICdERUZfRlJBR01FTlQnXG5cdFxuXHRcdFx0IyBlbGlmIHZhbHVlIGlzICdURVJNSU5BVE9SJyBhbmQgZW5kMSBpcyAnJScgXG5cdFx0XHQjIFx0Y2xvc2VTZWxlY3RvcigpXG5cblx0XHRlbGlmIHZhbHVlIGlzICdURVJNSU5BVE9SJyBhbmQgZW5kMSBpcyAnREVGJ1xuXHRcdFx0Y2xvc2VEZWYoKVxuXG5cdFx0IyBUT0RPIEJMT0NLIFBBUkFNIEJVR1xuXHRcdCMgcmVhbGx5K1xuXHRcdGVsaWYgdmFsdWUgaXMgJyYnIGFuZCBjb250ZXh0ID09ICdERUYnXG5cdFx0XHQjIGNvbnNvbGUubG9nKFwib2theSFcIilcblx0XHRcdHRva2lkID0gJ0JMT0NLX0FSRydcblx0XHRcdCMgY2hhbmdlIHRoZSBuZXh0IGlkZW50aWZpZXIgaW5zdGVhZD9cblxuXHRcdCMgZWxpZiB2YWx1ZS5tYXRjaCgpXG5cdFx0ZWxpZiB2YWx1ZSA9PSAnKicgYW5kIEBjaHVuay5jaGFyQXQoMSkubWF0Y2goL1tBLVphLXpcXF9cXEBcXFtdLykgYW5kIChwcmV2OnNwYWNlZCBvciBbJywnLCcoJywnWycsJ3snLCd8JywnXFxuJywnXFx0J10uaW5kZXhPZihwdikgPj0gMClcblx0XHRcdHRva2lkID0gXCJTUExBVFwiXG5cblx0XHRlbGlmIHZhbHVlID09ICfiiJonXG5cdFx0XHR0b2tpZCA9ICdTUVJUJ1xuXHRcdGVsaWYgdmFsdWUgPT0gJ8aSJ1xuXHRcdFx0dG9raWQgPSAnRlVOQydcblx0XHRlbGlmIHZhbHVlIGluIE1BVEhcblx0XHRcdHRva2lkID0gJ01BVEgnXG5cdFx0ZWxpZiB2YWx1ZSBpbiBDT01QQVJFXG5cdFx0XHR0b2tpZCA9ICdDT01QQVJFJ1xuXHRcdGVsaWYgdmFsdWUgaW4gQ09NUE9VTkRfQVNTSUdOXG5cdFx0XHR0b2tpZCA9ICdDT01QT1VORF9BU1NJR04nXG5cdFx0ZWxpZiB2YWx1ZSBpbiBVTkFSWVxuXHRcdFx0dG9raWQgPSAnVU5BUlknXG5cdFx0ZWxpZiB2YWx1ZSBpbiBTSElGVFxuXHRcdFx0dG9raWQgPSAnU0hJRlQnXG5cdFx0ZWxpZiB2YWx1ZSBpbiBMT0dJQ1xuXHRcdFx0dG9raWQgPSAnTE9HSUMnICMgb3IgdmFsdWUgaXMgJz8nIGFuZCBwcmV2PzpzcGFjZWQgXG5cblx0XHRlbGlmIHByZXYgYW5kICFwcmV2OnNwYWNlZFxuXHRcdFx0IyBuZWVkIGEgYmV0dGVyIHdheSB0byBkbyB0aGVzZVxuXHRcdFx0aWYgdmFsdWUgaXMgJygnIGFuZCBlbmQxID09ICclJ1xuXHRcdFx0XHR0b2tpZCA9ICdUQUdfQVRUUlNfU1RBUlQnXG5cblx0XHRcdGVsaWYgdmFsdWUgaXMgJygnIGFuZCBwdCBpbiBDQUxMQUJMRVxuXHRcdFx0XHQjIG5vdCB1c2luZyB0aGlzID8/P1xuXHRcdFx0XHQjIHByZXZbMF0gPSAnRlVOQ19FWElTVCcgaWYgcHJldlswXSBpcyAnPydcblx0XHRcdFx0dG9raWQgPSAnQ0FMTF9TVEFSVCdcblxuXHRcdFx0ZWxpZiB2YWx1ZSBpcyAnWycgYW5kIHB0IGluIElOREVYQUJMRVxuXHRcdFx0XHR0b2tpZCA9ICdJTkRFWF9TVEFSVCdcblx0XHRcdFx0dFRzKHByZXYsJ0lOREVYX1NPQUsnKSBpZiBwdCA9PSAnPydcblx0XHRcdFx0IyBwcmV2WzBdID0gJ0lOREVYX1NPQUsnIGlmIHByZXZbMF0gPT0gJz8nXG5cblx0XHRzd2l0Y2ggdmFsdWVcblx0XHRcdHdoZW4gJygnLCAneycsICdbJyB0aGVuIHB1c2hFbmQoSU5WRVJTRVNbdmFsdWVdKVxuXHRcdFx0d2hlbiAnKScsICd9JywgJ10nIHRoZW4gcGFpciB2YWx1ZVxuXG5cdFx0IyBoYWNreSBydWxlIHRvIHRyeSB0byBhbGxvdyBmb3IgdHVwbGUtYXNzaWdubWVudHMgaW4gYmxvY2tzXG5cdFx0IyBpZiB2YWx1ZSBpcyAnLCcgYW5kIHByZXZbMF0gaXMgJ0lERU5USUZJRVInIGFuZCBAdG9rZW5zW0B0b2tlbnM6bGVuZ3RoIC0gMl1bMF0gaW4gWydURVJNSU5BVE9SJywnSU5ERU5UJ11cblx0XHQjICAgIyB0b2tlbiBcIlRVUExFXCIsIFwidHVwbGVcIiAjIHNob3VsZCByYXRoZXIgaW5zZXJ0IGl0IHNvbWV3aGVyZSBlbHNlLCBubz9cblx0XHQjICAgY29uc29sZS5sb2coXCJmb3VuZCBjb21tYVwiKVxuXG5cdFx0dG9rZW4odG9raWQsIHZhbHVlLCB2YWx1ZTpsZW5ndGgpXG5cdFx0cmV0dXJuIHZhbHVlOmxlbmd0aFxuXG5cdCMgVG9rZW4gTWFuaXB1bGF0b3JzXG5cdCMgLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0IyBTYW5pdGl6ZSBhIGhlcmVkb2Mgb3IgaGVyZWNvbW1lbnQgYnlcblx0IyBlcmFzaW5nIGFsbCBleHRlcm5hbCBpbmRlbnRhdGlvbiBvbiB0aGUgbGVmdC1oYW5kIHNpZGUuXG5cdGRlZiBzYW5pdGl6ZUhlcmVkb2MgZG9jLCBvcHRpb25zXG5cdFx0dmFyIG1hdGNoXG5cdFx0dmFyIGluZGVudCA9IG9wdGlvbnM6aW5kZW50XG5cdFx0dmFyIGhlcmVjb21tZW50ID0gb3B0aW9uczpoZXJlY29tbWVudFxuXG5cdFx0aWYgaGVyZWNvbW1lbnRcblx0XHRcdGlmIEhFUkVET0NfSUxMRUdBTC50ZXN0KGRvYylcblx0XHRcdFx0ZXJyb3IgXCJibG9jayBjb21tZW50IGNhbm5vdCBjb250YWluICcqLycgc3RhcnRpbmdcIlxuXHRcdFx0cmV0dXJuIGRvYyBpZiBkb2MuaW5kZXhPZignXFxuJykgPD0gMFxuXHRcdGVsc2Vcblx0XHRcdHdoaWxlIG1hdGNoID0gSEVSRURPQ19JTkRFTlQuZXhlYyhkb2MpXG5cdFx0XHRcdHZhciBhdHRlbXB0ID0gbWF0Y2hbMV1cblx0XHRcdFx0aWYgaW5kZW50IGlzIG51bGwgb3IgMCA8IGF0dGVtcHQ6bGVuZ3RoIDwgaW5kZW50Omxlbmd0aFxuXHRcdFx0XHRcdGluZGVudCA9IGF0dGVtcHRcblxuXHRcdGRvYyA9IGRvYy5yZXBsYWNlIFJlZ0V4cChcIlxcXFxue2luZGVudH1cIixcImdcIiksICdcXG4nIGlmIGluZGVudFxuXHRcdGRvYyA9IGRvYy5yZXBsYWNlIC9eXFxuLywgJycgdW5sZXNzIGhlcmVjb21tZW50XG5cdFx0cmV0dXJuIGRvY1xuXG5cdCMgQSBzb3VyY2Ugb2YgYW1iaWd1aXR5IGluIG91ciBncmFtbWFyIHVzZWQgdG8gYmUgcGFyYW1ldGVyIGxpc3RzIGluIGZ1bmN0aW9uXG5cdCMgZGVmaW5pdGlvbnMgdmVyc3VzIGFyZ3VtZW50IGxpc3RzIGluIGZ1bmN0aW9uIGNhbGxzLiBXYWxrIGJhY2t3YXJkcywgdG9raWRnaW5nXG5cdCMgcGFyYW1ldGVycyBzcGVjaWFsbHkgaW4gb3JkZXIgdG8gbWFrZSB0aGluZ3MgZWFzaWVyIGZvciB0aGUgcGFyc2VyLlxuXHRkZWYgdGFnUGFyYW1ldGVyc1xuXHRcdHJldHVybiB0aGlzIGlmIGxhc3RUb2tlblR5cGUgIT0gJyknXG5cdFx0dmFyIHN0YWNrID0gW11cblx0XHR2YXIgdG9rZW5zID0gQHRva2Vuc1xuXHRcdHZhciBpID0gdG9rZW5zOmxlbmd0aFxuXG5cdFx0dFRzKHRva2Vuc1stLWldLCAnUEFSQU1fRU5EJylcblxuXHRcdHdoaWxlIHZhciB0b2sgPSB0b2tlbnNbLS1pXVxuXHRcdFx0dmFyIHQgPSB0VCh0b2spXG5cdFx0XHRzd2l0Y2ggdFxuXHRcdFx0XHR3aGVuICcpJ1xuXHRcdFx0XHRcdHN0YWNrLnB1c2ggdG9rXG5cdFx0XHRcdHdoZW4gJygnLCAnQ0FMTF9TVEFSVCdcblx0XHRcdFx0XHRpZiBzdGFjazpsZW5ndGhcblx0XHRcdFx0XHRcdHN0YWNrLnBvcFxuXHRcdFx0XHRcdGVsaWYgdCBpcyAnKCdcblx0XHRcdFx0XHRcdHRUcyh0b2ssJ1BBUkFNX1NUQVJUJylcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzXG5cdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXNcblxuXHRcdHJldHVybiB0aGlzXG5cblx0IyBDbG9zZSB1cCBhbGwgcmVtYWluaW5nIG9wZW4gYmxvY2tzIGF0IHRoZSBlbmQgb2YgdGhlIGZpbGUuXG5cdGRlZiBjbG9zZUluZGVudGF0aW9uXG5cdFx0IyBjdHggPSBjb250ZXh0XG5cdFx0IyBwYWlyKGN0eCkgaWYgY3R4IGluIFsnJScsJ0RFRiddXG5cdFx0Y2xvc2VEZWZcblx0XHRjbG9zZVNlbGVjdG9yXG5cdFx0b3V0ZGVudFRva2VuKEBpbmRlbnQsbm8sMClcblxuXHQjIE1hdGNoZXMgYSBiYWxhbmNlZCBncm91cCBzdWNoIGFzIGEgc2luZ2xlIG9yIGRvdWJsZS1xdW90ZWQgc3RyaW5nLiBQYXNzIGluXG5cdCMgYSBzZXJpZXMgb2YgZGVsaW1pdGVycywgYWxsIG9mIHdoaWNoIG11c3QgYmUgbmVzdGVkIGNvcnJlY3RseSB3aXRoaW4gdGhlXG5cdCMgY29udGVudHMgb2YgdGhlIHN0cmluZy4gVGhpcyBtZXRob2QgYWxsb3dzIHVzIHRvIGhhdmUgc3RyaW5ncyB3aXRoaW5cblx0IyBpbnRlcnBvbGF0aW9ucyB3aXRoaW4gc3RyaW5ncywgYWQgaW5maW5pdHVtLlxuXHRkZWYgYmFsYW5jZWRTdHJpbmcgc3RyLCBlbmRcblx0XHR2YXIgbWF0Y2gsIGxldHRlciwgcHJldlxuXG5cdFx0IyBjb25zb2xlLmxvZyAnYmFsYW5jaW5nIHN0cmluZyEnLCBzdHIsIGVuZFxuXHRcdHZhciBzdGFjayA9IFtlbmRdXG5cdFx0dmFyIGkgPSAwXG5cblx0XHQjIGNvdWxkIGl0IG5vdCBoYXBwZW4gaGVyZT9cblx0XHR3aGlsZSBpIDwgKHN0cjpsZW5ndGggLSAxKVxuXHRcdFx0aSsrXG5cdFx0XHR2YXIgbGV0dGVyID0gc3RyLmNoYXJBdChpKVxuXHRcdFx0c3dpdGNoIGxldHRlclxuXHRcdFx0XHR3aGVuICdcXFxcJ1xuXHRcdFx0XHRcdGkrK1xuXHRcdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHRcdHdoZW4gZW5kXG5cdFx0XHRcdFx0c3RhY2sucG9wXG5cdFx0XHRcdFx0dW5sZXNzIHN0YWNrOmxlbmd0aFxuXHRcdFx0XHRcdFx0dmFyIHYgPSBzdHIuc2xpY2UoMCwgaSArIDEpXG5cdFx0XHRcdFx0XHRyZXR1cm4gdlxuXHRcdFx0XHRcdGVuZCA9IHN0YWNrW3N0YWNrOmxlbmd0aCAtIDFdXG5cdFx0XHRcdFx0Y29udGludWVcblxuXHRcdFx0aWYgZW5kIGlzICd9JyBhbmQgKGxldHRlciA9PSAnXCInIG9yIGxldHRlciA9PSBcIidcIilcblx0XHRcdFx0c3RhY2sucHVzaChlbmQgPSBsZXR0ZXIpXG5cblx0XHRcdGVsaWYgZW5kIGlzICd9JyBhbmQgbGV0dGVyIGlzICcvJyBhbmQgbWF0Y2ggPSAoSEVSRUdFWC5leGVjKHN0ci5zbGljZSBpKSBvciBSRUdFWC5leGVjKHN0ci5zbGljZSBpKSlcblx0XHRcdFx0aSArPSBtYXRjaFswXTpsZW5ndGggLSAxXG5cblx0XHRcdGVsaWYgZW5kIGlzICd9JyBhbmQgbGV0dGVyIGlzICd7J1xuXHRcdFx0XHRzdGFjay5wdXNoIGVuZCA9ICd9J1xuXHRcdFx0ZWxpZiBlbmQgaXMgJ1wiJyBhbmQgbGV0dGVyIGlzICd7J1xuXHRcdFx0XHRzdGFjay5wdXNoIGVuZCA9ICd9J1xuXHRcdFx0cHJldiA9IGxldHRlclxuXG5cdFx0ZXJyb3IgXCJtaXNzaW5nIHsgc3RhY2sucG9wIH0sIHN0YXJ0aW5nXCIgdW5sZXNzIEBvcHRzOnNpbGVudFxuXG5cdCMgRXhwYW5kIHZhcmlhYmxlcyBhbmQgZXhwcmVzc2lvbnMgaW5zaWRlIGRvdWJsZS1xdW90ZWQgc3RyaW5ncyB1c2luZ1xuXHQjIFJ1YnktbGlrZSBub3RhdGlvbiBmb3Igc3Vic3RpdHV0aW9uIG9mIGFyYml0cmFyeSBleHByZXNzaW9ucy5cblx0I1xuXHQjICAgICBcIkhlbGxvICN7bmFtZS5jYXBpdGFsaXplKCl9LlwiXG5cdCNcblx0IyBJZiBpdCBlbmNvdW50ZXJzIGFuIGludGVycG9sYXRpb24sIHRoaXMgbWV0aG9kIHdpbGwgcmVjdXJzaXZlbHkgY3JlYXRlIGFcblx0IyBuZXcgTGV4ZXIsIHRva2VuaXplIHRoZSBpbnRlcnBvbGF0ZWQgY29udGVudHMsIGFuZCBtZXJnZSB0aGVtIGludG8gdGhlXG5cdCMgdG9rZW4gc3RyZWFtLlxuXHRkZWYgaW50ZXJwb2xhdGVTdHJpbmcgc3RyLCBvcHRpb25zID0ge31cblx0XHQjIGNvbnNvbGUubG9nIFwiaW50ZXJwb2xhdGUgc3RyaW5nXCJcblx0XHR2YXIgaGVyZWRvYyA9IG9wdGlvbnM6aGVyZWRvY1xuXHRcdHZhciBxdW90ZSA9IG9wdGlvbnM6cXVvdGVcblx0XHR2YXIgcmVnZXggPSBvcHRpb25zOnJlZ2V4XG5cdFx0dmFyIHByZWZpeCA9IG9wdGlvbnM6cHJlZml4XG5cblx0XHR2YXIgc3RhcnRMb2MgPSBAbG9jXG5cdFx0dmFyIHRva2VucyA9IFtdXG5cdFx0dmFyIHBpID0gMFxuXHRcdHZhciBpICA9IC0xXG5cdFx0dmFyIGxvY09mZnNldCA9IG9wdGlvbnM6b2Zmc2V0IG9yIDFcblx0XHR2YXIgc3RybGVuID0gc3RyOmxlbmd0aFxuXHRcdHZhciBsZXR0ZXJcblx0XHR2YXIgZXhwclxuXG5cdFx0dmFyIGlzSW50ZXJwb2xhdGVkID0gbm9cblx0XHQjIG91dCBvZiBib3VuZHNcblx0XHR3aGlsZSBsZXR0ZXIgPSBzdHIuY2hhckF0KGkgKz0gMSlcblx0XHRcdGlmIGxldHRlciBpcyAnXFxcXCdcblx0XHRcdFx0aSArPSAxXG5cdFx0XHRcdGNvbnRpbnVlXG5cblx0XHRcdHVubGVzcyBzdHIuY2hhckF0KGkpIGlzICd7JyBhbmQgKGV4cHIgPSBiYWxhbmNlZFN0cmluZyhzdHIuc2xpY2UoaSksICd9JykpXG5cdFx0XHRcdGNvbnRpbnVlXG5cblx0XHRcdGlzSW50ZXJwb2xhdGVkID0geWVzXG5cblx0XHRcdCMgdGhlc2UgaGF2ZSBubyByZWFsIHNlbnNlIG9mIGxvY2F0aW9uIG9yIGFueXRoaW5nP1xuXHRcdFx0aWYgcGkgPCBpXG5cdFx0XHRcdCMgdGhpcyBpcyB0aGUgcHJlZml4LXN0cmluZyAtIGJlZm9yZSBhbnkgaXRlbVxuXHRcdFx0XHR2YXIgdG9rID0gVG9rZW4ubmV3KCdORU9TVFJJTkcnLCBlc2NhcGVTdHIoc3RyLnNsaWNlKHBpLCBpKSxoZXJlZG9jLHF1b3RlKSxAbG9jICsgcGkgKyBsb2NPZmZzZXQsaSAtIHBpKVxuXHRcdFx0XHQjIHRvay5AbG9jID0gQGxvYyArIHBpXG5cdFx0XHRcdCMgdG9rLkBsZW4gPSBpIC0gcGkgKyAyXG5cdFx0XHRcdHRva2Vucy5wdXNoKHRvaylcblxuXHRcdFx0dG9rZW5zLnB1c2ggVG9rZW4ubmV3KCd7eycsJ3snLEBsb2MgKyBpICsgbG9jT2Zmc2V0LDEpXG5cblx0XHRcdHZhciBpbm5lciA9IGV4cHIuc2xpY2UoMSwgLTEpXG5cdFx0XHQjIGNvbnNvbGUubG9nICdpbm5lciBpcycsaW5uZXJcblx0XHRcdCMgcmVtb3ZlIGxlYWRpbmcgc3BhY2VzIFxuXHRcdFx0IyBuZWVkIHRvIGtlZXAgdHJhY2sgb2YgaG93IG11Y2ggd2hpdGVzcGFjZSB3ZSBkcm9wcGVkIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRpbm5lciA9IGlubmVyLnJlcGxhY2UoL15bXlxcblxcU10rLywnJylcblxuXHRcdFx0aWYgaW5uZXI6bGVuZ3RoXG5cdFx0XHRcdCMgd2UgbmVlZCB0byByZW1lbWJlciB0aGUgbG9jIHdlIHN0YXJ0IGF0XG5cdFx0XHRcdCMgY29uc29sZS5sb2coJ2ludGVycG9sYXRlIGZyb20gbG9jJyxAbG9jLGkpXG5cdFx0XHRcdCMgcmVhbGx5PyB3aHkgbm90IGp1c3QgYWRkIHRvIHRoZSBzdGFjaz8/XG5cdFx0XHRcdCMgd2hhdCBhYm91dCB0aGUgYWRkZWQgXG5cdFx0XHRcdCMgc2hvdWxkIHNoYXJlIHdpdGggdGhlIHNlbGVjdG9yIG5vP1xuXHRcdFx0XHQjIGNvbnNvbGUubG9nIFwidG9rZW5pemUgaW5uZXIgcGFydHMgb2Ygc3RyaW5nXCIsaW5uZXJcblx0XHRcdFx0dmFyIHNwYWNlcyA9IDBcblx0XHRcdFx0dmFyIG9mZnNldCA9IEBsb2MgKyBpICsgKGV4cHI6bGVuZ3RoIC0gaW5uZXI6bGVuZ3RoKSAtIDFcblx0XHRcdFx0IyB3aHkgY3JlYXRlIGEgd2hvbGUgbmV3IGxleGVyPyBTaG91bGQgcmF0aGVyIHJldXNlIG9uZVxuXHRcdFx0XHQjIG11Y2ggYmV0dGVyIHRvIHNpbXBseSBtb3ZlIGludG8gaW50ZXJwb2xhdGlvbiBtb2RlIHdoZXJlXG5cdFx0XHRcdCMgd2UgY29udGludWUgcGFyc2luZyB1bnRpbCB3ZSBtZWV0IHVucGFpcmVkIH1cblx0XHRcdFx0dmFyIG5lc3RlZCA9IExleGVyLm5ldy50b2tlbml6ZSBpbm5lciwgaW5saW5lOiB5ZXMsIHJld3JpdGU6IG5vLCBsb2M6IG9mZnNldCArIGxvY09mZnNldFxuXHRcdFx0XHQjIGNvbnNvbGUubG9nIG5lc3RlZC5wb3BcblxuXHRcdFx0XHRpZiBuZXN0ZWRbMF0gYW5kIHRUKG5lc3RlZFswXSkgPT0gJ1RFUk1JTkFUT1InXG5cdFx0XHRcdFx0bmVzdGVkLnNoaWZ0XG5cblx0XHRcdFx0aWYgbmVzdGVkOmxlbmd0aFxuXHRcdFx0XHRcdHRva2Vucy5wdXNoICpuZXN0ZWQgIyBULnRva2VuKCdUT0tFTlMnLG5lc3RlZCwwKVxuXHRcdFx0XG5cdFx0XHQjIHNob3VsZCByYXRoZXIgYWRkIHRoZSBhbW91bnQgYnkgd2hpY2ggb3VyIGxleGVyIGhhcyBtb3ZlZD9cblx0XHRcdGkgKz0gZXhwcjpsZW5ndGggLSAxXG5cdFx0XHR0b2tlbnMucHVzaCBUb2tlbi5uZXcoJ319JywnfScsQGxvYyArIGkgKyBsb2NPZmZzZXQsMSlcblx0XHRcdHBpID0gaSArIDFcblxuXHRcdCMgYWRkaW5nIHRoZSBsYXN0IHBhcnQgb2YgdGhlIHN0cmluZyBoZXJlXG5cdFx0aWYgaSA+PSBwaSBhbmQgcGkgPCBzdHI6bGVuZ3RoXG5cdFx0XHQjIHNldCB0aGUgbGVuZ3RoIGFzIHdlbGwgLSBvcj9cblx0XHRcdCMgdGhlIHN0cmluZyBhZnRlcj9cblx0XHRcdCMgY29uc29sZS5sb2cgJ3B1c2ggbmVvc3RyaW5nJ1xuXHRcdFx0dG9rZW5zLnB1c2ggVG9rZW4ubmV3KCdORU9TVFJJTkcnLCBlc2NhcGVTdHIoc3RyLnNsaWNlKHBpKSxoZXJlZG9jLHF1b3RlKSxAbG9jICsgcGkgKyBsb2NPZmZzZXQsIHN0cjpsZW5ndGggLSBwaSlcblxuXHRcdCMgY29uc29sZS5sb2cgdG9rZW5zOmxlbmd0aFxuXHRcdHJldHVybiB0b2tlbnMgaWYgcmVnZXhcblxuXHRcdHJldHVybiB0b2tlbiAnTkVPU1RSSU5HJywgJ1wiXCInIHVubGVzcyB0b2tlbnM6bGVuZ3RoXG5cblx0XHRAdG9rZW5zLnB1c2godG9rKSBmb3IgdG9rIGluIHRva2Vuc1xuXG5cdFx0cmV0dXJuIHRva2Vuc1xuXG5cdCMgTWF0Y2hlcyBhIGJhbGFuY2VkIGdyb3VwIHN1Y2ggYXMgYSBzaW5nbGUgb3IgZG91YmxlLXF1b3RlZCBzdHJpbmcuIFBhc3MgaW5cblx0IyBhIHNlcmllcyBvZiBkZWxpbWl0ZXJzLCBhbGwgb2Ygd2hpY2ggbXVzdCBiZSBuZXN0ZWQgY29ycmVjdGx5IHdpdGhpbiB0aGVcblx0IyBjb250ZW50cyBvZiB0aGUgc3RyaW5nLiBUaGlzIG1ldGhvZCBhbGxvd3MgdXMgdG8gaGF2ZSBzdHJpbmdzIHdpdGhpblxuXHQjIGludGVycG9sYXRpb25zIHdpdGhpbiBzdHJpbmdzLCBhZCBpbmZpbml0dW0uXG5cdGRlZiBiYWxhbmNlZFNlbGVjdG9yIHN0ciwgZW5kXG5cdFx0dmFyIHByZXZcblx0XHR2YXIgbGV0dGVyXG5cdFx0dmFyIHN0YWNrID0gW2VuZF1cblx0XHQjIEZJWE1FXG5cdFx0Zm9yIGkgaW4gWzEuLi5zdHI6bGVuZ3RoXVxuXHRcdFx0c3dpdGNoIGxldHRlciA9IHN0ci5jaGFyQXQoaSlcblx0XHRcdFx0d2hlbiAnXFxcXCdcblx0XHRcdFx0XHRpKytcblx0XHRcdFx0XHRjb250aW51ZVxuXHRcdFx0XHR3aGVuIGVuZFxuXHRcdFx0XHRcdHN0YWNrLnBvcFxuXHRcdFx0XHRcdHVubGVzcyBzdGFjazpsZW5ndGhcblx0XHRcdFx0XHRcdHJldHVybiBzdHIuc2xpY2UoMCwgaSArIDEpXG5cblx0XHRcdFx0XHRlbmQgPSBzdGFja1tzdGFjazpsZW5ndGggLSAxXVxuXHRcdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHRpZiBlbmQgaXMgJ30nIGFuZCBsZXR0ZXIgaXMgWycpJ11cblx0XHRcdFx0c3RhY2sucHVzaCBlbmQgPSBsZXR0ZXJcblx0XHRcdGVsaWYgZW5kIGlzICd9JyBhbmQgbGV0dGVyIGlzICd7J1xuXHRcdFx0XHRzdGFjay5wdXNoIGVuZCA9ICd9J1xuXHRcdFx0ZWxpZiBlbmQgaXMgJyknIGFuZCBsZXR0ZXIgaXMgJ3snXG5cdFx0XHRcdHN0YWNrLnB1c2ggZW5kID0gJ30nXG5cdFx0XHRwcmV2ID0gbGV0dGVyICMgd2hhdCwgd2h5P1xuXG5cdFx0ZXJyb3IgXCJtaXNzaW5nIHsgc3RhY2sucG9wIH0sIHN0YXJ0aW5nXCJcblxuXHQjIFBhaXJzIHVwIGEgY2xvc2luZyB0b2tlbiwgZW5zdXJpbmcgdGhhdCBhbGwgbGlzdGVkIHBhaXJzIG9mIHRva2VucyBhcmVcblx0IyBjb3JyZWN0bHkgYmFsYW5jZWQgdGhyb3VnaG91dCB0aGUgY291cnNlIG9mIHRoZSB0b2tlbiBzdHJlYW0uXG5cdGRlZiBwYWlyIHRva1xuXHRcdHZhciB3YW50ZWQgPSBsYXN0KEBlbmRzKVxuXHRcdHVubGVzcyB0b2sgPT0gd2FudGVkXG5cdFx0XHRlcnJvciBcInVubWF0Y2hlZCB7dG9rfVwiIHVubGVzcyAnT1VUREVOVCcgaXMgd2FudGVkXG5cdFx0XHR2YXIgc2l6ZSA9IGxhc3QoQGluZGVudHMpXG5cdFx0XHRAaW5kZW50IC09IHNpemVcblx0XHRcdG91dGRlbnRUb2tlbihzaXplLCB0cnVlLCAwKVxuXHRcdFx0cmV0dXJuIHBhaXIodG9rKVxuXHRcdHNlbGYucG9wRW5kXG5cblxuXHQjIEhlbHBlcnNcblx0IyAtLS0tLS0tXG5cblx0IyBBZGQgYSB0b2tlbiB0byB0aGUgcmVzdWx0cywgdGFraW5nIG5vdGUgb2YgdGhlIGxpbmUgbnVtYmVyLlxuXHRkZWYgdG9rZW4gaWQsIHZhbHVlLCBsZW4sIG9mZnNldFxuXHRcdEBsYXN0VHlwID0gaWRcblx0XHRAbGFzdFZhbCA9IHZhbHVlXG5cdFx0dmFyIHRvayA9IEBsYXN0ID0gVG9rZW4ubmV3KGlkLCB2YWx1ZSwgQGxvYyArIChvZmZzZXQgb3IgMCksIGxlbiBvciAwKVxuXHRcdEB0b2tlbnMucHVzaCB0b2tcblx0XHRyZXR1cm5cblxuXHRkZWYgbGFzdFRva2VuVHlwZVxuXHRcdHZhciB0b2tlbiA9IEB0b2tlbnNbQHRva2VuczpsZW5ndGggLSAxXVxuXHRcdHRva2VuID8gdFQodG9rZW4pIDogJ05PTkUnXG5cblx0ZGVmIGxhc3RUb2tlblZhbHVlXG5cdFx0dmFyIHRva2VuID0gQHRva2Vuc1tAdG9rZW5zOmxlbmd0aCAtIDFdXG5cdFx0dG9rZW4gPyB0b2tlbi5AdmFsdWUgOiAnJ1xuXHRcdFxuXHQjIFBlZWsgYXQgYSB0b2tpZCBpbiB0aGUgY3VycmVudCB0b2tlbiBzdHJlYW0uXG5cdGRlZiB0b2tpZCBpbmRleCwgdmFsXG5cdFx0aWYgdmFyIHRvayA9IGxhc3QoQHRva2VucywgaW5kZXgpXG5cdFx0XHR0VHModG9rLHZhbCkgaWYgdmFsXG5cdFx0XHRyZXR1cm4gdFQodG9rKVxuXHRcdFx0IyB0b2suQHR5cGUgPSB0b2tpZCBpZiB0b2tpZCAjIHdoeT9cblx0XHRcdCMgdG9rLkB0eXBlXG5cdFx0ZWxzZSBudWxsXG5cblx0IyBQZWVrIGF0IGEgdmFsdWUgaW4gdGhlIGN1cnJlbnQgdG9rZW4gc3RyZWFtLlxuXHRkZWYgdmFsdWUgaW5kZXgsIHZhbFxuXHRcdGlmIHZhciB0b2sgPSBsYXN0KEB0b2tlbnMsIGluZGV4KVxuXHRcdFx0dFZzKHRvayx2YWwpIGlmIHZhbFxuXHRcdFx0cmV0dXJuIHRWKHRvaylcblx0XHRcdCMgdG9rLkB2YWx1ZSA9IHZhbCBpZiB2YWwgIyB3aHk/XG5cdFx0XHQjIHRvay5AdmFsdWVcblx0XHRlbHNlIG51bGxcblx0XHRcblxuXHQjIEFyZSB3ZSBpbiB0aGUgbWlkc3Qgb2YgYW4gdW5maW5pc2hlZCBleHByZXNzaW9uP1xuXHRkZWYgdW5maW5pc2hlZFxuXHRcdHJldHVybiB0cnVlIGlmIExJTkVfQ09OVElOVUVSLnRlc3QoQGNodW5rKVx0XG5cdFx0cmV0dXJuIFVORklOSVNIRUQuaW5kZXhPZihAbGFzdFR5cCkgPj0gMFxuXHRcblx0IyB2YXIgdG9rZW5zID0gWydcXFxcJywnLicsICc/LicsICdVTkFSWScsICdNQVRIJywgJysnLCAnLScsICdTSElGVCcsICdSRUxBVElPTicsICdDT01QQVJFJywgJ0xPR0lDJywgJ0NPTVBPVU5EX0FTU0lHTicsICdUSFJPVycsICdFWFRFTkRTJ11cblxuXHQjIENvbnZlcnRzIG5ld2xpbmVzIGZvciBzdHJpbmcgbGl0ZXJhbHMuXG5cdGRlZiBlc2NhcGVMaW5lcyBzdHIsIGhlcmVkb2Ncblx0XHRzdHIucmVwbGFjZSBNVUxUSUxJTkVSLCAoaGVyZWRvYyA/ICdcXFxcbicgOiAnJylcblxuXHQjIENvbnN0cnVjdHMgYSBzdHJpbmcgdG9rZW4gYnkgZXNjYXBpbmcgcXVvdGVzIGFuZCBuZXdsaW5lcy5cblx0ZGVmIG1ha2VTdHJpbmcgYm9keSwgcXVvdGUsIGhlcmVkb2Ncblx0XHRyZXR1cm4gcXVvdGUgKyBxdW90ZSB1bmxlc3MgYm9keVxuXHRcdGJvZHkgPSBib2R5LnJlcGxhY2UoL1xcXFwoW1xcc1xcU10pL2cpIGRvIHxtYXRjaCwgY29udGVudHN8XG5cdFx0XHQoY29udGVudHMgPT0gJ1xcbicgb3IgY29udGVudHMgPT0gcXVvdGUpID8gY29udGVudHMgOiBtYXRjaFxuXHRcdCMgRG9lcyBub3Qgd29yayBub3dcblx0XHRib2R5ID0gYm9keS5yZXBsYWNlIFJlZ0V4cChcIntxdW90ZX1cIixcImdcIiksICdcXFxcJCYnXG5cdFx0cXVvdGUgKyBlc2NhcGVMaW5lcyhib2R5LCBoZXJlZG9jKSArIHF1b3RlXG5cdFx0XG5cdCMgVGhyb3dzIGEgc3ludGF4IGVycm9yIG9uIHRoZSBjdXJyZW50IGBAbGluZWAuXG5cdGRlZiBlcnJvciBtZXNzYWdlLCBsZW5cblx0XHRtZXNzYWdlID0gXCJ7bWVzc2FnZX0gb24gbGluZSB7QGxpbmV9XCIgaWYgQGxpbmUgaXNhIE51bWJlclxuXG5cdFx0aWYgbGVuXG5cdFx0XHRtZXNzYWdlICs9IFwiIFt7QGxvY306e0Bsb2MgKyBsZW59XVwiXG5cblx0XHR2YXIgZXJyID0gU3ludGF4RXJyb3IubmV3KG1lc3NhZ2UpXG5cdFx0ZXJyOmxpbmUgPSBAbGluZVxuXHRcdCMgZXJyOmNvbHVtbk51bWJlclxuXHRcdHZhciBlcnIgPSBFUlIuSW1iYVBhcnNlRXJyb3IubmV3KGVyciwgdG9rZW5zOiBAdG9rZW5zLCBwb3M6IEB0b2tlbnM6bGVuZ3RoKVxuXHRcdGVycjpyZWdpb24gPSBbQGxvYyxAbG9jICsgKGxlbiBvciAwKV1cblx0XHR0aHJvdyBlcnJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHNyYy9jb21waWxlci9sZXhlci5pbWJhXG4gKiovIiwiXG5cbmV4cG9ydCB2YXIgVE9LID0ge31cbnZhciBUVEVSTUlOQVRPUiA9IFRPSy5URVJNSU5BVE9SID0gMVxudmFyIFRJREVOVElGSUVSID0gVE9LLklERU5USUZJRVIgPSBUT0suSVZBUiA9IDJcbnZhciBDT05TVCA9IFRPSy5DT05TVCA9IDNcbnZhciBWQVIgPSBUT0suVkFSID0gNFxudmFyIElGID0gVE9LLklGID0gNVxudmFyIEVMU0UgPSBUT0suRUxTRSA9IDZcbnZhciBERUYgPSBUT0suREVGID0gN1xuXG5leHBvcnQgY2xhc3MgVG9rZW5cblxuXHRkZWYgaW5pdGlhbGl6ZSB0eXBlLCB2YWx1ZSwgbG9jLCBsZW5cblx0XHRAdHlwZSAgPSB0eXBlXG5cdFx0QHZhbHVlID0gdmFsdWVcblx0XHRAbG9jICAgPSBsb2MgIT0gbnVsbCA/IGxvYyA6IC0xXG5cdFx0QGxlbiAgID0gbGVuIG9yIDBcblx0XHRAbWV0YSAgPSBudWxsXG5cdFx0dGhpczpnZW5lcmF0ZWQgPSBub1xuXHRcdHRoaXM6bmV3TGluZSA9IG5vXG5cdFx0dGhpczpzcGFjZWQgPSBub1xuXHRcdHJldHVybiBzZWxmXG5cblx0ZGVmIHR5cGVcblx0XHRAdHlwZVxuXG5cdGRlZiB2YWx1ZVxuXHRcdEB2YWx1ZVxuXG5cdGRlZiB0cmF2ZXJzZVxuXHRcdHJldHVyblxuXHRcdFxuXHRkZWYgY1xuXHRcdFwiXCIgKyBAdmFsdWVcblxuXHRkZWYgdG9TdHJpbmdcblx0XHRAdmFsdWVcblxuXHRkZWYgY2hhckF0IGlcblx0XHRAdmFsdWUuY2hhckF0KGkpXG5cblx0ZGVmIHNsaWNlIGlcblx0XHRAdmFsdWUuc2xpY2UoaSlcblxuXHRkZWYgcmVnaW9uXG5cdFx0W0Bsb2MsQGxvYyArIChAbGVuIG9yIEB2YWx1ZTpsZW5ndGgpXVxuXG5cdGRlZiBzb3VyY2VNYXBNYXJrZXJcblx0XHRAbG9jID09IC0xID8gJzonIDogXCIlJHtAbG9jfSQlXCJcblx0XHQjIEBjb2wgPT0gLTEgPyAnJyA6IFwiJSV7QGxpbmV9JHtAY29sfSUlXCJcblxuXG5leHBvcnQgZGVmIGxleFxuXHR2YXIgdG9rZW4gPSB0aGlzOnRva2Vuc1t0aGlzOnBvcysrXVxuXHR2YXIgdHRhZ1xuXG5cdGlmIHRva2VuXG5cdFx0dHRhZyA9IHRva2VuLkB0eXBlXG5cdFx0dGhpczp5eXRleHQgPSB0b2tlblxuXHRlbHNlXG5cdFx0dHRhZyA9ICcnXG5cblx0cmV0dXJuIHR0YWdcblxuXG4jIGV4cG9ydCBkZWYgdG9rZW4gdHlwLCB2YWwsIGxpbmUsIGNvbCwgbGVuIGRvIFRva2VuLm5ldyh0eXAsdmFsLGxpbmUsIGNvbCBvciAwLCBsZW4gb3IgMCkgIyBbbnVsbCx0eXAsdmFsLGxvY11cbmV4cG9ydCBkZWYgdG9rZW4gdHlwLCB2YWwgZG8gVG9rZW4ubmV3KHR5cCx2YWwsLTEsMClcblxuZXhwb3J0IGRlZiB0eXAgdG9rIGRvIHRvay5AdHlwZVxuZXhwb3J0IGRlZiB2YWwgdG9rIGRvIHRvay5AdmFsdWUgIyB0b2tbb2Zmc2V0ICsgMV1cbmV4cG9ydCBkZWYgbGluZSB0b2sgZG8gdG9rLkBsaW5lICMgdG9rW29mZnNldCArIDJdXG5leHBvcnQgZGVmIGxvYyB0b2sgZG8gdG9rLkBsb2MgIyB0b2tbb2Zmc2V0ICsgMl1cblxuZXhwb3J0IGRlZiBzZXRUeXAgdG9rLCB2IGRvIHRvay5AdHlwZSA9IHZcbmV4cG9ydCBkZWYgc2V0VmFsIHRvaywgdiBkbyB0b2suQHZhbHVlID0gdlxuZXhwb3J0IGRlZiBzZXRMaW5lIHRvaywgdiBkbyB0b2suQGxpbmUgPSB2XG5leHBvcnQgZGVmIHNldExvYyB0b2ssIHYgZG8gdG9rLkBsb2MgPSB2XG5cblxuZXhwb3J0IHZhciBMQlJBQ0tFVCA9IFRva2VuLm5ldygneycsJ3snLDAsMCwwKVxuZXhwb3J0IHZhciBSQlJBQ0tFVCA9IFRva2VuLm5ldygnfScsJ30nLDAsMCwwKVxuXG5leHBvcnQgdmFyIExQQVJFTiA9IFRva2VuLm5ldygnKCcsJygnLDAsMCwwKVxuZXhwb3J0IHZhciBSUEFSRU4gPSBUb2tlbi5uZXcoJyknLCcpJywwLDAsMClcblxuTEJSQUNLRVQ6Z2VuZXJhdGVkID0geWVzXG5SQlJBQ0tFVDpnZW5lcmF0ZWQgPSB5ZXNcbkxQQVJFTjpnZW5lcmF0ZWQgPSB5ZXNcblJQQVJFTjpnZW5lcmF0ZWQgPSB5ZXNcblxuZXhwb3J0IHZhciBJTkRFTlQgPSBUb2tlbi5uZXcoJ0lOREVOVCcsJzInLDAsMCwwKVxuZXhwb3J0IHZhciBPVVRERU5UID0gVG9rZW4ubmV3KCdPVVRERU5UJywnMicsMCwwLDApXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogc3JjL2NvbXBpbGVyL3Rva2VuLmltYmFcbiAqKi8iLCJcbiMgVGhlIEltYmEgbGFuZ3VhZ2UgaGFzIGEgZ29vZCBkZWFsIG9mIG9wdGlvbmFsIHN5bnRheCwgaW1wbGljaXQgc3ludGF4LFxuIyBhbmQgc2hvcnRoYW5kIHN5bnRheC4gVGhpcyBjYW4gZ3JlYXRseSBjb21wbGljYXRlIGEgZ3JhbW1hciBhbmQgYmxvYXRcbiMgdGhlIHJlc3VsdGluZyBwYXJzZSB0YWJsZS4gSW5zdGVhZCBvZiBtYWtpbmcgdGhlIHBhcnNlciBoYW5kbGUgaXQgYWxsLCB3ZSB0YWtlXG4jIGEgc2VyaWVzIG9mIHBhc3NlcyBvdmVyIHRoZSB0b2tlbiBzdHJlYW0sIHVzaW5nIHRoaXMgKipSZXdyaXRlcioqIHRvIGNvbnZlcnRcbiMgc2hvcnRoYW5kIGludG8gdGhlIHVuYW1iaWd1b3VzIGxvbmcgZm9ybSwgYWRkIGltcGxpY2l0IGluZGVudGF0aW9uIGFuZFxuIyBwYXJlbnRoZXNlcywgYW5kIGdlbmVyYWxseSBjbGVhbiB0aGluZ3MgdXAuXG5cbnZhciBUID0gcmVxdWlyZSAnLi90b2tlbidcbnZhciBUb2tlbiA9IFQuVG9rZW5cblxuIyBCYXNlZCBvbiB0aGUgb3JpZ2luYWwgcmV3cml0ZXIuY29mZmVlIGZyb20gQ29mZmVlU2NyaXB0XG5leHBvcnQgY2xhc3MgUmV3cml0ZXJcblx0XG5cdGRlZiB0b2tlbnNcblx0XHRAdG9rZW5zXG5cdFx0XG5cdCMgSGVscGZ1bCBzbmlwcGV0IGZvciBkZWJ1Z2dpbmc6XG5cdCMgICAgIGNvbnNvbGUubG9nICh0WzBdICsgJy8nICsgdFsxXSBmb3IgdCBpbiBAdG9rZW5zKS5qb2luICcgJ1xuXHQjIFJld3JpdGUgdGhlIHRva2VuIHN0cmVhbSBpbiBtdWx0aXBsZSBwYXNzZXMsIG9uZSBsb2dpY2FsIGZpbHRlciBhdFxuXHQjIGEgdGltZS4gVGhpcyBjb3VsZCBjZXJ0YWlubHkgYmUgY2hhbmdlZCBpbnRvIGEgc2luZ2xlIHBhc3MgdGhyb3VnaCB0aGVcblx0IyBzdHJlYW0sIHdpdGggYSBiaWcgb2wnIGVmZmljaWVudCBzd2l0Y2gsIGJ1dCBpdCdzIG11Y2ggbmljZXIgdG8gd29yayB3aXRoXG5cdCMgbGlrZSB0aGlzLiBUaGUgb3JkZXIgb2YgdGhlc2UgcGFzc2VzIG1hdHRlcnMgLS0gaW5kZW50YXRpb24gbXVzdCBiZVxuXHQjIGNvcnJlY3RlZCBiZWZvcmUgaW1wbGljaXQgcGFyZW50aGVzZXMgY2FuIGJlIHdyYXBwZWQgYXJvdW5kIGJsb2NrcyBvZiBjb2RlLlxuXHRkZWYgcmV3cml0ZSB0b2tlbnMsIG9wdHMgPSB7fVxuXHRcdEB0b2tlbnMgID0gdG9rZW5zXG5cdFx0QG9wdGlvbnMgPSBvcHRzXG5cblx0XHQjIGNvbnNvbGUubG9nIFwidG9rZW5zIGluOiBcIiArIHRva2VuczpsZW5ndGhcblx0XHRjb25zb2xlLnRpbWUoXCJ0b2tlbml6ZTpyZXdyaXRlXCIpIGlmIG9wdHM6cHJvZmlsZVxuXG5cdFx0dmFyIGkgPSAwXG5cdFx0IyBmbGFnIGVtcHR5IG1ldGhvZHNcblx0XHR3aGlsZSB2YXIgdG9rZW4gPSB0b2tlbnNbaV1cblx0XHRcdHZhciBuZXh0ID0gdG9rZW5zW2kgKyAxXVxuXHRcdFx0aWYgdG9rZW4uQHR5cGUgPT0gJ0RFRl9CT0RZJyBhbmQgbmV4dCBhbmQgbmV4dC5AdHlwZSA9PSAnVEVSTUlOQVRPUidcblx0XHRcdFx0dG9rZW4uQHR5cGUgPSAnREVGX0VNUFRZJ1xuXHRcdFx0aSsrXG5cblx0XHRzdGVwKFwiZW5zdXJlRmlyc3RMaW5lXCIpXG5cdFx0c3RlcChcInJlbW92ZUxlYWRpbmdOZXdsaW5lc1wiKVxuXHRcdHN0ZXAoXCJyZW1vdmVNaWRFeHByZXNzaW9uTmV3bGluZXNcIilcblx0XHRzdGVwKFwidGFnRGVmQXJndW1lbnRzXCIpXG5cdFx0c3RlcChcImNsb3NlT3BlbkNhbGxzXCIpXG5cdFx0c3RlcChcImNsb3NlT3BlbkluZGV4ZXNcIilcblx0XHRzdGVwKFwiY2xvc2VPcGVuVGFnc1wiKVxuXHRcdHN0ZXAoXCJjbG9zZU9wZW5UYWdBdHRyTGlzdHNcIilcblx0XHRzdGVwKFwiYWRkSW1wbGljaXRJbmRlbnRhdGlvblwiKVxuXHRcdHN0ZXAoXCJ0YWdQb3N0Zml4Q29uZGl0aW9uYWxzXCIpXG5cdFx0c3RlcChcImFkZEltcGxpY2l0QnJhY2VzXCIpXG5cdFx0c3RlcChcImFkZEltcGxpY2l0UGFyZW50aGVzZXNcIilcblxuXHRcdGNvbnNvbGUudGltZUVuZChcInRva2VuaXplOnJld3JpdGVcIikgaWYgb3B0czpwcm9maWxlXG5cdFx0IyBjb25zb2xlLmxvZyBcInRva2VucyBvdXQ6IFwiICsgQHRva2VuczpsZW5ndGhcblx0XHRAdG9rZW5zXG5cblx0ZGVmIHN0ZXAgZm5cblx0XHRpZiBAb3B0aW9uczpwcm9maWxlXG5cdFx0XHRjb25zb2xlLmxvZyBcIi0tLS0gc3RhcnRpbmcge2ZufSAtLS0tIFwiXG5cdFx0XHRjb25zb2xlLnRpbWUoZm4pXG5cblx0XHR0aGlzW2ZuXSgpXG5cblx0XHRpZiBAb3B0aW9uczpwcm9maWxlXG5cdFx0XHRjb25zb2xlLnRpbWVFbmQoZm4pXG5cdFx0XHRjb25zb2xlLmxvZyBcIlxcblxcblwiXG5cdFx0cmV0dXJuXG5cblx0IyBSZXdyaXRlIHRoZSB0b2tlbiBzdHJlYW0sIGxvb2tpbmcgb25lIHRva2VuIGFoZWFkIGFuZCBiZWhpbmQuXG5cdCMgQWxsb3cgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgYmxvY2sgdG8gdGVsbCB1cyBob3cgbWFueSB0b2tlbnMgdG8gbW92ZVxuXHQjIGZvcndhcmRzIChvciBiYWNrd2FyZHMpIGluIHRoZSBzdHJlYW0sIHRvIG1ha2Ugc3VyZSB3ZSBkb24ndCBtaXNzIGFueXRoaW5nXG5cdCMgYXMgdG9rZW5zIGFyZSBpbnNlcnRlZCBhbmQgcmVtb3ZlZCwgYW5kIHRoZSBzdHJlYW0gY2hhbmdlcyBsZW5ndGggdW5kZXJcblx0IyBvdXIgZmVldC5cblx0ZGVmIHNjYW5Ub2tlbnMgYmxvY2tcblx0XHR2YXIgdG9rZW5zID0gQHRva2Vuc1xuXG5cdFx0dmFyIGkgPSAwXG5cdFx0d2hpbGUgdmFyIHRva2VuID0gdG9rZW5zW2ldXG5cdFx0XHRpICs9IGJsb2NrLmNhbGwoc2VsZiwgdG9rZW4sIGksIHRva2VucylcblxuXHRcdHRydWVcblxuXHRkZWYgZGV0ZWN0RW5kIGksIGNvbmRpdGlvbiwgYWN0aW9uXG5cdFx0dmFyIHRva2VucyA9IEB0b2tlbnNcblx0XHR2YXIgbGV2ZWxzID0gMFxuXHRcdHZhciBzdGFydHMgPSBbXVxuXHRcdHZhciB0b2tlblxuXHRcdHZhciB0LHZcblxuXHRcdHdoaWxlIHRva2VuID0gdG9rZW5zW2ldXG5cdFx0XHRpZiBsZXZlbHMgPT0gMCBhbmQgY29uZGl0aW9uLmNhbGwodGhpcyx0b2tlbixpLHN0YXJ0cylcblx0XHRcdFx0cmV0dXJuIGFjdGlvbi5jYWxsKHNlbGYsIHRva2VuLCBpKVxuXHRcdFx0aWYgIXRva2VuIG9yIGxldmVscyA8IDBcblx0XHRcdFx0cmV0dXJuIGFjdGlvbi5jYWxsKHNlbGYsIHRva2VuLCBpIC0gMSlcblxuXHRcdFx0dCA9IFQudHlwKHRva2VuKVxuXG5cdFx0XHRpZiBFWFBSRVNTSU9OX1NUQVJULmluZGV4T2YodCkgPj0gMFxuXHRcdFx0XHRzdGFydHMucHVzaChpKSBpZiBsZXZlbHMgPT0gMFxuXHRcdFx0XHRsZXZlbHMgKz0gMVxuXHRcdFx0ZWxpZiBFWFBSRVNTSU9OX0VORC5pbmRleE9mKHQpID49IDBcblx0XHRcdFx0bGV2ZWxzIC09IDFcblx0XHRcdGkgKz0gMVxuXHRcdGkgLSAxXG5cblx0ZGVmIGVuc3VyZUZpcnN0TGluZVxuXHRcdHZhciB0b2sgPSBAdG9rZW5zWzBdXG5cblx0XHRpZiBULnR5cCh0b2spID09ICdURVJNSU5BVE9SJ1xuXHRcdFx0IyBjb25zb2xlLmxvZyBcImFkZGluZyBib2R5c3RhcnRcIlxuXHRcdFx0QHRva2VucyA9IFtULnRva2VuKCdCT0RZU1RBUlQnLCdCT0RZU1RBUlQnKV0uY29uY2F0KEB0b2tlbnMpXG5cdFx0XHQjIFQuc2V0VHlwKHRvaywnSEVBREVSJylcblx0XHRyZXR1cm5cblxuXHQjIExlYWRpbmcgbmV3bGluZXMgd291bGQgaW50cm9kdWNlIGFuIGFtYmlndWl0eSBpbiB0aGUgZ3JhbW1hciwgc28gd2Vcblx0IyBkaXNwYXRjaCB0aGVtIGhlcmUuXG5cdGRlZiByZW1vdmVMZWFkaW5nTmV3bGluZXNcblx0XHR2YXIgYXQgPSAwXG5cblx0XHRmb3IgdG9rZW4saSBpbiBAdG9rZW5zXG5cdFx0XHRpZiBULnR5cCh0b2tlbikgIT0gJ1RFUk1JTkFUT1InXG5cdFx0XHRcdGJyZWFrIGF0ID0gaVxuXHRcdFxuXHRcdEB0b2tlbnMuc3BsaWNlKDAsIGF0KSBpZiBhdFxuXG5cdFx0cmV0dXJuXG5cblx0IyBTb21lIGJsb2NrcyBvY2N1ciBpbiB0aGUgbWlkZGxlIG9mIGV4cHJlc3Npb25zIC0tIHdoZW4gd2UncmUgZXhwZWN0aW5nXG5cdCMgdGhpcywgcmVtb3ZlIHRoZWlyIHRyYWlsaW5nIG5ld2xpbmVzLlxuXHRkZWYgcmVtb3ZlTWlkRXhwcmVzc2lvbk5ld2xpbmVzXG5cdFx0c2NhblRva2VucyBkbyB8dG9rZW4saSx0b2tlbnN8ICMgZG8gfHRva2VuLGksdG9rZW5zfFxuXHRcdFx0dmFyIG5leHQgPSB0b2tlblR5cGUoaSArIDEpXG5cblx0XHRcdHJldHVybiAxIHVubGVzcyBULnR5cCh0b2tlbikgaXMgJ1RFUk1JTkFUT1InIGFuZCBFWFBSRVNTSU9OX0NMT1NFLmluZGV4T2YobmV4dCkgPj0gMFxuXHRcdFx0cmV0dXJuIDEgaWYgbmV4dCA9PSAnT1VUREVOVCdcblx0XHRcdHRva2Vucy5zcGxpY2UoaSwgMSlcblx0XHRcdDBcblxuXG5cdGRlZiB0YWdEZWZBcmd1bWVudHNcblx0XHR5ZXNcblxuXHQjIFRoZSBsZXhlciBoYXMgdGFnZ2VkIHRoZSBvcGVuaW5nIHBhcmVudGhlc2lzIG9mIGEgbWV0aG9kIGNhbGwuIE1hdGNoIGl0IHdpdGhcblx0IyBpdHMgcGFpcmVkIGNsb3NlLiBXZSBoYXZlIHRoZSBtaXMtbmVzdGVkIG91dGRlbnQgY2FzZSBpbmNsdWRlZCBoZXJlIGZvclxuXHQjIGNhbGxzIHRoYXQgY2xvc2Ugb24gdGhlIHNhbWUgbGluZSwganVzdCBiZWZvcmUgdGhlaXIgb3V0ZGVudC5cblx0ZGVmIGNsb3NlT3BlbkNhbGxzXG5cdFx0dmFyIGNvbmRpdGlvbiA9IGRvIHx0b2tlbixpfFxuXHRcdFx0dmFyIHQgPSBULnR5cCh0b2tlbilcblx0XHRcdCh0ID09ICcpJyBvciB0ID09ICdDQUxMX0VORCcpIHx8IHQgPT0gJ09VVERFTlQnIGFuZCB0b2tlblR5cGUoaSAtIDEpID09ICcpJ1xuXG5cdFx0dmFyIGFjdGlvbiA9IGRvIHx0b2tlbiwgaXxcblx0XHRcdHZhciB0ID0gVC50eXAodG9rZW4pXG5cdFx0XHR2YXIgdG9rID0gQHRva2Vuc1t0ID09ICdPVVRERU5UJyA/IGkgLSAxIDogaV1cblx0XHRcdFQuc2V0VHlwKHRvaywnQ0FMTF9FTkQnKVxuXG5cdFx0c2NhblRva2VucyBkbyB8dG9rZW4saXxcblx0XHRcdGRldGVjdEVuZChpICsgMSwgY29uZGl0aW9uLCBhY3Rpb24pIGlmIFQudHlwKHRva2VuKSBpcyAnQ0FMTF9TVEFSVCdcblx0XHRcdHJldHVybiAxXG5cblx0IyBUaGUgbGV4ZXIgaGFzIHRhZ2dlZCB0aGUgb3BlbmluZyBwYXJlbnRoZXNpcyBvZiBhbiBpbmRleGluZyBvcGVyYXRpb24gY2FsbC5cblx0IyBNYXRjaCBpdCB3aXRoIGl0cyBwYWlyZWQgY2xvc2UuXG5cdGRlZiBjbG9zZU9wZW5JbmRleGVzXG5cdFx0dmFyIGNvbmRpdGlvbiA9IGRvIHx0b2tlbiwgaXwgVC50eXAodG9rZW4pIGluIFsnXScsICdJTkRFWF9FTkQnXVxuXHRcdHZhciBhY3Rpb24gICAgPSBkbyB8dG9rZW4sIGl8IFQuc2V0VHlwKHRva2VuLCdJTkRFWF9FTkQnKVxuXHRcdFxuXHRcdHNjYW5Ub2tlbnMgZG8gfHRva2VuLGl8XG5cdFx0XHRkZXRlY3RFbmQgaSArIDEsIGNvbmRpdGlvbiwgYWN0aW9uIGlmIFQudHlwKHRva2VuKSBpcyAnSU5ERVhfU1RBUlQnXG5cdFx0XHRyZXR1cm4gMVxuXG5cdFxuXHRkZWYgY2xvc2VPcGVuVGFnQXR0ckxpc3RzXG5cdFx0dmFyIGNvbmRpdGlvbiA9IGRvIHx0b2tlbiwgaXwgVC50eXAodG9rZW4pIGluIFsnKScsICdUQUdfQVRUUlNfRU5EJ11cblx0XHR2YXIgYWN0aW9uICAgID0gZG8gfHRva2VuLCBpfCBULnNldFR5cCh0b2tlbiwnVEFHX0FUVFJTX0VORCcpICMgJ1RBR19BVFRSU19FTkQnXG5cblx0XHRzY2FuVG9rZW5zIGRvIHx0b2tlbixpfFxuXHRcdFx0ZGV0ZWN0RW5kIGkgKyAxLCBjb25kaXRpb24sIGFjdGlvbiBpZiBULnR5cCh0b2tlbikgaXMgJ1RBR19BVFRSU19TVEFSVCdcblx0XHRcdHJldHVybiAxXG5cdFxuXHQjIFRoZSBsZXhlciBoYXMgdGFnZ2VkIHRoZSBvcGVuaW5nIHBhcmVudGhlc2lzIG9mIGFuIGluZGV4aW5nIG9wZXJhdGlvbiBjYWxsLlxuXHQjIE1hdGNoIGl0IHdpdGggaXRzIHBhaXJlZCBjbG9zZS4gU2hvdWxkIGJlIGRvbmUgaW4gbGV4ZXIgZGlyZWN0bHlcblx0ZGVmIGNsb3NlT3BlblRhZ3Ncblx0XHR2YXIgY29uZGl0aW9uID0gZG8gfHRva2VuLCBpfCBULnR5cCh0b2tlbikgaW4gWyc+JywgJ1RBR19FTkQnXVxuXHRcdHZhciBhY3Rpb24gICAgPSBkbyB8dG9rZW4sIGl8IFQuc2V0VHlwKHRva2VuLCdUQUdfRU5EJykgIyB0b2tlblswXSA9ICdUQUdfRU5EJ1xuXG5cdFx0c2NhblRva2VucyBkbyB8dG9rZW4saXxcblx0XHRcdGRldGVjdEVuZCBpICsgMSwgY29uZGl0aW9uLCBhY3Rpb24gaWYgVC50eXAodG9rZW4pIGlzICdUQUdfU1RBUlQnXG5cdFx0XHRyZXR1cm4gMVxuXHRcdFxuXHRkZWYgYWRkSW1wbGljaXRDb21tYXNcblx0XHRyZXR1cm5cblxuXHRkZWYgYWRkSW1wbGljaXRCbG9ja0NhbGxzXG5cdFx0dmFyIGkgPSAxXG5cdFx0dmFyIHRva2VucyA9IEB0b2tlbnNcblxuXHRcdHdoaWxlIHZhciB0b2tlbiA9IHRva2Vuc1tpXVxuXHRcdFx0dmFyIHQgPSB0b2tlbi5AdHlwZVxuXHRcdFx0dmFyIHYgPSB0b2tlbi5AdmFsdWVcblx0XHRcdCMgaG1tXG5cdFx0XHRpZiB0ID09ICdETycgYW5kICh2ID09ICdJTkRFWF9FTkQnIG9yIHYgPT0gJ0lERU5USUZJRVInIG9yIHYgPT0gJ05FVycpXG5cdFx0XHRcdHRva2Vucy5zcGxpY2UgaSArIDEsIDAsIFQudG9rZW4oJ0NBTExfRU5EJywnKScpXG5cdFx0XHRcdHRva2Vucy5zcGxpY2UgaSArIDEsIDAsIFQudG9rZW4oJ0NBTExfU1RBUlQnLCcoJylcblx0XHRcdFx0aSsrXG5cdFx0XHRpKytcblxuXHRcdHJldHVyblxuXG5cdCMgT2JqZWN0IGxpdGVyYWxzIG1heSBiZSB3cml0dGVuIHdpdGggaW1wbGljaXQgYnJhY2VzLCBmb3Igc2ltcGxlIGNhc2VzLlxuXHQjIEluc2VydCB0aGUgbWlzc2luZyBicmFjZXMgaGVyZSwgc28gdGhhdCB0aGUgcGFyc2VyIGRvZXNuJ3QgaGF2ZSB0by5cblx0ZGVmIGFkZEltcGxpY2l0QnJhY2VzXG5cdFx0dmFyIHN0YWNrICAgICAgID0gW11cblx0XHR2YXIgc3RhcnQgICAgICAgPSBudWxsXG5cdFx0dmFyIHN0YXJ0SW5kZW50ID0gMFxuXHRcdHZhciBzdGFydElkeCA9IG51bGxcblxuXHRcdHZhciBub0JyYWNlVGFnID0gWydDTEFTUycsICdJRicsJ1VOTEVTUycsJ1RBRycsJ1dISUxFJywnRk9SJywnVU5USUwnLCdDQVRDSCcsJ0ZJTkFMTFknLCdNT0RVTEUnLCdMRUFESU5HX1dIRU4nXVxuXHRcdHZhciBub0JyYWNlQ29udGV4dCA9IFsnSUYnLCdURVJOQVJZJywnRk9SJ11cblxuXHRcdHZhciBub0JyYWNlID0gbm9cblxuXHRcdHZhciBzY29wZSA9IGRvIFxuXHRcdFx0c3RhY2tbc3RhY2s6bGVuZ3RoIC0gMV0gb3IgW11cblxuXHRcdHZhciBhY3Rpb24gPSBkbyB8dG9rZW4saXxcblx0XHRcdEB0b2tlbnMuc3BsaWNlIGksIDAsIFQuUkJSQUNLRVRcblxuXHRcdHZhciBvcGVuID0gZG8gfHRva2VuLGl8XG5cdFx0XHRAdG9rZW5zLnNwbGljZSBpLCAwLCBULkxCUkFDS0VUXG5cblx0XHR2YXIgY2xvc2UgPSBkbyB8dG9rZW4saXxcblx0XHRcdEB0b2tlbnMuc3BsaWNlIGksIDAsIFQuUkJSQUNLRVRcblxuXHRcdHZhciBzdGFja1Rva2VuID0gZG8gfGEsYnxcblx0XHRcdHJldHVybiBbYSxiXVxuXG5cdFx0c2NhblRva2VucyBkbyB8dG9rZW4saSx0b2tlbnN8XG5cdFx0XHR2YXIgdHlwZSA9IFQudHlwKHRva2VuKVxuXHRcdFx0dmFyIHYgPSBULnZhbCh0b2tlbilcblx0XHRcdHZhciBjdHggPSBzdGFja1tzdGFjazpsZW5ndGggLSAxXSBvciBbXVxuXHRcdFx0dmFyIGlkeFxuXG5cdFx0XHRpZiBub0JyYWNlQ29udGV4dC5pbmRleE9mKHR5cGUpID49IDBcblx0XHRcdFx0IyBjb25zb2xlLmxvZyBcImZvdW5kIG5vQnJhY2VUYWcge3R5cGV9XCJcblx0XHRcdFx0c3RhY2sucHVzaCBzdGFja1Rva2VuKHR5cGUsaSlcblx0XHRcdFx0cmV0dXJuIDFcblxuXHRcdFx0aWYgdiA9PSAnPydcblx0XHRcdFx0IyBjb25zb2xlLmxvZygnVEVSTkFSWSBPUEVSQVRPUiEnKVxuXHRcdFx0XHRzdGFjay5wdXNoIHN0YWNrVG9rZW4oJ1RFUk5BUlknLGkpXG5cdFx0XHRcdHJldHVybiAxXG5cdFx0XHRcblx0XHRcdCMgbm8gbmVlZCB0byB0ZXN0IGZvciB0aGlzIGhlcmUgYXMgd2VsbCBhcyBpblxuXHRcdFx0aWYgRVhQUkVTU0lPTl9TVEFSVC5pbmRleE9mKHR5cGUpID49IDBcblx0XHRcdFx0aWYgdHlwZSA9PSAnSU5ERU5UJyBhbmQgbm9CcmFjZUNvbnRleHQuaW5kZXhPZihjdHhbMF0pID49IDBcblx0XHRcdFx0XHRzdGFjay5wb3BcblxuXHRcdFx0XHQjIGNvbnNvbGUubG9nKCdleHByZXNzaW9uIHN0YXJ0Jyx0eXBlLGN0eFswXSlcblx0XHRcdFx0aWYgdHlwZSA9PSAnSU5ERU5UJyBhbmQgdG9rZW5UeXBlKGkgLSAxKSA9PSAneydcblx0XHRcdFx0XHQjIHN0YWNrID8hPyBubyB0b2tlblxuXHRcdFx0XHRcdHN0YWNrLnB1c2ggc3RhY2tUb2tlbigneycsIGkpICMgc2hvdWxkIG5vdCBhdXRvZ2VuZXJhdGUgYW5vdGhlcj9cblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHN0YWNrLnB1c2ggc3RhY2tUb2tlbih0eXBlLCBpKVxuXHRcdFx0XHRyZXR1cm4gMVxuXG5cdFx0XHRpZiBFWFBSRVNTSU9OX0VORC5pbmRleE9mKHR5cGUpID49IDBcblx0XHRcdFx0IyBjb25zb2xlLmxvZyBcIkVYUFJFU1NJT05fRU5EIGF0IHt0eXBlfSAtIHN0YWNrIGlzIHtjdHhbMF19XCJcblx0XHRcdFx0aWYgY3R4WzBdID09ICdURVJOQVJZJyAjIEZJWD9cblx0XHRcdFx0XHRzdGFjay5wb3BcblxuXHRcdFx0XHRzdGFydCA9IHN0YWNrLnBvcFxuXHRcdFx0XHR1bmxlc3Mgc3RhcnRcblx0XHRcdFx0XHRjb25zb2xlLmxvZyBcIk5PIFNUQUNLISFcIlxuXHRcdFx0XHRzdGFydFsyXSA9IGlcblxuXHRcdFx0XHQjIHNlZW1zIGxpa2UgdGhlIHN0YWNrIHNob3VsZCB1c2UgdG9rZW5zLCBubz8pXG5cdFx0XHRcdGlmIHN0YXJ0WzBdID09ICd7JyBhbmQgc3RhcnQ6Z2VuZXJhdGVkICMgICMgdHlwZSAhPSAnfScgIyBhbmQgc3RhcnQ6Z2VuZXJhdGVkXG5cdFx0XHRcdFx0Y2xvc2UodG9rZW4saSlcblx0XHRcdFx0XHRyZXR1cm4gMVxuXG5cdFx0XHRcdHJldHVybiAxXG5cdFx0XHRcblx0XHRcdCMgaXMgdGhpcyBjb3JyZWN0PyBzYW1lIGZvciBpZi9jbGFzcyBldGM/XG5cdFx0XHRpZiBjdHhbMF0gPT0gJ1RFUk5BUlknIGFuZCAodHlwZSA9PSAnVEVSTUlOQVRPUicgb3IgdHlwZSA9PSAnT1VUREVOVCcpXG5cdFx0XHRcdHN0YWNrLnBvcFxuXHRcdFx0XHRyZXR1cm4gMVxuXG5cdFx0XHRpZiBub0JyYWNlQ29udGV4dC5pbmRleE9mKGN0eFswXSkgPj0gMCBhbmQgdHlwZSA9PSAnSU5ERU5UJ1xuXHRcdFx0XHRjb25zb2xlLmxvZyBcInBvcHBpbmcgbm9CcmFjZUNvbnRleHRcIlxuXHRcdFx0XHRzdGFjay5wb3Bcblx0XHRcdFx0cmV0dXJuIDFcblxuXG5cdFx0XHRpZiB0eXBlID09ICcsJ1xuXHRcdFx0XHQjIGF1dG9tYXRpY2FsbHkgYWRkIGFuIGVuZGluZyBoZXJlIGlmIGluc2lkZTpnZW5lcmF0ZWQgc2NvcGU/XG5cdFx0XHRcdCMgaXQgaXMgaW1wb3J0YW50IHRoYXQgdGhpcyBpczpnZW5lcmF0ZWQoISlcblx0XHRcdFx0aWYgY3R4WzBdID09ICd7JyBhbmQgY3R4OmdlbmVyYXRlZFxuXHRcdFx0XHRcdHRva2Vucy5zcGxpY2UoaSwgMCwgVC5SQlJBQ0tFVClcblx0XHRcdFx0XHRzdGFjay5wb3Bcblx0XHRcdFx0XHRyZXR1cm4gMlxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0cmV0dXJuIDFcblx0XHRcdFx0dHJ1ZVxuXG5cdFx0XHQjIGZvdW5kIGEgdHlwZVxuXHRcdFx0aWYgdHlwZSA9PSAnOicgYW5kIGN0eFswXSAhPSAneycgYW5kIGN0eFswXSAhPSAnVEVSTkFSWScgYW5kIChub0JyYWNlQ29udGV4dC5pbmRleE9mKGN0eFswXSkgPT0gLTEpXG5cdFx0XHRcdCMgY291bGQganVzdCBjaGVjayBpZiB0aGUgZW5kIHdhcyByaWdodCBiZWZvcmUgdGhpcz9cblx0XHRcdFx0XG5cdFx0XHRcdGlmIHN0YXJ0IGFuZCBzdGFydFsyXSA9PSBpIC0gMVxuXHRcdFx0XHRcdCMgY29uc29sZS5sb2coJ3RoaXMgZXhwcmVzc2lvbiB3YXMganVzdCBlbmRpbmcgYmVmb3JlIGNvbG9uIScpXG5cdFx0XHRcdFx0aWR4ID0gc3RhcnRbMV0gLSAxICMgdGhlc2UgYXJlIHRoZSBzdGFja1Rva2Vuc1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0IyBjb25zb2xlLmxvZyBcInJld3JpdGUgaGVyZT8gI3tpfVwiXG5cdFx0XHRcdFx0aWR4ID0gaSAtIDIgIyBpZiBzdGFydCB0aGVuIHN0YXJ0WzFdIC0gMSBlbHNlIGkgLSAyXG5cdFx0XHRcdFx0IyBpZHggPSBpZHggLSAxIGlmIHRva2VuVHlwZShpZHgpIGlzICdURVJNSU5BVE9SJ1xuXG5cdFx0XHRcdGlkeCAtPSAyIHdoaWxlIHRva2VuVHlwZShpZHggLSAxKSBpcyAnSEVSRUNPTU1FTlQnXG5cblx0XHRcdFx0dmFyIHQwID0gdG9rZW5zW2lkeCAtIDFdXG5cblx0XHRcdFx0aWYgdDAgYW5kIFQudHlwKHQwKSA9PSAnfScgYW5kIHQwOmdlbmVyYXRlZFxuXHRcdFx0XHRcdHRva2Vucy5zcGxpY2UoaWR4IC0gMSwxKVxuXHRcdFx0XHRcdHZhciBzID0gc3RhY2tUb2tlbigneycpXG5cdFx0XHRcdFx0czpnZW5lcmF0ZWQgPSB5ZXNcblx0XHRcdFx0XHRzdGFjay5wdXNoIHNcblx0XHRcdFx0XHRyZXR1cm4gMFxuXG5cdFx0XHRcdCMgaGFja3kgZWRnZWNhc2UgZm9yIGluZGVudHNcblx0XHRcdFx0ZWxpZiB0MCBhbmQgVC50eXAodDApID09ICcsJyBhbmQgdG9rZW5UeXBlKGlkeCAtIDIpID09ICd9J1xuXHRcdFx0XHRcdHRva2Vucy5zcGxpY2UoaWR4IC0gMiwxKVxuXHRcdFx0XHRcdHZhciBzID0gc3RhY2tUb2tlbigneycpXG5cdFx0XHRcdFx0czpnZW5lcmF0ZWQgPSB5ZXNcblx0XHRcdFx0XHRzdGFjay5wdXNoIHNcblx0XHRcdFx0XHRyZXR1cm4gMFxuXG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHR2YXIgcyA9IHN0YWNrVG9rZW4oJ3snKVxuXHRcdFx0XHRcdHM6Z2VuZXJhdGVkID0geWVzXG5cdFx0XHRcdFx0c3RhY2sucHVzaCBzXG5cdFx0XHRcdFx0b3Blbih0b2tlbixpZHggKyAxKVxuXHRcdFx0XHRcdHJldHVybiAyXG5cblx0XHRcdCMgd2UgcHJvYmFibHkgbmVlZCB0byBydW4gdGhyb3VnaCBhdXRvY2FsbCBmaXJzdD8hXG5cblx0XHRcdGlmIHR5cGUgPT0gJ0RPJyAjIGFuZCBjdHg6Z2VuZXJhdGVkXG5cdFx0XHRcdHZhciBwcmV2ID0gVC50eXAodG9rZW5zW2kgLSAxXSkgIyBbMF1cblx0XHRcdFx0aWYgWydOVU1CRVInLCdTVFJJTkcnLCdSRUdFWCcsJ1NZTUJPTCcsJ10nLCd9JywnKScsJ1NUUklOR19FTkQnXS5pbmRleE9mKHByZXYpID49IDBcblxuXHRcdFx0XHRcdHZhciB0b2sgPSBULnRva2VuKCcsJywgJywnKVxuXHRcdFx0XHRcdHRvazpnZW5lcmF0ZWQgPSB5ZXNcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKGksMCx0b2spXG5cblx0XHRcdFx0XHRpZiBjdHg6Z2VuZXJhdGVkXG5cdFx0XHRcdFx0XHRjbG9zZSh0b2tlbixpKVxuXHRcdFx0XHRcdFx0c3RhY2sucG9wXG5cdFx0XHRcdFx0XHRyZXR1cm4gMlxuXG5cdFx0XHRpZiAodHlwZSA9PSAnVEVSTUlOQVRPUicgb3IgdHlwZSA9PSAnT1VUREVOVCcgb3IgdHlwZSA9PSAnREVGX0JPRFknKSBhbmQgY3R4OmdlbmVyYXRlZFxuXHRcdFx0XHRjbG9zZSh0b2tlbixpKVxuXHRcdFx0XHRzdGFjay5wb3Bcblx0XHRcdFx0cmV0dXJuIDJcblxuXHRcdFx0cmV0dXJuIDFcblxuXHQjIE1ldGhvZHMgbWF5IGJlIG9wdGlvbmFsbHkgY2FsbGVkIHdpdGhvdXQgcGFyZW50aGVzZXMsIGZvciBzaW1wbGUgY2FzZXMuXG5cdCMgSW5zZXJ0IHRoZSBpbXBsaWNpdCBwYXJlbnRoZXNlcyBoZXJlLCBzbyB0aGF0IHRoZSBwYXJzZXIgZG9lc24ndCBoYXZlIHRvXG5cdCMgZGVhbCB3aXRoIHRoZW0uXG5cdCMgUHJhY3RpY2FsbHkgZXZlcnl0aGluZyB3aWxsIG5vdyBiZSBjYWxsYWJsZSB0aGlzIHdheSAoZXZlcnkgaWRlbnRpZmllcilcblx0ZGVmIGFkZEltcGxpY2l0UGFyZW50aGVzZXNcblx0XHRcblx0XHR2YXIgbm9DYWxsVGFnID0gWydDTEFTUycsICdJRicsJ1VOTEVTUycsJ1RBRycsJ1dISUxFJywnRk9SJywnVU5USUwnLCdDQVRDSCcsJ0ZJTkFMTFknLCdNT0RVTEUnLCdMRUFESU5HX1dIRU4nXVxuXHRcdFxuXHRcdHZhciBhY3Rpb24gPSBkbyB8dG9rZW4saXxcblx0XHRcdEB0b2tlbnMuc3BsaWNlIGksIDAsIFQudG9rZW4oJ0NBTExfRU5EJywgJyknKVxuXG5cdFx0IyBjb25zb2xlLmxvZyBcImFkZGluZyBpbXBsaWNpdCBwYXJlbnRoZXNpc1wiICMgLHNlbGY6c2NhblRva2Vuc1xuXHRcdHZhciB0b2tlbnMgPSBAdG9rZW5zXG5cblx0XHR2YXIgbm9DYWxsID0gbm9cblx0XHR2YXIgc2VlbkZvciA9IG5vXG5cdFx0dmFyIGVuZENhbGxBdFRlcm1pbmF0b3IgPSBub1xuXG5cdFx0dmFyIGkgPSAwXG5cdFx0d2hpbGUgdmFyIHRva2VuID0gdG9rZW5zW2ldXG5cblx0XHRcdCMgdG8gaGFuZGxlIGNhc2VzIGxpa2U6XG5cdFx0XHQjIGlmIGEoZG8geWVzKS50ZXN0XG5cdFx0XHQjIFx0eWVzXG5cdFx0XHQjIHdlIG5lZWQgdG8ga2VlcCBhIHN0YWNrIGZvciBiYWxhbmNlZCBwYWlyc1xuXHRcdFx0IyB1bnRpbCB0aGVuIHlvdSBtdXN0IGV4cGxpY2l0bHkgZW5kIHRoZSBjYWxsIGxpa2Vcblx0XHRcdCMgaWYgYShkbyB5ZXMpLnRlc3QoKVxuXHRcdFx0IyBcdHllc1xuXG5cdFx0XHR2YXIgdHlwZSA9IHRva2VuLkB0eXBlXG5cblx0XHRcdHZhciBwcmV2ICAgID0gdG9rZW5zW2kgLSAxXVxuXHRcdFx0dmFyIGN1cnJlbnQgPSB0b2tlbnNbaV1cblx0XHRcdHZhciBuZXh0ICAgID0gdG9rZW5zW2kgKyAxXVxuXG5cdFx0XHR2YXIgcHQgPSBwcmV2IGFuZCBwcmV2LkB0eXBlXG5cdFx0XHR2YXIgbnQgPSBuZXh0IGFuZCBuZXh0LkB0eXBlXG5cblx0XHRcdCMgaWYgcHQgPT0gJ1dIRU4nXG5cdFx0XHQjIE5ldmVyIG1ha2UgdGhlc2UgdGFncyBpbXBsaWNpdGx5IGNhbGxcblx0XHRcdCMgc2hvdWxkIHdlIG5vdCBqdXN0IHJlbW92ZSB0aGVzZSBmcm9tIElNUExJQ0lUX0ZVTkM/XG5cdFx0XHRpZiAocHQgPT0gJyknIG9yIHB0ID09ICddJykgYW5kIHR5cGUgPT0gJ0lOREVOVCdcblx0XHRcdFx0bm9DYWxsID0geWVzXG5cblx0XHRcdGlmIG5vQ2FsbFRhZy5pbmRleE9mKHB0KSA+PSAwXG5cdFx0XHRcdCMgY29uc29sZS5sb2coXCJzZWVuIG5vY2FsbCB0YWcge3B0fSAoe3B0fSB7dHlwZX0ge250fSlcIilcblx0XHRcdFx0ZW5kQ2FsbEF0VGVybWluYXRvciA9IHllc1xuXHRcdFx0XHRub0NhbGwgID0geWVzXG5cdFx0XHRcdHNlZW5Gb3IgPSB5ZXMgaWYgcHQgPT0gJ0ZPUidcblx0XHRcdFx0XG5cblx0XHRcdHZhciBjYWxsT2JqZWN0ID0gbm9cblx0XHRcdHZhciBjYWxsSW5kZW50ID0gbm9cblxuXHRcdFx0IyBbcHJldiwgY3VycmVudCwgbmV4dF0gPSB0b2tlbnNbaSAtIDEgLi4gaSArIDFdXG5cblx0XHRcdCMgY2hlY2sgZm9yIGNvbW1lbnRzXG5cdFx0XHQjIGNvbnNvbGUubG9nIFwiZGV0ZWN0IGVuZD8/XCJcblx0XHRcdGlmICFub0NhbGwgYW5kIHR5cGUgPT0gJ0lOREVOVCcgYW5kIG5leHRcblx0XHRcdFx0dmFyIHByZXZJbXBGdW5jID0gcHQgYW5kIElNUExJQ0lUX0ZVTkMuaW5kZXhPZihwdCkgPj0gMFxuXHRcdFx0XHR2YXIgbmV4dEltcENhbGwgPSBudCBhbmQgSU1QTElDSVRfQ0FMTC5pbmRleE9mKG50KSA+PSAwXG5cdFx0XHRcdGNhbGxPYmplY3QgPSAoKG5leHQ6Z2VuZXJhdGVkIGFuZCBudCBpcyAneycpIG9yIG5leHRJbXBDYWxsKSBhbmQgcHJldkltcEZ1bmNcblx0XHRcdFx0Y2FsbEluZGVudCA9IG5leHRJbXBDYWxsIGFuZCBwcmV2SW1wRnVuY1xuXG5cdFx0XHR2YXIgc2VlblNpbmdsZSAgPSBub1xuXHRcdFx0dmFyIHNlZW5Db250cm9sID0gbm9cblx0XHRcdCMgSG1tID9cblxuXHRcdFx0IyB0aGlzIGlzIG5vdCBjb3JyZWN0IGlmIHRoaXMgaXMgaW5zaWRlIGEgYmxvY2ssbm8/XG5cdFx0XHRpZiAodHlwZSA9PSAnVEVSTUlOQVRPUicgb3IgdHlwZSA9PSAnT1VUREVOVCcgb3IgdHlwZSA9PSAnSU5ERU5UJylcblx0XHRcdFx0ZW5kQ2FsbEF0VGVybWluYXRvciA9IG5vXG5cdFx0XHRcdG5vQ2FsbCA9IG5vIFxuXG5cdFx0XHR0b2tlbjpjYWxsICA9IHllcyBpZiB0eXBlIGlzICc/JyBhbmQgcHJldiBhbmQgIXByZXY6c3BhY2VkXG5cblx0XHRcdCMgd2hlcmUgZG9lcyBmcm9tVGhlbSBjb21lIGZyb20/XG5cdFx0XHRpZiB0b2tlbjpmcm9tVGhlblxuXHRcdFx0XHRjb250aW51ZSBpICs9IDEgXG5cdFx0XHQjIGhlcmUgd2UgZGVhbCB3aXRoIDpzcGFjZWQgYW5kIDpuZXdMaW5lXG5cdFx0XHR1bmxlc3MgY2FsbE9iamVjdCBvciBjYWxsSW5kZW50IG9yIChwcmV2IGFuZCBwcmV2OnNwYWNlZCkgYW5kIChwcmV2OmNhbGwgb3IgSU1QTElDSVRfRlVOQy5pbmRleE9mKHB0KSA+PSAwKSBhbmQgKElNUExJQ0lUX0NBTEwuaW5kZXhPZih0eXBlKSA+PSAwIG9yICEodG9rZW46c3BhY2VkIG9yIHRva2VuOm5ld0xpbmUpIGFuZCBJTVBMSUNJVF9VTlNQQUNFRF9DQUxMLmluZGV4T2YodHlwZSkgPj0gMClcblx0XHRcdFx0Y29udGludWUgaSArPSAxXG5cblxuXHRcdFx0dG9rZW5zLnNwbGljZSBpLCAwLCBULnRva2VuKCdDQUxMX1NUQVJUJywgJygnKVxuXHRcdFx0IyBjb25zb2xlLmxvZyBcImFkZGVkICgge3ByZXZ9XCJcblx0XHRcdHZhciBjb25kID0gZG8gfHRva2VuLGl8XG5cdFx0XHRcdHZhciB0eXBlID0gVC50eXAodG9rZW4pXG5cdFx0XHRcdHJldHVybiB5ZXMgaWYgIXNlZW5TaW5nbGUgYW5kIHRva2VuOmZyb21UaGVuXG5cdFx0XHRcdHZhciBpZmVsc2UgPSB0eXBlID09ICdJRicgb3IgdHlwZSA9PSAnVU5MRVNTJyBvciB0eXBlID09ICdFTFNFJ1xuXHRcdFx0XHRzZWVuU2luZ2xlICA9IHllcyBpZiBpZmVsc2Ugb3IgdHlwZSA9PSAnQ0FUQ0gnXG5cdFx0XHRcdHNlZW5Db250cm9sID0geWVzIGlmIGlmZWxzZSBvciB0eXBlID09ICdTV0lUQ0gnIG9yIHR5cGUgPT0gJ1RSWSdcblx0XHRcdFx0dmFyIHByZXYgPSB0b2tlblR5cGUoaSAtIDEpXG5cblx0XHRcdFx0cmV0dXJuIHllcyBpZiAodHlwZSA9PSAnLicgb3IgdHlwZSA9PSAnPy4nIG9yIHR5cGUgPT0gJzo6JykgYW5kIHByZXYgaXMgJ09VVERFTlQnXG5cdFx0XHRcdHJldHVybiB5ZXMgaWYgZW5kQ2FsbEF0VGVybWluYXRvciBhbmQgKHR5cGUgPT0gJ0lOREVOVCcgb3IgdHlwZSA9PSAnVEVSTUlOQVRPUicpXG5cdFx0XHRcdGlmICh0eXBlID09ICdXSEVOJyBvciB0eXBlID09ICdCWScpIGFuZCAhc2VlbkZvclxuXHRcdFx0XHRcdCMgY29uc29sZS5sb2cgXCJkb250IGNsb3NlIGltcGxpY2l0IGNhbGwgb3V0c2lkZSBmb3JcIlxuXHRcdFx0XHRcdHJldHVybiBubyBcblxuXHRcdFx0XHR2YXIgcG9zdCA9IHRva2Vuc1tpICsgMV1cblx0XHRcdFx0dmFyIHBvc3RUeXAgPSBwb3N0IGFuZCBULnR5cChwb3N0KVxuXHRcdFx0XHQjIFdURlxuXHRcdFx0XHRyZXR1cm4gIXRva2VuOmdlbmVyYXRlZCBhbmQgcHJldiBpc250ICcsJyBhbmQgKElNUExJQ0lUX0VORC5pbmRleE9mKHR5cGUpID49IDAgb3IgKHR5cGUgaXMgJ0lOREVOVCcgYW5kICFzZWVuQ29udHJvbCkgb3IgKHR5cGUgaXMgJ0RPUycgYW5kIHByZXYgIT0gJz0nKSkgYW5kICh0eXBlIGlzbnQgJ0lOREVOVCcgb3IgKHRva2VuVHlwZShpIC0gMikgaXNudCAnQ0xBU1MnIGFuZCBJTVBMSUNJVF9CTE9DSy5pbmRleE9mKHByZXYpID09IC0xIGFuZCBub3QgKHBvc3QgYW5kICgocG9zdDpnZW5lcmF0ZWQgYW5kIHBvc3RUeXAgaXMgJ3snKSBvciBJTVBMSUNJVF9DQUxMLmluZGV4T2YocG9zdFR5cCkgPj0gMCkpKSlcblxuXHRcdFx0IyBUaGUgYWN0aW9uIGZvciBkZXRlY3Rpbmcgd2hlbiB0aGUgY2FsbCBzaG91bGQgZW5kXG5cdFx0XHQjIGNvbnNvbGUubG9nIFwiZGV0ZWN0IGVuZD8/XCJcblx0XHRcdGRldGVjdEVuZChpICsgMSwgY29uZCwgYWN0aW9uKVxuXHRcdFx0VC5zZXRUeXAocHJldiwnRlVOQ19FWElTVCcpIGlmIFQudHlwKHByZXYpID09ICc/J1xuXHRcdFx0aSArPSAyXG5cdFx0XHQjIG5lZWQgdG8gcmVzZXQgYWZ0ZXIgYSBtYXRjaFxuXHRcdFx0ZW5kQ2FsbEF0VGVybWluYXRvciA9IG5vXG5cdFx0XHRub0NhbGwgPSBub1xuXHRcdFx0c2VlbkZvciA9IG5vXG5cblxuXHRcdHJldHVyblxuXG5cdCMgQmVjYXVzZSBvdXIgZ3JhbW1hciBpcyBMQUxSKDEpLCBpdCBjYW4ndCBoYW5kbGUgc29tZSBzaW5nbGUtbGluZVxuXHQjIGV4cHJlc3Npb25zIHRoYXQgbGFjayBlbmRpbmcgZGVsaW1pdGVycy4gVGhlICoqUmV3cml0ZXIqKiBhZGRzIHRoZSBpbXBsaWNpdFxuXHQjIGJsb2Nrcywgc28gaXQgZG9lc24ndCBuZWVkIHRvLiAnKScgY2FuIGNsb3NlIGEgc2luZ2xlLWxpbmUgYmxvY2ssXG5cdCMgYnV0IHdlIG5lZWQgdG8gbWFrZSBzdXJlIGl0J3MgYmFsYW5jZWQuXG5cdGRlZiBhZGRJbXBsaWNpdEluZGVudGF0aW9uXG5cblx0XHRcblx0XHR2YXIgaSA9IDBcblx0XHR2YXIgdG9rZW5zID0gQHRva2Vuc1xuXHRcdHdoaWxlIHZhciB0b2tlbiA9IHRva2Vuc1tpXVxuXHRcdFx0dmFyIHR5cGUgPSBULnR5cCh0b2tlbilcblx0XHRcdHZhciBuZXh0ID0gdG9rZW5UeXBlKGkgKyAxKVxuXG5cdFx0XHQjIHdoeSBhcmUgd2UgcmVtb3ZpbmcgdGVybWluYXRvcnMgYWZ0ZXIgdGhlbj8gc2hvdWxkIGJlIGFibGUgdG8gaGFuZGxlXG5cdFx0XHRpZiB0eXBlID09ICdURVJNSU5BVE9SJyBhbmQgbmV4dCA9PSAnVEhFTidcblx0XHRcdFx0dG9rZW5zLnNwbGljZShpLCAxKVxuXHRcdFx0XHRjb250aW51ZVxuXG5cdFx0XHRpZiB0eXBlIGlzICdDQVRDSCcgYW5kIHRva2VuVHlwZShpICsgMikgaW4gWydPVVRERU5UJywgJ1RFUk1JTkFUT1InLCAnRklOQUxMWSddXG5cdFx0XHRcdHRva2Vucy5zcGxpY2UgaSArIDIsIDAsICppbmRlbnRhdGlvbih0b2tlbilcblx0XHRcdFx0Y29udGludWUgaSArPSA0XG5cblx0XHRcdGlmIFNJTkdMRV9MSU5FUlMuaW5kZXhPZih0eXBlKSA+PSAwIGFuZCAobmV4dCAhPSAnSU5ERU5UJyBhbmQgbmV4dCAhPSAnQkxPQ0tfUEFSQU1fU1RBUlQnKSBhbmQgbm90ICh0eXBlID09ICdFTFNFJyBhbmQgbmV4dCA9PSAnSUYnKSBhbmQgdHlwZSAhPSAnRUxJRidcblxuXHRcdFx0XHR2YXIgc3RhcnRlciA9IHR5cGVcblxuXHRcdFx0XHR2YXIgaW5kZW50ID0gVC50b2tlbignSU5ERU5UJywgJzInKVxuXHRcdFx0XHR2YXIgb3V0ZGVudCA9IFQuT1VUREVOVFxuXHRcdFx0XHQjIHZhciBpbmRlbnQsIG91dGRlbnQgPSBpbmRlbnRhdGlvbih0b2tlbilcblx0XHRcdFx0aW5kZW50OmZyb21UaGVuICAgPSB0cnVlIGlmIHN0YXJ0ZXIgaXMgJ1RIRU4nICMgc2V0dGluZyBzcGVjaWFsIHZhbHVlcyBmb3IgdGhlc2UgLS0gY2Fubm90IHJlYWxseSByZXVzZT9cblx0XHRcdFx0aW5kZW50OmdlbmVyYXRlZCAgPSB0cnVlXG5cdFx0XHRcdCMgb3V0ZGVudDpnZW5lcmF0ZWQgPSB0cnVlXG5cdFx0XHRcdHRva2Vucy5zcGxpY2UgaSArIDEsIDAsIGluZGVudFxuXG5cdFx0XHRcdHZhciBjb25kaXRpb24gPSBkbyB8dG9rZW4saXxcblx0XHRcdFx0XHR2YXIgdCA9IFQudHlwKHRva2VuKVxuXHRcdFx0XHRcdFQudmFsKHRva2VuKSAhPSAnOycgYW5kIFNJTkdMRV9DTE9TRVJTLmluZGV4T2YodCkgPj0gMCBhbmQgbm90ICh0ID09ICdFTFNFJyBhbmQgc3RhcnRlciAhPSAnSUYnIGFuZCBzdGFydGVyICE9ICdUSEVOJylcblxuXHRcdFx0XHR2YXIgYWN0aW9uID0gZG8gfHRva2VuLGl8XG5cdFx0XHRcdFx0dmFyIGlkeCA9IHRva2VuVHlwZShpIC0gMSkgaXMgJywnID8gaSAtIDEgOiBpXG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZSBpZHgsIDAsIG91dGRlbnRcblxuXHRcdFx0XHRkZXRlY3RFbmQoaSArIDIsIGNvbmRpdGlvbiwgYWN0aW9uKVxuXHRcdFx0XHR0b2tlbnMuc3BsaWNlIGksIDEgaWYgdHlwZSBpcyAnVEhFTidcblx0XHRcdFxuXHRcdFx0aSsrXG5cblx0XHRyZXR1cm5cblxuXHQjIFRhZyBwb3N0Zml4IGNvbmRpdGlvbmFscyBhcyBzdWNoLCBzbyB0aGF0IHdlIGNhbiBwYXJzZSB0aGVtIHdpdGggYVxuXHQjIGRpZmZlcmVudCBwcmVjZWRlbmNlLlxuXHRkZWYgdGFnUG9zdGZpeENvbmRpdGlvbmFsc1xuXHRcdHZhciBjb25kaXRpb24gPSBkbyB8dG9rZW4saXwgVC50eXAodG9rZW4pIGluIFsnVEVSTUlOQVRPUicsICdJTkRFTlQnXVxuXG5cdFx0c2NhblRva2VucyBkbyB8dG9rZW4sIGl8XG5cdFx0XHR2YXIgdHlwID0gVC50eXAodG9rZW4pXG5cdFx0XHRyZXR1cm4gMSB1bmxlc3MgdHlwID09ICdJRicgb3IgdHlwID09ICdGT1InXG5cdFx0XHR2YXIgb3JpZ2luYWwgPSB0b2tlblxuXHRcdFx0ZGV0ZWN0RW5kKGkgKyAxLCBjb25kaXRpb24pIGRvIHx0b2tlbixpfFxuXHRcdFx0XHRULnNldFR5cChvcmlnaW5hbCwgJ1BPU1RfJyArIFQudHlwKG9yaWdpbmFsKSkgaWYgVC50eXAodG9rZW4pICE9ICdJTkRFTlQnXG5cdFx0XHQxXG5cblx0IyBHZW5lcmF0ZSB0aGUgaW5kZW50YXRpb24gdG9rZW5zLCBiYXNlZCBvbiBhbm90aGVyIHRva2VuIG9uIHRoZSBzYW1lIGxpbmUuXG5cdGRlZiBpbmRlbnRhdGlvbiB0b2tlblxuXHRcdFtULnRva2VuKCdJTkRFTlQnLCAnMicpLCBULnRva2VuKCdPVVRERU5UJywgJzInKV1cblxuXHQjIExvb2sgdXAgYSB0eXBlIGJ5IHRva2VuIGluZGV4LlxuXHRkZWYgdHlwZSBpIFxuXHRcdCMgaWYgaSA8IDAgdGhlbiByZXR1cm4gbnVsbFxuXHRcdHZhciB0b2sgPSBAdG9rZW5zW2ldXG5cdFx0dG9rIGFuZCBULnR5cCh0b2spXG5cdFx0IyBpZiB0b2sgdGhlbiB0b2tbMF0gZWxzZSBudWxsXG5cblx0ZGVmIHRva2VuVHlwZSBpIFxuXHRcdHZhciB0b2sgPSBAdG9rZW5zW2ldXG5cdFx0dG9rIGFuZCBULnR5cCh0b2spXG5cdFx0IyByZXR1cm4gdG9rIGFuZCB0b2tbMF1cblxuIyBDb25zdGFudHNcbiMgLS0tLS0tLS0tXG5cbiMgTGlzdCBvZiB0aGUgdG9rZW4gcGFpcnMgdGhhdCBtdXN0IGJlIGJhbGFuY2VkLlxudmFyIEJBTEFOQ0VEX1BBSVJTID0gW1xuXHRbJygnLCAnKSddXG5cdFsnWycsICddJ11cblx0Wyd7JywgJ30nXVxuXHRbJ3t7JywgJ319J11cblx0WydJTkRFTlQnLCAnT1VUREVOVCddLFxuXHRbJ0NBTExfU1RBUlQnLCAnQ0FMTF9FTkQnXVxuXHRbJ1BBUkFNX1NUQVJUJywgJ1BBUkFNX0VORCddXG5cdFsnSU5ERVhfU1RBUlQnLCAnSU5ERVhfRU5EJ11cblx0WydUQUdfU1RBUlQnLCdUQUdfRU5EJ11cblx0WydUQUdfUEFSQU1fU1RBUlQnLCdUQUdfUEFSQU1fRU5EJ11cblx0WydUQUdfQVRUUlNfU1RBUlQnLCdUQUdfQVRUUlNfRU5EJ11cblx0WydCTE9DS19QQVJBTV9TVEFSVCcsJ0JMT0NLX1BBUkFNX0VORCddXG5dXG5cbiMgVGhlIGludmVyc2UgbWFwcGluZ3Mgb2YgYEJBTEFOQ0VEX1BBSVJTYCB3ZSdyZSB0cnlpbmcgdG8gZml4IHVwLCBzbyB3ZSBjYW5cbiMgbG9vayB0aGluZ3MgdXAgZnJvbSBlaXRoZXIgZW5kLlxuZXhwb3J0IHZhciBJTlZFUlNFUyA9IHt9XG5cbiMgVGhlIHRva2VucyB0aGF0IHNpZ25hbCB0aGUgc3RhcnQvZW5kIG9mIGEgYmFsYW5jZWQgcGFpci5cbiMgdmFyIEVYUFJFU1NJT05fU1RBUlQgPSBbXVxuIyB2YXIgRVhQUkVTU0lPTl9FTkQgICA9IFtdXG5cbmZvciBwYWlyIGluIEJBTEFOQ0VEX1BBSVJTXG5cdHZhciBsZWZ0ID0gcGFpclswXVxuXHR2YXIgcml0ZSA9IHBhaXJbMV1cblx0SU5WRVJTRVNbcml0ZV0gPSBsZWZ0XG5cdElOVkVSU0VTW2xlZnRdID0gcml0ZVxuXG52YXIgRVhQUkVTU0lPTl9TVEFSVCA9IFsnKCcsJ1snLCd7JywnSU5ERU5UJywnQ0FMTF9TVEFSVCcsJ1BBUkFNX1NUQVJUJywnSU5ERVhfU1RBUlQnLCdUQUdfUEFSQU1fU1RBUlQnLCdCTE9DS19QQVJBTV9TVEFSVCcsJ1NUUklOR19TVEFSVCcsJ3t7JywgJ1RBR19TVEFSVCddXG52YXIgRVhQUkVTU0lPTl9FTkQgPSBbJyknLCddJywnfScsJ09VVERFTlQnLCdDQUxMX0VORCcsJ1BBUkFNX0VORCcsJ0lOREVYX0VORCcsJ1RBR19QQVJBTV9FTkQnLCdCTE9DS19QQVJBTV9FTkQnLCdTVFJJTkdfRU5EJywnfX0nLCAnVEFHX0VORCddXG5cbnZhciBJREVOVElGSUVSUyA9IFsnSURFTlRJRklFUicsICdHVkFSJywgJ0lWQVInLCAnQ1ZBUicsICdDT05TVCcsICdBUkdWQVInXVxuXG4jIFRva2VucyB0aGF0IGluZGljYXRlIHRoZSBjbG9zZSBvZiBhIGNsYXVzZSBvZiBhbiBleHByZXNzaW9uLlxudmFyIEVYUFJFU1NJT05fQ0xPU0UgPSBbJ0NBVENIJywgJ1dIRU4nLCAnRUxTRScsICdGSU5BTExZJ10uY29uY2F0IEVYUFJFU1NJT05fRU5EXG5cbiMgVG9rZW5zIHRoYXQsIGlmIGZvbGxvd2VkIGJ5IGFuIGBJTVBMSUNJVF9DQUxMYCwgaW5kaWNhdGUgYSBmdW5jdGlvbiBpbnZvY2F0aW9uLlxudmFyIElNUExJQ0lUX0ZVTkMgICAgPSBbJ0lERU5USUZJRVInLCAnU1VQRVInLCAjICcpJywgJ0lOREVYX0VORCcsICMgICdDQUxMX0VORCcsXG5cdCdAJywgJ1RISVMnLCdTRUxGJywgJ0VWRU5UJywnVFJJR0dFUicsJ1RBR19FTkQnLCAnSVZBUicsIFxuXHQnR1ZBUicsICdDT05TVCcsICdBUkdWQVInLCAnTkVXJywgJ0JSRUFLJywgJ0NPTlRJTlVFJywnUkVUVVJOJ1xuXVxuXG4jIElmIHByZWNlZGVkIGJ5IGFuIGBJTVBMSUNJVF9GVU5DYCwgaW5kaWNhdGVzIGEgZnVuY3Rpb24gaW52b2NhdGlvbi5cbnZhciBJTVBMSUNJVF9DQUxMICAgID0gW1xuXHQnU0VMRUNUT1InLCdJREVOVElGSUVSJywgJ05VTUJFUicsICdTVFJJTkcnLCAnU1lNQk9MJywgJ0pTJywgJ1JFR0VYJywgJ05FVycsICdQQVJBTV9TVEFSVCcsICdDTEFTUydcblx0J0lGJywgJ1VOTEVTUycsICdUUlknLCAnU1dJVENIJywgJ1RISVMnLCAnQk9PTCcsICdUUlVFJywnRkFMU0UnLCAnTlVMTCcsICdVTkRFRklORUQnLCAnVU5BUlknLCAnU1VQRVInLCAnSVZBUicsICdHVkFSJywgJ0NPTlNUJywgJ0FSR1ZBUicsJ1NFTEYnLCBcblx0J0AnLCAnWycsICcoJywgJ3snLCAnLS0nLCAnKysnLCdTRUxFQ1RPUicsICdUQUdfU1RBUlQnLCAnVEFHSUQnLCAnIycsICdTRUxFQ1RPUl9TVEFSVCcsICdJRFJFRicsICdTUExBVCcsICdETycsICdCTE9DS19BUkcnXG5cdCdGT1InLCAnU1RSSU5HX1NUQVJUJywnQ09OVElOVUUnLCdCUkVBSydcbl0gIyAnLT4nLCAnPT4nLCB3aHkgZG9lcyBpdCBub3Qgd29yayB3aXRoIHN5bWJvbD9cblxudmFyIElNUExJQ0lUX0lOREVOVF9DQUxMID0gW1xuXHQnRk9SJ1xuXVxuIyBpcyBub3QgZG8gYW4gaW1wbGljaXQgY2FsbD8/XG5cbnZhciBJTVBMSUNJVF9VTlNQQUNFRF9DQUxMID0gWycrJywgJy0nXVxuXG4jIFRva2VucyBpbmRpY2F0aW5nIHRoYXQgdGhlIGltcGxpY2l0IGNhbGwgbXVzdCBlbmNsb3NlIGEgYmxvY2sgb2YgZXhwcmVzc2lvbnMuXG52YXIgSU1QTElDSVRfQkxPQ0sgICA9IFsneycsICdbJywgJywnLCdCTE9DS19QQVJBTV9FTkQnLCAnRE8nXSAjICctPicsICc9PicsIFxuXG52YXIgQ09ORElUSU9OQUxfQVNTSUdOID0gWyd8fD0nLCAnJiY9JywgJz89JywgJyY9JywgJ3w9J11cbnZhciBDT01QT1VORF9BU1NJR04gPSBbJy09JywgJys9JywgJy89JywgJyo9JywgJyU9JywgJ3x8PScsICcmJj0nLCAnPz0nLCAnPDw9JywgJz4+PScsICc+Pj49JywgJyY9JywgJ149JywgJ3w9J11cbnZhciBVTkFSWSA9IFsnIScsICd+JywgJ05FVycsICdUWVBFT0YnLCAnREVMRVRFJ11cbnZhciBMT0dJQyAgID0gWycmJicsICd8fCcsICcmJywgJ3wnLCAnXiddXG5cbiMgb3B0aW1pemUgZm9yIGZpeGVkIGFycmF5c1xudmFyIE5PX0lNUExJQ0lUX0JMT0NLX0NBTEwgPSBbXG5cdCdDQUxMX0VORCcsJz0nLCdERUZfQk9EWScsJygnLCdDQUxMX1NUQVJUJywnLCcsJzonLCdSRVRVUk4nXG5cdCctPScsICcrPScsICcvPScsICcqPScsICclPScsICd8fD0nLCAnJiY9JywgJz89JywgJzw8PScsICc+Pj0nLCAnPj4+PScsICcmPScsICdePScsICd8PSdcbl0gIyAuY29uY2F0KENPTVBPVU5EX0FTU0lHTilcblxuXG4jIGNvbnNvbGUubG9nIE5PX0lNUExJQ0lUX0JMT0NLX0NBTEw6bGVuZ3RoXG4jIE5PX0lNUExJQ0lUX0JMT0NLX0NBTExcbiMgSU1QTElDSVRfQ09NTUEgPSBbJy0+JywgJz0+JywgJ3snLCAnWycsICdOVU1CRVInLCAnU1RSSU5HJywgJ1NZTUJPTCcsICdJREVOVElGSUVSJywnRE8nXVxuXG52YXIgSU1QTElDSVRfQ09NTUEgPSBbJ0RPJ11cblxuIyBUb2tlbnMgdGhhdCBhbHdheXMgbWFyayB0aGUgZW5kIG9mIGFuIGltcGxpY2l0IGNhbGwgZm9yIHNpbmdsZS1saW5lcnMuXG52YXIgSU1QTElDSVRfRU5EICAgICA9IFsnUE9TVF9JRicsICdQT1NUX1VOTEVTUycsICdQT1NUX0ZPUicsICdXSElMRScsICdVTlRJTCcsICdXSEVOJywgJ0JZJywgJ0xPT1AnLCAnVEVSTUlOQVRPUicsJ0RFRl9CT0RZJywnREVGX0ZSQUdNRU5UJ11cblxuIyBTaW5nbGUtbGluZSBmbGF2b3JzIG9mIGJsb2NrIGV4cHJlc3Npb25zIHRoYXQgaGF2ZSB1bmNsb3NlZCBlbmRpbmdzLlxuIyBUaGUgZ3JhbW1hciBjYW4ndCBkaXNhbWJpZ3VhdGUgdGhlbSwgc28gd2UgaW5zZXJ0IHRoZSBpbXBsaWNpdCBpbmRlbnRhdGlvbi5cbnZhciBTSU5HTEVfTElORVJTICAgID0gWydFTFNFJywgJ1RSWScsICdGSU5BTExZJywgJ1RIRU4nLCdCTE9DS19QQVJBTV9FTkQnLCdETycsJ0JFR0lOJywnQ0FUQ0hfVkFSJ10gIyAnLT4nLCAnPT4nLCByZWFsbHk/XG52YXIgU0lOR0xFX0NMT1NFUlMgICA9IFsnVEVSTUlOQVRPUicsICdDQVRDSCcsICdGSU5BTExZJywgJ0VMU0UnLCAnT1VUREVOVCcsICdMRUFESU5HX1dIRU4nXVxuXG4jIFRva2VucyB0aGF0IGVuZCBhIGxpbmUuXG52YXIgTElORUJSRUFLUyAgICAgICA9IFsnVEVSTUlOQVRPUicsICdJTkRFTlQnLCAnT1VUREVOVCddXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBzcmMvY29tcGlsZXIvcmV3cml0ZXIuaW1iYVxuICoqLyIsIi8qIHBhcnNlciBnZW5lcmF0ZWQgYnkgamlzb24tZm9yayAqL1xudmFyIHBhcnNlciA9IChmdW5jdGlvbigpe1xudmFyIG89ZnVuY3Rpb24oayx2LG8sbCl7Zm9yKG89b3x8e30sbD1rLmxlbmd0aDtsLS07b1trW2xdXT12KTtyZXR1cm4gb30sJFYwPVsxLDRdLCRWMT1bMSw2XSwkVjI9WzEsMzJdLCRWMz1bMSwzM10sJFY0PVsxLDM0XSwkVjU9WzEsMzVdLCRWNj1bMSw3NV0sJFY3PVsxLDExNV0sJFY4PVsxLDEyOF0sJFY5PVsxLDEyMV0sJFZhPVsxLDEyMl0sJFZiPVsxLDEyM10sJFZjPVsxLDEyMF0sJFZkPVsxLDEyNF0sJFZlPVsxLDEzMV0sJFZmPVsxLDExNF0sJFZnPVsxLDEzMl0sJFZoPVsxLDgwXSwkVmk9WzEsODFdLCRWaj1bMSw4Ml0sJFZrPVsxLDgzXSwkVmw9WzEsODRdLCRWbT1bMSw4NV0sJFZuPVsxLDg2XSwkVm89WzEsNzNdLCRWcD1bMSwxMThdLCRWcT1bMSw5NV0sJFZyPVsxLDkxXSwkVnM9WzEsODhdLCRWdD1bMSw3MV0sJFZ1PVsxLDY1XSwkVnY9WzEsNjZdLCRWdz1bMSwxMTFdLCRWeD1bMSw5MF0sJFZ5PVsxLDg3XSwkVno9WzEsMjhdLCRWQT1bMSwyOV0sJFZCPVsxLDk2XSwkVkM9WzEsOTRdLCRWRD1bMSwxMTJdLCRWRT1bMSwxMTNdLCRWRj1bMSwxMjZdLCRWRz1bMSw2N10sJFZIPVsxLDY4XSwkVkk9WzEsMTE5XSwkVko9WzEsMTFdLCRWSz1bMSwxMjddLCRWTD1bMSw3OF0sJFZNPVsxLDM3XSwkVk49WzEsNDNdLCRWTz1bMSwxMTBdLCRWUD1bMSw2OV0sJFZRPVsxLDg5XSwkVlI9WzEsMTI1XSwkVlM9WzEsNTldLCRWVD1bMSw3NF0sJFZVPVsxLDEwNV0sJFZWPVsxLDEwNl0sJFZXPVsxLDEwN10sJFZYPVsxLDEyOV0sJFZZPVsxLDEzMF0sJFZaPVsxLDYzXSwkVl89WzEsMTA0XSwkViQ9WzEsNTFdLCRWMDE9WzEsNTJdLCRWMTE9WzEsNTNdLCRWMjE9WzEsNTRdLCRWMzE9WzEsNTVdLCRWNDE9WzEsNTZdLCRWNTE9WzEsMTM0XSwkVjYxPVsxLDYsMTEsMTM3XSwkVjcxPVsxLDEzNl0sJFY4MT1bMSw2LDExLDE0LDEzN10sJFY5MT1bMSwxNDRdLCRWYTE9WzEsMTQ1XSwkVmIxPVsxLDE0N10sJFZjMT1bMSwxNDhdLCRWZDE9WzEsMTQxXSwkVmUxPVsxLDE0MF0sJFZmMT1bMSwxNDJdLCRWZzE9WzEsMTQzXSwkVmgxPVsxLDE0Nl0sJFZpMT1bMSwxNTFdLCRWajE9WzEsNiwxMCwxMSwxNCwyMiw3MSw5MCw5NywxMDYsMTEyLDEyNiwxMzUsMTM3LDE0NywxNzEsMjAwLDIwMSwyMTIsMjEzLDIxNCwyMTksMjIwLDIyOSwyMzgsMjM5LDI0MiwyNDMsMjQ2LDI0NywyNDhdLCRWazE9WzIsMjYzXSwkVmwxPVsxLDE1OF0sJFZtMT1bMSwxNjRdLCRWbjE9WzEsMTYyXSwkVm8xPVsxLDE2MF0sJFZwMT1bMSwxNjFdLCRWcTE9WzEsMTY1XSwkVnIxPVsxLDE2M10sJFZzMT1bMSw2LDEwLDExLDE0LDIyLDkwLDk3LDEzN10sJFZ0MT1bMSw2LDExLDE0LDEzNywyMTIsMjE0LDIxOSwyMjAsMjM4XSwkVnUxPVsxLDYsMTAsMTEsMTQsMjEsMjIsNzEsODgsODksOTAsOTcsMTA2LDExMSwxMTIsMTI2LDEzNSwxMzcsMTQ0LDE0NywxNzEsMTgwLDE4MSwxODMsMTk2LDIwMCwyMDEsMjEyLDIxMywyMTQsMjE5LDIyMCwyMjksMjM4LDIzOSwyNDIsMjQzLDI0NiwyNDcsMjQ4XSwkVnYxPVsyLDIzMV0sJFZ3MT1bMSwxNzhdLCRWeDE9WzEsMTc2XSwkVnkxPVsxLDYsMTAsMTEsMTQsMjEsMjIsNzEsODgsODksOTAsOTcsMTA2LDExMSwxMTIsMTE3LDEyNiwxMzUsMTM3LDE0NCwxNDcsMTcxLDE4MCwxODEsMTgzLDE5NiwyMDAsMjAxLDIxMiwyMTMsMjE0LDIxOSwyMjAsMjI5LDIzOCwyMzksMjQyLDI0MywyNDYsMjQ3LDI0OF0sJFZ6MT1bMiwyMjddLCRWQTE9WzYsMTQsNTMsNTQsODgsOTEsMTA2LDExMSwxMTMsMTE2XSwkVkIxPVsxLDIxMl0sJFZDMT1bMSwyMTddLCRWRDE9WzEsNiwxMCwxMSwxNCwyMSwyMiw3MSw4OCw4OSw5MCw5NywxMDYsMTExLDExMiwxMTcsMTI2LDEzNSwxMzcsMTQ0LDE0NywxNzEsMTgwLDE4MSwxODMsMTk2LDIwMCwyMDEsMjEyLDIxMywyMTQsMjE5LDIyMCwyMjksMjM4LDIzOSwyNDIsMjQzLDI0NCwyNDUsMjQ2LDI0NywyNDgsMjQ5XSwkVkUxPVsxLDIyN10sJFZGMT1bMSwyMjRdLCRWRzE9WzEsMjI5XSwkVkgxPVs2LDEwLDE0LDkwXSwkVkkxPVsyLDI0NF0sJFZKMT1bMSwyNTddLCRWSzE9WzEsMjQ3XSwkVkwxPVsxLDI3Nl0sJFZNMT1bMSwyNzddLCRWTjE9WzUxLDg5XSwkVk8xPVs4NSw4Niw4Nyw4OCw5MSw5Miw5Myw5NCw5NSw5NiwxMDAsMTAyXSwkVlAxPVsxLDI4OV0sJFZRMT1bMSw2LDEwLDExLDE0LDIxLDIyLDUzLDU0LDcxLDg4LDg5LDkwLDkxLDk3LDEwNiwxMTEsMTEyLDExMywxMTYsMTE3LDEyNiwxMzUsMTM3LDE0NCwxNDcsMTcxLDE4MCwxODEsMTgzLDE5NiwyMDAsMjAxLDIxMiwyMTMsMjE0LDIxOSwyMjAsMjI5LDIzOCwyMzksMjQyLDI0MywyNDQsMjQ1LDI0NiwyNDcsMjQ4LDI0OV0sJFZSMT1bMSwyOTVdLCRWUzE9WzUxLDg5LDk2LDIyNV0sJFZUMT1bMSw2LDEwLDExLDE0LDIxLDIyLDY3LDY5LDcwLDcxLDg4LDg5LDkwLDk3LDEwNiwxMTEsMTEyLDEyNiwxMzUsMTM3LDE0NCwxNDcsMTcxLDE4MCwxODEsMTgzLDE5NiwyMDAsMjAxLDIxMiwyMTMsMjE0LDIxOSwyMjAsMjI5LDIzOCwyMzksMjQyLDI0MywyNDYsMjQ3LDI0OF0sJFZVMT1bMSw2LDEwLDExLDE0LDIxLDIyLDcxLDg4LDg5LDkwLDk3LDEwNiwxMTEsMTEyLDEyNiwxMzUsMTM3LDE0NCwxNDcsMTcxLDE4MCwxODEsMTgzLDE5NiwyMDAsMjAxLDIwNywyMDgsMjEyLDIxMywyMTQsMjE5LDIyMCwyMjksMjMyLDIzNCwyMzcsMjM4LDIzOSwyNDIsMjQzLDI0NiwyNDcsMjQ4XSwkVlYxPVs1MSw1Myw1NCw1OF0sJFZXMT1bMSwzMjZdLCRWWDE9WzEsMzI3XSwkVlkxPVsxLDYsMTAsMTEsMTQsMjIsNzEsOTAsOTcsMTA2LDExMiwxMzUsMTM3LDE0NywyMDAsMjAxLDIxMiwyMTMsMjE0LDIxOSwyMjAsMjI5LDIzOF0sJFZaMT1bMSwzNDBdLCRWXzE9WzEsMzQ0XSwkViQxPVsxLDYsMTEsMTQsMjIsNzEsOTAsOTcsMTA2LDExMiwxMjYsMTM1LDEzNywxNDcsMTcxLDIwMCwyMDEsMjEyLDIxMywyMTQsMjE5LDIyMCwyMjksMjM4LDIzOSwyNDIsMjQzLDI0NiwyNDcsMjQ4XSwkVjAyPVs2LDE0LDEwNl0sJFYxMj1bMSwzNTRdLCRWMjI9WzEsNiwxMCwxMSwxNCwyMSwyMiw3MSw4OSw5MCw5NywxMDYsMTEyLDEyNiwxMzUsMTM3LDE0NywxNzEsMjAwLDIwMSwyMTIsMjEzLDIxNCwyMTksMjIwLDIyOSwyMzgsMjM5LDI0MiwyNDMsMjQ2LDI0NywyNDhdLCRWMzI9WzE0LDI4XSwkVjQyPVsxLDYsMTEsMTQsMjgsMTM3LDIxMiwyMTQsMjE5LDIyMCwyMzhdLCRWNTI9WzIsMjg0XSwkVjYyPVsxLDYsMTAsMTEsMTQsMjEsMjIsNzEsODgsODksOTAsOTcsMTA2LDExMSwxMTIsMTE3LDEyNiwxMzUsMTM3LDE0NCwxNDcsMTcxLDE4MCwxODEsMTgzLDE5NiwyMDAsMjAxLDIxMiwyMTMsMjE0LDIxOSwyMjAsMjI3LDIyOCwyMjksMjM4LDIzOSwyNDIsMjQzLDI0NCwyNDUsMjQ2LDI0NywyNDgsMjQ5XSwkVjcyPVsyLDE4NF0sJFY4Mj1bMSwzNjldLCRWOTI9WzYsMTAsMTEsMTQsMjIsOTddLCRWYTI9WzE0LDE0N10sJFZiMj1bMiwxODZdLCRWYzI9WzEsMzc5XSwkVmQyPVsxLDM4MF0sJFZlMj1bMSwzODFdLCRWZjI9WzEsMzg1XSwkVmcyPVs2LDEwLDExLDE0LDkwXSwkVmgyPVs2LDEwLDExLDE0LDkwLDEzNV0sJFZpMj1bMSw2LDEwLDExLDE0LDIyLDcxLDkwLDk3LDEwNiwxMTIsMTM1LDEzNywxNDcsMjAwLDIwMSwyMjAsMjI5LDIzOF0sJFZqMj1bMSw2LDEwLDExLDE0LDIyLDcxLDkwLDk3LDEwNiwxMTIsMTM1LDEzNywxNDcsMjAwLDIwMSwyMTMsMjIwLDIyOSwyMzhdLCRWazI9WzIyNywyMjhdLCRWbDI9WzE0LDIyNywyMjhdLCRWbTI9WzEsNiwxMSwxNCwyMiw3MSw5MCw5NywxMDYsMTEyLDEzNSwxMzcsMTQ3LDE3MSwyMDAsMjAxLDIxMiwyMTMsMjE0LDIxOSwyMjAsMjI5LDIzOCwyMzksMjQyLDI0MywyNDYsMjQ3LDI0OF0sJFZuMj1bODgsOTFdLCRWbzI9WzEsNDA2XSwkVnAyPVsxLDQwN10sJFZxMj1bMjEsODgsOTEsMTY0LDE2NV0sJFZyMj1bMSw2LDEwLDExLDE0LDIyLDcxLDkwLDk3LDEwNiwxMTIsMTI2LDEzNSwxMzcsMTQ3LDE3MSwyMDAsMjAxLDIxMiwyMTMsMjE0LDIxOSwyMjAsMjI5LDIzOCwyMzksMjQyLDI0MywyNDcsMjQ4XSwkVnMyPVsxLDYsMTAsMTEsMTQsMjIsNzEsOTAsOTcsMTA2LDExMiwxMzUsMTM3LDE0NywyMDAsMjAxLDIxMywyMjldLCRWdDI9WzE5LDIwLDIzLDI0LDI2LDMyLDUxLDUzLDU0LDU2LDU4LDYwLDYyLDY0LDY2LDczLDc0LDc1LDc2LDc3LDc4LDc5LDgwLDgzLDg5LDkxLDk2LDEwMywxMTIsMTIyLDEyMywxMjQsMTMwLDEzNiwxNDMsMTQ0LDE1MSwxNTIsMTU0LDE1NiwxNTcsMTU4LDE3NSwxODQsMTg1LDE4OCwxOTMsMTk0LDE5NywxOTgsMjA0LDIxMCwyMTIsMjE0LDIxNiwyMTksMjIwLDIzMCwyMzYsMjQwLDI0MSwyNDIsMjQzLDI0NCwyNDVdLCRWdTI9WzEsNiwxMCwxMSwxNCwyMiw3MSw5MCw5NywxMDYsMTEyLDEyNiwxMzUsMTM3LDE0NywxNzEsMjAwLDIwMSwyMTIsMjEzLDIxNCwyMTksMjIwLDIyOSwyMzIsMjM3LDIzOCwyMzksMjQyLDI0MywyNDYsMjQ3LDI0OF0sJFZ2Mj1bMTEsMjMyLDIzNF0sJFZ3Mj1bMSw0NTNdLCRWeDI9WzIsMTg1XSwkVnkyPVs2LDEwLDExXSwkVnoyPVsxLDQ2MV0sJFZBMj1bMTQsMjIsMTQ3XSwkVkIyPVsxLDQ2OV0sJFZDMj1bMSw2LDEwLDExLDE0LDIyLDcxLDkwLDk3LDEwNiwxMTIsMTM1LDEzNywxNDcsMjAwLDIwMSwyMTIsMjE0LDIxOSwyMjAsMjI5LDIzOF0sJFZEMj1bNTEsNTgsODldLCRWRTI9WzE0LDIyXSwkVkYyPVsxLDQ5Ml0sJFZHMj1bMTAsMTRdLCRWSDI9WzEsNTQyXSwkVkkyPVs2LDEwXTtcbnZhciBwYXJzZXIgPSB7dHJhY2U6IGZ1bmN0aW9uIHRyYWNlKCkgeyB9LFxueXk6IHt9LFxuc3ltYm9sc186IHtcImVycm9yXCI6MixcIlJvb3RcIjozLFwiQm9keVwiOjQsXCJCbG9ja1wiOjUsXCJURVJNSU5BVE9SXCI6NixcIkJPRFlTVEFSVFwiOjcsXCJMaW5lXCI6OCxcIlRlcm1pbmF0b3JcIjo5LFwiSU5ERU5UXCI6MTAsXCJPVVRERU5UXCI6MTEsXCJTcGxhdFwiOjEyLFwiRXhwcmVzc2lvblwiOjEzLFwiLFwiOjE0LFwiQ29tbWVudFwiOjE1LFwiU3RhdGVtZW50XCI6MTYsXCJSZXR1cm5cIjoxNyxcIlRocm93XCI6MTgsXCJTVEFURU1FTlRcIjoxOSxcIkJSRUFLXCI6MjAsXCJDQUxMX1NUQVJUXCI6MjEsXCJDQUxMX0VORFwiOjIyLFwiQ09OVElOVUVcIjoyMyxcIkRFQlVHR0VSXCI6MjQsXCJJbXBvcnRTdGF0ZW1lbnRcIjoyNSxcIklNUE9SVFwiOjI2LFwiSW1wb3J0QXJnTGlzdFwiOjI3LFwiRlJPTVwiOjI4LFwiSW1wb3J0RnJvbVwiOjI5LFwiQVNcIjozMCxcIkltcG9ydEFyZ1wiOjMxLFwiU1RSSU5HXCI6MzIsXCJWYXJJZGVudGlmaWVyXCI6MzMsXCJBd2FpdFwiOjM0LFwiVmFsdWVcIjozNSxcIkNvZGVcIjozNixcIk9wZXJhdGlvblwiOjM3LFwiQXNzaWduXCI6MzgsXCJJZlwiOjM5LFwiVGVybmFyeVwiOjQwLFwiVHJ5XCI6NDEsXCJXaGlsZVwiOjQyLFwiRm9yXCI6NDMsXCJTd2l0Y2hcIjo0NCxcIkNsYXNzXCI6NDUsXCJNb2R1bGVcIjo0NixcIlRhZ0RlY2xhcmF0aW9uXCI6NDcsXCJUYWdcIjo0OCxcIlByb3BlcnR5XCI6NDksXCJJZGVudGlmaWVyXCI6NTAsXCJJREVOVElGSUVSXCI6NTEsXCJJdmFyXCI6NTIsXCJJVkFSXCI6NTMsXCJDVkFSXCI6NTQsXCJHdmFyXCI6NTUsXCJHVkFSXCI6NTYsXCJDb25zdFwiOjU3LFwiQ09OU1RcIjo1OCxcIkFyZ3ZhclwiOjU5LFwiQVJHVkFSXCI6NjAsXCJTeW1ib2xcIjo2MSxcIlNZTUJPTFwiOjYyLFwiQWxwaGFOdW1lcmljXCI6NjMsXCJOVU1CRVJcIjo2NCxcIkludGVycG9sYXRlZFN0cmluZ1wiOjY1LFwiU1RSSU5HX1NUQVJUXCI6NjYsXCJORU9TVFJJTkdcIjo2NyxcIkludGVycG9sYXRpb25cIjo2OCxcIlNUUklOR19FTkRcIjo2OSxcInt7XCI6NzAsXCJ9fVwiOjcxLFwiTGl0ZXJhbFwiOjcyLFwiSlNcIjo3MyxcIlJFR0VYXCI6NzQsXCJCT09MXCI6NzUsXCJUUlVFXCI6NzYsXCJGQUxTRVwiOjc3LFwiTlVMTFwiOjc4LFwiVU5ERUZJTkVEXCI6NzksXCJSRVRVUk5cIjo4MCxcIkFyZ3VtZW50c1wiOjgxLFwiVGFnU2VsZWN0b3JcIjo4MixcIlNFTEVDVE9SX1NUQVJUXCI6ODMsXCJUYWdTZWxlY3RvclR5cGVcIjo4NCxcIlNFTEVDVE9SX05TXCI6ODUsXCJTRUxFQ1RPUl9JRFwiOjg2LFwiU0VMRUNUT1JfQ0xBU1NcIjo4NyxcIi5cIjo4OCxcIntcIjo4OSxcIn1cIjo5MCxcIiNcIjo5MSxcIlNFTEVDVE9SX0NPTUJJTkFUT1JcIjo5MixcIlNFTEVDVE9SX1BTRVVET19DTEFTU1wiOjkzLFwiU0VMRUNUT1JfR1JPVVBcIjo5NCxcIlVOSVZFUlNBTF9TRUxFQ1RPUlwiOjk1LFwiW1wiOjk2LFwiXVwiOjk3LFwiU0VMRUNUT1JfQVRUUl9PUFwiOjk4LFwiVGFnU2VsZWN0b3JBdHRyVmFsdWVcIjo5OSxcIlNFTEVDVE9SX1RBR1wiOjEwMCxcIlNlbGVjdG9yXCI6MTAxLFwiU0VMRUNUT1JfRU5EXCI6MTAyLFwiVEFHX1NUQVJUXCI6MTAzLFwiVGFnT3B0aW9uc1wiOjEwNCxcIlRhZ0F0dHJpYnV0ZXNcIjoxMDUsXCJUQUdfRU5EXCI6MTA2LFwiVGFnQm9keVwiOjEwNyxcIlRhZ1R5cGVOYW1lXCI6MTA4LFwiU2VsZlwiOjEwOSxcIlRBR19UWVBFXCI6MTEwLFwiSU5ERVhfU1RBUlRcIjoxMTEsXCJJTkRFWF9FTkRcIjoxMTIsXCJAXCI6MTEzLFwiVGFnQXR0clwiOjExNCxcIk9wdENvbW1hXCI6MTE1LFwiVEFHX0FUVFJcIjoxMTYsXCI9XCI6MTE3LFwiVGFnQXR0clZhbHVlXCI6MTE4LFwiQXJnTGlzdFwiOjExOSxcIlRhZ1R5cGVEZWZcIjoxMjAsXCJUYWdEZWNsYXJhdGlvbkJsb2NrXCI6MTIxLFwiRVhURU5EXCI6MTIyLFwiTE9DQUxcIjoxMjMsXCJUQUdcIjoxMjQsXCJUYWdUeXBlXCI6MTI1LFwiQ09NUEFSRVwiOjEyNixcIlRhZ0RlY2xLZXl3b3Jkc1wiOjEyNyxcIlRBR19JRFwiOjEyOCxcIlRhZ0lkXCI6MTI5LFwiSURSRUZcIjoxMzAsXCJBc3NpZ25hYmxlXCI6MTMxLFwiT3V0ZGVudFwiOjEzMixcIkFzc2lnbk9ialwiOjEzMyxcIk9iakFzc2lnbmFibGVcIjoxMzQsXCI6XCI6MTM1LFwiKFwiOjEzNixcIilcIjoxMzcsXCJIRVJFQ09NTUVOVFwiOjEzOCxcIkNPTU1FTlRcIjoxMzksXCJNZXRob2RcIjoxNDAsXCJEb1wiOjE0MSxcIkJlZ2luXCI6MTQyLFwiQkVHSU5cIjoxNDMsXCJET1wiOjE0NCxcIkJMT0NLX1BBUkFNX1NUQVJUXCI6MTQ1LFwiUGFyYW1MaXN0XCI6MTQ2LFwiQkxPQ0tfUEFSQU1fRU5EXCI6MTQ3LFwiUHJvcFR5cGVcIjoxNDgsXCJQcm9wZXJ0eUlkZW50aWZpZXJcIjoxNDksXCJPYmplY3RcIjoxNTAsXCJQUk9QXCI6MTUxLFwiQVRUUlwiOjE1MixcIlR1cGxlQXNzaWduXCI6MTUzLFwiVkFSXCI6MTU0LFwiTWV0aG9kRGVjbGFyYXRpb25cIjoxNTUsXCJHTE9CQUxcIjoxNTYsXCJFWFBPUlRcIjoxNTcsXCJERUZcIjoxNTgsXCJNZXRob2RTY29wZVwiOjE1OSxcIk1ldGhvZFNjb3BlVHlwZVwiOjE2MCxcIk1ldGhvZElkZW50aWZpZXJcIjoxNjEsXCJNZXRob2RCb2R5XCI6MTYyLFwiTWV0aG9kUmVjZWl2ZXJcIjoxNjMsXCJERUZfQk9EWVwiOjE2NCxcIkRFRl9FTVBUWVwiOjE2NSxcIlRoaXNcIjoxNjYsXCJQYXJhbVwiOjE2NyxcIkFycmF5XCI6MTY4LFwiUGFyYW1WYXJcIjoxNjksXCJTUExBVFwiOjE3MCxcIkxPR0lDXCI6MTcxLFwiQkxPQ0tfQVJHXCI6MTcyLFwiVmFyUmVmZXJlbmNlXCI6MTczLFwiVmFyQXNzaWduYWJsZVwiOjE3NCxcIkxFVFwiOjE3NSxcIlNpbXBsZUFzc2lnbmFibGVcIjoxNzYsXCJORVdcIjoxNzcsXCJTdXBlclwiOjE3OCxcIlNvYWthYmxlT3BcIjoxNzksXCI/OlwiOjE4MCxcIi46XCI6MTgxLFwiSW5kZXhWYWx1ZVwiOjE4MixcIj8uXCI6MTgzLFwiU1VQRVJcIjoxODQsXCJBV0FJVFwiOjE4NSxcIlBhcmVudGhldGljYWxcIjoxODYsXCJSYW5nZVwiOjE4NyxcIkFSR1VNRU5UU1wiOjE4OCxcIkludm9jYXRpb25cIjoxODksXCJTbGljZVwiOjE5MCxcIkFzc2lnbkxpc3RcIjoxOTEsXCJDbGFzc1N0YXJ0XCI6MTkyLFwiQ0xBU1NcIjoxOTMsXCJNT0RVTEVcIjoxOTQsXCJPcHRGdW5jRXhpc3RcIjoxOTUsXCJGVU5DX0VYSVNUXCI6MTk2LFwiVEhJU1wiOjE5NyxcIlNFTEZcIjoxOTgsXCJSYW5nZURvdHNcIjoxOTksXCIuLlwiOjIwMCxcIi4uLlwiOjIwMSxcIkFyZ1wiOjIwMixcIlNpbXBsZUFyZ3NcIjoyMDMsXCJUUllcIjoyMDQsXCJDYXRjaFwiOjIwNSxcIkZpbmFsbHlcIjoyMDYsXCJGSU5BTExZXCI6MjA3LFwiQ0FUQ0hcIjoyMDgsXCJDQVRDSF9WQVJcIjoyMDksXCJUSFJPV1wiOjIxMCxcIldoaWxlU291cmNlXCI6MjExLFwiV0hJTEVcIjoyMTIsXCJXSEVOXCI6MjEzLFwiVU5USUxcIjoyMTQsXCJMb29wXCI6MjE1LFwiTE9PUFwiOjIxNixcIkZvckJvZHlcIjoyMTcsXCJGb3JLZXl3b3JkXCI6MjE4LFwiRk9SXCI6MjE5LFwiUE9TVF9GT1JcIjoyMjAsXCJGb3JCbG9ja1wiOjIyMSxcIkZvclN0YXJ0XCI6MjIyLFwiRm9yU291cmNlXCI6MjIzLFwiRm9yVmFyaWFibGVzXCI6MjI0LFwiT1dOXCI6MjI1LFwiRm9yVmFsdWVcIjoyMjYsXCJGT1JJTlwiOjIyNyxcIkZPUk9GXCI6MjI4LFwiQllcIjoyMjksXCJTV0lUQ0hcIjoyMzAsXCJXaGVuc1wiOjIzMSxcIkVMU0VcIjoyMzIsXCJXaGVuXCI6MjMzLFwiTEVBRElOR19XSEVOXCI6MjM0LFwiSWZCbG9ja1wiOjIzNSxcIklGXCI6MjM2LFwiRUxJRlwiOjIzNyxcIlBPU1RfSUZcIjoyMzgsXCI/XCI6MjM5LFwiVU5BUllcIjoyNDAsXCJTUVJUXCI6MjQxLFwiLVwiOjI0MixcIitcIjoyNDMsXCItLVwiOjI0NCxcIisrXCI6MjQ1LFwiTUFUSFwiOjI0NixcIlNISUZUXCI6MjQ3LFwiUkVMQVRJT05cIjoyNDgsXCJDT01QT1VORF9BU1NJR05cIjoyNDksXCIkYWNjZXB0XCI6MCxcIiRlbmRcIjoxfSxcbnRlcm1pbmFsc186IHsyOlwiZXJyb3JcIiw2OlwiVEVSTUlOQVRPUlwiLDc6XCJCT0RZU1RBUlRcIiwxMDpcIklOREVOVFwiLDExOlwiT1VUREVOVFwiLDE0OlwiLFwiLDE5OlwiU1RBVEVNRU5UXCIsMjA6XCJCUkVBS1wiLDIxOlwiQ0FMTF9TVEFSVFwiLDIyOlwiQ0FMTF9FTkRcIiwyMzpcIkNPTlRJTlVFXCIsMjQ6XCJERUJVR0dFUlwiLDI2OlwiSU1QT1JUXCIsMjg6XCJGUk9NXCIsMzA6XCJBU1wiLDMyOlwiU1RSSU5HXCIsNTE6XCJJREVOVElGSUVSXCIsNTM6XCJJVkFSXCIsNTQ6XCJDVkFSXCIsNTY6XCJHVkFSXCIsNTg6XCJDT05TVFwiLDYwOlwiQVJHVkFSXCIsNjI6XCJTWU1CT0xcIiw2NDpcIk5VTUJFUlwiLDY2OlwiU1RSSU5HX1NUQVJUXCIsNjc6XCJORU9TVFJJTkdcIiw2OTpcIlNUUklOR19FTkRcIiw3MDpcInt7XCIsNzE6XCJ9fVwiLDczOlwiSlNcIiw3NDpcIlJFR0VYXCIsNzU6XCJCT09MXCIsNzY6XCJUUlVFXCIsNzc6XCJGQUxTRVwiLDc4OlwiTlVMTFwiLDc5OlwiVU5ERUZJTkVEXCIsODA6XCJSRVRVUk5cIiw4MzpcIlNFTEVDVE9SX1NUQVJUXCIsODU6XCJTRUxFQ1RPUl9OU1wiLDg2OlwiU0VMRUNUT1JfSURcIiw4NzpcIlNFTEVDVE9SX0NMQVNTXCIsODg6XCIuXCIsODk6XCJ7XCIsOTA6XCJ9XCIsOTE6XCIjXCIsOTI6XCJTRUxFQ1RPUl9DT01CSU5BVE9SXCIsOTM6XCJTRUxFQ1RPUl9QU0VVRE9fQ0xBU1NcIiw5NDpcIlNFTEVDVE9SX0dST1VQXCIsOTU6XCJVTklWRVJTQUxfU0VMRUNUT1JcIiw5NjpcIltcIiw5NzpcIl1cIiw5ODpcIlNFTEVDVE9SX0FUVFJfT1BcIiwxMDA6XCJTRUxFQ1RPUl9UQUdcIiwxMDI6XCJTRUxFQ1RPUl9FTkRcIiwxMDM6XCJUQUdfU1RBUlRcIiwxMDY6XCJUQUdfRU5EXCIsMTEwOlwiVEFHX1RZUEVcIiwxMTE6XCJJTkRFWF9TVEFSVFwiLDExMjpcIklOREVYX0VORFwiLDExMzpcIkBcIiwxMTY6XCJUQUdfQVRUUlwiLDExNzpcIj1cIiwxMjI6XCJFWFRFTkRcIiwxMjM6XCJMT0NBTFwiLDEyNDpcIlRBR1wiLDEyNjpcIkNPTVBBUkVcIiwxMjg6XCJUQUdfSURcIiwxMzA6XCJJRFJFRlwiLDEzNTpcIjpcIiwxMzY6XCIoXCIsMTM3OlwiKVwiLDEzODpcIkhFUkVDT01NRU5UXCIsMTM5OlwiQ09NTUVOVFwiLDE0MzpcIkJFR0lOXCIsMTQ0OlwiRE9cIiwxNDU6XCJCTE9DS19QQVJBTV9TVEFSVFwiLDE0NzpcIkJMT0NLX1BBUkFNX0VORFwiLDE1MTpcIlBST1BcIiwxNTI6XCJBVFRSXCIsMTU0OlwiVkFSXCIsMTU2OlwiR0xPQkFMXCIsMTU3OlwiRVhQT1JUXCIsMTU4OlwiREVGXCIsMTY0OlwiREVGX0JPRFlcIiwxNjU6XCJERUZfRU1QVFlcIiwxNzA6XCJTUExBVFwiLDE3MTpcIkxPR0lDXCIsMTcyOlwiQkxPQ0tfQVJHXCIsMTc1OlwiTEVUXCIsMTc3OlwiTkVXXCIsMTgwOlwiPzpcIiwxODE6XCIuOlwiLDE4MzpcIj8uXCIsMTg0OlwiU1VQRVJcIiwxODU6XCJBV0FJVFwiLDE4ODpcIkFSR1VNRU5UU1wiLDE5MzpcIkNMQVNTXCIsMTk0OlwiTU9EVUxFXCIsMTk2OlwiRlVOQ19FWElTVFwiLDE5NzpcIlRISVNcIiwxOTg6XCJTRUxGXCIsMjAwOlwiLi5cIiwyMDE6XCIuLi5cIiwyMDQ6XCJUUllcIiwyMDc6XCJGSU5BTExZXCIsMjA4OlwiQ0FUQ0hcIiwyMDk6XCJDQVRDSF9WQVJcIiwyMTA6XCJUSFJPV1wiLDIxMjpcIldISUxFXCIsMjEzOlwiV0hFTlwiLDIxNDpcIlVOVElMXCIsMjE2OlwiTE9PUFwiLDIxOTpcIkZPUlwiLDIyMDpcIlBPU1RfRk9SXCIsMjI1OlwiT1dOXCIsMjI3OlwiRk9SSU5cIiwyMjg6XCJGT1JPRlwiLDIyOTpcIkJZXCIsMjMwOlwiU1dJVENIXCIsMjMyOlwiRUxTRVwiLDIzNDpcIkxFQURJTkdfV0hFTlwiLDIzNjpcIklGXCIsMjM3OlwiRUxJRlwiLDIzODpcIlBPU1RfSUZcIiwyMzk6XCI/XCIsMjQwOlwiVU5BUllcIiwyNDE6XCJTUVJUXCIsMjQyOlwiLVwiLDI0MzpcIitcIiwyNDQ6XCItLVwiLDI0NTpcIisrXCIsMjQ2OlwiTUFUSFwiLDI0NzpcIlNISUZUXCIsMjQ4OlwiUkVMQVRJT05cIiwyNDk6XCJDT01QT1VORF9BU1NJR05cIn0sXG5wcm9kdWN0aW9uc186IFswLFszLDBdLFszLDFdLFszLDJdLFs0LDFdLFs0LDFdLFs0LDNdLFs0LDJdLFs5LDFdLFs1LDJdLFs1LDNdLFs1LDRdLFs4LDFdLFs4LDFdLFs4LDNdLFs4LDNdLFs4LDFdLFs4LDFdLFsxNiwxXSxbMTYsMV0sWzE2LDFdLFsxNiwxXSxbMTYsNF0sWzE2LDFdLFsxNiw0XSxbMTYsMV0sWzE2LDFdLFsyNSw0XSxbMjUsNF0sWzI1LDJdLFsyOSwxXSxbMjcsMV0sWzI3LDNdLFszMSwxXSxbMTMsMV0sWzEzLDFdLFsxMywxXSxbMTMsMV0sWzEzLDFdLFsxMywxXSxbMTMsMV0sWzEzLDFdLFsxMywxXSxbMTMsMV0sWzEzLDFdLFsxMywxXSxbMTMsMV0sWzEzLDFdLFsxMywxXSxbMTMsMV0sWzUwLDFdLFs1MiwxXSxbNTIsMV0sWzU1LDFdLFs1NywxXSxbNTksMV0sWzYxLDFdLFs2MywxXSxbNjMsMV0sWzYzLDFdLFs2MywxXSxbNjUsMV0sWzY1LDJdLFs2NSwyXSxbNjUsMl0sWzY4LDJdLFs2OCwzXSxbNzIsMV0sWzcyLDFdLFs3MiwxXSxbNzIsMV0sWzcyLDFdLFs3MiwxXSxbNzIsMV0sWzcyLDFdLFsxNywyXSxbMTcsMl0sWzE3LDFdLFs4MiwxXSxbODIsMl0sWzgyLDJdLFs4MiwyXSxbODIsMl0sWzgyLDVdLFs4Miw1XSxbODIsMl0sWzgyLDJdLFs4MiwyXSxbODIsMl0sWzgyLDRdLFs4Miw2XSxbODQsMV0sWzEwMSwyXSxbOTksMV0sWzk5LDFdLFs5OSwzXSxbNDgsNF0sWzQ4LDVdLFs0OCw1XSxbMTA4LDFdLFsxMDgsMV0sWzEwOCwxXSxbMTA4LDBdLFsxMDQsMV0sWzEwNCwzXSxbMTA0LDRdLFsxMDQsM10sWzEwNCw1XSxbMTA0LDVdLFsxMDQsM10sWzEwNCwyXSxbMTA0LDVdLFsxMDUsMF0sWzEwNSwxXSxbMTA1LDNdLFsxMDUsNF0sWzExNCwxXSxbMTE0LDNdLFsxMTgsMV0sWzEwNywzXSxbMTA3LDNdLFsxMjAsMV0sWzEyMCwzXSxbNDcsMV0sWzQ3LDJdLFs0NywyXSxbMTIxLDJdLFsxMjEsM10sWzEyMSw0XSxbMTIxLDVdLFsxMjcsMF0sWzEyNywxXSxbMTI1LDFdLFsxMjUsMV0sWzEyOSwxXSxbMTI5LDJdLFszOCwzXSxbMzgsNV0sWzEzMywxXSxbMTMzLDNdLFsxMzMsNV0sWzEzMywxXSxbMTM0LDFdLFsxMzQsMV0sWzEzNCwxXSxbMTM0LDFdLFsxMzQsMV0sWzEzNCwzXSxbMTUsMV0sWzE1LDFdLFszNiwxXSxbMzYsMV0sWzM2LDFdLFsxNDIsMl0sWzE0MSwyXSxbMTQxLDVdLFsxNDEsNl0sWzQ5LDNdLFs0OSw1XSxbNDksMl0sWzE0OCwxXSxbMTQ4LDFdLFsxNDksMV0sWzE0OSwzXSxbMTUzLDRdLFsxNDAsMV0sWzE0MCwyXSxbMTQwLDJdLFsxNTUsOF0sWzE1NSw1XSxbMTU1LDZdLFsxNTUsM10sWzE2MCwxXSxbMTYwLDFdLFsxNjEsMV0sWzE2MSwxXSxbMTYxLDNdLFsxNjIsMl0sWzE2MiwyXSxbMTYyLDFdLFsxNTksMV0sWzE1OSwxXSxbMTU5LDFdLFsxNTksMV0sWzExNSwwXSxbMTE1LDFdLFsxNDYsMF0sWzE0NiwxXSxbMTQ2LDNdLFsxNjcsMV0sWzE2NywxXSxbMTY3LDFdLFsxNjcsMl0sWzE2NywyXSxbMTY3LDJdLFsxNjcsM10sWzE2OSwxXSxbMTIsMl0sWzE3MywzXSxbMTczLDJdLFsxNzMsMl0sWzE3MywzXSxbMTczLDJdLFszMywxXSxbMzMsMV0sWzE3NCwxXSxbMTc0LDFdLFsxNzQsMV0sWzE3NiwxXSxbMTc2LDFdLFsxNzYsMV0sWzE3NiwxXSxbMTc2LDFdLFsxNzYsMV0sWzE3NiwxXSxbMTc2LDNdLFsxNzYsM10sWzE3NiwzXSxbMTc2LDNdLFsxNzYsM10sWzE3NiwzXSxbMTc2LDNdLFsxNzYsM10sWzE3Niw0XSxbMTc5LDFdLFsxNzksMV0sWzE3OCwxXSxbMTMxLDFdLFsxMzEsMV0sWzEzMSwxXSxbMzQsMl0sWzM1LDFdLFszNSwxXSxbMzUsMV0sWzM1LDFdLFszNSwxXSxbMzUsMV0sWzM1LDFdLFszNSwxXSxbMzUsMV0sWzM1LDFdLFsxODIsMV0sWzE4MiwxXSxbMTUwLDRdLFsxOTEsMF0sWzE5MSwxXSxbMTkxLDNdLFsxOTEsNF0sWzE5MSw2XSxbNDUsMV0sWzQ1LDJdLFs0NSwyXSxbNDUsMl0sWzQ1LDJdLFs0NSwzXSxbMTkyLDJdLFsxOTIsM10sWzE5Miw0XSxbMTkyLDVdLFs0NiwyXSxbNDYsM10sWzE4OSwzXSxbMTg5LDJdLFsxOTUsMF0sWzE5NSwxXSxbODEsMl0sWzgxLDRdLFsxNjYsMV0sWzEwOSwxXSxbMTY4LDJdLFsxNjgsNF0sWzE5OSwxXSxbMTk5LDFdLFsxODcsNV0sWzE5MCwzXSxbMTkwLDJdLFsxOTAsMl0sWzExOSwxXSxbMTE5LDNdLFsxMTksNF0sWzExOSw0XSxbMTE5LDZdLFsxMzIsMl0sWzEzMiwxXSxbMjAyLDFdLFsyMDIsMV0sWzIwMiwxXSxbMjAyLDFdLFsyMDMsMV0sWzIwMywzXSxbNDEsMl0sWzQxLDNdLFs0MSwzXSxbNDEsNF0sWzIwNiwyXSxbMjA1LDNdLFsxOCwyXSxbMTg2LDNdLFsxODYsNV0sWzIxMSwyXSxbMjExLDRdLFsyMTEsMl0sWzIxMSw0XSxbNDIsMl0sWzQyLDJdLFs0MiwyXSxbNDIsMV0sWzIxNSwyXSxbMjE1LDJdLFs0MywyXSxbNDMsMl0sWzQzLDJdLFsyMTgsMV0sWzIxOCwxXSxbMjIxLDJdLFsyMTcsMl0sWzIxNywyXSxbMjIyLDJdLFsyMjIsM10sWzIyNiwxXSxbMjI2LDFdLFsyMjYsMV0sWzIyNCwxXSxbMjI0LDNdLFsyMjMsMl0sWzIyMywyXSxbMjIzLDRdLFsyMjMsNF0sWzIyMyw0XSxbMjIzLDZdLFsyMjMsNl0sWzQ0LDVdLFs0NCw3XSxbNDQsNF0sWzQ0LDZdLFsyMzEsMV0sWzIzMSwyXSxbMjMzLDNdLFsyMzMsNF0sWzIzNSwzXSxbMjM1LDVdLFsyMzUsNF0sWzIzNSwzXSxbMzksMV0sWzM5LDNdLFszOSwzXSxbNDAsNV0sWzM3LDJdLFszNywyXSxbMzcsMl0sWzM3LDJdLFszNywyXSxbMzcsMl0sWzM3LDJdLFszNywyXSxbMzcsM10sWzM3LDNdLFszNywzXSxbMzcsM10sWzM3LDNdLFszNywzXSxbMzcsM10sWzM3LDNdLFszNyw1XV0sXG5wZXJmb3JtQWN0aW9uOiBmdW5jdGlvbiBwZXJmb3JtQWN0aW9uKHNlbGYsIHl5dGV4dCwgeXksIHl5c3RhdGUgLyogYWN0aW9uWzFdICovLCAkJCAvKiB2c3RhY2sgKi8pIHtcbi8qIHNlbGYgPT0geXl2YWwgKi9cblxudmFyICQwID0gJCQubGVuZ3RoIC0gMTtcbnN3aXRjaCAoeXlzdGF0ZSkge1xuY2FzZSAxOlxucmV0dXJuIHNlbGYuJCA9IG5ldyB5eS5Sb290KFtdKTtcbmJyZWFrO1xuY2FzZSAyOlxucmV0dXJuIHNlbGYuJCA9IG5ldyB5eS5Sb290KCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMzpcbnJldHVybiBzZWxmLiQgPSAkJFskMC0xXTtcbmJyZWFrO1xuY2FzZSA0Olxuc2VsZi4kID0gbmV3IHl5LkJsb2NrKFtdKTtcbmJyZWFrO1xuY2FzZSA1Olxuc2VsZi4kID0gbmV3IHl5LkJsb2NrKFskJFskMF1dKTtcbmJyZWFrO1xuY2FzZSA2Olxuc2VsZi4kID0gJCRbJDAtMl0uYnJlYWsoJCRbJDAtMV0pLmFkZCgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDc6XG5zZWxmLiQgPSAkJFskMC0xXS5icmVhaygkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDg6XG5zZWxmLiQgPSBuZXcgeXkuVGVybWluYXRvcigkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDk6XG5zZWxmLiQgPSBuZXcgeXkuQmxvY2soW10pLmluZGVudGVkKCQkWyQwLTFdLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMTA6IGNhc2UgMTE5Olxuc2VsZi4kID0gJCRbJDAtMV0uaW5kZW50ZWQoJCRbJDAtMl0sJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAxMTpcbnNlbGYuJCA9ICQkWyQwLTFdLnByZWJyZWFrKCQkWyQwLTJdKS5pbmRlbnRlZCgkJFskMC0zXSwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDEyOiBjYXNlIDEzOiBjYXNlIDE2OiBjYXNlIDE3OiBjYXNlIDE4OiBjYXNlIDE5OiBjYXNlIDI2OiBjYXNlIDMwOiBjYXNlIDMzOiBjYXNlIDM0OiBjYXNlIDM1OiBjYXNlIDM2OiBjYXNlIDM3OiBjYXNlIDM4OiBjYXNlIDM5OiBjYXNlIDQwOiBjYXNlIDQxOiBjYXNlIDQyOiBjYXNlIDQzOiBjYXNlIDQ0OiBjYXNlIDQ1OiBjYXNlIDQ2OiBjYXNlIDQ3OiBjYXNlIDQ4OiBjYXNlIDQ5OiBjYXNlIDU5OiBjYXNlIDYwOiBjYXNlIDY3OiBjYXNlIDkzOiBjYXNlIDk0OiBjYXNlIDk5OiBjYXNlIDExODogY2FzZSAxMjM6IGNhc2UgMTMwOiBjYXNlIDE0MTogY2FzZSAxNDI6IGNhc2UgMTQzOiBjYXNlIDE0NDogY2FzZSAxNDU6IGNhc2UgMTQ2OiBjYXNlIDE1MDogY2FzZSAxNTE6IGNhc2UgMTUyOiBjYXNlIDE2MDogY2FzZSAxNjE6IGNhc2UgMTYyOiBjYXNlIDE2NTogY2FzZSAxNzQ6IGNhc2UgMTc1OiBjYXNlIDE3NzogY2FzZSAxODA6IGNhc2UgMTgxOiBjYXNlIDE4MjogY2FzZSAxODM6IGNhc2UgMTg0OiBjYXNlIDE4NTogY2FzZSAxOTY6IGNhc2UgMjAzOiBjYXNlIDIwNDogY2FzZSAyMDU6IGNhc2UgMjA2OiBjYXNlIDIwNzogY2FzZSAyMDg6IGNhc2UgMjEwOiBjYXNlIDIxMTogY2FzZSAyMTI6IGNhc2UgMjEzOiBjYXNlIDIyNzogY2FzZSAyMjg6IGNhc2UgMjI5OiBjYXNlIDIzMTogY2FzZSAyMzI6IGNhc2UgMjMzOiBjYXNlIDIzNDogY2FzZSAyMzU6IGNhc2UgMjM3OiBjYXNlIDIzODogY2FzZSAyMzk6IGNhc2UgMjQwOiBjYXNlIDI0OTogY2FzZSAyODM6IGNhc2UgMjg0OiBjYXNlIDI4NTogY2FzZSAyODY6IGNhc2UgMjg3OiBjYXNlIDI4ODogY2FzZSAzMDY6IGNhc2UgMzEyOiBjYXNlIDMxMzogY2FzZSAzMTk6IGNhc2UgMzM1OiBjYXNlIDM0MzpcbnNlbGYuJCA9ICQkWyQwXTtcbmJyZWFrO1xuY2FzZSAxNDogY2FzZSAxNTpcbnNlbGYuJCA9ICQkWyQwLTJdLmFkZEV4cHJlc3Npb24oJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyMDogY2FzZSA2ODpcbnNlbGYuJCA9IG5ldyB5eS5MaXRlcmFsKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjE6XG5zZWxmLiQgPSBuZXcgeXkuQnJlYWtTdGF0ZW1lbnQoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyMjpcbnNlbGYuJCA9IG5ldyB5eS5CcmVha1N0YXRlbWVudCgkJFskMC0zXSwkJFskMC0xXSk7XG5icmVhaztcbmNhc2UgMjM6XG5zZWxmLiQgPSBuZXcgeXkuQ29udGludWVTdGF0ZW1lbnQoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyNDpcbnNlbGYuJCA9IG5ldyB5eS5Db250aW51ZVN0YXRlbWVudCgkJFskMC0zXSwkJFskMC0xXSk7XG5icmVhaztcbmNhc2UgMjU6XG5zZWxmLiQgPSBuZXcgeXkuRGVidWdnZXJTdGF0ZW1lbnQoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyNzpcbnNlbGYuJCA9IG5ldyB5eS5JbXBvcnRTdGF0ZW1lbnQoJCRbJDAtMl0sJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyODpcbnNlbGYuJCA9IG5ldyB5eS5JbXBvcnRTdGF0ZW1lbnQobnVsbCwkJFskMC0yXSwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDI5Olxuc2VsZi4kID0gbmV3IHl5LkltcG9ydFN0YXRlbWVudChudWxsLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMzE6IGNhc2UgMTEzOiBjYXNlIDE4NzogY2FzZSAzMjI6XG5zZWxmLiQgPSBbJCRbJDBdXTtcbmJyZWFrO1xuY2FzZSAzMjogY2FzZSAxMTQ6IGNhc2UgMTg4Olxuc2VsZi4kID0gJCRbJDAtMl0uY29uY2F0KCQkWyQwXSk7XG5icmVhaztcbmNhc2UgNTA6XG5zZWxmLiQgPSBuZXcgeXkuSWRlbnRpZmllcigkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDUxOiBjYXNlIDUyOlxuc2VsZi4kID0gbmV3IHl5Lkl2YXIoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSA1MzpcbnNlbGYuJCA9IG5ldyB5eS5HdmFyKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgNTQ6XG5zZWxmLiQgPSBuZXcgeXkuQ29uc3QoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSA1NTpcbnNlbGYuJCA9IG5ldyB5eS5Bcmd2YXIoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSA1NjpcbnNlbGYuJCA9IG5ldyB5eS5TeW1ib2woJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSA1NzpcbnNlbGYuJCA9IG5ldyB5eS5OdW0oJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSA1ODpcbnNlbGYuJCA9IG5ldyB5eS5TdHIoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSA2MTpcbnNlbGYuJCA9IG5ldyB5eS5JbnRlcnBvbGF0ZWRTdHJpbmcoW10se29wZW46ICQkWyQwXX0pO1xuYnJlYWs7XG5jYXNlIDYyOlxuc2VsZi4kID0gJCRbJDAtMV0uYWRkKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgNjM6XG5zZWxmLiQgPSAkJFskMF0gPyAoJCRbJDAtMV0uYWRkKCQkWyQwXSkpIDogKCQkWyQwLTFdKTtcbmJyZWFrO1xuY2FzZSA2NDpcbnNlbGYuJCA9ICQkWyQwLTFdLm9wdGlvbignY2xvc2UnLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgNjU6XG5zZWxmLiQgPSBudWxsO1xuYnJlYWs7XG5jYXNlIDY2OiBjYXNlIDkyOiBjYXNlIDk1OiBjYXNlIDEyMDogY2FzZSAxNDc6IGNhc2UgMTYzOiBjYXNlIDE3NjogY2FzZSAyODI6XG5zZWxmLiQgPSAkJFskMC0xXTtcbmJyZWFrO1xuY2FzZSA2OTpcbnNlbGYuJCA9IG5ldyB5eS5SZWdFeHAoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSA3MDpcbnNlbGYuJCA9IG5ldyB5eS5Cb29sKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgNzE6XG5zZWxmLiQgPSB5eS5UUlVFO1xuYnJlYWs7XG5jYXNlIDcyOlxuc2VsZi4kID0geXkuRkFMU0U7XG5icmVhaztcbmNhc2UgNzM6XG5zZWxmLiQgPSB5eS5OSUw7XG5icmVhaztcbmNhc2UgNzQ6XG5zZWxmLiQgPSB5eS5VTkRFRklORUQ7XG5icmVhaztcbmNhc2UgNzU6IGNhc2UgNzY6XG5zZWxmLiQgPSBuZXcgeXkuUmV0dXJuKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgNzc6XG5zZWxmLiQgPSBuZXcgeXkuUmV0dXJuKCk7XG5icmVhaztcbmNhc2UgNzg6XG5zZWxmLiQgPSBuZXcgeXkuU2VsZWN0b3IoW10se3R5cGU6ICQkWyQwXX0pO1xuYnJlYWs7XG5jYXNlIDc5Olxuc2VsZi4kID0gJCRbJDAtMV0uYWRkKG5ldyB5eS5TZWxlY3RvclR5cGUoJCRbJDBdKSwndGFnJyk7XG5icmVhaztcbmNhc2UgODA6XG5zZWxmLiQgPSAkJFskMC0xXS5hZGQobmV3IHl5LlNlbGVjdG9yTmFtZXNwYWNlKCQkWyQwXSksJ25zJyk7XG5icmVhaztcbmNhc2UgODE6XG5zZWxmLiQgPSAkJFskMC0xXS5hZGQobmV3IHl5LlNlbGVjdG9ySWQoJCRbJDBdKSwnaWQnKTtcbmJyZWFrO1xuY2FzZSA4MjpcbnNlbGYuJCA9ICQkWyQwLTFdLmFkZChuZXcgeXkuU2VsZWN0b3JDbGFzcygkJFskMF0pLCdjbGFzcycpO1xuYnJlYWs7XG5jYXNlIDgzOlxuc2VsZi4kID0gJCRbJDAtNF0uYWRkKG5ldyB5eS5TZWxlY3RvckNsYXNzKCQkWyQwLTFdKSwnY2xhc3MnKTtcbmJyZWFrO1xuY2FzZSA4NDpcbnNlbGYuJCA9ICQkWyQwLTRdLmFkZChuZXcgeXkuU2VsZWN0b3JJZCgkJFskMC0xXSksJ2lkJyk7XG5icmVhaztcbmNhc2UgODU6XG5zZWxmLiQgPSAkJFskMC0xXS5hZGQobmV3IHl5LlNlbGVjdG9yQ29tYmluYXRvcigkJFskMF0pLCdzZXAnKTtcbmJyZWFrO1xuY2FzZSA4NjpcbnNlbGYuJCA9ICQkWyQwLTFdLmFkZChuZXcgeXkuU2VsZWN0b3JQc2V1ZG9DbGFzcygkJFskMF0pLCdwc2V1ZG9jbGFzcycpO1xuYnJlYWs7XG5jYXNlIDg3Olxuc2VsZi4kID0gJCRbJDAtMV0uZ3JvdXAoKTtcbmJyZWFrO1xuY2FzZSA4ODpcbnNlbGYuJCA9ICQkWyQwLTFdLmFkZChuZXcgeXkuU2VsZWN0b3JVbml2ZXJzYWwoJCRbJDBdKSwndW5pdmVyc2FsJyk7XG5icmVhaztcbmNhc2UgODk6XG5zZWxmLiQgPSAkJFskMC0zXS5hZGQobmV3IHl5LlNlbGVjdG9yQXR0cmlidXRlKCQkWyQwLTFdKSwnYXR0cicpO1xuYnJlYWs7XG5jYXNlIDkwOlxuc2VsZi4kID0gJCRbJDAtNV0uYWRkKG5ldyB5eS5TZWxlY3RvckF0dHJpYnV0ZSgkJFskMC0zXSwkJFskMC0yXSwkJFskMC0xXSksJ2F0dHInKTtcbmJyZWFrO1xuY2FzZSA5MTogY2FzZSAxMDA6IGNhc2UgMTAxOiBjYXNlIDEzMjogY2FzZSAxMzM6XG5zZWxmLiQgPSBuZXcgeXkuVGFnVHlwZUlkZW50aWZpZXIoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSA5NjpcbnNlbGYuJCA9ICQkWyQwLTJdLnNldCh7YXR0cmlidXRlczogJCRbJDAtMV0sb3BlbjogJCRbJDAtM10sY2xvc2U6ICQkWyQwXX0pO1xuYnJlYWs7XG5jYXNlIDk3Olxuc2VsZi4kID0gJCRbJDAtM10uc2V0KHthdHRyaWJ1dGVzOiAkJFskMC0yXSxib2R5OiAkJFskMF0sb3BlbjogJCRbJDAtNF0sY2xvc2U6ICQkWyQwLTFdfSk7XG5icmVhaztcbmNhc2UgOTg6XG5zZWxmLiQgPSBuZXcgeXkuVGFnV3JhcHBlcigkJFskMC0yXSwkJFskMC00XSwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDEwMjpcbnNlbGYuJCA9IG5ldyB5eS5UYWdUeXBlSWRlbnRpZmllcignZGl2Jyk7XG5icmVhaztcbmNhc2UgMTAzOlxuc2VsZi4kID0gbmV3IHl5LlRhZyh7dHlwZTogJCRbJDBdfSk7XG5icmVhaztcbmNhc2UgMTA0Olxuc2VsZi4kID0gJCRbJDAtMl0uYWRkU3ltYm9sKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMTA1Olxuc2VsZi4kID0gJCRbJDAtM10uYWRkSW5kZXgoJCRbJDAtMV0pO1xuYnJlYWs7XG5jYXNlIDEwNjpcbnNlbGYuJCA9ICQkWyQwLTJdLmFkZENsYXNzKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMTA3Olxuc2VsZi4kID0gJCRbJDAtNF0uYWRkQ2xhc3MoJCRbJDAtMV0pO1xuYnJlYWs7XG5jYXNlIDEwODpcbnNlbGYuJCA9ICQkWyQwLTRdLnNldCh7a2V5OiAkJFskMC0xXX0pO1xuYnJlYWs7XG5jYXNlIDEwOTpcbnNlbGYuJCA9ICQkWyQwLTJdLnNldCh7aWQ6ICQkWyQwXX0pO1xuYnJlYWs7XG5jYXNlIDExMDpcbnNlbGYuJCA9ICQkWyQwLTFdLnNldCh7aXZhcjogJCRbJDBdfSk7XG5icmVhaztcbmNhc2UgMTExOlxuc2VsZi4kID0gJCRbJDAtNF0uc2V0KHtpZDogJCRbJDAtMV19KTtcbmJyZWFrO1xuY2FzZSAxMTI6IGNhc2UgMTc5OiBjYXNlIDE4NjpcbnNlbGYuJCA9IFtdO1xuYnJlYWs7XG5jYXNlIDExNTpcbnNlbGYuJCA9ICQkWyQwLTNdLmNvbmNhdCgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDExNjpcbnNlbGYuJCA9IG5ldyB5eS5UYWdBdHRyKCQkWyQwXSwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDExNzpcbnNlbGYuJCA9IG5ldyB5eS5UYWdBdHRyKCQkWyQwLTJdLCQkWyQwXSwkJFskMC0xXSk7XG5icmVhaztcbmNhc2UgMTIxOlxuc2VsZi4kID0gbmV3IHl5LlRhZ0Rlc2MoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAxMjI6XG5zZWxmLiQgPSAkJFskMC0yXS5jbGFzc2VzKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMTI0Olxuc2VsZi4kID0gJCRbJDBdLnNldCh7ZXh0ZW5zaW9uOiB0cnVlfSk7XG5icmVhaztcbmNhc2UgMTI1Olxuc2VsZi4kID0gJCRbJDBdLnNldCh7bG9jYWw6IHRydWV9KTtcbmJyZWFrO1xuY2FzZSAxMjY6XG5zZWxmLiQgPSBuZXcgeXkuVGFnRGVjbGFyYXRpb24oJCRbJDBdKS5zZXQoe2tleXdvcmQ6ICQkWyQwLTFdfSk7XG5icmVhaztcbmNhc2UgMTI3Olxuc2VsZi4kID0gbmV3IHl5LlRhZ0RlY2xhcmF0aW9uKCQkWyQwLTFdLG51bGwsJCRbJDBdKS5zZXQoe2tleXdvcmQ6ICQkWyQwLTJdfSk7XG5icmVhaztcbmNhc2UgMTI4Olxuc2VsZi4kID0gbmV3IHl5LlRhZ0RlY2xhcmF0aW9uKCQkWyQwLTJdLCQkWyQwXSkuc2V0KHtrZXl3b3JkOiAkJFskMC0zXX0pO1xuYnJlYWs7XG5jYXNlIDEyOTpcbnNlbGYuJCA9IG5ldyB5eS5UYWdEZWNsYXJhdGlvbigkJFskMC0zXSwkJFskMC0xXSwkJFskMF0pLnNldCh7a2V5d29yZDogJCRbJDAtNF19KTtcbmJyZWFrO1xuY2FzZSAxMzE6XG5zZWxmLiQgPSBbJ3l5LmV4dGVuZCddO1xuYnJlYWs7XG5jYXNlIDEzNDogY2FzZSAxMzU6XG5zZWxmLiQgPSBuZXcgeXkuVGFnSWQoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAxMzY6XG5zZWxmLiQgPSBuZXcgeXkuQXNzaWduKCQkWyQwLTFdLCQkWyQwLTJdLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMTM3Olxuc2VsZi4kID0gbmV3IHl5LkFzc2lnbigkJFskMC0zXSwkJFskMC00XSwkJFskMC0xXS5pbmRlbnRlZCgkJFskMC0yXSwkJFskMF0pKTtcbmJyZWFrO1xuY2FzZSAxMzg6XG5zZWxmLiQgPSBuZXcgeXkuT2JqQXR0cigkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDEzOTpcbnNlbGYuJCA9IG5ldyB5eS5PYmpBdHRyKCQkWyQwLTJdLCQkWyQwXSwnb2JqZWN0Jyk7XG5icmVhaztcbmNhc2UgMTQwOlxuc2VsZi4kID0gbmV3IHl5Lk9iakF0dHIoJCRbJDAtNF0sJCRbJDAtMV0uaW5kZW50ZWQoJCRbJDAtMl0sJCRbJDBdKSwnb2JqZWN0Jyk7XG5icmVhaztcbmNhc2UgMTQ4Olxuc2VsZi4kID0gbmV3IHl5LkNvbW1lbnQoJCRbJDBdLHRydWUpO1xuYnJlYWs7XG5jYXNlIDE0OTpcbnNlbGYuJCA9IG5ldyB5eS5Db21tZW50KCQkWyQwXSxmYWxzZSk7XG5icmVhaztcbmNhc2UgMTUzOlxuc2VsZi4kID0gbmV3IHl5LkJlZ2luKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMTU0Olxuc2VsZi4kID0gbmV3IHl5LkxhbWJkYShbXSwkJFskMF0sbnVsbCxudWxsLHtib3VuZDogdHJ1ZX0pO1xuYnJlYWs7XG5jYXNlIDE1NTpcbnNlbGYuJCA9IG5ldyB5eS5MYW1iZGEoJCRbJDAtMl0sJCRbJDBdLG51bGwsbnVsbCx7Ym91bmQ6IHRydWV9KTtcbmJyZWFrO1xuY2FzZSAxNTY6XG5zZWxmLiQgPSBuZXcgeXkuTGFtYmRhKCQkWyQwLTNdLCQkWyQwLTFdLG51bGwsbnVsbCx7Ym91bmQ6IHRydWV9KTtcbmJyZWFrO1xuY2FzZSAxNTc6XG5zZWxmLiQgPSBuZXcgeXkuUHJvcGVydHlEZWNsYXJhdGlvbigkJFskMC0xXSwkJFskMF0sJCRbJDAtMl0pO1xuYnJlYWs7XG5jYXNlIDE1ODpcbnNlbGYuJCA9IG5ldyB5eS5Qcm9wZXJ0eURlY2xhcmF0aW9uKCQkWyQwLTNdLCQkWyQwLTFdLCQkWyQwLTRdKTtcbmJyZWFrO1xuY2FzZSAxNTk6XG5zZWxmLiQgPSBuZXcgeXkuUHJvcGVydHlEZWNsYXJhdGlvbigkJFskMF0sbnVsbCwkJFskMC0xXSk7XG5icmVhaztcbmNhc2UgMTY0Olxuc2VsZi4kID0gJCRbJDAtM107XG5icmVhaztcbmNhc2UgMTY2OiBjYXNlIDI1MjpcbnNlbGYuJCA9ICQkWyQwXS5zZXQoe2dsb2JhbDogJCRbJDAtMV19KTtcbmJyZWFrO1xuY2FzZSAxNjc6IGNhc2UgMjAyOiBjYXNlIDI1MzpcbnNlbGYuJCA9ICQkWyQwXS5zZXQoe2V4cG9ydDogJCRbJDAtMV19KTtcbmJyZWFrO1xuY2FzZSAxNjg6XG5zZWxmLiQgPSBuZXcgeXkuTWV0aG9kRGVjbGFyYXRpb24oJCRbJDAtMl0sJCRbJDBdLCQkWyQwLTRdLCQkWyQwLTZdLCQkWyQwLTVdKS5zZXQoe2RlZjogJCRbJDAtN119KTtcbmJyZWFrO1xuY2FzZSAxNjk6XG5zZWxmLiQgPSBuZXcgeXkuTWV0aG9kRGVjbGFyYXRpb24oW10sJCRbJDBdLCQkWyQwLTFdLCQkWyQwLTNdLCQkWyQwLTJdKS5zZXQoe2RlZjogJCRbJDAtNF19KTtcbmJyZWFrO1xuY2FzZSAxNzA6XG5zZWxmLiQgPSBuZXcgeXkuTWV0aG9kRGVjbGFyYXRpb24oJCRbJDAtMl0sJCRbJDBdLCQkWyQwLTRdLG51bGwpLnNldCh7ZGVmOiAkJFskMC01XX0pO1xuYnJlYWs7XG5jYXNlIDE3MTpcbnNlbGYuJCA9IG5ldyB5eS5NZXRob2REZWNsYXJhdGlvbihbXSwkJFskMF0sJCRbJDAtMV0sbnVsbCkuc2V0KHtkZWY6ICQkWyQwLTJdfSk7XG5icmVhaztcbmNhc2UgMTcyOlxuc2VsZi4kID0ge3N0YXRpYzogdHJ1ZX07XG5icmVhaztcbmNhc2UgMTczOlxuc2VsZi4kID0ge307XG5icmVhaztcbmNhc2UgMTc4Olxuc2VsZi4kID0gJCRbJDBdLmJvZHkoKTtcbmJyZWFrO1xuY2FzZSAxODk6XG5zZWxmLiQgPSBuZXcgeXkuTmFtZWRQYXJhbXMoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAxOTA6XG5zZWxmLiQgPSBuZXcgeXkuQXJyYXlQYXJhbXMoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAxOTE6XG5zZWxmLiQgPSBuZXcgeXkuUmVxdWlyZWRQYXJhbSgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDE5MjpcbnNlbGYuJCA9IG5ldyB5eS5TcGxhdFBhcmFtKCQkWyQwXSxudWxsLCQkWyQwLTFdKTtcbmJyZWFrO1xuY2FzZSAxOTM6IGNhc2UgMTk0Olxuc2VsZi4kID0gbmV3IHl5LkJsb2NrUGFyYW0oJCRbJDBdLG51bGwsJCRbJDAtMV0pO1xuYnJlYWs7XG5jYXNlIDE5NTpcbnNlbGYuJCA9IG5ldyB5eS5PcHRpb25hbFBhcmFtKCQkWyQwLTJdLCQkWyQwXSwkJFskMC0xXSk7XG5icmVhaztcbmNhc2UgMTk3Olxuc2VsZi4kID0geXkuU1BMQVQoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAxOTg6IGNhc2UgMjAxOlxuc2VsZi4kID0geXkuU1BMQVQobmV3IHl5LlZhclJlZmVyZW5jZSgkJFskMF0sJCRbJDAtMl0pLCQkWyQwLTFdKTtcbmJyZWFrO1xuY2FzZSAxOTk6IGNhc2UgMjAwOlxuc2VsZi4kID0gbmV3IHl5LlZhclJlZmVyZW5jZSgkJFskMF0sJCRbJDAtMV0pO1xuYnJlYWs7XG5jYXNlIDIwOTpcbnNlbGYuJCA9IG5ldyB5eS5JdmFyQWNjZXNzKCcuJyxudWxsLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjE0Olxuc2VsZi4kID0gbmV3IHl5LlZhck9yQWNjZXNzKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjE1Olxuc2VsZi4kID0gbmV3IHl5Lk5ldygkJFskMC0yXSk7XG5icmVhaztcbmNhc2UgMjE2Olxuc2VsZi4kID0gbmV3IHl5LlN1cGVyQWNjZXNzKCcuJywkJFskMC0yXSwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDIxNzpcbnNlbGYuJCA9IG5ldyB5eS5Qcm9wZXJ0eUFjY2VzcygkJFskMC0xXSwkJFskMC0yXSwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDIxODogY2FzZSAyMTk6IGNhc2UgMjIwOiBjYXNlIDIyMjpcbnNlbGYuJCA9IG5ldyB5eS5BY2Nlc3MoJCRbJDAtMV0sJCRbJDAtMl0sJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyMjE6XG5zZWxmLiQgPSBuZXcgeXkuQWNjZXNzKCcuJywkJFskMC0yXSxuZXcgeXkuSWRlbnRpZmllcigkJFskMF0udmFsdWUoKSkpO1xuYnJlYWs7XG5jYXNlIDIyMzpcbnNlbGYuJCA9IG5ldyB5eS5JbmRleEFjY2VzcygnLicsJCRbJDAtM10sJCRbJDAtMV0pO1xuYnJlYWs7XG5jYXNlIDIyNjpcbnNlbGYuJCA9IHl5LlNVUEVSO1xuYnJlYWs7XG5jYXNlIDIzMDpcbnNlbGYuJCA9IG5ldyB5eS5Bd2FpdCgkJFskMF0pLnNldCh7a2V5d29yZDogJCRbJDAtMV19KTtcbmJyZWFrO1xuY2FzZSAyMzY6XG5zZWxmLiQgPSB5eS5BUkdVTUVOVFM7XG5icmVhaztcbmNhc2UgMjQxOlxuc2VsZi4kID0gbmV3IHl5LkluZGV4KCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjQyOlxuc2VsZi4kID0gbmV3IHl5LlNsaWNlKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjQzOlxuc2VsZi4kID0gbmV3IHl5Lk9iaigkJFskMC0yXSwkJFskMC0zXS5nZW5lcmF0ZWQpO1xuYnJlYWs7XG5jYXNlIDI0NDpcbnNlbGYuJCA9IG5ldyB5eS5Bc3NpZ25MaXN0KFtdKTtcbmJyZWFrO1xuY2FzZSAyNDU6XG5zZWxmLiQgPSBuZXcgeXkuQXNzaWduTGlzdChbJCRbJDBdXSk7XG5icmVhaztcbmNhc2UgMjQ2OiBjYXNlIDI3ODpcbnNlbGYuJCA9ICQkWyQwLTJdLmFkZCgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDI0NzogY2FzZSAyNzk6XG5zZWxmLiQgPSAkJFskMC0zXS5hZGQoJCRbJDAtMV0pLmFkZCgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDI0ODpcbnNlbGYuJCA9ICQkWyQwLTVdLmNvbmNhdCgkJFskMC0yXS5pbmRlbnRlZCgkJFskMC0zXSwkJFskMF0pKTtcbmJyZWFrO1xuY2FzZSAyNTA6XG5zZWxmLiQgPSAkJFskMF0uc2V0KHtleHRlbnNpb246ICQkWyQwLTFdfSk7XG5icmVhaztcbmNhc2UgMjUxOlxuc2VsZi4kID0gJCRbJDBdLnNldCh7bG9jYWw6ICQkWyQwLTFdfSk7XG5icmVhaztcbmNhc2UgMjU0Olxuc2VsZi4kID0gJCRbJDBdLnNldCh7ZXhwb3J0OiAkJFskMC0yXSxsb2NhbDogJCRbJDAtMV19KTtcbmJyZWFrO1xuY2FzZSAyNTU6XG5zZWxmLiQgPSBuZXcgeXkuQ2xhc3NEZWNsYXJhdGlvbigkJFskMF0sbnVsbCxbXSkuc2V0KHtrZXl3b3JkOiAkJFskMC0xXX0pO1xuYnJlYWs7XG5jYXNlIDI1NjpcbnNlbGYuJCA9IG5ldyB5eS5DbGFzc0RlY2xhcmF0aW9uKCQkWyQwLTFdLG51bGwsJCRbJDBdKS5zZXQoe2tleXdvcmQ6ICQkWyQwLTJdfSk7XG5icmVhaztcbmNhc2UgMjU3Olxuc2VsZi4kID0gbmV3IHl5LkNsYXNzRGVjbGFyYXRpb24oJCRbJDAtMl0sJCRbJDBdLFtdKS5zZXQoe2tleXdvcmQ6ICQkWyQwLTNdfSk7XG5icmVhaztcbmNhc2UgMjU4Olxuc2VsZi4kID0gbmV3IHl5LkNsYXNzRGVjbGFyYXRpb24oJCRbJDAtM10sJCRbJDAtMV0sJCRbJDBdKS5zZXQoe2tleXdvcmQ6ICQkWyQwLTRdfSk7XG5icmVhaztcbmNhc2UgMjU5Olxuc2VsZi4kID0gbmV3IHl5Lk1vZHVsZSgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDI2MDpcbnNlbGYuJCA9IG5ldyB5eS5Nb2R1bGUoJCRbJDAtMV0sbnVsbCwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDI2MTpcbnNlbGYuJCA9IG5ldyB5eS5DYWxsKCQkWyQwLTJdLCQkWyQwXSwkJFskMC0xXSk7XG5icmVhaztcbmNhc2UgMjYyOlxuc2VsZi4kID0gJCRbJDAtMV0uYWRkQmxvY2soJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyNjM6XG5zZWxmLiQgPSBmYWxzZTtcbmJyZWFrO1xuY2FzZSAyNjQ6XG5zZWxmLiQgPSB0cnVlO1xuYnJlYWs7XG5jYXNlIDI2NTpcbnNlbGYuJCA9IG5ldyB5eS5BcmdMaXN0KFtdKTtcbmJyZWFrO1xuY2FzZSAyNjY6XG5zZWxmLiQgPSAkJFskMC0yXTtcbmJyZWFrO1xuY2FzZSAyNjc6XG5zZWxmLiQgPSBuZXcgeXkuVGhpcygkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDI2ODpcbnNlbGYuJCA9IG5ldyB5eS5TZWxmKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjY5Olxuc2VsZi4kID0gbmV3IHl5LkFycihuZXcgeXkuQXJnTGlzdChbXSkpO1xuYnJlYWs7XG5jYXNlIDI3MDpcbnNlbGYuJCA9IG5ldyB5eS5BcnIoJCRbJDAtMl0pO1xuYnJlYWs7XG5jYXNlIDI3MTpcbnNlbGYuJCA9ICcuLic7XG5icmVhaztcbmNhc2UgMjcyOlxuc2VsZi4kID0gJy4uLic7XG5icmVhaztcbmNhc2UgMjczOlxuc2VsZi4kID0geXkuT1AoJCRbJDAtMl0sJCRbJDAtM10sJCRbJDAtMV0pO1xuYnJlYWs7XG5jYXNlIDI3NDpcbnNlbGYuJCA9IG5ldyB5eS5SYW5nZSgkJFskMC0yXSwkJFskMF0sJCRbJDAtMV0pO1xuYnJlYWs7XG5jYXNlIDI3NTpcbnNlbGYuJCA9IG5ldyB5eS5SYW5nZSgkJFskMC0xXSxudWxsLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjc2Olxuc2VsZi4kID0gbmV3IHl5LlJhbmdlKG51bGwsJCRbJDBdLCQkWyQwLTFdKTtcbmJyZWFrO1xuY2FzZSAyNzc6XG5zZWxmLiQgPSBuZXcgeXkuQXJnTGlzdChbJCRbJDBdXSk7XG5icmVhaztcbmNhc2UgMjgwOlxuc2VsZi4kID0gJCRbJDAtMl0uaW5kZW50ZWQoJCRbJDAtM10sJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyODE6XG5zZWxmLiQgPSAkJFskMC01XS5jb25jYXQoJCRbJDAtMl0pO1xuYnJlYWs7XG5jYXNlIDI4OTpcbnNlbGYuJCA9IFtdLmNvbmNhdCgkJFskMC0yXSwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDI5MDpcbnNlbGYuJCA9IG5ldyB5eS5UcnkoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyOTE6XG5zZWxmLiQgPSBuZXcgeXkuVHJ5KCQkWyQwLTFdLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjkyOlxuc2VsZi4kID0gbmV3IHl5LlRyeSgkJFskMC0xXSxudWxsLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjkzOlxuc2VsZi4kID0gbmV3IHl5LlRyeSgkJFskMC0yXSwkJFskMC0xXSwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDI5NDpcbnNlbGYuJCA9IG5ldyB5eS5GaW5hbGx5KCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjk1Olxuc2VsZi4kID0gbmV3IHl5LkNhdGNoKCQkWyQwXSwkJFskMC0xXSk7XG5icmVhaztcbmNhc2UgMjk2Olxuc2VsZi4kID0gbmV3IHl5LlRocm93KCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjk3Olxuc2VsZi4kID0gbmV3IHl5LlBhcmVucygkJFskMC0xXSwkJFskMC0yXSwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDI5ODpcbnNlbGYuJCA9IG5ldyB5eS5QYXJlbnMoJCRbJDAtMl0sJCRbJDAtNF0sJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyOTk6XG5zZWxmLiQgPSBuZXcgeXkuV2hpbGUoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAzMDA6XG5zZWxmLiQgPSBuZXcgeXkuV2hpbGUoJCRbJDAtMl0se2d1YXJkOiAkJFskMF19KTtcbmJyZWFrO1xuY2FzZSAzMDE6XG5zZWxmLiQgPSBuZXcgeXkuV2hpbGUoJCRbJDBdLHtpbnZlcnQ6IHRydWV9KTtcbmJyZWFrO1xuY2FzZSAzMDI6XG5zZWxmLiQgPSBuZXcgeXkuV2hpbGUoJCRbJDAtMl0se2ludmVydDogdHJ1ZSxndWFyZDogJCRbJDBdfSk7XG5icmVhaztcbmNhc2UgMzAzOiBjYXNlIDMxMTogY2FzZSAzMTQ6XG5zZWxmLiQgPSAkJFskMC0xXS5hZGRCb2R5KCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMzA0OiBjYXNlIDMwNTpcbnNlbGYuJCA9ICQkWyQwXS5hZGRCb2R5KHl5LkJsb2NrLndyYXAoWyQkWyQwLTFdXSkpO1xuYnJlYWs7XG5jYXNlIDMwNzpcbnNlbGYuJCA9IG5ldyB5eS5XaGlsZShuZXcgeXkuTGl0ZXJhbCgndHJ1ZScpKS5hZGRCb2R5KCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMzA4Olxuc2VsZi4kID0gbmV3IHl5LldoaWxlKG5ldyB5eS5MaXRlcmFsKCd0cnVlJykpLmFkZEJvZHkoeXkuQmxvY2sud3JhcChbJCRbJDBdXSkpO1xuYnJlYWs7XG5jYXNlIDMwOTogY2FzZSAzMTA6XG5zZWxmLiQgPSAkJFskMF0uYWRkQm9keShbJCRbJDAtMV1dKTtcbmJyZWFrO1xuY2FzZSAzMTU6XG5zZWxmLiQgPSB7c291cmNlOiBuZXcgeXkuVmFsdWVOb2RlKCQkWyQwXSl9O1xuYnJlYWs7XG5jYXNlIDMxNjpcbnNlbGYuJCA9ICQkWyQwXS5jb25maWd1cmUoe293bjogJCRbJDAtMV0ub3duLG5hbWU6ICQkWyQwLTFdWzBdLGluZGV4OiAkJFskMC0xXVsxXSxrZXl3b3JkOiAkJFskMC0xXS5rZXl3b3JkfSk7XG5icmVhaztcbmNhc2UgMzE3Olxuc2VsZi4kID0gKCQkWyQwXS5rZXl3b3JkID0gJCRbJDAtMV0pICYmICQkWyQwXTtcbmJyZWFrO1xuY2FzZSAzMTg6XG5zZWxmLiQgPSAoJCRbJDBdLm93biA9IHRydWUpICYmICgkJFskMF0ua2V5d29yZCA9ICQkWyQwLTJdKSAmJiAkJFskMF07XG5icmVhaztcbmNhc2UgMzIwOiBjYXNlIDMyMTpcbnNlbGYuJCA9IG5ldyB5eS5WYWx1ZU5vZGUoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAzMjM6XG5zZWxmLiQgPSBbJCRbJDAtMl0sJCRbJDBdXTtcbmJyZWFrO1xuY2FzZSAzMjQ6XG5zZWxmLiQgPSBuZXcgeXkuRm9ySW4oe3NvdXJjZTogJCRbJDBdfSk7XG5icmVhaztcbmNhc2UgMzI1Olxuc2VsZi4kID0gbmV3IHl5LkZvck9mKHtzb3VyY2U6ICQkWyQwXSxvYmplY3Q6IHRydWV9KTtcbmJyZWFrO1xuY2FzZSAzMjY6XG5zZWxmLiQgPSBuZXcgeXkuRm9ySW4oe3NvdXJjZTogJCRbJDAtMl0sZ3VhcmQ6ICQkWyQwXX0pO1xuYnJlYWs7XG5jYXNlIDMyNzpcbnNlbGYuJCA9IG5ldyB5eS5Gb3JPZih7c291cmNlOiAkJFskMC0yXSxndWFyZDogJCRbJDBdLG9iamVjdDogdHJ1ZX0pO1xuYnJlYWs7XG5jYXNlIDMyODpcbnNlbGYuJCA9IG5ldyB5eS5Gb3JJbih7c291cmNlOiAkJFskMC0yXSxzdGVwOiAkJFskMF19KTtcbmJyZWFrO1xuY2FzZSAzMjk6XG5zZWxmLiQgPSBuZXcgeXkuRm9ySW4oe3NvdXJjZTogJCRbJDAtNF0sZ3VhcmQ6ICQkWyQwLTJdLHN0ZXA6ICQkWyQwXX0pO1xuYnJlYWs7XG5jYXNlIDMzMDpcbnNlbGYuJCA9IG5ldyB5eS5Gb3JJbih7c291cmNlOiAkJFskMC00XSxzdGVwOiAkJFskMC0yXSxndWFyZDogJCRbJDBdfSk7XG5icmVhaztcbmNhc2UgMzMxOlxuc2VsZi4kID0gbmV3IHl5LlN3aXRjaCgkJFskMC0zXSwkJFskMC0xXSk7XG5icmVhaztcbmNhc2UgMzMyOlxuc2VsZi4kID0gbmV3IHl5LlN3aXRjaCgkJFskMC01XSwkJFskMC0zXSwkJFskMC0xXSk7XG5icmVhaztcbmNhc2UgMzMzOlxuc2VsZi4kID0gbmV3IHl5LlN3aXRjaChudWxsLCQkWyQwLTFdKTtcbmJyZWFrO1xuY2FzZSAzMzQ6XG5zZWxmLiQgPSBuZXcgeXkuU3dpdGNoKG51bGwsJCRbJDAtM10sJCRbJDAtMV0pO1xuYnJlYWs7XG5jYXNlIDMzNjpcbnNlbGYuJCA9ICQkWyQwLTFdLmNvbmNhdCgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDMzNzpcbnNlbGYuJCA9IFtuZXcgeXkuU3dpdGNoQ2FzZSgkJFskMC0xXSwkJFskMF0pXTtcbmJyZWFrO1xuY2FzZSAzMzg6XG5zZWxmLiQgPSBbbmV3IHl5LlN3aXRjaENhc2UoJCRbJDAtMl0sJCRbJDAtMV0pXTtcbmJyZWFrO1xuY2FzZSAzMzk6XG5zZWxmLiQgPSBuZXcgeXkuSWYoJCRbJDAtMV0sJCRbJDBdLHt0eXBlOiAkJFskMC0yXX0pO1xuYnJlYWs7XG5jYXNlIDM0MDpcbnNlbGYuJCA9ICQkWyQwLTRdLmFkZEVsc2UobmV3IHl5LklmKCQkWyQwLTFdLCQkWyQwXSx7dHlwZTogJCRbJDAtMl19KSk7XG5icmVhaztcbmNhc2UgMzQxOlxuc2VsZi4kID0gJCRbJDAtM10uYWRkRWxzZShuZXcgeXkuSWYoJCRbJDAtMV0sJCRbJDBdLHt0eXBlOiAkJFskMC0yXX0pKTtcbmJyZWFrO1xuY2FzZSAzNDI6XG5zZWxmLiQgPSAkJFskMC0yXS5hZGRFbHNlKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMzQ0Olxuc2VsZi4kID0gbmV3IHl5LklmKCQkWyQwXSxuZXcgeXkuQmxvY2soWyQkWyQwLTJdXSkse3R5cGU6ICQkWyQwLTFdLHN0YXRlbWVudDogdHJ1ZX0pO1xuYnJlYWs7XG5jYXNlIDM0NTpcbnNlbGYuJCA9IG5ldyB5eS5JZigkJFskMF0sbmV3IHl5LkJsb2NrKFskJFskMC0yXV0pLHt0eXBlOiAkJFskMC0xXX0pO1xuYnJlYWs7XG5jYXNlIDM0NjpcbnNlbGYuJCA9IHl5LklmLnRlcm5hcnkoJCRbJDAtNF0sJCRbJDAtMl0sJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAzNDc6IGNhc2UgMzQ4Olxuc2VsZi4kID0geXkuT1AoJCRbJDAtMV0sJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAzNDk6XG5zZWxmLiQgPSBuZXcgeXkuT3AoJy0nLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMzUwOlxuc2VsZi4kID0gbmV3IHl5Lk9wKCcrJywkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDM1MTpcbnNlbGYuJCA9IG5ldyB5eS5VbmFyeU9wKCctLScsbnVsbCwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDM1MjpcbnNlbGYuJCA9IG5ldyB5eS5VbmFyeU9wKCcrKycsbnVsbCwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDM1MzpcbnNlbGYuJCA9IG5ldyB5eS5VbmFyeU9wKCctLScsJCRbJDAtMV0sbnVsbCx0cnVlKTtcbmJyZWFrO1xuY2FzZSAzNTQ6XG5zZWxmLiQgPSBuZXcgeXkuVW5hcnlPcCgnKysnLCQkWyQwLTFdLG51bGwsdHJ1ZSk7XG5icmVhaztcbmNhc2UgMzU1OiBjYXNlIDM1NjpcbnNlbGYuJCA9IG5ldyB5eS5PcCgkJFskMC0xXSwkJFskMC0yXSwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDM1NzogY2FzZSAzNTg6IGNhc2UgMzU5OiBjYXNlIDM2MDpcbnNlbGYuJCA9IHl5Lk9QKCQkWyQwLTFdLCQkWyQwLTJdLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMzYxOlxuc2VsZi4kID0gKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYgKCQkWyQwLTFdLmNoYXJBdCgwKSA9PSAnIScpIHtcblx0XHRcdFx0XHRyZXR1cm4geXkuT1AoJCRbJDAtMV0uc2xpY2UoMSksJCRbJDAtMl0sJCRbJDBdKS5pbnZlcnQoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4geXkuT1AoJCRbJDAtMV0sJCRbJDAtMl0sJCRbJDBdKTtcblx0XHRcdFx0fTtcblx0XHRcdH0oKSk7XG5icmVhaztcbmNhc2UgMzYyOlxuc2VsZi4kID0geXkuT1BfQ09NUE9VTkQoJCRbJDAtMV0uX3ZhbHVlLCQkWyQwLTFdLCQkWyQwLTJdLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMzYzOlxuc2VsZi4kID0geXkuT1BfQ09NUE9VTkQoJCRbJDAtM10uX3ZhbHVlLCQkWyQwLTRdLCQkWyQwLTFdLmluZGVudGVkKCQkWyQwLTJdLCQkWyQwXSkpO1xuYnJlYWs7XG59XG59LFxudGFibGU6IFt7MTpbMiwxXSwzOjEsNDoyLDU6Myw3OiRWMCw4OjUsMTA6JFYxLDEyOjcsMTM6OCwxNTo5LDE2OjEwLDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxMzg6JFZ6LDEzOTokVkEsMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTcwOiRWSiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHsxOlszXX0sezE6WzIsMl0sNjokVjUxLDk6MTMzfSx7NjpbMSwxMzVdfSxvKCRWNjEsWzIsNF0pLG8oJFY2MSxbMiw1XSx7MTQ6JFY3MX0pLHs0OjEzOCw2OlsxLDEzOV0sNzokVjAsODo1LDExOlsxLDEzN10sMTI6NywxMzo4LDE1OjksMTY6MTAsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDEzODokVnosMTM5OiRWQSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzA6JFZKLDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sbygkVjgxLFsyLDEyXSksbygkVjgxLFsyLDEzXSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwxMjY6JFY5MSwxNzE6JFZhMSwyMTI6JFZVLDIxNDokVlYsMjE5OiRWWCwyMjA6JFZZLDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSksbygkVjgxLFsyLDE2XSksbygkVjgxLFsyLDE3XSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNTIsMjE3OjE1MywyMTI6JFZVLDIxNDokVlYsMjE5OiRWWCwyMjA6JFZZLDIzODokVmkxfSksezEzOjE1NCwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sbygkVmoxLFsyLDM0XSksbygkVmoxLFsyLDM1XSx7MTk1OjE1NiwxNDE6MTU3LDE3OToxNTksMjE6JFZrMSw4ODokVmwxLDg5OiRWbTEsMTExOiRWbjEsMTQ0OiRWQywxODA6JFZvMSwxODE6JFZwMSwxODM6JFZxMSwxOTY6JFZyMX0pLG8oJFZqMSxbMiwzNl0pLG8oJFZqMSxbMiwzN10pLG8oJFZqMSxbMiwzOF0pLG8oJFZqMSxbMiwzOV0pLG8oJFZqMSxbMiw0MF0pLG8oJFZqMSxbMiw0MV0pLG8oJFZqMSxbMiw0Ml0pLG8oJFZqMSxbMiw0M10pLG8oJFZqMSxbMiw0NF0pLG8oJFZqMSxbMiw0NV0pLG8oJFZqMSxbMiw0Nl0pLG8oJFZqMSxbMiw0N10pLG8oJFZqMSxbMiw0OF0pLG8oJFZqMSxbMiw0OV0pLG8oJFZzMSxbMiwxNDhdKSxvKCRWczEsWzIsMTQ5XSksbygkVnQxLFsyLDE4XSksbygkVnQxLFsyLDE5XSksbygkVnQxLFsyLDIwXSksbygkVnQxLFsyLDIxXSx7MjE6WzEsMTY2XX0pLG8oJFZ0MSxbMiwyM10sezIxOlsxLDE2N119KSxvKCRWdDEsWzIsMjVdKSxvKCRWdDEsWzIsMjZdKSx7MTM6MTY4LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWdTEsJFZ2MSx7MTE3OlsxLDE2OV19KSxvKCRWdTEsWzIsMjMyXSksbygkVnUxLFsyLDIzM10pLG8oJFZ1MSxbMiwyMzRdKSxvKCRWdTEsWzIsMjM1XSksbygkVnUxLFsyLDIzNl0pLG8oJFZ1MSxbMiwyMzddKSxvKCRWdTEsWzIsMjM4XSksbygkVnUxLFsyLDIzOV0pLG8oJFZ1MSxbMiwyNDBdKSxvKCRWajEsWzIsMTUwXSksbygkVmoxLFsyLDE1MV0pLG8oJFZqMSxbMiwxNTJdKSx7MTM6MTcwLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTM6MTcxLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTM6MTcyLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTM6MTczLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MzI6JFY3LDM1OjE3NSw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgyOjkyLDgzOiRWcCw4OTokVncxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwOToxMDEsMTI5OjQ1LDEzMDokVngsMTMxOjE3NywxMzY6JFZ5LDE1MDo3NywxNTQ6JFZGLDE1NzokVngxLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3NjoxNzQsMTc4OjM5LDE4NDokVkwsMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTc6JFZRLDE5ODokVlJ9LHszMjokVjcsMzU6MTc1LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODI6OTIsODM6JFZwLDg5OiRWdzEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTA5OjEwMSwxMjk6NDUsMTMwOiRWeCwxMzE6MTc3LDEzNjokVnksMTUwOjc3LDE1NDokVkYsMTU3OiRWeDEsMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjE3OSwxNzg6MzksMTg0OiRWTCwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5NzokVlEsMTk4OiRWUn0sbygkVnkxLCRWejEsezI0NDpbMSwxODBdLDI0NTpbMSwxODFdLDI0OTpbMSwxODJdfSksbygkVmoxLFsyLDM0M10sezIzMjpbMSwxODNdLDIzNzpbMSwxODRdfSksezU6MTg1LDEwOiRWMX0sezU6MTg2LDEwOiRWMX0sbygkVmoxLFsyLDMwNl0pLHs1OjE4NywxMDokVjF9LHsxMDpbMSwxODldLDEzOjE4OCwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sbygkVmoxLFsyLDI0OV0pLHsxMjE6MTkxLDEyNDokVncsMTkyOjE5MCwxOTM6JFZPfSx7MTIxOjE5MywxMjQ6JFZ3LDE5MjoxOTIsMTkzOiRWT30sezE1NToxOTUsMTU4OiRWSSwxOTI6MTk0LDE5MzokVk99LHsxMjM6WzEsMTk3XSwxNTQ6JFZGLDE1NToxOTgsMTU3OiRWeDEsMTU4OiRWSSwxNzM6MTk5LDE3NTokVkssMTkyOjE5NiwxOTM6JFZPfSx7MzI6JFY3LDM1OjE3NSw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgyOjkyLDgzOiRWcCw4OTokVncxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwOToxMDEsMTI5OjQ1LDEzMDokVngsMTMxOjE3NywxMzY6JFZ5LDE1MDo3NywxNTQ6JFZGLDE1NzokVngxLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3NjoyMDAsMTc4OjM5LDE4NDokVkwsMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTc6JFZRLDE5ODokVlJ9LG8oJFZqMSxbMiwxMjNdKSxvKCRWQTEsWzIsMTAyXSx7MTA0OjIwMSwxMDg6MjAzLDEwOToyMDQsNTE6WzEsMjA1XSw4OTpbMSwyMDJdLDExMDpbMSwyMDZdLDE5ODokVlJ9KSx7NTA6MjA4LDUxOiRWOCw4OTpbMSwyMDldLDE0OToyMDd9LG8oJFZ0MSxbMiw3N10sezM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDE3OjMwLDE4OjMxLDI1OjM2LDEzMTozOCwxNzg6MzksNzI6NDAsMTg2OjQxLDE4Nzo0MiwxNjY6NDQsMTI5OjQ1LDEwMTo0NiwxODk6NDcsMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTc2OjU3LDIzNTo1OCwyMTE6NjAsMjE1OjYxLDIxNzo2MiwxOTI6NjQsMTIxOjcwLDE0ODo3MiwxNjg6NzYsMTUwOjc3LDYzOjc5LDgyOjkyLDE1NTo5Myw1Nzo5Nyw1Mjo5OCw1NTo5OSw1OToxMDAsMTA5OjEwMSwxNzM6MTAyLDUwOjEwMywyMTg6MTA4LDIyMjoxMDksNjE6MTE2LDY1OjExNywxNjoxNTUsMTM6MjEwLDgxOjIxMSwxOTokVjIsMjA6JFYzLDIxOiRWQjEsMjM6JFY0LDI0OiRWNSwyNjokVjYsMzI6JFY3LDUxOiRWOCw1MzokVjksNTQ6JFZhLDU2OiRWYiw1ODokVmMsNjA6JFZkLDYyOiRWZSw2NDokVmYsNjY6JFZnLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMzokVnQsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTMwOiRWeCwxMzY6JFZ5LDE0MzokVkIsMTQ0OiRWQywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNzU6JFZLLDE4NDokVkwsMTg1OiRWTSwxODg6JFZOLDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxNjokVlcsMjMwOiRWWiwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9KSx7MTM6MjEzLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7Mjc6MjE0LDI5OjIxNSwzMToyMTYsMzI6JFZDMSwzMzoyMTgsNTA6MjIwLDUxOiRWOCw1NzoyMTksNTg6JFZjfSxvKCRWeTEsWzIsMjI4XSksbygkVnkxLFsyLDIyOV0pLG8oJFZEMSxbMiwyMjZdKSxvKCRWdTEsWzIsNjddKSxvKCRWdTEsWzIsNjhdKSxvKCRWdTEsWzIsNjldKSxvKCRWdTEsWzIsNzBdKSxvKCRWdTEsWzIsNzFdKSxvKCRWdTEsWzIsNzJdKSxvKCRWdTEsWzIsNzNdKSxvKCRWdTEsWzIsNzRdKSx7NDoyMjEsNzokVjAsODo1LDEwOlsxLDIyMl0sMTI6NywxMzo4LDE1OjksMTY6MTAsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDEzODokVnosMTM5OiRWQSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzA6JFZKLDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezEwOiRWRTEsMTI6MjI4LDEzOjIyMywxNToyMzAsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcyw5NzokVkYxLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTE5OjIyNSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTM4OiRWeiwxMzk6JFZBLDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MDokVkosMTcxOiRWRzEsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjAyOjIyNiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oWzEsNiwxMCwxMSwxNCwyMSwyMiw3MSw4OCw4OSw5MCw5MSw5NywxMDYsMTExLDExMiwxMjYsMTM1LDEzNywxNDQsMTQ3LDE3MSwxODAsMTgxLDE4MywxOTYsMjAwLDIwMSwyMTIsMjEzLDIxNCwyMTksMjIwLDIyOSwyMzgsMjM5LDI0MiwyNDMsMjQ2LDI0NywyNDhdLFsyLDI2N10pLG8oJFZ1MSxbMiwxMzRdKSx7NTA6MjMxLDUxOiRWOH0sezg0OjIzMyw4NTpbMSwyMzRdLDg2OlsxLDIzNV0sODc6WzEsMjM2XSw4ODpbMSwyMzddLDkxOlsxLDIzOF0sOTI6WzEsMjM5XSw5MzpbMSwyNDBdLDk0OlsxLDI0MV0sOTU6WzEsMjQyXSw5NjpbMSwyNDNdLDEwMDpbMSwyNDRdLDEwMjpbMSwyMzJdfSxvKCRWajEsWzIsMTY1XSksezU6MjQ1LDEwOiRWMSwxNDU6WzEsMjQ2XX0sbygkVkgxLCRWSTEsezYxOjExNiw2NToxMTcsMTkxOjI0OCwxMzM6MjQ5LDEzNDoyNTAsMTU6MjUxLDUwOjI1Miw1NzoyNTMsNjM6MjU0LDUyOjI1NSw1NToyNTYsMzI6JFY3LDUxOiRWOCw1MzokVjksNTQ6JFZhLDU2OiRWYiw1ODokVmMsNjI6JFZlLDY0OiRWZiw2NjokVmcsMTM2OiRWSjEsMTM4OiRWeiwxMzk6JFZBLDE0NTokVksxfSksezU6MjU4LDEwOiRWMX0sbygkVkQxLFsyLDIwOF0pLG8oJFZEMSxbMiwyMDldKSxvKCRWRDEsWzIsMjEwXSksbygkVkQxLFsyLDIxMV0pLG8oJFZEMSxbMiwyMTJdKSxvKCRWRDEsWzIsMjEzXSksbygkVkQxLFsyLDIxNF0pLHsxMzoyNTksMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHsxMzoyNjAsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHsxMzoyNjEsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHs1OjI2MiwxMDokVjEsMTM6MjYzLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7NTA6MjY4LDUxOiRWOCw4OTokVncxLDk2OiRWcywxNTA6MjcwLDE2ODoyNjksMTg3OjI2NCwyMjQ6MjY1LDIyNTpbMSwyNjZdLDIyNjoyNjd9LHsyMjM6MjcxLDIyNzpbMSwyNzJdLDIyODpbMSwyNzNdfSx7MzI6JFY3LDM1OjE3NSw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgyOjkyLDgzOiRWcCw4OTokVncxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwOToxMDEsMTI5OjQ1LDEzMDokVngsMTMxOjE3NywxMzY6JFZ5LDE1MDo3NywxNTQ6JFZGLDE1NzokVngxLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3NjoyNzQsMTc4OjM5LDE4NDokVkwsMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTc6JFZRLDE5ODokVlJ9LHsxMTA6JFZMMSwxMjU6Mjc1LDEyODokVk0xfSxvKCRWTjEsWzIsMTYwXSksbygkVk4xLFsyLDE2MV0pLG8oJFZ1MSxbMiw1N10pLG8oJFZ1MSxbMiw1OF0pLG8oJFZ1MSxbMiw1OV0pLG8oJFZ1MSxbMiw2MF0sezY4OjI3OSw2NzpbMSwyNzhdLDY5OlsxLDI4MF0sNzA6WzEsMjgxXX0pLG8oJFZPMSxbMiw3OF0pLHs1MDoyODcsNTE6JFY4LDU1OjI4Niw1NjokVmIsNTc6Mjg4LDU4OiRWYyw4OTokVlAxLDEwOToyODUsMTU5OjI4MiwxNjE6MjgzLDE2NjoyODQsMTk3OiRWUSwxOTg6JFZSfSxvKFsxLDYsMTAsMTEsMTQsMjEsMjIsMjgsNzEsODgsODksOTAsOTEsOTcsMTA2LDExMSwxMTIsMTE3LDEyNiwxMzUsMTM3LDE0NCwxNDcsMTY0LDE2NSwxNzEsMTgwLDE4MSwxODMsMTk2LDIwMCwyMDEsMjEyLDIxMywyMTQsMjE5LDIyMCwyMjksMjM4LDIzOSwyNDIsMjQzLDI0NCwyNDUsMjQ2LDI0NywyNDgsMjQ5XSxbMiw1NF0pLG8oJFZRMSxbMiw1MV0pLG8oJFZRMSxbMiw1Ml0pLG8oWzEsNiwxMCwxMSwxNCwyMSwyMiw3MSw4OCw4OSw5MCw5MSw5NywxMDYsMTExLDExMiwxMTcsMTI2LDEzNSwxMzcsMTQ0LDE0NywxNzEsMTgwLDE4MSwxODMsMTk2LDIwMCwyMDEsMjEyLDIxMywyMTQsMjE5LDIyMCwyMjksMjM4LDIzOSwyNDIsMjQzLDI0NCwyNDUsMjQ2LDI0NywyNDgsMjQ5XSxbMiw1M10pLG8oJFZEMSxbMiw1NV0pLG8oJFZRMSxbMiwyNjhdKSx7NTA6MjkzLDUxOiRWOCw1NzoyOTIsNTg6JFZjLDk2OiRWUjEsMTY4OjI5NCwxNzA6WzEsMjkwXSwxNzQ6MjkxfSx7NTA6MjkzLDUxOiRWOCw1NzoyOTIsNTg6JFZjLDk2OiRWUjEsMTY4OjI5NCwxNzA6WzEsMjk3XSwxNzQ6Mjk2fSxvKFsxLDYsMTAsMTEsMTQsMjEsMjIsMjgsNzEsODgsODksOTAsOTEsOTcsOTgsMTA2LDExMSwxMTIsMTE3LDEyNiwxMzUsMTM3LDE0NCwxNDcsMTY0LDE2NSwxNzEsMTgwLDE4MSwxODMsMTk2LDIwMCwyMDEsMjEyLDIxMywyMTQsMjE5LDIyMCwyMjcsMjI4LDIyOSwyMzgsMjM5LDI0MiwyNDMsMjQ0LDI0NSwyNDYsMjQ3LDI0OCwyNDldLFsyLDUwXSksbygkVlMxLFsyLDMxMl0pLG8oJFZTMSxbMiwzMTNdKSxvKCRWRDEsWzIsNTZdKSxvKCRWVDEsWzIsNjFdKSxvKCRWNjEsWzIsN10sezEyOjcsMTM6OCwxNTo5LDE2OjEwLDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDE3OjMwLDE4OjMxLDI1OjM2LDEzMTozOCwxNzg6MzksNzI6NDAsMTg2OjQxLDE4Nzo0MiwxNjY6NDQsMTI5OjQ1LDEwMTo0NiwxODk6NDcsMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTc2OjU3LDIzNTo1OCwyMTE6NjAsMjE1OjYxLDIxNzo2MiwxOTI6NjQsMTIxOjcwLDE0ODo3MiwxNjg6NzYsMTUwOjc3LDYzOjc5LDgyOjkyLDE1NTo5Myw1Nzo5Nyw1Mjo5OCw1NTo5OSw1OToxMDAsMTA5OjEwMSwxNzM6MTAyLDUwOjEwMywyMTg6MTA4LDIyMjoxMDksNjE6MTE2LDY1OjExNyw4OjI5OCwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjY6JFY2LDMyOiRWNyw1MTokVjgsNTM6JFY5LDU0OiRWYSw1NjokVmIsNTg6JFZjLDYwOiRWZCw2MjokVmUsNjQ6JFZmLDY2OiRWZyw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDM6JFZ0LDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEzMDokVngsMTM2OiRWeSwxMzg6JFZ6LDEzOTokVkEsMTQzOiRWQiwxNDQ6JFZDLDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE3MDokVkosMTc1OiRWSywxODQ6JFZMLDE4NTokVk0sMTg4OiRWTiwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTI6JFZVLDIxNDokVlYsMjE2OiRWVywyMTk6JFZYLDIyMDokVlksMjMwOiRWWiwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9KSxvKFsxLDYsMTEsMTksMjAsMjMsMjQsMjYsMzIsNTEsNTMsNTQsNTYsNTgsNjAsNjIsNjQsNjYsNzMsNzQsNzUsNzYsNzcsNzgsNzksODAsODMsODksOTEsOTYsMTAzLDEyMiwxMjMsMTI0LDEzMCwxMzYsMTM3LDEzOCwxMzksMTQzLDE0NCwxNTEsMTUyLDE1NCwxNTYsMTU3LDE1OCwxNzAsMTcxLDE3NSwxODQsMTg1LDE4OCwxOTMsMTk0LDE5NywxOTgsMjA0LDIxMCwyMTIsMjE0LDIxNiwyMTksMjIwLDIzMCwyMzYsMjQwLDI0MSwyNDIsMjQzLDI0NCwyNDVdLFsyLDhdKSx7MTpbMiwzXX0sezEyOjMwMCwxMzoyOTksMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzA6JFZKLDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sbygkVlUxLFsyLDldKSx7NjokVjUxLDk6MTMzLDExOlsxLDMwMV19LHs0OjMwMiw3OiRWMCw4OjUsMTI6NywxMzo4LDE1OjksMTY6MTAsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDEzODokVnosMTM5OiRWQSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzA6JFZKLDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezEzOjMwMywxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezEzOjMwNCwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezEzOjMwNSwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezEzOjMwNiwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezEzOjMwNywxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezEzOjMwOCwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezEzOjMwOSwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezEzOjMxMCwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezEzOjMxMSwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sbygkVmoxLFsyLDMwNV0pLG8oJFZqMSxbMiwzMTBdKSx7MTM6MzEyLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWajEsWzIsMzA0XSksbygkVmoxLFsyLDMwOV0pLG8oWzEsNiwxMCwxMSwxNCwyMiw5NywxMzddLFsyLDE5N10sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMTI2OiRWOTEsMTcxOiRWYTEsMjEyOiRWVSwyMTQ6JFZWLDIxOTokVlgsMjIwOiRWWSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0pLHsyMTE6MTUyLDIxMjokVlUsMjE0OiRWViwyMTc6MTUzLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjM4OiRWaTF9LHsyMTokVkIxLDgxOjMxM30sbygkVnUxLFsyLDI2Ml0pLG8oJFZWMSxbMiwyMjRdLHsxNzg6MzE1LDYxOjMxNiw2MjokVmUsMTc3OlsxLDMxNF0sMTg0OiRWTH0pLHs1MDozMTcsNTE6JFY4LDUyOjMxOCw1MzokVjksNTQ6JFZhLDU3OjMxOSw1ODokVmN9LHs1MDozMjAsNTE6JFY4fSx7NTA6MzIxLDUxOiRWOH0sezEzOjMyMywxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4MjozMjIsMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkwOjMyNCwxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwxOTk6MzI1LDIwMDokVlcxLDIwMTokVlgxLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezIxOlsyLDI2NF19LHsxNDU6JFZLMX0sbygkVlYxLFsyLDIyNV0pLHsxMzozMjgsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHsxMzozMjksMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oJFZZMSxbMiwyMzBdLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDEyNjokVjkxLDE3MTokVmExLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSksezEwOlsxLDMzMV0sMTM6MzMwLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWajEsWzIsMzQ3XSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MH0pLG8oJFZqMSxbMiwzNDhdLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwfSksbygkVmoxLFsyLDM0OV0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTB9KSxvKCRWajEsWzIsMzUwXSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MH0pLG8oJFZqMSxbMiwzNTFdLHsyMTokVnoxLDg4OiRWejEsODk6JFZ6MSwxMTE6JFZ6MSwxNDQ6JFZ6MSwxODA6JFZ6MSwxODE6JFZ6MSwxODM6JFZ6MSwxOTY6JFZ6MX0pLHsyMTokVmsxLDg4OiRWbDEsODk6JFZtMSwxMTE6JFZuMSwxNDE6MTU3LDE0NDokVkMsMTc5OjE1OSwxODA6JFZvMSwxODE6JFZwMSwxODM6JFZxMSwxOTU6MTU2LDE5NjokVnIxfSx7MTU0OiRWRiwxNTc6JFZ4MSwxNzM6MTk5LDE3NTokVkt9LG8oWzIxLDg4LDg5LDExMSwxNDQsMTgwLDE4MSwxODMsMTk2XSwkVnYxKSxvKCRWSDEsJFZJMSx7NjE6MTE2LDY1OjExNywxOTE6MjQ4LDEzMzoyNDksMTM0OjI1MCwxNToyNTEsNTA6MjUyLDU3OjI1Myw2MzoyNTQsNTI6MjU1LDU1OjI1NiwzMjokVjcsNTE6JFY4LDUzOiRWOSw1NDokVmEsNTY6JFZiLDU4OiRWYyw2MjokVmUsNjQ6JFZmLDY2OiRWZywxMzY6JFZKMSwxMzg6JFZ6LDEzOTokVkF9KSxvKCRWajEsWzIsMzUyXSx7MjE6JFZ6MSw4ODokVnoxLDg5OiRWejEsMTExOiRWejEsMTQ0OiRWejEsMTgwOiRWejEsMTgxOiRWejEsMTgzOiRWejEsMTk2OiRWejF9KSxvKCRWajEsWzIsMzUzXSksbygkVmoxLFsyLDM1NF0pLHsxMDpbMSwzMzNdLDEzOjMzMiwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezU6MzM1LDEwOiRWMSwyMzY6WzEsMzM0XX0sezEzOjMzNiwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sbygkVmoxLFsyLDI5MF0sezIwNTozMzcsMjA2OjMzOCwyMDc6JFZaMSwyMDg6WzEsMzM5XX0pLG8oJFZqMSxbMiwzMDNdKSxvKCRWajEsWzIsMzExXSksezEwOlsxLDM0MV0sMTI2OiRWOTEsMTcxOiRWYTEsMjExOjE0OSwyMTI6JFZVLDIxNDokVlYsMjE3OjE1MCwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSx7MjMxOjM0MiwyMzM6MzQzLDIzNDokVl8xfSxvKCRWajEsWzIsMjUwXSksbygkVmoxLFsyLDEyNF0pLG8oJFZqMSxbMiwyNTFdKSxvKCRWajEsWzIsMTI1XSksbygkVmoxLFsyLDI1Ml0pLG8oJFZqMSxbMiwxNjZdKSxvKCRWajEsWzIsMjUzXSksezE5MjozNDUsMTkzOiRWT30sbygkVmoxLFsyLDE2N10pLG8oJFZEMSxbMiwyMDJdKSxvKCRWJDEsWzIsMjU5XSx7NTozNDYsMTA6JFYxLDIxOiRWejEsODg6JFZ6MSw4OTokVnoxLDExMTokVnoxLDE0NDokVnoxLDE4MDokVnoxLDE4MTokVnoxLDE4MzokVnoxLDE5NjokVnoxfSksbygkVjAyLFsyLDExMl0sezEwNTozNDcsNTI6MzUyLDExNDozNTMsNTM6JFY5LDU0OiRWYSw4ODpbMSwzNDhdLDkxOlsxLDM1MV0sMTExOlsxLDM0OV0sMTEzOlsxLDM1MF0sMTE2OiRWMTJ9KSx7MTM6MzU1LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWQTEsWzIsMTAzXSksbygkVkExLFsyLDk5XSksbygkVkExLFsyLDEwMF0pLG8oJFZBMSxbMiwxMDFdKSxvKCRWajEsWzIsMTU5XSx7MTUwOjM1NiwyMTpbMSwzNTddLDg5OiRWdzF9KSxvKCRWMjIsWzIsMTYyXSksezEzOjM1OCwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sbygkVnQxLFsyLDc1XSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwxMjY6JFY5MSwxNzE6JFZhMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0pLG8oJFZ0MSxbMiw3Nl0pLHsxMDokVkUxLDEyOjIyOCwxMzozNjEsMTU6MjMwLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIyOlsxLDM1OV0sMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDExOTozNjAsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDEzODokVnosMTM5OiRWQSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzA6JFZKLDE3MTokVkcxLDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwMjoyMjYsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWdDEsWzIsMjk2XSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwxMjY6JFY5MSwxNzE6JFZhMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0pLHsxNDpbMSwzNjNdLDI4OlsxLDM2Ml19LG8oJFZ0MSxbMiwyOV0sezMwOlsxLDM2NF19KSxvKCRWMzIsWzIsMzFdKSxvKFsxLDYsMTEsMTQsMzAsMTM3LDIxMiwyMTQsMjE5LDIyMCwyMzhdLFsyLDMwXSksbygkVjQyLFsyLDMzXSksbygkVjQyLFsyLDIwM10pLG8oJFY0MixbMiwyMDRdKSx7NjokVjUxLDk6MTMzLDEzNzpbMSwzNjVdfSx7NDozNjYsNzokVjAsODo1LDEyOjcsMTM6OCwxNTo5LDE2OjEwLDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxMzg6JFZ6LDEzOTokVkEsMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTcwOiRWSiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oWzYsMTAsMTQsOTddLCRWNTIsezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMTk5OjM2NywxMjY6JFY5MSwxNzE6JFZhMSwyMDA6JFZXMSwyMDE6JFZYMSwyMTI6JFZVLDIxNDokVlYsMjE5OiRWWCwyMjA6JFZZLDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSksbygkVjYyLFsyLDI2OV0pLG8oWzYsMTAsOTddLCRWNzIsezExNTozNjgsMTQ6JFY4Mn0pLG8oJFY5MixbMiwyNzddKSx7MTA6JFZFMSwxMjoyMjgsMTM6MzYxLDE1OjIzMCwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTE5OjM3MCwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTM4OiRWeiwxMzk6JFZBLDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MDokVkosMTcxOiRWRzEsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjAyOjIyNiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oJFY5MixbMiwyODVdKSxvKCRWOTIsWzIsMjg2XSksbygkVjkyLFsyLDI4N10pLG8oJFZ1MSxbMiwxMzVdKSxvKCRWdTEsWzIsOTJdKSxvKCRWTzEsWzIsNzldKSxvKCRWTzEsWzIsODBdKSxvKCRWTzEsWzIsODFdKSxvKCRWTzEsWzIsODJdKSx7ODk6WzEsMzcxXX0sezg5OlsxLDM3Ml19LG8oJFZPMSxbMiw4NV0pLG8oJFZPMSxbMiw4Nl0pLG8oJFZPMSxbMiw4N10pLG8oJFZPMSxbMiw4OF0pLHs1MDozNzMsNTE6JFY4fSxvKCRWTzEsWzIsOTFdKSxvKCRWdTEsWzIsMTU0XSksbygkVmEyLCRWYjIsezE0NjozNzQsMTY3OjM3NSwxNTA6Mzc2LDE2ODozNzcsMTY5OjM3OCw1MDozODIsNTE6JFY4LDg5OiRWdzEsOTY6JFZSMSwxNzA6JFZjMiwxNzE6JFZkMiwxNzI6JFZlMn0pLG8oJFZhMiwkVmIyLHsxNjc6Mzc1LDE1MDozNzYsMTY4OjM3NywxNjk6Mzc4LDUwOjM4MiwxNDY6MzgzLDUxOiRWOCw4OTokVncxLDk2OiRWUjEsMTcwOiRWYzIsMTcxOiRWZDIsMTcyOiRWZTJ9KSxvKFs2LDEwLDkwXSwkVjcyLHsxMTU6Mzg0LDE0OiRWZjJ9KSxvKCRWZzIsWzIsMjQ1XSksbygkVmcyLFsyLDEzOF0sezEzNTpbMSwzODZdfSksbygkVmcyLFsyLDE0MV0pLG8oJFZoMixbMiwxNDJdKSxvKCRWaDIsWzIsMTQzXSksbygkVmgyLFsyLDE0NF0pLG8oJFZoMixbMiwxNDVdKSxvKCRWaDIsWzIsMTQ2XSksezEzOjM4NywxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sbygkVmoxLFsyLDE1M10pLHs1OjM4OCwxMDokVjEsMTI2OiRWOTEsMTcxOiRWYTEsMjExOjE0OSwyMTI6JFZVLDIxNDokVlYsMjE3OjE1MCwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSxvKCRWaTIsWzIsMjk5XSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwxMjY6JFY5MSwxNzE6JFZhMSwyMTI6JFZVLDIxMzpbMSwzODldLDIxNDokVlYsMjE5OiRWWCwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0pLG8oJFZpMixbMiwzMDFdLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDEyNjokVjkxLDE3MTokVmExLDIxMjokVlUsMjEzOlsxLDM5MF0sMjE0OiRWViwyMTk6JFZYLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSksbygkVmoxLFsyLDMwN10pLG8oJFZqMixbMiwzMDhdLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDEyNjokVjkxLDE3MTokVmExLDIxMjokVlUsMjE0OiRWViwyMTk6JFZYLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSksbygkVmoxLFsyLDMxNV0pLG8oJFZrMixbMiwzMTddKSx7NTA6MjY4LDUxOiRWOCw4OTokVncxLDk2OiRWUjEsMTUwOjI3MCwxNjg6MjY5LDIyNDozOTEsMjI2OjI2N30sbygkVmsyLFsyLDMyMl0sezE0OlsxLDM5Ml19KSxvKCRWbDIsWzIsMzE5XSksbygkVmwyLFsyLDMyMF0pLG8oJFZsMixbMiwzMjFdKSxvKCRWajEsWzIsMzE2XSksezEzOjM5MywxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezEzOjM5NCwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sbygkVm0yLFsyLDI1NV0sezU6Mzk1LDEwOiRWMSwyMTokVnoxLDg4OiRWejEsODk6JFZ6MSwxMTE6JFZ6MSwxNDQ6JFZ6MSwxODA6JFZ6MSwxODE6JFZ6MSwxODM6JFZ6MSwxOTY6JFZ6MSwxMjY6WzEsMzk2XX0pLG8oJFZtMixbMiwxMjZdLHs1OjM5NywxMDokVjEsMTI2OlsxLDM5OF19KSxvKCRWajEsWzIsMTMyXSksbygkVmoxLFsyLDEzM10pLG8oJFZUMSxbMiw2Ml0pLG8oJFZUMSxbMiw2M10pLG8oJFZUMSxbMiw2NF0pLHsxMzo0MDAsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3MTpbMSwzOTldLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezg4OlsxLDQwMl0sOTE6WzEsNDAzXSwxNjA6NDAxfSxvKCRWbjIsWzIsMTgwXSx7MTYyOjQwNSwyMTpbMSw0MDRdLDE2NDokVm8yLDE2NTokVnAyfSksbygkVm4yLFsyLDE4MV0pLG8oJFZuMixbMiwxODJdKSxvKCRWbjIsWzIsMTgzXSksbygkVnEyLFsyLDE3NF0pLG8oJFZxMixbMiwxNzVdKSx7MTM6NDA4LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7NTA6MjkzLDUxOiRWOCw1NzoyOTIsNTg6JFZjLDk2OiRWUjEsMTY4OjI5NCwxNzQ6NDA5fSxvKCRWRDEsWzIsMTk5XSksbygkVkQxLFsyLDIwNV0pLG8oJFZEMSxbMiwyMDZdKSxvKCRWRDEsWzIsMjA3XSksezEwOiRWRTEsMTI6MjI4LDEzOjM2MSwxNToyMzAsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcyw5NzokVkYxLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTE5OjIyNSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTM4OiRWeiwxMzk6JFZBLDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MDokVkosMTcxOiRWRzEsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjAyOjIyNiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oJFZEMSxbMiwyMDBdKSx7NTA6MjkzLDUxOiRWOCw1NzoyOTIsNTg6JFZjLDk2OiRWUjEsMTY4OjI5NCwxNzQ6NDEwfSxvKCRWNjEsWzIsNl0sezE0OiRWNzF9KSxvKCRWODEsWzIsMTRdLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDEyNjokVjkxLDE3MTokVmExLDIxMjokVlUsMjE0OiRWViwyMTk6JFZYLDIyMDokVlksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSxvKCRWODEsWzIsMTVdKSxvKCRWVTEsWzIsMTBdKSx7NjokVjUxLDk6MTMzLDExOlsxLDQxMV19LG8oJFZyMixbMiwzNTVdLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDI0NjokVmYxfSksbygkVnIyLFsyLDM1Nl0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMjQ2OiRWZjF9KSxvKCRWajEsWzIsMzU3XSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MH0pLG8oWzEsNiwxMCwxMSwxNCwyMiw3MSw5MCw5NywxMDYsMTEyLDEyNiwxMzUsMTM3LDE0NywxNzEsMjAwLDIwMSwyMTIsMjEzLDIxNCwyMTksMjIwLDIyOSwyMzgsMjM5LDI0NywyNDhdLFsyLDM1OF0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjF9KSxvKFsxLDYsMTAsMTEsMTQsMjIsNzEsOTAsOTcsMTA2LDExMiwxMjYsMTM1LDEzNywxNDcsMTcxLDIwMCwyMDEsMjEyLDIxMywyMTQsMjE5LDIyMCwyMjksMjM4LDIzOV0sWzIsMzU5XSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0pLG8oWzEsNiwxMCwxMSwxNCwyMiw3MSw5MCw5NywxMDYsMTEyLDEzNSwxMzcsMTQ3LDE3MSwyMDAsMjAxLDIxMiwyMTMsMjE0LDIxOSwyMjAsMjI5LDIzOCwyMzldLFsyLDM2MF0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMTI2OiRWOTEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSxvKFsxLDYsMTAsMTEsMTQsMjIsNzEsOTAsOTcsMTA2LDExMiwxMjYsMTM1LDEzNywxNDcsMTcxLDIwMCwyMDEsMjEyLDIxMywyMTQsMjE5LDIyMCwyMjksMjM4LDIzOSwyNDhdLFsyLDM2MV0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzF9KSxvKCRWczIsWzIsMzQ1XSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwxMjY6JFY5MSwxNzE6JFZhMSwyMTI6JFZVLDIxNDokVlYsMjE5OiRWWCwyMjA6JFZZLDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSksezEyNjokVjkxLDEzNTpbMSw0MTJdLDE3MTokVmExLDIxMToxNDksMjEyOiRWVSwyMTQ6JFZWLDIxNzoxNTAsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0sbygkVnMyLFsyLDM0NF0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMTI2OiRWOTEsMTcxOiRWYTEsMjEyOiRWVSwyMTQ6JFZWLDIxOTokVlgsMjIwOiRWWSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0pLG8oJFZ1MSxbMiwyNjFdKSxvKCRWRDEsWzIsMjE1XSksbygkVkQxLFsyLDIxNl0pLG8oJFZEMSxbMiwyMjFdKSxvKCRWRDEsWzIsMjE3XSksbygkVkQxLFsyLDIyMF0pLG8oJFZEMSxbMiwyMjJdKSxvKCRWRDEsWzIsMjE4XSksbygkVkQxLFsyLDIxOV0pLHsxMTI6WzEsNDEzXX0sezExMjpbMiwyNDFdLDEyNjokVjkxLDE3MTokVmExLDE5OTo0MTQsMjAwOiRWVzEsMjAxOiRWWDEsMjExOjE0OSwyMTI6JFZVLDIxNDokVlYsMjE3OjE1MCwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSx7MTEyOlsyLDI0Ml19LHsxMzo0MTUsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oJFZ0MixbMiwyNzFdKSxvKCRWdDIsWzIsMjcyXSksezIyOlsxLDQxNl0sMTI2OiRWOTEsMTcxOiRWYTEsMjExOjE0OSwyMTI6JFZVLDIxNDokVlYsMjE3OjE1MCwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSx7MjI6WzEsNDE3XSwxMjY6JFY5MSwxNzE6JFZhMSwyMTE6MTQ5LDIxMjokVlUsMjE0OiRWViwyMTc6MTUwLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9LG8oJFZZMSxbMiwxMzZdLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDEyNjokVjkxLDE3MTokVmExLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSksezEzOjQxOCwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sbygkVlkxLFsyLDM2Ml0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMTI2OiRWOTEsMTcxOiRWYTEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSx7MTM6NDE5LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTM6NDIwLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWdTIsWzIsMzQyXSksezU6NDIxLDEwOiRWMSwxMjY6JFY5MSwxNzE6JFZhMSwyMTE6MTQ5LDIxMjokVlUsMjE0OiRWViwyMTc6MTUwLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9LG8oJFZqMSxbMiwyOTFdLHsyMDY6NDIyLDIwNzokVloxfSksbygkVmoxLFsyLDI5Ml0pLHsyMDk6WzEsNDIzXX0sezU6NDI0LDEwOiRWMX0sezIzMTo0MjUsMjMzOjM0MywyMzQ6JFZfMX0sezExOlsxLDQyNl0sMjMyOlsxLDQyN10sMjMzOjQyOCwyMzQ6JFZfMX0sbygkVnYyLFsyLDMzNV0pLHsxMzo0MzAsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDM6NDI5LDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sbygkVmoxLFsyLDI1NF0pLG8oJFZqMSxbMiwyNjBdKSx7NjokVjcyLDE0OlsxLDQzMl0sMTA2OlsxLDQzMV0sMTE1OjQzM30sezUxOlsxLDQzNV0sNjI6WzEsNDM0XSw4OTpbMSw0MzZdfSx7MTM6NDM3LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7ODk6WzEsNDM4XX0sezUxOlsxLDQzOV0sODk6WzEsNDQwXX0sbygkVkExLFsyLDExMF0pLG8oJFYwMixbMiwxMTNdKSxvKCRWMDIsWzIsMTE2XSx7MTE3OlsxLDQ0MV19KSx7OTA6WzEsNDQyXSwxMjY6JFY5MSwxNzE6JFZhMSwyMTE6MTQ5LDIxMjokVlUsMjE0OiRWViwyMTc6MTUwLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9LG8oJFZqMSxbMiwxNTddKSx7ODk6JFZ3MSwxNTA6NDQzfSx7OTA6WzEsNDQ0XSwxMjY6JFY5MSwxNzE6JFZhMSwyMTE6MTQ5LDIxMjokVlUsMjE0OiRWViwyMTc6MTUwLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9LG8oJFZ1MSxbMiwyNjVdKSxvKFs2LDEwLDIyXSwkVjcyLHsxMTU6NDQ1LDE0OiRWODJ9KSxvKCRWOTIsJFY1Mix7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwxMjY6JFY5MSwxNzE6JFZhMSwyMTI6JFZVLDIxNDokVlYsMjE5OiRWWCwyMjA6JFZZLDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSksezI5OjQ0NiwzMjokVkMxfSx7MzE6NDQ3LDMzOjIxOCw1MDoyMjAsNTE6JFY4LDU3OjIxOSw1ODokVmN9LHszMTo0NDgsMzM6MjE4LDUwOjIyMCw1MTokVjgsNTc6MjE5LDU4OiRWY30sbygkVnUxLFsyLDI5N10pLHs2OiRWNTEsOToxMzMsMTE6WzEsNDQ5XX0sezEzOjQ1MCwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezY6JFY1MSw5OjQ1MiwxMDokVncyLDk3OlsxLDQ1MV19LG8oWzYsMTAsMTEsMjIsOTddLCRWeDIsezM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDE3OjMwLDE4OjMxLDI1OjM2LDEzMTozOCwxNzg6MzksNzI6NDAsMTg2OjQxLDE4Nzo0MiwxNjY6NDQsMTI5OjQ1LDEwMTo0NiwxODk6NDcsMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTc2OjU3LDIzNTo1OCwyMTE6NjAsMjE1OjYxLDIxNzo2MiwxOTI6NjQsMTIxOjcwLDE0ODo3MiwxNjg6NzYsMTUwOjc3LDYzOjc5LDgyOjkyLDE1NTo5Myw1Nzo5Nyw1Mjo5OCw1NTo5OSw1OToxMDAsMTA5OjEwMSwxNzM6MTAyLDUwOjEwMywyMTg6MTA4LDIyMjoxMDksNjE6MTE2LDY1OjExNywxNjoxNTUsMTI6MjI4LDE1OjIzMCwxMzozNjEsMjAyOjQ1NCwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjY6JFY2LDMyOiRWNyw1MTokVjgsNTM6JFY5LDU0OiRWYSw1NjokVmIsNTg6JFZjLDYwOiRWZCw2MjokVmUsNjQ6JFZmLDY2OiRWZyw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDM6JFZ0LDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEzMDokVngsMTM2OiRWeSwxMzg6JFZ6LDEzOTokVkEsMTQzOiRWQiwxNDQ6JFZDLDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE3MDokVkosMTcxOiRWRzEsMTc1OiRWSywxODQ6JFZMLDE4NTokVk0sMTg4OiRWTiwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTI6JFZVLDIxNDokVlYsMjE2OiRWVywyMTk6JFZYLDIyMDokVlksMjMwOiRWWiwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9KSxvKCRWeTIsJFY3Mix7MTE1OjQ1NSwxNDokVjgyfSksezEzOjQ1NiwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezEzOjQ1NywxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezk3OlsxLDQ1OF0sOTg6WzEsNDU5XX0sezE0OiRWejIsMTQ3OlsxLDQ2MF19LG8oJFZBMixbMiwxODddKSxvKCRWQTIsWzIsMTg5XSksbygkVkEyLFsyLDE5MF0pLG8oJFZBMixbMiwxOTFdLHsxMTc6WzEsNDYyXX0pLHs1MDozODIsNTE6JFY4LDE2OTo0NjN9LHs1MDozODIsNTE6JFY4LDE2OTo0NjR9LHs1MDozODIsNTE6JFY4LDE2OTo0NjV9LG8oWzE0LDIyLDExNywxNDddLFsyLDE5Nl0pLHsxNDokVnoyLDE0NzpbMSw0NjZdfSx7NjokVjUxLDk6NDY4LDEwOiRWQjIsOTA6WzEsNDY3XX0sbyhbNiwxMCwxMSw5MF0sJFZ4Mix7NjE6MTE2LDY1OjExNywxMzQ6MjUwLDE1OjI1MSw1MDoyNTIsNTc6MjUzLDYzOjI1NCw1MjoyNTUsNTU6MjU2LDEzMzo0NzAsMzI6JFY3LDUxOiRWOCw1MzokVjksNTQ6JFZhLDU2OiRWYiw1ODokVmMsNjI6JFZlLDY0OiRWZiw2NjokVmcsMTM2OiRWSjEsMTM4OiRWeiwxMzk6JFZBfSksezEwOlsxLDQ3Ml0sMTM6NDcxLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTI2OiRWOTEsMTM3OlsxLDQ3M10sMTcxOiRWYTEsMjExOjE0OSwyMTI6JFZVLDIxNDokVlYsMjE3OjE1MCwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSxvKCRWdTIsWzIsMzM5XSksezEzOjQ3NCwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezEzOjQ3NSwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sbygkVmsyLFsyLDMxOF0pLHs1MDoyNjgsNTE6JFY4LDg5OiRWdzEsOTY6JFZSMSwxNTA6MjcwLDE2ODoyNjksMjI2OjQ3Nn0sbyhbMSw2LDEwLDExLDE0LDIyLDcxLDkwLDk3LDEwNiwxMTIsMTM1LDEzNywxNDcsMjAwLDIwMSwyMTIsMjE0LDIxOSwyMjAsMjM4XSxbMiwzMjRdLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDEyNjokVjkxLDE3MTokVmExLDIxMzpbMSw0NzddLDIyOTpbMSw0NzhdLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSksbygkVkMyLFsyLDMyNV0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMTI2OiRWOTEsMTcxOiRWYTEsMjEzOlsxLDQ3OV0sMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSxvKCRWajEsWzIsMjU2XSksezEzOjQ4MCwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sbygkVmoxLFsyLDEyN10pLHsxMTA6JFZMMSwxMjU6NDgxLDEyODokVk0xfSxvKCRWVDEsWzIsNjVdKSx7NzE6WzEsNDgyXSwxMjY6JFY5MSwxNzE6JFZhMSwyMTE6MTQ5LDIxMjokVlUsMjE0OiRWViwyMTc6MTUwLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9LHs1MDoyODcsNTE6JFY4LDU3OjI4OCw1ODokVmMsODk6JFZQMSwxNjE6NDgzfSxvKCRWRDIsWzIsMTcyXSksbygkVkQyLFsyLDE3M10pLG8oJFZFMiwkVmIyLHsxNjc6Mzc1LDE1MDozNzYsMTY4OjM3NywxNjk6Mzc4LDUwOjM4MiwxNDY6NDg0LDUxOiRWOCw4OTokVncxLDk2OiRWUjEsMTcwOiRWYzIsMTcxOiRWZDIsMTcyOiRWZTJ9KSxvKCRWajEsWzIsMTcxXSksezU6NDg1LDEwOiRWMSw4OTokVm0xLDE0MTo0ODYsMTQ0OiRWQ30sbygkVmoxLFsyLDE3OV0pLHs5MDpbMSw0ODddLDEyNjokVjkxLDE3MTokVmExLDIxMToxNDksMjEyOiRWVSwyMTQ6JFZWLDIxNzoxNTAsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0sbygkVkQxLFsyLDE5OF0pLG8oJFZEMSxbMiwyMDFdKSxvKCRWVTEsWzIsMTFdKSx7MTM6NDg4LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWRDEsWzIsMjIzXSksezEzOjQ4OSwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTEyOlsyLDI3NV0sMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezExMjpbMiwyNzZdLDEyNjokVjkxLDE3MTokVmExLDIxMToxNDksMjEyOiRWVSwyMTQ6JFZWLDIxNzoxNTAsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0sbygkVnQxLFsyLDIyXSksbygkVnQxLFsyLDI0XSksezY6JFY1MSw5OjQ5MSwxMTokVkYyLDEyNjokVjkxLDEzMjo0OTAsMTcxOiRWYTEsMjExOjE0OSwyMTI6JFZVLDIxNDokVlYsMjE3OjE1MCwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSx7NjokVjUxLDk6NDkxLDExOiRWRjIsMTI2OiRWOTEsMTMyOjQ5MywxNzE6JFZhMSwyMTE6MTQ5LDIxMjokVlUsMjE0OiRWViwyMTc6MTUwLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9LHs1OjQ5NCwxMDokVjEsMTI2OiRWOTEsMTcxOiRWYTEsMjExOjE0OSwyMTI6JFZVLDIxNDokVlYsMjE3OjE1MCwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSxvKCRWdTIsWzIsMzQxXSksbygkVmoxLFsyLDI5M10pLHs1OjQ5NSwxMDokVjF9LG8oJFZqMSxbMiwyOTRdKSx7MTE6WzEsNDk2XSwyMzI6WzEsNDk3XSwyMzM6NDI4LDIzNDokVl8xfSxvKCRWajEsWzIsMzMzXSksezU6NDk4LDEwOiRWMX0sbygkVnYyLFsyLDMzNl0pLHs1OjQ5OSwxMDokVjEsMTQ6WzEsNTAwXX0sbygkVkcyLFsyLDI4OF0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMTI2OiRWOTEsMTcxOiRWYTEsMjEyOiRWVSwyMTQ6JFZWLDIxOTokVlgsMjIwOiRWWSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0pLG8oJFYkMSxbMiw5Nl0sezEwNzo1MDEsMTA6WzEsNTAyXSwyMTpbMSw1MDNdfSksezY6JFZ4MiwxMTQ6NTA0LDExNjokVjEyfSx7NjpbMSw1MDVdfSxvKCRWQTEsWzIsMTA0XSksbygkVkExLFsyLDEwNl0pLHsxMzo1MDYsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHsxMTI6WzEsNTA3XSwxMjY6JFY5MSwxNzE6JFZhMSwyMTE6MTQ5LDIxMjokVlUsMjE0OiRWViwyMTc6MTUwLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9LHsxMzo1MDgsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oJFZBMSxbMiwxMDldKSx7MTM6NTA5LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTM6NTExLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMTg6NTEwLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHsxMDY6WzEsNTEyXX0sezIyOlsxLDUxM119LG8oJFYyMixbMiwxNjNdKSx7NjokVjUxLDk6NDUyLDEwOiRWdzIsMjI6WzEsNTE0XX0sbygkVnQxLFsyLDI3XSksbygkVjMyLFsyLDMyXSksbygkVnQxLFsyLDI4XSksezEzNzpbMSw1MTVdfSx7OTc6WzEsNTE2XSwxMjY6JFY5MSwxNzE6JFZhMSwyMTE6MTQ5LDIxMjokVlUsMjE0OiRWViwyMTc6MTUwLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9LG8oJFY2MixbMiwyNzBdKSx7MTI6MjI4LDEzOjM2MSwxNToyMzAsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxMzg6JFZ6LDEzOTokVkEsMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTcwOiRWSiwxNzE6JFZHMSwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDI6NTE3LDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezEwOiRWRTEsMTI6MjI4LDEzOjM2MSwxNToyMzAsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDExOTo1MTgsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDEzODokVnosMTM5OiRWQSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzA6JFZKLDE3MTokVkcxLDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwMjoyMjYsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWOTIsWzIsMjc4XSksezY6JFY1MSw5OjUyMCwxMDokVncyLDExOiRWRjIsMTMyOjUxOX0sezkwOlsxLDUyMV0sMTI2OiRWOTEsMTcxOiRWYTEsMjExOjE0OSwyMTI6JFZVLDIxNDokVlYsMjE3OjE1MCwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSx7OTA6WzEsNTIyXSwxMjY6JFY5MSwxNzE6JFZhMSwyMTE6MTQ5LDIxMjokVlUsMjE0OiRWViwyMTc6MTUwLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9LG8oJFZPMSxbMiw4OV0pLHszMjokVjcsNTE6WzEsNTI0XSw2MToxMTYsNjI6JFZlLDYzOjUyNSw2NDokVmYsNjU6MTE3LDY2OiRWZyw4OTpbMSw1MjZdLDk5OjUyM30sezU6NTI3LDEwOiRWMX0sezUwOjM4Miw1MTokVjgsODk6JFZ3MSw5NjokVlIxLDE1MDozNzYsMTY3OjUyOCwxNjg6Mzc3LDE2OTozNzgsMTcwOiRWYzIsMTcxOiRWZDIsMTcyOiRWZTJ9LHsxMzo1MjksMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oJFZBMixbMiwxOTJdKSxvKCRWQTIsWzIsMTkzXSksbygkVkEyLFsyLDE5NF0pLHs1OjUzMCwxMDokVjF9LG8oWzEsNiwxMCwxMSwxNCwyMSwyMiw3MSw4OCw4OSw5MCw5NywxMDYsMTExLDExMiwxMTcsMTI2LDEzNSwxMzcsMTQ0LDE0NywxNzEsMTgwLDE4MSwxODMsMTk2LDIwMCwyMDEsMjEyLDIxMywyMTQsMjE5LDIyMCwyMjcsMjI4LDIyOSwyMzgsMjM5LDI0MiwyNDMsMjQ2LDI0NywyNDhdLFsyLDI0M10pLHsxNToyNTEsMzI6JFY3LDUwOjI1Miw1MTokVjgsNTI6MjU1LDUzOiRWOSw1NDokVmEsNTU6MjU2LDU2OiRWYiw1NzoyNTMsNTg6JFZjLDYxOjExNiw2MjokVmUsNjM6MjU0LDY0OiRWZiw2NToxMTcsNjY6JFZnLDEzMzo1MzEsMTM0OjI1MCwxMzY6JFZKMSwxMzg6JFZ6LDEzOTokVkF9LG8oWzYsMTAsMTEsMTRdLCRWSTEsezYxOjExNiw2NToxMTcsMTMzOjI0OSwxMzQ6MjUwLDE1OjI1MSw1MDoyNTIsNTc6MjUzLDYzOjI1NCw1MjoyNTUsNTU6MjU2LDE5MTo1MzIsMzI6JFY3LDUxOiRWOCw1MzokVjksNTQ6JFZhLDU2OiRWYiw1ODokVmMsNjI6JFZlLDY0OiRWZiw2NjokVmcsMTM2OiRWSjEsMTM4OiRWeiwxMzk6JFZBfSksbygkVmcyLFsyLDI0Nl0pLG8oJFZnMixbMiwxMzldLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDEyNjokVjkxLDE3MTokVmExLDIxMjokVlUsMjE0OiRWViwyMTk6JFZYLDIyMDokVlksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSx7MTM6NTMzLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWaDIsWzIsMTQ3XSksbygkVmoyLFsyLDMwMF0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMTI2OiRWOTEsMTcxOiRWYTEsMjEyOiRWVSwyMTQ6JFZWLDIxOTokVlgsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSxvKCRWajIsWzIsMzAyXSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwxMjY6JFY5MSwxNzE6JFZhMSwyMTI6JFZVLDIxNDokVlYsMjE5OiRWWCwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0pLG8oJFZrMixbMiwzMjNdKSx7MTM6NTM0LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTM6NTM1LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTM6NTM2LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKFsxLDYsMTEsMTQsMjIsNzEsOTAsOTcsMTA2LDExMiwxMzUsMTM3LDE0NywyMDAsMjAxLDIxMywyMjAsMjI5LDIzOF0sWzIsMjU3XSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCw1OjUzNywxMDokVjEsMTI2OiRWOTEsMTcxOiRWYTEsMjEyOiRWVSwyMTQ6JFZWLDIxOTokVlgsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSxvKCRWJDEsWzIsMTI4XSx7NTo1MzgsMTA6JFYxfSksbygkVlQxLFsyLDY2XSksezIxOlsxLDUzOV0sMTYyOjU0MCwxNjQ6JFZvMiwxNjU6JFZwMn0sezE0OiRWejIsMjI6WzEsNTQxXX0sbygkVmoxLFsyLDE3N10pLG8oJFZqMSxbMiwxNzhdKSxvKCRWcTIsWzIsMTc2XSksbyhbMSw2LDEwLDExLDE0LDIyLDcxLDkwLDk3LDEwNiwxMTIsMTM1LDEzNywxNDcsMjAwLDIwMSwyMTIsMjEzLDIxNCwyMTksMjIwLDIyOSwyMzgsMjM5XSxbMiwzNDZdLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDEyNjokVjkxLDE3MTokVmExLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSksezExMjpbMiwyNzRdLDEyNjokVjkxLDE3MTokVmExLDIxMToxNDksMjEyOiRWVSwyMTQ6JFZWLDIxNzoxNTAsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0sbygkVmoxLFsyLDEzN10pLHsxMTokVkgyfSxvKCRWajEsWzIsMjgzXSksbygkVmoxLFsyLDM2M10pLG8oJFZ1MixbMiwzNDBdKSxvKFsxLDYsMTAsMTEsMTQsMjIsNzEsOTAsOTcsMTA2LDExMiwxMjYsMTM1LDEzNywxNDcsMTcxLDIwMCwyMDEsMjA3LDIxMiwyMTMsMjE0LDIxOSwyMjAsMjI5LDIzOCwyMzksMjQyLDI0MywyNDYsMjQ3LDI0OF0sWzIsMjk1XSksbygkVmoxLFsyLDMzMV0pLHs1OjU0MywxMDokVjF9LHsxMTpbMSw1NDRdfSxvKCRWdjIsWzIsMzM3XSx7NjpbMSw1NDVdfSksezEzOjU0NiwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sbygkVmoxLFsyLDk3XSksezEwOiRWRTEsMTI6MjI4LDEzOjM2MSwxNToyMzAsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDExOTo1NDcsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDEzODokVnosMTM5OiRWQSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzA6JFZKLDE3MTokVkcxLDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwMjoyMjYsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTA6JFZFMSwxMjoyMjgsMTM6MzYxLDE1OjIzMCwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTE5OjU0OCwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTM4OiRWeiwxMzk6JFZBLDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MDokVkosMTcxOiRWRzEsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjAyOjIyNiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oJFYwMixbMiwxMTRdKSx7MTE0OjU0OSwxMTY6JFYxMn0sezkwOlsxLDU1MF0sMTI2OiRWOTEsMTcxOiRWYTEsMjExOjE0OSwyMTI6JFZVLDIxNDokVlYsMjE3OjE1MCwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSxvKCRWQTEsWzIsMTA1XSksezkwOlsxLDU1MV0sMTI2OiRWOTEsMTcxOiRWYTEsMjExOjE0OSwyMTI6JFZVLDIxNDokVlYsMjE3OjE1MCwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSx7OTA6WzEsNTUyXSwxMjY6JFY5MSwxNzE6JFZhMSwyMTE6MTQ5LDIxMjokVlUsMjE0OiRWViwyMTc6MTUwLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9LG8oJFYwMixbMiwxMTddKSxvKCRWMDIsWzIsMTE4XSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwxMjY6JFY5MSwxNzE6JFZhMSwyMTI6JFZVLDIxNDokVlYsMjE5OiRWWCwyMjA6JFZZLDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSksbygkVmoxLFsyLDk4XSksbygkVmoxLFsyLDE1OF0pLG8oJFZ1MSxbMiwyNjZdKSxvKCRWdTEsWzIsMjk4XSksbygkVnUxLFsyLDI3M10pLG8oJFY5MixbMiwyNzldKSxvKCRWeTIsJFY3Mix7MTE1OjU1MywxNDokVjgyfSksbygkVjkyLFsyLDI4MF0pLHsxMTokVkgyLDEyOjIyOCwxMzozNjEsMTU6MjMwLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTM4OiRWeiwxMzk6JFZBLDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MDokVkosMTcxOiRWRzEsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjAyOjUxNywyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oJFZPMSxbMiw4M10pLG8oJFZPMSxbMiw4NF0pLHs5NzpbMSw1NTRdfSx7OTc6WzIsOTNdfSx7OTc6WzIsOTRdfSx7MTM6NTU1LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWdTEsWzIsMTU1XSksbygkVkEyLFsyLDE4OF0pLG8oJFZBMixbMiwxOTVdLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDEyNjokVjkxLDE3MTokVmExLDIxMjokVlUsMjE0OiRWViwyMTk6JFZYLDIyMDokVlksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSx7OTA6WzEsNTU2XX0sbygkVmcyLFsyLDI0N10pLG8oJFZ5MiwkVjcyLHsxMTU6NTU3LDE0OiRWZjJ9KSx7NjokVjUxLDk6NDkxLDExOiRWRjIsMTI2OiRWOTEsMTMyOjU1OCwxNzE6JFZhMSwyMTE6MTQ5LDIxMjokVlUsMjE0OiRWViwyMTc6MTUwLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9LG8oWzEsNiwxMCwxMSwxNCwyMiw3MSw5MCw5NywxMDYsMTEyLDEzNSwxMzcsMTQ3LDIwMCwyMDEsMjEyLDIxMywyMTQsMjE5LDIyMCwyMzhdLFsyLDMyNl0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMTI2OiRWOTEsMTcxOiRWYTEsMjI5OlsxLDU1OV0sMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSxvKCRWQzIsWzIsMzI4XSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwxMjY6JFY5MSwxNzE6JFZhMSwyMTM6WzEsNTYwXSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0pLG8oJFZZMSxbMiwzMjddLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDEyNjokVjkxLDE3MTokVmExLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSksbygkVmoxLFsyLDI1OF0pLG8oJFZqMSxbMiwxMjldKSxvKCRWRTIsJFZiMix7MTY3OjM3NSwxNTA6Mzc2LDE2ODozNzcsMTY5OjM3OCw1MDozODIsMTQ2OjU2MSw1MTokVjgsODk6JFZ3MSw5NjokVlIxLDE3MDokVmMyLDE3MTokVmQyLDE3MjokVmUyfSksbygkVmoxLFsyLDE2OV0pLHsxNjI6NTYyLDE2NDokVm8yLDE2NTokVnAyfSxvKCRWajEsWzIsMjgyXSksezY6JFY1MSw5OjQ5MSwxMTokVkYyLDEzMjo1NjN9LG8oJFZqMSxbMiwzMzRdKSxvKCRWdjIsWzIsMzM4XSksbygkVkcyLFsyLDI4OV0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMTI2OiRWOTEsMTcxOiRWYTEsMjEyOiRWVSwyMTQ6JFZWLDIxOTokVlgsMjIwOiRWWSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0pLG8oJFZJMiwkVjcyLHsxMTU6NTY1LDExOlsxLDU2NF0sMTQ6JFY4Mn0pLG8oJFZJMiwkVjcyLHsxMTU6NTY1LDE0OiRWODIsMjI6WzEsNTY2XX0pLG8oJFYwMixbMiwxMTVdKSxvKCRWQTEsWzIsMTA3XSksbygkVkExLFsyLDEwOF0pLG8oJFZBMSxbMiwxMTFdKSx7NjokVjUxLDk6NTIwLDEwOiRWdzIsMTE6JFZGMiwxMzI6NTY3fSxvKCRWTzEsWzIsOTBdKSx7OTA6WzEsNTY4XSwxMjY6JFY5MSwxNzE6JFZhMSwyMTE6MTQ5LDIxMjokVlUsMjE0OiRWViwyMTc6MTUwLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9LG8oJFZ1MSxbMiwxNTZdKSx7NjokVjUxLDk6NTcwLDEwOiRWQjIsMTE6JFZGMiwxMzI6NTY5fSxvKCRWZzIsWzIsMTQwXSksezEzOjU3MSwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezEzOjU3MiwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezE0OiRWejIsMjI6WzEsNTczXX0sbygkVmoxLFsyLDE3MF0pLG8oJFZqMSxbMiwzMzJdKSxvKCRWajEsWzIsMTE5XSksezY6JFY1MSw5OjQ1MiwxMDokVncyfSxvKCRWajEsWzIsMTIwXSksbygkVjkyLFsyLDI4MV0pLHs5NzpbMiw5NV19LG8oJFZnMixbMiwyNDhdKSx7MTE6JFZIMiwxNToyNTEsMzI6JFY3LDUwOjI1Miw1MTokVjgsNTI6MjU1LDUzOiRWOSw1NDokVmEsNTU6MjU2LDU2OiRWYiw1NzoyNTMsNTg6JFZjLDYxOjExNiw2MjokVmUsNjM6MjU0LDY0OiRWZiw2NToxMTcsNjY6JFZnLDEzMzo1MzEsMTM0OjI1MCwxMzY6JFZKMSwxMzg6JFZ6LDEzOTokVkF9LG8oJFZZMSxbMiwzMjldLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDEyNjokVjkxLDE3MTokVmExLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSksbygkVlkxLFsyLDMzMF0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMTI2OiRWOTEsMTcxOiRWYTEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSx7MTYyOjU3NCwxNjQ6JFZvMiwxNjU6JFZwMn0sbygkVmoxLFsyLDE2OF0pXSxcbmRlZmF1bHRBY3Rpb25zOiB7MTM1OlsyLDNdLDE2MzpbMiwyNjRdLDMyNDpbMiwyNDJdLDUyNDpbMiw5M10sNTI1OlsyLDk0XSw1Njg6WzIsOTVdfSxcbnBhcnNlRXJyb3I6IGZ1bmN0aW9uIHBhcnNlRXJyb3Ioc3RyLCBoYXNoKSB7XG4gICAgaWYgKGhhc2gucmVjb3ZlcmFibGUpIHtcbiAgICAgICAgdGhpcy50cmFjZShzdHIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihzdHIpO1xuICAgIH1cbn0sXG5wYXJzZTogZnVuY3Rpb24gcGFyc2UoaW5wdXQpIHtcblxuICAgIC8vIEZvciBJbWJhIHdlIGFyZSBnb2luZyB0byBkcm9wIG1vc3Qgb2YgdGhlIGZlYXR1cmVzIHRoYXQgYXJlIG5vdCB1c2VkXG4gICAgLy8gTG9jYXRpb25zIGFyZSBwcm92aWRlZCBieSB0aGUgdG9rZW5zIGZyb20gdGhlIGxleGVyIGRpcmVjdGx5IC0gc28gZHJvcCB5eWxsb2NcbiAgICAvLyBXZSBkb250IHJlYWxseSBuZWVkIHRoZSBzaGFyZWQgc3RhdGUgKGl0IHNlZW1zKVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBzdGFjayA9IFswXSxcbiAgICAgICAgdHN0YWNrID0gW10sIC8vIHRva2VuIHN0YWNrXG4gICAgICAgIHZzdGFjayA9IFtudWxsXSwgLy8gc2VtYW50aWMgdmFsdWUgc3RhY2tcbiAgICAgICAgdGFibGUgPSB0aGlzLnRhYmxlLFxuICAgICAgICB5eXRleHQgPSAnJyxcbiAgICAgICAgeXlsaW5lbm8gPSAwLFxuICAgICAgICB5eWxlbmcgPSAwLFxuICAgICAgICByZWNvdmVyaW5nID0gMCxcbiAgICAgICAgVEVSUk9SID0gMixcbiAgICAgICAgRU9GID0gMTtcblxuICAgIC8vIHZhciBhcmdzID0gbHN0YWNrLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAvL3RoaXMucmVkdWN0aW9uQ291bnQgPSB0aGlzLnNoaWZ0Q291bnQgPSAwO1xuXG4gICAgdmFyIGxleGVyID0gT2JqZWN0LmNyZWF0ZSh0aGlzLmxleGVyKTtcbiAgICB2YXIgeXkgPSB0aGlzLnl5O1xuXG4gICAgbGV4ZXIuc2V0SW5wdXQoaW5wdXQseXkpO1xuXG4gICAgaWYgKHR5cGVvZiB5eS5wYXJzZUVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucGFyc2VFcnJvciA9IHl5LnBhcnNlRXJyb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXJzZUVycm9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLnBhcnNlRXJyb3I7IC8vIHdoYXQ/XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9wU3RhY2sgKG4pIHtcbiAgICAgICAgc3RhY2subGVuZ3RoID0gc3RhY2subGVuZ3RoIC0gMiAqIG47XG4gICAgICAgIHZzdGFjay5sZW5ndGggPSB2c3RhY2subGVuZ3RoIC0gbjtcbiAgICB9XG5cbiAgICB2YXIgc3ltYm9sLCBwcmVFcnJvclN5bWJvbCwgc3RhdGUsIGFjdGlvbiwgYSwgciwgeXl2YWwgPSB7fSwgcCwgbGVuLCBuZXdTdGF0ZSwgZXhwZWN0ZWQ7XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVFcnJvcigpe1xuICAgICAgICB2YXIgZXJyb3JfcnVsZV9kZXB0aDtcbiAgICAgICAgdmFyIGVyclN0ciA9ICcnO1xuXG4gICAgICAgIC8vIFJldHVybiB0aGUgcnVsZSBzdGFjayBkZXB0aCB3aGVyZSB0aGUgbmVhcmVzdCBlcnJvciBydWxlIGNhbiBiZSBmb3VuZC5cbiAgICAgICAgLy8gUmV0dXJuIEZBTFNFIHdoZW4gbm8gZXJyb3IgcmVjb3ZlcnkgcnVsZSB3YXMgZm91bmQuXG4gICAgICAgIC8vIHdlIGhhdmUgbm8gcnVsZXMgbm93XG4gICAgICAgIGZ1bmN0aW9uIGxvY2F0ZU5lYXJlc3RFcnJvclJlY292ZXJ5UnVsZShzdGF0ZSkge1xuICAgICAgICAgICAgdmFyIHN0YWNrX3Byb2JlID0gc3RhY2subGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHZhciBkZXB0aCA9IDA7XG5cbiAgICAgICAgICAgIC8vIHRyeSB0byByZWNvdmVyIGZyb20gZXJyb3JcbiAgICAgICAgICAgIGZvcig7Oykge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBlcnJvciByZWNvdmVyeSBydWxlIGluIHRoaXMgc3RhdGVcbiAgICAgICAgICAgICAgICBpZiAoKFRFUlJPUi50b1N0cmluZygpKSBpbiB0YWJsZVtzdGF0ZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlcHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT09IDAgfHwgc3RhY2tfcHJvYmUgPCAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gTm8gc3VpdGFibGUgZXJyb3IgcmVjb3ZlcnkgcnVsZSBhdmFpbGFibGUuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YWNrX3Byb2JlIC09IDI7IC8vIHBvcFN0YWNrKDEpOiBbc3ltYm9sLCBhY3Rpb25dXG4gICAgICAgICAgICAgICAgc3RhdGUgPSBzdGFja1tzdGFja19wcm9iZV07XG4gICAgICAgICAgICAgICAgKytkZXB0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVjb3ZlcmluZykge1xuICAgICAgICAgICAgLy8gZmlyc3Qgc2VlIGlmIHRoZXJlJ3MgYW55IGNoYW5jZSBhdCBoaXR0aW5nIGFuIGVycm9yIHJlY292ZXJ5IHJ1bGU6XG4gICAgICAgICAgICBlcnJvcl9ydWxlX2RlcHRoID0gbG9jYXRlTmVhcmVzdEVycm9yUmVjb3ZlcnlSdWxlKHN0YXRlKTtcblxuICAgICAgICAgICAgLy8gUmVwb3J0IGVycm9yXG4gICAgICAgICAgICBleHBlY3RlZCA9IFtdO1xuXG4gICAgICAgICAgICB2YXIgdHN5bSA9IGxleGVyLnl5dGV4dDtcbiAgICAgICAgICAgIHZhciB0b2sgPSBzZWxmLnRlcm1pbmFsc19bc3ltYm9sXSB8fCBzeW1ib2w7XG4gICAgICAgICAgICB2YXIgdGxvYyA9IHRzeW0gPyB0c3ltLl9sb2MgOiAtMTtcbiAgICAgICAgICAgIHZhciB0cG9zID0gdGxvYyAhPSAtMSA/IFwiW1wiICsgdHN5bS5fbG9jICsgXCI6XCIgKyB0c3ltLl9sZW4gKyBcIl1cIiA6ICdbMDowXSc7XG5cbiAgICAgICAgICAgIGlmIChsZXhlci5zaG93UG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBlcnJTdHIgPSAnUGFyc2UgZXJyb3IgYXQgJysodHBvcykrXCI6XFxuXCIrbGV4ZXIuc2hvd1Bvc2l0aW9uKCkrXCJcXG5FeHBlY3RpbmcgXCIrZXhwZWN0ZWQuam9pbignLCAnKSArIFwiLCBnb3QgJ1wiICsgKHNlbGYudGVybWluYWxzX1tzeW1ib2xdIHx8IHN5bWJvbCkrIFwiJ1wiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlcnJTdHIgPSAnUGFyc2UgZXJyb3IgYXQgJysodHBvcykrXCI6IFVuZXhwZWN0ZWQgXCIgKyAoc3ltYm9sID09IEVPRiA/IFwiZW5kIG9mIGlucHV0XCIgOiAoXCInXCIrKHRvaykrXCInXCIpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5wYXJzZUVycm9yKGVyclN0ciwge1xuICAgICAgICAgICAgICAgIGxleGVyOiBsZXhlcixcbiAgICAgICAgICAgICAgICB0ZXh0OiBsZXhlci5tYXRjaCxcbiAgICAgICAgICAgICAgICB0b2tlbjogdG9rLFxuICAgICAgICAgICAgICAgIGxpbmU6IGxleGVyLnl5bGluZW5vLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgICAgICAgICAgICByZWNvdmVyYWJsZTogKGVycm9yX3J1bGVfZGVwdGggIT09IGZhbHNlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJlRXJyb3JTeW1ib2wgIT09IEVPRikge1xuICAgICAgICAgICAgZXJyb3JfcnVsZV9kZXB0aCA9IGxvY2F0ZU5lYXJlc3RFcnJvclJlY292ZXJ5UnVsZShzdGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBqdXN0IHJlY292ZXJlZCBmcm9tIGFub3RoZXIgZXJyb3JcbiAgICAgICAgaWYgKHJlY292ZXJpbmcgPT0gMykge1xuICAgICAgICAgICAgaWYgKHN5bWJvbCA9PT0gRU9GIHx8IHByZUVycm9yU3ltYm9sID09PSBFT0YpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyU3RyIHx8ICdQYXJzaW5nIGhhbHRlZCB3aGlsZSBzdGFydGluZyB0byByZWNvdmVyIGZyb20gYW5vdGhlciBlcnJvci4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZGlzY2FyZCBjdXJyZW50IGxvb2thaGVhZCBhbmQgZ3JhYiBhbm90aGVyXG4gICAgICAgICAgICB5eXRleHQgPSBsZXhlci55eXRleHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0cnkgdG8gcmVjb3ZlciBmcm9tIGVycm9yXG4gICAgICAgIGlmIChlcnJvcl9ydWxlX2RlcHRoID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyclN0ciB8fCAnUGFyc2luZyBoYWx0ZWQuIE5vIHN1aXRhYmxlIGVycm9yIHJlY292ZXJ5IHJ1bGUgYXZhaWxhYmxlLicpO1xuICAgICAgICB9XG4gICAgICAgIHBvcFN0YWNrKGVycm9yX3J1bGVfZGVwdGgpO1xuICAgICAgICBwcmVFcnJvclN5bWJvbCA9IChzeW1ib2wgPT0gVEVSUk9SID8gbnVsbCA6IHN5bWJvbCk7IC8vIHNhdmUgdGhlIGxvb2thaGVhZCB0b2tlblxuICAgICAgICBzeW1ib2wgPSBURVJST1I7ICAgICAgICAgLy8gaW5zZXJ0IGdlbmVyaWMgZXJyb3Igc3ltYm9sIGFzIG5ldyBsb29rYWhlYWRcbiAgICAgICAgc3RhdGUgPSBzdGFja1tzdGFjay5sZW5ndGgtMV07XG4gICAgICAgIGFjdGlvbiA9IHRhYmxlW3N0YXRlXSAmJiB0YWJsZVtzdGF0ZV1bVEVSUk9SXTtcbiAgICAgICAgcmVjb3ZlcmluZyA9IDM7IC8vIGFsbG93IDMgcmVhbCBzeW1ib2xzIHRvIGJlIHNoaWZ0ZWQgYmVmb3JlIHJlcG9ydGluZyBhIG5ldyBlcnJvclxuICAgIH1cblxuXG4gICAgdmFyIF9fc3ltID0gdGhpcy5zeW1ib2xzXztcbiAgICB2YXIgX19wcm9kID0gdGhpcy5wcm9kdWN0aW9uc187XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAvLyByZXRyZWl2ZSBzdGF0ZSBudW1iZXIgZnJvbSB0b3Agb2Ygc3RhY2tcbiAgICAgICAgc3RhdGUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAoc3ltYm9sID09PSBudWxsIHx8IHR5cGVvZiBzeW1ib2wgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHN5bWJvbCA9IF9fc3ltW2xleGVyLmxleCgpXSB8fCBFT0Y7XG4gICAgICAgIH1cbiAgICAgICAgYWN0aW9uID0gdGFibGVbc3RhdGVdICYmIHRhYmxlW3N0YXRlXVtzeW1ib2xdO1xuXG5faGFuZGxlX2Vycm9yOlxuICAgICAgICBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ3VuZGVmaW5lZCcgfHwgIWFjdGlvbi5sZW5ndGggfHwgIWFjdGlvblswXSkge1xuICAgICAgICAgICAgaGFuZGxlRXJyb3IoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoYWN0aW9uWzBdKSB7XG4gICAgICAgICAgICBjYXNlIDE6IC8vIHNoaWZ0XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChzeW1ib2wpO1xuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goYWN0aW9uWzFdKTsgLy8gcHVzaCBzdGF0ZVxuICAgICAgICAgICAgICAgIHZzdGFjay5wdXNoKGxleGVyLnl5dGV4dCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgc3ltYm9sID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoIXByZUVycm9yU3ltYm9sKSB7IC8vIG5vcm1hbCBleGVjdXRpb24vbm8gZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgeXl0ZXh0ID0gbGV4ZXIueXl0ZXh0O1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3ZlcmluZyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY292ZXJpbmctLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVycm9yIGp1c3Qgb2NjdXJyZWQsIHJlc3VtZSBvbGQgbG9va2FoZWFkIGYvIGJlZm9yZSBlcnJvclxuICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBwcmVFcnJvclN5bWJvbDtcbiAgICAgICAgICAgICAgICAgICAgcHJlRXJyb3JTeW1ib2wgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGxlbiA9IF9fcHJvZFthY3Rpb25bMV1dWzFdO1xuICAgICAgICAgICAgICAgIC8vIHBlcmZvcm0gc2VtYW50aWMgYWN0aW9uXG4gICAgICAgICAgICAgICAgeXl2YWwuJCA9IHZzdGFja1t2c3RhY2subGVuZ3RoLWxlbl07XG4gICAgICAgICAgICAgICAgciA9IHRoaXMucGVyZm9ybUFjdGlvbih5eXZhbCwgeXl0ZXh0LCB5eSwgYWN0aW9uWzFdLCB2c3RhY2spO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgd2hpbGUobGVuID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHZzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgbGVuLS07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChfX3Byb2RbYWN0aW9uWzFdXVswXSk7XG4gICAgICAgICAgICAgICAgbmV3U3RhdGUgPSB0YWJsZVtzdGFja1tzdGFjay5sZW5ndGgtMl1dW3N0YWNrW3N0YWNrLmxlbmd0aC0xXV07XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChuZXdTdGF0ZSk7XG4gICAgICAgICAgICAgICAgdnN0YWNrLnB1c2goeXl2YWwuJCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufX07XG5cbmZ1bmN0aW9uIFBhcnNlciAoKSB7XG4gIHRoaXMueXkgPSB7fTtcbn1cblBhcnNlci5wcm90b3R5cGUgPSBwYXJzZXI7cGFyc2VyLlBhcnNlciA9IFBhcnNlcjtcbnJldHVybiBuZXcgUGFyc2VyO1xufSkoKTtcblxuXG5pZiAodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuZXhwb3J0cy5wYXJzZXIgPSBwYXJzZXI7XG5leHBvcnRzLlBhcnNlciA9IHBhcnNlci5QYXJzZXI7XG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcGFyc2VyLnBhcnNlLmFwcGx5KHBhcnNlciwgYXJndW1lbnRzKTsgfTtcbi8vIGV4cG9ydHMubWFpbiA9IGZ1bmN0aW9uIGNvbW1vbmpzTWFpbihhcmdzKSB7XG4vLyAgICAgaWYgKCFhcmdzWzFdKSB7XG4vLyAgICAgICAgIGNvbnNvbGUubG9nKCdVc2FnZTogJythcmdzWzBdKycgRklMRScpO1xuLy8gICAgICAgICBwcm9jZXNzLmV4aXQoMSk7XG4vLyAgICAgfVxuLy8gICAgIHZhciBzb3VyY2UgPSByZXF1aXJlKCdmcycpLnJlYWRGaWxlU3luYyhyZXF1aXJlKCdwYXRoJykubm9ybWFsaXplKGFyZ3NbMV0pLCBcInV0ZjhcIik7XG4vLyAgICAgcmV0dXJuIGV4cG9ydHMucGFyc2VyLnBhcnNlKHNvdXJjZSk7XG4vLyB9O1xuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIHJlcXVpcmUubWFpbiA9PT0gbW9kdWxlKSB7XG4gIGV4cG9ydHMubWFpbihwcm9jZXNzLmFyZ3Yuc2xpY2UoMSkpO1xufVxufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWIvY29tcGlsZXIvcGFyc2VyLmpzXG4gKiogbW9kdWxlIGlkID0gNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0bW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufVxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBzZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAod2VicGFjaykvfi9ub2RlLWxpYnMtYnJvd3Nlci9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xuICoqIG1vZHVsZSBpZCA9IDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIiMgVE9ETyBDcmVhdGUgRXhwcmVzc2lvbiAtIG1ha2UgYWxsIGV4cHJlc3Npb25zIGluaGVyaXQgZnJvbSB0aGVzZT9cblxuZXh0ZXJuIHBhcnNlSW50XG5cbnZhciBoZWxwZXJzID0gcmVxdWlyZSAnLi9oZWxwZXJzJ1xudmFyIEVSUiA9IHJlcXVpcmUgJy4vZXJyb3JzJ1xudmFyIHY4ID0gbnVsbCAjIHJlcXVpcmUgJ3Y4LW5hdGl2ZXMnXG5cbnZhciBUID0gcmVxdWlyZSAnLi90b2tlbidcbnZhciBUb2tlbiA9IFQuVG9rZW5cblxuaW1wb3J0IFNvdXJjZU1hcCBmcm9tICcuL3NvdXJjZW1hcCdcblxuZXhwb3J0IHZhciBBU1QgPSB7fVxuXG4jIEhlbHBlcnMgZm9yIG9wZXJhdG9yc1xuZXhwb3J0IHZhciBPUCA9IGRvIHxvcCwgbCwgcnxcblx0dmFyIG8gPSBTdHJpbmcob3ApXG5cdCMgY29uc29sZS5sb2cgXCJvcGVyYXRvclwiLG9cblx0c3dpdGNoIG9cblx0XHR3aGVuICcuJ1xuXHRcdFx0ciA9IElkZW50aWZpZXIubmV3KHIpIGlmIHIgaXNhIFN0cmluZ1xuXHRcdFx0IyByID0gci52YWx1ZSBpZiByIGlzYSBWYXJPckFjY2Vzc1xuXHRcdFx0QWNjZXNzLm5ldyhvcCxsLHIpXG5cdFx0d2hlbiAnPSdcblx0XHRcdHJldHVybiBUdXBsZUFzc2lnbi5uZXcob3AsbCxyKSBpZiBsIGlzYSBUdXBsZVxuXHRcdFx0QXNzaWduLm5ldyhvcCxsLHIpXG5cblx0XHR3aGVuICc/PScsJ3x8PScsJyYmPSdcblx0XHRcdENvbmRpdGlvbmFsQXNzaWduLm5ldyhvcCxsLHIpXG5cdFx0d2hlbiAnKz0nLCctPScsJyo9JywnLz0nLCdePScsJyU9J1xuXHRcdFx0Q29tcG91bmRBc3NpZ24ubmV3KG9wLGwscilcblxuXHRcdHdoZW4gJz8uJ1xuXHRcdFx0aWYgciBpc2EgVmFyT3JBY2Nlc3Ncblx0XHRcdFx0IyBjb25zb2xlLmxvZyBcImlzIHZhciBvciBhY2Nlc3NcIlxuXHRcdFx0XHRyID0gci52YWx1ZVxuXHRcdFx0IyBkZXBlbmRzIG9uIHRoZSByaWdodCBzaWRlIC0gdGhpcyBpcyB3cm9uZ1xuXHRcdFx0UHJvcGVydHlBY2Nlc3MubmV3KG9wLGwscilcblxuXHRcdHdoZW4gJ2luc3RhbmNlb2YnXG5cdFx0XHRJbnN0YW5jZU9mLm5ldyhvcCxsLHIpXG5cdFx0d2hlbiAnaW4nXG5cdFx0XHRJbi5uZXcob3AsbCxyKVxuXHRcdHdoZW4gJ3R5cGVvZidcblx0XHRcdFR5cGVPZi5uZXcob3AsbCxyKVxuXHRcdHdoZW4gJ2RlbGV0ZSdcblx0XHRcdERlbGV0ZS5uZXcob3AsbCxyKVxuXHRcdHdoZW4gJy0tJywnKysnLCchJywn4oiaJ1xuXHRcdFx0VW5hcnlPcC5uZXcob3AsbCxyKVxuXHRcdHdoZW4gJz4nLCc8JywnPj0nLCc8PScsJz09JywnPT09JywnIT0nLCchPT0nXG5cdFx0XHRDb21wYXJpc29uT3AubmV3KG9wLGwscilcblx0XHR3aGVuICfiiKknLCfiiKonXG5cdFx0XHRNYXRoT3AubmV3KG9wLGwscilcblx0XHR3aGVuICcuLicsJy4uLidcblx0XHRcdFJhbmdlLm5ldyhvcCxsLHIpXG5cdFx0ZWxzZVxuXHRcdFx0T3AubmV3KG9wLGwscilcblxuZXhwb3J0IHZhciBPUF9DT01QT1VORCA9IGRvIHxzeW0sb3AsbCxyfFxuXHQjIGNvbnNvbGUubG9nIFwiPy4gc29hayBvcGVyYXRvclwiLHN5bVxuXHRpZiBzeW0gPT0gJz8uJ1xuXHRcdGNvbnNvbGUubG9nIFwiPy4gc29hayBvcGVyYXRvclwiXG5cdFx0cmV0dXJuIG51bGxcblx0aWYgc3ltID09ICc/PScgb3Igc3ltID09ICd8fD0nIG9yIHN5bSA9PSAnJiY9J1xuXHRcdHJldHVybiBDb25kaXRpb25hbEFzc2lnbi5uZXcob3AsbCxyKVxuXHRlbHNlXG5cdFx0cmV0dXJuIENvbXBvdW5kQXNzaWduLm5ldyhvcCxsLHIpXG5cbnZhciBPUFRTID0ge31cbnZhciBST09UID0gbnVsbFxuXG5leHBvcnQgdmFyIE5PREVTID0gW11cblxudmFyIExJVCA9IGRvIHx2YWx8XG5cdExpdGVyYWwubmV3KHZhbClcblxudmFyIFNZTSA9IGRvIHx2YWx8XG5cdFN5bWJvbC5uZXcodmFsKVxuXG52YXIgSUYgPSBkbyB8Y29uZCxib2R5LGFsdHxcblx0dmFyIG5vZGUgPSBJZi5uZXcoY29uZCxib2R5KVxuXHRub2RlLmFkZEVsc2UoYWx0KSBpZiBhbHRcblx0bm9kZVxuXG52YXIgRk4gPSBkbyB8cGFycyxib2R5fFxuXHRGdW5jLm5ldyhwYXJzLGJvZHkpXG5cbnZhciBDQUxMID0gZG8gfGNhbGxlZSxwYXJzID0gW118XG5cdCMgcG9zc2libHkgcmV0dXJuIGluc3RlYWQoISlcblx0Q2FsbC5uZXcoY2FsbGVlLHBhcnMpXG5cbnZhciBDQUxMU0VMRiA9IGRvIHxuYW1lLHBhcnMgPSBbXXxcblx0dmFyIHJlZiA9IElkZW50aWZpZXIubmV3KG5hbWUpXG5cdENhbGwubmV3KE9QKCcuJyxTRUxGLHJlZikscGFycylcblxudmFyIEJMT0NLID0gZG9cblx0QmxvY2sud3JhcChbXTpzbGljZS5jYWxsKGFyZ3VtZW50cykpXG5cbnZhciBXSElMRSA9IGRvIHx0ZXN0LGNvZGV8XG5cdFdoaWxlLm5ldyh0ZXN0KS5hZGRCb2R5KGNvZGUpXG5cbmV4cG9ydCB2YXIgU1BMQVQgPSBkbyB8dmFsdWV8XG5cdGlmIHZhbHVlIGlzYSBBc3NpZ25cblx0XHQjIHAgXCJXQVJOXCJcblx0XHR2YWx1ZS5sZWZ0ID0gU3BsYXQubmV3KHZhbHVlLmxlZnQpXG5cdFx0cmV0dXJuIHZhbHVlXG5cdGVsc2Vcblx0XHRTcGxhdC5uZXcodmFsdWUpXG5cdFx0IyBub3Qgc3VyZSBhYm91dCB0aGlzXG5cbiMgT1AuQVNTSUdOTUVOVCA9IFsgXCI9XCIgLCBcIis9XCIgLCBcIi09XCIgLCBcIio9XCIgLCBcIi89XCIgLCBcIiU9XCIsIFwiPDw9XCIgLCBcIj4+PVwiICwgXCI+Pj49XCIsIFwifD1cIiAsIFwiXj1cIiAsIFwiJj1cIiBdXG4jIE9QLkxPR0lDQUwgPSBbIFwifHxcIiAsIFwiJiZcIiBdXG4jIE9QLlVOQVJZID0gWyBcIisrXCIgLCBcIi0tXCIgXVxuXG52YXIgU0VNSUNPTE9OX1RFU1QgPSAvOyhcXHMqXFwvXFwvLiopP1tcXG5cXHNcXHRdKiQvXG52YXIgUkVTRVJWRURfVEVTVCA9IC9eKGRlZmF1bHR8Y2hhcikkL1xuXG4jIGNhcHR1cmVzIGVycm9yIGZyb20gcGFyc2VyXG5leHBvcnQgZGVmIHBhcnNlRXJyb3Igc3RyLCBvXG5cdCMgY29uc29sZS5sb2cgJ3BhcnNlRXJyb3InLG86dG9rZW5cblxuXHQjIGZpbmQgbmVhcmVzdCB0b2tlblxuXHR2YXIgZXJyXG5cblx0aWYgbzpsZXhlclxuXHRcdHZhciB0b2tlbiA9IG86bGV4ZXI6eXl0ZXh0XG5cdFx0IyBjb25zb2xlLmxvZyBvOmxleGVyOnBvcyx0b2tlbi5AbG9jXG5cdFx0ZXJyID0gRVJSLkltYmFQYXJzZUVycm9yLm5ldyh7bWVzc2FnZTogc3RyfSx7XG5cdFx0XHRwb3M6IG86bGV4ZXI6cG9zXG5cdFx0XHR0b2tlbnM6IG86bGV4ZXI6dG9rZW5zXG5cdFx0XHR0b2tlbjogbzpsZXhlcjp5eXRleHRcblx0XHRcdG1ldGE6IG9cblx0XHR9KVxuXG5cdFx0dGhyb3cgZXJyXG5cblx0XHQjIHNob3VsZCBmaW5kIHRoZSBjbG9zZXN0IHRva2VuIHdpdGggYWN0dWFsIHBvc2l0aW9uXG5cdFx0IyBzdHIgPSBcIlt7dG9rZW4uQGxvY306e3Rva2VuLkBsZW4gfHwgU3RyaW5nKHRva2VuKTpsZW5ndGh9XSB7c3RyfVwiXG5cdHZhciBlID0gRXJyb3IubmV3KHN0cilcblx0ZTpsZXhlciA9IG86bGV4ZXJcblx0ZTpvcHRpb25zID0gb1xuXHR0aHJvdyBlXG5cbmRlZiBjX18gb2JqXG5cdHR5cGVvZiBvYmogPT0gJ3N0cmluZycgPyBvYmogOiBvYmouY1xuXG5kZWYgbWFya19fIHRva1xuXHRpZiB0b2sgYW5kIChPUFRTOnNvdXJjZU1hcElubGluZSBvciBPUFRTOnNvdXJjZU1hcCkgYW5kIHRvazpzb3VyY2VNYXBNYXJrZXJcblx0XHR0b2suc291cmNlTWFwTWFya2VyXG5cdGVsc2Vcblx0XHQnJ1xuXG5kZWYgbnVtX18gbnVtXG5cdE51bS5uZXcobnVtKVxuXG5kZWYgc3RyX18gc3RyXG5cdCMgc2hvdWxkIHBhY2sgaW4gdG9rZW4/IT9cblx0U3RyLm5ldyhzdHIpXG5cbmRlZiBibGtfXyBvYmpcblx0b2JqIGlzYSBBcnJheSA/IEJsb2NrLndyYXAob2JqKSA6IG9ialxuXG5kZWYgc3ltX18gb2JqXG5cdCMgY29uc29sZS5sb2cgXCJzeW0ge29ian1cIlxuXHRoZWxwZXJzLnN5bWJvbGl6ZShTdHJpbmcob2JqKSlcblxuZGVmIGNhcnlfXyBhcnlcblx0YXJ5Lm1hcCh8dnwgdHlwZW9mIHYgPT0gJ3N0cmluZycgPyB2IDogdi5jIClcblxuZGVmIGR1bXBfXyBvYmosIGtleVxuXHRpZiBvYmogaXNhIEFycmF5XG5cdFx0b2JqLm1hcCBkbyB8dnwgdiAmJiB2OmR1bXAgPyB2LmR1bXAoa2V5KSA6IHZcblx0ZWxpZiBvYmogYW5kIG9iajpkdW1wXG5cdFx0b2JqLmR1bXBcblxuZGVmIGNvbXBhY3RfXyBhcnlcblx0aWYgYXJ5IGlzYSBMaXN0Tm9kZVxuXHRcdHJldHVybiBhcnkuY29tcGFjdFxuXG5cdGFyeS5maWx0ZXIgZG8gfHZ8IHYgIT0gdW5kZWZpbmVkICYmIHYgIT0gbnVsbFxuXG5kZWYgcmVkdWNlX18gcmVzLGFyeVxuXHRmb3IgdiBpbiBhcnlcblx0XHR2IGlzYSBBcnJheSA/IHJlZHVjZV9fKHJlcyx2KSA6IHJlcy5wdXNoKHYpXG5cdHJldHVyblxuXG5kZWYgZmxhdHRlbl9fIGFyeSwgY29tcGFjdCA9IG5vXG5cdHZhciBvdXQgPSBbXVxuXHRmb3IgdiBpbiBhcnlcblx0XHR2IGlzYSBBcnJheSA/IHJlZHVjZV9fKG91dCx2KSA6IG91dC5wdXNoKHYpXG5cdHJldHVybiBvdXRcblx0XG5kZWYgQVNULnBhcnNlIHN0ciwgb3B0cyA9IHt9XG5cdHZhciBpbmRlbnQgPSBzdHIubWF0Y2goL1xcdCsvKVswXVxuXHQjIHJlYWxseT8gUmVxdWlyZSB0aGUgY29tcGlsZXIsIG5vdCB0aGlzXG5cdEltYmFjLnBhcnNlKHN0cixvcHRzKVxuXG5kZWYgQVNULmlubGluZSBzdHIsIG9wdHMgPSB7fVxuXHRwYXJzZShzdHIsb3B0cykuYm9keVxuXG5kZWYgQVNULm5vZGUgdHlwLCBwYXJzXG5cdGlmIHR5cCA9PSAnY2FsbCdcblx0XHRpZiBwYXJzWzBdLmMgPT0gJ3JldHVybidcblx0XHRcdHBhcnNbMF0gPSAndGF0YSdcdFxuXHRcdENhbGwubmV3KHBhcnNbMF0scGFyc1sxXSxwYXJzWzJdKVxuXG5cbmRlZiBBU1QuZXNjYXBlQ29tbWVudHMgc3RyXG5cdHJldHVybiAnJyB1bmxlc3Mgc3RyXG5cdHJldHVybiBzdHJcblxuZXhwb3J0IGNsYXNzIEluZGVudGF0aW9uXG5cblx0cHJvcCBvcGVuXG5cdHByb3AgY2xvc2VcblxuXHRkZWYgaW5pdGlhbGl6ZSBhLGJcblx0XHRAb3BlbiA9IGFcblx0XHRAY2xvc2UgPSBiXG5cdFx0c2VsZlxuXG5cdGRlZiBpc0dlbmVyYXRlZFxuXHRcdEBvcGVuIGFuZCBAb3BlbjpnZW5lcmF0ZWRcblxuXHRkZWYgYWxvY1xuXHRcdEBvcGVuIGFuZCBAb3Blbi5AbG9jIG9yIDBcblxuXHRkZWYgYmxvY1xuXHRcdEBjbG9zZSBhbmQgQGNsb3NlLkBsb2Mgb3IgMFxuXG5cdCMgc2hvdWxkIHJhdGhlciBwYXJzZSBhbmQgZXh0cmFjdCB0aGUgY29tbWVudHMsIG5vP1xuXHRkZWYgd3JhcCBzdHJcblx0XHQjIHZhciBwcmUsIHBvc3Rcblx0XG5cdFx0IyBjb25zb2xlLmxvZyBcIklOREVOVCB7QG9wZW4gYW5kIEpTT04uc3RyaW5naWZ5KEBvcGVuLkBtZXRhKX1cIlxuXHRcdCMgY29uc29sZS5sb2cgXCJPVVRERU5UIHtAY2xvc2V9XCJcblx0XHQjIHZhciBvdiA9IEBvcGVuIGFuZCBAb3Blbi5AdmFsdWVcblx0XHQjIGlmIG92IGFuZCBvdjpsZW5ndGggPiAxXG5cdFx0IyBcdGNvbnNvbGUubG9nIFwidmFsdWUgZm9yIGluZGVudFwiLG92XG5cdFx0IyBcdGlmIG92LmluZGV4T2YoJyV8JScpXG5cdFx0IyBcdFx0cHJlID0gb3Yuc3Vic3RyXG5cdFx0dmFyIG9tID0gQG9wZW4gYW5kIEBvcGVuLkBtZXRhXG5cdFx0dmFyIHByZSA9IG9tIGFuZCBvbTpwcmUgb3IgJydcblx0XHR2YXIgcG9zdCA9IG9tIGFuZCBvbTpwb3N0IG9yICcnXG5cdFx0dmFyIGVzYyA9IEFTVDplc2NhcGVDb21tZW50c1xuXHRcdHZhciBvdXQgPSBAY2xvc2VcblxuXHRcdCMgdGhlIGZpcnN0IG5ld2xpbmUgc2hvdWxkIG5vdCBiZSBpbmRlbnRlZD9cblx0XHRzdHIgPSBwb3N0LnJlcGxhY2UoL15cXG4vLCcnKSArIHN0clxuXHRcdHN0ciA9IHN0ci5yZXBsYWNlKC9eL2csXCJcXHRcIikucmVwbGFjZSgvXFxuL2csXCJcXG5cXHRcIikucmVwbGFjZSgvXFxuXFx0JC9nLFwiXFxuXCIpXG5cblx0XHRzdHIgPSBwcmUgKyAnXFxuJyArIHN0clxuXHRcdHN0ciArPSBvdXQuYyBpZiBvdXQgaXNhIFRlcm1pbmF0b3Jcblx0XHRzdHIgPSBzdHIgKyAnXFxuJyB1bmxlc3Mgc3RyW3N0cjpsZW5ndGggLSAxXSA9PSAnXFxuJ1xuXHRcdHJldHVybiBzdHJcblx0XHRcbnZhciBJTkRFTlQgPSBJbmRlbnRhdGlvbi5uZXcoe30se30pXG5cbmNsYXNzIFN0YXNoXG5cblx0ZGVmIGluaXRpYWxpemVcblx0XHRAZW50aXRpZXMgPSBbXVxuXG5cdGRlZiBhZGQgaXRlbVxuXHRcdEBlbnRpdGllcy51bnNoaWZ0KGl0ZW0pXG5cdFx0c2VsZlxuXG5cdGRlZiBwbHVjayBpdGVtXG5cdFx0dmFyIG1hdGNoID0gbnVsbFxuXHRcdGZvciBlbnRpdHksaSBpbiBAZW50aXRpZXNcblx0XHRcdGlmIGVudGl0eSA9PSBpdGVtIG9yIGVudGl0eSBpc2EgaXRlbVxuXHRcdFx0XHRtYXRjaCA9IGVudGl0eVxuXHRcdFx0XHRAZW50aXRpZXMuc3BsaWNlKGksMSlcblx0XHRcdFx0cmV0dXJuIG1hdGNoXG5cdFx0cmV0dXJuIG51bGxcblxuXG5leHBvcnQgY2xhc3MgU3RhY2tcblxuXHRwcm9wIGxvZ2xldmVsXG5cdHByb3Agbm9kZXNcblx0cHJvcCBzY29wZXNcblxuXHRkZWYgaW5pdGlhbGl6ZVxuXHRcdHJlc2V0XG5cblx0ZGVmIHJlc2V0XG5cdFx0QG5vZGVzICAgID0gW11cblx0XHRAc2NvcGluZyAgPSBbXVxuXHRcdEBzY29wZXMgICA9IFtdICMgZm9yIGFuYWx5c2lzIC0gc2hvdWxkIHJlbmFtZVxuXHRcdEBzdGFzaCAgICA9IFN0YXNoLm5ldyhzZWxmKVxuXHRcdEBsb2dsZXZlbCA9IDNcblx0XHRAY291bnRlciAgPSAwXG5cdFx0QGNvdW50ZXJzID0ge31cblx0XHRzZWxmXG5cblx0ZGVmIGluY3IgbmFtZVxuXHRcdEBjb3VudGVyc1tuYW1lXSB8fD0gMFxuXHRcdEBjb3VudGVyc1tuYW1lXSArPSAxXG5cblx0ZGVmIHN0YXNoXG5cdFx0QHN0YXNoXG5cblx0ZGVmIG9wdGlvbiBrZXlcblx0XHRAb3B0aW9ucyBhbmQgQG9wdGlvbnNba2V5XVxuXG5cdGRlZiBhZGRTY29wZSBzY29wZVxuXHRcdEBzY29wZXMucHVzaChzY29wZSlcblx0XHRzZWxmXG5cblx0ZGVmIHRyYXZlcnNlIG5vZGVcblx0XHRzZWxmXG5cblx0ZGVmIHB1c2ggbm9kZVxuXHRcdEBub2Rlcy5wdXNoKG5vZGUpXG5cdFx0IyBub3Qgc3VyZSBpZiB3ZSBoYXZlIGFscmVhZHkgZGVmaW5lZCBhIHNjb3BlP1xuXHRcdHNlbGZcblxuXHRkZWYgcG9wIG5vZGVcblx0XHRAbm9kZXMucG9wICMgKG5vZGUpXG5cdFx0c2VsZlxuXG5cdGRlZiBwYXJlbnRcblx0XHRAbm9kZXNbQG5vZGVzOmxlbmd0aCAtIDJdXG5cblx0ZGVmIGN1cnJlbnRcblx0XHRAbm9kZXNbQG5vZGVzOmxlbmd0aCAtIDFdXG5cblx0ZGVmIHVwIHRlc3Rcblx0XHR0ZXN0IHx8PSBkbyB8dnwgISh2IGlzYSBWYXJPckFjY2VzcylcblxuXHRcdGlmIHRlc3Q6cHJvdG90eXBlIGlzYSBOb2RlXG5cdFx0XHR2YXIgdHlwID0gdGVzdFxuXHRcdFx0dGVzdCA9IGRvIHx2fCB2IGlzYSB0eXBcblxuXHRcdHZhciBpID0gQG5vZGVzOmxlbmd0aCAtIDIgIyBrZXlcblx0XHR3aGlsZSBpID49IDBcblx0XHRcdHZhciBub2RlID0gQG5vZGVzW2ldXG5cdFx0XHRyZXR1cm4gbm9kZSBpZiB0ZXN0KG5vZGUpXG5cdFx0XHRpIC09IDFcblx0XHRyZXR1cm4gbnVsbFxuXG5cdGRlZiByZWxhdGl2ZSBub2RlLCBvZmZzZXQgPSAwXG5cdFx0dmFyIGlkeCA9IEBub2Rlcy5pbmRleE9mKG5vZGUpXG5cdFx0aWR4ID49IDAgPyBAbm9kZXNbaWR4ICsgb2Zmc2V0XSA6IG51bGxcblxuXHRkZWYgc2NvcGUgbHZsID0gMFxuXHRcdHZhciBpID0gQG5vZGVzOmxlbmd0aCAtIDEgLSBsdmxcblx0XHR3aGlsZSBpID49IDBcblx0XHRcdHZhciBub2RlID0gQG5vZGVzW2ldXG5cdFx0XHRyZXR1cm4gbm9kZS5Ac2NvcGUgaWYgbm9kZS5Ac2NvcGVcblx0XHRcdGkgLT0gMVxuXHRcdHJldHVybiBudWxsXG5cblx0ZGVmIHNjb3Blc1xuXHRcdCMgaW5jbHVkZSBkZWVwZXIgc2NvcGVzIGFzIHdlbGw/XG5cdFx0dmFyIHNjb3BlcyA9IFtdXG5cdFx0dmFyIGkgPSBAbm9kZXM6bGVuZ3RoIC0gMVxuXHRcdHdoaWxlIGkgPj0gMFxuXHRcdFx0dmFyIG5vZGUgPSBAbm9kZXNbaV1cblx0XHRcdHNjb3Blcy5wdXNoKG5vZGUuQHNjb3BlKSBpZiBub2RlLkBzY29wZVxuXHRcdFx0aSAtPSAxXG5cdFx0cmV0dXJuIHNjb3Blc1xuXG5cdGRlZiBtZXRob2Rcblx0XHR1cChNZXRob2REZWNsYXJhdGlvbilcblxuXHRkZWYgYmxvY2tcblx0XHR1cChCbG9jaylcblxuXHRkZWYgaXNFeHByZXNzaW9uXG5cdFx0dmFyIGkgPSBAbm9kZXM6bGVuZ3RoIC0gMVxuXHRcdHdoaWxlIGkgPj0gMFxuXHRcdFx0dmFyIG5vZGUgPSBAbm9kZXNbaV1cblx0XHRcdCMgd2h5IGFyZSB3ZSBub3QgdXNpbmcgaXNFeHByZXNzaW9uIGhlcmUgYXMgd2VsbD9cblx0XHRcdGlmIG5vZGUgaXNhIENvZGUgb3Igbm9kZSBpc2EgTG9vcFxuXHRcdFx0XHRyZXR1cm4gZmFsc2Vcblx0XHRcdGlmIG5vZGUuaXNFeHByZXNzaW9uXG5cdFx0XHRcdHJldHVybiB0cnVlXG5cdFx0XHQjIHByb2JhYmx5IG5vdCB0aGUgcmlnaHQgdGVzdCAtIG5lZWQgdG8gYmUgbW9yZSBleHBsaWNpdFxuXHRcdFx0aSAtPSAxXG5cdFx0cmV0dXJuIGZhbHNlXG5cblx0ZGVmIHRvU3RyaW5nXG5cdFx0XCJTdGFjayh7QG5vZGVzLmpvaW4oXCIgLT4gXCIpfSlcIlxuXG5cdGRlZiBzY29waW5nXG5cdFx0QG5vZGVzLmZpbHRlcih8bnwgbi5Ac2NvcGUgKS5tYXAofG58IG4uQHNjb3BlIClcblxuIyBMb3RzIG9mIGdsb2JhbHMgLS0gcmVhbGx5IG5lZWQgdG8gZGVhbCB3aXRoIG9uZSBzdGFjayBwZXIgZmlsZSAvIGNvbnRleHRcbmV4cG9ydCB2YXIgU1RBQ0sgPSBTdGFjay5uZXdcblxuR0xPQlNUQUNLID0gU1RBQ0tcblxuIyB1c2UgYSBiaXRtYXNrIGZvciB0aGVzZVxuXG5leHBvcnQgY2xhc3MgTm9kZVxuXG5cdHByb3Agb1xuXHRwcm9wIG9wdGlvbnNcblx0cHJvcCB0cmF2ZXJzZWRcblxuXHRkZWYgc2FmZWNoYWluXG5cdFx0bm9cblxuXHQjIGRlZiBkb21cblx0IyBcdHZhciBuYW1lID0gXCJhc3RfXCIgKyBzZWxmOmNvbnN0cnVjdG9yOm5hbWUucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZyxcIiQxXyQyXCIpLnRvTG93ZXJDYXNlXG5cdCMgXHQjIHAgXCJ0cnkgdG8gZ2V0IHRoZSBkb20tbm9kZSBmb3IgdGhpcyBhc3Qtbm9kZVwiLG5hbWVcblx0IyBcdGlmIEltYmEuVEFHU1tuYW1lXVxuXHQjIFx0XHR2YXIgbm9kZSA9IEltYmEudGFnKG5hbWUpXG5cdCMgXHRcdG5vZGUuYmluZChzZWxmKS5idWlsZFxuXHQjIFx0XHRyZXR1cm4gbm9kZVxuXHQjIFx0ZWxzZVxuXHQjIFx0XHRyZXR1cm4gXCJbe25hbWV9XVwiXG5cblx0ZGVmIHBcblx0XG5cdFx0IyBhbGxvdyBjb250cm9sbGluZyB0aGlzIGZyb20gY29tbWFuZGxpbmVcblx0XHRpZiBTVEFDSy5sb2dsZXZlbCA+IDBcblx0XHRcdGNvbnNvbGUubG9nKCphcmd1bWVudHMpXG5cdFx0c2VsZlxuXG5cdGRlZiB0eXBlTmFtZVxuXHRcdHNlbGY6Y29uc3RydWN0b3I6bmFtZVxuXG5cdGRlZiBuYW1lcGF0aFxuXHRcdHR5cGVOYW1lXG5cblx0ZGVmIGluaXRpYWxpemVcblx0XHRzZXR1cFxuXHRcdHNlbGZcblxuXHRkZWYgc2V0dXBcblx0XHRAZXhwcmVzc2lvbiA9IG5vXG5cdFx0QHRyYXZlcnNlZCA9IG5vXG5cdFx0QHBhcmVucyA9IG5vXG5cdFx0QGNhY2hlID0gbnVsbFxuXHRcdEB2YWx1ZSA9IG51bGxcblx0XHRzZWxmXG5cblx0ZGVmIHNldCBvYmpcblx0XHQjIGNvbnNvbGUubG9nIFwic2V0dGluZyBvcHRpb25zIHtKU09OLnN0cmluZ2lmeShvYmopfVwiXG5cdFx0QG9wdGlvbnMgfHw9IHt9XG5cdFx0Zm9yIG93biBrLHYgb2Ygb2JqXG5cdFx0XHRAb3B0aW9uc1trXSA9IHZcblx0XHRzZWxmXG5cblx0IyBnZXQgYW5kIHNldFxuXHRkZWYgb3B0aW9uIGtleSwgdmFsXG5cdFx0aWYgdmFsICE9IHVuZGVmaW5lZFxuXHRcdFx0IyBjb25zb2xlLmxvZyBcInNldHRpbmcgb3B0aW9uIHtrZXl9IHt2YWx9XCJcblx0XHRcdEBvcHRpb25zIHx8PSB7fVxuXHRcdFx0QG9wdGlvbnNba2V5XSA9IHZhbFxuXHRcdFx0cmV0dXJuIHNlbGZcblxuXHRcdEBvcHRpb25zICYmIEBvcHRpb25zW2tleV1cblxuXHRkZWYgY29uZmlndXJlIG9ialxuXHRcdHNldChvYmopXG5cblx0ZGVmIHJlZ2lvblxuXHRcdFswLDBdXG5cblx0ZGVmIGxvY1xuXHRcdFswLDBdXG5cblx0ZGVmIHRva2VuXG5cdFx0bnVsbFxuXG5cdGRlZiBjb21waWxlXG5cdFx0c2VsZlxuXG5cdGRlZiB2aXNpdFxuXHRcdHNlbGZcblxuXHRkZWYgc3RhY2tcblx0XHRTVEFDS1xuXG5cdGRlZiBpc1N0cmluZ1xuXHRcdG5vXG5cblx0ZGVmIGlzUHJpbWl0aXZlIGRlZXBcblx0XHRub1xuXG5cdGRlZiBpc1Jlc2VydmVkXG5cdFx0bm9cblxuXHQjIHNob3VsZCByYXRoZXIgZG8gdHJhdmVyc2Fsc1xuXHQjIG8gPSB7fSwgdXAsIGtleSwgaW5kZXhcblx0ZGVmIHRyYXZlcnNlXG5cdFx0aWYgQHRyYXZlcnNlZFxuXHRcdFx0cmV0dXJuIHNlbGYgXG5cdFx0IyBOT0RFUy5wdXNoKHNlbGYpXG5cdFx0QHRyYXZlcnNlZCA9IHllc1xuXHRcdFNUQUNLLnB1c2ggc2VsZlxuXHRcdHZpc2l0KFNUQUNLKVxuXHRcdFNUQUNLLnBvcCBzZWxmXG5cdFx0cmV0dXJuIHNlbGZcblxuXHRkZWYgaW5zcGVjdFxuXHRcdHt0eXBlOiBzZWxmOmNvbnN0cnVjdG9yLnRvU3RyaW5nfVxuXG5cdGRlZiBqcyBvXG5cdFx0XCJOT0RFXCJcblxuXHRkZWYgdG9TdHJpbmdcblx0XHRcIntzZWxmOmNvbnN0cnVjdG9yOm5hbWV9XCJcblxuXHQjIHN3YWxsb3cgbWlnaHQgYmUgYmV0dGVyIG5hbWVcblx0ZGVmIGNvbnN1bWUgbm9kZVxuXHRcdGlmIG5vZGUgaXNhIFB1c2hBc3NpZ25cblx0XHRcdHJldHVybiBQdXNoQXNzaWduLm5ldyhub2RlLm9wLG5vZGUubGVmdCxzZWxmKVxuXG5cdFx0aWYgbm9kZSBpc2EgQXNzaWduXG5cdFx0XHQjIHAgXCJjb25zdW1lIGFzc2lnbm1lbnRcIi5jeWFuXG5cdFx0XHQjIG5vZGUucmlnaHQgPSBzZWxmXG5cdFx0XHRyZXR1cm4gT1Aobm9kZS5vcCxub2RlLmxlZnQsc2VsZilcblx0XHRlbGlmIG5vZGUgaXNhIE9wXG5cdFx0XHRyZXR1cm4gT1Aobm9kZS5vcCxub2RlLmxlZnQsc2VsZilcblx0XHRlbGlmIG5vZGUgaXNhIFJldHVyblxuXHRcdFx0IyBwIFwiY29uc3VtZSByZXR1cm5cIi5jeWFuXG5cdFx0XHRyZXR1cm4gUmV0dXJuLm5ldyhzZWxmKVxuXHRcdHJldHVybiBzZWxmXG5cblx0ZGVmIHRvRXhwcmVzc2lvblxuXHRcdEBleHByZXNzaW9uID0gdHJ1ZVxuXHRcdHNlbGZcblxuXHRkZWYgZm9yY2VFeHByZXNzaW9uXG5cdFx0QGV4cHJlc3Npb24gPSB0cnVlXG5cdFx0c2VsZlxuXG5cdGRlZiBpc0V4cHJlc3NhYmxlXG5cdFx0dHJ1ZVxuXG5cdGRlZiBpc0V4cHJlc3Npb25cblx0XHRAZXhwcmVzc2lvbiB8fCBmYWxzZVxuXG5cdGRlZiBoYXNTaWRlRWZmZWN0c1xuXHRcdHRydWVcblxuXHRkZWYgaXNVc2VkXG5cdFx0dHJ1ZVxuXHRcdFxuXHRkZWYgc2hvdWxkUGFyZW50aGVzaXplXG5cdFx0ZmFsc2VcblxuXHRkZWYgYmxvY2tcblx0XHRCbG9jay53cmFwKFtzZWxmXSlcblxuXHRkZWYgbm9kZVxuXHRcdHNlbGZcblxuXHRkZWYgc2NvcGVfX1xuXHRcdFNUQUNLLnNjb3BlXG5cblx0ZGVmIHVwXG5cdFx0U1RBQ0sucGFyZW50XG5cblx0ZGVmIHV0aWxcblx0XHRVdGlsXG5cblx0ZGVmIHJlY2VpdmVyXG5cdFx0c2VsZlxuXG5cdGRlZiBhZGRFeHByZXNzaW9uIGV4cHJcblx0XHQjIG1pZ2h0IGJlIGJldHRlciB0byBuZXN0IHRoaXMgdXAgYWZ0ZXIgcGFyc2luZyBpcyBkb25lP1xuXHRcdCMgcCBcImFkZEV4cHJlc3Npb24ge3NlbGZ9IDwtIHtleHByfVwiXG5cdFx0dmFyIG5vZGUgPSBFeHByZXNzaW9uQmxvY2submV3KFtzZWxmXSlcblx0XHRyZXR1cm4gbm9kZS5hZGRFeHByZXNzaW9uKGV4cHIpXG5cblxuXHRkZWYgaW5kZW50ZWQgYSxiXG5cblx0XHRpZiBhIGlzYSBJbmRlbnRhdGlvblxuXHRcdFx0QGluZGVudGF0aW9uID0gYVxuXHRcdFx0cmV0dXJuIHNlbGZcblxuXHRcdCMgdGhpcyBpcyBhIF9CSUdfIGhhY2tcblx0XHRpZiBiIGlzYSBBcnJheVxuXHRcdFx0YWRkKGJbMF0pXG5cdFx0XHRiID0gYlsxXVxuXG5cdFx0IyBpZiBpbmRlbnQgYW5kIGluZGVudC5tYXRjaCgvXFw6Lylcblx0XHRAaW5kZW50YXRpb24gfHw9IGEgYW5kIGIgPyBJbmRlbnRhdGlvbi5uZXcoYSxiKSA6IElOREVOVFxuXHRcdHNlbGZcblxuXHRkZWYgcHJlYnJlYWsgdGVybSA9ICdcXG4nXG5cdFx0IyBpbiBvcHRpb25zIGluc3RlYWQ/XG5cdFx0IyBjb25zb2xlLmxvZyBcInByZWJyZWFrISEhIVwiXG5cdFx0IyBAcHJlYnJlYWsgPSBAcHJlYnJlYWsgb3IgdGVybVxuXHRcdHNlbGZcblxuXHRkZWYgaW52ZXJ0XG5cdFx0cmV0dXJuIE9QKCchJyxzZWxmKVxuXG5cdGRlZiBjYWNoZSBvID0ge31cblx0XHRAY2FjaGUgPSBvXG5cdFx0bzp2YXIgPSBzY29wZV9fLnRlbXBvcmFyeShzZWxmLG8pXG5cdFx0bzpsb29rdXBzID0gMFxuXHRcdHNlbGZcblxuXHRkZWYgY2FjaGV2YXJcblx0XHRAY2FjaGUgJiYgQGNhY2hlOnZhclxuXG5cdGRlZiBkZWNhY2hlXG5cdFx0aWYgQGNhY2hlXG5cdFx0XHRjYWNoZXZhci5mcmVlXG5cdFx0XHRAY2FjaGUgPSBudWxsXG5cdFx0c2VsZlxuXG5cdCMgaXMgdGhpcyB3aXRob3V0IHNpZGUtZWZmZWN0cz8gaG1tIC0gd2hhdCBkb2VzIGl0IGV2ZW4gZG8/XG5cdGRlZiBwcmVkZWNsYXJlXG5cdFx0aWYgQGNhY2hlXG5cdFx0XHRzY29wZV9fLnZhcnMuc3dhcChAY2FjaGU6dmFyLHNlbGYpXG5cdFx0c2VsZlxuXG5cdCMgdGhlIFwibmFtZS1zdWdnZXN0aW9uXCIgZm9yIG5vZGVzIGlmIHRoZXkgbmVlZCB0byBiZSBjYWNoZWRcblx0ZGVmIGFsaWFzXG5cdFx0bnVsbFxuXG5cdGRlZiB3YXJuIHRleHQsIG9wdHMgPSB7fVxuXHRcdG9wdHM6bWVzc2FnZSA9IHRleHRcblx0XHRvcHRzOmxvYyB8fD0gbG9jXG5cdFx0c2NvcGVfXy5yb290Lndhcm4gb3B0c1xuXHRcdHNlbGZcblxuXHRkZWYgYyBvXG5cdFx0dmFyIHMgPSBTVEFDS1xuXHRcdHZhciBjaCA9IEBjYWNoZVxuXHRcdHJldHVybiBjX2NhY2hlZChjaCkgaWYgY2ggYW5kIGNoOmNhY2hlZFxuXG5cdFx0cy5wdXNoKHNlbGYpXG5cdFx0Zm9yY2VFeHByZXNzaW9uIGlmIG8gJiYgbzpleHByZXNzaW9uXG5cblx0XHR2OCBhbmQgY29uc29sZS5sb2cgdjguaGFzRmFzdE9iamVjdEVsZW1lbnRzKHNlbGYpXG5cblx0XHRpZiBvIGFuZCBvOmluZGVudFxuXHRcdFx0QGluZGVudGF0aW9uIHx8PSBJTkRFTlRcblxuXHRcdHZhciBvdXQgPSBqcyhzLG8pXG5cblx0XHQjIHJlYWxseT8gd2h5IG5vdCBjYWxsIHRoaXMgc29tZXdoZXJlIGVsc2U/XG5cdFx0dmFyIHBhcmVuID0gc2hvdWxkUGFyZW50aGVzaXplXG5cdFx0XG5cdFx0aWYgdmFyIGluZGVudCA9IEBpbmRlbnRhdGlvblxuXHRcdFx0b3V0ID0gaW5kZW50LndyYXAob3V0LG8pXG5cblx0XHQjIHNob3VsZCBtb3ZlIHRoaXMgc29tZXdoZXJlIGVsc2UgcmVhbGx5XG5cdFx0b3V0ID0gXCIoe291dH0pXCIgaWYgcGFyZW5cblx0XHRpZiBvIGFuZCBvOmJyYWNlc1xuXHRcdFx0aWYgaW5kZW50XG5cdFx0XHRcdG91dCA9ICd7JyArIG91dCArICd9JyBcblx0XHRcdGVsc2Vcblx0XHRcdFx0b3V0ID0gJ3sgJyArIG91dCArICcgfSdcblxuXHRcdHMucG9wKHNlbGYpXG5cblx0XHRpZiBjaCA9IEBjYWNoZVxuXHRcdFx0b3V0ID0gXCJ7Y2g6dmFyLmN9ID0ge291dH1cIiB1bmxlc3MgY2g6bWFudWFsXG5cdFx0XHR2YXIgcGFyID0gcy5jdXJyZW50XG5cdFx0XHRvdXQgPSAnKCcgKyBvdXQgKyAnKScgaWYgcGFyIGlzYSBBY2Nlc3MgfHwgcGFyIGlzYSBPcCAjIG90aGVycz8gIyBcblx0XHRcdGNoOmNhY2hlZCA9IHllc1xuXHRcdHJldHVybiBvdXRcblxuXHRkZWYgY19jYWNoZWQgY2FjaGVcblx0XHRjYWNoZTpsb29rdXBzKytcblx0XHRjYWNoZTp2YXIuZnJlZSBpZiBjYWNoZTp1c2VzID09IGNhY2hlOmxvb2t1cHNcblx0XHRyZXR1cm4gY2FjaGU6dmFyLmMgIyByZWNvbXBpbGUgZXZlcnkgdGltZT8/XG5cbmV4cG9ydCBjbGFzcyBWYWx1ZU5vZGUgPCBOb2RlXG5cblx0cHJvcCB2YWx1ZVxuXG5cdGRlZiBpbml0aWFsaXplIHZhbHVlXG5cdFx0c2V0dXBcblx0XHRAdmFsdWUgPSBsb2FkKHZhbHVlKVxuXG5cdGRlZiBsb2FkIHZhbHVlXG5cdFx0dmFsdWVcblxuXHRkZWYganMgb1xuXHRcdHR5cGVvZiBAdmFsdWUgPT0gJ3N0cmluZycgPyBAdmFsdWUgOiBAdmFsdWUuY1xuXG5cdGRlZiB2aXNpdFxuXHRcblx0XHRAdmFsdWUudHJhdmVyc2UgaWYgQHZhbHVlIGlzYSBOb2RlICMgICYmIEB2YWx1ZTp0cmF2ZXJzZVxuXHRcdHNlbGZcblxuXHRkZWYgcmVnaW9uXG5cdFx0W0B2YWx1ZS5AbG9jLEB2YWx1ZS5AbG9jICsgQHZhbHVlLkBsZW5dXG5cblxuZXhwb3J0IGNsYXNzIFN0YXRlbWVudCA8IFZhbHVlTm9kZVxuXG5cdGRlZiBpc0V4cHJlc3NhYmxlXG5cdFx0cmV0dXJuIG5vXG5cblxuZXhwb3J0IGNsYXNzIE1ldGEgPCBWYWx1ZU5vZGVcblxuXHRkZWYgaXNQcmltaXRpdmUgZGVlcFxuXHRcdHllc1xuXG5leHBvcnQgY2xhc3MgQ29tbWVudCA8IE1ldGFcblx0XG5cdGRlZiB2aXNpdFxuXHRcdCMgc3RhY2suc3Rhc2guYWRkKHNlbGYpXG5cblx0XHRpZiB2YXIgYmxvY2sgPSB1cFxuXHRcdFx0dmFyIGlkeCA9IGJsb2NrLmluZGV4T2Yoc2VsZikgKyAxXG5cdFx0XHRpZHggKz0gMSBpZiBibG9jay5pbmRleChpZHgpIGlzYSBUZXJtaW5hdG9yXG5cdFx0XHRpZiB2YXIgbmV4dCA9IGJsb2NrLmluZGV4KGlkeClcblx0XHRcdFx0bmV4dC5AZGVzYyA9IHNlbGZcblxuXHRcdFx0IyBjb25zb2xlLmxvZyBcIk5leHQgaXRlbSBhZnRlciBjb21tZW50IGlzIHtibG9jay5pbmRleChpZHgpfVwiXG5cblx0XHRzZWxmXG5cblx0ZGVmIHRvRG9jXG5cdFx0aGVscGVycy5ub3JtYWxpemVJbmRlbnRhdGlvbihcIlwiICsgQHZhbHVlLkB2YWx1ZSlcblxuXHRkZWYgdG9KU09OXG5cdFx0aGVscGVycy5ub3JtYWxpemVJbmRlbnRhdGlvbihcIlwiICsgQHZhbHVlLkB2YWx1ZSlcblxuXHRkZWYgYyBvXG5cdFx0dmFyIHYgPSBAdmFsdWUuQHZhbHVlXG5cdFx0IyBwIEB2YWx1ZS50eXBlXG5cdFx0aWYgbyBhbmQgbzpleHByZXNzaW9uIG9yIHYubWF0Y2goL1xcbi8pIG9yIEB2YWx1ZS50eXBlID09ICdIRVJFQ09NTUVOVCcgIyBtdWx0aWxpbmU/XG5cdFx0XHRcIi8qe3Z9Ki9cIlxuXHRcdGVsc2Vcblx0XHRcdFwiLy8ge3Z9XCJcblxuZXhwb3J0IGNsYXNzIFRlcm1pbmF0b3IgPCBNZXRhXG5cdFxuXHRkZWYgaW5pdGlhbGl6ZSB2XG5cdFx0QHZhbHVlID0gdlxuXHRcdHNlbGZcblxuXHRkZWYgdHJhdmVyc2Vcblx0XHRzZWxmXG5cblx0ZGVmIGNcblx0XHQjIFRPRE8gdGhpcyBjYW4gY29udGFpbiBzZXZlcmFsIG5ld2xpbmVzXG5cdFx0IyBmb3Igc291cmNlbWFwcyBpdCB3b3VsZCBiZSBuaWNlIHRvIHBhcnNlIHRoaXNcblx0XHQjIGFuZCBmaXggaXQgdXAgbWFya19fKEB2YWx1ZSkgKyBcblx0XHRyZXR1cm4gQHZhbHVlLmNcblx0XHQjIHZhciB2ID0gdmFsdWUucmVwbGFjZSgvXFxcXG4vZywnXFxuJylcblx0XHQjIHYgIyAuc3BsaXQoKVxuXHRcdCMgdi5zcGxpdChcIlxcblwiKS5tYXAofHZ8IHYgPyBcIiAvLyB7dn1cIiA6IHYpLmpvaW4oXCJcXG5cIilcblxuZXhwb3J0IGNsYXNzIE5ld2xpbmUgPCBUZXJtaW5hdG9yXG5cblx0ZGVmIGluaXRpYWxpemUgdlxuXHRcdEB0cmF2ZXJzZWQgPSBub1xuXHRcdEB2YWx1ZSA9IHYgb3IgJ1xcbidcblxuXHRkZWYgY1xuXHRcdGNfXyhAdmFsdWUpXG5cdFx0XG5cbiMgd2VpcmQgcGxhY2U/XG5leHBvcnQgY2xhc3MgSW5kZXggPCBWYWx1ZU5vZGVcblxuXHRkZWYganMgb1xuXHRcdEB2YWx1ZS5jXG5cbmV4cG9ydCBjbGFzcyBMaXN0Tm9kZSA8IE5vZGVcblxuXHRwcm9wIG5vZGVzXG5cblx0ZGVmIGluaXRpYWxpemUgbGlzdFxuXHRcdHNldHVwXG5cdFx0QG5vZGVzID0gbG9hZChsaXN0IG9yIFtdKVxuXHRcdEBpbmRlbnRhdGlvbiA9IG51bGxcblxuXHQjIFBFUkYgYWNjZXMgQG5vZGVzIGRpcmVjdGx5P1xuXHRkZWYgbGlzdFxuXHRcdEBub2Rlc1xuXG5cdGRlZiBjb21wYWN0XG5cdFx0QG5vZGVzID0gY29tcGFjdF9fKEBub2Rlcylcblx0XHRzZWxmXG5cblx0ZGVmIGxvYWQgbGlzdFxuXHRcdGxpc3RcblxuXHRkZWYgY29uY2F0IG90aGVyXG5cdFx0IyBuZWVkIHRvIHN0b3JlIGluZGVudGVkIGNvbnRlbnQgYXMgd2VsbD9cblx0XHRAbm9kZXMgPSBub2Rlcy5jb25jYXQob3RoZXIgaXNhIEFycmF5ID8gb3RoZXIgOiBvdGhlci5ub2Rlcylcblx0XHRzZWxmXG5cblx0ZGVmIHN3YXAgaXRlbSwgb3RoZXJcblx0XHR2YXIgaWR4ID0gaW5kZXhPZihpdGVtKVxuXHRcdG5vZGVzW2lkeF0gPSBvdGhlciBpZiBpZHggPj0gMFxuXHRcdHNlbGZcblxuXHRkZWYgcHVzaCBpdGVtXG5cdFx0QG5vZGVzLnB1c2goaXRlbSlcblx0XHRzZWxmXG5cblx0ZGVmIHBvcFxuXHRcdHZhciBlbmQgPSBAbm9kZXMucG9wXG5cdFx0cmV0dXJuIGVuZFxuXG5cdGRlZiBhZGQgaXRlbVxuXHRcdEBub2Rlcy5wdXNoKGl0ZW0pXG5cdFx0c2VsZlxuXG5cdGRlZiB1bnNoaWZ0IGl0ZW0sIGJyXG5cdFx0QG5vZGVzLnVuc2hpZnQoQlIpIGlmIGJyXG5cdFx0QG5vZGVzLnVuc2hpZnQoaXRlbSlcblx0XHRzZWxmXG5cblx0IyB0ZXN0XG5cdGRlZiBzbGljZSBhLCBiXG5cdFx0c2VsZjpjb25zdHJ1Y3Rvci5uZXcoQG5vZGVzLnNsaWNlKGEsYikpXG5cblx0XG5cblx0ZGVmIGJyZWFrIGJyLCBwcmUgPSBub1xuXHRcdGJyID0gVGVybWluYXRvci5uZXcoYnIpIGlmIHR5cGVvZiBiciA9PSAnc3RyaW5nJ1xuXHRcdHByZSA/IHVuc2hpZnQoYnIpIDogcHVzaChicilcblx0XHRzZWxmXG5cblx0ZGVmIHNvbWUgY2Jcblx0XHRmb3Igbm9kZSBpbiBAbm9kZXNcblx0XHRcdHJldHVybiB5ZXMgaWYgY2Iobm9kZSlcblx0XHRyZXR1cm4gbm9cblxuXHRkZWYgZXZlcnkgY2Jcblx0XHRmb3Igbm9kZSBpbiBAbm9kZXNcblx0XHRcdHJldHVybiBubyB1bmxlc3MgY2Iobm9kZSlcblx0XHRyZXR1cm4geWVzXG5cblx0ZGVmIGZpbHRlciBjYlxuXHRcdEBub2Rlcy5maWx0ZXIoY2IpXG5cblx0ZGVmIHBsdWNrIGNiXG5cdFx0dmFyIGl0ZW0gPSBmaWx0ZXIoY2IpWzBdXG5cdFx0cmVtb3ZlKGl0ZW0pIGlmIGl0ZW1cblx0XHRyZXR1cm4gaXRlbVxuXG5cdGRlZiBpbmRleE9mIGl0ZW1cblx0XHRAbm9kZXMuaW5kZXhPZihpdGVtKVxuXG5cdGRlZiBpbmRleCBpXG5cdFx0QG5vZGVzW2ldXG5cblx0ZGVmIHJlbW92ZSBpdGVtXG5cdFx0dmFyIGlkeCA9IEBub2Rlcy5pbmRleE9mKGl0ZW0pXG5cdFx0QG5vZGVzLnNwbGljZShpZHgsIDEpIGlmIGlkeCA+PSAwXG5cdFx0c2VsZlxuXG5cdGRlZiByZW1vdmVBdCBpZHhcblx0XHR2YXIgaXRlbSA9IEBub2Rlc1tpZHhdXG5cdFx0QG5vZGVzLnNwbGljZShpZHgsIDEpIGlmIGlkeCA+PSAwXG5cdFx0cmV0dXJuIGl0ZW1cblx0XHRcblxuXHRkZWYgcmVwbGFjZSBvcmlnaW5hbCwgcmVwbGFjZW1lbnRcblx0XHR2YXIgaWR4ID0gQG5vZGVzLmluZGV4T2Yob3JpZ2luYWwpXG5cdFx0aWYgaWR4ID49IDBcblx0XHRcdGlmIHJlcGxhY2VtZW50IGlzYSBBcnJheVxuXHRcdFx0XHQjIHAgXCJyZXBsYWNlaW5nIHdpdGggYXJyYXkgb2YgaXRlbXNcIlxuXHRcdFx0XHRAbm9kZXMuc3BsaWNlKGlkeCwxLCpyZXBsYWNlbWVudClcblx0XHRcdGVsc2Vcblx0XHRcdFx0QG5vZGVzW2lkeF0gPSByZXBsYWNlbWVudCBcblx0XHRzZWxmXG5cblx0ZGVmIGZpcnN0XG5cdFx0QG5vZGVzWzBdXG5cblx0ZGVmIGxhc3Rcblx0XHR2YXIgaSA9IEBub2RlczpsZW5ndGhcblx0XHR3aGlsZSBpXG5cdFx0XHRpID0gaSAtIDFcblx0XHRcdHZhciB2ID0gQG5vZGVzW2ldXG5cdFx0XHRyZXR1cm4gdiB1bmxlc3MgdiBpc2EgTWV0YVxuXHRcdHJldHVybiBudWxsXG5cblx0ZGVmIG1hcCBmblxuXHRcdEBub2Rlcy5tYXAoZm4pXG5cblx0ZGVmIGZvckVhY2ggZm5cblx0XHRAbm9kZXMuZm9yRWFjaChmbilcblxuXHRkZWYgcmVtYXAgZm5cblx0XHRAbm9kZXMgPSBtYXAoZm4pXG5cdFx0c2VsZlxuXG5cdGRlZiBjb3VudFxuXHRcdEBub2RlczpsZW5ndGhcblxuXHRkZWYgcmVhbENvdW50XG5cdFx0dmFyIGsgPSAwXG5cdFx0Zm9yIG5vZGUgaW4gQG5vZGVzXG5cdFx0XHRrKysgaWYgbm9kZSBhbmQgIShub2RlIGlzYSBNZXRhKVxuXHRcdHJldHVybiBrXG5cblx0ZGVmIHZpc2l0XG5cdFx0Zm9yIG5vZGUgaW4gQG5vZGVzXG5cdFx0XHRub2RlIGFuZCBub2RlLnRyYXZlcnNlXG5cdFx0c2VsZlxuXG5cdGRlZiBpc0V4cHJlc3NhYmxlXG5cdFx0Zm9yIG5vZGUgaW4gbm9kZXNcblx0XHRcdHJldHVybiBubyBpZiBub2RlIGFuZCAhbm9kZS5pc0V4cHJlc3NhYmxlXG5cdFx0IyByZXR1cm4gbm8gdW5sZXNzIG5vZGVzLmV2ZXJ5KHx2fCB2LmlzRXhwcmVzc2FibGUgKVxuXHRcdHJldHVybiB5ZXNcblxuXHRkZWYgdG9BcnJheVxuXHRcdEBub2Rlc1xuXG5cdGRlZiBkZWxpbWl0ZXJcblx0XHRAZGVsaW1pdGVyIG9yIFwiLFwiXG5cblx0ZGVmIGpzIG8sIG5vZGVzOiBAbm9kZXNcblx0XHR2YXIgZGVsaW0gPSAnLCdcblx0XHR2YXIgZXhwcmVzcyA9IGRlbGltICE9ICc7J1xuXHRcdHZhciBsYXN0ID0gbGFzdFxuXG5cdFx0dmFyIGkgPSAwXG5cdFx0dmFyIGwgPSBub2RlczpsZW5ndGhcblx0XHR2YXIgc3RyID0gXCJcIlxuXG5cdFx0Zm9yIGFyZyBpbiBub2Rlc1xuXHRcdFx0dmFyIHBhcnQgPSB0eXBlb2YgYXJnID09ICdzdHJpbmcnID8gYXJnIDogKGFyZyA/IGFyZy5jKGV4cHJlc3Npb246IGV4cHJlc3MpIDogJycpXG5cdFx0XHRzdHIgKz0gcGFydFxuXHRcdFx0c3RyICs9IGRlbGltIGlmIHBhcnQgYW5kICghZXhwcmVzcyBvciBhcmcgIT0gbGFzdCkgYW5kICEoYXJnIGlzYSBNZXRhKVxuXG5cdFx0cmV0dXJuIHN0clxuXG5cdGRlZiBpbmRlbnRlZCBhLGJcblx0XHRpZiBhIGlzYSBJbmRlbnRhdGlvblxuXHRcdFx0QGluZGVudGF0aW9uID0gYVxuXHRcdFx0cmV0dXJuIHNlbGZcblxuXHRcdEBpbmRlbnRhdGlvbiB8fD0gYSBhbmQgYiA/IEluZGVudGF0aW9uLm5ldyhhLGIpIDogSU5ERU5UXG5cdFx0c2VsZlxuXHRcdFxuXG5leHBvcnQgY2xhc3MgQXJnTGlzdCA8IExpc3ROb2RlXG5cbiNcdGRlZiBpbmRlbnRlZCBhLGJcbiNcdFx0aWYgYSBpc2EgSW5kZW50YXRpb25cbiNcdFx0XHRAaW5kZW50YXRpb24gPSBhXG4jXHRcdFx0cmV0dXJuIHNlbGZcbiNcbiNcdFx0QGluZGVudGF0aW9uIHx8PSBhIGFuZCBiID8gSW5kZW50YXRpb24ubmV3KGEsYikgOiBJTkRFTlRcbiNcdFx0c2VsZlxuXG4jIGRlZiBoYXNTcGxhdFxuIyBcdEBub2Rlcy5zb21lIGRvIHx2fCB2IGlzYSBTcGxhdFxuIyBkZWYgZGVsaW1pdGVyXG4jIFx0XCIsXCJcblxuXG5leHBvcnQgY2xhc3MgQXNzaWduTGlzdCA8IEFyZ0xpc3RcdFxuXG5cdGRlZiBjb25jYXQgb3RoZXJcblx0XHRpZiBAbm9kZXM6bGVuZ3RoID09IDAgYW5kIG90aGVyIGlzYSBBc3NpZ25MaXN0XG5cdFx0XHRyZXR1cm4gb3RoZXJcblx0XHRlbHNlXG5cdFx0XHRzdXBlcihvdGhlcilcblx0XHQjIG5lZWQgdG8gc3RvcmUgaW5kZW50ZWQgY29udGVudCBhcyB3ZWxsP1xuXHRcdCMgQG5vZGVzID0gbm9kZXMuY29uY2F0KG90aGVyIGlzYSBBcnJheSA/IG90aGVyIDogb3RoZXIubm9kZXMpXG5cdFx0c2VsZlxuXG5cbmV4cG9ydCBjbGFzcyBCbG9jayA8IExpc3ROb2RlXHRcblx0XG5cdHByb3AgaGVhZFxuXG5cdGRlZiBpbml0aWFsaXplIGxpc3Rcblx0XHRzZXR1cFxuXHRcdCMgQG5vZGVzID0gY29tcGFjdF9fKGZsYXR0ZW5fXyhsaXN0KSkgb3IgW11cblx0XHRAbm9kZXMgPSBsaXN0IG9yIFtdXG5cdFx0QGhlYWQgPSBudWxsXG5cdFx0QGluZGVudGF0aW9uID0gbnVsbFxuXG5cdGRlZiBzZWxmLndyYXAgYXJ5XG5cdFx0dW5sZXNzIGFyeSBpc2EgQXJyYXlcblx0XHRcdHRocm93IFN5bnRheEVycm9yLm5ldyhcIndoYXRcIilcblx0XHRhcnk6bGVuZ3RoID09IDEgJiYgYXJ5WzBdIGlzYSBCbG9jayA/IGFyeVswXSA6IEJsb2NrLm5ldyhhcnkpXG5cblx0ZGVmIHZpc2l0XG5cdFx0QHNjb3BlLnZpc2l0IGlmIEBzY29wZVxuXG5cdFx0Zm9yIG5vZGUsaSBpbiBAbm9kZXNcblx0XHRcdG5vZGUgYW5kIG5vZGUudHJhdmVyc2Vcblx0XHRzZWxmXG5cblx0ZGVmIGJsb2NrXG5cdFx0c2VsZlxuXG5cdCMgZGVmIGluZGVudGVkIGEsYlxuXHQjIFx0QGluZGVudGF0aW9uIHx8PSBhIGFuZCBiID8gSW5kZW50YXRpb24ubmV3KGEsYikgOiBJTkRFTlRcblx0IyBcdHNlbGZcblxuXHRkZWYgbG9jXG5cdFx0IyByYXRoZXIgaW5kZW50cywgbm8/XG5cdFx0aWYgdmFyIG9wdCA9IG9wdGlvbig6ZW5kcylcblx0XHRcdCMgcCBcImxvY2F0aW9uIGlzXCIsb3B0XG5cdFx0XHR2YXIgYSA9IG9wdFswXS5sb2Ncblx0XHRcdHZhciBiID0gb3B0WzFdLmxvY1xuXG5cdFx0XHRwIFwibm8gbG9jIGZvciB7b3B0WzBdfVwiIHVubGVzcyBhXG5cdFx0XHRwIFwibm8gbG9jIGZvciB7b3B0WzFdfVwiIHVubGVzcyBiXG5cblx0XHRcdFthWzBdLGJbMV1dXG5cdFx0ZWxpZiB2YXIgaW5kID0gQGluZGVudGF0aW9uXG5cdFx0XHRbaW5kLmFsb2MsaW5kLmJsb2NdXG5cdFx0ZWxzZVxuXHRcdFx0WzAsMF1cblxuXHQjIGdvIHRocm91Z2ggY2hpbGRyZW4gYW5kIHVud3JhcCBpbm5lciBub2Rlc1xuXHRkZWYgdW53cmFwXG5cdFx0dmFyIGFyeSA9IFtdXG5cdFx0Zm9yIG5vZGUsaSBpbiBub2Rlc1xuXHRcdFx0aWYgbm9kZSBpc2EgQmxvY2tcblx0XHRcdFx0IyBwIFwidW53cmFwcGluZyBpbm5lciBibG9ja1wiXG5cdFx0XHRcdGFyeTpwdXNoLmFwcGx5KGFyeSxub2RlLnVud3JhcClcblx0XHRcdGVsc2Vcblx0XHRcdFx0YXJ5LnB1c2gobm9kZSlcblx0XHRyZXR1cm4gYXJ5XG5cblx0ZGVmIHB1c2ggaXRlbVxuXHRcdEBub2Rlcy5wdXNoKGl0ZW0pXG5cdFx0c2VsZlxuXG5cdGRlZiBhZGQgaXRlbVxuXHRcdEBub2Rlcy5wdXNoKGl0ZW0pXG5cdFx0c2VsZlxuXG5cdCMgVGhpcyBpcyBqdXN0IHRvIHdvcmsgYXMgYW4gaW5wbGFjZSByZXBsYWNlbWVudCBvZiBub2Rlcy5jb2ZmZWVcblx0IyBBZnRlciB0aGluZ3MgYXJlIHdvcmtpbmcgb2theSB3ZSdsbCBkbyBiaWdnZXIgcmVmYWN0b3JpbmdzXG5cdGRlZiBjb21waWxlIG8gPSB7fVxuXHRcdHZhciByb290ID0gUm9vdC5uZXcoc2VsZixvKVxuXHRcdHJvb3QuY29tcGlsZShvKVxuXG5cblx0IyBOb3Qgc3VyZSBpZiB3ZSBzaG91bGQgY3JlYXRlIGEgc2VwYXJhdGUgYmxvY2s/XG5cdGRlZiBhbmFseXplIG8gPSB7fVxuXHRcdCMgcCBcImFuYWx5emluZyBibG9jayEhIVwiLG9cblx0XHRzZWxmXG5cblx0ZGVmIGNwYXJ0IG5vZGVcblx0XHR2YXIgb3V0ID0gdHlwZW9mIG5vZGUgPT0gJ3N0cmluZycgPyBub2RlIDogKG5vZGUgPyBub2RlLmMgOiBcIlwiKVxuXHRcdHJldHVybiBcIlwiIGlmIG91dCA9PSBudWxsIG9yIG91dCA9PSB1bmRlZmluZWQgb3Igb3V0ID09IFwiXCJcblxuXHRcdGlmIG91dCBpc2EgQXJyYXlcblx0XHRcdHZhciBzdHIgPSBcIlwiXG5cdFx0XHR2YXIgbCA9IG91dDpsZW5ndGhcblx0XHRcdHZhciBpID0gMFxuXHRcdFx0d2hpbGUgaSA8IGxcblx0XHRcdFx0c3RyICs9IGNwYXJ0KG91dFtpKytdKVxuXHRcdFx0cmV0dXJuIHN0clxuXG5cdFx0dmFyIGhhc1NlbWlDb2xvbiA9IFNFTUlDT0xPTl9URVNULnRlc3Qob3V0KVxuXHRcdG91dCArPSBcIjtcIiB1bmxlc3MgaGFzU2VtaUNvbG9uIG9yIG5vZGUgaXNhIE1ldGFcblx0XHRyZXR1cm4gb3V0XG5cblx0ZGVmIGpzIG8sIG9wdHNcblx0XHR2YXIgYXN0ID0gQG5vZGVzXG5cdFx0dmFyIGwgPSBhc3Q6bGVuZ3RoXG5cdFx0IyByZWFsbHk/XG5cdFx0dmFyIGV4cHJlc3MgPSBpc0V4cHJlc3Npb24gb3Igby5pc0V4cHJlc3Npb24gb3IgKG9wdGlvbig6ZXhwcmVzcykgYW5kIGlzRXhwcmVzc2FibGUpXG5cdFx0cmV0dXJuICcnIGlmIGFzdDpsZW5ndGggPT0gMFxuXG5cdFx0aWYgZXhwcmVzc1xuXHRcdFx0cmV0dXJuIHN1cGVyKG8sbm9kZXM6IGFzdClcblxuXHRcdHZhciBzdHIgPSBcIlwiXG5cdFx0Zm9yIHYgaW4gYXN0XG5cdFx0XHRzdHIgKz0gY3BhcnQodilcblxuXHRcdCMgbm93IGFkZCB0aGUgaGVhZCBpdGVtcyBhcyB3ZWxsXG5cdFx0aWYgQGhlYWQgYW5kIEBoZWFkOmxlbmd0aCA+IDBcblx0XHRcdHZhciBwcmVmaXggPSBcIlwiXG5cdFx0XHRmb3IgdiBpbiBAaGVhZFxuXHRcdFx0XHR2YXIgaHYgPSBjcGFydCh2KVxuXHRcdFx0XHRwcmVmaXggKz0gaHYgKyAnXFxuJyBpZiBodlxuXHRcdFx0c3RyID0gcHJlZml4ICsgc3RyXG5cdFx0cmV0dXJuIHN0clxuXG5cblx0IyBTaG91bGQgdGhpcyBjcmVhdGUgdGhlIGZ1bmN0aW9uIGFzIHdlbGw/XG5cdGRlZiBkZWZlcnMgb3JpZ2luYWwsIHJlcGxhY2VtZW50XG5cdFx0dmFyIGlkeCA9IEBub2Rlcy5pbmRleE9mKG9yaWdpbmFsKVxuXHRcdEBub2Rlc1tpZHhdID0gcmVwbGFjZW1lbnQgaWYgaWR4ID49IDBcblx0XHR2YXIgcmVzdCA9IEBub2Rlcy5zcGxpY2UoaWR4ICsgMSlcblx0XHRyZXR1cm4gcmVzdFxuXG5cdGRlZiBleHByZXNzaW9uc1xuXHRcdHZhciBleHByZXNzaW9ucyA9IFtdXG5cdFx0Zm9yIG5vZGUgaW4gbm9kZXNcblx0XHRcdGV4cHJlc3Npb25zLnB1c2gobm9kZSkgdW5sZXNzIG5vZGUgaXNhIFRlcm1pbmF0b3Jcblx0XHRyZXR1cm4gZXhwcmVzc2lvbnNcblx0XHRcblxuXHRkZWYgY29uc3VtZSBub2RlXG5cdFx0aWYgbm9kZSBpc2EgVGFnVHJlZSAjIHNwZWNpYWwgY2FzZT8hP1xuXHRcdFx0QG5vZGVzID0gQG5vZGVzLm1hcCBkbyB8Y2hpbGR8XG5cdFx0XHRcdGNoaWxkLmNvbnN1bWUobm9kZSlcblxuXHRcdFx0bGV0IHJlYWwgPSBleHByZXNzaW9uc1xuXHRcdFx0IyBGSVhNRSBzaG91bGQgbm90IGluY2x1ZGUgdGVybWluYXRvcnMgYW5kIGNvbW1lbnRzIHdoZW4gY291bnRpbmdcblx0XHRcdCMgc2hvdWxkIG9ubHkgd3JhcCB0aGUgY29udGVudCBpbiBhcnJheSAocmV0dXJuaW5nIGFsbCBwYXJ0cylcblx0XHRcdCMgZm9yIGlmL2Vsc2UgYmxvY2tzIC0tIG5vdCBsb29wc1xuXG5cdFx0XHQjIHdlIG5lZWQgdG8gY29tcGFyZSB0aGUgcmVhbCBsZW5ndGhcblx0XHRcdGlmICFub2RlLkBsb29wICYmIHJlYWw6bGVuZ3RoID4gMVxuXHRcdFx0XHQjIHAgXCJsZW5ndGhzXCIsQG5vZGVzOmxlbmd0aCxleHByZXNzaW9uczpsZW5ndGhcblx0XHRcdFx0bGV0IG5yID0gbm9kZS5ibG9ja3MucHVzaChzZWxmKVxuXHRcdFx0XHR2YXIgYXJyID0gQXJyLm5ldyhBcmdMaXN0Lm5ldyggQG5vZGVzICkpXG5cdFx0XHRcdGFyci5pbmRlbnRlZChAaW5kZW50YXRpb24pXG5cdFx0XHRcdEBpbmRlbnRhdGlvbiA9IG51bGxcblxuXHRcdFx0XHRpZiBub2RlLnJlYWN0aXZlXG5cdFx0XHRcdFx0QG5vZGVzID0gW1V0aWwuY2FsbEltYmEoXCJzdGF0aWNcIixbYXJyLE51bS5uZXcobnIpXSldXG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRAbm9kZXMgPSBbYXJyXVxuXG5cdFx0XHRcblx0XHRcblx0XHRcdHJldHVybiBzZWxmXG5cblx0XHQjIGNhbiBhbHNvIHJldHVybiBzdXBlciBpZiBpdCBpcyBleHByZXNzYWJsZSwgYnV0IHNob3VsZCB3ZSByZWFsbHk/XG5cdFx0aWYgdmFyIGJlZm9yZSA9IGxhc3Rcblx0XHRcdHZhciBhZnRlciA9IGJlZm9yZS5jb25zdW1lKG5vZGUpXG5cdFx0XHRpZiBhZnRlciAhPSBiZWZvcmVcblx0XHRcdFx0IyBwIFwicmVwbGFjZSBub2RlIGluIGJsb2NrIHtiZWZvcmV9IC0+IHthZnRlcn1cIlxuXHRcdFx0XHRpZiBhZnRlciBpc2EgQmxvY2tcblx0XHRcdFx0XHQjIHAgXCJyZXBsYWNlZCB3aXRoIGJsb2NrIC0tIHNob3VsZCBiYXNpY2FsbHkgYWRkIGl0IGluc3RlYWQ/XCJcblx0XHRcdFx0XHRhZnRlciA9IGFmdGVyLm5vZGVzXG5cblx0XHRcdFx0cmVwbGFjZShiZWZvcmUsYWZ0ZXIpXG5cdFx0IyByZWFsbHk/XG5cdFx0cmV0dXJuIHNlbGZcblxuXG5cdGRlZiBpc0V4cHJlc3NhYmxlXG5cdFx0cmV0dXJuIG5vIHVubGVzcyBAbm9kZXMuZXZlcnkofHZ8IHYuaXNFeHByZXNzYWJsZSApXG5cdFx0cmV0dXJuIHllc1xuXG5cdGRlZiBpc0V4cHJlc3Npb25cblx0XG5cdFx0b3B0aW9uKDpleHByZXNzKSB8fCBAZXhwcmVzc2lvblxuXG5cbiMgdGhpcyBpcyBhbG1vc3QgbGlrZSB0aGUgb2xkIFZhckRlY2xhcmF0aW9ucyBidXQgd2l0aG91dCB0aGUgdmFsdWVzXG5leHBvcnQgY2xhc3MgVmFyQmxvY2sgPCBMaXN0Tm9kZVxuXG5cblx0ZGVmIGxvYWQgbGlzdFxuXHRcdHZhciBmaXJzdCA9IGxpc3RbMF1cblxuXHRcdGlmIGZpcnN0IGlzYSBBc3NpZ25cblx0XHRcdEB0eXBlID0gZmlyc3QubGVmdC5AdHlwZVxuXHRcdGVsaWYgZmlyc3QgaXNhIFZhclJlZmVyZW5jZVxuXHRcdFx0QHR5cGUgPSBmaXJzdC5AdHlwZVxuXHRcdCMgcCBcImhlcmUge2xpc3RbMF19IC0ge0B0eXBlfVwiXG5cdFx0IyBAdHlwZSA9IGxpc3RbMF0gYW5kIGxpc3RbMF0udHlwZVxuXHRcdGxpc3Rcblx0XHRcblx0IyBUT0RPIEFsbCB0aGVzZSBpbm5lciBpdGVtcyBzaG91bGQgcmF0aGVyIGJlIHN0cmFpZ2h0IHVwIGxpdGVyYWxzXG5cdCMgb3IgYmFzaWMgbG9jYWx2YXJzIC0gd2l0aG91dCBhbnkgY2FyZSB3aGF0c29ldmVyIGFib3V0IGFkZGluZyB2YXIgdG8gdGhlXG5cdCMgYmVnaW5uaW5nIGV0Yy4gXG5cdGRlZiBhZGRFeHByZXNzaW9uIGV4cHJcblx0XHQjIHAgXCJWYXJCbG9jay5hZGRFeHByZXNzaW9uIHtzZWxmfSA8LSB7ZXhwcn1cIlxuXG5cdFx0aWYgZXhwciBpc2EgQXNzaWduXG5cdFx0XHQjIG1ha2Ugc3VyZSB0aGUgbGVmdC1zaWRlIGlzIGEgdmFyLXJlZmVyZW5jZVxuXHRcdFx0IyB0aGlzIHNob3VsZCBiZSBhIGRpZmZlcmVudCB0eXBlIG9mIGFzc2lnbiwgbm8/XG5cdFx0XHRpZiBleHByLmxlZnQgaXNhIFZhck9yQWNjZXNzXG5cdFx0XHRcdGV4cHIubGVmdCA9IFZhclJlZmVyZW5jZS5uZXcoZXhwci5sZWZ0LnZhbHVlLEB0eXBlKVxuXG5cdFx0XHRwdXNoKGV4cHIpXG5cblx0XHRlbGlmIGV4cHIgaXNhIEFzc2lnblxuXHRcdFx0YWRkRXhwcmVzc2lvbihleHByLmxlZnQpICMgbWFrZSBzdXJlIHRoaXMgaXMgYSB2YWxpZCB0aGluZz9cblx0XHRcdCMgbWFrZSB0aGlzIGludG8gYSB0dXBsZSBpbnN0ZWFkXG5cdFx0XHQjIGRvZXMgbm90IG5lZWQgdG8gYmUgYSB0dXBsZT9cblx0XHRcdHJldHVybiBUdXBsZUFzc2lnbi5uZXcoJz0nLFR1cGxlLm5ldyhub2RlcyksZXhwci5yaWdodClcblxuXHRcdGVsaWYgZXhwciBpc2EgVmFyT3JBY2Nlc3Ncblx0XHRcdCMgdGhpcyBpcyByZWFsbHkgYSBWYXJSZWZlcmVuY2Vcblx0XHRcdHB1c2goVmFyUmVmZXJlbmNlLm5ldyhleHByLnZhbHVlLEB0eXBlKSlcblxuXHRcdGVsaWYgZXhwciBpc2EgU3BsYXQgJiYgZXhwci5ub2RlIGlzYSBWYXJPckFjY2Vzc1xuXHRcdFx0IyBwIFwiaXMgYSBzcGxhdCAtIG9ubHkgYWxsb3dlZCBpbiB0dXBsZS1hc3NpZ25tZW50XCJcblx0XHRcdCMgd2hhdD9cblx0XHRcdGV4cHIudmFsdWUgPSBWYXJSZWZlcmVuY2UubmV3KGV4cHIubm9kZS52YWx1ZSxAdHlwZSlcblx0XHRcdHB1c2goZXhwcilcblx0XHRlbHNlXG5cdFx0XHRwIFwiVmFyQmxvY2suYWRkRXhwcmVzc2lvbiB7c2VsZn0gPC0ge2V4cHJ9XCJcblx0XHRcdHRocm93IFwiVmFyQmxvY2sgZG9lcyBub3QgYWxsb3cgbm9uLXZhcmlhYmxlIGV4cHJlc3Npb25zXCJcblx0XHRzZWxmXG5cblxuXHRkZWYgaXNFeHByZXNzYWJsZVxuXHRcdCMgd2Ugd291bGQgbmVlZCB0byBmb3JjZS1kcm9wIHRoZSB2YXJpYWJsZXMsIG1ha2VzIGxpdHRsZSBzZW5zZVxuXHRcdCMgYnV0LCBpdCBjb3VsZCBiZSwgY291bGQganVzdCBwdXNoIHRoZSB2YXJpYWJsZXMgb3V0P1xuXHRcdG5vXG5cblx0ZGVmIGpzIG9cblx0XHQjIHAgXCJWYXJCbG9ja1wiXG5cdFx0IyBmb3IgbiBpbiBAbm9kZXNcblx0XHQjIFx0cCBcIlZhckJsb2NrIGNoaWxkIHtufVwiXG5cdFx0dmFyIGNvZGUgPSBjb21wYWN0X18oZmxhdHRlbl9fKGNhcnlfXyhub2RlcykpKVxuXHRcdGNvZGUgPSBjb2RlLmZpbHRlcih8bnwgbiAhPSBudWxsICYmIG4gIT0gdW5kZWZpbmVkICYmIG4gIT0gRU1QVFkpXG5cdFx0dmFyIG91dCA9IGNvZGUuam9pbihcIixcIilcblx0XHQjIHdlIGp1c3QgbmVlZCB0byB0cnVzdCB0aGF0IHRoZSB2YXJpYWJsZXMgaGF2ZSBiZWVuIGF1dG9kZWNsYXJlZCBiZWZvcmVoYW5kXG5cdFx0IyBpZiB3ZSBhcmUgaW5zaWRlIGFuIGV4cHJlc3Npb25cblx0XHRvdXQgPSBcInZhciBcIiArIG91dCB1bmxlc3Mgby5pc0V4cHJlc3Npb25cblx0XHRyZXR1cm4gb3V0XG5cblxuXHRkZWYgY29uc3VtZSBub2RlXG5cdFx0IyBJdCBkb2VzbnQgbWFrZSBtdWNoIHNlbnNlIGZvciBhIFZhckJsb2NrIHRvIGNvbnN1bWUgYW55dGhpbmdcblx0XHQjIGl0IHNob3VsZCBwcm9iYWJseSByZXR1cm4gdm9pZCBmb3IgbWV0aG9kc1xuXHRcdHJldHVybiBzZWxmXG5cblxuIyBDb3VsZCBpbmhlcml0IGZyb20gdmFsdWVOb2RlXG5leHBvcnQgY2xhc3MgUGFyZW5zIDwgVmFsdWVOb2RlXG5cblx0ZGVmIGluaXRpYWxpemUgdmFsdWUsIG9wZW4sIGNsb3NlXG5cdFx0c2V0dXBcblx0XHRAb3BlbiA9IG9wZW5cblx0XHRAY2xvc2UgPSBjbG9zZVxuXHRcdEB2YWx1ZSA9IGxvYWQodmFsdWUpXG5cdFxuXHRkZWYgbG9hZCB2YWx1ZVxuXHRcdEBub3BhcmVuID0gbm9cblx0XHR2YWx1ZSBpc2EgQmxvY2sgYW5kIHZhbHVlLmNvdW50ID09IDEgPyB2YWx1ZS5maXJzdCA6IHZhbHVlXG5cblx0ZGVmIGlzU3RyaW5nXG5cdFx0IyBjaGVja2luZyBpZiB0aGlzIGlzIGFuIGludGVycG9sYXRlZCBzdHJpbmdcblx0XHRAb3BlbiBhbmQgU3RyaW5nKEBvcGVuKSA9PSAnKFwiJyBvciB2YWx1ZS5pc1N0cmluZ1xuXHRcdFxuXHRkZWYganMgb1xuXG5cdFx0dmFyIHBhciA9IHVwXG5cdFx0dmFyIHYgPSBAdmFsdWVcblx0XHR2YXIgc3RyID0gbnVsbFxuXG5cdFx0QG5vcGFyZW4gPSB5ZXMgaWYgdiBpc2EgRnVuY1xuXHRcdCMgcCBcImNvbXBpbGUgcGFyZW5zIHt2fSB7diBpc2EgQmxvY2sgYW5kIHYuY291bnR9XCJcblx0XHQjIHAgXCJQYXJlbnMgdXAge3Bhcn0ge28uaXNFeHByZXNzaW9ufVwiXG5cdFx0aWYgcGFyIGlzYSBCbG9ja1xuXHRcdFx0IyBpcyBpdCB3b3J0aCBpdD9cblx0XHRcdEBub3BhcmVuID0geWVzIHVubGVzcyBvLmlzRXhwcmVzc2lvblxuXHRcdFx0c3RyID0gdiBpc2EgQXJyYXkgPyBjYXJ5X18odikgOiB2LmMoZXhwcmVzc2lvbjogby5pc0V4cHJlc3Npb24pXG5cdFx0ZWxzZVxuXHRcdFx0c3RyID0gdiBpc2EgQXJyYXkgPyBjYXJ5X18odikgOiB2LmMoZXhwcmVzc2lvbjogeWVzKVxuXG5cdFx0IyBjaGVjayBpZiB3ZSByZWFsbHkgbmVlZCBwYXJlbnMgaGVyZT9cblx0XHRyZXR1cm4gc3RyXG5cblx0ZGVmIHNldCBvYmpcblx0XHRjb25zb2xlLmxvZyBcIlBhcmVucyBzZXQge0pTT04uc3RyaW5naWZ5KG9iail9XCJcblx0XHRzdXBlcihvYmopXG5cdFx0XG5cblx0ZGVmIHNob3VsZFBhcmVudGhlc2l6ZVxuXHRcdCMgbm8gbmVlZCB0byBwYXJlbnRoZXNpemUgaWYgdGhpcyBpcyBhIGxpbmUgaW4gYSBibG9ja1xuXHRcdHJldHVybiBubyBpZiBAbm9wYXJlbiAjICBvciBwYXIgaXNhIEFyZ0xpc3Rcblx0XHRyZXR1cm4geWVzXG5cblxuXHRkZWYgcHJlYnJlYWsgYnJcblx0XHRzdXBlcihicilcblx0XHRjb25zb2xlLmxvZyBcIlBSRUJSRUFLXCJcblx0XHRAdmFsdWUucHJlYnJlYWsoYnIpIGlmIEB2YWx1ZVxuXHRcdHNlbGZcblxuXG5cdGRlZiBpc0V4cHJlc3NhYmxlXG5cdFx0QHZhbHVlLmlzRXhwcmVzc2FibGVcblxuXHRkZWYgY29uc3VtZSBub2RlXG5cdFx0QHZhbHVlLmNvbnN1bWUobm9kZSlcblxuXG4jIENvdWxkIGluaGVyaXQgZnJvbSB2YWx1ZU5vZGVcbiMgYW4gZXhwbGljaXQgZXhwcmVzc2lvbi1ibG9jayAod2l0aCBwYXJlbnMpIGlzIHNvbWV3aGF0IGRpZmZlcmVudFxuIyBjYW4gYmUgdXNlZCB0byByZXR1cm4gYWZ0ZXIgYW4gZXhwcmVzc2lvblxuZXhwb3J0IGNsYXNzIEV4cHJlc3Npb25CbG9jayA8IExpc3ROb2RlXG5cblxuXHRkZWYgY1xuXHRcdG1hcCh8aXRlbXwgaXRlbS5jKS5qb2luKFwiLFwiKVxuXG5cdGRlZiBjb25zdW1lIG5vZGVcblx0XHR2YWx1ZS5jb25zdW1lKG5vZGUpXG5cblx0ZGVmIGFkZEV4cHJlc3Npb24gZXhwclxuXHRcdCMgTmVlZCB0byB0YWtlIGNhcmUgb2YgdGhlIHNwbGF0IGhlcmUgdG8uLiBoYXp6bGVcblx0XHRpZiBleHByLm5vZGUgaXNhIEFzc2lnblxuXHRcdFx0IyBwIFwiaXMgYXNzaWdubWVudCFcIlxuXHRcdFx0cHVzaChleHByLmxlZnQpXG5cdFx0XHQjIG1ha2UgdGhpcyBpbnRvIGEgdHVwbGUgaW5zdGVhZFxuXHRcdFx0IyBwb3NzaWJseSBmaXggdGhpcyBhcyB3ZWxsPyE/XG5cdFx0XHRyZXR1cm4gVHVwbGVBc3NpZ24ubmV3KCc9JyxUdXBsZS5uZXcobm9kZXMpLGV4cHIucmlnaHQpXG5cdFx0ZWxzZVxuXHRcdFx0cHVzaChleHByKVxuXHRcdHNlbGZcblxuXG5cbiMgU1RBVEVNRU5UU1xuXG5leHBvcnQgY2xhc3MgUmV0dXJuIDwgU3RhdGVtZW50XG5cblx0cHJvcCB2YWx1ZVxuXG5cdGRlZiBpbml0aWFsaXplIHZcblx0XHRAdHJhdmVyc2VkID0gbm9cblx0XHRAdmFsdWUgPSB2IGlzYSBBcmdMaXN0IGFuZCB2LmNvdW50ID09IDEgPyB2Lmxhc3QgOiB2XG5cdFx0IyBAcHJlYnJlYWsgPSB2IGFuZCB2LkBwcmVicmVha1xuXHRcdCMgY29uc29sZS5sb2cgXCJyZXR1cm4/IT8ge3Z9XCIsQHByZWJyZWFrXG5cdFx0IyBpZiB2IGlzYSBBcmdMaXN0IGFuZCB2LmNvdW50ID09IDFcblx0XHRyZXR1cm4gc2VsZlxuXG5cdGRlZiB2aXNpdFxuXHRcdEB2YWx1ZS50cmF2ZXJzZSBpZiBAdmFsdWUgJiYgQHZhbHVlOnRyYXZlcnNlXG5cblx0ZGVmIGpzIG9cblx0XHR2YXIgdiA9IEB2YWx1ZVxuXG5cdFx0aWYgdiBpc2EgQXJnTGlzdFxuXHRcdFx0cmV0dXJuIFwicmV0dXJuIFt7di5jKGV4cHJlc3Npb246IHllcyl9XVwiXG5cdFx0ZWxpZiB2XG5cdFx0XHRyZXR1cm4gXCJyZXR1cm4ge3YuYyhleHByZXNzaW9uOiB5ZXMpfVwiXG5cdFx0ZWxzZVxuXHRcdFx0XCJyZXR1cm5cIlxuXG5cdGRlZiBjXG5cdFx0cmV0dXJuIHN1cGVyIGlmICF2YWx1ZSBvciB2YWx1ZS5pc0V4cHJlc3NhYmxlXG5cdFx0IyBwIFwicmV0dXJuIG11c3QgY2FzY2FkZSBpbnRvIHZhbHVlXCIucmVkXG5cdFx0dmFsdWUuY29uc3VtZShzZWxmKS5jXG5cblx0ZGVmIGNvbnN1bWUgbm9kZVxuXHRcdHJldHVybiBzZWxmXG5cbmV4cG9ydCBjbGFzcyBJbXBsaWNpdFJldHVybiA8IFJldHVyblxuXG5leHBvcnQgY2xhc3MgR3JlZWR5UmV0dXJuIDwgSW1wbGljaXRSZXR1cm5cblxuIyBjYW5ub3QgbGl2ZSBpbnNpZGUgYW4gZXhwcmVzc2lvbighKVxuZXhwb3J0IGNsYXNzIFRocm93IDwgU3RhdGVtZW50XG5cblx0ZGVmIGpzIG9cblx0XHRcInRocm93IHt2YWx1ZS5jfVwiXG5cblx0ZGVmIGNvbnN1bWUgbm9kZVxuXHRcdCMgUk9BRE1BUCBzaG91bGQgcG9zc2libHkgY29uc3VtZSB0byB0aGUgdmFsdWUgb2YgdGhyb3cgYW5kIHRoZW4gdGhyb3c/XG5cdFx0cmV0dXJuIHNlbGZcblx0XHRcblxuZXhwb3J0IGNsYXNzIExvb3BGbG93U3RhdGVtZW50IDwgU3RhdGVtZW50XG5cblx0cHJvcCBsaXRlcmFsXG5cdHByb3AgZXhwcmVzc2lvblxuXG5cdGRlZiBpbml0aWFsaXplIGxpdCwgZXhwclxuXHRcdHNlbGYubGl0ZXJhbCA9IGxpdFxuXHRcdHNlbGYuZXhwcmVzc2lvbiA9IGV4cHIgIyAmJiBBcmdMaXN0Lm5ldyhleHByKSAjIHJlYWxseT9cblxuXHRkZWYgdmlzaXRcblx0XHRleHByZXNzaW9uLnRyYXZlcnNlIGlmIGV4cHJlc3Npb25cblxuXHRkZWYgY29uc3VtZSBub2RlXG5cdFx0IyBwIFwiYnJlYWsvY29udGludWUgc2hvdWxkIGNvbnN1bWU/IVwiXG5cdFx0c2VsZlxuXG5cdGRlZiBjXG5cdFx0cmV0dXJuIHN1cGVyIHVubGVzcyBleHByZXNzaW9uXG5cdFx0IyBnZXQgdXAgdG8gdGhlIG91dGVyIGxvb3Bcblx0XHR2YXIgX2xvb3AgPSBTVEFDSy51cChMb29wKVxuXHRcdCMgcCBcImZvdW5kIGxvb3A/XCIsX2xvb3BcblxuXHRcdCMgbmVlZCB0byBmaXggdGhlIGdyYW1tYXIgZm9yIHRoaXMuIFJpZ2h0IG5vdyBpdCBcblx0XHQjIGlzIGxpa2UgYSBmYWtlIGNhbGwsIGJ1dCBzaG91bGQgb25seSBjYXJlIGFib3V0IHRoZSBmaXJzdCBhcmd1bWVudFxuXHRcdHZhciBleHByID0gc2VsZi5leHByZXNzaW9uXG5cblx0XHRpZiBfbG9vcC5jYXRjaGVyXG5cdFx0XHRleHByID0gZXhwci5jb25zdW1lKF9sb29wLmNhdGNoZXIpXG5cdFx0XHR2YXIgY29weSA9IHNlbGY6Y29uc3RydWN0b3IubmV3KGxpdGVyYWwpXG5cdFx0XHRCbG9jay5uZXcoW2V4cHIsY29weV0pLmNcblx0XHRlbGlmIGV4cHJcblx0XHRcdHZhciBjb3B5ID0gc2VsZjpjb25zdHJ1Y3Rvci5uZXcobGl0ZXJhbClcblx0XHRcdEJsb2NrLm5ldyhbZXhwcixjb3B5XSkuY1xuXHRcdGVsc2Vcblx0XHRcdHN1cGVyXG5cdFx0IyByZXR1cm4gXCJsb29wZmxvd1wiXG5cdFx0XG5cbmV4cG9ydCBjbGFzcyBCcmVha1N0YXRlbWVudCA8IExvb3BGbG93U3RhdGVtZW50XG5cdGRlZiBqcyBvIGRvIFwiYnJlYWtcIlxuXG5leHBvcnQgY2xhc3MgQ29udGludWVTdGF0ZW1lbnQgPCBMb29wRmxvd1N0YXRlbWVudFxuXHRkZWYganMgbyBkbyBcImNvbnRpbnVlXCJcblxuZXhwb3J0IGNsYXNzIERlYnVnZ2VyU3RhdGVtZW50IDwgU3RhdGVtZW50XG5cblxuIyBQQVJBTVNcblxuZXhwb3J0IGNsYXNzIFBhcmFtIDwgTm9kZVxuXG5cdHByb3AgbmFtZVxuXHRwcm9wIGluZGV4XG5cdHByb3AgZGVmYXVsdHNcblx0cHJvcCBzcGxhdFxuXHRwcm9wIHZhcmlhYmxlXG5cblx0IyB3aGF0IGFib3V0IG9iamVjdC1wYXJhbXM/XG5cblx0ZGVmIGluaXRpYWxpemUgbmFtZSwgZGVmYXVsdHMsIHR5cFxuXHRcdCMgY291bGQgaGF2ZSBpbnRyb2R1Y2VkIGJ1Z3MgYnkgbW92aW5nIGJhY2sgdG8gaWRlbnRpZmllciBoZXJlXG5cdFx0QHRyYXZlcnNlZCA9IG5vXG5cdFx0QG5hbWUgPSBuYW1lICMgLnZhbHVlICMgdGhpcyBpcyBhbiBpZGVudGlmaWVyKCEpXG5cdFx0QGRlZmF1bHRzID0gZGVmYXVsdHNcblx0XHRAdHlwID0gdHlwXG5cdFx0QHZhcmlhYmxlID0gbnVsbFxuXG5cdGRlZiB2YXJuYW1lXG5cdFx0QHZhcmlhYmxlID8gQHZhcmlhYmxlLmMgOiBuYW1lXG5cblx0ZGVmIGpzIG9cblx0XHRyZXR1cm4gQHZhcmlhYmxlLmMgaWYgQHZhcmlhYmxlXG5cblx0XHRpZiBkZWZhdWx0c1xuXHRcdFx0IyBzaG91bGQgbm90IGluY2x1ZGUgYW55IHNvdXJjZS1tYXBwaW5nIGhlcmU/XG5cdFx0XHRcImlmKHtuYW1lLmN9ID09IG51bGwpIHtuYW1lLmN9ID0ge2RlZmF1bHRzLmN9XCJcblx0XHQjIHNlZSBpZiB0aGlzIGlzIHRoZSBpbml0aWFsIGRlY2xhcmF0b3I/XG5cblx0ZGVmIHZpc2l0XG5cdFx0QGRlZmF1bHRzLnRyYXZlcnNlIGlmIEBkZWZhdWx0c1xuXHRcdHNlbGYudmFyaWFibGUgfHw9IHNjb3BlX18ucmVnaXN0ZXIobmFtZSxzZWxmKVxuXG5cdFx0aWYgQG5hbWUgaXNhIElkZW50aWZpZXJcblx0XHRcdCMgY2hhbmdlIHR5cGUgaGVyZT9cblx0XHRcdEBuYW1lLkB2YWx1ZS5AdHlwZSA9IFwiUEFSQU1WQVJcIiBpZiBAbmFtZS5AdmFsdWVcblx0XHRcdEBuYW1lLnJlZmVyZW5jZXMoQHZhcmlhYmxlKVxuXHRcdFx0IyBjb25zb2xlLmxvZyBcImdvdCBoZXJlISEge0BuYW1lOmNvbnN0cnVjdG9yfVwiXG5cdFx0XHQjIEBuYW1lLkB0b2tlbi5AdmFyaWFibGUgPSBAdmFyaWFibGUgaWYgQG5hbWUuQHRva2VuXG5cdFx0XG5cdFx0c2VsZlxuXG5cdGRlZiBhc3NpZ25tZW50XG5cdFx0T1AoJz0nLHZhcmlhYmxlLmFjY2Vzc29yLGRlZmF1bHRzKVxuXG5cdGRlZiBpc0V4cHJlc3NhYmxlXG5cdFx0IWRlZmF1bHRzIHx8IGRlZmF1bHRzLmlzRXhwcmVzc2FibGVcblx0XHQjIHAgXCJ2aXNpdGluZyBwYXJhbSEhIVwiXG5cblx0ZGVmIGR1bXBcblx0XHR7bG9jOiBsb2N9XG5cblx0ZGVmIGxvY1xuXHRcdEBuYW1lICYmIEBuYW1lLnJlZ2lvblxuXG5cdGRlZiB0b0pTT05cblx0XHR7XG5cdFx0XHR0eXBlOiB0eXBlTmFtZVxuXHRcdFx0bmFtZTogbmFtZVxuXHRcdFx0ZGVmYXVsdHM6IGRlZmF1bHRzXG5cdFx0fVxuXHRcdFxuXG5leHBvcnQgY2xhc3MgU3BsYXRQYXJhbSA8IFBhcmFtXG5cblx0ZGVmIGxvY1xuXHRcdCMgaGFja3kuLiBjYW5ub3Qga25vdyBmb3Igc3VyZSB0aGF0IHRoaXMgaXMgcmlnaHQ/XG5cdFx0dmFyIHIgPSBuYW1lLnJlZ2lvblxuXHRcdFtyWzBdIC0gMSxyWzFdXVxuXG5leHBvcnQgY2xhc3MgQmxvY2tQYXJhbSA8IFBhcmFtXG5cblx0ZGVmIGNcblx0XHRcImJsb2NrcGFyYW1cIlxuXG5cdGRlZiBsb2Ncblx0XHQjIGhhY2t5Li4gY2Fubm90IGtub3cgZm9yIHN1cmUgdGhhdCB0aGlzIGlzIHJpZ2h0P1xuXHRcdHZhciByID0gbmFtZS5yZWdpb25cblx0XHRbclswXSAtIDEsclsxXV1cblxuXG5leHBvcnQgY2xhc3MgT3B0aW9uYWxQYXJhbSA8IFBhcmFtXG5cbmV4cG9ydCBjbGFzcyBOYW1lZFBhcmFtIDwgUGFyYW1cblxuZXhwb3J0IGNsYXNzIFJlcXVpcmVkUGFyYW0gPCBQYXJhbVxuXG5leHBvcnQgY2xhc3MgTmFtZWRQYXJhbXMgPCBMaXN0Tm9kZVxuXG5cdHByb3AgaW5kZXhcblx0cHJvcCB2YXJpYWJsZVxuXG5cdGRlZiBsb2FkIGxpc3Rcblx0XHR2YXIgbG9hZCA9ICh8a3wgTmFtZWRQYXJhbS5uZXcoay5rZXksay52YWx1ZSkgKVxuXHRcdGxpc3QgaXNhIE9iaiA/IGxpc3QudmFsdWUubWFwKGxvYWQpIDogbGlzdFxuXG5cdGRlZiB2aXNpdFxuXHRcdHZhciBzID0gc2NvcGVfX1xuXHRcdEB2YXJpYWJsZSB8fD0gcy50ZW1wb3Jhcnkoc2VsZiwgcG9vbDogJ2tleXBhcnMnKVxuXHRcdEB2YXJpYWJsZS5wcmVkZWNsYXJlZFxuXG5cdFx0IyB0aGlzIGlzIGEgbGlzdG5vZGUsIHdoaWNoIHdpbGwgYXV0b21hdGljYWxseSB0cmF2ZXJzZVxuXHRcdCMgYW5kIHZpc2l0IGFsbCBjaGlsZHJlblxuXHRcdHN1cGVyXG5cdFx0IyByZWdpc3RlciB0aGUgaW5uZXIgdmFyaWFibGVzIGFzIHdlbGwoISlcblx0XHRzZWxmXG5cblxuXHRkZWYgdmFybmFtZVxuXHRcdHZhcmlhYmxlLmNcblxuXHRkZWYgbmFtZVxuXHRcdHZhcm5hbWVcblxuXHRkZWYganMgb1xuXHRcdFwibmFtZWRwYXJcIlxuXG5cdGRlZiB0b0pTT05cblx0XHR7XG5cdFx0XHR0eXBlOiB0eXBlTmFtZVxuXHRcdFx0bm9kZXM6IGZpbHRlcih8dnwgdiBpc2EgTmFtZWRQYXJhbSlcblx0XHR9XG5cblxuZXhwb3J0IGNsYXNzIEluZGV4ZWRQYXJhbSA8IFBhcmFtXG5cblx0cHJvcCBwYXJlbnRcblx0cHJvcCBzdWJpbmRleFxuXG5cdGRlZiB2aXNpdFxuXHRcdCMgcCBcIlZJU0lUIFBBUkFNIHtuYW1lfSFcIlxuXHRcdCMgYXJ5LlstMV0gIyBwb3NzaWJsZVxuXHRcdCMgYXJ5LigtMSkgIyBwb3NzaWJsZVxuXHRcdCMgc3RyKC9vay8sLTEpXG5cdFx0IyBzY29wZS5yZWdpc3RlcihAbmFtZSxzZWxmKVxuXHRcdCMgQlVHIFRoZSBkZWZhdWx0cyBzaG91bGQgcHJvYmFibHkgYmUgbG9va2VkIHVwIGxpa2UgdmFyc1xuXHRcdHNlbGYudmFyaWFibGUgfHw9IHNjb3BlX18ucmVnaXN0ZXIobmFtZSxzZWxmKVxuXHRcdHNlbGYudmFyaWFibGUucHJveHkocGFyZW50LnZhcmlhYmxlLHN1YmluZGV4KVxuXHRcdHNlbGZcblxuXG5leHBvcnQgY2xhc3MgQXJyYXlQYXJhbXMgPCBMaXN0Tm9kZVxuXG5cdHByb3AgaW5kZXhcblx0cHJvcCB2YXJpYWJsZVxuXG5cdGRlZiB2aXNpdFxuXHRcdHZhciBzID0gc2NvcGVfX1xuXHRcdEB2YXJpYWJsZSB8fD0gcy50ZW1wb3Jhcnkoc2VsZiwgcG9vbDogJ2tleXBhcnMnKVxuXHRcdEB2YXJpYWJsZS5wcmVkZWNsYXJlZFxuXG5cdFx0IyBub3cgd2hlbiB3ZSBsb29wIHRocm91Z2ggdGhlc2UgaW5uZXIgcGFyYW1zIC0gd2UgY3JlYXRlIHRoZSBwYXJzXG5cdFx0IyB3aXRoIHRoZSBjb3JyZWN0IG5hbWUsIGJ1dCBiaW5kIHRoZW0gdG8gdGhlIHBhcmVudFxuXHRcdHN1cGVyXG5cblx0ZGVmIG5hbWVcblx0XHR2YXJpYWJsZS5jXG5cblx0ZGVmIGxvYWQgbGlzdFxuXHRcdHJldHVybiBudWxsIHVubGVzcyBsaXN0IGlzYSBBcnJcblx0XHQjIHAgXCJsb2FkaW5nIGFycmF5cGFyYW1zXCJcblx0XHQjIHRyeSB0aGUgYmFzaWMgZmlyc3Rcblx0XHR1bmxlc3MgbGlzdC5zcGxhdFxuXHRcdFx0bGlzdC52YWx1ZS5tYXAgZG8gfHYsaXxcblx0XHRcdFx0IyBtdXN0IG1ha2Ugc3VyZSB0aGUgcGFyYW1zIGFyZSBzdXBwb3J0ZWQgaGVyZVxuXHRcdFx0XHQjIHNob3VsZCByZWFsbHkgbm90IHBhcnNlIGFueSBhcnJheSBhdCBhbGwoISlcblx0XHRcdFx0dmFyIG5hbWUgPSB2XG5cdFx0XHRcdGlmIHYgaXNhIFZhck9yQWNjZXNzXG5cdFx0XHRcdFx0IyBwIFwidmFyb3JhY2Nlc3Mge3YudmFsdWV9XCJcblx0XHRcdFx0XHQjIEZJWD9cblx0XHRcdFx0XHRuYW1lID0gdi52YWx1ZS52YWx1ZVxuXHRcdFx0XHRcdCMgdGhpcyBpcyBhY2NlcHRlZFxuXHRcdFx0XHRwYXJzZShuYW1lLHYsaSlcblxuXHRkZWYgcGFyc2UgbmFtZSxjaGlsZCxpXG5cdFx0dmFyIHBhcmFtID0gSW5kZXhlZFBhcmFtLm5ldyhuYW1lLG51bGwpXG5cblx0XHRwYXJhbS5wYXJlbnQgPSBzZWxmXG5cdFx0cGFyYW0uc3ViaW5kZXggPSBpXG5cdFx0cGFyYW1cblxuXHRkZWYgaGVhZCBhc3Rcblx0XHQjIFwiYXJyYXlwYXJhbXNcIlxuXHRcdHNlbGZcblxuZXhwb3J0IGNsYXNzIFBhcmFtTGlzdCA8IExpc3ROb2RlXG5cblx0cHJvcCBzcGxhdFxuXHRwcm9wIGJsb2NrXG5cblx0ZGVmIGF0IGluZGV4LCBmb3JjZSA9IG5vLCBuYW1lID0gbnVsbFxuXHRcdGlmIGZvcmNlXG5cdFx0XHRhZGQoUGFyYW0ubmV3KGNvdW50ID09IGluZGV4ICYmIG5hbWUgfHwgXCJfe2NvdW50fVwiKSkgdW50aWwgY291bnQgPiBpbmRleFxuXHRcdFx0IyBuZWVkIHRvIHZpc2l0IGF0IHRoZSBzYW1lIHRpbWUsIG5vP1xuXHRcdGxpc3RbaW5kZXhdXG5cblx0ZGVmIG1ldGFkYXRhXG5cdFx0ZmlsdGVyKHxwYXJ8ICEocGFyIGlzYSBNZXRhKSlcblxuXHRkZWYgdG9KU09OXG5cdFx0bWV0YWRhdGFcblxuXHRkZWYgdmlzaXRcblx0XHRAc3BsYXQgPSBmaWx0ZXIofHBhcnwgcGFyIGlzYSBTcGxhdFBhcmFtKVswXVxuXHRcdHZhciBibGsgPSBmaWx0ZXIofHBhcnwgcGFyIGlzYSBCbG9ja1BhcmFtKVxuXG5cdFx0aWYgYmxrOmxlbmd0aCA+IDFcblx0XHRcdGJsa1sxXS53YXJuIFwiYSBtZXRob2QgY2FuIG9ubHkgaGF2ZSBvbmUgJmJsb2NrIHBhcmFtZXRlclwiXG5cblx0XHRlbGlmIGJsa1swXSAmJiBibGtbMF0gIT0gbGFzdFxuXHRcdFx0YmxrWzBdLndhcm4gXCImYmxvY2sgbXVzdCBiZSB0aGUgbGFzdCBwYXJhbWV0ZXIgb2YgYSBtZXRob2RcIlxuXHRcdFx0IyB3YXJuIFwiJmJsb2NrIG11c3QgYmUgdGhlIGxhc3QgcGFyYW1ldGVyIG9mIGEgbWV0aG9kXCIsIGJsa1swXVxuXG5cdFx0IyBhZGQgbW9yZSB3YXJuaW5ncyBsYXRlcighKVxuXHRcdCMgc2hvdWxkIHByb2JhYmx5IHRocm93IGVycm9yIGFzIHdlbGwgdG8gc3RvcCBjb21waWxhdGlvblxuXG5cdFx0IyBuZWVkIHRvIHJlZ2lzdGVyIHRoZSByZXF1aXJlZC1wYXJzIGFzIHZhcmlhYmxlc1xuXHRcdHN1cGVyXG5cblx0ZGVmIGpzIG9cblx0XHRyZXR1cm4gRU1QVFkgaWYgY291bnQgPT0gMFxuXHRcdHJldHVybiBoZWFkKG8pIGlmIG8ucGFyZW50IGlzYSBCbG9ja1xuXG5cdFx0IyBpdGVtcyA9IG1hcCh8YXJnfCBhcmcubmFtZS5jICkuY29tcGFjdFxuXHRcdCMgcmV0dXJuIG51bGwgdW5sZXNzIGl0ZW1zWzBdXG5cblx0XHRpZiBvLnBhcmVudCBpc2EgQ29kZVxuXHRcdFx0IyByZW1vdmUgdGhlIHNwbGF0LCBmb3Igc3VyZS4uIG5lZWQgdG8gaGFuZGxlIHRoZSBvdGhlciBpdGVtcyBhcyB3ZWxsXG5cdFx0XHQjIHRoaXMgaXMgbWVzc3kgd2l0aCByZWZlcmVuY2VzIHRvIGFyZ3ZhcnMgZXRjIGV0Yy4gRml4XG5cdFx0XHR2YXIgcGFycyA9IG5vZGVzXG5cdFx0XHQjIHBhcnMgPSBmaWx0ZXIofGFyZ3wgYXJnICE9IEBzcGxhdCAmJiAhKGFyZyBpc2EgQmxvY2tQYXJhbSkpIGlmIEBzcGxhdFxuXHRcdFx0cGFycyA9IGZpbHRlcih8YXJnfCBhcmcgaXNhIFJlcXVpcmVkUGFyYW0gb3IgYXJnIGlzYSBPcHRpb25hbFBhcmFtKSBpZiBAc3BsYXRcblx0XHRcdGNvbXBhY3RfXyhwYXJzLm1hcCh8YXJnfCBjX18oYXJnLnZhcm5hbWUpICkpLmpvaW4oXCIsXCIpXG5cdFx0ZWxzZVxuXHRcdFx0dGhyb3cgXCJub3QgaW1wbGVtZW50ZWQgcGFyYW1saXN0IGpzXCJcblx0XHRcdFwidGFcIiArIGNvbXBhY3RfXyhtYXAofGFyZ3wgYXJnLmMgKSkuam9pbihcIixcIilcblxuXHRkZWYgaGVhZCBvXG5cdFx0dmFyIHJlZyA9IFtdXG5cdFx0dmFyIG9wdCA9IFtdXG5cdFx0dmFyIGJsayA9IG51bGxcblx0XHR2YXIgc3BsYXQgPSBudWxsXG5cdFx0dmFyIG5hbWVkID0gbnVsbFxuXHRcdHZhciBhcnlzID0gW11cblx0XHR2YXIgc2lnbmF0dXJlID0gW11cblx0XHR2YXIgaWR4ID0gMFxuXG5cdFx0bm9kZXMuZm9yRWFjaCBkbyB8cGFyLGl8XG5cdFx0XHRwYXIuaW5kZXggPSBpZHhcblx0XHRcdGlmIHBhciBpc2EgTmFtZWRQYXJhbXNcblx0XHRcdFx0c2lnbmF0dXJlLnB1c2goJ25hbWVkJylcblx0XHRcdFx0bmFtZWQgPSBwYXJcblx0XHRcdGVsaWYgcGFyIGlzYSBPcHRpb25hbFBhcmFtIFxuXHRcdFx0XHRzaWduYXR1cmUucHVzaCgnb3B0Jylcblx0XHRcdFx0b3B0LnB1c2gocGFyKVxuXHRcdFx0ZWxpZiBwYXIgaXNhIEJsb2NrUGFyYW1cblx0XHRcdFx0c2lnbmF0dXJlLnB1c2goJ2JsaycpXG5cdFx0XHRcdGJsayA9IHBhclxuXHRcdFx0ZWxpZiBwYXIgaXNhIFNwbGF0UGFyYW1cblx0XHRcdFx0c2lnbmF0dXJlLnB1c2goJ3NwbGF0Jylcblx0XHRcdFx0c3BsYXQgPSBwYXJcblx0XHRcdFx0aWR4IC09IDEgIyB0aGlzIHNob3VsZCByZWFsbHkgYmUgcmVtb3ZlZCBmcm9tIHRoZSBsaXN0LCBubz9cblx0XHRcdGVsaWYgcGFyIGlzYSBBcnJheVBhcmFtc1xuXHRcdFx0XHRhcnlzLnB1c2gocGFyKVxuXHRcdFx0XHRzaWduYXR1cmUucHVzaCgnYXJ5Jylcblx0XHRcdGVsc2Vcblx0XHRcdFx0c2lnbmF0dXJlLnB1c2goJ3JlZycpXG5cdFx0XHRcdHJlZy5wdXNoKHBhcilcblx0XHRcdGlkeCsrXG5cblx0XHRpZiBuYW1lZFxuXHRcdFx0dmFyIG5hbWVkdmFyID0gbmFtZWQudmFyaWFibGVcblxuXHRcdCMgdmFyIG9wdCA9IG5vZGVzLmZpbHRlcih8bnwgbiBpc2EgT3B0aW9uYWxQYXJhbSlcblx0XHQjIHZhciBibGsgPSBub2Rlcy5maWx0ZXIofG58IG4gaXNhIEJsb2NrUGFyYW0pWzBdXG5cdFx0IyB2YXIgc3BsYXQgPSBub2Rlcy5maWx0ZXIofG58IG4gaXNhIFNwbGF0UGFyYW0pWzBdXG5cblx0XHQjIHNpbXBsZSBzaXR1YXRpb24gd2hlcmUgd2Ugc2ltcGx5IHN3aXRjaFxuXHRcdCMgY2FuIHByb2JhYmx5IG9wdGltaXplIGJ5IG5vdCBsb29raW5nIGF0IGFyZ3VtZW50cyBhdCBhbGxcblx0XHR2YXIgYXN0ID0gW11cblx0XHR2YXIgaXNGdW5jID0gZG8gfGpzfCBcInR5cGVvZiB7anN9ID09ICdmdW5jdGlvbidcIlxuXG5cdFx0IyBUaGlzIGlzIGJyb2tlbiB3aGVuIGRlYWxpbmcgd2l0aCBpZnJhbWVzIGFuYyBYU1Mgc2NyaXB0aW5nXG5cdFx0IyBidXQgZm9yIG5vdyBpdCBpcyB0aGUgYmVzdCB0ZXN0IGZvciBhY3R1YWwgYXJndW1lbnRzXG5cdFx0IyBjYW4gYWxzbyBkbyBjb25zdHJ1Y3Rvci5uYW1lID09ICdPYmplY3QnXG5cdFx0dmFyIGlzT2JqID0gZG8gfGpzfCBcIntqc30uY29uc3RydWN0b3IgPT09IE9iamVjdFwiXG5cdFx0dmFyIGlzbnRPYmogPSBkbyB8anN8IFwie2pzfS5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0XCJcblx0XHQjIHNob3VsZCBoYW5kbGUgc29tZSBjb21tb24gY2FzZXMgaW4gYSBjbGVhbmVyIChsZXNzIHZlcmJvc2UpIG1hbm5lclxuXHRcdCMgZG9lcyB0aGlzIHdvcmsgd2l0aCBkZWZhdWx0IHBhcmFtcyBhZnRlciBvcHRpb25hbCBvbmVzPyBJcyB0aGF0IGV2ZW4gd29ydGggYW55dGhpbmc/XG5cdFx0IyB0aGlzIG9ubHkgd29ya3MgaW4gb25lIGRpcmVjdGlvbiBub3csIHVubGlrZSBUdXBsZUFzc2lnblxuXG5cdFx0IyB3ZSBkb250IHJlYWxseSBjaGVjayB0aGUgbGVuZ3RoIGV0YyBub3cgLS0gc28gaXQgaXMgYnVnZ3kgZm9yIGxvdHMgb2YgYXJndW1lbnRzXG5cblx0XHQjIGlmIHdlIGhhdmUgb3B0aW9uYWwgcGFyYW1zIGluIHRoZSByZWd1bGFyIG9yZGVyIGV0YyB3ZSBjYW4gZ28gdGhlIGVhc3kgcm91dGVcblx0XHQjIHNsaWdodGx5IGhhY2t5IG5vdy4gU2hvdWxkIHJlZmFjdG9yIGFsbCBvZiB0aGVzZSB0byB1c2UgdGhlIHNpZ25hdHVyZT9cblx0XHRpZiAhbmFtZWQgJiYgIXNwbGF0ICYmICFibGsgJiYgb3B0Omxlbmd0aCA+IDAgJiYgc2lnbmF0dXJlLmpvaW4oXCIgXCIpLm1hdGNoKC9vcHQkLylcblx0XHRcdGZvciBwYXIsaSBpbiBvcHRcblx0XHRcdFx0YXN0LnB1c2ggXCJpZih7cGFyLm5hbWUuY30gPT09IHVuZGVmaW5lZCkge3Bhci5uYW1lLmN9ID0ge3Bhci5kZWZhdWx0cy5jfVwiXG5cblx0XHRcblx0XHRlbGlmIG5hbWVkICYmICFzcGxhdCAmJiAhYmxrICYmIG9wdDpsZW5ndGggPT0gMCAjIGFuZCBubyBibG9jaz8hXG5cdFx0XHQjIGRpZmZlcmVudCBzaG9ydGhhbmRzXG5cdFx0XHQjIGlmIG5hbWVkXG5cdFx0XHRhc3QucHVzaCBcImlmKCF7bmFtZWR2YXIuY318fHtpc250T2JqKG5hbWVkdmFyLmMpfSkge25hbWVkdmFyLmN9ID0gXFx7XFx9XCJcblxuXHRcdGVsaWYgYmxrICYmIG9wdDpsZW5ndGggPT0gMSAmJiAhc3BsYXQgJiYgIW5hbWVkXG5cdFx0XHR2YXIgb3AgPSBvcHRbMF1cblx0XHRcdHZhciBvcG4gPSBvcC5uYW1lLmNcblx0XHRcdHZhciBibiA9IGJsay5uYW1lLmNcblx0XHRcdGFzdC5wdXNoIFwiaWYoe2JufT09dW5kZWZpbmVkICYmIHtpc0Z1bmMob3BuKX0pIHtibn0gPSB7b3BufSx7b3BufSA9IHtvcC5kZWZhdWx0cy5jfVwiXG5cdFx0XHRhc3QucHVzaCBcImlmKHtvcG59PT11bmRlZmluZWQpIHtvcG59ID0ge29wLmRlZmF1bHRzLmN9XCJcblxuXHRcdGVsaWYgYmxrICYmIG5hbWVkICYmIG9wdDpsZW5ndGggPT0gMCAmJiAhc3BsYXRcblx0XHRcdHZhciBibiA9IGJsay5uYW1lLmNcblx0XHRcdGFzdC5wdXNoIFwiaWYoe2JufT09dW5kZWZpbmVkICYmIHtpc0Z1bmMobmFtZWR2YXIuYyl9KSB7Ym59ID0ge25hbWVkdmFyLmN9LHtuYW1lZHZhci5jfSA9IFxce1xcfVwiXG5cdFx0XHRhc3QucHVzaCBcImVsc2UgaWYoIXtuYW1lZHZhci5jfXx8e2lzbnRPYmoobmFtZWR2YXIuYyl9KSB7bmFtZWR2YXIuY30gPSBcXHtcXH1cIlxuXG5cdFx0ZWxpZiBvcHQ6bGVuZ3RoID4gMCB8fCBzcGxhdCAjICYmIGJsayAgIyAmJiAhc3BsYXRcblxuXHRcdFx0dmFyIGFyZ3ZhciA9IHNjb3BlX18udGVtcG9yYXJ5KHNlbGYsIHBvb2w6ICdhcmd1bWVudHMnKS5wcmVkZWNsYXJlZC5jXG5cdFx0XHR2YXIgbGVuID0gc2NvcGVfXy50ZW1wb3Jhcnkoc2VsZiwgcG9vbDogJ2NvdW50ZXInKS5wcmVkZWNsYXJlZC5jXG5cblx0XHRcdHZhciBsYXN0ID0gXCJ7YXJndmFyfVt7bGVufS0xXVwiXG5cdFx0XHR2YXIgcG9wID0gXCJ7YXJndmFyfVstLXtsZW59XVwiXG5cdFx0XHRhc3QucHVzaCBcInZhciB7YXJndmFyfSA9IGFyZ3VtZW50cywge2xlbn0gPSB7YXJndmFyfS5sZW5ndGhcIlxuXG5cdFx0XHRpZiBibGtcblx0XHRcdFx0dmFyIGJuID0gYmxrLm5hbWUuY1xuXHRcdFx0XHRpZiBzcGxhdFxuXHRcdFx0XHRcdGFzdC5wdXNoIFwidmFyIHtibn0gPSB7aXNGdW5jKGxhc3QpfSA/IHtwb3B9IDogbnVsbFwiXG5cdFx0XHRcdGVsaWYgcmVnOmxlbmd0aCA+IDBcblx0XHRcdFx0XHQjIGFzdC5wdXNoIFwiLy8gc2V2ZXJhbCByZWdzIHJlYWxseT9cIlxuXHRcdFx0XHRcdGFzdC5wdXNoIFwidmFyIHtibn0gPSB7bGVufSA+IHtyZWc6bGVuZ3RofSAmJiB7aXNGdW5jKGxhc3QpfSA/IHtwb3B9IDogbnVsbFwiXG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRhc3QucHVzaCBcInZhciB7Ym59ID0ge2lzRnVuYyhsYXN0KX0gPyB7cG9wfSA6IG51bGxcIlxuXG5cdFx0XHQjIGlmIHdlIGhhdmUgbmFtZWQgcGFyYW1zIC0gbG9vayBmb3IgdGhlbSBiZWZvcmUgc3BsYXRcblx0XHRcdCMgc2hvdWxkIHByb2JhYmx5IGxvb3AgdGhyb3VnaCBwYXJzIGluIHRoZSBzYW1lIG9yZGVyIHRoZXkgd2VyZSBhZGRlZFxuXHRcdFx0IyBzaG91bGQgaXQgYmUgcHJpb3JpdGl6ZWQgYWJvdmUgb3B0aW9uYWwgb2JqZWN0cz8/XG5cdFx0XHRpZiBuYW1lZFxuXHRcdFx0XHQjIHNob3VsZCBub3QgaW5jbHVkZSBpdCB3aGVuIHRoZXJlIGlzIGEgc3BsYXQ/XG5cdFx0XHRcdGFzdC5wdXNoIFwidmFyIHtuYW1lZHZhci5jfSA9IHtsYXN0fSYme2lzT2JqKGxhc3QpfSA/IHtwb3B9IDogXFx7XFx9XCJcblxuXHRcdFx0Zm9yIHBhcixpIGluIG9wdFxuXHRcdFx0XHRhc3QucHVzaCBcImlmKHtsZW59IDwge3Bhci5pbmRleCArIDF9KSB7cGFyLm5hbWUuY30gPSB7cGFyLmRlZmF1bHRzLmN9XCJcblxuXHRcdFx0IyBhZGQgdGhlIHNwbGF0XG5cdFx0XHRpZiBzcGxhdFxuXHRcdFx0XHR2YXIgc24gPSBzcGxhdC5uYW1lLmNcblx0XHRcdFx0dmFyIHNpID0gc3BsYXQuaW5kZXhcblxuXHRcdFx0XHRpZiBzaSA9PSAwXG5cdFx0XHRcdFx0YXN0LnB1c2ggXCJ2YXIge3NufSA9IG5ldyBBcnJheSh7bGVufT57c2l9ID8ge2xlbn0gOiAwKVwiXG5cdFx0XHRcdFx0YXN0LnB1c2ggXCJ3aGlsZSh7bGVufT57c2l9KSB7c259W3tsZW59LTFdID0ge3BvcH1cIlxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0YXN0LnB1c2ggXCJ2YXIge3NufSA9IG5ldyBBcnJheSh7bGVufT57c2l9ID8ge2xlbn0te3NpfSA6IDApXCJcblx0XHRcdFx0XHRhc3QucHVzaCBcIndoaWxlKHtsZW59PntzaX0pIHtzbn1bLS17bGVufSAtIHtzaX1dID0ge2FyZ3Zhcn1be2xlbn1dXCJcblxuXHRcdFx0IyBpZiBuYW1lZFxuXHRcdFx0IyBcdGZvciBrLGkgaW4gbmFtZWQubm9kZXNcblx0XHRcdCMgXHRcdCMgT1AoJy4nLG5hbWVkdmFyKSA8LSB0aGlzIGlzIHRoZSByaWdodCB3YXksIHdpdGggaW52YWxpZCBuYW1lcyBldGNcblx0XHRcdCMgXHRcdHZhciBvcCA9IE9QKCcuJyxuYW1lZHZhcixrLmtleSkuY1xuXHRcdFx0IyBcdFx0YXN0LnB1c2ggXCJ2YXIge2sua2V5LmN9ID0ge29wfSAhPT0gdW5kZWZpbmVkID8ge29wfSA6IHtrLnZhbHVlLmN9XCJcblxuXHRcdFx0IyBpZiBuYW1lZFxuXG5cdFx0XHQjIHJldHVybiBhc3Quam9pbihcIjtcXG5cIikgKyBcIjtcIlxuXHRcdFx0IyByZXR1cm4gXCJpZih7b3B0WzBdLm5hbWUuY30gaW5zdGFuY2VvZiBGdW5jdGlvbikge2Jsay5jfSA9IHtvcHRbMF0uY307XCJcblxuXG5cdFx0ZWxpZiBvcHQ6bGVuZ3RoID4gMFxuXHRcdFx0Zm9yIHBhcixpIGluIG9wdFxuXHRcdFx0XHRhc3QucHVzaCBcImlmKHtwYXIubmFtZS5jfSA9PT0gdW5kZWZpbmVkKSB7cGFyLm5hbWUuY30gPSB7cGFyLmRlZmF1bHRzLmN9XCJcblxuXHRcdCMgbm93IHNldCBzdHVmZiBpZiBuYW1lZCBwYXJhbXMoISlcblxuXHRcdGlmIG5hbWVkXG5cdFx0XHRmb3IgayxpIGluIG5hbWVkLm5vZGVzXG5cdFx0XHRcdCMgY29uc29sZS5sb2cgXCJuYW1lZCB2YXIge2suY31cIlxuXHRcdFx0XHR2YXIgb3AgPSBPUCgnLicsbmFtZWR2YXIsay5jKS5jXG5cdFx0XHRcdGFzdC5wdXNoIFwidmFyIHtrLmN9ID0ge29wfSAhPT0gdW5kZWZpbmVkID8ge29wfSA6IHtrLmRlZmF1bHRzLmN9XCJcblxuXHRcdGlmIGFyeXM6bGVuZ3RoXG5cdFx0XHRmb3IgdixpIGluIGFyeXNcblx0XHRcdFx0IyBjcmVhdGUgdHVwbGVzXG5cdFx0XHRcdCMgcCBcImFkZGluZyBhcnJheXBhcmFtc1wiXG5cdFx0XHRcdHYuaGVhZChvLGFzdCxzZWxmKVxuXHRcdFx0XHQjIGFzdC5wdXNoIHYuY1xuXHRcdFx0XHRcblxuXG5cdFx0IyBpZiBvcHQ6bGVuZ3RoID09IDBcblx0XHRyZXR1cm4gYXN0Omxlbmd0aCA+IDAgPyAoYXN0LmpvaW4oXCI7XFxuXCIpICsgXCI7XCIpIDogRU1QVFlcblxuXG4jIExlZ2FjeS4gU2hvdWxkIG1vdmUgYXdheSBmcm9tIHRoaXM/XG5leHBvcnQgY2xhc3MgVmFyaWFibGVEZWNsYXJhdGlvbiA8IExpc3ROb2RlXG5cblx0IyBmb3IgbGF0ZXIsIG1vei1hc3Qgc3R5bGVcblx0cHJvcCBraW5kXG5cblx0IyB3ZSB3YW50IHRvIHJlZ2lzdGVyIHRoZXNlIHZhcmlhYmxlcyBpblxuXHRkZWYgYWRkIG5hbWUsIGluaXQsIHBvcyA9IC0xXG5cdFx0dmFyIHZhcmRlYyA9IFZhcmlhYmxlRGVjbGFyYXRvci5uZXcobmFtZSxpbml0KVxuXHRcdHZhcmRlYy52YXJpYWJsZSA9IG5hbWUgaWYgbmFtZSBpc2EgVmFyaWFibGVcblx0XHRwb3MgPT0gMCA/IHVuc2hpZnQodmFyZGVjKSA6IHB1c2godmFyZGVjKVxuXHRcdHZhcmRlY1xuXG5cdFx0IyBUT0RPICh0YXJnZXQpIDw8IChub2RlKSByZXdyaXRlcyB0byBhIGNhY2hpbmcgcHVzaCB3aGljaCByZXR1cm5zIG5vZGVcblxuXHQjIGRlZiByZW1vdmUgaXRlbVxuXHQjIFx0aWYgaXRlbSBpc2EgVmFyaWFibGVcblx0IyBcdFx0bWFwIGRvIHx2LGl8XG5cdCMgXHRcdFx0aWYgdi52YXJpYWJsZSA9PSBpdGVtXG5cdCMgXHRcdFx0XHRwIFwiZm91bmQgdmFyaWFibGUgdG8gcmVtb3ZlXCJcblx0IyBcdFx0XHRcdHN1cGVyLnJlbW92ZSh2KVxuXHQjIFx0ZWxzZVxuXHQjIFx0XHRzdXBlci5yZW1vdmUoaXRlbSlcblx0IyBcdHNlbGZcblx0XG5cdGRlZiBsb2FkIGxpc3Rcblx0XHQjIHRlbXBvcmFyeSBzb2x1dGlvbiEhIVxuXHRcdGxpc3QubWFwIGRvIHxwYXJ8IFZhcmlhYmxlRGVjbGFyYXRvci5uZXcocGFyLm5hbWUscGFyLmRlZmF1bHRzLHBhci5zcGxhdClcblxuXHRkZWYgaXNFeHByZXNzYWJsZVxuXHRcdG5vZGVzLmV2ZXJ5KHxpdGVtfCBpdGVtLmlzRXhwcmVzc2FibGUpXG5cblx0ZGVmIGpzIG9cblx0XHRyZXR1cm4gRU1QVFkgaWYgY291bnQgPT0gMFxuXG5cdFx0aWYgY291bnQgPT0gMSAmJiAhaXNFeHByZXNzYWJsZVxuXHRcdFx0IyBwIFwiU0hPVUxEIEFMVEVSIFZBUkRFQyEhIVwiLmN5YW5cblx0XHRcdGZpcnN0LnZhcmlhYmxlLmF1dG9kZWNsYXJlXG5cdFx0XHR2YXIgbm9kZSA9IGZpcnN0LmFzc2lnbm1lbnRcblx0XHRcdHJldHVybiBub2RlLmNcblxuXHRcdCMgRklYIFBFUkZPUk1BTkNFXG5cdFx0dmFyIG91dCA9IGNvbXBhY3RfXyhjYXJ5X18obm9kZXMpKS5qb2luKFwiLCBcIilcblx0XHRvdXQgPyBcInZhciB7b3V0fVwiIDogXCJcIlxuXHRcdCMgXCJ2YXIgXCIgKyBjb21wYWN0X18oY2FyeV9fKG5vZGVzKSkuam9pbihcIiwgXCIpICsgXCJcIlxuXG5leHBvcnQgY2xhc3MgVmFyaWFibGVEZWNsYXJhdG9yIDwgUGFyYW1cblxuXHQjIGNhbiBwb3NzaWJseSBjcmVhdGUgdGhlIHZhcmlhYmxlIGltbWVkaWF0ZWx5IGJ1dCB3YWl0IHdpdGggc2NvcGUtZGVjbGFyaW5nXG5cdCMgV2hhdCBpZiB0aGlzIGlzIG1lcmVseSB0aGUgZGVjbGFyYXRpb24gb2YgYSBzeXN0ZW0vdGVtcG9yYXJ5IHZhcmlhYmxlP1xuXHRkZWYgdmlzaXRcblx0XHQjIGV2ZW4gaWYgd2Ugc2hvdWxkIHRyYXZlcnNlIHRoZSBkZWZhdWx0cyBhcyBpZiB0aGlzIHZhcmlhYmxlIGRvZXMgbm90IGV4aXN0XG5cdFx0IyB3ZSBuZWVkIHRvIHByZXJlZ2lzdGVyIGl0IGFuZCB0aGVuIGFjdGl2YXRlIGl0IGxhdGVyXG5cdFx0c2VsZi52YXJpYWJsZSB8fD0gc2NvcGVfXy5yZWdpc3RlcihuYW1lLG51bGwpXG5cdFx0ZGVmYXVsdHMudHJhdmVyc2UgaWYgZGVmYXVsdHNcblx0XHQjIFdBUk4gd2hhdCBpZiBpdCBpcyBhbHJlYWR5IGRlY2xhcmVkP1xuXHRcdHNlbGYudmFyaWFibGUuZGVjbGFyYXRvciA9IHNlbGZcblx0XHRzZWxmLnZhcmlhYmxlLmFkZFJlZmVyZW5jZShuYW1lKVxuXHRcdHNlbGZcblx0XHRcblx0IyBuZWVkcyB0byBiZSBsaW5rZWQgdXAgdG8gdGhlIGFjdHVhbCBzY29wZWQgdmFyaWFibGVzLCBubz9cblx0ZGVmIGpzIG9cblx0XHRyZXR1cm4gbnVsbCBpZiB2YXJpYWJsZS5AcHJveHlcblxuXHRcdHZhciBkZWZzID0gZGVmYXVsdHNcblx0XHQjIEZJWE1FIG5lZWQgdG8gZGVhbCB3aXRoIHZhci1kZWZpbmVzIHdpdGhpbiBvdGhlciBzdGF0ZW1lbnRzIGV0Y1xuXHRcdCMgRklYTUUgbmVlZCBiZXR0ZXIgc3ludGF4IGZvciB0aGlzXG5cdFx0aWYgZGVmcyAhPSBudWxsICYmIGRlZnMgIT0gdW5kZWZpbmVkXG5cdFx0XHQjIGNvbnNvbGUubG9nIFwiZGVmYXVsdHMgaXMge2RlZmF1bHRzfVwiXG5cdFx0XHRkZWZzID0gZGVmcy5jKGV4cHJlc3Npb246IHllcykgaWYgZGVmcyBpc2EgTm9kZVxuXG5cdFx0XHRcInt2YXJpYWJsZS5jfSA9IHtkZWZzfVwiXG5cdFx0ZWxzZVxuXHRcdFx0XCJ7dmFyaWFibGUuY31cIlxuXG5cdGRlZiBhY2Nlc3NvclxuXHRcdHNlbGZcblxuXG4jIFRPRE8gY2xlYW4gdXAgYW5kIHJlZmFjdG9yIGFsbCB0aGUgZGlmZmVyZW50IHJlcHJlc2VudGF0aW9ucyBvZiB2YXJzXG4jIFZhck5hbWUsIFZhclJlZmVyZW5jZSwgTG9jYWxWYXJBY2Nlc3M/XG5leHBvcnQgY2xhc3MgVmFyTmFtZSA8IFZhbHVlTm9kZVxuXG5cdHByb3AgdmFyaWFibGVcblx0cHJvcCBzcGxhdFxuXG5cdGRlZiBpbml0aWFsaXplIGEsYlxuXHRcdHN1cGVyXG5cdFx0QHNwbGF0ID0gYlxuXG5cdGRlZiB2aXNpdFxuXHRcdCMgcCBcInZpc2l0aW5nIHZhcm5hbWUoISlcIiwgdmFsdWUuY1xuXHRcdCMgc2hvdWxkIHdlIG5vdCBsb29rdXAgaW5zdGVhZD9cblx0XHQjIEZJWE1FIHAgXCJyZWdpc3RlciB2YWx1ZSB7dmFsdWUuY31cIlxuXHRcdHNlbGYudmFyaWFibGUgfHw9IHNjb3BlX18ucmVnaXN0ZXIodmFsdWUuYyxudWxsKVxuXHRcdHNlbGYudmFyaWFibGUuZGVjbGFyYXRvciA9IHNlbGZcblx0XHRzZWxmLnZhcmlhYmxlLmFkZFJlZmVyZW5jZSh2YWx1ZSlcblx0XHRzZWxmXG5cblx0ZGVmIGpzIG9cblx0XHR2YXJpYWJsZS5jXG5cblx0ZGVmIGNcblx0XHR2YXJpYWJsZS5jXHRcdFxuXHRcdFxuXG5leHBvcnQgY2xhc3MgVmFyTGlzdCA8IE5vZGVcblxuXHRwcm9wIHR5cGUgIyBsZXQgLyB2YXIgLyBjb25zdFxuXHRwcm9wIGxlZnRcblx0cHJvcCByaWdodFxuXG5cdCMgZm9ybWF0IDp0eXBlLCA6bGVmdCwgOnJpZ2h0XG5cblx0IyBzaG91bGQgdGhyb3cgZXJyb3IgaWYgdGhlcmUgYXJlIG1vcmUgdmFsdWVzIG9uIHJpZ2h0IHRoYW4gbGVmdFxuXG5cdGRlZiBpbml0aWFsaXplIHQsbCxyXG5cdFx0QHRyYXZlcnNlZCA9IG5vXG5cdFx0QHR5cGUgPSB0eXBlXG5cdFx0QGxlZnQgPSBsXG5cdFx0QHJpZ2h0ID0gclxuXG5cdGRlZiB2aXNpdFxuXG5cdFx0IyB3ZSBuZWVkIHRvIGNhcmVmdWxseSB0cmF2ZXJzZSBjaGlsZHJlbiBpbiB0aGUgcmlnaHQgb3JkZXJcblx0XHQjIHNpbmNlIHdlIHNob3VsZCBiZSBhYmxlIHRvIHJlZmVyZW5jZVxuXHRcdGZvciBsLGkgaW4gbGVmdFxuXHRcdFx0bC50cmF2ZXJzZSAjIHRoaXMgc2hvdWxkIHJlYWxseSBiZSBhIHZhci1kZWNsYXJhdGlvblxuXHRcdFx0ci50cmF2ZXJzZSBpZiB2YXIgciA9IHJpZ2h0W2ldXG5cdFx0c2VsZlxuXG5cdGRlZiBqcyBvXG5cdFx0IyBmb3IgdGhlIHJlZ3VsYXIgaXRlbXMgXG5cdFx0dmFyIHBhaXJzID0gW11cblx0XHR2YXIgbGwgPSBsZWZ0Omxlbmd0aFxuXHRcdHZhciBybCA9IHJpZ2h0Omxlbmd0aFxuXHRcdHZhciB2ID0gbnVsbFxuXG5cdFx0IyBzcGxhdHRpbmcgaGVyZSB3ZSBjb21lXG5cdFx0aWYgbGwgPiAxICYmIHJsID09IDFcblx0XHRcdHAgXCJtdWx0aWFzc2lnbiFcIlxuXHRcdFx0dmFyIHIgPSByaWdodFswXVxuXHRcdFx0ci5jYWNoZVxuXHRcdFx0Zm9yIGwsaSBpbiBsZWZ0XG5cdFx0XHRcdGlmIGwuc3BsYXRcblx0XHRcdFx0XHR0aHJvdyBcIm5vdCBzdXBwb3J0ZWQ/XCJcblx0XHRcdFx0XHRwIFwic3BsYXRcIiAjIEZJWCByZWltcGxlbWVudCBzbGljZT9cblx0XHRcdFx0XHRpZiBpID09IGxsIC0gMVxuXHRcdFx0XHRcdFx0diA9IHV0aWwuc2xpY2UocixpKVxuXHRcdFx0XHRcdFx0cCBcImxhc3RcIlxuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdHYgPSB1dGlsLnNsaWNlKHIsaSwtKGxsIC0gaSkgKyAxKVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0diA9IE9QKCcuJyxyLG51bV9fKGkpKVxuXHRcdFx0XHRcblx0XHRcdFx0cGFpcnMucHVzaChPUCgnPScsbCx2KSlcblxuXHRcdGVsc2Vcblx0XHRcdGZvciBsLGkgaW4gbGVmdFxuXHRcdFx0XHR2YXIgciA9IHJpZ2h0W2ldXG5cdFx0XHRcdHBhaXJzLnB1c2gociA/IE9QKCc9JyxsLnZhcmlhYmxlLmFjY2Vzc29yLHIpIDogbClcblxuXHRcdHJldHVybiBcInZhciB7cGFpcnMuY31cIlxuXG5cbiMgQ09ERVxuXG5leHBvcnQgY2xhc3MgQ29kZSA8IE5vZGVcblxuXHRwcm9wIGhlYWRcblx0cHJvcCBib2R5XG5cdHByb3Agc2NvcGVcblx0cHJvcCBwYXJhbXNcblxuXHRkZWYgc2NvcGV0eXBlXG5cdFx0U2NvcGVcblxuXHRkZWYgdmlzaXRcblx0XHRAc2NvcGUudmlzaXQgaWYgQHNjb3BlXG5cdFx0IyBAc2NvcGUucGFyZW50ID0gU1RBQ0suc2NvcGUoMSkgaWYgQHNjb3BlXG5cdFx0c2VsZlxuXG5cbiMgUmVuYW1lIHRvIFByb2dyYW0/XG5leHBvcnQgY2xhc3MgUm9vdCA8IENvZGVcblxuXHRkZWYgaW5pdGlhbGl6ZSBib2R5LCBvcHRzXG5cdFx0IyBwIFwiY3JlYXRlIHJvb3QhXCJcblx0XHRAdHJhdmVyc2VkID0gbm9cblx0XHRAYm9keSA9IGJsa19fKGJvZHkpXG5cdFx0QHNjb3BlID0gUm9vdFNjb3BlLm5ldyhzZWxmLG51bGwpXG5cdFx0QG9wdGlvbnMgPSB7fVxuXG5cdGRlZiB2aXNpdFxuXHRcdFJPT1QgPSBTVEFDSy5ST09UID0gQHNjb3BlXG5cdFx0c2NvcGUudmlzaXRcblx0XHRib2R5LnRyYXZlcnNlXG5cblx0ZGVmIGNvbXBpbGUgb1xuXHRcdFNUQUNLLnJlc2V0ICMgLS0gbmVzdGVkIGNvbXBpbGF0aW9uIGRvZXMgbm90IHdvcmsgbm93XG5cdFx0T1BUUyA9IFNUQUNLLkBvcHRpb25zID0gQG9wdGlvbnMgPSBvIG9yIHt9XG5cblx0XHR0cmF2ZXJzZVxuXG5cdFx0dmFyIG91dCA9IGNcblx0XHR2YXIgcmVzdWx0ID0ge1xuXHRcdFx0anM6IG91dCxcblx0XHRcdGFzdDogc2VsZixcblx0XHRcdHdhcm5pbmdzOiBzY29wZS53YXJuaW5ncyxcblx0XHRcdG9wdGlvbnM6IG8sXG5cdFx0XHR0b1N0cmluZzogKGRvIHRoaXM6anMpXG5cdFx0fVxuXHRcdGlmIG86c291cmNlTWFwSW5saW5lIG9yIG86c291cmNlTWFwXG5cdFx0XHRyZXN1bHQ6c291cmNlbWFwID0gU291cmNlTWFwLm5ldyhyZXN1bHQpLmdlbmVyYXRlXG5cblx0XHRyZXR1cm4gcmVzdWx0XG5cblx0ZGVmIGpzIG9cblx0XHR2YXIgb3V0XG5cdFx0aWYgQG9wdGlvbnM6YmFyZVxuXHRcdFx0b3V0ID0gc2NvcGUuY1xuXHRcdGVsc2Vcblx0XHRcdGJvZHkuY29uc3VtZShJbXBsaWNpdFJldHVybi5uZXcpXG5cdFx0XHRvdXQgPSBzY29wZS5jKGluZGVudDogeWVzKVxuXHRcdFx0b3V0ID0gb3V0LnJlcGxhY2UoL15cXG4/LywnXFxuJylcblx0XHRcdG91dCA9IG91dC5yZXBsYWNlKC9cXG4/JC8sJ1xcblxcbicpXG5cdFx0XHRvdXQgPSAnKGZ1bmN0aW9uKCl7JyArIG91dCArICd9KSgpJ1xuXG5cdFx0IyBmaW5kIGFuZCByZXBsYWNlIHNoZWJhbmdzXG5cdFx0dmFyIHNoZWJhbmdzID0gW11cblx0XHRvdXQgPSBvdXQucmVwbGFjZSgvXlsgXFx0XSpcXC9cXC8oXFwhLispJC9tZykgZG8gfG0sc2hlYmFuZ3xcblx0XHRcdCMgcCBcImZvdW5kIHNoZWJhbmcge3NoZWJhbmd9XCJcblx0XHRcdHNoZWJhbmcgPSBzaGViYW5nLnJlcGxhY2UoL1xcYmltYmFcXGIvZywnbm9kZScpXG5cdFx0XHRzaGViYW5ncy5wdXNoKFwiI3tzaGViYW5nfVxcblwiKVxuXHRcdFx0cmV0dXJuIFwiXCJcblxuXHRcdG91dCA9IHNoZWJhbmdzLmpvaW4oJycpICsgb3V0XG5cblx0XHRyZXR1cm4gb3V0XG5cblxuXHRkZWYgYW5hbHl6ZSBsb2dsZXZlbDogMCwgZW50aXRpZXM6IG5vLCBzY29wZXM6IHllc1xuXHRcdFNUQUNLLmxvZ2xldmVsID0gbG9nbGV2ZWxcblx0XHRTVEFDSy5AYW5hbHl6aW5nID0gdHJ1ZVxuXHRcdFJPT1QgPSBTVEFDSy5ST09UID0gQHNjb3BlXG5cblx0XHRPUFRTID0ge1xuXHRcdFx0YW5hbHlzaXM6IHtcblx0XHRcdFx0ZW50aXRpZXM6IGVudGl0aWVzLFxuXHRcdFx0XHRzY29wZXM6IHNjb3Blc1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRyYXZlcnNlXG5cdFx0U1RBQ0suQGFuYWx5emluZyA9IGZhbHNlXG5cblx0XHRyZXR1cm4gc2NvcGUuZHVtcFxuXG5cdGRlZiBpbnNwZWN0XG5cdFx0dHJ1ZVxuXG5leHBvcnQgY2xhc3MgQ2xhc3NEZWNsYXJhdGlvbiA8IENvZGVcblxuXHRwcm9wIG5hbWVcblx0cHJvcCBzdXBlcmNsYXNzXG5cdHByb3AgaW5pdG9yXG5cblx0ZGVmIGNvbnN1bWUgbm9kZVxuXHRcdGlmIG5vZGUgaXNhIFJldHVyblxuXHRcdFx0b3B0aW9uKCdyZXR1cm4nLHllcylcblx0XHRcdHJldHVybiBzZWxmXG5cdFx0c3VwZXJcblxuXHRkZWYgbmFtZXBhdGhcblx0XHRAbmFtZXBhdGggfHw9IFwie25hbWUuY31cIlxuXG5cdGRlZiBtZXRhZGF0YVxuXHRcdHtcblx0XHRcdHR5cGU6ICdjbGFzcydcblx0XHRcdG5hbWVwYXRoOiBuYW1lcGF0aFxuXHRcdFx0aW5oZXJpdHM6IHN1cGVyY2xhc3M/Lm5hbWVwYXRoXG5cdFx0XHRwYXRoOiBuYW1lLmMudG9TdHJpbmdcblx0XHRcdGRlc2M6IEBkZXNjXG5cdFx0XHRsb2M6IGxvY1xuXHRcdH1cdFxuXG5cdGRlZiB0b0pTT05cblx0XHRtZXRhZGF0YVxuXG5cdGRlZiBpbml0aWFsaXplIG5hbWUsIHN1cGVyY2xhc3MsIGJvZHlcblx0XHQjIHdoYXQgYWJvdXQgdGhlIG5hbWVzcGFjZT9cblx0XHRAdHJhdmVyc2VkID0gbm9cblx0XHRAbmFtZSA9IG5hbWVcblx0XHRAc3VwZXJjbGFzcyA9IHN1cGVyY2xhc3Ncblx0XHRAc2NvcGUgPSBDbGFzc1Njb3BlLm5ldyhzZWxmKVxuXHRcdEBib2R5ID0gYmxrX18oYm9keSlcblx0XHRzZWxmXG5cblx0ZGVmIHZpc2l0XG5cdFx0IyByZXBsYWNlIHdpdGggc29tZSBhZHZhbmNlZCBsb29rdXA/XG5cdFx0Uk9PVC5lbnRpdGllcy5hZGQobmFtZXBhdGgsc2VsZilcblx0XHRzY29wZS52aXNpdFxuXHRcdGJvZHkudHJhdmVyc2Vcblx0XHRzZWxmXG5cblx0ZGVmIGpzIG9cblx0XHRzY29wZS52aXJ0dWFsaXplICMgaXMgdGhpcyBhbHdheXMgbmVlZGVkP1xuXHRcdHNjb3BlLmNvbnRleHQudmFsdWUgPSBuYW1lXG5cblx0XHQjIHNob3VsZCBwcm9iYWJseSBhbHNvIHdhcm4gYWJvdXQgc3R1ZmYgZXRjXG5cdFx0aWYgb3B0aW9uKDpleHRlbnNpb24pXG5cdFx0XHRyZXR1cm4gYm9keS5jXG5cblx0XHR2YXIgaGVhZCA9IFtdXG5cdFx0dmFyIG8gPSBAb3B0aW9ucyBvciB7fVxuXHRcdHZhciBjbmFtZSA9IG5hbWUgaXNhIEFjY2VzcyA/IG5hbWUucmlnaHQgOiBuYW1lXG5cdFx0dmFyIG5hbWVzcGFjZWQgPSBuYW1lICE9IGNuYW1lXG5cdFx0dmFyIGluaXRvciA9IG51bGxcblx0XHR2YXIgc3VwID0gc3VwZXJjbGFzc1xuXG5cdFx0dmFyIGJvZHlpbmRleCA9IC0xXG5cdFx0dmFyIHNwYWNlcyA9IGJvZHkuZmlsdGVyIGRvIHxpdGVtfCBpdGVtIGlzYSBUZXJtaW5hdG9yXG5cdFx0dmFyIG1hcmsgPSBtYXJrX18ob3B0aW9uKCdrZXl3b3JkJykpXG5cblx0XHRib2R5Lm1hcCBkbyB8YyxpfFxuXHRcdFx0aWYgYyBpc2EgTWV0aG9kRGVjbGFyYXRpb24gJiYgYy50eXBlID09IDpjb25zdHJ1Y3RvclxuXHRcdFx0XHRib2R5aW5kZXggPSBpXG5cblx0XHRpZiBib2R5aW5kZXggPj0gMFxuXHRcdFx0aW5pdG9yID0gYm9keS5yZW1vdmVBdChib2R5aW5kZXgpXG5cblx0XHQjIHZhciBpbml0b3IgPSBib2R5LnBsdWNrIGRvIHxjfCBjIGlzYSBNZXRob2REZWNsYXJhdGlvbiAmJiBjLnR5cGUgPT0gOmNvbnN0cnVjdG9yXG5cdFx0IyBjb21waWxlIHRoZSBjbmFtZVxuXHRcdGNuYW1lID0gY25hbWUuYyB1bmxlc3MgdHlwZW9mIGNuYW1lID09ICdzdHJpbmcnXG5cblx0XHR2YXIgY3BhdGggPSB0eXBlb2YgbmFtZSAgPT0gJ3N0cmluZycgPyBuYW1lIDogbmFtZS5jXG5cblx0XHRpZiAhaW5pdG9yXG5cdFx0XHRpZiBzdXBcblx0XHRcdFx0aW5pdG9yID0gXCJ7bWFya31mdW5jdGlvbiB7Y25hbWV9KClcXHsgcmV0dXJuIHtzdXAuY30uYXBwbHkodGhpcyxhcmd1bWVudHMpIFxcfTtcXG5cXG5cIlxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRpbml0b3IgPSBcInttYXJrfWZ1bmN0aW9uIHtjbmFtZX0oKVwiICsgJ3sgfTtcXG5cXG4nXG5cdFx0XHRcblx0XHRlbHNlXG5cdFx0XHRpbml0b3IubmFtZSA9IGNuYW1lXG5cdFx0XHRpbml0b3IgPSBpbml0b3IuYyArICc7J1xuXHRcdFxuXHRcdCMgaWYgd2UgYXJlIGRlZmluaW5nIGEgY2xhc3MgaW5zaWRlIGEgbmFtZXNwYWNlIGV0YyAtLSBob3cgc2hvdWxkIHdlIHNldCB1cCB0aGUgY2xhc3M/XG5cdFx0XG5cdFx0aWYgbmFtZXNwYWNlZFxuXHRcdFx0IyBzaG91bGQgdXNlIE5vZGVzIHRvIGJ1aWxkIHRoaXMgaW5zdGVhZFxuXHRcdFx0aW5pdG9yID0gXCJ7Y3BhdGh9ID0ge2luaXRvcn1cIiAjIE9QKCc9JyxuYW1lLGluaXRvcilcblxuXHRcdGhlYWQucHVzaChpbml0b3IpICMgLy8gQGNsYXNzIHtjbmFtZX1cXG5cblxuXHRcdGlmIGJvZHlpbmRleCA+PSAwXG5cdFx0XHQjIGFkZCB0aGUgc3BhY2UgYWZ0ZXIgaW5pdG9yP1xuXHRcdFx0aWYgYm9keS5pbmRleChib2R5aW5kZXgpIGlzYSBUZXJtaW5hdG9yXG5cdFx0XHRcdGhlYWQucHVzaChib2R5LnJlbW92ZUF0KGJvZHlpbmRleCkpXG5cdFx0ZWxzZVxuXHRcdFx0IyBoZWFkLnB1c2goVGVybWluYXRvci5uZXcoJ1xcblxcbicpKVxuXHRcdFx0dHJ1ZVxuXHRcdFxuXG5cblx0XHRpZiBzdXBcblx0XHRcdCMgY29uc29sZS5sb2cgXCJkZWFsIHdpdGggc3VwZXJjbGFzcyFcIlxuXHRcdFx0IyBoZWFkLnB1c2goXCIvLyBleHRlbmRpbmcgdGhlIHN1cGVyY2xhc3NcXG5pbWJhJGNsYXNzKHtuYW1lLmN9LHtzdXAuY30pO1xcblxcblwiKVxuXHRcdFx0aGVhZC5wdXNoKFV0aWwuU3ViY2xhc3MubmV3KFtuYW1lLHN1cF0pKVxuXG5cdFx0IyBvbmx5IGlmIGl0IGlzIG5vdCBuYW1lc3BhY2VkXG5cdFx0aWYgbzpnbG9iYWwgYW5kICFuYW1lc3BhY2VkICMgb3B0aW9uKDpnbG9iYWwpXG5cdFx0XHRoZWFkLnB1c2goXCJnbG9iYWwue2NuYW1lfSA9IHtjcGF0aH07IC8vIGdsb2JhbCBjbGFzcyBcXG5cIilcblxuXHRcdGlmIG86ZXhwb3J0IGFuZCAhbmFtZXNwYWNlZFxuXHRcdFx0aGVhZC5wdXNoKFwiZXhwb3J0cy57Y25hbWV9ID0ge2NwYXRofTsgLy8gZXhwb3J0IGNsYXNzIFxcblwiKVxuXG5cdFx0IyBGSVhNRVxuXHRcdCMgaWYgbmFtZXNwYWNlZCBhbmQgKG86bG9jYWwgb3IgbzpleHBvcnQpXG5cdFx0IyBcdGNvbnNvbGUubG9nIFwibmFtZXNwYWNlZCBjbGFzc2VzIGFyZSBpbXBsaWNpdGx5IGxvY2FsL2dsb2JhbCBkZXBlbmRpbmcgb24gdGhlIG5hbWVzcGFjZVwiXG5cblx0XHRpZiBvcHRpb24oJ3JldHVybicpXG5cdFx0XHRib2R5LnB1c2goXCJyZXR1cm4ge2NwYXRofTtcIilcblxuXHRcdGJvZHkudW5zaGlmdChwYXJ0KSBmb3IgcGFydCBpbiBoZWFkLnJldmVyc2Vcblx0XHRib2R5LkBpbmRlbnRhdGlvbiA9IG51bGxcblx0XHR2YXIgZW5kID0gYm9keS5pbmRleChib2R5LmNvdW50IC0gMSlcblx0XHRib2R5LnBvcCBpZiBlbmQgaXNhIFRlcm1pbmF0b3IgYW5kIGVuZC5jOmxlbmd0aCA9PSAxXG5cblx0XHR2YXIgb3V0ID0gYm9keS5jXG5cblx0XHRyZXR1cm4gb3V0XG5cblxuZXhwb3J0IGNsYXNzIFRhZ0RlY2xhcmF0aW9uIDwgQ29kZVxuXG5cdHByb3AgbmFtZVxuXHRwcm9wIHN1cGVyY2xhc3Ncblx0cHJvcCBpbml0b3JcblxuXHRkZWYgbmFtZXBhdGhcblx0XHRcIjx7bmFtZX0+XCJcblxuXHRkZWYgdG9KU09OXG5cdFx0e1xuXHRcdFx0dHlwZTogJ3RhZydcblx0XHRcdG5hbWVwYXRoOiBuYW1lcGF0aFxuXHRcdFx0aW5oZXJpdHM6IHN1cGVyY2xhc3MgPyBcIjx7c3VwZXJjbGFzcy5uYW1lfT5cIiA6IG51bGxcblx0XHRcdGxvYzogbG9jXG5cdFx0XHRkZXNjOiBAZGVzY1xuXHRcdH1cblxuXHRkZWYgaW5pdGlhbGl6ZSBuYW1lLCBzdXBlcmNsYXNzLCBib2R5XG5cdFx0IyB3aGF0IGFib3V0IHRoZSBuYW1lc3BhY2U/XG5cdFx0IyBAbmFtZSA9IFRhZ1R5cGVSZWYubmV3KG5hbWUpXG5cdFx0QHRyYXZlcnNlZCA9IG5vXG5cdFx0QG5hbWUgPSBuYW1lXG5cdFx0QHN1cGVyY2xhc3MgPSBzdXBlcmNsYXNzXG5cdFx0QHNjb3BlID0gVGFnU2NvcGUubmV3KHNlbGYpXG5cdFx0QGJvZHkgPSBibGtfXyhib2R5IHx8IFtdKVxuXG5cdGRlZiB2aXNpdFxuXHRcdFJPT1QuZW50aXRpZXMucmVnaXN0ZXIoc2VsZikgIyB3aGF0IGlmIHRoaXMgaXMgbm90IGxvY2FsP1xuXG5cdFx0Zm9yIHNjb3BlLGkgaW4gU1RBQ0suc2NvcGVzXG5cdFx0XHRpZiBpID4gMCBhbmQgc2NvcGUgaXNhIFRhZ1Njb3BlXG5cdFx0XHRcdCMgcmVnaXN0ZXIgaW5zaWRlIGhlcmU/XG5cdFx0XHRcdHNjb3BlLm5vZGUub3B0aW9uKDpoYXNMb2NhbFRhZ3MseWVzKVxuXHRcdFx0XHRvcHRpb24oOnBhcmVudCxzY29wZS5ub2RlKVxuXHRcdFx0XHRicmVha1xuXHRcdFx0XHQjIGNvbnNvbGUubG9nIFwidGFnIGlzIGxvY2FsISEhXCJcblx0XHQjIHJlcGxhY2Ugd2l0aCBzb21lIGFkdmFuY2VkIGxvb2t1cD9cblx0XHRzY29wZS52aXNpdFxuXHRcdGJvZHkudHJhdmVyc2VcblxuXHRkZWYgaWRcblx0XHRuYW1lLmlkXG5cblx0ZGVmIHRhZ3NwYWNlXG5cdFx0dmFyIGN0eCA9IHNjb3BlLmNsb3N1cmUudGFnQ29udGV4dFBhdGhcblx0XHRuYW1lLm5zID8gXCJ7Y3R4fS57bmFtZS5ucy50b1VwcGVyQ2FzZX1cIiA6IGN0eFxuXG5cdGRlZiBqcyBvXG5cdFx0c2NvcGUuY29udGV4dC52YWx1ZSA9IEBjdHggPSBzY29wZS5kZWNsYXJlKCd0YWcnLG51bGwsc3lzdGVtOiB5ZXMpXG5cblx0XHR2YXIgbnMgPSBuYW1lLm5zXG5cdFx0dmFyIG1hcmsgPSBtYXJrX18ob3B0aW9uKCdrZXl3b3JkJykpXG5cblx0XHR2YXIgcGFyYW1zID0gW2hlbHBlcnMuc2luZ2xlcXVvdGUobmFtZS5uYW1lKV1cblx0XHR2YXIgY2JvZHkgPSBib2R5LmNcblx0XHQjIHZhciBvdXRib2R5ID0gYm9keS5jb3VudCA/IFwiLCBmdW5jdGlvbih7QGN0eC5jfSlcXHt7Y2JvZHl9XFx9XCIgOiAnJ1xuXG5cdFx0aWYgc3VwZXJjbGFzc1xuXHRcdFx0IyBXQVJOIHdoYXQgaWYgdGhlIHN1cGVyY2xhc3MgaGFzIGEgbmFtZXNwYWNlP1xuXHRcdFx0cGFyYW1zLnB1c2goaGVscGVycy5zaW5nbGVxdW90ZShzdXBlcmNsYXNzLm5hbWUpKVxuXG5cdFx0aWYgYm9keS5jb3VudFxuXHRcdFx0aWYgb3B0aW9uKDpoYXNMb2NhbFRhZ3MpXG5cdFx0XHRcdHBhcmFtcy5wdXNoKFwiZnVuY3Rpb24oe0BjdHguY30se3Njb3BlLmNsb3N1cmUudGFnQ29udGV4dFBhdGh9KVxce3tjYm9keX1cXH1cIilcblx0XHRcdGVsc2Vcblx0XHRcdFx0cGFyYW1zLnB1c2goXCJmdW5jdGlvbih7QGN0eC5jfSlcXHt7Y2JvZHl9XFx9XCIpXG5cblx0XHR2YXIgbWV0aCA9IG9wdGlvbig6ZXh0ZW5zaW9uKSA/ICdleHRlbmRUYWcnIDogJ2RlZmluZVRhZydcblx0XHQjIHJldHVybiBcInttYXJrfXt0YWdzcGFjZX0uZXh0ZW5kVGFnKCd7bmFtZS5uYW1lfSd7b3V0Ym9keX0pXCJcblxuXHRcdCMgdmFyIHN1cCA9IHN1cGVyY2xhc3MgYW5kIFwiLFwiICsgaGVscGVycy5zaW5nbGVxdW90ZShzdXBlcmNsYXNzLmZ1bmMpIG9yIFwiXCJcblxuXHRcdCMgdmFyIG91dCA9IGlmIG5hbWUuaWRcblx0XHQjXHRcInttYXJrfXt0YWdzcGFjZX0uZGVmaW5lU2luZ2xldG9uKCd7bmFtZS5uYW1lfSd7c3VwfXtvdXRib2R5fSlcIlxuXHRcdCMgZWxzZVxuXG5cdFx0cmV0dXJuIFwie21hcmt9e3RhZ3NwYWNlfS57bWV0aH0oe3BhcmFtcy5qb2luKCcsICcpfSlcIlxuXG5cdFx0IyByZXR1cm4gb3V0XG5cbmV4cG9ydCBjbGFzcyBGdW5jIDwgQ29kZVxuXG5cdHByb3AgbmFtZVxuXHRwcm9wIHBhcmFtc1xuXHRwcm9wIHRhcmdldFxuXHRwcm9wIG9wdGlvbnNcblx0cHJvcCB0eXBlXG5cdHByb3AgY29udGV4dFxuXG5cdGRlZiBzY29wZXR5cGUgZG8gRnVuY3Rpb25TY29wZVxuXG5cdGRlZiBpbml0aWFsaXplIHBhcmFtcywgYm9keSwgbmFtZSwgdGFyZ2V0LCBvXG5cdFx0IyBwIFwiSU5JVCBGdW5jdGlvbiEhXCIscGFyYW1zLGJvZHksbmFtZVxuXHRcdHZhciB0eXAgPSBzY29wZXR5cGVcblx0XHRAdHJhdmVyc2VkID0gbm9cblx0XHRAYm9keSA9IGJsa19fKGJvZHkpXG5cdFx0QHNjb3BlIHx8PSAobyBhbmQgbzpzY29wZSkgfHwgdHlwLm5ldyhzZWxmKVxuXHRcdEBzY29wZS5wYXJhbXMgPSBAcGFyYW1zID0gUGFyYW1MaXN0Lm5ldyhwYXJhbXMpXG5cdFx0QG5hbWUgPSBuYW1lIHx8ICcnXG5cdFx0QHRhcmdldCA9IHRhcmdldFxuXHRcdEBvcHRpb25zID0gb1xuXHRcdEB0eXBlID0gOmZ1bmN0aW9uXG5cdFx0QHZhcmlhYmxlID0gbnVsbFxuXHRcdHNlbGZcblxuXHRkZWYgdmlzaXRcblx0XHRzY29wZS52aXNpdFxuXHRcdEBjb250ZXh0ID0gc2NvcGUucGFyZW50XG5cdFx0QHBhcmFtcy50cmF2ZXJzZVxuXHRcdEBib2R5LnRyYXZlcnNlICMgc28gc29vbj9cblx0XHRcblxuXHRkZWYganMgb1xuXHRcdGJvZHkuY29uc3VtZShJbXBsaWNpdFJldHVybi5uZXcpIHVubGVzcyBvcHRpb24oOm5vcmV0dXJuKVxuXHRcdHZhciBpbmQgPSBib2R5LkBpbmRlbnRhdGlvblxuXHRcdCMgdmFyIHMgPSBpbmQgYW5kIGluZC5Ab3BlblxuXHRcdCMgcCBcImluZGVudCBmdW5jdGlvbj8ge2JvZHkuQGluZGVudGF0aW9ufSB7c30ge3M6Z2VuZXJhdGVkfSB7Ym9keS5jb3VudH1cIlxuXHRcdGJvZHkuQGluZGVudGF0aW9uID0gbnVsbCBpZiBpbmQgYW5kIGluZC5pc0dlbmVyYXRlZFxuXHRcdHZhciBjb2RlID0gc2NvcGUuYyhpbmRlbnQ6ICghaW5kIG9yICFpbmQuaXNHZW5lcmF0ZWQpLCBicmFjZXM6IHllcylcblxuXHRcdCMgYXJncyA9IHBhcmFtcy5tYXAgZG8gfHBhcnwgcGFyLm5hbWVcblx0XHQjIGhlYWQgPSBwYXJhbXMubWFwIGRvIHxwYXJ8IHBhci5jXG5cdFx0IyBjb2RlID0gW2hlYWQsYm9keS5jKGV4cHJlc3Npb246IG5vKV0uZmxhdHRlbl9fLmNvbXBhY3Quam9pbihcIlxcblwiKS53cmFwXG5cdFx0IyBGSVhNRSBjcmVhdGluZyB0aGUgZnVuY3Rpb24tbmFtZSB0aGlzIHdheSBpcyBwcm9uZSB0byBjcmVhdGUgbmFtaW5nLWNvbGxpc2lvbnNcblx0XHQjIHdpbGwgbmVlZCB0byB3cmFwIHRoZSB2YWx1ZSBpbiBhIEZ1bmN0aW9uTmFtZSB3aGljaCB0YWtlcyBjYXJlIG9mIGxvb2tpbmcgdXAgc2NvcGVcblx0XHQjIGFuZCBwb3NzaWJseSBkZWFsaW5nIHdpdGggaXRcblx0XHR2YXIgbmFtZSA9IHR5cGVvZiBAbmFtZSA9PSAnc3RyaW5nJyA/IEBuYW1lIDogQG5hbWUuY1xuXHRcdHZhciBuYW1lID0gbmFtZSA/ICcgJyArIG5hbWUucmVwbGFjZSgvXFwuL2csJ18nKSA6ICcnXG5cdFx0dmFyIG91dCA9IFwiZnVuY3Rpb257bmFtZX0oe3BhcmFtcy5jfSkgXCIgKyBjb2RlXG5cdFx0b3V0ID0gXCIoe291dH0pKClcIiBpZiBvcHRpb24oOmV2YWwpXG5cdFx0cmV0dXJuIG91dFxuXG5cdGRlZiBzaG91bGRQYXJlbnRoZXNpemUgcGFyID0gdXBcblx0XHRwYXIgaXNhIENhbGwgJiYgcGFyLmNhbGxlZSA9PSBzZWxmXG5cdFx0IyBpZiB1cCBhcyBhIGNhbGw/IE9ubHkgaWYgd2UgYXJlIFxuXG5leHBvcnQgY2xhc3MgTGFtYmRhIDwgRnVuY1xuXHRkZWYgc2NvcGV0eXBlIGRvIExhbWJkYVNjb3BlXG5cbmV4cG9ydCBjbGFzcyBUYWdGcmFnbWVudEZ1bmMgPCBGdW5jXG5cbiMgTWV0aG9kRGVjbGFyYXRpb25cbiMgQ3JlYXRlIGEgc2hhcmVkIGJvZHk/XG5cbmV4cG9ydCBjbGFzcyBNZXRob2REZWNsYXJhdGlvbiA8IEZ1bmNcblxuXHRwcm9wIHZhcmlhYmxlXG5cblx0ZGVmIHNjb3BldHlwZSBkbyBNZXRob2RTY29wZVxuXG5cdGRlZiBjb25zdW1lIG5vZGVcblx0XHRpZiBub2RlIGlzYSBSZXR1cm5cblx0XHRcdG9wdGlvbigncmV0dXJuJyx5ZXMpXG5cdFx0XHRyZXR1cm4gc2VsZlxuXHRcdHN1cGVyXG5cblx0ZGVmIG1ldGFkYXRhXG5cdFx0e1xuXHRcdFx0dHlwZTogXCJtZXRob2RcIlxuXHRcdFx0bmFtZTogXCJcIiArIG5hbWVcblx0XHRcdG5hbWVwYXRoOiBuYW1lcGF0aFxuXHRcdFx0cGFyYW1zOiBAcGFyYW1zLm1ldGFkYXRhXG5cdFx0XHRkZXNjOiBAZGVzY1xuXHRcdFx0c2NvcGVucjogc2NvcGUuQG5yXG5cdFx0XHRsb2M6IGxvY1xuXHRcdH1cblxuXHRkZWYgbG9jXG5cdFx0aWYgbGV0IGQgPSBvcHRpb24oOmRlZilcblx0XHRcdFtkLkBsb2MsYm9keS5sb2NbMV1dXG5cdFx0ZWxzZVxuXHRcdFx0WzAsMF1cblx0XHRcblxuXHRkZWYgdG9KU09OXG5cdFx0bWV0YWRhdGFcblxuXHRkZWYgbmFtZXBhdGhcblx0XHRyZXR1cm4gQG5hbWVwYXRoIGlmIEBuYW1lcGF0aFxuXHRcdFxuXHRcdHZhciBuYW1lID0gU3RyaW5nKG5hbWUpXG5cdFx0dmFyIHNlcCA9IChvcHRpb24oJ3N0YXRpYycpID8gJy4nIDogJyMnKVxuXHRcdGlmIHRhcmdldFxuXHRcdFx0QG5hbWVwYXRoID0gQHRhcmdldC5uYW1lcGF0aCArIHNlcCArIG5hbWVcblx0XHRlbHNlXG5cdFx0XHRAbmFtZXBhdGggPSAnJicgKyBuYW1lXG5cblx0ZGVmIHZpc2l0XG5cdFx0IyBAZGVzYyA9IHN0YWNrLnN0YXNoLnBsdWNrKENvbW1lbnQpXG5cdFx0IyBAZGVzYyA9IHN0YWNrLnN0YXNoLnBsdWNrKENvbW1lbnQpXG5cdFx0IyBwcmVicmVhayAjIG1ha2Ugc3VyZSB0aGlzIGhhcyBhIGJyZWFrP1xuXHRcdHNjb3BlLnZpc2l0XG5cblx0XHRpZiBTdHJpbmcobmFtZSkgPT0gJ2luaXRpYWxpemUnXG5cdFx0XHRzZWxmLnR5cGUgPSA6Y29uc3RydWN0b3JcblxuXHRcdGlmIG9wdGlvbig6Z3JlZWR5KVxuXHRcdFx0d2FybiBcImRlcHJlY2F0ZWRcIlxuXHRcdFx0IyBzZXQoZ3JlZWR5OiB0cnVlKVxuXHRcdFx0IyBwIFwiQk9EWSBFWFBSRVNTSU9OUyEhIFRoaXMgaXMgYSBmcmFnbWVudFwiXG5cdFx0XHR2YXIgdHJlZSA9IFRhZ1RyZWUubmV3XG5cdFx0XHRAYm9keSA9IGJvZHkuY29uc3VtZSh0cmVlKVxuXHRcdFx0IyBib2R5Lm5vZGVzID0gW0Fyci5uZXcoYm9keS5ub2RlcyldXG5cdFx0XG5cdFx0QGNvbnRleHQgPSBzY29wZS5wYXJlbnQuY2xvc3VyZVxuXHRcdEBwYXJhbXMudHJhdmVyc2VcblxuXHRcdGlmIHRhcmdldCBpc2EgU2VsZlxuXHRcdFx0QHRhcmdldCA9IEBjb250ZXh0LmNvbnRleHRcblx0XHRcdHNldChzdGF0aWM6IHllcylcblxuXHRcdGlmIGNvbnRleHQgaXNhIENsYXNzU2NvcGVcblx0XHRcdGNvbnRleHQuYW5ub3RhdGUoc2VsZilcblx0XHRcdEB0YXJnZXQgfHw9IGNvbnRleHQuY29udGV4dFxuXHRcdFx0IyByZWdpc3RlciBhcyBjbGFzcy1tZXRob2Q/XG5cdFx0XHQjIHNob3VsZCByZWdpc3RlciBmb3IgdGhpc1xuXHRcdFx0IyBjb25zb2xlLmxvZyBcImNvbnRleHQgaXMgY2xhc3NzY29wZSB7QG5hbWV9XCJcblxuXHRcdGlmICFAdGFyZ2V0XG5cdFx0XHQjIHNob3VsZCBub3QgYmUgcmVnaXN0ZXJlZCBvbiB0aGUgb3V0ZXJtb3N0IGNsb3N1cmU/XG5cdFx0XHRAdmFyaWFibGUgPSBjb250ZXh0LnJlZ2lzdGVyKG5hbWUsIHNlbGYsIHR5cGU6ICdtZXRoJylcblxuXHRcdFJPT1QuZW50aXRpZXMuYWRkKG5hbWVwYXRoLHNlbGYpXG5cdFx0QGJvZHkudHJhdmVyc2UgIyBzbyBzb29uP1xuXHRcdHNlbGZcblxuXHRkZWYgc3VwZXJuYW1lXG5cdFx0dHlwZSA9PSA6Y29uc3RydWN0b3IgPyB0eXBlIDogbmFtZVxuXG5cblx0IyBGSVhNRSBleHBvcnQgZ2xvYmFsIGV0YyBhcmUgTk9UIHZhbGlkIGZvciBtZXRob2RzIGluc2lkZSBhbnkgb3RoZXIgc2NvcGUgdGhhblxuXHQjIHRoZSBvdXRlcm1vc3Qgc2NvcGUgKHJvb3QpXG5cblx0ZGVmIGpzIG9cblx0XHQjIEZJWE1FIERvIHRoaXMgaW4gdGhlIGdyYW1tYXIgLSByZW1uYW50cyBvZiBvbGQgaW1wbGVtZW50YXRpb25cblx0XHR1bmxlc3MgdHlwZSA9PSA6Y29uc3RydWN0b3Igb3Igb3B0aW9uKDpub3JldHVybilcblx0XHRcdGlmIG9wdGlvbig6Z3JlZWR5KVxuXHRcdFx0XHQjIGhhYWFja1xuXHRcdFx0XHRib2R5LmNvbnN1bWUoR3JlZWR5UmV0dXJuLm5ldylcblx0XHRcdGVsc2Vcblx0XHRcdFx0Ym9keS5jb25zdW1lKEltcGxpY2l0UmV0dXJuLm5ldylcblxuXHRcdHZhciBjb2RlID0gc2NvcGUuYyhpbmRlbnQ6IHllcywgYnJhY2VzOiB5ZXMpXG5cblx0XHQjIHNhbWUgZm9yIEZ1bmMgLS0gc2hvdWxkIGdlbmVyYWxpemVcblx0XHR2YXIgbmFtZSA9IHR5cGVvZiBAbmFtZSA9PSAnc3RyaW5nJyA/IEBuYW1lIDogQG5hbWUuY1xuXHRcdG5hbWUgPSBuYW1lLnJlcGxhY2UoL1xcLi9nLCdfJylcblxuXHRcdCMgdmFyIG5hbWUgPSBzZWxmLm5hbWUuYy5yZXBsYWNlKC9cXC4vZywnXycpICMgV0hBVD9cblx0XHR2YXIgZm9vdCA9IFtdXG5cblx0XHR2YXIgbGVmdCA9IFwiXCJcblx0XHR2YXIgZnVuYyA9IFwiKHtwYXJhbXMuY30pXCIgKyBjb2RlICMgLndyYXBcblx0XHR2YXIgdGFyZ2V0ID0gc2VsZi50YXJnZXRcblx0XHR2YXIgZGVjbCA9ICFvcHRpb24oOmdsb2JhbCkgYW5kICFvcHRpb24oOmV4cG9ydClcblxuXHRcdGlmIHRhcmdldCBpc2EgU2NvcGVDb250ZXh0XG5cdFx0XHQjIHRoZSB0YXJnZXQgaXMgYSBzY29wZSBjb250ZXh0XG5cdFx0XHR0YXJnZXQgPSBudWxsXG5cblx0XHR2YXIgY3R4ID0gY29udGV4dFxuXHRcdHZhciBvdXQgPSBcIlwiXG5cdFx0dmFyIG1hcmsgPSBtYXJrX18ob3B0aW9uKCdkZWYnKSlcblx0XHQjIGlmIGN0eCBcblxuXHRcdHZhciBmbmFtZSA9IHN5bV9fKHNlbGYubmFtZSlcblx0XHQjIGNvbnNvbGUubG9nIFwic3ltYm9saXplIHtzZWxmLm5hbWV9IC0tIHtmbmFtZX1cIlxuXHRcdHZhciBmZGVjbCA9IGZuYW1lICMgZGVjbCA/IGZuYW1lIDogJydcblxuXHRcdGlmIGN0eCBpc2EgQ2xhc3NTY29wZSBhbmQgIXRhcmdldFxuXHRcdFx0aWYgdHlwZSA9PSA6Y29uc3RydWN0b3Jcblx0XHRcdFx0b3V0ID0gXCJ7bWFya31mdW5jdGlvbiB7Zm5hbWV9e2Z1bmN9XCJcblx0XHRcdGVsaWYgb3B0aW9uKDpzdGF0aWMpXG5cdFx0XHRcdG91dCA9IFwie21hcmt9e2N0eC5jb250ZXh0LmN9LntmbmFtZX0gPSBmdW5jdGlvbiB7ZnVuY31cIlxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRvdXQgPSBcInttYXJrfXtjdHguY29udGV4dC5jfS5wcm90b3R5cGUue2ZuYW1lfSA9IGZ1bmN0aW9uIHtmdW5jfVwiXG5cblx0XHRlbGlmIGN0eCBpc2EgUm9vdFNjb3BlIGFuZCAhdGFyZ2V0XG5cdFx0XHQjIHJlZ2lzdGVyIG1ldGhvZCBhcyBhIHJvb3QtZnVuY3Rpb24sIGJ1dCB3aXRoIGF1dG8tY2FsbD8gaG1tXG5cdFx0XHQjIHNob3VsZCBwcm9iYWJseSBzZXQgdXNpbmcgdmFyaWFibGUgZGlyZWN0bHkgaW5zdGVhZCwgbm8/XG5cdFx0XHRvdXQgPSBcInttYXJrfWZ1bmN0aW9uIHtmZGVjbH17ZnVuY31cIlxuXG5cdFx0ZWxpZiB0YXJnZXQgYW5kIG9wdGlvbig6c3RhdGljKVxuXHRcdFx0b3V0ID0gXCJ7bWFya317dGFyZ2V0LmN9LntmbmFtZX0gPSBmdW5jdGlvbiB7ZnVuY31cIlxuXG5cdFx0ZWxpZiB0YXJnZXRcblx0XHRcdG91dCA9IFwie21hcmt9e3RhcmdldC5jfS5wcm90b3R5cGUue2ZuYW1lfSA9IGZ1bmN0aW9uIHtmdW5jfVwiXG5cdFx0ZWxzZVxuXHRcdFx0b3V0ID0gXCJ7bWFya31mdW5jdGlvbiB7ZmRlY2x9e2Z1bmN9XCJcblxuXHRcdGlmIG9wdGlvbig6Z2xvYmFsKVxuXHRcdFx0b3V0ID0gXCJ7Zm5hbWV9ID0ge291dH1cIlxuXG5cdFx0aWYgb3B0aW9uKDpleHBvcnQpXG5cdFx0XHRvdXQgPSBcIntvdXR9OyBleHBvcnRzLntmbmFtZX0gPSB7Zm5hbWV9O1wiXG5cdFx0XHRvdXQgPSBcIntvdXR9OyByZXR1cm4ge2ZuYW1lfTtcIiBpZiBvcHRpb24oOnJldHVybilcblxuXHRcdGVsaWYgb3B0aW9uKDpyZXR1cm4pXG5cdFx0XHRvdXQgPSBcInJldHVybiB7b3V0fVwiXG5cblx0XHRvdXRcblxuXG5leHBvcnQgY2xhc3MgVGFnRnJhZ21lbnREZWNsYXJhdGlvbiA8IE1ldGhvZERlY2xhcmF0aW9uXG5cblxuZXhwb3J0IGNsYXNzIFByb3BlcnR5RGVjbGFyYXRpb24gPCBOb2RlXG5cblx0dmFyIHByb3BUZW1wbGF0ZSA9ICcnJ1xuXHQke2hlYWRlcnN9XG5cdCR7cGF0aH0uJHtnZXR0ZXJ9ID0gZnVuY3Rpb24odil7IHJldHVybiAke2dldH07IH1cblx0JHtwYXRofS4ke3NldHRlcn0gPSBmdW5jdGlvbih2KXsgJHtzZXR9OyByZXR1cm4gdGhpczsgfVxuXHQke2luaXR9XG5cdCcnJ1xuXG5cdHZhciBwcm9wV2F0Y2hUZW1wbGF0ZSA9ICcnJ1xuXHQke2hlYWRlcnN9XG5cdCR7cGF0aH0uJHtnZXR0ZXJ9ID0gZnVuY3Rpb24odil7IHJldHVybiAke2dldH07IH1cblx0JHtwYXRofS4ke3NldHRlcn0gPSBmdW5jdGlvbih2KXtcblx0XHR2YXIgYSA9IHRoaXMuJHtnZXR0ZXJ9KCk7XG5cdFx0aWYodiAhPSBhKSB7ICR7c2V0fTsgfVxuXHRcdGlmKHYgIT0gYSkgeyAke29uZGlydHl9IH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQke2luaXR9XG5cdCcnJ1xuXG5cdHByb3AgbmFtZVxuXHRwcm9wIG9wdGlvbnNcblxuXHRkZWYgaW5pdGlhbGl6ZSBuYW1lLCBvcHRpb25zLCB0b2tlblxuXHRcdEB0b2tlbiA9IHRva2VuXG5cdFx0QHRyYXZlcnNlZCA9IG5vXG5cdFx0QG5hbWUgPSBuYW1lXG5cdFx0QG9wdGlvbnMgPSBvcHRpb25zIHx8IE9iai5uZXcoQXNzaWduTGlzdC5uZXcpXG5cblx0ZGVmIHZpc2l0XG5cdFx0QG9wdGlvbnMudHJhdmVyc2Vcblx0XHRzZWxmXG5cblx0IyBUaGlzIHdpbGwgc29vbiBzdXBwb3J0IGJpbmRpbmdzIC8gbGlzdGVuZXJzIGV0YywgbXVjaCBtb3JlXG5cdCMgYWR2YW5jZWQgZ2VuZXJhdGVkIGNvZGUgYmFzZWQgb24gb3B0aW9ucyBwYXNzZWQgaW4uXG5cdGRlZiBjXG5cdFx0dmFyIG8gPSBvcHRpb25zXG5cdFx0dmFyIGFzdCA9IFwiXCJcblx0XHR2YXIga2V5ID0gbmFtZS5qc1xuXHRcdHZhciBzY29wZSA9IFNUQUNLLnNjb3BlXG5cblx0XHR2YXIgYWRkRGVzYyA9IG8ua2V5czpsZW5ndGhcblxuXHRcdHZhciBwYXJzID0gby5oYXNoXG5cblx0XHR2YXIgaXNBdHRyID0gKEB0b2tlbiBhbmQgU3RyaW5nKEB0b2tlbikgPT0gJ2F0dHInKSBvciBvLmtleSg6YXR0cilcblxuXHRcdHZhciBqcyA9XG5cdFx0XHRrZXk6IGtleVxuXHRcdFx0Z2V0dGVyOiBrZXlcblx0XHRcdHNldHRlcjogc3ltX18oXCJzZXQte2tleX1cIilcblx0XHRcdHNjb3BlOiBcIntzY29wZS5jb250ZXh0LmN9XCIgXG5cdFx0XHRwYXRoOiAnJHtzY29wZX0ucHJvdG90eXBlJ1xuXHRcdFx0c2V0OiBcInRoaXMuX3trZXl9ID0gdlwiXG5cdFx0XHRnZXQ6IFwidGhpcy5fe2tleX1cIlxuXHRcdFx0aW5pdDogXCJcIlxuXHRcdFx0aGVhZGVyczogXCJcIlxuXHRcdFx0b25kaXJ0eTogXCJcIlxuXG5cblx0XHRpZiBwYXJzOmlubGluZVxuXHRcdFx0aWYgcGFyczppbmxpbmUgaXNhIEJvb2wgYW5kICFwYXJzOmlubGluZS50cnV0aHlcblx0XHRcdFx0by5yZW1vdmUoJ2lubGluZScpXG5cdFx0XHRcdCMgcCBcImRvbnQgbWFrZSBhdHRyIGlubGluZSghKVwiXG5cdFx0XHRcdHJldHVybiBcIkltYmEue0B0b2tlbn0oe2pzOnNjb3BlfSwne25hbWUudmFsdWV9Jyx7by5jfSlcIi5yZXBsYWNlKCcse30pJywnKScpXG5cblx0XHRcdCMgcCBcInBhcnMgaW5saW5lPyE/IHtwYXJzOmlubGluZX1cIiwgdHlwZW9mIHBhcnM6aW5saW5lXG5cblx0XHR2YXIgdHBsID0gcHJvcFRlbXBsYXRlXG5cblx0XHRvLmFkZCgnbmFtZScsU3ltYm9sLm5ldyhrZXkpKVxuXG5cdFx0aWYgcGFyczp3YXRjaFxuXHRcdFx0IyBwIFwid2F0Y2ggaXMgYSBwcm9wZXJ0eSB7cGFyczp3YXRjaH1cIlxuXHRcdFx0dHBsID0gcHJvcFdhdGNoVGVtcGxhdGUgdW5sZXNzIHBhcnM6d2F0Y2ggaXNhIEJvb2wgYW5kICFwYXJzOndhdGNoLnRydXRoeVxuXHRcdFx0dmFyIHdmbiA9IFwie2tleX1EaWRTZXRcIlxuXG5cdFx0XHRpZiBwYXJzOndhdGNoIGlzYSBTeW1ib2xcblx0XHRcdFx0d2ZuID0gcGFyczp3YXRjaFxuXHRcdFx0ZWxpZiBwYXJzOndhdGNoIGlzYSBCb29sXG5cdFx0XHRcdG8ua2V5KDp3YXRjaCkudmFsdWUgPSBTeW1ib2wubmV3KFwie2tleX1EaWRTZXRcIilcblxuXHRcdFx0dmFyIGZuID0gT1AoJy4nLFRoaXMubmV3LHdmbilcblx0XHRcdGpzOm9uZGlydHkgPSBPUCgnJiYnLGZuLENBTEwoZm4sWyd2JywnYScsXCJ0aGlzLl9fe2tleX1cIl0pKS5jXG5cblx0XHRpZiBwYXJzOm9ic2VydmVcblx0XHRcdGlmIHBhcnM6b2JzZXJ2ZSBpc2EgQm9vbFxuXHRcdFx0XHRvLmtleSg6b2JzZXJ2ZSkudmFsdWUgPSBTeW1ib2wubmV3KFwie2tleX1EaWRFbWl0XCIpXG5cblx0XHRcdHRwbCA9IHByb3BXYXRjaFRlbXBsYXRlXG5cdFx0XHRqczpvbmRpcnR5ID0gXCJJbWJhLm9ic2VydmVQcm9wZXJ0eSh0aGlzLCd7a2V5fScse28ua2V5KDpvYnNlcnZlKS52YWx1ZS5jfSx2LGEpO1wiICvCoChqczpvbmRpcnR5IG9yICcnKVxuXHRcdFx0IyBPUCgnJiYnLGZuLENBTEwoZm4sWyd2JywnYScsXCJ0aGlzLl9fe2tleX1cIl0pKS5jXG5cblx0XHRpZiAoQHRva2VuIGFuZCBTdHJpbmcoQHRva2VuKSA9PSAnYXR0cicpIG9yIG8ua2V5KDpkb20pIG9yIG8ua2V5KDphdHRyKVxuXHRcdFx0bGV0IGF0dHJLZXkgPSBvLmtleSg6ZG9tKSBpc2EgU3RyID8gby5rZXkoOmRvbSkgOiBuYW1lLnZhbHVlXG5cdFx0XHQjIG5lZWQgdG8gbWFrZSBzdXJlIG8gaGFzIGEga2V5IGZvciBhdHRyIHRoZW4gLSBzbyB0aGF0IHRoZSBkZWxlZ2F0ZSBjYW4ga25vdz9cblx0XHRcdGpzOnNldCA9IFwidGhpcy5zZXRBdHRyaWJ1dGUoJ3thdHRyS2V5fScsdilcIlxuXHRcdFx0anM6Z2V0ID0gXCJ0aGlzLmdldEF0dHJpYnV0ZSgne2F0dHJLZXl9JylcIlxuXG5cdFx0ZWxpZiBvLmtleSg6ZGVsZWdhdGUpXG5cdFx0XHQjIGlmIHdlIGhhdmUgYSBkZWxlZ2F0ZVxuXHRcdFx0anM6c2V0ID0gXCJ2ID0gdGhpcy5fX3trZXl9LmRlbGVnYXRlLnNldCh0aGlzLCd7a2V5fScsdix0aGlzLl9fe2tleX0pXCJcblx0XHRcdGpzOmdldCA9IFwidGhpcy5fX3trZXl9LmRlbGVnYXRlLmdldCh0aGlzLCd7a2V5fScsdGhpcy5fX3trZXl9KVwiXG5cblxuXG5cdFx0aWYgcGFyczpkZWZhdWx0XG5cdFx0XHRpZiBvLmtleSg6ZG9tKVxuXHRcdFx0XHQjIEZJWE1FIGdvIHRocm91Z2ggY2xhc3MtbWV0aG9kIHNldEF0dHJpYnV0ZSBpbnN0ZWFkXG5cdFx0XHRcdGpzOmluaXQgPSBcIntqczpzY29wZX0uZG9tKCkuc2V0QXR0cmlidXRlKCd7a2V5fScse3BhcnM6ZGVmYXVsdC5jfSk7XCJcblx0XHRcdGVsc2Vcblx0XHRcdFx0IyBpZiB0aGlzIGlzIG5vdCBhIHByaW1pdGl2ZSAtIGl0IE1VU1QgYmUgaW5jbHVkZWQgaW4gdGhlXG5cdFx0XHRcdCMgZ2V0dGVyIC8gc2V0dGVyIGluc3RlYWRcblx0XHRcdFx0anM6aW5pdCA9IFwie2pzOnNjb3BlfS5wcm90b3R5cGUuX3trZXl9ID0ge3BhcnM6ZGVmYXVsdC5jfTtcIlxuXG5cdFx0aWYgby5rZXkoOmNoYWluYWJsZSlcblx0XHRcdGpzOmdldCA9IFwidiAhPT0gdW5kZWZpbmVkID8gKHRoaXMue2pzOnNldHRlcn0odiksdGhpcykgOiB7anM6Z2V0fVwiXG5cblxuXHRcdGpzOm9wdGlvbnMgPSBvLmNcblxuXHRcdGlmIGFkZERlc2Ncblx0XHRcdGpzOmhlYWRlcnMgPSBcIntqczpwYXRofS5fX3tqczpnZXR0ZXJ9ID0ge2pzOm9wdGlvbnN9O1wiXG5cblx0XHR2YXIgcmVnID0gL1xcJFxceyhcXHcrKVxcfS9nbVxuXHRcdCMgdmFyIHRwbCA9IG8ua2V5KDp3YXRjaCkgPyBwcm9wV2F0Y2hUZW1wbGF0ZSA6IHByb3BUZW1wbGF0ZVxuXHRcdHZhciBvdXQgPSB0cGwucmVwbGFjZShyZWcpIGRvIHxtLGF8IGpzW2FdXG5cdFx0IyBydW4gYW5vdGhlciB0aW1lIGZvciBuZXN0aW5nLiBoYWNreVxuXHRcdG91dCA9IG91dC5yZXBsYWNlKHJlZykgZG8gfG0sYXwganNbYV1cblx0XHQjIG91dCA9IG91dC5yZXBsYWNlKC9cXG5cXHMqJC8sJycpXG5cdFx0b3V0ID0gb3V0LnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxuXHRcdFxuXHRcdCMgaWYgby5rZXkoOnYpXG5cdFx0cmV0dXJuIG91dFxuXG5cblxuIyBMaXRlcmFscyBzaG91bGQgcHJvYmFibHkgbm90IGluaGVyaXQgZnJvbSB0aGUgc2FtZSBwYXJlbnRcbiMgYXMgYXJyYXlzLCB0dXBsZXMsIG9iamVjdHMgd291bGQgYmUgYmV0dGVyIG9mZiBpbmhlcml0aW5nXG4jIGZyb20gbGlzdG5vZGUuXG5cbmV4cG9ydCBjbGFzcyBMaXRlcmFsIDwgVmFsdWVOb2RlXG5cdFxuXHRkZWYgaW5pdGlhbGl6ZSB2XG5cdFx0QHRyYXZlcnNlZCA9IG5vXG5cdFx0QGV4cHJlc3Npb24gPSB5ZXNcblx0XHRAY2FjaGUgPSBudWxsXG5cdFx0QHJhdyA9IG51bGxcblx0XHRAdmFsdWUgPSB2XG5cblx0ZGVmIHRvU3RyaW5nXG5cdFx0XCJcIiArIHZhbHVlXG5cblx0ZGVmIGhhc1NpZGVFZmZlY3RzXG5cdFx0ZmFsc2Vcblx0XHRcblxuZXhwb3J0IGNsYXNzIEJvb2wgPCBMaXRlcmFsXG5cdFxuXHQjIFNob3VsZCBrZWVwIHRoZSByZWFsIHZhbHVlICh5ZXMvbm8vdHJ1ZS9mYWxzZSk/XG5cdGRlZiBpbml0aWFsaXplIHZcblx0XHRAdmFsdWUgPSB2XG5cdFx0QHJhdyA9IFN0cmluZyh2KSA9PSBcInRydWVcIiA/IHRydWUgOiBmYWxzZVxuXG5cdGRlZiBjYWNoZVxuXHRcdHNlbGZcblxuXHRkZWYgaXNQcmltaXRpdmVcblx0XHR5ZXNcblxuXHRkZWYgdHJ1dGh5XG5cdFx0IyBwIFwiYm9vbCBpcyB0cnV0aHk/IHt2YWx1ZX1cIlxuXHRcdFN0cmluZyh2YWx1ZSkgPT0gXCJ0cnVlXCJcblx0XHQjIHllc1xuXG5cdGRlZiBqcyBvXG5cdFx0U3RyaW5nKEB2YWx1ZSlcblxuXHRkZWYgY1xuXHRcdFNUQUNLLkBjb3VudGVyICs9IDFcblx0XHQjIHVuZGVmaW5lZCBzaG91bGQgbm90IGJlIGEgYm9vbFxuXHRcdFN0cmluZyhAdmFsdWUpXG5cdFx0IyBAcmF3ID8gXCJ0cnVlXCIgOiBcImZhbHNlXCJcblxuXHRkZWYgdG9KU09OXG5cdFx0e3R5cGU6ICdCb29sJywgdmFsdWU6IEB2YWx1ZX1cblxuZXhwb3J0IGNsYXNzIFVuZGVmaW5lZCA8IExpdGVyYWxcblx0XG5cdGRlZiBpc1ByaW1pdGl2ZVxuXHRcdHllc1xuXG5cdGRlZiBjXG5cdFx0bWFya19fKEB2YWx1ZSkgKyBcInVuZGVmaW5lZFwiXG5cbmV4cG9ydCBjbGFzcyBOaWwgPCBMaXRlcmFsXG5cdFxuXHRkZWYgaXNQcmltaXRpdmVcblx0XHR5ZXNcblxuXHRkZWYgY1xuXHRcdG1hcmtfXyhAdmFsdWUpICsgXCJudWxsXCJcblxuZXhwb3J0IGNsYXNzIFRydWUgPCBCb29sXG5cblx0ZGVmIHJhd1xuXHRcdHRydWVcblxuXHRkZWYgY1xuXHRcdG1hcmtfXyhAdmFsdWUpICsgXCJ0cnVlXCJcblx0XHRcbmV4cG9ydCBjbGFzcyBGYWxzZSA8IEJvb2xcblxuXHRkZWYgcmF3XG5cdFx0ZmFsc2VcblxuXHRkZWYgY1xuXHRcdG1hcmtfXyhAdmFsdWUpICsgXCJmYWxzZVwiXG5cbmV4cG9ydCBjbGFzcyBOdW0gPCBMaXRlcmFsXG5cdFxuXHQjIHZhbHVlIGlzIHRva2VuIC0gc2hvdWxkIG5vdCBiZVxuXHRkZWYgaW5pdGlhbGl6ZSB2XG5cdFx0QHRyYXZlcnNlZCA9IG5vXG5cdFx0QHZhbHVlID0gdlxuXG5cdGRlZiB0b1N0cmluZ1xuXHRcdFN0cmluZyhAdmFsdWUpXG5cblx0ZGVmIGlzUHJpbWl0aXZlIGRlZXBcblx0XHR5ZXNcblxuXHRkZWYgc2hvdWxkUGFyZW50aGVzaXplIHBhciA9IHVwXG5cdFx0cGFyIGlzYSBBY2Nlc3MgYW5kIHBhci5sZWZ0ID09IHNlbGZcblxuXHRkZWYganMgb1xuXHRcdHZhciBudW0gPSBTdHJpbmcoQHZhbHVlKVxuXHRcdCMgY29uc29sZS5sb2cgXCJjb21waWxlZCBudW0gdG8ge251bX1cIlxuXHRcdHJldHVybiBudW1cblxuXHRkZWYgYyBvXG5cdFx0cmV0dXJuIHN1cGVyKG8pIGlmIEBjYWNoZVxuXHRcdHZhciBqcyA9IFN0cmluZyhAdmFsdWUpXG5cdFx0dmFyIHBhciA9IFNUQUNLLmN1cnJlbnRcblx0XHR2YXIgcGFyZW4gPSBwYXIgaXNhIEFjY2VzcyBhbmQgcGFyLmxlZnQgPT0gc2VsZlxuXHRcdCMgb25seSBpZiB0aGlzIGlzIHRoZSByaWdodCBwYXJ0IG9mIHRlaCBhY2Nlc1xuXHRcdCMgY29uc29sZS5sb2cgXCJzaG91bGQgcGFyZW4/PyB7c2hvdWxkUGFyZW50aGVzaXplfVwiXG5cdFx0cGFyZW4gPyBcIih7bWFya19fKEB2YWx1ZSl9XCIgKyBqcyArIFwiKVwiIDogKG1hcmtfXyhAdmFsdWUpICsganMpXG5cdFx0IyBAY2FjaGUgPyBzdXBlcihvKSA6IFN0cmluZyhAdmFsdWUpXG5cblx0ZGVmIGNhY2hlIG9cblx0XHQjIHAgXCJjYWNoZSBudW1cIixvXG5cdFx0cmV0dXJuIHNlbGYgdW5sZXNzIG8gYW5kIChvOmNhY2hlIG9yIG86cG9vbClcblx0XHRzdXBlcihvKVxuXG5cdGRlZiByYXdcblx0XHQjIHJlYWxseT9cblx0XHRKU09OLnBhcnNlKFN0cmluZyh2YWx1ZSkpXG5cblx0ZGVmIHRvSlNPTlxuXHRcdHt0eXBlOiB0eXBlTmFtZSwgdmFsdWU6IHJhd31cblxuIyBzaG91bGQgYmUgcXVvdGVkIG5vP1xuIyB3aGF0IGFib3V0IHN0cmluZ3MgaW4gb2JqZWN0LWxpdGVyYWxzP1xuIyB3ZSB3YW50IHRvIGJlIGFibGUgdG8gc2VlIGlmIHRoZSB2YWx1ZXMgYXJlIGFsbG93ZWRcbmV4cG9ydCBjbGFzcyBTdHIgPCBMaXRlcmFsXG5cblx0ZGVmIGluaXRpYWxpemUgdlxuXHRcdEB0cmF2ZXJzZWQgPSBub1xuXHRcdEBleHByZXNzaW9uID0geWVzXG5cdFx0QGNhY2hlID0gbnVsbFxuXHRcdEB2YWx1ZSA9IHZcblx0XHQjIHNob3VsZCBncmFiIHRoZSBhY3R1YWwgdmFsdWUgaW1tZWRpYXRlbHk/XG5cblx0ZGVmIGlzU3RyaW5nXG5cdFx0eWVzXG5cblx0ZGVmIGlzUHJpbWl0aXZlIGRlZXBcblx0XHR5ZXNcblxuXHRkZWYgcmF3XG5cdFx0IyBKU09OLnBhcnNlIHJlcXVpcmVzIGRvdWJsZS1xdW90ZWQgc3RyaW5ncyxcblx0XHQjIHdoaWxlIGV2YWwgYWxzbyBhbGxvd3Mgc2luZ2xlIHF1b3Rlcy4gXG5cdFx0IyBORVhUIGV2YWwgaXMgbm90IGFjY2Vzc2libGUgbGlrZSB0aGlzXG5cdFx0IyBXQVJOSU5HIFRPRE8gYmUgY2FyZWZ1bCEgLSBzaG91bGQgY2xlYW4gdXBcblxuXHRcdEByYXcgfHw9IFN0cmluZyh2YWx1ZSkuc2xpY2UoMSwtMSkgIyBpbmNyZWRpYmx5IHN0dXBpZCBzb2x1dGlvblxuXG5cdGRlZiBpc1ZhbGlkSWRlbnRpZmllclxuXHRcdCMgdGhlcmUgYXJlIGFsc28gc29tZSB2YWx1ZXMgd2UgY2Fubm90IHVzZVxuXHRcdHJhdy5tYXRjaCgvXlthLXpBLVpcXCRcXF9dK1tcXGRcXHdcXCRcXF9dKiQvKSA/IHRydWUgOiBmYWxzZVxuXG5cdGRlZiBqcyBvXG5cdFx0U3RyaW5nKEB2YWx1ZSlcblxuXHRkZWYgYyBvXG5cdFx0QGNhY2hlID8gc3VwZXIobykgOiBTdHJpbmcoQHZhbHVlKVxuXG5cbmV4cG9ydCBjbGFzcyBJbnRlcnBvbGF0aW9uIDwgVmFsdWVOb2RlXG5cbiMgQ3VycmVudGx5IG5vdCB1c2VkIC0gaXQgd291bGQgYmUgYmV0dGVyIHRvIHVzZSB0aGlzXG4jIGZvciByZWFsIGludGVycG9sYXRlZCBzdHJpbmdzIHRob3VnaCwgdGhhbiB0byBicmVha1xuIyB0aGVtIHVwIGludG8gdGhlaXIgcGFydHMgYmVmb3JlIHBhcnNpbmdcbmV4cG9ydCBjbGFzcyBJbnRlcnBvbGF0ZWRTdHJpbmcgPCBOb2RlXG5cblx0ZGVmIGluaXRpYWxpemUgbm9kZXMsIG8gPSB7fVxuXHRcdEBub2RlcyA9IG5vZGVzXG5cdFx0QG9wdGlvbnMgPSBvXG5cdFx0c2VsZlxuXG5cdGRlZiBhZGQgcGFydFxuXHRcdEBub2Rlcy5wdXNoKHBhcnQpIGlmIHBhcnRcblx0XHRzZWxmXG5cblx0ZGVmIHZpc2l0XG5cdFx0Zm9yIG5vZGUgaW4gQG5vZGVzXG5cdFx0XHRub2RlLnRyYXZlcnNlXG5cdFx0c2VsZlxuXG5cdGRlZiBlc2NhcGVTdHJpbmcgc3RyXG5cdFx0IyB2YXIgaWR4ID0gMFxuXHRcdCMgdmFyIGxlbiA9IHN0cjpsZW5ndGhcblx0XHQjIHZhciBjaHJcblx0XHQjIHdoaWxlIGNociA9IHN0cltpZHgrK11cblx0XHRzdHIgPSBzdHIucmVwbGFjZSgvXFxuL2csICdcXFxcXFxuJylcblxuXHRkZWYganMgb1xuXHRcdCMgY3JlYXRpbmcgdGhlIHN0cmluZ1xuXHRcdHZhciBwYXJ0cyA9IFtdXG5cdFx0dmFyIHN0ciA9ICcoJ1xuXG5cdFx0QG5vZGVzLm1hcCBkbyB8cGFydCxpfFxuXHRcdFx0aWYgcGFydCBpc2EgVG9rZW4gYW5kIHBhcnQuQHR5cGUgPT0gJ05FT1NUUklORydcblx0XHRcdFx0IyBlc2NhXG5cdFx0XHRcdHBhcnRzLnB1c2goJ1wiJyArIGVzY2FwZVN0cmluZyhwYXJ0LkB2YWx1ZSkgKyAnXCInKVxuXHRcdFx0ZWxpZiBwYXJ0XG5cdFx0XHRcdGlmIGkgPT0gMFxuXHRcdFx0XHRcdCMgZm9yY2UgZmlyc3QgcGFydCB0byBiZSBzdHJpbmdcblx0XHRcdFx0XHRwYXJ0cy5wdXNoKCdcIlwiJylcblx0XHRcdFx0cGFydC5AcGFyZW5zID0geWVzXG5cdFx0XHRcdHBhcnRzLnB1c2gocGFydC5jKGV4cHJlc3Npb246IHllcykpXG5cblx0XHRzdHIgKz0gcGFydHMuam9pbihcIiArIFwiKVxuXHRcdHN0ciArPSAnKSdcblx0XHRyZXR1cm4gc3RyXG5cblxuZXhwb3J0IGNsYXNzIFR1cGxlIDwgTGlzdE5vZGVcblxuXHRkZWYgY1xuXHRcdCMgY29tcGlsZXMgYXMgYW4gYXJyYXlcblx0XHRBcnIubmV3KG5vZGVzKS5jXG5cblx0ZGVmIGhhc1NwbGF0XG5cdFx0ZmlsdGVyKHx2fCB2IGlzYSBTcGxhdCApWzBdXG5cblx0ZGVmIGNvbnN1bWUgbm9kZVxuXHRcdGlmIGNvdW50ID09IDFcblx0XHRcdHJldHVybiBmaXJzdC5jb25zdW1lKG5vZGUpXG5cdFx0ZWxzZVxuXHRcdFx0dGhyb3cgXCJtdWx0aXR1cGxlIGNhbm5vdCBjb25zdW1lXCJcblx0XHRcblx0XG4jIEJlY2F1c2Ugd2UndmUgZHJvcHBlZCB0aGUgU3RyLXdyYXBwZXIgaXQgaXMga2luZGEgZGlmZmljdWx0XG5leHBvcnQgY2xhc3MgU3ltYm9sIDwgTGl0ZXJhbFxuXG5cdGRlZiBpc1ZhbGlkSWRlbnRpZmllclxuXHRcdHJhdy5tYXRjaCgvXlthLXpBLVpcXCRcXF9dK1tcXGRcXHdcXCRcXF9dKiQvKSA/IHRydWUgOiBmYWxzZVxuXG5cdGRlZiBpc1ByaW1pdGl2ZSBkZWVwXG5cdFx0eWVzXG5cblx0ZGVmIHJhd1xuXHRcdEByYXcgfHw9IHN5bV9fKHZhbHVlKVxuXG5cdGRlZiBqcyBvXG5cdFx0XCIne3N5bV9fKHZhbHVlKX0nXCJcblxuZXhwb3J0IGNsYXNzIFJlZ0V4cCA8IExpdGVyYWxcblxuXHRkZWYgaXNQcmltaXRpdmVcblx0XHR5ZXNcblxuXHQjIGRlZiB0b1N0cmluZ1xuXHQjIFx0XCJcIiArIHZhbHVlXG5cbiMgU2hvdWxkIGluaGVyaXQgZnJvbSBMaXN0Tm9kZSAtIHdvdWxkIHNpbXBsaWZ5XG5leHBvcnQgY2xhc3MgQXJyIDwgTGl0ZXJhbFxuXG5cdGRlZiBsb2FkIHZhbHVlXG5cdFx0dmFsdWUgaXNhIEFycmF5ID8gQXJnTGlzdC5uZXcodmFsdWUpIDogdmFsdWVcblxuXHRkZWYgcHVzaCBpdGVtXG5cdFx0dmFsdWUucHVzaChpdGVtKVxuXHRcdHNlbGZcblxuXHRkZWYgY291bnRcblx0XHR2YWx1ZTpsZW5ndGhcblxuXHRkZWYgbm9kZXNcblx0XHR2YXIgdmFsID0gdmFsdWVcblx0XHR2YWwgaXNhIEFycmF5ID8gdmFsIDogdmFsLm5vZGVzXG5cblx0ZGVmIHNwbGF0XG5cdFx0dmFsdWUuc29tZSh8dnwgdiBpc2EgU3BsYXQpXG5cblx0ZGVmIHZpc2l0XG5cdFx0QHZhbHVlLnRyYXZlcnNlIGlmIEB2YWx1ZSBhbmQgQHZhbHVlOnRyYXZlcnNlXG5cdFx0c2VsZlxuXG5cdGRlZiBpc1ByaW1pdGl2ZSBkZWVwXG5cdFx0IXZhbHVlLnNvbWUofHZ8ICF2LmlzUHJpbWl0aXZlKHllcykgKVxuXG5cdGRlZiBqcyBvXG5cblx0XHR2YXIgdmFsID0gQHZhbHVlXG5cdFx0cmV0dXJuIFwiW11cIiB1bmxlc3MgdmFsXG5cblx0XHR2YXIgc3BsYXQgPSBzcGxhdFxuXHRcdHZhciBub2RlcyA9IHZhbCBpc2EgQXJyYXkgPyB2YWwgOiB2YWwubm9kZXNcblx0XHQjIHAgXCJ2YWx1ZSBvZiBhcnJheSBpc2Ege0B2YWx1ZX1cIlxuXG5cdFx0IyBmb3IgdiBpbiBAdmFsdWVcblx0XHQjIFx0YnJlYWsgc3BsYXQgPSB5ZXMgaWYgdiBpc2EgU3BsYXRcblx0XHQjIHZhciBzcGxhdCA9IHZhbHVlLnNvbWUofHZ8IHYgaXNhIFNwbGF0KVxuXG5cdFx0aWYgc3BsYXRcblx0XHRcdCMgXCJTUExBVFRFRCBBUlJBWSFcIlxuXHRcdFx0IyBpZiB3ZSBrbm93IGZvciBjZXJ0YWluIHRoYXQgdGhlIHNwbGF0cyBhcmUgYXJyYXlzIHdlIGNhbiBkcm9wIHRoZSBzbGljZT9cblx0XHRcdCMgcCBcImFycmF5IGlzIHNwbGF0PyE/XCJcblx0XHRcdHZhciBzbGljZXMgPSBbXVxuXHRcdFx0dmFyIGdyb3VwID0gbnVsbFxuXG5cdFx0XHRmb3IgdiBpbiBub2Rlc1xuXHRcdFx0XHRpZiB2IGlzYSBTcGxhdFxuXHRcdFx0XHRcdHNsaWNlcy5wdXNoKHYpXG5cdFx0XHRcdFx0Z3JvdXAgPSBudWxsXG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRzbGljZXMucHVzaChncm91cCA9IEFyci5uZXcoW10pKSB1bmxlc3MgZ3JvdXBcblx0XHRcdFx0XHRncm91cC5wdXNoKHYpXG5cblx0XHRcdFwiW10uY29uY2F0KHtjYXJ5X18oc2xpY2VzKS5qb2luKFwiLCBcIil9KVwiXG5cdFx0ZWxzZVxuXHRcdFx0IyB2ZXJ5IHRlbXBvcmFyeS4gbmVlZCBhIG1vcmUgZ2VuZXJpYyB3YXkgdG8gcHJldHRpZnkgY29kZVxuXHRcdFx0IyBzaG91bGQgZGVwZW5kIG9uIHRoZSBsZW5ndGggb2YgdGhlIGlubmVyIGl0ZW1zIGV0Y1xuXHRcdFx0IyBpZiBAaW5kZW50ZWQgb3Igb3B0aW9uKDppbmRlbnQpIG9yIHZhbHVlLkBpbmRlbnRlZFxuXHRcdFx0I1x0XCJbXFxue3ZhbHVlLmMuam9pbihcIixcXG5cIikuaW5kZW50fVxcbl1cIlxuXHRcdFx0dmFyIG91dCA9IHZhbCBpc2EgQXJyYXkgPyBjYXJ5X18odmFsKSA6IHZhbC5jXG5cdFx0XHRcIlt7b3V0fV1cIlxuXG5cdGRlZiBoYXNTaWRlRWZmZWN0c1xuXHRcdHZhbHVlLnNvbWUofHZ8IHYuaGFzU2lkZUVmZmVjdHMgKVxuXG5cdGRlZiB0b1N0cmluZ1xuXHRcdFwiQXJyXCJcblx0XG5cdGRlZiBpbmRlbnRlZCBhLGJcblx0XHRAdmFsdWUuaW5kZW50ZWQoYSxiKVxuXHRcdHNlbGZcblxuXHRkZWYgc2VsZi53cmFwIHZhbFxuXHRcdEFyci5uZXcodmFsKVxuXG4jIHNob3VsZCBub3QgYmUgY2tsYXNzaWZpZWQgYXMgYSBsaXRlcmFsP1xuZXhwb3J0IGNsYXNzIE9iaiA8IExpdGVyYWxcblxuXHRkZWYgbG9hZCB2YWx1ZVxuXHRcdHZhbHVlIGlzYSBBcnJheSA/IEFzc2lnbkxpc3QubmV3KHZhbHVlKSA6IHZhbHVlXG5cblx0ZGVmIHZpc2l0XG5cdFx0QHZhbHVlLnRyYXZlcnNlIGlmIEB2YWx1ZVxuXHRcdCMgZm9yIHYgaW4gdmFsdWVcblx0XHQjIFx0di50cmF2ZXJzZVxuXHRcdHNlbGZcblxuXHRkZWYganMgb1xuXHRcdHZhciBkeW4gPSB2YWx1ZS5maWx0ZXIofHZ8IHYgaXNhIE9iakF0dHIgYW5kICh2LmtleSBpc2EgT3Agb3Igdi5rZXkgaXNhIEludGVycG9sYXRlZFN0cmluZykgIClcblxuXHRcdGlmIGR5bjpsZW5ndGggPiAwXG5cdFx0XHR2YXIgaWR4ID0gdmFsdWUuaW5kZXhPZihkeW5bMF0pXG5cdFx0XHQjIHAgXCJkeW5hbWljIGtleXMhIHtkeW59XCJcblx0XHRcdCMgY3JlYXRlIGEgdGVtcCB2YXJpYWJsZVxuXG5cdFx0XHR2YXIgdG1wID0gc2NvcGVfXy50ZW1wb3Jhcnkoc2VsZilcblx0XHRcdCMgc2V0IHRoZSB0ZW1wb3Jhcnkgb2JqZWN0IHRvIHRoZSBzYW1lXG5cdFx0XHR2YXIgZmlyc3QgPSB2YWx1ZS5zbGljZSgwLGlkeClcblx0XHRcdHZhciBvYmogPSBPYmoubmV3KGZpcnN0KVxuXHRcdFx0dmFyIGFzdCA9IFtPUCgnPScsdG1wLG9iaildXG5cblx0XHRcdHZhbHVlLnNsaWNlKGlkeCkuZm9yRWFjaCBkbyB8YXRyfFxuXHRcdFx0XHRhc3QucHVzaChPUCgnPScsT1AoJy4nLHRtcCxhdHIua2V5KSxhdHIudmFsdWUpKVxuXHRcdFx0YXN0LnB1c2godG1wKSAjIGFjY2VzcyB0aGUgdG1wIGF0IGluIHRoZSBsYXN0IHBhcnRcblx0XHRcdHJldHVybiBQYXJlbnMubmV3KGFzdCkuY1xuXG5cdFx0IyBmb3Igb2JqZWN0cyB3aXRoIGV4cHJlc3Npb24ta2V5cyB3ZSBuZWVkIHRvIHRoaW5rIGRpZmZlcmVudGx5XG5cdFx0J3snICsgdmFsdWUuYyArICd9J1xuXG5cdGRlZiBhZGQgaywgdlxuXHRcdGsgPSBJZGVudGlmaWVyLm5ldyhrKSBpZiBrIGlzYSBTdHJpbmdcblx0XHR2YXIga3YgPSBPYmpBdHRyLm5ldyhrLHYpXG5cdFx0dmFsdWUucHVzaChrdilcblx0XHRyZXR1cm4ga3ZcblxuXHRkZWYgcmVtb3ZlIGtleVxuXHRcdGZvciBrIGluIHZhbHVlXG5cdFx0XHR2YWx1ZS5yZW1vdmUoaykgaWYgay5rZXkuc3ltYm9sID09IGtleVxuXHRcdHNlbGZcblxuXHRkZWYga2V5c1xuXHRcdE9iamVjdC5rZXlzKGhhc2gpXG5cblx0ZGVmIGhhc2hcblx0XHR2YXIgaGFzaCA9IHt9XG5cdFx0Zm9yIGsgaW4gdmFsdWVcblx0XHRcdGhhc2hbay5rZXkuc3ltYm9sXSA9IGsudmFsdWUgaWYgayBpc2EgT2JqQXR0clxuXHRcdHJldHVybiBoYXNoXG5cdFx0IyByZXR1cm4gayBpZiBrLmtleS5zeW1ib2wgPT0ga2V5XG5cblx0IyBhZGQgbWV0aG9kIGZvciBmaW5kaW5nIHByb3BlcnRpZXMgZXRjP1xuXHRkZWYga2V5IGtleVxuXHRcdGZvciBrIGluIHZhbHVlXG5cdFx0XHRyZXR1cm4gayBpZiBrIGlzYSBPYmpBdHRyIGFuZCBrLmtleS5zeW1ib2wgPT0ga2V5XG5cdFx0bnVsbFxuXG5cdGRlZiBpbmRlbnRlZCBhLGJcblx0XHRAdmFsdWUuaW5kZW50ZWQoYSxiKVxuXHRcdHNlbGZcblxuXHRkZWYgaGFzU2lkZUVmZmVjdHNcblx0XHR2YWx1ZS5zb21lKHx2fCB2Lmhhc1NpZGVFZmZlY3RzIClcblxuXHQjIGZvciBjb252ZXJ0aW5nIGEgcmVhbCBvYmplY3QgaW50byBhbiBhc3QtcmVwcmVzZW50YXRpb25cblx0ZGVmIHNlbGYud3JhcCBvYmpcblx0XHR2YXIgYXR0cnMgPSBbXVxuXHRcdGZvciBvd24gayx2IG9mIG9ialxuXHRcdFx0aWYgdiBpc2EgQXJyYXlcblx0XHRcdFx0diA9IEFyci53cmFwKHYpXG5cdFx0XHRlbGlmIHY6Y29uc3RydWN0b3IgPT0gT2JqZWN0XG5cdFx0XHRcdHYgPSBPYmoud3JhcCh2KVxuXHRcdFx0YXR0cnMucHVzaChPYmpBdHRyLm5ldyhrLHYpKVxuXHRcdHJldHVybiBPYmoubmV3KGF0dHJzKVxuXG5cdGRlZiB0b1N0cmluZ1xuXHRcdFwiT2JqXCJcblx0XHRcbmV4cG9ydCBjbGFzcyBPYmpBdHRyIDwgTm9kZVxuXG5cdHByb3Aga2V5XG5cdHByb3AgdmFsdWVcblx0cHJvcCBvcHRpb25zXG5cblx0ZGVmIGluaXRpYWxpemUga2V5LCB2YWx1ZVxuXHRcdEB0cmF2ZXJzZWQgPSBub1xuXHRcdEBrZXkgPSBrZXlcblx0XHRAdmFsdWUgPSB2YWx1ZVxuXHRcdEBkeW5hbWljID0ga2V5IGlzYSBPcFxuXHRcdHNlbGZcblxuXHRkZWYgdmlzaXRcblx0XHQjIHNob3VsZCBwcm9iYWJseSB0cmF2ZXJzZSBrZXkgYXMgd2VsbCwgdW5sZXNzIGl0IGlzIGEgZGVhZCBzaW1wbGUgaWRlbnRpZmllclxuXHRcdGtleS50cmF2ZXJzZVxuXHRcdHZhbHVlLnRyYXZlcnNlXG5cblx0ZGVmIGpzIG9cblx0XHR2YXIgayA9IGtleS5pc1Jlc2VydmVkID8gXCIne2tleS5jfSdcIiA6IGtleS5jXG5cdFx0XCJ7a306IHt2YWx1ZS5jfVwiXG5cblx0ZGVmIGhhc1NpZGVFZmZlY3RzXG5cdFx0dHJ1ZVxuXHRcdFxuXG5cbmV4cG9ydCBjbGFzcyBBcmdzUmVmZXJlbmNlIDwgTm9kZVxuXG5cdCMgc2hvdWxkIHJlZ2lzdGVyIGluIHRoaXMgc2NvcGUgLS1cblx0ZGVmIGNcblx0XHRcImFyZ3VtZW50c1wiXG5cbiMgc2hvdWxkIGJlIGEgc2VwYXJhdGUgQ29udGV4dCBvciBzb21ldGhpbmdcbmV4cG9ydCBjbGFzcyBTZWxmIDwgTGl0ZXJhbFxuXG5cdHByb3Agc2NvcGVcblxuXHRkZWYgaW5pdGlhbGl6ZSBzY29wZVxuXHRcdEBzY29wZSA9IHNjb3BlXG5cblx0ZGVmIGNhY2hlXG5cdFx0c2VsZlxuXG5cdGRlZiByZWZlcmVuY2Vcblx0XHRyZXR1cm4gc2VsZlxuXG5cdGRlZiBjXG5cdFx0dmFyIHMgPSBzY29wZV9fXG5cdFx0KHMgPyBzLmNvbnRleHQuYyA6IFwidGhpc1wiKVxuXG5leHBvcnQgY2xhc3MgSW1wbGljaXRTZWxmIDwgU2VsZlxuXHRcdFxuZXhwb3J0IGNsYXNzIFRoaXMgPCBTZWxmXG5cblx0ZGVmIGNhY2hlXG5cdFx0c2VsZlxuXG5cdGRlZiByZWZlcmVuY2Vcblx0XHQjIHAgXCJyZWZlcmVuY2luZyB0aGlzXCJcblx0XHRzZWxmXG5cblx0ZGVmIGNcblx0XHRcInRoaXNcIlxuXG5cblxuXG4jIE9QRVJBVE9SU1xuXG5leHBvcnQgY2xhc3MgT3AgPCBOb2RlXG5cblx0cHJvcCBvcFxuXHRwcm9wIGxlZnRcblx0cHJvcCByaWdodFxuXG5cdGRlZiBpbml0aWFsaXplIG8sIGwsIHIgXG5cdFx0IyBzZXQgZXhwcmVzc2lvbiB5ZXMsIG5vP1xuXHRcdEBleHByZXNzaW9uID0gbm9cblx0XHRAdHJhdmVyc2VkID0gbm9cblx0XHRAcGFyZW5zID0gbm9cblx0XHRAY2FjaGUgPSBudWxsXG5cdFx0QGludmVydCA9IG5vXG5cdFx0QG9wVG9rZW4gPSBvXG5cdFx0QG9wID0gbyBhbmQgby5AdmFsdWUgb3Igb1xuXHRcdEBsZWZ0ID0gbFxuXHRcdEByaWdodCA9IHJcblx0XHRyZXR1cm4gc2VsZlxuXG5cdGRlZiB2aXNpdFxuXHRcdEByaWdodC50cmF2ZXJzZSBpZiBAcmlnaHRcblx0XHRAbGVmdC50cmF2ZXJzZSBpZiBAbGVmdFxuXHRcdHJldHVybiBzZWxmXG5cblx0ZGVmIGlzRXhwcmVzc2FibGVcblx0XHQjIHdoYXQgaWYgcmlnaHQgaXMgYSBzdHJpbmc/IT9cblx0XHQhcmlnaHQgfHwgcmlnaHQuaXNFeHByZXNzYWJsZVxuXG5cdGRlZiBqcyBvXG5cdFx0dmFyIG91dCA9IG51bGxcblx0XHR2YXIgb3AgPSBAb3BcblxuXHRcdHZhciBsID0gQGxlZnRcblx0XHR2YXIgciA9IEByaWdodFxuXG5cdFx0bCA9IGwuYyBpZiBsIGlzYSBOb2RlXG5cdFx0ciA9IHIuYyBpZiByIGlzYSBOb2RlXG5cblx0XHRpZiBsICYmIHJcblx0XHRcdG91dCA9IFwie2x9IHttYXJrX18oQG9wVG9rZW4pfXtvcH0ge3J9XCJcblx0XHRlbGlmIGxcblx0XHRcdG91dCA9IFwie21hcmtfXyhAb3BUb2tlbil9e29wfXtsfVwiXG5cdFx0IyBvdXQgPSBvdXQucGFyZW50aGVzaXplIGlmIHVwIGlzYSBPcCAjIHJlYWxseT9cblx0XHRvdXRcblxuXHRkZWYgc2hvdWxkUGFyZW50aGVzaXplXG5cdFx0QHBhcmVuc1xuXHRcdCMgb3B0aW9uKDpwYXJlbnMpXG5cblx0ZGVmIHByZWNlZGVuY2Vcblx0XHQxMFxuXG5cdGRlZiBjb25zdW1lIG5vZGVcblx0XHQjIHAgJ2Fzc2lnbmlmeSBpZj8hJ1xuXHRcdCMgaWYgaXQgaXMgcG9zc2libGUsIGNvbnZlcnQgaW50byBleHByZXNzaW9uXG5cdFx0aWYgbm9kZSBpc2EgVGFnVHJlZVxuXHRcdFx0QGxlZnQuY29uc3VtZShub2RlKSBpZiBAbGVmdFxuXHRcdFx0QHJpZ2h0LmNvbnN1bWUobm9kZSkgaWYgQHJpZ2h0XG5cdFx0XHQjIEBib2R5ID0gQGJvZHkuY29uc3VtZShub2RlKVxuXHRcdFx0IyBAYWx0ID0gQGFsdC5jb25zdW1lKG5vZGUpIGlmIEBhbHRcblx0XHRcdHJldHVybiBzZWxmXG5cdFx0IyBwIFwiT3AuY29uc3VtZSB7bm9kZX1cIi5jeWFuXG5cdFx0cmV0dXJuIHN1cGVyIGlmIGlzRXhwcmVzc2FibGVcblxuXHRcdCMgVE9ETyBjYW4gcmF0aGVyIHVzZSBnbG9iYWwgY2FjaGluZz9cblx0XHR2YXIgdG1wdmFyID0gc2NvcGVfXy5kZWNsYXJlKDp0bXAsbnVsbCxzeXN0ZW06IHllcylcblx0XHR2YXIgY2xvbmUgPSBPUChvcCxsZWZ0LG51bGwpXG5cdFx0dmFyIGFzdCA9IHJpZ2h0LmNvbnN1bWUoY2xvbmUpXG5cdFx0YXN0LmNvbnN1bWUobm9kZSkgaWYgbm9kZVxuXHRcdHJldHVybiBhc3RcblxuZXhwb3J0IGNsYXNzIENvbXBhcmlzb25PcCA8IE9wXG5cblx0ZGVmIGludmVydFxuXHRcdCMgYXJlIHRoZXJlIG90aGVyIGNvbXBhcmlzb24gb3BzP1xuXHRcdCMgd2hhdCBhYm91dCBhIGNoYWluP1xuXHRcdHZhciBvcCA9IEBvcFxuXHRcdHZhciBwYWlycyA9IFsgXCI9PVwiLFwiIT1cIiAsIFwiPT09XCIsXCIhPT1cIiAsIFwiPlwiLFwiPD1cIiAsIFwiPFwiLFwiPj1cIiBdXG5cdFx0dmFyIGlkeCA9IHBhaXJzLmluZGV4T2Yob3ApXG5cdFx0aWR4ICs9IChpZHggJSAyID8gLTEgOiAxKVxuXG5cdFx0IyBwIFwiaW52ZXJ0IHtAb3B9XCJcblx0XHQjIHAgXCJpbnZlcnRlZCBjb21wYXJpc29uKCEpIHtpZHh9IHtvcH0gLT4ge3BhaXJzW2lkeF19XCJcblx0XHRzZWxmLm9wID0gcGFpcnNbaWR4XVxuXHRcdEBpbnZlcnQgPSAhQGludmVydFxuXHRcdHNlbGZcblxuXHRkZWYgY1xuXHRcdGlmIGxlZnQgaXNhIENvbXBhcmlzb25PcFxuXHRcdFx0bGVmdC5yaWdodC5jYWNoZVxuXHRcdFx0T1AoJyYmJyxsZWZ0LE9QKG9wLGxlZnQucmlnaHQscmlnaHQpKS5jXG5cdFx0ZWxzZVxuXHRcdFx0c3VwZXJcblxuXHRkZWYganMgb1xuXHRcdHZhciBvcCA9IEBvcFxuXHRcdHZhciBsID0gQGxlZnRcblx0XHR2YXIgciA9IEByaWdodFxuXG5cdFx0bCA9IGwuYyBpZiBsIGlzYSBOb2RlXG5cdFx0ciA9IHIuYyBpZiByIGlzYSBOb2RlXG5cdFx0cmV0dXJuIFwie2x9IHttYXJrX18oQG9wVG9rZW4pfXtvcH0ge3J9XCJcblxuXHRcdFxuZXhwb3J0IGNsYXNzIE1hdGhPcCA8IE9wXG5cdCMgQlVHIGlmIHdlIGhhdmUgYSBzdGF0ZW1lbnQgaW4gbGVmdCBvciByaWdodCB3ZSBuZWVkXG5cdCMgdG8gRk9SQ0UgaXQgaW50byBhbiBleHByZXNzaW9uLCBhbmQgcmVnaXN0ZXIgd2FybmluZ1xuXHQjIHNob3VsZCBub3QgYXQgYWxsIGNvbnN1bWUgYW55dGhpbmcgbGlrZSBhIHJlZ3VsYXIgT3Bcblx0ZGVmIGNcblx0XHRpZiBvcCA9PSAn4oiqJ1xuXHRcdFx0cmV0dXJuIHV0aWwudW5pb24obGVmdCxyaWdodCkuY1xuXHRcdGVsaWYgb3AgPT0gJ+KIqSdcblx0XHRcdHJldHVybiB1dGlsLmludGVyc2VjdChsZWZ0LHJpZ2h0KS5jXG5cblxuZXhwb3J0IGNsYXNzIFVuYXJ5T3AgPCBPcFxuXG5cdGRlZiBpbnZlcnRcblx0XHRpZiBvcCA9PSAnISdcblx0XHRcdHJldHVybiBsZWZ0XG5cdFx0ZWxzZVxuXHRcdFx0c3VwZXIgIyByZWd1bGFyIGludmVydFxuXG5cdGRlZiBqcyBvXG5cdFx0dmFyIGwgPSBAbGVmdFxuXHRcdHZhciByID0gQHJpZ2h0XG5cdFx0IyBhbGwgb2YgdGhpcyBjb3VsZCByZWFsbHkgYmUgZG9uZSBpIGEgbXVjaFxuXHRcdCMgY2xlYW5lciB3YXkuXG5cdFx0IyBsLnNldChwYXJlbnM6IHllcykgaWYgbCAjIGFyZSB3ZSByZWFsbHkgc3VyZSBhYm91dCB0aGlzP1xuXHRcdCMgci5zZXQocGFyZW5zOiB5ZXMpIGlmIHJcblxuXHRcdGlmIG9wID09ICchJ1xuXHRcdFx0IyBsLkBwYXJlbnMgPSB5ZXNcblx0XHRcdHZhciBzdHIgPSBsLmNcblx0XHRcdHZhciBwYXJlbiA9IGwuc2hvdWxkUGFyZW50aGVzaXplKHNlbGYpXG5cdFx0XHQjIHAgXCJjaGVjayBmb3IgcGFyZW5zIGluICE6IHtzdHJ9IHtsfSB7bC5AcGFyZW5zfSB7bC5zaG91bGRQYXJlbnRoZXNpemUoc2VsZil9XCJcblx0XHRcdCMgRklYTUUgdGhpcyBpcyBhIHZlcnkgaGFja3kgd29ya2Fyb3VuZC4gTmVlZCB0byBoYW5kbGUgYWxsIHRoaXNcblx0XHRcdCMgaW4gdGhlIGNoaWxkIGluc3RlYWQsIHByb2JsZW1zIGFyaXNlIGR1ZSB0byBhdXRvbWF0aWMgY2FjaGluZ1xuXHRcdFx0c3RyID0gJygnICsgc3RyICsgJyknIHVubGVzcyBzdHIubWF0Y2goL15cXCE/KFtcXHdcXC5dKykkLykgb3IgbCBpc2EgUGFyZW5zIG9yIHBhcmVuIG9yIGwgaXNhIEFjY2VzcyBvciBsIGlzYSBDYWxsXG5cdFx0XHQjIGwuc2V0KHBhcmVuczogeWVzKSAjIHN1cmU/XG5cdFx0XHRcIntvcH17c3RyfVwiXG5cblx0XHRlbGlmIG9wID09ICfiiJonXG5cdFx0XHRcIk1hdGguc3FydCh7bC5jfSlcIlxuXG5cdFx0ZWxpZiBsZWZ0XG5cdFx0XHRcIntsLmN9e29wfVwiXG5cblx0XHRlbHNlXG5cdFx0XHRcIntvcH17ci5jfVwiXG5cblx0ZGVmIG5vcm1hbGl6ZVxuXHRcdHJldHVybiBzZWxmIGlmIG9wID09ICchJyBvciBvcCA9PSAn4oiaJ1xuXHRcdHZhciBub2RlID0gKGxlZnQgfHwgcmlnaHQpLm5vZGVcblx0XHQjIGZvciBwcm9wZXJ0eS1hY2Nlc3NvcnMgd2UgbmVlZCB0byByZXdyaXRlIHRoZSBhc3Rcblx0XHRyZXR1cm4gc2VsZiB1bmxlc3Mgbm9kZSBpc2EgUHJvcGVydHlBY2Nlc3NcblxuXHRcdCMgYXNrIHRvIGNhY2hlIHRoZSBwYXRoXG5cdFx0bm9kZS5sZWZ0LmNhY2hlIGlmIG5vZGUgaXNhIEFjY2VzcyAmJiBub2RlLmxlZnRcblxuXHRcdHZhciBudW0gPSBOdW0ubmV3KDEpXG5cdFx0dmFyIGFzdCA9IE9QKCc9Jyxub2RlLE9QKG9wWzBdLG5vZGUsbnVtKSlcblx0XHRhc3QgPSBPUChvcFswXSA9PSAnLScgPyAnKycgOiAnLScsYXN0LG51bSkgaWYgbGVmdFxuXG5cdFx0cmV0dXJuIGFzdFxuXG5cdGRlZiBjb25zdW1lIG5vZGVcblx0XHR2YXIgbm9ybSA9IG5vcm1hbGl6ZVxuXHRcdG5vcm0gPT0gc2VsZiA/IHN1cGVyIDogbm9ybS5jb25zdW1lKG5vZGUpXG5cblx0ZGVmIGNcblx0XHR2YXIgbm9ybSA9IG5vcm1hbGl6ZVxuXHRcdG5vcm0gPT0gc2VsZiA/IHN1cGVyIDogbm9ybS5jXG5cbmV4cG9ydCBjbGFzcyBJbnN0YW5jZU9mIDwgT3BcblxuXHRkZWYganMgb1xuXHRcdCMgZml4IGNoZWNrcyBmb3IgU3RyaW5nIGFuZCBOdW1iZXJcblx0XHQjIHAgcmlnaHQuaW5zcGVjdFxuXG5cdFx0aWYgcmlnaHQgaXNhIENvbnN0XG5cdFx0XHQjIFdBUk4gb3RoZXJ3aXNlIC0gd2hhdCBkbyB3ZSBkbz8gZG9lcyBub3Qgd29yayB3aXRoIGR5bmFtaWNcblx0XHRcdCMgY2xhc3NlcyBldGM/IFNob3VsZCBwcm9iYWJseSBzZW5kIHRvIHV0aWxpdHkgZnVuY3Rpb24gaXNhJFxuXHRcdFx0dmFyIG5hbWUgPSBjX18ocmlnaHQudmFsdWUpXG5cdFx0XHR2YXIgb2JqID0gbGVmdC5ub2RlXG5cdFx0XHQjIFRPRE8gYWxzbyBjaGVjayBmb3IgcHJpbWl0aXZlLWNvbnN0cnVjdG9yXG5cdFx0XHRpZiBuYW1lIGluIFsnU3RyaW5nJywnTnVtYmVyJywnQm9vbGVhbiddXG5cdFx0XHRcdHVubGVzcyBvYmogaXNhIExvY2FsVmFyQWNjZXNzXG5cdFx0XHRcdFx0b2JqLmNhY2hlXG5cdFx0XHRcdCMgbmVlZCBhIGRvdWJsZSBjaGVjayBmb3IgdGhlc2UgKGNhY2hlIGxlZnQpIC0gcG9zc2libHlcblx0XHRcdFx0cmV0dXJuIFwiKHR5cGVvZiB7b2JqLmN9PT0ne25hbWUudG9Mb3dlckNhc2V9J3x8e29iai5jfSBpbnN0YW5jZW9mIHtuYW1lfSlcIlxuXHRcdFx0XG5cdFx0XHRcdCMgY29udmVydFxuXHRcdHZhciBvdXQgPSBcIntsZWZ0LmN9IHtvcH0ge3JpZ2h0LmN9XCJcblxuXHRcdCMgc2hvdWxkIHRoaXMgbm90IGhhcHBlbiBpbiAjYz9cblx0XHRvdXQgPSBoZWxwZXJzLnBhcmVudGhlc2l6ZShvdXQpIGlmIG8ucGFyZW50IGlzYSBPcFxuXHRcdG91dFxuXG5leHBvcnQgY2xhc3MgVHlwZU9mIDwgT3BcblxuXHRkZWYganMgb1xuXHRcdFwidHlwZW9mIHtsZWZ0LmN9XCJcblxuZXhwb3J0IGNsYXNzIERlbGV0ZSA8IE9wXG5cblx0ZGVmIGpzIG9cblx0XHQjIFRPRE8gdGhpcyB3aWxsIGV4ZWN1dGUgY2FsbHMgc2V2ZXJhbCB0aW1lcyBpZiB0aGUgcGF0aCBpcyBub3QgZGlyZWN0bHkgdG8gYW4gb2JqZWN0XG5cdFx0IyBuZWVkIHRvIGNhY2hlIHRoZSByZWNlaXZlclxuXHRcdHZhciBsID0gbGVmdFxuXHRcdHZhciB0bXAgPSBzY29wZV9fLnRlbXBvcmFyeShzZWxmLCBwb29sOiAndmFsJylcblx0XHR2YXIgbyA9IE9QKCc9Jyx0bXAsbClcblx0XHQjIEZJWE1FXG5cdFx0cmV0dXJuIFwiKHtvLmN9LGRlbGV0ZSB7bC5jfSwge3RtcC5jfSlcIiAjIG9oIHdlbGxcblx0XHQjIHZhciBhc3QgPSBbT1AoJz0nLHRtcCxsZWZ0KSxcImRlbGV0ZSB7bGVmdC5jfVwiLHRtcF1cblx0XHQjIHNob3VsZCBwYXJlbnRoZXNpemUgZGlyZWN0bHkgbm8/XG5cdFx0IyBhc3QuY1xuXG5cdGRlZiBzaG91bGRQYXJlbnRoZXNpemVcblx0XHR5ZXNcblxuZXhwb3J0IGNsYXNzIEluIDwgT3BcblxuXHRkZWYgaW52ZXJ0XG5cdFx0QGludmVydCA9ICFAaW52ZXJ0XG5cdFx0c2VsZlxuXG5cdGRlZiBqcyBvXG5cdFx0dmFyIGNvbmQgPSBAaW52ZXJ0ID8gXCI9PSAtMVwiIDogXCI+PSAwXCJcblx0XHR2YXIgaWR4ID0gVXRpbC5pbmRleE9mKGxlZnQscmlnaHQpXG5cdFx0XCJ7aWR4LmN9IHtjb25kfVwiXG5cdFxuXG5cblxuXG5cblxuIyBBQ0NFU1NcblxuZXhwb3J0IHZhciBLX0lWQVIgPSAxXG5leHBvcnQgdmFyIEtfU1lNID0gMlxuZXhwb3J0IHZhciBLX1NUUiA9IDNcbmV4cG9ydCB2YXIgS19QUk9QID0gNFxuXG5leHBvcnQgY2xhc3MgQWNjZXNzIDwgT3BcblxuXHRkZWYgaW5pdGlhbGl6ZSBvLCBsLCByIFxuXHRcdCMgc2V0IGV4cHJlc3Npb24geWVzLCBubz9cblx0XHRAZXhwcmVzc2lvbiA9IG5vXG5cdFx0QHRyYXZlcnNlZCA9IG5vXG5cdFx0QHBhcmVucyA9IG5vXG5cdFx0QGNhY2hlID0gbnVsbFxuXHRcdEBpbnZlcnQgPSBub1xuXHRcdEBvcCA9IG8gYW5kIG8uQHZhbHVlIG9yIG9cblx0XHRAbGVmdCA9IGxcblx0XHRAcmlnaHQgPSByXG5cdFx0cmV0dXJuIHNlbGZcblxuXHRkZWYgY2xvbmUgbGVmdCwgcmlnaHRcblx0XHR2YXIgY3RvciA9IHNlbGY6Y29uc3RydWN0b3Jcblx0XHRjdG9yLm5ldyhvcCxsZWZ0LHJpZ2h0KVxuXG5cdGRlZiBqcyBvXG5cdFx0dmFyIHJhdyA9IG51bGxcblx0XHR2YXIgcmd0ID0gcmlnaHRcblx0XHR2YXIgY3R4ID0gKGxlZnQgfHwgc2NvcGVfXy5jb250ZXh0KVxuXHRcdHZhciBwcmUgPSBcIlwiXG5cdFx0dmFyIG1hcmsgPSAnJ1xuXG5cdFx0IyBpZiBzYWZlY2hhaW5cblx0XHQjXHRwIFwiQWNjZXNzIGlzIHNhZmVjaGFpbmVkIHtyZ3QuY31cIlxuXG5cblx0XHRpZiByZ3QgaXNhIE51bVxuXHRcdFx0cmV0dXJuIGN0eC5jICsgXCJbXCIgKyByZ3QuYyArIFwiXVwiXG5cblx0XHQjIGlzIHRoaXMgcmlnaHQ/IFNob3VsZCBub3QgdGhlIGluZGV4IGNvbXBpbGUgdGhlIGJyYWNrZXRzXG5cdFx0IyBvciB2YWx1ZSBpcyBhIHN5bWJvbCAtLSBzaG91bGQgYmUgdGhlIHNhbWUsIG5vP1xuXHRcdGlmIHJndCBpc2EgSW5kZXggYW5kIChyZ3QudmFsdWUgaXNhIFN0ciBvciByZ3QudmFsdWUgaXNhIFN5bWJvbClcblx0XHRcdHJndCA9IHJndC52YWx1ZVxuXG5cdFx0IyBUT0RPIGRvIHRoZSBpZGVudGlmaWVyLXZhbGlkYXRpb24gaW4gYSBjZW50cmFsIHBsYWNlIGluc3RlYWRcblx0XHRpZiByZ3QgaXNhIFN0ciBhbmQgcmd0LmlzVmFsaWRJZGVudGlmaWVyXG5cdFx0XHRyYXcgPSByZ3QucmF3XG5cblx0XHRlbGlmIHJndCBpc2EgU3ltYm9sIGFuZCByZ3QuaXNWYWxpZElkZW50aWZpZXJcblx0XHRcdHJhdyA9IHJndC5yYXdcblxuXHRcdGVsaWYgcmd0IGlzYSBJZGVudGlmaWVyIGFuZCByZ3QuaXNWYWxpZElkZW50aWZpZXJcblx0XHRcdG1hcmsgPSBtYXJrX18ocmd0LkB2YWx1ZSlcblx0XHRcdHJhdyA9IHJndC5jXG5cblx0XHRpZiBzYWZlY2hhaW4gYW5kIGN0eFxuXHRcdFx0Y3R4LmNhY2hlKGZvcmNlOiB5ZXMpXG5cdFx0XHRwcmUgPSBjdHguYyArIFwiICYmIFwiXG5cblx0XHQjIHJlYWxseT9cblx0XHQjIHZhciBjdHggPSAobGVmdCB8fCBzY29wZV9fLmNvbnRleHQpXG5cdFx0dmFyIG91dCA9IGlmIHJhd1xuXHRcdFx0IyBzZWUgaWYgaXQgbmVlZHMgcXVvdGluZ1xuXHRcdFx0IyBuZWVkIHRvIGNoZWNrIHRvIHNlZSBpZiBpdCBpcyBsZWdhbFxuXHRcdFx0Y3R4ID8gXCJ7Y3R4LmN9LnttYXJrfXtyYXd9XCIgOiByYXdcblx0XHRlbHNlXG5cdFx0XHR2YXIgciA9IHJndCBpc2EgTm9kZSA/IHJndC5jKGV4cHJlc3Npb246IHllcykgOiByZ3Rcblx0XHRcdFwie2N0eC5jfVt7cn1dXCJcblxuXHRcdCMgaWYgc2FmZWNoYWluIGFuZCBjdHhcblx0XHQjIFx0b3V0ID0gXCJ7Y3R4LmN9ICYmIHtvdXR9XCJcblxuXHRcdHJldHVybiBwcmUgKyBvdXRcblxuXHRkZWYgdmlzaXRcblx0XHRsZWZ0LnRyYXZlcnNlIGlmIGxlZnRcblx0XHRyaWdodC50cmF2ZXJzZSBpZiByaWdodFxuXHRcdHJldHVyblxuXG5cdGRlZiBpc0V4cHJlc3NhYmxlXG5cdFx0dHJ1ZVxuXG5cdGRlZiBhbGlhc1xuXHRcdHJpZ2h0IGlzYSBJZGVudGlmaWVyID8gcmlnaHQuYWxpYXMgOiBzdXBlcigpXG5cblx0ZGVmIHNhZmVjaGFpblxuXHRcdCMgcmlnaHQuc2FmZWNoYWluXG5cdFx0U3RyaW5nKEBvcCkgPT0gJz8uJyBvciBTdHJpbmcoQG9wKSA9PSAnPzonXG5cblx0ZGVmIGNhY2hlIG9cblx0XHQocmlnaHQgaXNhIEl2YXIgJiYgIWxlZnQpID8gc2VsZiA6IHN1cGVyKG8pXG5cdFx0XG5cblxuIyBTaG91bGQgY2hhbmdlIHRoaXMgdG8ganVzdCByZWZlciBkaXJlY3RseSB0byB0aGUgdmFyaWFibGU/IE9yIFZhclJlZmVyZW5jZVxuZXhwb3J0IGNsYXNzIExvY2FsVmFyQWNjZXNzIDwgQWNjZXNzXG5cblx0cHJvcCBzYWZlY2hhaW5cblxuXHRkZWYganMgb1xuXHRcdGlmIHJpZ2h0IGlzYSBWYXJpYWJsZSBhbmQgcmlnaHQudHlwZSA9PSAnbWV0aCdcblx0XHRcdHJldHVybiBcIntyaWdodC5jfSgpXCIgdW5sZXNzIHVwIGlzYSBDYWxsXG5cblx0XHRyaWdodC5jXG5cblx0ZGVmIHZhcmlhYmxlXG5cdFx0cmlnaHRcblxuXHRkZWYgY2FjaGUgbyA9IHt9XG5cdFx0c3VwZXIobykgaWYgbzpmb3JjZVxuXHRcdHNlbGZcblxuXHRkZWYgYWxpYXNcblx0XHR2YXJpYWJsZS5AYWxpYXMgb3Igc3VwZXIoKVxuXG5cbmV4cG9ydCBjbGFzcyBHbG9iYWxWYXJBY2Nlc3MgPCBWYWx1ZU5vZGVcblxuXHRkZWYganMgb1xuXHRcdHZhbHVlLmNcblxuXG5leHBvcnQgY2xhc3MgT2JqZWN0QWNjZXNzIDwgQWNjZXNzXG5cblxuZXhwb3J0IGNsYXNzIFByb3BlcnR5QWNjZXNzIDwgQWNjZXNzXG5cblx0ZGVmIGluaXRpYWxpemUgbywgbCwgciBcblx0XHRAdHJhdmVyc2VkID0gbm9cblx0XHRAaW52ZXJ0ID0gbm9cblx0XHRAcGFyZW5zID0gbm9cblx0XHRAZXhwcmVzc2lvbiA9IG5vICMgeWVzP1xuXHRcdEBjYWNoZSA9IG51bGxcblx0XHRAb3AgPSBvXG5cdFx0QGxlZnQgPSBsXG5cdFx0QHJpZ2h0ID0gclxuXHRcdHJldHVybiBzZWxmXG5cblx0ZGVmIHZpc2l0XG5cdFx0QHJpZ2h0LnRyYXZlcnNlIGlmIEByaWdodFxuXHRcdEBsZWZ0LnRyYXZlcnNlIGlmIEBsZWZ0XG5cdFx0cmV0dXJuIHNlbGZcblxuXHQjIHJpZ2h0IGluIGMgd2Ugc2hvdWxkIHBvc3NpYmx5IG92ZXJyaWRlXG5cdCMgdG8gY3JlYXRlIGEgY2FsbCBhbmQgcmVndWxhciBhY2Nlc3MgaW5zdGVhZFxuXG5cdGRlZiBqcyBvXG5cdFxuXHRcdGlmIHZhciByZWMgPSByZWNlaXZlclxuXHRcdFx0IyBwIFwiY29udmVydGluZyB0byBjYWxsXCJcblx0XHRcdHZhciBhc3QgPSBDQUxMKE9QKCcuJyxsZWZ0LHJpZ2h0KSxbXSkgIyBjb252ZXJ0IHRvIEFyZ0xpc3Qgb3IgbnVsbFxuXHRcdFx0YXN0LnJlY2VpdmVyID0gcmVjXG5cdFx0XHRyZXR1cm4gYXN0LmNcblxuXHRcdHZhciB1cCA9IHVwXG5cblx0XHR1bmxlc3MgdXAgaXNhIENhbGxcblx0XHRcdCMgcCBcImNvbnZlcnQgdG8gY2FsbCBpbnN0ZWFkXCJcblx0XHRcdHZhciBhc3QgPSBDQUxMKEFjY2Vzcy5uZXcob3AsbGVmdCxyaWdodCksW10pXG5cdFx0XHRyZXR1cm4gYXN0LmNcblxuXHRcdCMgcmVhbGx5IG5lZWQgdG8gZml4IHRoaXMgLSBmb3Igc3VyZVxuXHRcdCMgc2hvdWxkIGJlIHBvc3NpYmxlIGZvciB0aGUgZnVuY3Rpb24gdG8gcmVtb3ZlIHRoaXMgdGhpcyBpbnN0ZWFkP1xuXHRcdHZhciBqcyA9IFwie3N1cGVyKG8pfVwiXG5cblx0XHR1bmxlc3MgKHVwIGlzYSBDYWxsIG9yIHVwIGlzYSBVdGlsLklzRnVuY3Rpb24pXG5cdFx0XHQjIHAgXCJDYWxsZWRcIlxuXHRcdFx0anMgKz0gXCIoKVwiXG5cblx0XHRyZXR1cm4ganNcblxuXG5cdGRlZiByZWNlaXZlclxuXHRcdGlmIGxlZnQgaXNhIFN1cGVyQWNjZXNzIHx8IGxlZnQgaXNhIFN1cGVyXG5cdFx0XHRTRUxGXG5cdFx0ZWxzZVxuXHRcdFx0bnVsbFxuXG5cbmV4cG9ydCBjbGFzcyBJdmFyQWNjZXNzIDwgQWNjZXNzXG5cblx0ZGVmIGNhY2hlXG5cdFx0IyBXQVJOIGhtbSwgdGhpcyBpcyBub3QgcmlnaHQuLi4gd2hlbiBhY2Nlc3Npbmcgb24gYW5vdGhlciBvYmplY3QgaXQgd2lsbCBuZWVkIHRvIGJlIGNhY2hlZFxuXHRcdHJldHVybiBzZWxmXG5cblxuZXhwb3J0IGNsYXNzIENvbnN0QWNjZXNzIDwgQWNjZXNzXG5cblxuZXhwb3J0IGNsYXNzIEluZGV4QWNjZXNzIDwgQWNjZXNzXG5cblx0ZGVmIGNhY2hlIG8gPSB7fVxuXHRcdHJldHVybiBzdXBlciBpZiBvOmZvcmNlXG5cdFx0cmlnaHQuY2FjaGVcblx0XHRzZWxmXG5cblxuZXhwb3J0IGNsYXNzIFN1cGVyQWNjZXNzIDwgQWNjZXNzXG5cblx0ZGVmIGpzIG9cblx0XHR2YXIgbSA9IG8ubWV0aG9kXG5cdFx0dmFyIHVwID0gby5wYXJlbnRcblx0XHR2YXIgZGVlcCA9IG8ucGFyZW50IGlzYSBBY2Nlc3NcblxuXHRcdHZhciBvdXQgPSBcIntsZWZ0LmN9Ll9fc3VwZXJfX1wiXG5cblx0XHR1bmxlc3MgdXAgaXNhIEFjY2Vzc1xuXHRcdFx0b3V0ICs9IFwiLnttLnN1cGVybmFtZS5jfVwiXG5cdFx0XHR1bmxlc3MgdXAgaXNhIENhbGwgIyBhdXRvY2FsbD9cblx0XHRcdFx0b3V0ICs9IFwiLmFwcGx5KHttLnNjb3BlLmNvbnRleHQuY30sYXJndW1lbnRzKVwiXG5cblx0XHRyZXR1cm4gb3V0XG5cblx0ZGVmIHJlY2VpdmVyXG5cdFx0U0VMRlxuXG5cbmV4cG9ydCBjbGFzcyBWYXJPckFjY2VzcyA8IFZhbHVlTm9kZVxuXG5cdGRlZiBpbml0aWFsaXplIHZhbHVlXG5cdFx0IyBzaG91bGQgcmF0aGVyIGNhbGwgdXAgdG8gdmFsdWVub2RlP1xuXHRcdEB0cmF2ZXJzZWQgXHQ9IG5vXG5cdFx0QHBhcmVucyBcdD0gbm9cblx0XHRAdmFsdWUgXHRcdD0gdmFsdWVcblx0XHRAaWRlbnRpZmllciA9IHZhbHVlXG5cdFx0QHRva2VuIFx0XHQ9IHZhbHVlLkB2YWx1ZVxuXHRcdEB2YXJpYWJsZSA9IG51bGxcblx0XHRzZWxmXG5cblx0IyBTaG9ydGNpcmN1aXQgdHJhdmVyc2Ugc28gdGhhdCBpdCBpcyBub3QgYWRkZWQgdG8gdGhlIHN0YWNrPyFcblx0ZGVmIHZpc2l0XG5cdFx0IyBAaWRlbnRpZmllciA9IHZhbHVlICMgdGhpcyBpcyBub3QgYSByZWFsIGlkZW50aWZpZXI/XG5cdFx0IyBjb25zb2xlLmxvZyBcIlZhck9yQWNjZXNzIHtAaWRlbnRpZmllcn1cIlxuXHRcdCMgcCBcInZpc2l0IHtzZWxmfVwiXG5cblxuXHRcdHZhciBzY29wZSA9IHNjb3BlX19cblxuXHRcdHZhciB2YXJpYWJsZSA9IHNjb3BlLmxvb2t1cCh2YWx1ZSlcblxuXHRcdCMgZG9lcyBub3QgcmVhbGx5IG5lZWQgdG8gaGF2ZSBhIGRlY2xhcmF0b3IgYWxyZWFkeT8gLS0gdHJpY2t5XG5cdFx0aWYgdmFyaWFibGUgJiYgdmFyaWFibGUuZGVjbGFyYXRvclxuXHRcdFx0IyB2YXIgZGVjbCA9IHZhcmlhYmxlLmRlY2xhcmF0b3JcblxuXHRcdFx0IyBpZiB0aGUgdmFyaWFibGUgaXMgbm90IGluaXRpYWxpemVkIGp1c3QgeWV0IGFuZCB3ZSBhcmVcblx0XHRcdCMgaW4gdGhlIHNhbWUgc2NvcGUgLSB3ZSBzaG91bGQgbm90IHRyZWF0IHRoaXMgYXMgYSB2YXItbG9va3VwXG5cdFx0XHQjIGllLiAgdmFyIHggPSB4IHdvdWxkIHJlc29sdmUgdG8gdmFyIHggPSB0aGlzLngoKSBpZiB4XG5cdFx0XHQjIHdhcyBub3QgcHJldmlvdXNseSBkZWZpbmVkXG5cblx0XHRcdCMgc2hvdWxkIGRvIHRoaXMgZXZlbiBpZiB3ZSBhcmUgbm90IGluIHRoZSBzYW1lIHNjb3BlP1xuXHRcdFx0IyB3ZSBvbmx5IG5lZWQgdG8gYmUgaW4gdGhlIHNhbWUgY2xvc3VyZSghKVxuXG5cdFx0XHRpZiB2YXJpYWJsZS5AaW5pdGlhbGl6ZWQgb3IgKHNjb3BlLmNsb3N1cmUgIT0gdmFyaWFibGUuc2NvcGUuY2xvc3VyZSlcblx0XHRcdFx0QHZhcmlhYmxlID0gdmFyaWFibGVcblx0XHRcdFx0dmFyaWFibGUuYWRkUmVmZXJlbmNlKHNlbGYpXG5cdFx0XHRcdEB2YWx1ZSA9IHZhcmlhYmxlICMgdmFyaWFibGUuYWNjZXNzb3Ioc2VsZilcblx0XHRcdFx0QHRva2VuLkB2YXJpYWJsZSA9IHZhcmlhYmxlXG5cdFx0XHRcdHJldHVybiBzZWxmXG5cblx0XHRcdCMgcCBcInZhciBpcyBub3QgeWV0IGluaXRpYWxpemVkIVwiXG5cdFx0XHQjIHAgXCJkZWNsYXJhdG9yIGZvciB2YXIge2RlY2wuQGRlY2xhcmVkfVwiXG5cdFx0XHQjIEZJWFxuXHRcdFx0IyBAdmFsdWUuc2FmZWNoYWluID0gc2FmZWNoYWluXG5cblx0XHQjIFRPRE8gZGVwcmVjYXRlIGFuZCByZW1vdmVcblx0XHRpZiB2YWx1ZS5zeW1ib2wuaW5kZXhPZignJCcpID49IDBcblx0XHRcdCMgYmlnIGhhY2sgLSBzaG91bGQgZGlzYWJsZVxuXHRcdFx0IyBtYWpvciBoYWNrIGhlcmUsIG5vP1xuXHRcdFx0IyBjb25zb2xlLmxvZyBcIkdsb2JhbFZhckFjY2Vzc1wiXG5cdFx0XHRAdmFsdWUgPSBHbG9iYWxWYXJBY2Nlc3MubmV3KHZhbHVlKVxuXHRcdFx0cmV0dXJuIHNlbGZcblxuXHRcdCMgcmVhbGx5PyB3aGF0IGFib3V0IGp1c3QgbWltaWNraW5nIHRoZSB0d28gZGlmZnJlbnQgaW5zdGVhZD9cblx0XHQjIFNob3VsZCB3ZSBub3QgcmV0dXJuIGEgY2FsbCBkaXJlY3RseSBpbnN0ZWFkP1xuXHRcdEB2YWx1ZSA9IFByb3BlcnR5QWNjZXNzLm5ldyhcIi5cIixzY29wZS5jb250ZXh0LHZhbHVlKVxuXHRcdCMgbWFyayB0aGUgc2NvcGUgLyBjb250ZXh0IC0tIHNvIHdlIGNhbiBzaG93IGNvcnJlY3QgaW1wbGljaXRcblx0XHRAdG9rZW4uQG1ldGEgPSB7dHlwZTogJ0FDQ0VTUyd9XG5cdFx0IyBAdmFsdWUudHJhdmVyc2UgIyBuYWhcblx0XHRzZWxmXG5cblx0ZGVmIGNcblx0XHRtYXJrX18oQHRva2VuKSArIChAdmFyaWFibGUgPyBzdXBlcigpIDogdmFsdWUuYylcblxuXHRkZWYganMgb1xuXHRcblx0XHRpZiB2YXIgdiA9IEB2YXJpYWJsZVxuXHRcdFx0dmFyIG91dCA9IHYuY1xuXHRcdFx0b3V0ICs9IFwiKClcIiBpZiB2LkB0eXBlID09ICdtZXRoJyBhbmQgIShvLnVwIGlzYSBDYWxsKVxuXHRcdFx0cmV0dXJuIG91dFxuXHRcdHJldHVybiBcIk5PTk9cIlxuXHRcdFxuXHRkZWYgbm9kZVxuXHRcdEB2YXJpYWJsZSA/IHNlbGYgOiB2YWx1ZVxuXG5cdGRlZiBzeW1ib2xcblx0XHRAaWRlbnRpZmllci5zeW1ib2xcblx0XHQjIHZhbHVlIGFuZCB2YWx1ZS5zeW1ib2xcblxuXHRkZWYgY2FjaGUgbyA9IHt9XG5cdFx0QHZhcmlhYmxlID8gKG86Zm9yY2UgYW5kIHN1cGVyKG8pKSA6IHZhbHVlLmNhY2hlKG8pXG5cdFx0IyBzaG91bGQgd2UgcmVhbGx5IGNhY2hlIHRoaXM/XG5cdFx0IyB2YWx1ZS5jYWNoZShvKVxuXG5cdGRlZiBkZWNhY2hlXG5cdFx0QHZhcmlhYmxlID8gc3VwZXIoKSA6IHZhbHVlLmRlY2FjaGVcblx0XHRzZWxmXG5cblx0ZGVmIGRvbVxuXHRcdHZhbHVlLmRvbVxuXG5cdGRlZiBzYWZlY2hhaW5cblx0XHRAaWRlbnRpZmllci5zYWZlY2hhaW5cblxuXHRkZWYgZHVtcFxuXHRcdHsgbG9jOiBsb2MgfVxuXG5cdGRlZiBsb2Ncblx0XHR2YXIgbG9jID0gQGlkZW50aWZpZXIucmVnaW9uXG5cdFx0cmV0dXJuIGxvYyBvciBbMCwwXVxuXG5cdGRlZiByZWdpb25cblx0XHRAaWRlbnRpZmllci5yZWdpb25cblxuXHRkZWYgdG9TdHJpbmdcblx0XHRcIlZhck9yQWNjZXNzKHt2YWx1ZX0pXCJcblxuXHRkZWYgdG9KU09OXG5cdFx0e3R5cGU6IHR5cGVOYW1lLCB2YWx1ZTogQGlkZW50aWZpZXIudG9TdHJpbmd9XG5cbiNcdGRlZiBqc1xuI1x0XHRpZiByaWdodCBpc2EgVmFyaWFibGUgYW5kIHJpZ2h0LnR5cGUgPT0gJ21ldGgnXG4jXHRcdFx0cmV0dXJuIFwie3JpZ2h0LmN9KClcIiB1bmxlc3MgdXAgaXNhIENhbGxcbiNcbiNcdFx0cmlnaHQuY1xuI1xuI1x0ZGVmIHZhcmlhYmxlXG4jXHRcdHJpZ2h0XG4jXG4jXHRkZWYgY2FjaGUgbyA9IHt9XG4jXHRcdHN1cGVyIGlmIG86Zm9yY2VcbiNcdFx0c2VsZlxuI1xuI1x0ZGVmIGFsaWFzXG4jXHRcdHZhcmlhYmxlLkBhbGlhcyBvciBzdXBlciAjIGlmIHJlc29sdmVkP1xuI1xuXG5leHBvcnQgY2xhc3MgVmFyUmVmZXJlbmNlIDwgVmFsdWVOb2RlXG5cblx0IyBUT0RPIFZhckJsb2NrIHNob3VsZCBjb252ZXJ0IHRoZXNlIHRvIHBsYWluIC8gZHVtYiBub2Rlc1xuXG5cdHByb3AgdmFyaWFibGVcblx0cHJvcCBkZWNsYXJlZFxuXHRwcm9wIHR5cGVcblxuXHRkZWYgaW5pdGlhbGl6ZSB2YWx1ZSwgdHlwZVxuXHRcdGlmIHZhbHVlIGlzYSBWYXJPckFjY2Vzc1xuXHRcdFx0dmFsdWUgPSB2YWx1ZS52YWx1ZVxuXHRcdCMgZm9yIG5vdyAtIHRoaXMgY2FuIGhhcHBlblxuXHRcdHN1cGVyKHZhbHVlKVxuXHRcdEBleHBvcnQgPSBub1xuXHRcdEB0eXBlID0gdHlwZSBhbmQgU3RyaW5nKHR5cGUpXG5cdFx0QHZhcmlhYmxlID0gbnVsbFxuXHRcdEBkZWNsYXJlZCA9IHllcyAjIGp1c3QgdGVzdGluZyBub3dcblxuXG5cdGRlZiBsb2Ncblx0XHQjIHAgXCJsb2MgZm9yIFZhclJlZmVyZW5jZSB7QHZhbHVlOmNvbnN0cnVjdG9yfSB7QHZhbHVlLkB2YWx1ZTpjb25zdHJ1Y3Rvcn0ge0B2YWx1ZS5yZWdpb259XCJcblx0XHRAdmFsdWUucmVnaW9uXG5cblx0ZGVmIHNldCBvXG5cdFx0IyBoYWNrIC0gd29ya2Fyb3VuZCBmb3IgaGlkZGVuIGNsYXNzZXMgcGVyZlxuXHRcdEBleHBvcnQgPSB5ZXMgaWYgbzpleHBvcnRcblx0XHRyZXR1cm4gc2VsZlxuXG5cdGRlZiBqcyBvXG5cdFx0IyBleHBlcmltZW50YWwgZml4XG5cdFx0XG5cdFx0IyB3aGF0IGFib3V0IHJlc29sdmluZz9cblx0XHR2YXIgcmVmID0gQHZhcmlhYmxlXG5cdFx0dmFyIG91dCA9IFwie21hcmtfXyhAdmFsdWUpfXtyZWYuY31cIlxuXG5cdFx0IyBwIFwiVmFyUmVmZXJlbmNlIHtvdXR9IC0ge28udXB9IHtvLnVwID09IHNlbGZ9XFxue299XCJcblxuXHRcdGlmIHJlZiAmJiAhcmVmLkBkZWNsYXJlZCAjIC5vcHRpb24oOmRlY2xhcmVkKVxuXHRcdFx0aWYgby51cChWYXJCbG9jaykgIyB1cCB2YXJibG9jaz8/XG5cdFx0XHRcdHJlZi5AZGVjbGFyZWQgPSB5ZXNcblxuXHRcdFx0XHQjIHJlZi5zZXQoZGVjbGFyZWQ6IHllcylcblx0XHRcdGVsaWYgby5pc0V4cHJlc3Npb24gb3IgQGV4cG9ydCAjIHdoeT9cblx0XHRcdFx0IyBwIFwiYXV0b2RlY2xhcmVcIlxuXHRcdFx0XHRyZWYuYXV0b2RlY2xhcmVcblx0XHRcdGVsc2Vcblx0XHRcdFx0b3V0ID0gXCJ2YXIge291dH1cIlxuXHRcdFx0XHRyZWYuQGRlY2xhcmVkID0geWVzXG5cdFx0XHRcdCMgcmVmLnNldChkZWNsYXJlZDogeWVzKVxuXG5cdFx0IyBuZWVkIHRvIHRoaW5rIHRoZSBleHBvcnQgdGhyb3VnaCAtLSBsaWtlIHJlZ2lzdGVyaW5nIHNvbWVob3dcblx0XHQjIHNob3VsZCByZWdpc3RlciBpbiBzY29wZSAtIGV4cG9ydCBvbiBhbmFseXNpcysrXG5cdFx0aWYgQGV4cG9ydFxuXHRcdFx0b3V0ID0gXCJtb2R1bGUuZXhwb3J0cy57cmVmLmN9ID0ge3JlZi5jfVwiXG5cblx0XHRyZXR1cm4gb3V0XG5cblx0ZGVmIGRlY2xhcmVcblx0XHRzZWxmXG5cblx0ZGVmIGNvbnN1bWUgbm9kZVxuXHRcdCMgcmVhbGx5PyB0aGUgY29uc3VtZWQgbm9kZSBkaXNzYXBwZWFyP1xuXHRcdEB2YXJpYWJsZSAmJiBAdmFyaWFibGUuYXV0b2RlY2xhcmVcblx0XHRzZWxmXG5cblx0ZGVmIHZpc2l0XG5cdFx0XG5cdFx0IyBjb25zb2xlLmxvZyBcInZhbHVlIHR5cGUgZm9yIFZhclJlZmVyZW5jZSB7QHZhbHVlfSB7QHZhbHVlLkBsb2N9IHtAdmFsdWU6Y29uc3RydWN0b3J9XCJcblxuXHRcdCMgc2hvdWxkIGJlIHBvc3NpYmxlIHRvIGhhdmUgYSBWYXJSZWZlcmVuY2Ugd2l0aG91dCBhIG5hbWUgYXMgd2VsbD8gZm9yIGEgc3lzdGVtLXZhcmlhYmxlXG5cdFx0IyBuYW1lIHNob3VsZCBub3Qgc2V0IHRoaXMgd2F5LlxuXHRcdCMgcCBcInZhcm5hbWUge3ZhbHVlfSB7dmFsdWU6Y29uc3RydWN0b3J9XCJcblx0XHR2YXIgbmFtZSA9IHZhbHVlLmNcblx0XHQjIHAgXCJ2aXNpdCB2YXJkZWNsIHtuYW1lfSB7dmFsdWV9XCJcblxuXHRcdCMgd2hhdCBhYm91dCBsb29raW5nIHVwPyAtIG9uIHJlZ2lzdGVyIHdlIHdhbnQgdG8gbWFya1xuXHRcdHZhciB2ID0gQHZhcmlhYmxlIHx8PSBzY29wZV9fLnJlZ2lzdGVyKG5hbWUsIHNlbGYsIHR5cGU6IEB0eXBlKVxuXHRcdCMgRklYTUUgLS0gc2hvdWxkIG5vdCBzaW1wbHkgb3ZlcnJpZGUgdGhlIGRlY2xhcmF0b3IgaGVyZSghKVxuXG5cdFx0aWYgIXYuZGVjbGFyYXRvclxuXHRcdFx0di5kZWNsYXJhdG9yID0gc2VsZlxuXG5cdFx0di5hZGRSZWZlcmVuY2UoQHZhbHVlKSBpZiBAdmFsdWUgIyBpcyB0aGlzIHRoZSBmaXJzdCByZWZlcmVuY2U/XG5cblx0XHQjIG9ubHkgbmVlZGVkIHdoZW4gYW5hbHl6aW5nP1xuXHRcdEB2YWx1ZS5AdmFsdWUuQHZhcmlhYmxlID0gdlxuXHRcdHNlbGZcblxuXHRkZWYgcmVmbnJcblx0XHR2YXJpYWJsZS5yZWZlcmVuY2VzLmluZGV4T2YodmFsdWUpXG5cblx0IyBjb252ZXJ0IHRoaXMgaW50byBhIGxpc3Qgb2YgcmVmZXJlbmNlc1xuXHRkZWYgYWRkRXhwcmVzc2lvbiBleHByXG5cblx0XHRWYXJCbG9jay5uZXcoW3NlbGZdKS5hZGRFeHByZXNzaW9uKGV4cHIpXG5cblxuIyBBU1NJR05cblxuZXhwb3J0IGNsYXNzIEFzc2lnbiA8IE9wXG5cblx0ZGVmIGluaXRpYWxpemUgbywgbCwgclxuXG5cdFx0IyB3b3JrYXJvdW5kIHVudGlsIHdlIGNvbXBsZXRlIHRyYW5zaXRpb24gZnJvbSBsdWEtc3R5bGUgYXNzaWdubWVudHNcblx0XHQjIHRvIGFsd2F5cyB1c2UgZXhwbGljaXQgdHVwbGVzIC0gdGhlbiB3ZSBjYW4gbW92ZSBhc3NpZ25tZW50cyBvdXQgZXRjXG5cdFx0IyB0aGlzIHdpbGwgbm90IGJlIG5lZWRlZCBhZnRlciB3ZSByZW1vdmUgc3VwcG9ydCBmb3IgdmFyIGEsYixjID0gMSwyLDNcblx0XHRpZiBsIGlzYSBWYXJSZWZlcmVuY2UgYW5kIGwudmFsdWUgaXNhIEFyclxuXHRcdFx0IyBjb252ZXJ0aW5nIGFsbCBub2RlcyB0byB2YXItcmVmZXJlbmNlcyA/XG5cdFx0XHQjIGRvIHdlIG5lZWQgdG8ga2VlcCBpdCBpbiBhIHZhcmJsb2NrIGF0IGFsbD9cblx0XHRcdHZhciB2YXJzID0gbC52YWx1ZS5ub2Rlcy5tYXAgZG8gfHZ8XG5cdFx0XHRcdCMgd2hhdCBhYm91dCBpbm5lciB0dXBsZXMgZXRjP1xuXHRcdFx0XHQjIGtlZXAgdGhlIHNwbGF0cyAtLSBjbHVtc3kgYnV0IHRydWVcblx0XHRcdFx0aWYgdiBpc2EgU3BsYXRcblx0XHRcdFx0XHQjIHAgXCJ2YWx1ZSBpcyBhIHNwbGF0ISFcIlxuXHRcdFx0XHRcdHYudmFsdWUgPSBWYXJSZWZlcmVuY2UubmV3KHYudmFsdWUsbC50eXBlKSB1bmxlc3Mgdi52YWx1ZSBpc2EgVmFyUmVmZXJlbmNlXG5cdFx0XHRcdGVsaWYgdiBpc2EgVmFyUmVmZXJlbmNlXG5cdFx0XHRcdFx0dHJ1ZVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0IyB3aGF0IGFib3V0IHJldGFpbmluZyBsb2NhdGlvbj9cblx0XHRcdFx0XHQjIHYgPSB2LnZhbHVlIGlmIHYgaXNhIFZhck9yQWNjZXNzXG5cdFx0XHRcdFx0diA9IFZhclJlZmVyZW5jZS5uZXcodixsLnR5cGUpXG5cblx0XHRcdFx0cmV0dXJuIHZcblx0XHRcdFx0XG5cdFx0XHRcdCMgdiBpc2EgVmFyUmVmZXJlbmNlID8gdiA6IFZhclJlZmVyZW5jZS5uZXcodilcblx0XHRcdHJldHVybiBUdXBsZUFzc2lnbi5uZXcobyxUdXBsZS5uZXcodmFycykscilcblxuXHRcdGlmIGwgaXNhIEFyclxuXHRcdFx0cmV0dXJuIFR1cGxlQXNzaWduLm5ldyhvLFR1cGxlLm5ldyhsLm5vZGVzKSxyKVxuXHRcdFx0IyBwIFwibGVmdCBpcyBhcnJheSBpbiBhc3NpZ24gLSBpbiBpbml0XCJcblxuXG5cdFx0IyBzZXQgZXhwcmVzc2lvbiB5ZXMsIG5vP1xuXHRcdEBleHByZXNzaW9uID0gbm9cblx0XHRAdHJhdmVyc2VkID0gbm9cblx0XHRAcGFyZW5zID0gbm9cblx0XHRAY2FjaGUgPSBudWxsXG5cdFx0QGludmVydCA9IG5vXG5cdFx0QG9wVG9rZW4gPSBvXG5cdFx0QG9wID0gbyBhbmQgby5AdmFsdWUgb3Igb1xuXHRcdEBsZWZ0ID0gbFxuXHRcdEByaWdodCA9IHJcblx0XHRyZXR1cm4gc2VsZlxuXG5cdGRlZiBpc0V4cHJlc3NhYmxlXG5cdFx0IXJpZ2h0IHx8IHJpZ2h0LmlzRXhwcmVzc2FibGVcblxuXHRkZWYgaXNVc2VkXG5cdFx0IyByZWFsbHk/XG5cdFx0IyBpZiB1cCBpcyBhIGJsb2NrIGluIGdlbmVyYWwgdGhpcyBzaG91bGQgbm90IGJlIHVzZWQgLS0gc2luY2UgaXQgc2hvdWxkIGFscmVhZHkgaGF2ZSByZWNlaXZlZCBpbXBsaWNpdCBzZWxmP1xuXHRcdGlmIHVwIGlzYSBCbG9jayAjICYmIHVwLmxhc3QgIT0gc2VsZlxuXHRcdFx0cmV0dXJuIG5vIFxuXHRcdHJldHVybiB5ZXNcblxuXHQjIEZJWE1FIG9wdGltaXplXG5cdGRlZiB2aXNpdFxuXHRcdHZhciBsID0gQGxlZnRcblx0XHR2YXIgciA9IEByaWdodFxuXG5cdFx0IyBXQVJOSU5HIC0gc2xpZ2h0bHkgdW5kZWZpbmVkXG5cdFx0IyBNQVJLIFRIRSBTVEFDS1xuXHRcdGwudHJhdmVyc2UgaWYgbFxuXG5cdFx0dmFyIGx2YXIgPSBsIGlzYSBWYXJSZWZlcmVuY2UgYW5kIGwudmFyaWFibGVcblxuXHRcdCMgaG93IGRvZXMgdGhpcyB3b3JrIHdpdGggY29uc3RhbnRzIHRoYXQgYXJlIHJlYWxseSB2YXIgcmVmZXJlbmNlcz9cblx0XHQjIHNob3VsZCB3b3JrIHdoZW4gdGhpbmdzIGFyZSBub3QgZGVzY3JpYmVkIGFzIHdlbGwgLSBidXQgdGhpcyBpcyBmb3IgdGVzdGluZ1xuXHRcdCMgYnV0IGlmIGl0IHJlZmVycyB0byBzb21ldGhpbmcgZWxzZSBcblx0XHRpZiAhbHZhciBhbmQgQGRlc2Ncblx0XHRcdCMgZW50aXRpZXMgc2hvdWxkIGJlIGFibGUgdG8gZXh0cmFjdCB0aGUgbmVlZGVkIGluZm8gaW5zdGVhZFxuXHRcdFx0Uk9PVC5lbnRpdGllcy5hZGQobC5uYW1lcGF0aCx7bmFtZXBhdGg6IGwubmFtZXBhdGgsIHR5cGU6IHIudHlwZU5hbWUsIGRlc2M6IEBkZXNjfSlcblxuXHRcdCMgdGhpcyBzaG91bGQgcHJvYmFibHkgYmUgZG9uZSBpbiBhIGRpZmZlcmVudCBtYW5uZXJcblx0XHRpZiBsdmFyIGFuZCBsdmFyLmRlY2xhcmF0b3IgPT0gbFxuXHRcdFx0bHZhci5AaW5pdGlhbGl6ZWQgPSBub1xuXHRcdFx0ci50cmF2ZXJzZSBpZiByXG5cdFx0XHRsdmFyLkBpbml0aWFsaXplZCA9IHllc1xuXG5cdFx0ZWxzZVxuXHRcdFx0ci50cmF2ZXJzZSBpZiByXG5cblx0XHRpZiBsIGlzYSBWYXJSZWZlcmVuY2Ugb3IgbC5AdmFyaWFibGVcblx0XHRcdGwuQHZhcmlhYmxlLmFzc2lnbmVkKHIsc2VsZilcblxuXHRcdHJldHVybiBzZWxmXG5cdFxuXHRkZWYgYyBvXG5cdFx0dW5sZXNzIHJpZ2h0LmlzRXhwcmVzc2FibGVcblx0XHRcdCMgcCBcIkFzc2lnbiNjIHJpZ2h0IGlzIG5vdCBleHByZXNzYWJsZSBcIlxuXHRcdFx0cmV0dXJuIHJpZ2h0LmNvbnN1bWUoc2VsZikuYyhvKVxuXHRcdCMgdGVzdGluZyB0aGlzXG5cdFx0cmV0dXJuIHN1cGVyKG8pXG5cblx0ZGVmIGpzIG9cblx0XHR1bmxlc3MgcmlnaHQuaXNFeHByZXNzYWJsZVxuXHRcdFx0cCBcIkFzc2lnbiNqcyByaWdodCBpcyBub3QgZXhwcmVzc2FibGUgXCJcblx0XHRcdCMgaGVyZSB0aGlzIHNob3VsZCBiZSBnbyBvdXQgb2YgdGhlIHN0YWNrKCEpXG5cdFx0XHQjIGl0IHNob3VsZCBhbHJlYWR5IGJlIGNvbnN1bWVkP1xuXHRcdFx0cmV0dXJuIHJpZ2h0LmNvbnN1bWUoc2VsZikuY1xuXG5cdFx0IyBwIFwiYXNzaWduIGxlZnQge2xlZnQ6Y29udHJzdHJ1fVwiXG5cdFx0dmFyIGwgPSBsZWZ0Lm5vZGVcblx0XHR2YXIgciA9IHJpZ2h0XG5cblx0XHQjIFdlIGFyZSBzZXR0aW5nIHNlbGYoISlcblx0XHQjIFRPRE8gZG9jdW1lbnQgZnVuY3Rpb25hbGl0eVxuXHRcdGlmIGwgaXNhIFNlbGZcblx0XHRcdHZhciBjdHggPSBzY29wZV9fLmNvbnRleHRcblx0XHRcdGwgPSBjdHgucmVmZXJlbmNlXG5cblxuXHRcdGlmIGwgaXNhIFByb3BlcnR5QWNjZXNzXG5cdFx0XHR2YXIgYXN0ID0gQ0FMTChPUCgnLicsbC5sZWZ0LGwucmlnaHQuc2V0dGVyKSxbcmlnaHRdKVxuXHRcdFx0YXN0LnJlY2VpdmVyID0gbC5yZWNlaXZlclxuXG5cdFx0XHRpZiBpc1VzZWRcblx0XHRcdFx0IyBwIFwiQXNzaWduIGlzIHVzZWQge3N0YWNrfVwiXG5cdFx0XHRcdCMgZG9udCBjYWNoZSBpdCBhZ2FpbiBpZiBpdCBpcyBhbHJlYWR5IGNhY2hlZCghKVxuXHRcdFx0XHRyaWdodC5jYWNoZShwb29sOiAndmFsJywgdXNlczogMSkgdW5sZXNzIHJpZ2h0LmNhY2hldmFyICMgXG5cdFx0XHRcdCMgdGhpcyBpcyBvbmx5IHdoZW4gdXNlZC4uIHNob3VsZCBiZSBtb3JlIGNsZXZlciBhYm91dCBpdFxuXHRcdFx0XHRhc3QgPSBQYXJlbnMubmV3KGJsa19fKFthc3QscmlnaHRdKSlcblxuXHRcdFx0IyBzaG91bGQgY2hlY2sgdGhlIHVwLXZhbHVlIG5vP1xuXHRcdFx0cmV0dXJuIGFzdC5jKGV4cHJlc3Npb246IHllcylcblxuXHRcdCMgaWYgbCBpc2EgVmFyUmVmZXJlbmNlXG5cdFx0IyBcdHAgXCJhc3NpZ24gdmFyLXJlZlwiXG5cdFx0IyBcdGwuQHZhcmlhYmxlLmFzc2lnbmVkKHIpXG5cblx0XHQjIEZJWE1FIC0tIGRvZXMgbm90IGFsd2F5cyBuZWVkIHRvIGJlIGFuIGV4cHJlc3Npb24/XG5cdFx0IyBwIFwidHlwZW9mIG9wIHtAb3BUb2tlbiBhbmQgQG9wVG9rZW46Y29uc3RydWN0b3J9XCJcblx0XHR2YXIgb3V0ID0gXCJ7bC5jfSB7bWFya19fKEBvcFRva2VuKX17b3B9IHtyaWdodC5jKGV4cHJlc3Npb246IHRydWUpfVwiXG5cblx0XHRyZXR1cm4gb3V0XG5cblx0IyBGSVhNRSBvcCBpcyBhIHRva2VuPyBfRklYX1xuXHQjIHRoaXMgKGFuZCBzaW1pbGFyIGNhc2VzKSBpcyBicm9rZW4gd2hlbiBjYWxsZWQgZnJvbVxuXHQjIGFub3RoZXIgcG9zaXRpb24gaW4gdGhlIHN0YWNrLCBzaW5jZSAndXAnIGlzIGR5bmFtaWNcblx0IyBzaG91bGQgbWF5YmUgZnJlZXplIHVwP1xuXHRkZWYgc2hvdWxkUGFyZW50aGVzaXplIHBhciA9IHVwXG5cdFx0QHBhcmVucyBvciBwYXIgaXNhIE9wICYmIHBhci5vcCAhPSAnPSdcblxuXHRkZWYgY29uc3VtZSBub2RlXG5cdFx0aWYgaXNFeHByZXNzYWJsZVxuXHRcdFx0Zm9yY2VFeHByZXNzaW9uXG5cdFx0XHRyZXR1cm4gc3VwZXIobm9kZSlcblxuXHRcdHZhciBhc3QgPSByaWdodC5jb25zdW1lKHNlbGYpXG5cdFx0cmV0dXJuIGFzdC5jb25zdW1lKG5vZGUpXG5cblx0IyBtb3JlIHdvcmthcm91bmQgZHVyaW5nIHRyYW5zaXRpb24gYXdheSBmcm9tIGEsYixjID0gMSwyLDMgc3R5bGUgYXNzaWduXG5cdGRlZiBhZGRFeHByZXNzaW9uIGV4cHJcblx0XHR2YXIgdHlwID0gRXhwcmVzc2lvbkJsb2NrXG5cdFx0aWYgQGxlZnQgYW5kIEBsZWZ0IGlzYSBWYXJSZWZlcmVuY2Vcblx0XHRcdHR5cCA9IFZhckJsb2NrXG5cdFx0IyBtaWdodCBiZSBiZXR0ZXIgdG8gbmVzdCB0aGlzIHVwIGFmdGVyIHBhcnNpbmcgaXMgZG9uZT9cblx0XHQjIHAgXCJBc3NpZ24uYWRkRXhwcmVzc2lvbiB7c2VsZn0gPC0ge2V4cHJ9XCJcblx0XHR2YXIgbm9kZSA9IHR5cC5uZXcoW3NlbGZdKVxuXHRcdHJldHVybiBub2RlLmFkZEV4cHJlc3Npb24oZXhwcilcblxuXG5leHBvcnQgY2xhc3MgUHVzaEFzc2lnbiA8IEFzc2lnblxuXG5cdGRlZiBqcyBvXG5cdFx0XCJ7bGVmdC5jfS5wdXNoKHtyaWdodC5jfSlcIlxuXG5cdGRlZiBjb25zdW1lIG5vZGVcblx0XHRyZXR1cm4gc2VsZlxuXG5cbmV4cG9ydCBjbGFzcyBDb25kaXRpb25hbEFzc2lnbiA8IEFzc2lnblxuXG5cdGRlZiBjb25zdW1lIG5vZGVcblx0XHRub3JtYWxpemUuY29uc3VtZShub2RlKVxuXG5cdGRlZiBub3JtYWxpemVcblx0XHR2YXIgbCA9IGxlZnQubm9kZVxuXHRcdHZhciBscyA9IGxcblxuXHRcdGlmIGwgaXNhIEFjY2Vzc1xuXHRcdFx0IyBwIFwiY29uZGl0aW9uYWwtYXNzaWduIHtsfSB7bC5sZWZ0fSB7bC5yaWdodH1cIlxuXHRcdFx0aWYgbC5sZWZ0XG5cdFx0XHRcdCMgcCBcImNhY2hlIGwubGVmdCB7bC5sZWZ0OmNvbnN0cnVjdG9yfcyLXCJcblx0XHRcdFx0bC5sZWZ0LmNhY2hlIFxuXHRcdFx0bHMgPSBsLmNsb25lKGwubGVmdCxsLnJpZ2h0KSAjIHRoaXMgc2hvdWxkIHN0aWxsIGJlIGNhY2hlZD9cblx0XHRcdGwuY2FjaGUgaWYgbCBpc2EgUHJvcGVydHlBY2Nlc3MgIyBjb3JyZWN0IG5vdywgdG8gYSBjZXJ0YWluIGRlZ3JlZVxuXHRcdFx0aWYgbCBpc2EgSW5kZXhBY2Nlc3Ncblx0XHRcdFx0IyBwIFwiY2FjaGUgdGhlIHJpZ2h0IHNpZGUgb2YgaW5kZXhBY2Nlc3MhISEge2wucmlnaHR9XCJcblx0XHRcdFx0bC5yaWdodC5jYWNoZSBcblxuXHRcdFx0IyB3ZSBzaG91bGQgb25seSBjYWNoZSB0aGUgdmFsdWUgaXRzZWxmIGlmIGl0IGlzIGR5bmFtaWM/XG5cdFx0XHQjIGwuY2FjaGUgIyBjYWNoZSB0aGUgdmFsdWUgYXMgd2VsbCAtLSB3ZSBjYW5ub3QgdXNlIHRoaXMgaW4gYXNzaWducyB0aGVtXG5cblx0XHQjIHNvbWUgb3BzIGFyZSBsZXNzIG1lc3N5XG5cdFx0IyBuZWVkIG9wIHRvIHN1cHBvcnQgY29uc3VtZSB0aGVuP1xuXHRcdHZhciBleHByID0gcmlnaHQuaXNFeHByZXNzYWJsZVxuXHRcdHZhciBhc3QgPSBudWxsXG5cdFx0IyBoZXJlIHdlIHNob3VsZCB1c2UgYXN0ID0gaWYgLi4uXG5cdFx0aWYgZXhwciAmJiBvcCA9PSAnfHw9J1xuXHRcdFx0YXN0ID0gT1AoJ3x8JyxsLCBPUCgnPScsbHMscmlnaHQpKVxuXHRcdGVsaWYgZXhwciAmJiBvcCA9PSAnJiY9J1xuXHRcdFx0YXN0ID0gT1AoJyYmJyxsLCBPUCgnPScsbHMscmlnaHQpKVxuXHRcdGVsc2Vcblx0XHRcdGFzdCA9IElGKGNvbmRpdGlvbiwgT1AoJz0nLGxzLHJpZ2h0KSwgbCkgIyBkbyB3ZSBuZWVkIGEgc2NvcGUgZm9yIHRoZXNlP1xuXHRcdFx0YXN0LnNjb3BlID0gbnVsbFxuXHRcdFx0IyBkcm9wIHRoZSBzY29wZVxuXHRcdFx0IyB0b3VjaCBzY29wZSAtLSBzaG91bGQgcHJvYmFibHkgdmlzaXQgdGhlIHdob2xlIHRoaW5nP1xuXHRcdFx0IyBhc3Quc2NvcGUudmlzaXRcblx0XHRhc3QudG9FeHByZXNzaW9uIGlmIGFzdC5pc0V4cHJlc3NhYmxlXG5cdFx0YXN0XG5cblxuXHRkZWYgY1xuXHRcdCMgV0FSTiB3aGF0IGlmIHdlIHJldHVybiB0aGUgc2FtZT9cblx0XHRub3JtYWxpemUuY1xuXG5cdGRlZiBjb25kaXRpb25cblxuXHRcdCMgdXNlIHN3aXRjaCBpbnN0ZWFkIHRvIGNhY2hlIG9wIGFjY2Vzc1xuXHRcdGlmIG9wID09ICc/PSdcblx0XHRcdE9QKCc9PScsbGVmdCxOVUxMKVxuXHRcdGVsaWYgb3AgPT0gJ3x8PSdcblx0XHRcdE9QKCchJyxsZWZ0KVxuXHRcdGVsaWYgb3AgPT0gJyYmPSdcblx0XHRcdGxlZnRcblx0XHRlbGlmIG9wID09ICchPz0nXG5cdFx0XHRPUCgnIT0nLGxlZnQsTlVMTClcblx0XHRlbHNlXG5cdFx0XHRsZWZ0XG5cdFx0XG5cdGRlZiBqcyBvXG5cdFx0IyBwIFwiQ29uZGl0aW9uYWxBc3NpZ24uanNcIi5yZWRcblx0XHR2YXIgYXN0ID0gSUYoY29uZGl0aW9uLCBPUCgnPScsbGVmdCxyaWdodCksIGxlZnQpXG5cdFx0YXN0LnNjb3BlID0gbnVsbCAjIG5vdCBzdXJlIGFib3V0IHRoaXNcblx0XHRhc3QudG9FeHByZXNzaW9uIGlmIGFzdC5pc0V4cHJlc3NhYmxlICMgZm9yY2VkIGV4cHJlc3Npb24gYWxyZWFkeVxuXHRcdHJldHVybiBhc3QuY1xuXG5leHBvcnQgY2xhc3MgQ29tcG91bmRBc3NpZ24gPCBBc3NpZ25cblxuXHQjIEZJWE1FIGNhbiB3ZSBtZXJnZSBjb25zdW1lIGFuZCBqcz9cblx0ZGVmIGNvbnN1bWUgbm9kZVxuXHRcdHJldHVybiBzdXBlciBpZiBpc0V4cHJlc3NhYmxlXG5cblx0XHR2YXIgYXN0ID0gbm9ybWFsaXplXG5cdFx0cmV0dXJuIGFzdC5jb25zdW1lKG5vZGUpIHVubGVzcyBhc3QgPT0gc2VsZlxuXG5cdFx0YXN0ID0gcmlnaHQuY29uc3VtZShzZWxmKVxuXHRcdHJldHVybiBhc3QuY29uc3VtZShub2RlKVxuXG5cdGRlZiBub3JtYWxpemVcblx0XHR2YXIgbG4gPSBsZWZ0Lm5vZGVcblx0XHQjIHdlIGRvbnQgbmVlZCB0byBjaGFuZ2UgdGhpcyBhdCBhbGxcblx0XHR1bmxlc3MgbG4gaXNhIFByb3BlcnR5QWNjZXNzXG5cdFx0XHRyZXR1cm4gc2VsZlxuXG5cdFx0aWYgbG4gaXNhIEFjY2Vzc1xuXHRcdFx0IyBsZWZ0IG1pZ2h0IGJlIHplcm8/IT8hXG5cdFx0XHRsbi5sZWZ0LmNhY2hlIGlmIGxuLmxlZnRcblx0XHQjIFRPRE8gRklYTUUgd2Ugd2FudCB0byBjYWNoZSB0aGUgY29udGV4dCBvZiB0aGUgYXNzaWdubWVudFxuXHRcdCMgcCBcIm5vcm1hbGl6ZSBjb21wb3VuZCBhc3NpZ24ge2xlZnR9XCJcblx0XHR2YXIgYXN0ID0gT1AoJz0nLGxlZnQsT1Aob3BbMF0sbGVmdCxyaWdodCkpXG5cdFx0YXN0LnRvRXhwcmVzc2lvbiBpZiBhc3QuaXNFeHByZXNzYWJsZVxuXG5cdFx0cmV0dXJuIGFzdFxuXHRcdFxuXHRkZWYgY1xuXHRcdHZhciBhc3QgPSBub3JtYWxpemVcblx0XHRyZXR1cm4gc3VwZXIgaWYgYXN0ID09IHNlbGZcblxuXHRcdCMgb3RoZXJ3aXNlIGl0IGlzIGltcG9ydGFudCB0aGF0IHdlIGFjdHVhbGx5IHJlcGxhY2UgdGhpcyBub2RlIGluIHRoZSBvdXRlciBibG9ja1xuXHRcdCMgd2hlbmV2ZXIgd2Ugbm9ybWFsaXplIGFuZCBvdmVycmlkZSBjIGl0IGlzIGltcG9ydGFudCB0aGF0IHdlIGNhbiBwYXNzIG9uIGNhY2hpbmdcblx0XHQjIGV0YyAtLSBvdGhlcndpc2UgdGhlcmUgV0lMTCBiZSBpc3N1ZXMuXG5cdFx0dmFyIHVwID0gU1RBQ0suY3VycmVudFxuXHRcdGlmIHVwIGlzYSBCbG9ja1xuXHRcdFx0IyBwIFwicGFyZW50IGlzIGJsb2NrLCBzaG91bGQgcmVwbGFjZSFcIlxuXHRcdFx0IyBhbiBhbHRlcm5hdGl2ZSB3b3VsZCBiZSB0byBqdXN0IHBhc3Ncblx0XHRcdHVwLnJlcGxhY2Uoc2VsZixhc3QpXG5cdFx0YXN0LmNcblxuXG5leHBvcnQgY2xhc3MgQXN5bmNBc3NpZ24gPCBBc3NpZ25cblxuXHQjIHRoaXMgd2lsbCB0cmFuc2Zvcm0gdGhlIHRyZWUgYnkgYSBkZWNlbnQgYW1vdW50LlxuXHQjIE5lZWQgdG8gYWRqdXN0IEJsb2NrIHRvIGFsbG93IHRoaXNcblxuXG5leHBvcnQgY2xhc3MgVHVwbGVBc3NpZ24gPCBBc3NpZ25cblxuXHRwcm9wIG9wXG5cdHByb3AgbGVmdFxuXHRwcm9wIHJpZ2h0XG5cdHByb3AgdHlwZVxuXG5cdGRlZiBpbml0aWFsaXplIGEsYixjXG5cdFx0QHRyYXZlcnNlZCA9IG5vXG5cdFx0QG9wID0gYVxuXHRcdEBsZWZ0ID0gYlxuXHRcdEByaWdodCA9IGNcblx0XHRAdGVtcG9yYXJ5ID0gW11cblxuXHRkZWYgaXNFeHByZXNzYWJsZVxuXHRcdHJpZ2h0LmlzRXhwcmVzc2FibGVcblxuXHRkZWYgYWRkRXhwcmVzc2lvbiBleHByXG5cdFx0aWYgcmlnaHQgaXNhIFR1cGxlXG5cdFx0XHRyaWdodC5wdXNoKGV4cHIpXG5cdFx0ZWxzZVxuXHRcdFx0IyBwIFwibWFraW5nIGNoaWxkIGJlY29tZSBhIHR1cGxlP1wiXG5cdFx0XHRzZWxmLnJpZ2h0ID0gVHVwbGUubmV3KFtyaWdodCxleHByXSlcblx0XHRcblx0XHRyZXR1cm4gc2VsZlxuXG5cdGRlZiB2aXNpdFxuXHRcdCMgaWYgdGhlIGZpcnN0IGxlZnQtdmFsdWUgaXMgYSB2YXItcmVmZXJlbmNlLCB0aGVuXG5cdFx0IyBhbGwgdGhlIHZhcmlhYmxlcyBzaG91bGQgYmUgZGVjbGFyZWQgYXMgdmFyaWFibGVzLlxuXHRcdCMgYnV0IGlmIHdlIGhhdmUgY29tcGxleCBpdGVtcyBpbiB0aGUgb3RoZXIgbGlzdCAtIGl0IGRvZXMgYmVjb21lIG11Y2ggaGFyZGVyXG5cblx0XHQjIGlmIHRoZSBmaXJzdCBpcyBhIHZhci1yZWZlcmVuY2UsIHRoZXkgc2hvdWxkIGFsbCBiZSghKSAuLiBvciBzcGxhdHM/XG5cdFx0IyB0aGlzIGlzIHJlYWxseSBhIGhhY2t5IHdhbyB0byBkbyBpdCB0aG91Z2hcblx0XHRpZiBsZWZ0LmZpcnN0Lm5vZGUgaXNhIFZhclJlZmVyZW5jZVxuXHRcdFx0c2VsZi50eXBlID0gJ3Zhcidcblx0XHRcdCMgc2hvdWxkIHBvc3NpYmx5IGFsbG93IHJlYWwgdmFycyBhcyB3ZWxsLCBubz9cblx0XHRcdEB2YXJzID0gbGVmdC5ub2Rlcy5maWx0ZXIofG58IG4gaXNhIFZhclJlZmVyZW5jZSlcblx0XHRcdCMgY29sbGVjdCB0aGUgdmFycyBmb3IgdHVwbGUgZm9yIGVhc3kgYWNjZXNzXG5cblx0XHRcdCMgTk9URSBjYW4gaW1wcm92ZS4uIHNob3VsZCByYXRoZXIgbWFrZSB0aGUgd2hvbGUgbGVmdCBiZSBhIFZhckJsb2NrIG9yIFR1cGxlVmFyQmxvY2tcblx0XHRcdCMgcCBcInR5cGUgaXMgdmFyIC0tIHNraXAgdGhlIHJlc3RcIlxuXG5cdFx0cmlnaHQudHJhdmVyc2Vcblx0XHRsZWZ0LnRyYXZlcnNlXG5cdFx0c2VsZlxuXG5cdGRlZiBqcyBvXG5cdFx0IyBvbmx5IGZvciBhY3R1YWwgaW5uZXIgZXhwcmVzc2lvbnMsIG90aGVyd2lzZSBjYWNoZSB0aGUgd2hvbGUgYXJyYXksIG5vP1xuXHRcdHVubGVzcyByaWdodC5pc0V4cHJlc3NhYmxlXG5cdFx0XHQjIHAgXCJUdXBsZUFzc2lnbi5jb25zdW1lISB7cmlnaHR9XCIuYmx1ZVxuXHRcdFxuXHRcdFx0cmV0dXJuIHJpZ2h0LmNvbnN1bWUoc2VsZikuY1xuXG5cdFx0IyBwIFwiVFVQTEUge3R5cGV9XCJcblxuXHRcdCMjIyBhLGIsYyA9IGFyZ3VtZW50cyAjIyNcblx0XHQjIC0gZGlyZWN0LiBubyBtYXR0ZXIgaWYgbHZhbHVlcyBhcmUgdmFyaWFibGVzIG9yIG5vdC4gTWFrZSBmYWtlIGFyZ3VtZW50cyB1cCB0byB0aGUgc2FtZSBjb3VudCBhcyB0dXBsZVxuXG5cdFx0IyMjIGEsKmIsYiA9IGFyZ3VtZW50cyAjIyNcblx0XHQjIE5lZWQgdG8gY29udmVydCBhcmd1bWVudHMgdG8gYW4gYXJyYXkuIElGIGFyZ3VtZW50cyBpcyBub3QgcmVmZXJlbmNlZCBhbnl3aGVyZSBlbHNlIGluIHNjb3BlLCBcblx0XHQjIHdlIGNhbiBkbyB0aGUgYXNzaWdubWVudCBkaXJlY3RseSB3aGlsZSByb2xsaW5nIHRocm91Z2ggYXJndW1lbnRzXG5cblx0XHQjIyMgYSxiID0gYixhICMjI1xuXHRcdCMgaWRlYWxseSB3ZSBvbmx5IG5lZWQgdG8gY2FjaGUgdGhlIGZpcnN0IHZhbHVlIChvciBuIC0gMSksIGFzc2lnbiBkaXJlY3RseSB3aGVuIHBvc3NpYmxlLlxuXG5cdFx0IyMjIGEsYixjID0gKG1ldGhvZCB8IGV4cHJlc3Npb24pICMjI1xuXHRcdCMgY29udmVydCByZXMgaW50byBhcnJheSwgYXNzaWduIGZyb20gYXJyYXkuIENhbiBjYWNoZSB0aGUgdmFyaWFibGUgd2hlbiBhc3NpZ25pbmcgZmlyc3QgdmFsdWVcblxuXHRcdCMgRmlyc3Qgd2UgbmVlZCB0byBmaW5kIG91dCB3aGV0aGVyIHdlIGFyZSByZXF1aXJlZCB0byBzdG9yZSB0aGUgcmVzdWx0IGluIGFuIGFycmF5IGJlZm9yZSBhc3NpZ25pbmdcblx0XHQjIElmIHRoaXMgbmVlZHMgdG8gYmUgYW4gZXhwcmVzc2lvbiAocmV0dXJucz8sIHdlIG5lZWQgdG8gZmFsbCBiYWNrIHRvIHRoZSBDUy13YSlcblxuXHRcdHZhciBhc3QgPSBCbG9jay5uZXcoW10pXG5cdFx0dmFyIGxmdCA9IHNlbGYubGVmdFxuXHRcdHZhciByZ3QgPSBzZWxmLnJpZ2h0XG5cdFx0dmFyIHR5cCA9IHNlbGYudHlwZVxuXHRcdHZhciB2aWEgPSBudWxsXG5cblx0XHR2YXIgbGkgICA9IDBcblx0XHR2YXIgcmkgICA9IGxmdC5jb3VudFxuXHRcdHZhciBsbGVuID0gcmlcblxuXG5cdFx0IyBpZiBAdmFyc1xuXHRcdCMgXHRwIFwidHVwbGUgaGFzIHtAdmFyczpsZW5ndGh9IHZhcnNcIlxuXG5cdFx0IyBpZiB3ZSBoYXZlIGEgc3BsYXQgb24gdGhlIGxlZnQgaXQgaXMgbXVjaCBtb3JlIGxpa2VseSB0aGF0IHdlIG5lZWQgdG8gc3RvcmUgcmlnaHRcblx0XHQjIGluIGEgdGVtcG9yYXJ5IGFycmF5LCBidXQgaWYgdGhlIHJpZ2h0IHNpZGUgaGFzIGEga25vd24gbGVuZ3RoLCBpdCBzaG91bGQgc3RpbGwgbm90IGJlIG5lZWRlZFxuXHRcdHZhciBsc3BsYXQgPSBsZnQuZmlsdGVyKHx2fCB2IGlzYSBTcGxhdCApWzBdXG5cblx0XHQjIGlmIHJpZ2h0IGlzIGFuIGFycmF5IHdpdGhvdXQgYW55IHNwbGF0cyAob3IgaW5uZXIgdHVwbGVzPyksIG5vcm1hbGl6ZSBpdCB0byB0dXBsZVxuXHRcdHJndCA9IFR1cGxlLm5ldyhyZ3Qubm9kZXMpIGlmIHJndCBpc2EgQXJyICYmICFyZ3Quc3BsYXRcblx0XHR2YXIgcmxlbiA9IHJndCBpc2EgVHVwbGUgPyByZ3QuY291bnQgOiBudWxsXG5cblx0XHQjIGlmIGFueSB2YWx1ZXMgYXJlIHN0YXRlbWVudHMgd2UgbmVlZCB0byBoYW5kbGUgdGhpcyBiZWZvcmUgY29udGludWluZ1xuXG5cdFx0IyMjIGEsYixjID0gMTAsMjAsYXJ5ICMjI1xuXHRcdCMgaWRlYWxseSB3ZSBvbmx5IG5lZWQgdG8gY2FjaGUgdGhlIGZpcnN0IHZhbHVlIChvciBuIC0gMSksIGFzc2lnbiBkaXJlY3RseSB3aGVuIHBvc3NpYmxlLlxuXHRcdCMgb25seSBpZiB0aGUgdmFyaWFibGVzIGFyZSBub3QgcHJlZGVmaW5lZCBvciBwcmVkZWNsYXJlZCBjYW4gYmUgd2UgY2VydGFpbiB0aGF0IHdlIGNhbiBkbyBpdCB3aXRob3V0IGNhY2hpbmdcblx0XHQjIGlmIHJsZW4gJiYgdHlwID09ICd2YXInICYmICFsc3BsYXRcblx0XHQjIFx0IyB0aGlzIGNhbiBiZSBkYW5nZXJvdXMgaW4gZWRnZWNhc2VzIHRoYXQgYXJlIHZlcnkgaGFyZCB0byBkZXRlY3Rcblx0XHQjIFx0IyBpZiBpdCBiZWNvbWVzIGFuIGlzc3VlLCBmYWxsIGJhY2sgdG8gc2ltcGxlciB2ZXJzaW9uc1xuXHRcdCMgXHQjIGRvZXMgbm90IGV2ZW4gbWF0dGVyIGlmIHRoZXJlIGlzIGEgc3BsYXQ/XG5cblx0XHQjIHNwZWNpYWwgY2FzZSBmb3IgYXJndW1lbnRzKCEpXG5cdFx0aWYgIWxzcGxhdCAmJiByZ3QgPT0gQVJHVU1FTlRTXG5cblx0XHRcdHZhciBwYXJzID0gc2NvcGVfXy5wYXJhbXNcblx0XHRcdCMgcCBcInNwZWNpYWwgY2FzZSB3aXRoIGFyZ3VtZW50cyB7cGFyc31cIlxuXHRcdFx0IyBmb3JjaW5nIHRoZSBhcmd1bWVudHMgdG8gYmUgbmFtZWRcblx0XHRcdCMgcCBcImdvdCBoZXJlPz8/IHtwYXJzfVwiXG5cdFx0XHRsZnQubWFwIGRvIHxsLGl8IGFzdC5wdXNoIE9QKCc9JyxsLm5vZGUscGFycy5hdChpLHllcykudmlzaXQudmFyaWFibGUpICMgcy5wYXJhbXMuYXQodmFsdWUgLSAxLHllcylcblxuXHRcdFxuXHRcdGVsaWYgcmxlblxuXHRcdFx0IyB3ZSBoYXZlIHNldmVyYWwgaXRlbXMgaW4gdGhlIHJpZ2h0IHBhcnQuIHdoYXQgYWJvdXQgc3BsYXRzIGhlcmU/XG5cblx0XHRcdCMgcHJlLWV2YWx1YXRlIHJ2YWx1ZXMgdGhhdCBtaWdodCBiZSByZWZlcmVuY2UgZnJvbSBvdGhlciBhc3NpZ25tZW50c1xuXHRcdFx0IyB3ZSBuZWVkIHRvIGNoZWNrIGlmIHRoZSByaWdodHNpZGUgdmFsdWVzIGhhcyBubyBzaWRlLWVmZmVjdHMuIENhdXNlIGlmXG5cdFx0XHQjIHRoZXkgZG9udCwgd2UgcmVhbGx5IGRvIG5vdCBuZWVkIHRlbXBvcmFyeSB2YXJpYWJsZXMuXG5cblx0XHRcdCMgc29tZSBvZiB0aGVzZSBvcHRpbWl6YXRpb25zIGFyZSBxdWl0ZSBwZXR0eSAtIG1ha2VzIHRoaW5ncyBtb3JlIGNvbXBsaWNhdGVkXG5cdFx0XHQjIGluIHRoZSBjb21waWxlciBvbmx5IHRvIGdldCBhcm91bmQgYWRkaW5nIGEgZmV3IHRlbXAtdmFyaWFibGVzIGhlcmUgYW5kIHRoZXJlXG5cblx0XHRcdCMgdmFyIGZpcnN0VW5zYWZlID0gMFxuXHRcdFx0IyBsZnQubWFwIGRvIHx2LGl8XG5cdFx0XHQjIFx0aWYgdiBpc2EgVmFyUmVmZXJlbmNlXG5cdFx0XHQjIFx0XHRwIFwibGVmdCBzaWRlIHtpfSB7dn0ge3YucmVmbnJ9XCJcblxuXHRcdFx0IyByZ3QubWFwIGRvIHx2LGl8XG5cdFx0XHQjIFx0aWYgdi5oYXNTaWRlRWZmZWN0c1xuXHRcdFx0IyBcdFx0IyByZXR1cm4gaWYgaSA9PSAwIG9yICF2Lmhhc1NpZGVFZmZlY3RzXG5cdFx0XHQjIFx0XHQjIHJldHVybiBpZiB2IGlzYSBOdW0gfHwgdiBpc2EgU3RyIHx8IGkgPT0gMFxuXHRcdFx0IyBcdFx0IyB3ZSBjb3VsZCBleHBsaWNpdGx5IGNyZWF0ZSBhIHRlbXBvcmFyeSB2YXJpYWJsZSBhbmQgYWRkaW5nIG5vZGVzIGZvciBhY2Nlc3NpbmcgZXRjXG5cdFx0XHQjIFx0XHQjIGJ1dCB0aGUgYnVpbHRpbiBjYWNoaW5nIHNob3VsZCByZWFsbHkgdGFrZSBjYXJlIG9mIHRoaXMgZm9yIHVzXG5cdFx0XHQjIFx0XHQjIHdlIG5lZWQgdG8gcmVhbGx5IGZvcmNlIHRoZSBjYWNoaW5nIHRob3VnaCAtLSBzaW5jZSB3ZSBuZWVkIGEgY29weSBvZiBpdCBldmVuIGlmIGl0IGlzIGEgbG9jYWxcblx0XHRcdCMgXHRcdCMgd2UgbmVlZCB0byBwcmVkZWNsYXJlIHRoZSB2YXJpYWJsZXMgYXQgdGhlIHRvcCBvZiBzY29wZSBpZiB0aGlzIGRvZXMgbm90IHRha2UgY2FyZSBvZiBpdFxuXHRcdFx0IyBcdFx0XG5cdFx0XHQjIFx0XHQjIHRoZXNlIGFyZSB0aGUgZGVjbGFyYXRpb25zIC0tIHdlIG5lZWQgdG8gYWRkIHRoZW0gc29tZXdoZXJlIHNtYXJ0XG5cdFx0XHQjIFx0XHRAdGVtcG9yYXJ5LnB1c2godikgIyBuZWVkIGEgZ2VuZXJhbGl6ZWQgd2F5IHRvIGRvIHRoaXMgdHlwZSBvZiB0aGluZ1xuXHRcdFx0IyBcdFx0YXN0LnB1c2godi5jYWNoZShmb3JjZTogeWVzLCB0eXBlOiAnc3dhcCcsIGRlY2xhcmVkOiB0eXAgPT0gJ3ZhcicpKVxuXHRcdFx0IyBcdFx0IyB0aGV5IGRvIG5lZWQgdG8gYmUgZGVjbGFyZWQsIG5vP1xuXG5cdFx0XHQjIG5vdyB3ZSBjYW4gZnJlZSB0aGUgY2FjaGVkIHZhcmlhYmxlc1xuXHRcdFx0IyBhc3QubWFwIGRvIHxufCBuLmRlY2FjaGVcblxuXHRcdFx0dmFyIHByZSA9IFtdXG5cdFx0XHR2YXIgcmVzdCA9IFtdXG5cblx0XHRcdHZhciBwYWlycyA9IGxmdC5tYXAgZG8gfGwsaXxcblx0XHRcdFx0dmFyIHYgPSBudWxsXG5cdFx0XHRcdCMgZGV0ZXJtaW5lIGlmIHRoaXMgbmVlZHMgdG8gYmUgcHJlY2FjaGVkP1xuXHRcdFx0XHQjIGlmIGwgaXNhIFZhclJlZmVyZW5jZVxuXHRcdFx0XHQjIFx0IyB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lIHRoZSB2YXJpYWJsZSBpcyByZWZlcmVuY2VkXG5cdFx0XHRcdCMgXHQjIHNob3VsZCBhbHNvIGNvdW50IGV2ZW4gaWYgaXQgaXMgcHJlZGVjbGFyZWQgYXQgdGhlIHRvcFxuXHRcdFx0XHQjIFx0aWYgbC5yZWZuciA9PSAwXG5cblx0XHRcdFx0aWYgbCA9PSBsc3BsYXRcblx0XHRcdFx0XHR2ID0gQXJnTGlzdC5uZXcoW10pXG5cdFx0XHRcdFx0dmFyIHRvID0gKHJsZW4gLSAocmkgLSBpKSlcblx0XHRcdFx0XHQjIHAgXCJhc3Npbmcgc3BsYXQgYXQgaW5kZXgge2l9IHRvIHNsaWNlIHtsaX0gLSB7dG99XCIuY3lhblxuXHRcdFx0XHRcdHYucHVzaChyZ3QuaW5kZXgobGkrKykpIHdoaWxlIGxpIDw9IHRvXG5cdFx0XHRcdFx0diA9IEFyci5uZXcodilcblx0XHRcdFx0XHQjIGFzdC5wdXNoIE9QKCc9JyxsLm5vZGUsQXJyLm5ldyh2KSlcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHYgPSByZ3QuaW5kZXgobGkrKylcblx0XHRcdFx0W2wubm9kZSx2XVxuXG5cdFx0XHRcdCMgaWYgbCBpc2EgVmFyUmVmZXJlbmNlICYmIGwucmVmbnIgXG5cdFx0XHR2YXIgY2xlYW4gPSB0cnVlXG5cdFx0XHRcblx0XHRcdHBhaXJzLm1hcCBkbyB8dixpfFxuXHRcdFx0XHR2YXIgbCA9IHZbMF1cblx0XHRcdFx0dmFyIHIgPSB2WzFdXG5cblx0XHRcdFx0aWYgY2xlYW5cblx0XHRcdFx0XHRpZiBsIGlzYSBWYXJSZWZlcmVuY2UgJiYgbC5yZWZuciA9PSAwXG5cdFx0XHRcdFx0XHQjIHN0aWxsIGNsZWFuXG5cdFx0XHRcdFx0XHRjbGVhbiA9IHllc1xuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdGNsZWFuID0gbm9cblx0XHRcdFx0XHRcdCMgcCBcIm5vdyBjYWNoZVwiXG5cdFx0XHRcdFx0XHRwYWlycy5zbGljZShpKS5tYXAgZG8gfHBhcnR8XG5cdFx0XHRcdFx0XHRcdGlmIHBhcnRbMV0uaGFzU2lkZUVmZmVjdHNcblx0XHRcdFx0XHRcdFx0XHRAdGVtcG9yYXJ5LnB1c2gocGFydFsxXSkgIyBuZWVkIGEgZ2VuZXJhbGl6ZWQgd2F5IHRvIGRvIHRoaXMgdHlwZSBvZiB0aGluZ1xuXHRcdFx0XHRcdFx0XHRcdGFzdC5wdXNoKHBhcnRbMV0uY2FjaGUoZm9yY2U6IHllcywgcG9vbDogJ3N3YXAnLCBkZWNsYXJlZDogdHlwID09ICd2YXInKSlcblx0XHRcdFx0XHRcdCMgcCBcImZyb20ge2l9IC0gY2FjaGUgYWxsIHJlbWFpbmluZyB3aXRoIHNpZGUtZWZmZWN0c1wiXG5cblx0XHRcdFx0IyBpZiB0aGUgcHJldmlvdXMgdmFsdWUgaW4gYXN0IGlzIGEgcmVmZXJlbmNlIHRvIG91ciB2YWx1ZSAtIHRoZSBjYWNoaW5nIHdhcyBub3QgbmVlZGVkXG5cdFx0XHRcdGlmIGFzdC5sYXN0ID09IHJcblx0XHRcdFx0XHRyLmRlY2FjaGVcblx0XHRcdFx0XHQjIHAgXCJ3YXMgY2FjaGVkIC0gbm90IG5lZWRlZFwiXG5cdFx0XHRcdFx0IyBzaW1wbGUgYXNzaWduXG5cdFx0XHRcdFx0YXN0LnJlcGxhY2UocixPUCgnPScsbCxyKSlcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdGFzdC5wdXNoIE9QKCc9JyxsLHIpXG5cblx0XHRcdCMgV0FSTiBGSVhNRSBJcyB0aGVyZSBub3QgYW4gaXNzdWUgd2l0aCBWYXJCbG9jayB2cyBub3QgaGVyZT9cblx0XHRlbHNlIFxuXHRcdFx0IyB0aGlzIGlzIHdoZXJlIHdlIG5lZWQgdG8gY2FjaGUgdGhlIHJpZ2h0IHNpZGUgYmVmb3JlIGFzc2lnbmluZ1xuXHRcdFx0IyBpZiB0aGUgcmlnaHQgc2lkZSBpcyBhIGZvciBsb29wLCB3ZSBDT1VMRCB0cnkgdG8gYmUgZXh0cmEgY2xldmVyLCBidXRcblx0XHRcdCMgZm9yIG5vdyBpdCBpcyBub3Qgd29ydGggdGhlIGFkZGVkIGNvbXBpbGVyIGNvbXBsZXhpdHlcblx0XHRcdFxuXHRcdFx0IyBpdGVyLmNhY2hlKGZvcmNlOiB5ZXMsIHR5cGU6ICdpdGVyJylcblx0XHRcdHZhciB0b3AgPSBWYXJCbG9jay5uZXdcblx0XHRcdHZhciBpdGVyID0gdXRpbC5pdGVyYWJsZShyZ3QsIHllcylcblx0XHRcdCMgY291bGQgc2V0IHRoZSB2YXJzIGluc2lkZSAtLSBtb3N0IGxpa2VseVxuXHRcdFx0YXN0LnB1c2godG9wKVxuXHRcdFx0dG9wLnB1c2goaXRlcilcblxuXHRcdFx0aWYgbHNwbGF0XG5cdFx0XHRcdHZhciBsZW4gPSB1dGlsLmxlbihpdGVyLCB5ZXMpXG5cdFx0XHRcdHZhciBpZHggPSB1dGlsLmNvdW50ZXIoMCwgeWVzKVxuXHRcdFx0XHQjIGNhY2hlIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5XG5cdFx0XHRcdHRvcC5wdXNoKGxlbikgIyBwcmVhc3NpZ24gdGhlIGxlbmd0aFxuXHRcdFx0XHQjIGNhY2hlIGNvdW50ZXIgdG8gbG9vcCB0aHJvdWdoXG5cdFx0XHRcdHRvcC5wdXNoKGlkeClcblxuXHRcdFx0IyBvbmx5IGlmIHRoZSBibG9jayBpcyB2YXJpYWJsZSBiYXNlZCwgbm8/XG5cdFx0XHQjIGFzdC5wdXNoKGJsayA9IFZhckJsb2NrLm5ldylcblx0XHRcdCMgYmxrID0gbnVsbFxuXHRcdFx0XG5cdFx0XHR2YXIgYmxrdHlwZSA9IHR5cCA9PSAndmFyJyA/IFZhckJsb2NrIDogQmxvY2tcblx0XHRcdHZhciBibGsgPSBibGt0eXBlLm5ldyhbXSlcblx0XHRcdCMgYmxrID0gdG9wIGlmIHR5cCA9PSAndmFyJ1xuXHRcdFx0YXN0LnB1c2goYmxrKVxuXG5cdFx0XHQjIGlmIHRoZSBsdmFscyBhcmUgbm90IHZhcmlhYmxlcyAtIHdlIG5lZWQgdG8gcHJlYXNzaWduXG5cdFx0XHQjIGNhbiBhbHNvIHVzZSBzbGljZSBoZXJlIGZvciBzaW1wbGljaXR5LCBidXQgdHJ5IHdpdGggd2hpbGUgbm93XHRcdFx0XG5cdFx0XHRsZnQubWFwIGRvIHxsLGl8XG5cdFx0XHRcdGlmIGwgPT0gbHNwbGF0XG5cdFx0XHRcdFx0dmFyIGx2YXIgPSBsLm5vZGVcblx0XHRcdFx0XHR2YXIgcmVtID0gbGxlbiAtIGkgLSAxICMgcmVtYWluaW5nIGFmdGVyIHNwbGF0XG5cblx0XHRcdFx0XHRpZiB0eXAgIT0gJ3Zhcidcblx0XHRcdFx0XHRcdHZhciBhcnIgPSB1dGlsLmFycmF5KE9QKCctJyxsZW4sIG51bV9fKGkgKyByZW0pICkseWVzKVxuXHRcdFx0XHRcdFx0dG9wLnB1c2goYXJyKVxuXHRcdFx0XHRcdFx0bHZhciA9IGFyci5jYWNoZXZhclxuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdGFzdC5wdXNoKGJsayA9IGJsa3R5cGUubmV3KSB1bmxlc3MgYmxrXG5cdFx0XHRcdFx0XHR2YXIgYXJyID0gdXRpbC5hcnJheSggT1AoJy0nLGxlbixudW1fXyhpICsgcmVtKSApIClcblx0XHRcdFx0XHRcdGJsay5wdXNoKE9QKCc9JyxsdmFyLGFycikpXG5cblx0XHRcdFx0XHQjIGlmICFsdmFyOnZhcmlhYmxlIHx8ICFsdmFyLnZhcmlhYmxlICMgbHZhciA9IFxuXHRcdFx0XHRcdCMgXHR0b3AucHVzaCgpXG5cdFx0XHRcdFx0I1x0cCBcImhhcyB2YXJpYWJsZSAtIG5vIG5lZWQgdG8gY3JlYXRlIGEgdGVtcFwiXG5cdFx0XHRcdFx0IyBibGsucHVzaChPUCgnPScsbHZhcixBcnIubmV3KFtdKSkpICMgZG9udCBwcmVjYWxjdWxhdGUgc2l6ZSBub3dcblx0XHRcdFx0XHQjIG1heCA9IHRvID0gKHJsZW4gLSAobGxlbiAtIGkpKVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdCBcblx0XHRcdFx0XHR2YXIgdGVzdCA9IHJlbSA/IE9QKCctJyxsZW4scmVtKSA6IGxlblxuXG5cdFx0XHRcdFx0dmFyIHNldCA9IE9QKCc9Jyxcblx0XHRcdFx0XHRcdE9QKCcuJyxsdmFyLE9QKCctJyxpZHgsbnVtX18oaSkpKSxcblx0XHRcdFx0XHRcdE9QKCcuJyxpdGVyLE9QKCcrKycsaWR4KSlcblx0XHRcdFx0XHQpXG5cblx0XHRcdFx0XHRhc3QucHVzaChXSElMRShPUCgnPCcsaWR4LHRlc3QpLCBzZXQpKVxuXG5cdFx0XHRcdFx0aWYgdHlwICE9ICd2YXInXG5cdFx0XHRcdFx0XHRhc3QucHVzaChibGsgPSBCbG9jay5uZXcpIFxuXHRcdFx0XHRcdFx0YmxrLnB1c2goT1AoJz0nLGwubm9kZSxsdmFyKSlcblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRibGsgPSBudWxsXG5cblx0XHRcdFx0XHQjIG5vdCBpZiBzcGxhdCB3YXMgbGFzdD9cblx0XHRcdFx0XHQjIGFzdC5wdXNoKGJsayA9IFZhckJsb2NrLm5ldylcblxuXHRcdFx0XHRlbGlmIGxzcGxhdFxuXHRcdFx0XHRcdGFzdC5wdXNoKGJsayA9IGJsa3R5cGUubmV3KSB1bmxlc3MgYmxrXG5cdFx0XHRcdFx0IyB3ZSBjb3VsZCBjYWNoZSB0aGUgcmF3IGNvZGUgb2YgdGhpcyBub2RlIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2Vcblx0XHRcdFx0XHRibGsucHVzaChPUCgnPScsbCxPUCgnLicsaXRlcixPUCgnKysnLGlkeCkpKSlcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdGFzdC5wdXNoKGJsayA9IGJsa3R5cGUubmV3KSB1bmxlc3MgYmxrXG5cdFx0XHRcdFx0YmxrLnB1c2goT1AoJz0nLGwsT1AoJy4nLGl0ZXIsbnVtX18oaSkgKSkpXG5cblx0XHQjIGlmIHdlIGFyZSBpbiBhbiBleHByZXNzaW9uIHdlIHJlYWxseSBuZWVkIHRvIFxuXHRcdGlmIG8uaXNFeHByZXNzaW9uIGFuZCBAdmFyc1xuXHRcdFx0IyBwIFwidHVwbGUgaXMgZXhwcmVzc2lvblwiICMgdmFyaWFibGVzIE1VU1QgYmUgYXV0b2RlY2xhcmVkIG91dHNpZGUgb2YgdGhlIGV4cHJlc3Npb25cblx0XHRcdGZvciB2IGluIEB2YXJzXG5cdFx0XHRcdHYudmFyaWFibGUuYXV0b2RlY2xhcmVcblxuXHRcdGVsaWYgQHZhcnNcblx0XHRcdGZvciB2IGluIEB2YXJzXG5cdFx0XHRcdCMgcCBcInByZWRlY2xhcmUgdmFyaWFibGUgYmVmb3JlIGNvbXBpbGF0aW9uXCJcblx0XHRcdFx0di52YXJpYWJsZS5wcmVkZWNsYXJlZFxuXG5cdFx0IyBpcyB0aGVyZSBhbnkgcmVhc29uIHRvIG1ha2UgaXQgaW50byBhbiBleHByZXNzaW9uP1xuXHRcdGlmIGFzdC5pc0V4cHJlc3NhYmxlICMgTk8hXG5cdFx0XHQjIHAgXCJleHByZXNzXCJcblx0XHRcdCMgaWYgdGhpcyBpcyBhbiBleHByZXNzaW9uXG5cdFx0XHR2YXIgb3V0ID0gYXN0LmMoZXhwcmVzc2lvbjogeWVzKVxuXHRcdFx0b3V0ID0gXCJ7dHlwfSB7b3V0fVwiIGlmIHR5cCBhbmQgIW8uaXNFeHByZXNzaW9uICMgbm90IGluIGV4cHJlc3Npb25cblx0XHRcdHJldHVybiBvdXRcblx0XHRlbHNlXG5cdFx0XHR2YXIgb3V0ID0gYXN0LmNcblx0XHRcdCMgaWYgdGhpcyBpcyBhIHZhcmJsb2NrIFxuXHRcdFx0cmV0dXJuIG91dFxuXG5cblx0ZGVmIGMgb1xuXHRcdHZhciBvdXQgPSBzdXBlcihvKVxuXHRcdCMgdGhpcyBpcyBvbmx5IHVzZWQgaW4gdHVwbGUgLS0gYmV0dGVyIHRvIGxldCB0aGUgdHVwbGUgaGF2IGEgc2VwYXJhdGUgI2Ncblx0XHRpZiBAdGVtcG9yYXJ5ICYmIEB0ZW1wb3Jhcnk6bGVuZ3RoXG5cdFx0XHRAdGVtcG9yYXJ5Lm1hcCBkbyB8dGVtcHwgdGVtcC5kZWNhY2hlXG5cdFx0cmV0dXJuIG91dFxuXG5cblxuIyBJREVOVElGSUVSU1xuXG4jIHJlYWxseSBuZWVkIHRvIGNsZWFuIHRoaXMgdXBcbiMgRHJvcCB0aGUgdG9rZW4/XG5leHBvcnQgY2xhc3MgSWRlbnRpZmllciA8IE5vZGVcblxuXHRwcm9wIHNhZmVjaGFpblxuXHRwcm9wIHZhbHVlXG5cblx0ZGVmIGluaXRpYWxpemUgdmFsdWVcblx0XHRAdmFsdWUgPSBsb2FkKHZhbHVlKVxuXHRcdEBzeW1ib2wgPSBudWxsXG5cdFx0QHNldHRlciA9IG51bGxcblxuXHRcdGlmIChcIlwiICsgdmFsdWUpLmluZGV4T2YoXCI/XCIpID49IDBcblx0XHRcdEBzYWZlY2hhaW4gPSB5ZXNcblx0XHQjIEBzYWZlY2hhaW4gPSAoXCJcIiArIHZhbHVlKS5pbmRleE9mKFwiP1wiKSA+PSAwXG5cdFx0c2VsZlxuXG5cdGRlZiByZWZlcmVuY2VzIHZhcmlhYmxlXG5cdFx0QHZhbHVlLkB2YXJpYWJsZSA9IHZhcmlhYmxlIGlmIEB2YWx1ZVxuXHRcdHNlbGZcblxuXHRkZWYgc291cmNlTWFwTWFya2VyXG5cdFx0QHZhbHVlLnNvdXJjZU1hcE1hcmtlclxuXG5cdGRlZiBsb2FkIHZcblx0XHRyZXR1cm4gKHYgaXNhIElkZW50aWZpZXIgPyB2LnZhbHVlIDogdilcblxuXHRkZWYgdHJhdmVyc2Vcblx0XHQjIE5PREVTLnB1c2goc2VsZilcblx0XHRzZWxmXG5cblx0ZGVmIHZpc2l0XG5cdFxuXHRcdGlmIEB2YWx1ZSBpc2EgTm9kZVxuXHRcdFx0IyBjb25zb2xlLmxvZyBcIklERU5USUZJRVIgVkFMVUUgSVMgTk9ERVwiXG5cdFx0XHRAdmFsdWUudHJhdmVyc2Vcblx0XHRzZWxmXG5cblx0ZGVmIHJlZ2lvblxuXHRcdFtAdmFsdWUuQGxvYyxAdmFsdWUuQGxvYyArIEB2YWx1ZS5AbGVuXVxuXG5cdGRlZiBpc1ZhbGlkSWRlbnRpZmllclxuXHRcdHllc1xuXHRcdFxuXHRkZWYgaXNSZXNlcnZlZFxuXHRcdEB2YWx1ZTpyZXNlcnZlZCBvciBSRVNFUlZFRF9URVNULnRlc3QoU3RyaW5nKEB2YWx1ZSkpXG5cblx0ZGVmIHN5bWJvbFxuXHRcdCMgY29uc29sZS5sb2cgXCJJZGVudGlmaWVyI3N5bWJvbCB7dmFsdWV9XCJcblx0XHRAc3ltYm9sIHx8PSBzeW1fXyh2YWx1ZSlcblxuXHRkZWYgc2V0dGVyXG5cdFx0IyBjb25zb2xlLmxvZyBcIklkZW50aWZpZXIjc2V0dGVyXCJcblx0XHRAc2V0dGVyIHx8PSBpZiB0cnVlXG5cdFx0XHR2YXIgdG9rID0gVG9rZW4ubmV3KCdJREVOVElGSUVSJyxzeW1fXygnc2V0LScgKyBAdmFsdWUpLEB2YWx1ZS5AbG9jIG9yIC0xKVxuXHRcdFx0SWRlbnRpZmllci5uZXcodG9rKVxuXHRcdFx0IyBJZGVudGlmaWVyLm5ldyhcInNldC17c3ltYm9sfVwiKVxuXG5cdGRlZiB0b1N0cmluZ1xuXHRcdFN0cmluZyhAdmFsdWUpXG5cblx0ZGVmIHRvSlNPTlxuXHRcdHRvU3RyaW5nXG5cblx0ZGVmIGFsaWFzXG5cdFx0c3ltX18oQHZhbHVlKVxuXG5cdGRlZiBqcyBvXG5cdFx0c3ltYm9sXG5cblx0ZGVmIGNcblx0XHRyZXR1cm4gJycgKyBzeW1ib2wgIyBtYXJrX18oQHZhbHVlKSArIFxuXG5cdGRlZiBkdW1wXG5cdFx0eyBsb2M6IHJlZ2lvbiB9XG5cblx0ZGVmIG5hbWVwYXRoXG5cdFx0dG9TdHJpbmdcblx0XHRcbmV4cG9ydCBjbGFzcyBUYWdJZCA8IElkZW50aWZpZXJcblxuXHRkZWYgaW5pdGlhbGl6ZSB2XG5cdFx0QHZhbHVlID0gdiBpc2EgSWRlbnRpZmllciA/IHYudmFsdWUgOiB2XG5cdFx0c2VsZlxuXG5cdGRlZiBjXG5cdFx0XCJpZCQoJ3t2YWx1ZS5jfScpXCJcblx0XHRcbiMgVGhpcyBpcyBub3QgYW4gaWRlbnRpZmllciAtIGl0IGlzIHJlYWxseSBhIHN0cmluZ1xuIyBJcyB0aGlzIG5vdCBhIGxpdGVyYWw/XG5cbiMgRklYTUUgUmVuYW1lIHRvIEl2YXJMaXRlcmFsPyBvciBzaW1wbHkgTGl0ZXJhbCB3aXRoIHR5cGUgSXZhclxuZXhwb3J0IGNsYXNzIEl2YXIgPCBJZGVudGlmaWVyXG5cblx0ZGVmIGluaXRpYWxpemUgdlxuXHRcdEB2YWx1ZSA9IHYgaXNhIElkZW50aWZpZXIgPyB2LnZhbHVlIDogdlxuXHRcdHNlbGZcblxuXHRkZWYgbmFtZVxuXHRcdGhlbHBlcnMuY2FtZWxDYXNlKEB2YWx1ZSkucmVwbGFjZSgvXkAvLCcnKVxuXHRcdCMgdmFsdWUuYy5jYW1lbENhc2UucmVwbGFjZSgvXkAvLCcnKVxuXG5cdGRlZiBhbGlhc1xuXHRcdCdfJyArIG5hbWVcblxuXHQjIHRoZSBAIHNob3VsZCBwb3NzaWJseSBiZSBnb25lIGZyb20gdGhlIHN0YXJ0P1xuXHRkZWYganMgb1xuXHRcdCdfJyArIG5hbWVcblxuXHRkZWYgY1xuXHRcdCdfJyArIGhlbHBlcnMuY2FtZWxDYXNlKEB2YWx1ZSkuc2xpY2UoMSkgIyAucmVwbGFjZSgvXkAvLCcnKSAjIG1hcmtfXyhAdmFsdWUpICsgXG5cblxuXG4jIEFtYmlndW91cyAtIFdlIG5lZWQgdG8gYmUgY29uc2lzdGVudCBhYm91dCBDb25zdCB2cyBDb25zdEFjY2Vzc1xuIyBCZWNvbWVzIG1vcmUgaW1wb3J0YW50IHdoZW4gd2UgaW1wbGVtZW50IHR5cGVpbmZlcmVuY2UgYW5kIGNvZGUtYW5hbHlzaXNcbmV4cG9ydCBjbGFzcyBDb25zdCA8IElkZW50aWZpZXJcblx0XHRcblx0ZGVmIHN5bWJvbFxuXHRcdCMgY29uc29sZS5sb2cgXCJJZGVudGlmaWVyI3N5bWJvbCB7dmFsdWV9XCJcblx0XHRAc3ltYm9sIHx8PSBzeW1fXyh2YWx1ZSlcblxuXHRkZWYganMgb1xuXHRcdHN5bWJvbFxuXG5cdGRlZiBjXG5cdFx0bWFya19fKEB2YWx1ZSkgKyBzeW1ib2xcblxuZXhwb3J0IGNsYXNzIFRhZ1R5cGVJZGVudGlmaWVyIDwgSWRlbnRpZmllclxuXG5cdHByb3AgbmFtZVxuXHRwcm9wIG5zXG5cblx0ZGVmIGluaXRpYWxpemUgdmFsdWVcblx0XHRAdmFsdWUgPSBsb2FkKHZhbHVlKVxuXHRcdHNlbGZcblxuXHRkZWYgbG9hZCB2YWxcblx0XHRAc3RyID0gKFwiXCIgKyB2YWwpXG5cdFx0dmFyIHBhcnRzID0gQHN0ci5zcGxpdChcIjpcIilcblx0XHRAcmF3ID0gdmFsXG5cdFx0QG5hbWUgPSBwYXJ0cy5wb3Bcblx0XHRAbnMgPSBwYXJ0cy5zaGlmdCAjIGlmIGFueT9cblx0XHRyZXR1cm4gQHN0clxuXG5cdGRlZiBqcyBvXG5cdFx0cmV0dXJuIFwiSW1iYS5UQUdTLntAc3RyLnJlcGxhY2UoXCI6XCIsXCIkXCIpfVwiXG5cblx0ZGVmIGNcblx0XHRqc1xuXG5cdGRlZiBmdW5jXG5cdFx0dmFyIG5hbWUgPSBAbmFtZS5yZXBsYWNlKC8tL2csJ18nKS5yZXBsYWNlKC9cXCMvLCcnKVxuXHRcdG5hbWUgKz0gXCIke0Bucy50b0xvd2VyQ2FzZX1cIiBpZiBAbnNcblx0XHRuYW1lXG5cblx0ZGVmIHNwYXduZXJcblx0XHRpZiBAbnNcblx0XHRcdFwie0Bucy50b1VwcGVyQ2FzZX0uJHtAbmFtZS5yZXBsYWNlKC8tL2csJ18nKX1cIlxuXHRcdGVsc2Vcblx0XHRcdFwiJHtAbmFtZS5yZXBsYWNlKC8tL2csJ18nKX1cIlxuXG5cdGRlZiBpZFxuXHRcdHZhciBtID0gQHN0ci5tYXRjaCgvXFwjKFtcXHdcXC1cXGRcXF9dKylcXGIvKVxuXHRcdG0gPyBtWzFdIDogbnVsbFxuXHRcdFxuXG5cdGRlZiBmbGFnXG5cdFx0XCJfXCIgKyBuYW1lLnJlcGxhY2UoLy0tL2csJ18nKS50b0xvd2VyQ2FzZVxuXG5cdGRlZiBzZWxcblx0XHRcIi57ZmxhZ31cIiAjICsgbmFtZS5yZXBsYWNlKC8tL2csJ18nKS50b0xvd2VyQ2FzZVxuXG5cdGRlZiBzdHJpbmdcblx0XHR2YWx1ZVxuXG5cbmV4cG9ydCBjbGFzcyBBcmd2YXIgPCBWYWx1ZU5vZGVcblxuXHRkZWYgY1xuXHRcdCMgTkVYVCAtLSBnbG9iYWwucGFyc2VJbnQgb3IgTnVtYmVyLnBhcnNlSW50IChiZXR0ZXIpXG5cdFx0dmFyIHYgPSBwYXJzZUludChTdHJpbmcodmFsdWUpKVxuXHRcdCMgRklYTUUgTm90IG5lZWRlZCBhbnltb3JlPyBJIHRoaW5rIHRoZSBsZXhlciBoYW5kbGVzIHRoaXNcblx0XHRyZXR1cm4gXCJhcmd1bWVudHNcIiBpZiB2ID09IDBcblxuXHRcdHZhciBzID0gc2NvcGVfX1xuXHRcdCMgcGFyYW1zIG5lZWQgdG8gZ28gdXAgdG8gdGhlIGNsb3Nlc3RlIG1ldGhvZC1zY29wZVxuXHRcdHZhciBwYXIgPSBzLnBhcmFtcy5hdCh2IC0gMSx5ZXMpXG5cdFx0XCJ7Y19fKHBhci5uYW1lKX1cIiAjIGNcblxuXG4jIENBTExcblxuZXhwb3J0IGNsYXNzIENhbGwgPCBOb2RlXG5cblx0cHJvcCBjYWxsZWVcblx0cHJvcCByZWNlaXZlclxuXHRwcm9wIGFyZ3Ncblx0cHJvcCBibG9ja1xuXG5cdGRlZiBpbml0aWFsaXplIGNhbGxlZSwgYXJncywgb3BleGlzdHNcblx0XHRAdHJhdmVyc2VkID0gbm9cblx0XHRAZXhwcmVzc2lvbiA9IG5vXG5cdFx0QHBhcmVucyA9IG5vXG5cdFx0QGNhY2hlID0gbnVsbFxuXHRcdEByZWNlaXZlciA9IG51bGxcblx0XHRAb3BleGlzdHMgPSBvcGV4aXN0c1xuXHRcdCMgc29tZSBheGlvbXMgdGhhdCBzaGFyZSB0aGUgc2FtZSBzeW50YXggYXMgY2FsbHMgd2lsbCBiZSByZWRpcmVjdGVkIGZyb20gaGVyZVxuXHRcdFxuXHRcdGlmIGNhbGxlZSBpc2EgVmFyT3JBY2Nlc3Ncblx0XHRcdHZhciBzdHIgPSBjYWxsZWUudmFsdWUuc3ltYm9sXG5cdFx0XHQjIHAgXCJDYWxsIGNhbGxlZSB7Y2FsbGVlfSAtIHtzdHJ9XCJcblx0XHRcdGlmIHN0ciA9PSAnZXh0ZXJuJ1xuXHRcdFx0XHQjIHAgXCJyZXR1cm5pbmcgZXh0ZXJuIGluc3RlYWQhXCJcblx0XHRcdFx0Y2FsbGVlLnZhbHVlLnZhbHVlLkB0eXBlID0gJ0VYVEVSTidcblx0XHRcdFx0cmV0dXJuIEV4dGVybkRlY2xhcmF0aW9uLm5ldyhhcmdzKVxuXHRcdFx0aWYgc3RyID09ICd0YWcnXG5cdFx0XHRcdCMgY29uc29sZS5sb2cgXCJFUlJPUiAtIGFjY2VzcyBhcmdzIGJ5IHNvbWUgbWV0aG9kXCJcblx0XHRcdFx0cmV0dXJuIFRhZ1dyYXBwZXIubmV3KGFyZ3MgYW5kIGFyZ3M6aW5kZXggPyBhcmdzLmluZGV4KDApIDogYXJnc1swXSlcblx0XHRcdGlmIHN0ciA9PSAnZXhwb3J0J1xuXHRcdFx0XHRyZXR1cm4gRXhwb3J0U3RhdGVtZW50Lm5ldyhhcmdzKVxuXG5cdFx0QGNhbGxlZSA9IGNhbGxlZVxuXHRcdEBhcmdzID0gYXJncyBvciBBcmdMaXN0Lm5ldyhbXSlcblxuXHRcdGlmIGFyZ3MgaXNhIEFycmF5XG5cdFx0XHRAYXJncyA9IEFyZ0xpc3QubmV3KGFyZ3MpXG5cdFx0XHQjIGNvbnNvbGUubG9nIFwiQVJHVU1FTlRTIElTIEFSUkFZIC0gZXJyb3Ige2FyZ3N9XCJcblx0XHQjIHAgXCJjYWxsIG9wZXhpc3RzIHtvcGV4aXN0c31cIlxuXHRcdHNlbGZcblxuXHRkZWYgdmlzaXRcblx0XHQjIGNvbnNvbGUubG9nIFwidmlzaXQgYXJncyB7YXJnc31cIlxuXHRcdGFyZ3MudHJhdmVyc2Vcblx0XHRjYWxsZWUudHJhdmVyc2VcblxuXHRcdCMgaWYgdGhlIGNhbGxlZSBpcyBhIFByb3BlcnR5QWNjZXNzIC0gYmV0dGVyIHRvIGltbWVkaWF0ZWx5IGNoYW5nZSBpdFxuXG5cdFx0QGJsb2NrICYmIEBibG9jay50cmF2ZXJzZSBcblxuXHRkZWYgYWRkQmxvY2sgYmxvY2tcblx0XHR2YXIgcG9zID0gQGFyZ3MuZmlsdGVyKHxuLGl8IG4gPT0gJyYnKVswXSAjIFdPVUxEIEJFIFRPS0VOIC0gQ0FSRUZVTFxuXHRcdHBvcyA/IGFyZ3MucmVwbGFjZShwb3MsYmxvY2spIDogYXJncy5wdXNoKGJsb2NrKVxuXHRcdHNlbGZcblxuXHRkZWYgcmVjZWl2ZXJcblx0XHRAcmVjZWl2ZXIgfHw9IChjYWxsZWUgaXNhIEFjY2VzcyAmJiBjYWxsZWUubGVmdCB8fCBOVUxMKVxuXG5cdCMgY2hlY2sgaWYgYWxsIGFyZ3VtZW50cyBhcmUgZXhwcmVzc2lvbnMgLSBvdGhlcndpc2Ugd2UgaGF2ZSBhbiBpc3N1ZVxuXG5cdGRlZiBzYWZlY2hhaW5cblx0XHRjYWxsZWUuc2FmZWNoYWluICMgcmVhbGx5P1xuXG5cdGRlZiBqcyBvXG5cdFx0dmFyIG9wdCA9IGV4cHJlc3Npb246IHllc1xuXHRcdHZhciByZWMgPSBudWxsXG5cdFx0IyB2YXIgYXJncyA9IGNvbXBhY3RfXyhhcmdzKSAjIHJlYWxseT9cblx0XHR2YXIgYXJncyA9IGFyZ3NcblxuXHRcdCMgZHJvcCB0aGlzP1xuXG5cdFx0dmFyIHNwbGF0ID0gYXJncy5zb21lIGRvIHx2fCB2IGlzYSBTcGxhdFxuXG5cdFx0dmFyIG91dCA9IG51bGxcblx0XHR2YXIgbGZ0ID0gbnVsbFxuXHRcdHZhciByZ3QgPSBudWxsXG5cdFx0dmFyIHdyYXAgPSBudWxsXG5cblx0XHR2YXIgY2FsbGVlID0gQGNhbGxlZSA9IEBjYWxsZWUubm9kZSAjIGRyb3AgdGhlIHZhciBvciBhY2Nlc3M/XG5cblx0XHQjIGlmIGNhbGxlZSBpc2EgQ2FsbCAmJiBjYWxsZWUuc2FmZWNoYWluXG5cdFx0I1x0eWVzXG5cblx0XHRpZiBjYWxsZWUgaXNhIEFjY2Vzc1xuXHRcdFx0bGZ0ID0gY2FsbGVlLmxlZnRcblx0XHRcdHJndCA9IGNhbGxlZS5yaWdodFxuXG5cdFx0aWYgY2FsbGVlIGlzYSBTdXBlciBvciBjYWxsZWUgaXNhIFN1cGVyQWNjZXNzXG5cdFx0XHRAcmVjZWl2ZXIgPSBzY29wZV9fLmNvbnRleHRcblx0XHRcdCMgcmV0dXJuIFwic3VwZXJjYWxsXCJcblxuXHRcdCMgbmV2ZXIgY2FsbCB0aGUgcHJvcGVydHktYWNjZXNzIGRpcmVjdGx5P1xuXHRcdGlmIGNhbGxlZSBpc2EgUHJvcGVydHlBY2Nlc3MgIyAmJiByZWMgPSBjYWxsZWUucmVjZWl2ZXJcblx0XHRcdCMgcCBcInVud3JhcHBpbmcgcHJvcGVydHktYWNjZXNzIGluIGNhbGxcIlxuXHRcdFx0QHJlY2VpdmVyID0gY2FsbGVlLnJlY2VpdmVyXG5cdFx0XHRjYWxsZWUgPSBAY2FsbGVlID0gQWNjZXNzLm5ldyhjYWxsZWUub3AsY2FsbGVlLmxlZnQsY2FsbGVlLnJpZ2h0KVxuXHRcdFx0IyBwIFwiZ290IGhlcmU/IHtjYWxsZWV9XCJcblx0XHRcdCMgY29uc29sZS5sb2cgXCJ1bndyYXBwaW5nIHRoZSBwcm9wZXJ0eUFjY2Vzc1wiXG5cblx0XHRpZiBjYWxsZWUuc2FmZWNoYWluXG5cdFx0XHQjIHAgXCJjYWxsZWUgaXMgc2FmZWNoYWluZWQ/IT9cIlxuXHRcdFx0IyBpZiBsZnQgaXNhIENhbGxcblx0XHRcdCMgaWYgbGZ0IGlzYSBDYWxsICMgY291bGQgYmUgYSBwcm9wZXJ0eSBhY2Nlc3MgYXMgd2VsbCAtIGl0IGlzIHRoZSBzYW1lP1xuXHRcdFx0IyBpZiBpdCBpcyBhIGxvY2FsIHZhciBhY2Nlc3Mgd2Ugc2ltcGx5IGNoZWNrIGlmIGl0IGlzIGEgZnVuY3Rpb24sIHRoZW4gY2FsbFxuXHRcdFx0IyBidXQgaXQgc2hvdWxkIGJlIHNhZmVjaGFpbmVkIG91dHNpZGUgYXMgd2VsbD9cblx0XHRcdCMgbGZ0LmNhY2hlIGlmIGxmdFxuXHRcdFx0IyB0aGUgb3V0ZXIgc2FmZWNoYWluIHNob3VsZCBub3QgY2FjaGUgdGhlIHdob2xlIGNhbGwgLSBvbmx5IGFzayB0byBjYWNoZVxuXHRcdFx0IyB0aGUgcmVzdWx0PyAtLSBjaGFpbiBvbnRvXG5cdFx0XHQjIHAgXCJDYWxsIHNhZmVjaGFpbiB7Y2FsbGVlfSB7bGZ0fS57cmd0fVwiXG5cdFx0XHR2YXIgaXNmbiA9IFV0aWwuSXNGdW5jdGlvbi5uZXcoW2NhbGxlZV0pXG5cdFx0XHR3cmFwID0gW1wie2lzZm4uY30gICYmICBcIixcIlwiXVxuXHRcdFx0Y2FsbGVlID0gT1AoJy4nLGNhbGxlZS5sZWZ0LGNhbGxlZS5yaWdodClcblx0XHRcdCMgY2FsbGVlIHNob3VsZCBhbHJlYWR5IGJlIGNhY2hlZCBub3cgLSBcblxuXHRcdCMgc2hvdWxkIGp1c3QgZm9yY2UgZXhwcmVzc2lvbiBmcm9tIHRoZSBzdGFydCwgbm8/XG5cdFx0aWYgc3BsYXRcblx0XHRcdCMgaW1wb3J0YW50IHRvIHdyYXAgdGhlIHNpbmdsZSB2YWx1ZSBpbiBhIHZhbHVlLCB0byBrZWVwIGltcGxpY2l0IGNhbGxcblx0XHRcdCMgdGhpcyBpcyBkdWUgdG8gdGhlIHdheSB3ZSBjaGVjayBmb3IgYW4gb3V0ZXIgQ2FsbCB3aXRob3V0IGNoZWNraW5nIGlmXG5cdFx0XHQjIHdlIGFyZSB0aGUgcmVjZWl2ZXIgKGluIFByb3BlcnR5QWNjZXNzKS4gU2hvdWxkIHJhdGhlciB3cmFwIGluIENhbGxBcmd1bWVudHNcblx0XHRcdGxldCByZWMgPSByZWNlaXZlclxuXHRcdFx0dmFyIGFyeSA9IChhcmdzLmNvdW50ID09IDEgPyBWYWx1ZU5vZGUubmV3KGFyZ3MuZmlyc3QudmFsdWUpIDogQXJyLm5ldyhhcmdzLmxpc3QpKVxuXG5cdFx0XHRyZWMuY2FjaGUgIyBuZWVkIHRvIGNhY2hlIHRoZSBjb250ZXh0IGFzIGl0IHdpbGwgYmUgcmVmZXJlbmNlZCBpbiBhcHBseVxuXHRcdFx0b3V0ID0gXCJ7Y2FsbGVlLmMoZXhwcmVzc2lvbjogeWVzKX0uYXBwbHkoe3JlYy5jfSx7YXJ5LmMoZXhwcmVzc2lvbjogeWVzKX0pXCJcblxuXHRcdGVsaWYgQHJlY2VpdmVyXG5cdFx0XHQjIHF1aWNrIHdvcmthcm91bmRcblx0XHRcdEByZWNlaXZlci5jYWNoZSB1bmxlc3MgQHJlY2VpdmVyIGlzYSBTY29wZUNvbnRleHRcblx0XHRcdGFyZ3MudW5zaGlmdChyZWNlaXZlcilcblx0XHRcdCMgc2hvdWxkIHJhdGhlciByZXdyaXRlIHRvIGEgbmV3IGNhbGw/XG5cdFx0XHRvdXQgPSBcIntjYWxsZWUuYyhleHByZXNzaW9uOiB5ZXMpfS5jYWxsKHthcmdzLmMoZXhwcmVzc2lvbjogeWVzKX0pXCJcblxuXHRcdGVsc2Vcblx0XHRcdG91dCA9IFwie2NhbGxlZS5jKGV4cHJlc3Npb246IHllcyl9KHthcmdzLmMoZXhwcmVzc2lvbjogeWVzKX0pXCJcblxuXHRcdGlmIHdyYXBcblx0XHRcdCMgd2Ugc2V0IHRoZSBjYWNoZXZhciBpbnNpZGVcblx0XHRcdCMgcCBcInNwZWNpYWwgY2FjaGluZyBmb3IgY2FsbFwiXG5cdFx0XHRpZiBAY2FjaGVcblx0XHRcdFx0QGNhY2hlOm1hbnVhbCA9IHllcyBcblx0XHRcdFx0b3V0ID0gXCIoe2NhY2hldmFyLmN9PXtvdXR9KVwiXG5cblx0XHRcdG91dCA9IFt3cmFwWzBdLG91dCx3cmFwWzFdXS5qb2luKFwiXCIpXG5cblx0XHRyZXR1cm4gb3V0XG5cblxuXG5cdFx0XG5leHBvcnQgY2xhc3MgSW1wbGljaXRDYWxsIDwgQ2FsbFxuXG5cdGRlZiBqcyBvXG5cdFx0XCJ7Y2FsbGVlLmN9KClcIlxuXG5leHBvcnQgY2xhc3MgTmV3IDwgQ2FsbFxuXG5cdGRlZiBqcyBvXG5cdFx0dmFyIHRhcmdldCA9IGNhbGxlZVxuXG5cdFx0d2hpbGUgdGFyZ2V0IGlzYSBBY2Nlc3Ncblx0XHRcdGxldCBsZWZ0ID0gdGFyZ2V0LmxlZnRcblxuXHRcdFx0aWYgKGxlZnQgaXNhIFByb3BlcnR5QWNjZXNzKSBvciAobGVmdCBpc2EgVmFyT3JBY2Nlc3MpXG5cdFx0XHRcdGNhbGxlZS5AcGFyZW5zID0geWVzXG5cdFx0XHRcdGJyZWFrXG5cblx0XHRcdHRhcmdldCA9IGxlZnRcblxuXHRcdHZhciBvdXQgPSBcIm5ldyB7Y2FsbGVlLmN9XCJcblx0XHRvdXQgKz0gJygpJyB1bmxlc3Mgby5wYXJlbnQgaXNhIENhbGxcblx0XHRvdXRcblxuZXhwb3J0IGNsYXNzIFN1cGVyQ2FsbCA8IENhbGxcblxuXHRkZWYganMgb1xuXHRcdHZhciBtID0gby5tZXRob2Rcblx0XHRzZWxmLnJlY2VpdmVyID0gU0VMRlxuXHRcdHNlbGYuY2FsbGVlID0gXCJ7bS50YXJnZXQuY30uc3VwZXIkLnByb3RvdHlwZS57bS5uYW1lLmN9XCJcblx0XHRzdXBlclxuXG5cblxuZXhwb3J0IGNsYXNzIEV4dGVybkRlY2xhcmF0aW9uIDwgTGlzdE5vZGVcblxuXHRkZWYgdmlzaXRcblxuXHRcdCMgcCBcInZpc2l0aW5nIGV4dGVybmRlY2xhcmF0aW9uXCJcblx0XHRub2RlcyA9IG1hcCBkbyB8aXRlbXwgaXRlbS5ub2RlICMgZHJvcCB2YXIgb3IgYWNjZXNzIHJlYWxseVxuXHRcdCMgb25seSBpbiBnbG9iYWwgc2NvcGU/XG5cdFx0dmFyIHJvb3QgPSBzY29wZV9fXG5cdFx0Zm9yIGl0ZW0gaW4gbm9kZXNcblx0XHRcdHZhciB2YXJpYWJsZSA9IHJvb3QucmVnaXN0ZXIgaXRlbS5zeW1ib2wsIGl0ZW0sIHR5cGU6ICdnbG9iYWwnXG5cdFx0XHR2YXJpYWJsZS5hZGRSZWZlcmVuY2UoaXRlbSlcblx0XHRzZWxmXG5cblx0ZGVmIGNcblx0XHRcIi8vIGV4dGVybnNcIlx0XHRcblx0XHRcblxuIyBGTE9XXG5cbmV4cG9ydCBjbGFzcyBDb250cm9sRmxvdyA8IE5vZGVcblxuXG5cbmV4cG9ydCBjbGFzcyBDb250cm9sRmxvd1N0YXRlbWVudCA8IENvbnRyb2xGbG93XG5cblx0ZGVmIGlzRXhwcmVzc2FibGVcblx0XHRub1xuXG5cblxuZXhwb3J0IGNsYXNzIElmIDwgQ29udHJvbEZsb3dcblxuXG5cdHByb3AgdGVzdFxuXHRwcm9wIGJvZHlcblx0cHJvcCBhbHRcblx0cHJvcCBzY29wZVxuXG5cdGRlZiBzZWxmLnRlcm5hcnkgY29uZCwgYm9keSwgYWx0XG5cdFx0IyBwcmVmZXIgdG8gY29tcGlsZSBpdCB0aGlzIHdheSBhcyB3ZWxsXG5cdFx0dmFyIG9iaiA9IElmLm5ldyhjb25kLCBCbG9jay5uZXcoW2JvZHldKSwgdHlwZTogJz8nKVxuXHRcdG9iai5hZGRFbHNlIEJsb2NrLm5ldyhbYWx0XSlcblx0XHRyZXR1cm4gb2JqXG5cblx0ZGVmIGFkZEVsc2UgYWRkXG5cdFx0IyBwIFwiYWRkIGVsc2UhXCIsYWRkXG5cdFx0aWYgYWx0ICYmIGFsdCBpc2EgSWZcblx0XHRcdCMgcCAnYWRkIHRvIHRoZSBpbm5lciBlbHNlKCEpJyxhZGRcblx0XHRcdGFsdC5hZGRFbHNlKGFkZClcblx0XHRlbHNlXG5cdFx0XHRzZWxmLmFsdCA9IGFkZFxuXHRcdHNlbGZcblxuXG5cdGRlZiBpbml0aWFsaXplIGNvbmQsIGJvZHksIG8gPSB7fVxuXHRcdHNldHVwXG5cdFx0QHRlc3QgPSBjb25kICMgKG86dHlwZSA9PSAndW5sZXNzJyA/IFVuYXJ5T3AubmV3KCchJyxjb25kLG51bGwpIDogY29uZClcblx0XHRAYm9keSA9IGJvZHlcblx0XHRAYWx0ICA9IG51bGxcblx0XHRAdHlwZSA9IG86dHlwZVxuXHRcdGludmVydCBpZiBAdHlwZSA9PSAndW5sZXNzJ1xuXHRcdEBzY29wZSA9IElmU2NvcGUubmV3KHNlbGYpXG5cdFx0c2VsZlxuXG5cdGRlZiBpbnZlcnRcblx0XHRpZiBAdGVzdCBpc2EgQ29tcGFyaXNvbk9wXG5cdFx0XHRAdGVzdCA9IEB0ZXN0LmludmVydFxuXHRcdGVsc2Vcblx0XHRcdEB0ZXN0ID0gVW5hcnlPcC5uZXcoJyEnLEB0ZXN0LG51bGwpXG5cblx0ZGVmIHZpc2l0XG5cdFx0dmFyIGFsdCA9IGFsdFxuXG5cdFx0QHNjb3BlLnZpc2l0IGlmIEBzY29wZVxuXHRcdHRlc3QudHJhdmVyc2UgaWYgdGVzdFxuXHRcdGJvZHkudHJhdmVyc2UgaWYgYm9keVxuXG5cdFx0IyBzaG91bGQgc2tpcCB0aGUgc2NvcGUgaW4gYWx0LlxuXHRcdGlmIGFsdFxuXHRcdFx0IyBwIFwic2NvcGluZyB7U1RBQ0suc2NvcGVzOmxlbmd0aH1cIlxuXHRcdFx0U1RBQ0sucG9wKHNlbGYpXG5cdFx0XHRhbHQuQHNjb3BlIHx8PSBCbG9ja1Njb3BlLm5ldyhhbHQpXG5cdFx0XHRhbHQudHJhdmVyc2Vcblx0XHRcdFNUQUNLLnB1c2goc2VsZilcblxuXHRcdCMgZm9yY2UgaXQgYXMgZXhwcmVzc2lvbj9cblx0XHR0b0V4cHJlc3Npb24gaWYgQHR5cGUgPT0gJz8nIGFuZCBpc0V4cHJlc3NhYmxlXG5cdFx0c2VsZlxuXG5cblx0ZGVmIGpzIG9cblx0XHR2YXIgYm9keSA9IGJvZHlcblx0XHQjIHdvdWxkIHBvc3NpYmx5IHdhbnQgdG8gbG9vayB1cCAvIG91dCBcblx0XHR2YXIgYnJhY2UgPSBicmFjZXM6IHllcywgaW5kZW50OiB5ZXNcblxuXHRcdHZhciBjb25kID0gdGVzdC5jKGV4cHJlc3Npb246IHllcykgIyB0aGUgY29uZGl0aW9uIGlzIGFsd2F5cyBhbiBleHByZXNzaW9uXG5cblx0XHRpZiBvLmlzRXhwcmVzc2lvblxuXHRcdFx0dmFyIGNvZGUgPSBib2R5LmMgIyAoYnJhY2VzOiB5ZXMpXG5cdFx0XHRjb2RlID0gJygnICsgY29kZSArICcpJyAjIGlmIGNvZGUuaW5kZXhPZignLCcpID49IDBcblx0XHRcdCMgaXMgZXhwcmVzc2lvbiFcblx0XHRcdGlmIGFsdFxuXHRcdFx0XHQjIGNvbnNvbGUubG9nIFwidHlwZSBvZiB0ZXJuYXJ5IHt0ZXN0fVwiXG5cdFx0XHRcdCMgYmUgc2FmZSAtIHdyYXAgY29uZGl0aW9uIGFzIHdlbGxcblx0XHRcdFx0IyBhc2sgZm9yIHBhcmVuc1xuXHRcdFx0XHRyZXR1cm4gXCJ7Y29uZH0gPyB7Y29kZX0gOiAoe2FsdC5jfSlcIlxuXHRcdFx0ZWxzZVxuXHRcdFx0XHQjIGFnYWluIC0gd2UgbmVlZCBhIGJldHRlciB3YXkgdG8gZGVjaWRlIHdoYXQgbmVlZHMgcGFyZW5zXG5cdFx0XHRcdCMgbWF5YmUgYmV0dGVyIGlmIHdlIHJld3JpdGUgdGhpcyB0byBhbiBPUCgnJiYnKSwgYW5kIHB1dFxuXHRcdFx0XHQjIHRoZSBwYXJlbnMgbG9naWMgdGhlcmVcblx0XHRcdFx0IyBjb25kIHNob3VsZCBwb3NzaWJseSBoYXZlIHBhcmVucyAtIGJ1dCB3aGVyZSBkbyB3ZSBkZWNpZGU/XG5cdFx0XHRcdGlmIEB0YWd0cmVlXG5cdFx0XHRcdFx0cmV0dXJuIFwiKHtjb25kfSkgPyB7Y29kZX0gOiB2b2lkKDApXCJcdFxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0cmV0dXJuIFwiKHtjb25kfSkgJiYge2NvZGV9XCJcblx0XHRlbHNlXG5cdFx0XHQjIGlmIHRoZXJlIGlzIG9ubHkgYSBzaW5nbGUgaXRlbSAtIGFuZCBpdCBpcyBhbiBleHByZXNzaW9uP1xuXHRcdFx0dmFyIGNvZGUgPSBudWxsXG5cdFx0XHQjIGlmIGJvZHkuY291bnQgPT0gMSAjIGRvbnQgaW5kZW50IGJ5IG91cnNlbHZlcz9cblxuXHRcdFx0aWYgYm9keSBpc2EgQmxvY2sgYW5kIGJvZHkuY291bnQgPT0gMSBhbmQgIShib2R5LmZpcnN0IGlzYSBMb29wRmxvd1N0YXRlbWVudClcblx0XHRcdFx0IyBwIFwiYm9keSB0byBib2R5IGZpcnN0IHtib2R5LmZpcnN0fVwiXG5cdFx0XHRcdGJvZHkgPSBib2R5LmZpcnN0XG5cblx0XHRcdCMgaWYgYm9keS5jb3VudCA9PSAxXG5cdFx0XHQjXHRwIFwib25lIGl0ZW0gb25seSFcIlxuXHRcdFx0I1x0Ym9keSA9IGJvZHkuZmlyc3RcblxuXHRcdFx0Y29kZSA9IGJvZHkuYyhicmFjZXM6IHllcykgIyAoYnJhY2VzOiB5ZXMpXG5cblx0XHRcdCMgZG9uJ3Qgd3JhcCBpZiBpdCBpcyBvbmx5IGEgc2luZ2xlIGV4cHJlc3Npb24/XG5cdFx0XHR2YXIgb3V0ID0gXCJ7bWFya19fKEB0eXBlKX1pZiAoe2NvbmR9KSBcIiArIGNvZGUgIyAnIHsnICsgY29kZSArICd9JyAjICd7JyArIGNvZGUgKyAnfSdcblx0XHRcdG91dCArPSBcIiBlbHNlIHthbHQuYyhhbHQgaXNhIElmID8ge30gOiBicmFjZSl9XCIgaWYgYWx0XG5cdFx0XHRvdXRcblxuXHRkZWYgc291cmNlTWFwTWFya2VyXG5cdFx0c2VsZlxuXG5cdGRlZiBjb25zdW1lIG5vZGVcblx0XHQjIHAgJ2Fzc2lnbmlmeSBpZj8hJ1xuXHRcdCMgaWYgaXQgaXMgcG9zc2libGUsIGNvbnZlcnQgaW50byBleHByZXNzaW9uXG5cdFx0aWYgbm9kZSBpc2EgVGFnVHJlZVxuXHRcdFx0QGJvZHkgPSBAYm9keS5jb25zdW1lKG5vZGUpXG5cdFx0XHRAYWx0ID0gQGFsdC5jb25zdW1lKG5vZGUpIGlmIEBhbHRcblx0XHRcdEB0YWd0cmVlID0gbm9kZVxuXHRcdFx0cmV0dXJuIHNlbGZcblxuXHRcdCMgc3BlY2lhbCBjYXNlIGZvciBJZiBjcmVhdGVkIGZyb20gY29uZGl0aW9uYWwgYXNzaWduIGFzIHdlbGw/XG5cdFx0IyBAdHlwZSA9PSAnPycgYW5kIFxuXHRcdCMgaWRlYWxseSB3ZSBkb250IHJlYWxseSB3YW50IHRvIG1ha2UgYW55IGV4cHJlc3Npb24gbGlrZSB0aGlzIGJ5IGRlZmF1bHRcblx0XHR2YXIgaXNSZXQgPSBub2RlIGlzYSBSZXR1cm5cblxuXHRcdCMgbWlnaHQgaGF2ZSBiZWVuIGZvcmNlZCB0byBleHByZXNzaW9uIGFscmVhZHlcblx0XHQjIGlmIGl0IHdhcyBvcmlnaW5hbGx5IGEgdGVybmFyeSAtIHdoeSBub3Rcblx0XHRpZiBAZXhwcmVzc2lvbiBvciAoKCFpc1JldCBvciBAdHlwZSA9PSAnPycpIGFuZCBpc0V4cHJlc3NhYmxlKVxuXHRcdFx0dG9FeHByZXNzaW9uICMgbWFyayBhcyBleHByZXNzaW9uKCEpIC0gaXMgdGhpcyBuZWVkZWQ/XG5cdFx0XHRyZXR1cm4gc3VwZXIobm9kZSlcblx0XHRlbHNlXG5cdFx0XHRAYm9keSA9IEBib2R5LmNvbnN1bWUobm9kZSlcblx0XHRcdEBhbHQgPSBAYWx0LmNvbnN1bWUobm9kZSkgaWYgQGFsdFxuXHRcdHNlbGZcblxuXG5cdGRlZiBpc0V4cHJlc3NhYmxlXG5cdFx0IyBwcm9jZXNzOnN0ZG91dC53cml0ZSAneCdcblx0XHR2YXIgZXhwID0gYm9keS5pc0V4cHJlc3NhYmxlICYmICghYWx0IHx8IGFsdC5pc0V4cHJlc3NhYmxlKVxuXHRcdHJldHVybiBleHBcblxuXG5cbmV4cG9ydCBjbGFzcyBMb29wIDwgU3RhdGVtZW50XG5cblxuXHRwcm9wIHNjb3BlXG5cdHByb3Agb3B0aW9uc1xuXHRwcm9wIGJvZHlcblx0cHJvcCBjYXRjaGVyXG5cblxuXHRkZWYgaW5pdGlhbGl6ZSBvcHRpb25zID0ge31cblx0XHRAdHJhdmVyc2VkID0gbm9cblx0XHRAb3B0aW9ucyA9IG9wdGlvbnNcblx0XHRAYm9keSA9IG51bGxcblx0XHRzZWxmXG5cblxuXHRkZWYgc2V0IG9ialxuXHRcdCMgcCBcImNvbmZpZ3VyZSBmb3IhXCJcblx0XHRAb3B0aW9ucyB8fD0ge31cblx0XHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iailcblx0XHRmb3IgayBpbiBrZXlzXG5cdFx0XHRAb3B0aW9uc1trXSA9IG9ialtrXVxuXHRcdHNlbGZcblxuXG5cdGRlZiBhZGRCb2R5IGJvZHlcblx0XHRzZWxmLmJvZHkgPSBibGtfXyhib2R5KVxuXHRcdHNlbGZcblxuXG5cdGRlZiBjIG9cblxuXHRcdHZhciBzID0gc3RhY2tcblx0XHR2YXIgY3VyciA9IHMuY3VycmVudFxuXHRcdCMgcCBcIkxvb3AuYyAtIHtpc0V4cHJlc3NhYmxlfSB7c3RhY2t9IHtzdGFjay5pc0V4cHJlc3Npb259XCJcblx0XHQjIHAgXCJzdGFjayBpcyBleHByZXNzaW9uPyB7b30ge2lzRXhwcmVzc2lvbn1cIlxuXG5cblxuXHRcdGlmIHN0YWNrLmlzRXhwcmVzc2lvbiBvciBpc0V4cHJlc3Npb25cblx0XHRcdCMgcCBcInRoZSBzdGFjayBpcyBhbiBleHByZXNzaW9uIGZvciBsb29wIG5vdyghKVwiXG5cdFx0XHQjIHdoYXQgdGhlIGlubmVyIG9uZSBzaG91bGQgbm90IGJlIGFuIGV4cHJlc3Npb24gdGhvdWdoP1xuXHRcdFx0IyB0aGlzIHdpbGwgcmVzdXQgaW4gYW4gaW5maW5pdGUgbG9vcCwgbm8/IT9cblx0XHRcdHZhciBhc3QgPSBDQUxMKEZOKFtdLFtzZWxmXSksW10pXG5cdFx0XHRyZXR1cm4gYXN0LmMgb1xuXHRcdFxuXHRcdGVsaWYgc3RhY2suY3VycmVudCBpc2EgQmxvY2sgb3IgKHMudXAgaXNhIEJsb2NrIGFuZCBzLmN1cnJlbnQuQGNvbnN1bWVyID09IHNlbGYpXG5cdFx0XG5cdFx0XHQjIHAgXCJ3aGF0IGlzIHRoZSBjdXJyZW50IHN0YWNrIG9mIGxvb3A/IHtzdGFjay5jdXJyZW50fVwiXG5cdFx0XHRzdXBlci5jIG9cblx0XHRlbHNlXG5cdFx0XHQjIHAgXCJTaG91bGQgbmV2ZXIgZ2V0IGhlcmU/IT9cIlxuXHRcdFx0dmFyIGFzdCA9IENBTEwoRk4oW10sW3NlbGZdKSxbXSlcblx0XHRcdHJldHVybiBhc3QuYyBvXG5cdFx0XHQjIG5lZWQgdG8gd3JhcCBpbiBmdW5jdGlvblxuXG5cblxuZXhwb3J0IGNsYXNzIFdoaWxlIDwgTG9vcFxuXG5cblx0cHJvcCB0ZXN0XG5cblxuXHRkZWYgaW5pdGlhbGl6ZSB0ZXN0LCBvcHRzXG5cdFx0QHRyYXZlcnNlZCA9IG5vXG5cdFx0QHRlc3QgPSB0ZXN0XG5cdFx0QG9wdGlvbnMgPSBvcHRzIG9yIHt9XG5cdFx0QHNjb3BlID0gV2hpbGVTY29wZS5uZXcoc2VsZilcblx0XHQjIHNldChvcHRzKSBpZiBvcHRzXG5cdFx0IyBwIFwiaW52ZXJ0IHRlc3QgZm9yIHdoaWxlPyB7QHRlc3R9XCJcblx0XHRpZiBvcHRpb24oOmludmVydClcblx0XHRcdCMgXCJpbnZlcnQgdGVzdCBmb3Igd2hpbGUge0B0ZXN0fVwiXG5cdFx0XHRAdGVzdCA9IHRlc3QuaW52ZXJ0IFxuXHRcdCMgaW52ZXJ0IHRoZSB0ZXN0XG5cblxuXHRkZWYgdmlzaXRcblx0XHRzY29wZS52aXNpdFxuXHRcdHRlc3QudHJhdmVyc2UgaWYgdGVzdFxuXHRcdGJvZHkudHJhdmVyc2UgaWYgYm9keVxuXG5cblx0IyBUT0RPIEJVRyAtLSB3aGVuIHdlIGRlY2xhcmUgYSB2YXIgbGlrZTogd2hpbGUgdmFyIHkgPSAuLi5cblx0IyB0aGUgdmFyaWFibGUgd2lsbCBiZSBkZWNsYXJlZCBpbiB0aGUgV2hpbGVTY29wZSB3aGljaCBuZXZlclxuXHQjIGZvcmNlLWRlY2xhcmVzIHRoZSBpbm5lciB2YXJpYWJsZXMgaW4gdGhlIHNjb3BlXG5cblx0ZGVmIGNvbnN1bWUgbm9kZVxuXHRcdCMgcCBcIldoaWxlLmNvbnN1bWUge25vZGV9XCIuY3lhblxuXHRcdCMgVGhpcyBpcyBuZXZlciBleHByZXNzYWJsZSwgYnV0IGF0IHNvbWUgcG9pbnRcblx0XHQjIHdlIG1pZ2h0IHdhbnQgdG8gd3JhcCBpdCBpbiBhIGZ1bmN0aW9uIChsaWtlIENTKVxuXHRcdHJldHVybiBzdXBlciBpZiBpc0V4cHJlc3NhYmxlXG5cblx0XHRpZiBub2RlIGlzYSBUYWdUcmVlXG5cdFx0XHQjIFdBUk4gdGhpcyBpcyBhIGhhY2sgdG8gYWxsb3cgcmVmZXJlbmNlcyBjb21pbmcgdGhyb3VnaCB0aGUgd3JhcHBpbmcgc2NvcGUgXG5cdFx0XHQjIHdpbGwgcmVzdWx0IGluIHVubmVlZGVkIHNlbGYtZGVjbGFyYXRpb25zIGFuZCBvdGhlciBvZGRpdGllc1xuXHRcdFx0c2NvcGUuY29udGV4dC5yZWZlcmVuY2Vcblx0XHRcdHJldHVybiBDQUxMKEZOKFtdLFtzZWxmXSksW10pXG5cblx0XHR2YXIgcmV1c2UgPSBub1xuXHRcdCMgV0FSTiBPcHRpbWl6YXRpb24gLSBtaWdodCBoYXZlIHVudGVuZGVkIHNpZGUtZWZmZWN0c1xuXHRcdCMgaWYgd2UgYXJlIGFzc2lnbmluZyBkaXJlY3RseSB0byBhIGxvY2FsIHZhcmlhYmxlLCB3ZSBzaW1wbHlcblx0XHQjIHVzZSBzYWlkIHZhcmlhYmxlIGZvciB0aGUgaW5uZXIgcmVzXG5cdFx0IyBpZiByZXVzZVxuXHRcdCMgXHRyZXN2YXIgPSBzY29wZS5kZWNsYXJlKG5vZGUubGVmdC5ub2RlLnZhcmlhYmxlLEFyci5uZXcoW10pLHByb3h5OiB5ZXMpXG5cdFx0IyBcdG5vZGUgPSBudWxsXG5cdFx0IyBcdHAgXCJjb25zdW1lIHZhcmlhYmxlIGRlY2xhcmF0b3IhP1wiLmN5YW5cblx0XHQjIGVsc2Vcblx0XHQjIGRlY2xhcmUgdGhlIHZhcmlhYmxlIHdlIHdpbGwgdXNlIHRvIHNvYWsgdXAgcmVzdWx0c1xuXHRcdCMgcCBcIkNyZWF0aW5nIHZhbHVlIHRvIHN0b3JlIHRoZSByZXN1bHQgb2YgbG9vcFwiLmN5YW5cblx0XHQjIFRPRE8gVXNlIGEgc3BlY2lhbCB2YXJ0eXBlIGZvciB0aGlzP1xuXHRcdHZhciByZXN2YXIgPSBzY29wZS5kZWNsYXJlKDpyZXMsQXJyLm5ldyhbXSksc3lzdGVtOiB5ZXMpXG5cdFx0IyBXSEFUIC0tIGZpeCB0aGlzIC0tXG5cdFx0QGNhdGNoZXIgPSBQdXNoQXNzaWduLm5ldyhcInB1c2hcIixyZXN2YXIsbnVsbCkgIyB0aGUgdmFsdWUgaXMgbm90IHByZXNldCAjIHdoYXRcblx0XHRib2R5LmNvbnN1bWUoQGNhdGNoZXIpICMgc2hvdWxkIHN0aWxsIHJldHVybiB0aGUgc2FtZSBib2R5XG5cblx0XHQjIHNjb3BlIHZhcnMgbXVzdCBub3QgYmUgY29tcGlsZWQgYmVmb3JlIHRoaXMgLS0gdGhpcyBpcyBpbXBvcnRhbnRcblx0XHR2YXIgYXN0ID0gQmxvY2submV3KFtzZWxmLHJlc3Zhci5hY2Nlc3Nvcl0pICMgc2hvdWxkIGJlIHZhcmFjY2VzcyBpbnN0ZWFkP1xuXHRcdGFzdC5jb25zdW1lKG5vZGUpXG5cdFx0IyBOT1RFIEhlcmUgd2UgY2FuIGZpbmQgYSB3YXkgdG8ga25vdyB3aGV0ZXIgb3Igbm90IHdlIGV2ZW4gbmVlZCB0byBcblx0XHQjIHJldHVybiB0aGUgcmVzdmFyLiBPZnRlbiBpdCB3aWxsIG5vdCBiZSBuZWVkZWRcblx0XHQjIEZJWE1FIHdoYXQgaGFwcGVucyBpZiB0aGVyZSBpcyBubyBub2RlPyE/XG5cblxuXHRkZWYganMgb1xuXHRcdHZhciBvdXQgPSBcIndoaWxlICh7dGVzdC5jKGV4cHJlc3Npb246IHllcyl9KVwiICsgYm9keS5jKGJyYWNlczogeWVzLCBpbmRlbnQ6IHllcykgIyAud3JhcFxuXG5cdFx0aWYgc2NvcGUudmFycy5jb3VudCA+IDBcblx0XHRcdCMgcCBcIndoaWxlLWJsb2NrIGhhcyBkZWNsYXJlZCB2YXJpYWJsZXMoISlcIlxuXHRcdFx0cmV0dXJuIFtzY29wZS52YXJzLmMsb3V0XVxuXHRcdG91dFxuXG5cblxuIyBUaGlzIHNob3VsZCBkZWZpbmUgYW4gb3BlbiBzY29wZVxuIyBzaG91bGQgcmF0aGVyIFxuZXhwb3J0IGNsYXNzIEZvciA8IExvb3BcblxuXG5cdGRlZiBpbml0aWFsaXplIG8gPSB7fVxuXHRcdEB0cmF2ZXJzZWQgPSBub1xuXHRcdEBvcHRpb25zID0gb1xuXHRcdEBzY29wZSA9IEZvclNjb3BlLm5ldyhzZWxmKVxuXHRcdEBjYXRjaGVyID0gbnVsbFxuXG5cdGRlZiB2aXNpdFxuXHRcdHNjb3BlLnZpc2l0XG5cdFx0b3B0aW9uc1s6c291cmNlXS50cmF2ZXJzZSAjIHdoYXQgYWJvdXQgYXdha2VuaW5nIHRoZSB2YXJzIGhlcmU/XG5cdFx0ZGVjbGFyZVxuXHRcdCMgc2hvdWxkIGJlIGFibGUgdG8gdG9nZ2xlIHdoZXRoZXIgdG8ga2VlcCB0aGUgcmVzdWx0cyBoZXJlIGFscmVhZHkoISlcblxuXHRcdCMgYWRkIGd1YXJkIHRvIGJvZHlcblx0XHRpZiBvcHRpb25zOmd1YXJkXG5cdFx0XHR2YXIgb3AgPSBJRihvcHRpb25zOmd1YXJkLmludmVydCxCbG9jay53cmFwKFtDb250aW51ZVN0YXRlbWVudC5uZXcoXCJjb250aW51ZVwiKV0pKVxuXHRcdFx0Ym9keS51bnNoaWZ0KG9wLEJSKVxuXG5cdFx0Ym9keS50cmF2ZXJzZVxuXHRcdFxuXHRkZWYgaXNCYXJlIHNyY1xuXHRcdHNyYyBhbmQgc3JjLkB2YXJpYWJsZSBhbmQgc3JjLkB2YXJpYWJsZS5AaXNBcnJheVxuXG5cdGRlZiBkZWNsYXJlXG5cdFx0dmFyIG8gPSBvcHRpb25zXG5cdFx0dmFyIHNjb3BlID0gc2NvcGVcblx0XHR2YXIgc3JjICA9IG86c291cmNlXG5cdFx0dmFyIHZhcnMgPSBvWzp2YXJzXSA9IHt9XG5cdFx0dmFyIG9pICAgPSBvOmluZGV4XG5cblx0XHR2YXIgYmFyZSA9IGlzQmFyZShzcmMpXG5cdFx0IyBwIFwic291cmNlIGlzIGEge3NyY30gLSB7YmFyZX1cIlxuXHRcdCMgdmFyIGkgPSB2YXJzOmluZGV4ID0gb2kgPyBzY29wZS5kZWNsYXJlKG9pLDApIDogdXRpbC5jb3VudGVyKDAseWVzKS5wcmVkZWNsYXJlXG5cblx0XHQjIHdoYXQgYWJvdXQgYSByYW5nZSB3aGVyZSB3ZSBhbHNvIGluY2x1ZGUgYW4gaW5kZXg/XG5cdFx0aWYgc3JjIGlzYSBSYW5nZVxuXHRcdFx0IyBwIFwicmFuZ2UgZm9yLWxvb3BcIlxuXG5cdFx0XHQjIHJlYWxseT8gZGVjbGFyZT8gXG5cdFx0XHQjIGFyZSB3ZSBzdXJlPyBfcmVhbGx5Xz9cblx0XHRcdHZhcnM6bGVuID0gc2NvcGUuZGVjbGFyZSgnbGVuJyxzcmMucmlnaHQpICMgdXRpbC5sZW4obyx5ZXMpLnByZWRlY2xhcmVcblx0XHRcdCMgbWFrZSB0aGUgc2NvcGUgYmUgdGhlIGRlY2xhcmF0b3Jcblx0XHRcdCMgVE9ETyB3b3VsZCBsaWtlIHRvIGJlIGFibGUgdG8gaGF2ZSBjb3VudGVyIGluIHJhbmdlIGFzIHdlbGxcblx0XHRcdHZhcnM6aW5kZXggPSBzY29wZS5yZWdpc3RlcihvOm5hbWUsc2NvcGUsdHlwZTogJ2xldCcsIGRlY2xhcmVkOiB5ZXMpXG5cdFx0XHQjIHAgXCJyZWdpc3RlcmVkIHt2YXJzOmluZGV4OmNvbnN0cnVjdG9yfVwiXG5cdFx0XHQjIHAgXCJpbmRleC12YXIgaXMgZGVjbGFyZW9kPyE/ISB7dmFyczppbmRleC5AZGVjbGFyZWR9XCJcblx0XHRcdHNjb3BlLnZhcnMucHVzaCh2YXJzOmluZGV4LmFzc2lnbm1lbnQoc3JjLmxlZnQpKVxuXHRcdFx0IyBzY29wZS5kZWNsYXJlKG9wdGlvbnM6bmFtZSxzcmMubGVmdClcblx0XHRcdHZhcnM6dmFsdWUgPSB2YXJzOmluZGV4XG5cdFx0ZWxzZVxuXHRcdFx0IyB2YXJzOnZhbHVlID0gc2NvcGUuZGVjbGFyZShvcHRpb25zOm5hbWUsbnVsbCxsZXQ6IHllcylcblx0XHRcdCMgd2UgYXJlIHVzaW5nIGF1dG9tYXRpYyBjYWNoaW5nIGZhciB0b28gbXVjaCBoZXJlXG5cblx0XHRcdCMgd2Ugc2hvdWxkIHNpbXBseSBjaGFuZ2UgaG93IGRlY2xhcmUgd29ya3Ncblx0XHRcdHZhciBpID0gdmFyczppbmRleCA9IG9pID8gc2NvcGUuZGVjbGFyZShvaSwwLHR5cGU6ICdsZXQnKSA6IHV0aWwuY291bnRlcigwLHllcyxzY29wZSkucHJlZGVjbGFyZVxuXG5cdFx0XHR2YXJzOnNvdXJjZSA9IGJhcmUgPyBzcmMgOiB1dGlsLml0ZXJhYmxlKHNyYyx5ZXMpLnByZWRlY2xhcmVcblx0XHRcdHZhcnM6bGVuICAgID0gdXRpbC5sZW4odmFyczpzb3VyY2UseWVzKS5wcmVkZWNsYXJlXG5cblx0XHRcdHZhcnM6dmFsdWUgPSBzY29wZS5kZWNsYXJlKG86bmFtZSxudWxsLHR5cGU6ICdsZXQnKVxuXHRcdFx0dmFyczp2YWx1ZS5hZGRSZWZlcmVuY2UobzpuYW1lKSAjIGFkZGluZyByZWZlcmVuY2UhXG5cdFx0XHRpLmFkZFJlZmVyZW5jZShvaSkgaWYgb2lcblxuXHRcdHJldHVybiBzZWxmXG5cblxuXHRkZWYgY29uc3VtZSBub2RlXG5cblx0XHRpZiBpc0V4cHJlc3NhYmxlXG5cdFx0XHRyZXR1cm4gc3VwZXIgXG5cblx0XHQjIG90aGVyIGNhc2VzIGFzIHdlbGwsIG5vP1xuXHRcdGlmIG5vZGUgaXNhIFRhZ1RyZWVcblx0XHRcdHNjb3BlLmNvbnRleHQucmVmZXJlbmNlXG5cdFx0XHR2YXIgcmVmID0gbm9kZS5yb290LnJlZmVyZW5jZVxuXHRcdFx0bm9kZS5AbG9vcCA9IHNlbGZcblxuXHRcdFx0IyBTaG91bGQgbm90IGJlIGNvbnN1bWVkIHRoZSBzYW1lIHdheVxuXHRcdFx0Ym9keS5jb25zdW1lKG5vZGUpXG5cdFx0XHRub2RlLkBsb29wID0gbnVsbFxuXHRcdFx0bGV0IGZuID0gTGFtYmRhLm5ldyhbUGFyYW0ubmV3KHJlZildLFtzZWxmXSlcblx0XHRcdGZuLnNjb3BlLndyYXAoc2NvcGUpXG5cdFx0XHQjIFRPRE8gU2NvcGUgb2YgZ2VuZXJhdGVkIGxhbWJkYSBzaG91bGQgYmUgYWRkZWQgaW50byBzdGFjayBmb3Jcblx0XHRcdCMgdmFyaWFibGUgbmFtaW5nIC8gcmVzb2x1dGlvblxuXHRcdFx0cmV0dXJuIENBTEwoZm4sW3JlZl0pXG5cblxuXHRcdGlmIEByZXN2YXJcblx0XHRcdCMgcCBcImFscmVhZHkgaGF2ZSBhIHJlc3ZhciAtLSBjaGFuZ2UgY29uc3VtZT8ge25vZGV9XCJcblx0XHRcdHZhciBhc3QgPSBCbG9jay5uZXcoW3NlbGYsQlIsQHJlc3Zhci5hY2Nlc3Nvcl0pXG5cdFx0XHRhc3QuY29uc3VtZShub2RlKVxuXHRcdFx0cmV0dXJuIGFzdFxuXHRcdFxuXHRcdCMgaWYgbm9kZSBpc2EgcmV0dXJuIC0tIGRvIHNvbWV0aGluZyBlbHNlXG5cblx0XHR2YXIgcmVzdmFyID0gbnVsbFxuXHRcdHZhciByZXVzZWFibGUgPSBubyAjIG5vZGUgaXNhIEFzc2lnbiAmJiBub2RlLmxlZnQubm9kZSBpc2EgTG9jYWxWYXJBY2Nlc3Ncblx0XHR2YXIgYXNzaWduZWUgPSBudWxsXG5cdFx0IyBtaWdodCBvbmx5IHdvcmsgZm9yIGxvY2Fscz9cblx0XHRpZiBub2RlIGlzYSBBc3NpZ25cblx0XHRcdCMgcCBcIm5vZGUgaXNhIGFzc2lnbiB7bm9kZX0ge25vZGUubGVmdH1cIlxuXHRcdFx0aWYgdmFyIHJlY2VpdmVyID0gbm9kZS5sZWZ0XG5cdFx0XHRcdGlmIGFzc2lnbmVlID0gcmVjZWl2ZXIuQHZhcmlhYmxlXG5cdFx0XHRcdFx0IyB3ZSBjYW4gb25seSBwdWxsIHRoZSB2YXIgcmVmZXJlbmNlIGludG8gdGhlIHNjb3BlXG5cdFx0XHRcdFx0IyBpZiB3ZSBrbm93IHRoYXQgdGhlIHZhcmlhYmxlIGlzIGRlY2xhcmVkIGluIHRoaXMgc2NvcGVcblx0XHRcdFx0XHRyZXVzZWFibGUgPSAocmVjZWl2ZXIgaXNhIFZhclJlZmVyZW5jZSlcblxuXHRcdCMgcCBcInJldXNhYmxlPyE/ISB7bm9kZX0ge25vZGV9XCJcblxuXHRcdCMgV0FSTiBPcHRpbWl6YXRpb24gLSBtaWdodCBoYXZlIHVudGVuZGVkIHNpZGUtZWZmZWN0c1xuXHRcdCMgaWYgd2UgYXJlIGFzc2lnbmluZyBkaXJlY3RseSB0byBhIGxvY2FsIHZhcmlhYmxlLCB3ZSBzaW1wbHlcblx0XHQjIHVzZSBzYWlkIHZhcmlhYmxlIGZvciB0aGUgaW5uZXIgcmVzXG5cdFx0aWYgcmV1c2VhYmxlIGFuZCBhc3NpZ25lZVxuXHRcdFx0IyBpbnN0ZWFkIG9mIGRlY2xhcmluZyBpdCBpbiB0aGUgc2NvcGUgLSB3aHkgbm90IGRlY2xhcmUgaXQgb3V0c2lkZT9cblx0XHRcdCMgaXQgbWlnaHQgYWxyZWFkeSBleGlzdCBpbiB0aGUgb3V0ZXIgc2NvcGUgbm8/XG5cdFx0XHQjIHAgXCJyZXVzZWFibGUge2Fzc2lnbmVlfSB7c2NvcGV9IHtzY29wZS5wYXJlbnQubG9va3VwKGFzc2lnbmVlKX1cIlxuXHRcdFx0IyBhc3NpZ25lZS5yZXNvbHZlXG5cdFx0XHQjIHNob3VsZCBwcm9iYWJseSBpbnN0ZWFkIGFsdGVyIHRoZSBhc3NpZ24tbm9kZSB0byBzZXQgdmFsdWUgdG8gYSBibGFuayBhcnJheVxuXHRcdFx0IyByZXN2YXIgPSBzY29wZS5wYXJlbnQuZGVjbGFyZShhc3NpZ25lZSxBcnIubmV3KFtdKSxwcm94eTogeWVzLHBvczogMClcblxuXHRcdFx0IyB0aGlzIHZhcmlhYmxlIHNob3VsZCByZWFsbHkgbm90IGJlIHJlZGVjbGFyZWQgaW5zaWRlIGhlcmUgYXQgYWxsXG5cdFx0XHRhc3NpZ25lZS5yZXNvbHZlXG5cdFx0XHQjIHJlc3ZhciA9IEByZXN2YXIgPSBzY29wZS5kZWNsYXJlKGFzc2lnbmVlLEFyci5uZXcoW10pLHByb3h5OiB5ZXMpXG5cblx0XHRcdCMgZG9udCBkZWNsYXJlIGl0IC0gc2ltcGx5IHB1c2ggYW4gYXNzaWduIGludG8gdGhlIHZhcmRlY2wgb2Ygc2NvcGVcblx0XHRcdHNjb3BlLnZhcnMudW5zaGlmdChPUCgnPScsYXNzaWduZWUsQXJyLm5ldyhbXSkpKVxuXHRcdFx0cmVzdmFyID0gQHJlc3ZhciA9IGFzc2lnbmVlXG5cblx0XHRcdG5vZGUuQGNvbnN1bWVyID0gc2VsZlxuXHRcdFx0bm9kZSA9IG51bGxcblxuXHRcdFx0IyBwIFwiY29uc3VtZSB2YXJpYWJsZSBkZWNsYXJhdG9yIT9cIi5jeWFuXG5cdFx0ZWxzZVxuXHRcdFx0IyBkZWNsYXJlIHRoZSB2YXJpYWJsZSB3ZSB3aWxsIHVzZSB0byBzb2FrIHVwIHJlc3VsdHNcblx0XHRcdCMgcCBcIkNyZWF0aW5nIHZhbHVlIHRvIHN0b3JlIHRoZSByZXN1bHQgb2YgbG9vcFwiLmN5YW5cblx0XHRcdCMgd2hhdCBhYm91dCBhIHBvb2wgaGVyZT9cblx0XHRcdHJlc3ZhciA9IEByZXN2YXIgPSBzY29wZS5kZWNsYXJlKDpyZXMsQXJyLm5ldyhbXSksc3lzdGVtOiB5ZXMpXG5cblx0XHRAY2F0Y2hlciA9IFB1c2hBc3NpZ24ubmV3KFwicHVzaFwiLHJlc3ZhcixudWxsKSAjIHRoZSB2YWx1ZSBpcyBub3QgcHJlc2V0XG5cdFx0Ym9keS5jb25zdW1lKEBjYXRjaGVyKSAjIHNob3VsZCBzdGlsbCByZXR1cm4gdGhlIHNhbWUgYm9keVxuXG5cblxuXHRcdGlmIG5vZGVcblx0XHRcdCMgcCBcInJldHVybmluZyBuZXcgYXN0IHdoZXJlIExvb3AgaXMgZmlyc3RcIlxuXHRcdFx0dmFyIGFzdCA9IEJsb2NrLm5ldyhbc2VsZixCUixyZXN2YXIuYWNjZXNzb3IuY29uc3VtZShub2RlKV0pXG5cdFx0XHRyZXR1cm4gYXN0XG5cdFx0IyB2YXIgYXN0ID0gQmxvY2submV3KFtzZWxmLEJSLHJlc3Zhci5hY2Nlc3Nvcl0pXG5cdFx0IyBhc3QuY29uc3VtZShub2RlKSBpZiBub2RlXG5cdFx0IyByZXR1cm4gYXN0XG5cdFx0IyBwIFwiTG9vcCBkaWQgY29uc3VtZSBzdWNjZXNzZnVsbHlcIlxuXHRcdHJldHVybiBzZWxmXG5cblx0XHQjIHRoaXMgaXMgbmV2ZXIgYW4gZXhwcmVzc2lvbiAoZm9yIG5vdyAtLSBidXQgc3RpbGwpXG5cdFx0IyByZXR1cm4gYXN0XG5cblxuXHRkZWYganMgb1xuXHRcdHZhciB2YXJzID0gb3B0aW9uczp2YXJzXG5cdFx0dmFyIGkgPSB2YXJzOmluZGV4XG5cdFx0dmFyIHZhbCA9IHZhcnM6dmFsdWVcblx0XHR2YXIgY29uZCA9IE9QKCc8JyxpLHZhcnM6bGVuKVxuXHRcdHZhciBzcmMgPSBvcHRpb25zOnNvdXJjZVxuXG5cdFx0IyBwIFwicmVmZXJlbmNlcyBmb3IgdmFsdWVcIix2YWwucmVmZXJlbmNlczpsZW5ndGhcblxuXHRcdHZhciBmaW5hbCA9IGlmIG9wdGlvbnM6c3RlcFxuXHRcdFx0T1AoJz0nLGksT1AoJysnLGksb3B0aW9uczpzdGVwKSlcblx0XHRlbHNlXG5cdFx0XHRPUCgnKysnLGkpXG5cblx0XHQjIGlmIHRoZXJlIGFyZSBmZXcgcmVmZXJlbmNlcyB0byB0aGUgdmFsdWUgLSB3ZSBjYW4gZHJvcFxuXHRcdCMgdGhlIGFjdHVhbCB2YXJpYWJsZSBhbmQgaW5zdGVhZCBtYWtlIGl0IHByb3h5IHRocm91Z2ggdGhlIGluZGV4XG5cdFx0aWYgc3JjIGlzYSBSYW5nZVxuXHRcdFx0Y29uZC5vcCA9ICc8PScgaWYgc3JjLmluY2x1c2l2ZVxuXHRcdFxuXHRcdGVsaWYgdmFsLnJlZmNvdW50IDwgMyBhbmQgdmFsLmFzc2lnbm1lbnRzOmxlbmd0aCA9PSAwXG5cdFx0XHQjIHAgXCJwcm94eSB0aGUgdmFsdWUge3ZhbC5hc3NpZ25tZW50czpsZW5ndGh9XCJcblx0XHRcdCMgcCBcInNob3VsZCBwcm94eSB2YWx1ZS12YXJpYWJsZSBpbnN0ZWFkXCJcblx0XHRcdHZhbC5wcm94eSh2YXJzOnNvdXJjZSxpKVxuXHRcdGVsc2Vcblx0XHRcdGJvZHkudW5zaGlmdChPUCgnPScsdmFsLE9QKCcuJyx2YXJzOnNvdXJjZSxpKSksIEJSKVxuXHRcdFx0IyBib2R5LnVuc2hpZnQoaGVhZClcblx0XHRcdCMgVE9ETyBjaGVjayBsZW5ndGhzIC0gaW50ZWxsaWdlbnRseSBkZWNpZGUgd2hldGhlciB0byBicmFjZSBhbmQgaW5kZW50XG5cdFx0dmFyIGhlYWQgPSBcInttYXJrX18ob3B0aW9uczprZXl3b3JkKX1mb3IgKHtzY29wZS52YXJzLmN9OyB7Y29uZC5jfTsge2ZpbmFsLmN9KSBcIlxuXHRcdGhlYWQgKyBib2R5LmMoYnJhY2VzOiB5ZXMsIGluZGVudDogeWVzKSAjIC53cmFwXG5cblxuXHRkZWYgaGVhZFxuXHRcdHZhciB2YXJzID0gb3B0aW9uczp2YXJzXG5cdFx0T1AoJz0nLHZhcnM6dmFsdWUsT1AoJy4nLHZhcnM6c291cmNlLHZhcnM6aW5kZXgpKVxuXG5cblxuZXhwb3J0IGNsYXNzIEZvckluIDwgRm9yXG5cblxuXHRcdFxuZXhwb3J0IGNsYXNzIEZvck9mIDwgRm9yXG5cblx0ZGVmIGRlY2xhcmVcblx0XHR2YXIgbyA9IG9wdGlvbnNcblx0XHR2YXIgdmFycyA9IG86dmFycyA9IHt9XG5cblx0XHQjIHNlZSBpZiBcblxuXHRcdCMgcCBcIkZvck9mIHNvdXJjZSBpc2Ege286c291cmNlfVwiXG5cblx0XHQjIGlmIG86c291cmNlIGlzIGEgdmFyaWFibGUgLS0gcmVmZXIgZGlyZWN0bHkgIyB2YXJpYWJsZT8gaXMgdGhpcyB0aGUgaXNzdWU/XG5cdFx0IyBwIHNjb3BlLkB2YXJtYXBbJ28nXSwgc2NvcGUucGFyZW50LkB2YXJtYXBbJ28nXVxuXG5cdFx0dmFyIHNyYyA9IHZhcnM6c291cmNlID0gbzpzb3VyY2UuQHZhcmlhYmxlIHx8IHNjb3BlLmRlY2xhcmUoJ28nLG86c291cmNlLCBzeXN0ZW06IHRydWUsIHR5cGU6ICdsZXQnKVxuXHRcdHZhciB2ID0gdmFyczp2YWx1ZSA9IHNjb3BlLmRlY2xhcmUobzppbmRleCxudWxsLGxldDogeWVzKSBpZiBvOmluZGV4XG5cblx0XHQjIHAgXCJGb3JPZiBvOmluZGV4IHtvOmluZGV4fSBvOm5hbWUge286bmFtZX1cIlxuXHRcdCMgaWYgbzppbmRleFxuXHRcdFxuXHRcdCMgcG9zc2libHkgcHJveHkgdGhlIGluZGV4LXZhcmlhYmxlP1xuXG5cdFx0aWYgbzpvd25cblx0XHRcdCMgdmFyIGkgPSB2YXJzOmluZGV4ID0gc2NvcGUuZGVjbGFyZSgnaScsMCxzeXN0ZW06IHRydWUsIHR5cGU6ICdsZXQnKSAjIG1hcmsgYXMgYSBjb3VudGVyP1xuXHRcdFx0dmFyIGkgPSB2YXJzOmluZGV4ID0gdXRpbC5jb3VudGVyKDAseWVzLHNjb3BlKS5wcmVkZWNsYXJlXG5cdFx0XHQjIHN5c3RlbXZhcmlhYmxlIC0tIHNob3VsZCBub3QgcmVhbGx5IGJlIGFkZGVkIHRvIHRoZSBtYXBcblx0XHRcdHZhciBrZXlzID0gdmFyczprZXlzID0gc2NvcGUuZGVjbGFyZSgna2V5cycsVXRpbC5rZXlzKHNyYy5hY2Nlc3Nvciksc3lzdGVtOiB5ZXMsIHR5cGU6ICdsZXQnKSAjIHRoZSBvdXRlciBvbmUgc2hvdWxkIHJlc29sdmUgZmlyc3Rcblx0XHRcdHZhciBsID0gdmFyczpsZW4gPSBzY29wZS5kZWNsYXJlKCdsJyxVdGlsLmxlbihrZXlzLmFjY2Vzc29yKSxzeXN0ZW06IHllcywgdHlwZTogJ2xldCcpXG5cdFx0XHR2YXIgayA9IHZhcnM6a2V5ID0gc2NvcGUucmVnaXN0ZXIobzpuYW1lLG86bmFtZSx0eXBlOiAnbGV0JykgIyBzY29wZS5kZWNsYXJlKG86bmFtZSxudWxsLHN5c3RlbTogeWVzKVxuXHRcdGVsc2Vcblx0XHRcdCMgd2Ugc2V0IHRoZSB2YXIgLS0gd2h5IGV2ZW4gZGVjbGFyZSBpdFxuXHRcdFx0IyBubyBuZWVkIHRvIGRlY2xhcmUgLS0gaXQgd2lsbCBkZWNsYXJlIGl0c2VsZiBpbiB0aGUgbG9vcCAtIG5vP1xuXHRcdFx0dmFyIGsgPSB2YXJzOmtleSA9IHNjb3BlLnJlZ2lzdGVyKG86bmFtZSxvOm5hbWUsdHlwZTogJ2xldCcpXG5cdFx0XG5cdFx0IyBUT0RPIHVzZSB1dGlsIC0gd2h5IGFkZCByZWZlcmVuY2VzIGFscmVhZHk/IEFoIC0tIHRoaXMgaXMgZm9yIHRoZSBoaWdobGlnaHRpbmdcblx0XHR2LmFkZFJlZmVyZW5jZShvOmluZGV4KSBpZiB2IGFuZCBvOmluZGV4XG5cdFx0ay5hZGRSZWZlcmVuY2UobzpuYW1lKSBpZiBrIGFuZCBvOm5hbWVcblxuXHRcdHNlbGZcblxuXHRkZWYganMgb1xuXHRcdHZhciB2YXJzID0gb3B0aW9uczp2YXJzXG5cblx0XHR2YXIgbyA9IHZhcnM6c291cmNlXG5cdFx0dmFyIGsgPSB2YXJzOmtleVxuXHRcdHZhciB2ID0gdmFyczp2YWx1ZVxuXHRcdHZhciBpID0gdmFyczppbmRleFxuXG5cblx0XHRpZiB2IFxuXHRcdFx0IyBzZXQgdmFsdWUgYXMgcHJveHkgb2Ygb2JqZWN0W2tleV1cblx0XHRcdCMgcG9zc2libHkgbWFrZSBpdCBhIHJlZj8gd2hhdCBpcyBoYXBwZW5pbmc/XG5cdFx0XHR2LnJlZmNvdW50IDwgMyA/IHYucHJveHkobyxrKSA6IGJvZHkudW5zaGlmdChPUCgnPScsdixPUCgnLicsbyxrKSkpXG5cblx0XHRpZiBvcHRpb25zOm93blxuXG5cdFx0XHRpZiBrLnJlZmNvdW50IDwgMyAjIHNob3VsZCBwcm9iYWJseSBhZGp1c3QgdGhlc2Vcblx0XHRcdFx0ay5wcm94eSh2YXJzOmtleXMsaSlcblx0XHRcdGVsc2Vcblx0XHRcdFx0Ym9keS51bnNoaWZ0KE9QKCc9JyxrLE9QKCcuJyx2YXJzOmtleXMsaSkpKVxuXG5cdFx0XHR2YXIgaGVhZCA9IFwie21hcmtfXyhvcHRpb25zOmtleXdvcmQpfWZvciAoe3Njb3BlLnZhcnMuY307IHtPUCgnPCcsaSx2YXJzOmxlbikuY307IHtPUCgnKysnLGkpLmN9KVwiXG5cdFx0XHRyZXR1cm4gaGVhZCArIGJvZHkuYyhpbmRlbnQ6IHllcywgYnJhY2VzOiB5ZXMpICMgLndyYXBcblxuXHRcdHZhciBjb2RlID0gYm9keS5jKGJyYWNlczogeWVzLCBpbmRlbnQ6IHllcylcblx0XHQjIGl0IGlzIHJlYWxseSBpbXBvcnRhbnQgdGhhdCB0aGlzIGlzIGEgdHJlYXRlZCBhcyBhIHN0YXRlbWVudFxuXHRcdHNjb3BlLnZhcnMuYyArIFwiO1xcbnttYXJrX18ob3B0aW9uczprZXl3b3JkKX1mb3IgKHZhciB7ay5jfSBpbiB7by5jfSlcIiArIGNvZGVcblxuXHRkZWYgaGVhZFxuXHRcdHZhciB2ID0gb3B0aW9uczp2YXJzXG5cblx0XHRbXG5cdFx0XHRPUCgnPScsdjprZXksT1AoJy4nLHY6a2V5cyx2OmluZGV4KSlcblx0XHRcdE9QKCc9Jyx2OnZhbHVlLE9QKCcuJyx2OnNvdXJjZSx2OmtleSkpIGlmIHY6dmFsdWVcblx0XHRdXG5cbiMgTk8gTkVFRD9cbmV4cG9ydCBjbGFzcyBCZWdpbiA8IEJsb2NrXG5cblxuXHRkZWYgaW5pdGlhbGl6ZSBib2R5XG5cdFx0QG5vZGVzID0gYmxrX18oYm9keSkubm9kZXNcblxuXG5cdGRlZiBzaG91bGRQYXJlbnRoZXNpemVcblx0XHRpc0V4cHJlc3Npb25cblxuXG5cbmV4cG9ydCBjbGFzcyBTd2l0Y2ggPCBDb250cm9sRmxvd1N0YXRlbWVudFxuXG5cblx0cHJvcCBzb3VyY2Vcblx0cHJvcCBjYXNlc1xuXHRwcm9wIGZhbGxiYWNrXG5cblxuXHRkZWYgaW5pdGlhbGl6ZSBhLGIsY1xuXHRcdEB0cmF2ZXJzZWQgPSBub1xuXHRcdEBzb3VyY2UgPSBhXG5cdFx0QGNhc2VzID0gYlxuXHRcdEBmYWxsYmFjayA9IGNcblxuXG5cdGRlZiB2aXNpdFxuXHRcdGMudHJhdmVyc2UgZm9yIGMgaW4gY2FzZXNcblx0XHRmYWxsYmFjay52aXNpdCBpZiBmYWxsYmFja1xuXHRcdHNvdXJjZS52aXNpdCBpZiBzb3VyY2Vcblx0XHRyZXR1cm5cblxuXG5cdGRlZiBjb25zdW1lIG5vZGVcblx0XHQjIFRPRE8gd29yayBpbnNpZGUgdGFncyAobGlrZSBsb29wcylcblx0XHRAY2FzZXMgPSBAY2FzZXMubWFwKHxpdGVtfCBpdGVtLmNvbnN1bWUobm9kZSkpXG5cdFx0QGZhbGxiYWNrID0gQGZhbGxiYWNrLmNvbnN1bWUobm9kZSkgaWYgQGZhbGxiYWNrXG5cdFx0c2VsZlxuXG5cdGRlZiBjIG9cblx0XHRpZiBzdGFjay5pc0V4cHJlc3Npb24gb3IgaXNFeHByZXNzaW9uXG5cdFx0XHR2YXIgYXN0ID0gQ0FMTChGTihbXSxbc2VsZl0pLFtdKVxuXHRcdFx0cmV0dXJuIGFzdC5jIG9cblxuXHRcdHN1cGVyLmMobylcblxuXG5cdGRlZiBqcyBvXG5cdFx0dmFyIGJvZHkgPSBbXVxuXG5cdFx0Zm9yIHBhcnQgaW4gY2FzZXNcblx0XHRcdHBhcnQuYXV0b2JyZWFrXG5cdFx0XHRib2R5LnB1c2gocGFydClcblxuXHRcdGlmIGZhbGxiYWNrXG5cdFx0XHRib2R5LnB1c2goXCJkZWZhdWx0OlxcblwiICsgZmFsbGJhY2suYyhpbmRlbnQ6IHllcykpXG5cblx0XHRcInN3aXRjaCAoe3NvdXJjZS5jfSkgXCIgKyBoZWxwZXJzLmJyYWNrZXRpemUoY2FyeV9fKGJvZHkpLmpvaW4oXCJcXG5cIikseWVzKVxuXG5cblxuZXhwb3J0IGNsYXNzIFN3aXRjaENhc2UgPCBDb250cm9sRmxvd1N0YXRlbWVudFxuXG5cblx0cHJvcCB0ZXN0XG5cdHByb3AgYm9keVxuXG5cblx0ZGVmIGluaXRpYWxpemUgdGVzdCwgYm9keVxuXHRcdEB0cmF2ZXJzZWQgPSBub1xuXHRcdEB0ZXN0ID0gdGVzdFxuXHRcdEBib2R5ID0gYmxrX18oYm9keSlcblxuXHRkZWYgdmlzaXRcblx0XHRib2R5LnRyYXZlcnNlXG5cblxuXHRkZWYgY29uc3VtZSBub2RlXG5cdFx0Ym9keS5jb25zdW1lKG5vZGUpXG5cdFx0c2VsZlxuXG5cblx0ZGVmIGF1dG9icmVha1xuXHRcdGJvZHkucHVzaChCcmVha1N0YXRlbWVudC5uZXcpIHVubGVzcyBib2R5Lmxhc3QgaXNhIEJyZWFrU3RhdGVtZW50XG5cdFx0c2VsZlxuXG5cblx0ZGVmIGpzIG9cblx0XHRAdGVzdCA9IFtAdGVzdF0gdW5sZXNzIEB0ZXN0IGlzYSBBcnJheSBcblx0XHR2YXIgY2FzZXMgPSBAdGVzdC5tYXAgZG8gfGl0ZW18IFwiY2FzZSB7aXRlbS5jfTpcIlxuXHRcdGNhc2VzLmpvaW4oXCJcXG5cIikgKyBib2R5LmMoaW5kZW50OiB5ZXMpICMgLmluZGVudFxuXG5cblxuZXhwb3J0IGNsYXNzIFRyeSA8IENvbnRyb2xGbG93U3RhdGVtZW50XG5cblxuXHRwcm9wIGJvZHlcblx0IyBwcm9wIG5jYXRjaFxuXHQjIHByb3AgbmZpbmFsbHlcblxuXHRkZWYgaW5pdGlhbGl6ZSBib2R5LCBjLCBmXG5cdFx0QHRyYXZlcnNlZCA9IG5vXG5cdFx0QGJvZHkgPSBibGtfXyhib2R5KVxuXHRcdEBjYXRjaCA9IGNcblx0XHRAZmluYWxseSA9IGZcblxuXG5cdGRlZiBjb25zdW1lIG5vZGVcblx0XHRAYm9keSA9IEBib2R5LmNvbnN1bWUobm9kZSlcblx0XHRAY2F0Y2ggPSBAY2F0Y2guY29uc3VtZShub2RlKSBpZiBAY2F0Y2hcblx0XHRAZmluYWxseSA9IEBmaW5hbGx5LmNvbnN1bWUobm9kZSkgaWYgQGZpbmFsbHlcblx0XHRzZWxmXG5cblxuXHRkZWYgdmlzaXRcblx0XHRAYm9keS50cmF2ZXJzZVxuXHRcdEBjYXRjaC50cmF2ZXJzZSBpZiBAY2F0Y2hcblx0XHRAZmluYWxseS50cmF2ZXJzZSBpZiBAZmluYWxseVxuXHRcdCMgbm8gYmxvY2tzIC0gYWRkIGFuIGVtcHR5IGNhdGNoXG5cblxuXHRkZWYganMgb1xuXHRcdHZhciBvdXQgPSBcInRyeSBcIiArIGJvZHkuYyhicmFjZXM6IHllcywgaW5kZW50OiB5ZXMpXG5cdFx0b3V0ICs9IFwiIFwiICsgQGNhdGNoLmMgaWYgQGNhdGNoXG5cdFx0b3V0ICs9IFwiIFwiICsgQGZpbmFsbHkuYyBpZiBAZmluYWxseVxuXG5cdFx0dW5sZXNzIEBjYXRjaCBvciBAZmluYWxseVxuXHRcdFx0b3V0ICs9IFwiIGNhdGNoIChlKSBcXHsgXFx9XCJcblx0XHRvdXQgKz0gXCI7XCJcblx0XHRvdXRcblxuXG5cbmV4cG9ydCBjbGFzcyBDYXRjaCA8IENvbnRyb2xGbG93U3RhdGVtZW50XG5cdFxuXHRwcm9wIGJvZHlcblxuXHRkZWYgaW5pdGlhbGl6ZSBib2R5LCB2YXJuYW1lXG5cdFx0QHRyYXZlcnNlZCA9IG5vXG5cdFx0QGJvZHkgPSBibGtfXyhib2R5IG9yIFtdKVxuXHRcdEBzY29wZSA9IENhdGNoU2NvcGUubmV3KHNlbGYpXG5cdFx0QHZhcm5hbWUgPSB2YXJuYW1lXG5cdFx0c2VsZlxuXG5cdGRlZiBjb25zdW1lIG5vZGVcblx0XHRAYm9keSA9IEBib2R5LmNvbnN1bWUobm9kZSlcblx0XHRzZWxmXG5cblxuXHRkZWYgdmlzaXRcblx0XHRAc2NvcGUudmlzaXRcblx0XHRAdmFyaWFibGUgPSBAc2NvcGUucmVnaXN0ZXIoQHZhcm5hbWUsc2VsZixwb29sOiAnY2F0Y2h2YXInKVxuXHRcdEBib2R5LnRyYXZlcnNlXG5cblxuXHRkZWYganMgb1xuXHRcdCMgb25seSBpbmRlbnQgaWYgaW5kZW50ZWQgYnkgZGVmYXVsdD9cblx0XHRcImNhdGNoICh7QHZhcmlhYmxlLmN9KSBcIiArIEBib2R5LmMoYnJhY2VzOiB5ZXMsIGluZGVudDogeWVzKVxuXG5cbiMgcmVwZWF0aW5nIG15c2VsZi4uIGRvbid0IGRlYWwgd2l0aCBpdCB1bnRpbCB3ZSBtb3ZlIHRvIGNvbXBhY3QgdHVwbGUtYXJnc1xuIyBmb3IgYWxsIGFzdG5vZGVzXG5cblxuZXhwb3J0IGNsYXNzIEZpbmFsbHkgPCBDb250cm9sRmxvd1N0YXRlbWVudFxuXG5cdGRlZiBpbml0aWFsaXplIGJvZHlcblx0XHRAdHJhdmVyc2VkID0gbm9cblx0XHRAYm9keSA9IGJsa19fKGJvZHkgb3IgW10pXG5cblxuXHRkZWYgdmlzaXRcblx0XHRAYm9keS50cmF2ZXJzZVxuXG5cblx0ZGVmIGNvbnN1bWUgbm9kZVxuXHRcdCMgc3dhbGxvdyBzaWxlbnRseVxuXHRcdHNlbGZcblxuXG5cdGRlZiBqcyBvXG5cdFx0XCJmaW5hbGx5IFwiICsgQGJvZHkuYyhicmFjZXM6IHllcywgaW5kZW50OiB5ZXMpXG5cblxuIyBSQU5HRVxuXG5leHBvcnQgY2xhc3MgUmFuZ2UgPCBPcFxuXG5cdGRlZiBpbmNsdXNpdmVcblx0XHRvcCA9PSAnLi4nXG5cdFx0XG5cdGRlZiBjXG5cdFx0XCJyYW5nZVwiXG5cblxuZXhwb3J0IGNsYXNzIFNwbGF0IDwgVmFsdWVOb2RlXG5cblx0ZGVmIGpzIG9cblx0XHR2YXIgcGFyID0gc3RhY2sucGFyZW50XG5cdFx0aWYgcGFyIGlzYSBBcmdMaXN0IG9yIHBhciBpc2EgQXJyXG5cdFx0XHRcIltdLnNsaWNlLmNhbGwoe3ZhbHVlLmN9KVwiXG5cdFx0ZWxzZVxuXHRcdFx0cCBcIndoYXQgaXMgdGhlIHBhcmVudD8ge3Bhcn1cIlxuXHRcdFx0XCJTUExBVFwiXG5cblx0ZGVmIG5vZGVcblx0XHR2YWx1ZVxuXG5cblxuXG5cbiMgVEFHU1xuXG5cblRBR19UWVBFUyA9IHt9XG5UQUdfQVRUUlMgPSB7fVxuXG5cblRBR19UWVBFUy5IVE1MID0gXCJhIGFiYnIgYWRkcmVzcyBhcmVhIGFydGljbGUgYXNpZGUgYXVkaW8gYiBiYXNlIGJkaSBiZG8gYmlnIGJsb2NrcXVvdGUgYm9keSBiciBcbmJ1dHRvbiBjYW52YXMgY2FwdGlvbiBjaXRlIGNvZGUgY29sIGNvbGdyb3VwIGRhdGEgZGF0YWxpc3QgZGQgZGVsIGRldGFpbHMgZGZuIFxuZGl2IGRsIGR0IGVtIGVtYmVkIGZpZWxkc2V0IGZpZ2NhcHRpb24gZmlndXJlIGZvb3RlciBmb3JtIGgxIGgyIGgzIGg0IGg1IGg2IFxuaGVhZCBoZWFkZXIgaHIgaHRtbCBpIGlmcmFtZSBpbWcgaW5wdXQgaW5zIGtiZCBrZXlnZW4gbGFiZWwgbGVnZW5kIGxpIGxpbmsgXG5tYWluIG1hcCBtYXJrIG1lbnUgbWVudWl0ZW0gbWV0YSBtZXRlciBuYXYgbm9zY3JpcHQgb2JqZWN0IG9sIG9wdGdyb3VwIG9wdGlvbiBcbm91dHB1dCBwIHBhcmFtIHByZSBwcm9ncmVzcyBxIHJwIHJ0IHJ1YnkgcyBzYW1wIHNjcmlwdCBzZWN0aW9uIHNlbGVjdCBzbWFsbCBcbnNvdXJjZSBzcGFuIHN0cm9uZyBzdHlsZSBzdWIgc3VtbWFyeSBzdXAgdGFibGUgdGJvZHkgdGQgdGV4dGFyZWEgdGZvb3QgdGggXG50aGVhZCB0aW1lIHRpdGxlIHRyIHRyYWNrIHUgdWwgdmFyIHZpZGVvIHdiclwiLnNwbGl0KFwiIFwiKVxuXG5UQUdfVFlQRVMuU1ZHID0gXCJjaXJjbGUgZGVmcyBlbGxpcHNlIGcgbGluZSBsaW5lYXJHcmFkaWVudCBtYXNrIHBhdGggcGF0dGVybiBwb2x5Z29uIHBvbHlsaW5lIFxucmFkaWFsR3JhZGllbnQgcmVjdCBzdG9wIHN2ZyB0ZXh0IHRzcGFuXCIuc3BsaXQoXCIgXCIpXG5cblRBR19BVFRSUy5IVE1MID0gXCJhY2NlcHQgYWNjZXNzS2V5IGFjdGlvbiBhbGxvd0Z1bGxTY3JlZW4gYWxsb3dUcmFuc3BhcmVuY3kgYWx0IGFzeW5jIFxuYXV0b0NvbXBsZXRlIGF1dG9Gb2N1cyBhdXRvUGxheSBjZWxsUGFkZGluZyBjZWxsU3BhY2luZyBjaGFyU2V0IGNoZWNrZWQgXG5jbGFzc05hbWUgY29scyBjb2xTcGFuIGNvbnRlbnQgY29udGVudEVkaXRhYmxlIGNvbnRleHRNZW51IGNvbnRyb2xzIGNvb3JkcyBcbmNyb3NzT3JpZ2luIGRhdGEgZGF0ZVRpbWUgZGVmZXIgZGlyIGRpc2FibGVkIGRvd25sb2FkIGRyYWdnYWJsZSBlbmNUeXBlIGZvcm0gXG5mb3JtTm9WYWxpZGF0ZSBmcmFtZUJvcmRlciBoZWlnaHQgaGlkZGVuIGhyZWYgaHJlZkxhbmcgaHRtbEZvciBodHRwRXF1aXYgaWNvbiBcbmlkIGxhYmVsIGxhbmcgbGlzdCBsb29wIG1heCBtYXhMZW5ndGggbWVkaWFHcm91cCBtZXRob2QgbWluIG11bHRpcGxlIG11dGVkIFxubmFtZSBub1ZhbGlkYXRlIHBhdHRlcm4gcGxhY2Vob2xkZXIgcG9zdGVyIHByZWxvYWQgcmFkaW9Hcm91cCByZWFkT25seSByZWwgXG5yZXF1aXJlZCByb2xlIHJvd3Mgcm93U3BhbiBzYW5kYm94IHNjb3BlIHNjcm9sbExlZnQgc2Nyb2xsaW5nIHNjcm9sbFRvcCBcbnNlYW1sZXNzIHNlbGVjdGVkIHNoYXBlIHNpemUgc3BhbiBzcGVsbENoZWNrIHNyYyBzcmNEb2Mgc3JjU2V0IHN0YXJ0IHN0ZXAgXG5zdHlsZSB0YWJJbmRleCB0YXJnZXQgdGl0bGUgdHlwZSB1c2VNYXAgdmFsdWUgd2lkdGggd21vZGVcIlxuXG5UQUdfQVRUUlMuU1ZHID0gXCJjeCBjeSBkIGR4IGR5IGZpbGwgZmlsbE9wYWNpdHkgZm9udEZhbWlseSBmb250U2l6ZSBmeCBmeSBncmFkaWVudFRyYW5zZm9ybSBcbmdyYWRpZW50VW5pdHMgbWFya2VyRW5kIG1hcmtlck1pZCBtYXJrZXJTdGFydCBvZmZzZXQgb3BhY2l0eSBcbnBhdHRlcm5Db250ZW50VW5pdHMgcGF0dGVyblVuaXRzIHBvaW50cyBwcmVzZXJ2ZUFzcGVjdFJhdGlvIHIgcnggcnkgXG5zcHJlYWRNZXRob2Qgc3RvcENvbG9yIHN0b3BPcGFjaXR5IHN0cm9rZSBzdHJva2VEYXNoYXJyYXkgc3Ryb2tlTGluZWNhcCBcbnN0cm9rZU9wYWNpdHkgc3Ryb2tlV2lkdGggdGV4dEFuY2hvciB0cmFuc2Zvcm0gdmVyc2lvbiB2aWV3Qm94IHgxIHgyIHggeTEgeTIgeVwiXG5cblxuZXhwb3J0IGNsYXNzIFRhZ0Rlc2MgPCBOb2RlXG5cblx0ZGVmIGluaXRpYWxpemVcblx0XHRwICdUYWdEZXNjISEhJywkMFxuXHRcdHNlbGZcblxuXHRkZWYgY2xhc3Nlc1xuXHRcdHAgJ1RhZ0Rlc2NDbGFzc2VzJywkMFxuXHRcdHNlbGZcblxuZXhwb3J0IGNsYXNzIFRhZyA8IE5vZGVcblxuXHRwcm9wIHBhcnRzXG5cdHByb3Agb2JqZWN0XG5cdHByb3AgcmVhY3RpdmVcblx0cHJvcCBwYXJlbnRcblx0cHJvcCB0cmVlXG5cblx0ZGVmIGluaXRpYWxpemUgbyA9IHt9XG5cdFx0QHRyYXZlcnNlZCA9IG5vXG5cdFx0QHBhcnRzID0gW11cblx0XHRvOmNsYXNzZXMgfHw9IFtdXG5cdFx0bzphdHRyaWJ1dGVzIHx8PSBbXVxuXHRcdG86Y2xhc3NlcyB8fD0gW11cblx0XHRAb3B0aW9ucyA9IG9cblx0XHRAcmVmZXJlbmNlID0gbnVsbFxuXHRcdEBvYmplY3QgPSBudWxsXG5cdFx0QHRyZWUgPSBudWxsXG5cdFx0c2VsZlxuXG5cdGRlZiBzZXQgb2JqXG5cdFx0Zm9yIG93biBrLHYgb2Ygb2JqXG5cdFx0XHRpZiBrID09ICdhdHRyaWJ1dGVzJ1xuXHRcdFx0XHQjIHAgXCJhdHRyaWJ1dHMhXCJcblx0XHRcdFx0YWRkQXR0cmlidXRlKGF0cikgZm9yIGF0ciBpbiB2XG5cdFx0XHRcdGNvbnRpbnVlXG5cblx0XHRcdEBvcHRpb25zW2tdID0gdlxuXHRcdHNlbGZcblxuXHRkZWYgYWRkQ2xhc3Mgbm9kZVxuXHRcdHVubGVzcyBub2RlIGlzYSBUYWdGbGFnXG5cdFx0XHRub2RlID0gVGFnRmxhZy5uZXcobm9kZSlcblx0XHRAb3B0aW9uczpjbGFzc2VzLnB1c2gobm9kZSlcblx0XHRAcGFydHMucHVzaChub2RlKVxuXG5cdFx0IyBwIFwiYWRkIGNsYXNzISEhXCJcblx0XHRzZWxmXG5cblx0ZGVmIGFkZEluZGV4IG5vZGVcblx0XHRAcGFydHMucHVzaChub2RlKVxuXHRcdEBvYmplY3QgPSBub2RlXG5cdFx0c2VsZlxuXG5cdGRlZiBhZGRTeW1ib2wgbm9kZVxuXHRcdCMgcCBcImFkZFN5bWJvbCB0byB0aGUgdGFnXCIsbm9kZVxuXHRcdGlmIEBwYXJ0czpsZW5ndGggPT0gMFxuXHRcdFx0QHBhcnRzLnB1c2gobm9kZSlcblx0XHRcdEBvcHRpb25zOm5zID0gbm9kZVxuXHRcdHNlbGZcblx0XHRcblxuXHRkZWYgYWRkQXR0cmlidXRlIGF0clxuXHRcdCMgcCBcImFkZCBhdHRyaWJ1dGUhISFcIiwga2V5LCB2YWx1ZVxuXHRcdEBwYXJ0cy5wdXNoKGF0cikgIyB3aGF0P1xuXHRcdEBvcHRpb25zOmF0dHJpYnV0ZXMucHVzaChhdHIpXG5cdFx0c2VsZlxuXG5cdGRlZiBlbmNsb3Npbmdcblx0XHQoQG9wdGlvbnM6Y2xvc2UgYW5kIEBvcHRpb25zOmNsb3NlLnZhbHVlKVxuXG5cdGRlZiB0eXBlXG5cdFx0QG9wdGlvbnM6dHlwZSB8fCA6ZGl2XG5cblx0ZGVmIGNvbnN1bWUgbm9kZVxuXHRcdHZhciBvID0gQG9wdGlvbnNcblxuXG5cdFx0aWYgbm9kZSBpc2EgVGFnVHJlZVxuXHRcdFx0IyBwIFwidGFnIGNvbnN1bWUgdGFndHJlZT8ge25vZGUucmVhY3RpdmV9XCJcblx0XHRcdHBhcmVudCA9IG5vZGUucm9vdFxuXHRcdFx0IyBvOnRyZWVSZWYgPSBub2RlLm5leHRDYWNoZUtleVxuXG5cdFx0XHRpZiBub2RlLkBsb29wXG5cdFx0XHRcdCMgYWx3YXR5cyBtYWtlIGl0ZW1zIGluIGxvb3AgcmVhY3RpdmVcblx0XHRcdFx0cmVhY3RpdmUgPSBub2RlLnJlYWN0aXZlIG9yIG9wdGlvbig6a2V5KVxuXHRcdFx0XHRvcHRpb24oOmxvb3Asbm9kZS5AbG9vcClcblxuXHRcdFx0XHRpZiBvcHRpb24oOml2YXIpXG5cdFx0XHRcdFx0d2FybiBcIlRhZyBpbnNpZGUgbG9vcCBjYW4gbm90IGhhdmUgYSBzdGF0aWMgcmVmZXJlbmNlIHtvcHRpb24oOml2YXIpfVwiLCB0eXBlOiAnZXJyb3InLCB0b2tlbjogb3B0aW9uKDppdmFyKS52YWx1ZVxuXG5cdFx0XHRlbHNlXG5cdFx0XHRcdHJlYWN0aXZlID0gbm9kZS5yZWFjdGl2ZSBvciAhIW9wdGlvbig6aXZhcilcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHNlbGZcblxuXHRcdHN1cGVyXG5cblxuXHRkZWYgdmlzaXRcblxuXHRcdHZhciBvID0gQG9wdGlvbnNcblxuXHRcdGlmIG86aXZhciBvciBvOmtleVxuXHRcdFx0cmVhY3RpdmUgPSB5ZXNcblxuXHRcdHZhciB0eXAgPSBlbmNsb3NpbmdcblxuXHRcdCMgbG9vayBmb3Igb3V0ZXIgdGFnIGhlcmU/XG5cblx0XHRpZiB0eXAgPT0gJy0+JyBvciB0eXAgPT0gJz0+J1xuXHRcdFx0IyBjb25zb2xlLmxvZyBcInRhZyBpcyB0ZW1wbGF0ZT8hPyB7dHlwfVwiXG5cdFx0XHRAdHJlZSA9IFRhZ1RyZWUubmV3KHNlbGYsbzpib2R5LCByb290OiBzZWxmLCByZWFjdGl2ZTogcmVhY3RpdmUpXG5cdFx0XHRvOmJvZHkgPSBUYWdGcmFnbWVudEZ1bmMubmV3KFtdLEJsb2NrLndyYXAoW0B0cmVlXSkpXG5cdFx0XHQjIGNvbnNvbGUubG9nIFwibWFkZSBvIGJvZHkgYSBmdW5jdGlvbj9cIlxuXG5cdFx0bzprZXkudHJhdmVyc2UgaWYgbzprZXlcblxuXHRcdGlmIG86Ym9keVxuXHRcdFx0bzpib2R5LnRyYXZlcnNlXG5cblx0XHQjIGlkIHNob3VsZCBhbHNvIGJlIGEgcmVndWxhciBwYXJ0XG5cdFxuXHRcdG86aWQudHJhdmVyc2UgaWYgbzppZFxuXHRcdFxuXG5cdFx0Zm9yIHBhcnQgaW4gQHBhcnRzXG5cdFx0XHRwYXJ0LnRyYXZlcnNlXG5cblx0XHQjIGZvciBhdHIgaW4gQG9wdGlvbnM6YXR0cmlidXRlc1xuXHRcdCMgXHRhdHIudHJhdmVyc2VcblxuXHRcdHNlbGZcblxuXHRkZWYgcmVmZXJlbmNlXG5cdFx0QHJlZmVyZW5jZSB8fD0gc2NvcGVfXy5jbG9zdXJlLnRlbXBvcmFyeShzZWxmLHBvb2w6ICd0YWcnKS5yZXNvbHZlXG5cblx0IyBzaG91bGQgdGhpcyBub3QgaGFwcGVuIGluIGpzP1xuXHQjIHNob3VsZCB0aGlzIG5vdCBoYXBwZW4gaW4ganM/XG5cdGRlZiBqcyBvXG5cdFx0IyBwIEpTT04uc3RyaW5naWZ5KEBvcHRpb25zKVxuXHRcdCMgdmFyIGF0dHJzID0gVGFnQXR0cmlidXRlcy5uZXcobzphdHRyaWJ1dGVzKVxuXHRcdCMgcCBcImdvdCBoZXJlP1wiXG5cdFx0dmFyIG8gPSBAb3B0aW9uc1xuXHRcdHZhciBhID0ge31cblx0XHR2YXIgZW5jID0gZW5jbG9zaW5nXG5cblx0XHR2YXIgc2V0dXAgPSBbXVxuXHRcdHZhciBjYWxscyA9IFtdXG5cdFx0dmFyIHN0YXRpY3MgPSBbXVxuXG5cdFx0dmFyIHNjb3BlID0gc2NvcGVfX1xuXHRcdHZhciBjb21taXQgPSBcImVuZFwiXG5cdFx0dmFyIGNvbnRlbnQgPSBvOmJvZHlcblxuXHRcdHZhciBpc1NlbGYgPSB0eXBlIGlzYSBTZWxmXG5cdFx0dmFyIGJvZHlTZXR0ZXIgPSBpc1NlbGYgPyBcInNldENoaWxkcmVuXCIgOiBcInNldENvbnRlbnRcIlxuXG5cdFx0IyBzaG91bGQgbm90IGNhY2hlIHN0YXRpY3MgaWYgdGhlIG5vZGUgaXRzZWxmIGlzIG5vdCBjYWNoZWRcblx0XHQjIHRoYXQgd291bGQgb25seSBtYW5nbGUgdGhlIG9yZGVyIGluIHdoaWNoIHdlIHNldCB0aGUgcHJvcGVydGllc1xuXHRcdHZhciBjYWNoZVN0YXRpY3MgPSB5ZXNcblxuXHRcdGZvciBhdHIgaW4gbzphdHRyaWJ1dGVzXG5cdFx0XHRhW2F0ci5rZXldID0gYXRyLnZhbHVlICMgLnBvcHVsYXRlKG9iailcblxuXHRcdHZhciBxdW90ZSA9IGRvIHxzdHJ8IGhlbHBlcnMuc2luZ2xlcXVvdGUoc3RyKVxuXHRcdHZhciBpZCA9IG86aWQgaXNhIE5vZGUgPyBvOmlkLmMgOiAobzppZCBhbmQgcXVvdGUobzppZC5jKSlcblx0XHR2YXIgdHJlZSA9IEB0cmVlIG9yIG51bGxcblx0XHR2YXIgcGFyZW50ID0gc2VsZi5wYXJlbnRcblx0XHQjIHZhciBwYXJUcmVlID0gcGFyZW50IGFuZCBwYXJlbnQudHJlZVxuXG5cblx0XHQjICBcInNjb3BlIGlzXCIsICEhc2NvcGVcblx0XHQjIHAgXCJ0eXBlIGlzIHt0eXBlfVwiXG5cdFx0dmFyIG91dCA9IGlmIGlzU2VsZlxuXHRcdFx0Y29tbWl0ID0gXCJzeW5jZWRcIlxuXHRcdFx0IyBwIFwiZ290IGhlcmVcIlxuXHRcdFx0IyBzZXR0aW5nIGNvcnJlY3QgY29udGV4dCBkaXJlY3RseVxuXHRcdFx0cmVhY3RpdmUgPSB5ZXNcblx0XHRcdEByZWZlcmVuY2UgPSBzY29wZS5jb250ZXh0XG5cdFx0XHRzY29wZS5jb250ZXh0LmNcblx0XHRlbHNlXG5cdFx0XHRcInttYXJrX18obzpvcGVuKX17c2NvcGUudGFnQ29udGV4dFBhdGh9Lnt0eXBlLnNwYXduZXJ9KClcIlxuXG5cdFx0aWYgbzppZFxuXHRcdFx0c3RhdGljcy5wdXNoKFwiLnNldElkKHtxdW90ZShvOmlkKX0pXCIpXG5cdFx0IyB0aGlzIGlzIHJlYWN0aXZlIGlmIGl0IGhhcyBhbiBpdmFyXG5cdFx0aWYgbzppdmFyXG5cdFx0XHRyZWFjdGl2ZSA9IHllc1xuXHRcdFx0c3RhdGljcy5wdXNoKFwiLnNldFJlZih7cXVvdGUobzppdmFyLm5hbWUpfSx7c2NvcGUuY29udGV4dC5jfSlcIilcblxuXHRcdGlmIG86Ym9keSBpc2EgRnVuY1xuXHRcdFx0IyBjb25zb2xlLmxvZyBcIm86Ym9keSBpc2EgZnVuY3Rpb24hXCJcblx0XHRcdGJvZHlTZXR0ZXIgPSBcInNldFRlbXBsYXRlXCJcblxuXHRcdGVsaWYgbzpib2R5XG5cdFx0XHRpZiBvOmJvZHkgaXNhIEFyZ0xpc3QgYW5kIG86Ym9keS5jb3VudCA9PSAxIGFuZCBvOmJvZHkuZmlyc3QuaXNTdHJpbmdcblx0XHRcdFx0Ym9keVNldHRlciA9IFwic2V0VGV4dFwiXG5cblx0XHRcdGVsc2Vcblx0XHRcdFx0IyB3b3VsZCBwcm9iYWJseSBiZSBiZXR0ZXIgdG8gY29udmVydCB0byBhIHRhZ3RyZWUgZHVyaW5nIHRoZSBpbml0aWFsIHZpc2l0XG5cdFx0XHRcdHRyZWUgPSBUYWdUcmVlLm5ldyhzZWxmLCBvOmJvZHksIHJvb3Q6IHNlbGYsIHJlYWN0aXZlOiByZWFjdGl2ZSlcblx0XHRcdFx0Y29udGVudCA9IHRyZWVcblx0XHRcdFx0c2VsZi50cmVlID0gdHJlZVxuXG5cdFx0aWYgdHJlZVxuXHRcdFx0IyB0aGlzIGlzIHRoZSBwb2ludCB3aGVyZSB3ZSB0cmF2ZXJzZSB0aGUgaW5uZXIgbm9kZXMgd2l0aCBvdXIgdHJlZVxuXHRcdFx0IyBzaG91bGQgcmF0aGVyIGhhcHBlbiBpbiB2aXNpdCAtIGxvbmcgYmVmb3JlLlxuXHRcdFx0dHJlZS5yZXNvbHZlXG5cblx0XHRmb3IgcGFydCBpbiBAcGFydHNcblx0XHRcdHZhciBwanNcblx0XHRcdHZhciBwY2FjaGUgPSBub1xuXG5cdFx0XHRpZiBwYXJ0IGlzYSBUYWdBdHRyXG5cdFx0XHRcdHZhciBha2V5ID0gU3RyaW5nKHBhcnQua2V5KVxuXHRcdFx0XHR2YXIgYXZhbCA9IHBhcnQudmFsdWVcblx0XHRcdFx0IyBwIFwicGFydCB2YWx1ZSB7YXZhbH0ge2F2YWwuaXNQcmltaXRpdmUoeWVzKX1cIlxuXG5cdFx0XHRcdCMgdGhlIGF0dHIgc2hvdWxkIGNvbXBpbGUgaXRzZWxmIGluc3RlYWQgLS0gcmVhbGx5XG5cdFx0XHRcdHBjYWNoZSA9IGF2YWwuaXNQcmltaXRpdmVcblxuXHRcdFx0XHRpZiBha2V5WzBdID09ICcuJyAjIHNob3VsZCBjaGVjayBpbiBhIGJldHRlciB3YXlcblx0XHRcdFx0XHRwY2FjaGUgPSBub1xuXHRcdFx0XHRcdHBqcyA9IFwiLmZsYWcoe3F1b3RlKGFrZXkuc3Vic3RyKDEpKX0se2F2YWwuY30pXCJcblx0XHRcdFx0ZWxpZiBha2V5WzBdID09ICc6J1xuXHRcdFx0XHRcdCMgbmVlZCB0byBhbmFseXplIHdoZXRoZXIgdGhpcyBpcyBzdGF0aWMgb3Igbm90XG5cdFx0XHRcdFx0cGpzID0gXCIuc2V0SGFuZGxlcih7cXVvdGUoYWtleS5zdWJzdHIoMSkpfSx7YXZhbC5jfSx7c2NvcGUuY29udGV4dC5jfSlcIlxuXHRcdFx0XHRlbGlmIGFrZXkuc3Vic3RyKDAsNSkgPT0gJ2RhdGEtJ1xuXHRcdFx0XHRcdHBqcyA9IFwiLmRhdGFzZXQoJ3tha2V5LnNsaWNlKDUpfScse2F2YWwuY30pXCJcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHBqcyA9IFwiLnttYXJrX18ocGFydC5rZXkpfXtoZWxwZXJzLnNldHRlclN5bShha2V5KX0oe2F2YWwuY30pXCJcblxuXHRcdFx0ZWxpZiBwYXJ0IGlzYSBUYWdGbGFnXG5cdFx0XHRcdHBqcyA9IHBhcnQuY1xuXHRcdFx0XHRwY2FjaGUgPSB5ZXNcblxuXHRcdFx0aWYgcGpzXG5cdFx0XHRcdGNhY2hlU3RhdGljcyAmJiBwY2FjaGUgPyBzdGF0aWNzLnB1c2gocGpzKSA6IGNhbGxzLnB1c2gocGpzKVxuXG5cblxuXHRcdGlmIG9iamVjdFxuXHRcdFx0Y2FsbHMucHVzaChcIi5zZXRPYmplY3Qoe29iamVjdC5jfSlcIilcblxuXHRcdCMgcCBcInRhZ3RyZWUgaXMgc3RhdGljPyB7dHJlZS5zdGF0aWN9XCJcblxuXHRcdCMgd2UgbmVlZCB0byB0cmlnZ2VyIG91ciBvd24gcmVmZXJlbmNlIGJlZm9yZSB0aGUgYm9keSBkb2VzXG5cdFx0IyBidXQgd2UgZG8gbm90IG5lZWQgYSByZWZlcmVuY2UgaWYgd2UgaGF2ZSBubyBib2R5IChubyBub2RlcyB3aWxsIHJlZmVyIGl0KVxuXHRcdGlmIHJlYWN0aXZlIGFuZCB0cmVlICMgYW5kIHRyZWUuaGFzVGFnc1xuXHRcdFx0cmVmZXJlbmNlXG5cblx0XHRpZiByZWFjdGl2ZSBhbmQgcGFyZW50IGFuZCBwYXJlbnQudHJlZVxuXHRcdFx0bzp0cmVlUmVmID0gcGFyZW50LnRyZWUubmV4dENhY2hlS2V5KHNlbGYpXG5cblx0XHRpZiB2YXIgYm9keSA9IGNvbnRlbnQgYW5kIGNvbnRlbnQuYyhleHByZXNzaW9uOiB5ZXMpICMgZm9yY2UgaXQgdG8gYmUgYW4gZXhwcmVzc2lvbiwgbm8/XG5cdFx0XHRsZXQgdHlwID0gMFxuXG5cdFx0XHRpZiB0cmVlIFxuXHRcdFx0XHRpZiB0cmVlLnN0YXRpY1xuXHRcdFx0XHRcdHR5cCA9IDJcblx0XHRcdFx0ZWxpZiByZWFjdGl2ZSBvciB0cmVlLnJlYWN0aXZlXG5cdFx0XHRcdFx0aWYgIXRyZWUuc2luZ2xlIG9yIHRyZWUuc2luZ2xlIGlzYSBJZlxuXHRcdFx0XHRcdFx0dHlwID0gMVxuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdHR5cCA9IDNcblx0XHRcdFx0XHRcdFxuXG5cdFx0XHRpZiBib2R5U2V0dGVyID09ICdzZXRDaGlsZHJlbicgb3IgYm9keVNldHRlciA9PSAnc2V0Q29udGVudCdcblx0XHRcdFx0Y2FsbHMucHVzaCBcIi57Ym9keVNldHRlcn0oe2JvZHl9LHt0eXB9KVwiXG5cdFx0XHRlbHNlXG5cdFx0XHRcdGNhbGxzLnB1c2ggXCIue2JvZHlTZXR0ZXJ9KHtib2R5fSlcIlxuXG5cdFx0XHQjIG91dCArPSBcIi5ib2R5KHtib2R5fSlcIlxuXG5cdFx0IyBpZiBvOmF0dHJpYnV0ZXM6bGVuZ3RoICMgb3IgLS0gYWx3YXlzP1xuXHRcdCMgYWRkcyBsb3RzIG9mIGV4dHJhIGNhbGxzIC0gYnV0IG9rYXkgZm9yIG5vd1xuXHRcdGNhbGxzLnB1c2ggXCIue2NvbW1pdH0oKVwiXG5cblx0XHRpZiBzdGF0aWNzOmxlbmd0aFxuXHRcdFx0b3V0ID0gb3V0ICsgc3RhdGljcy5qb2luKFwiXCIpXG5cblx0XG5cdFx0aWYgKG86aXZhciBvciBvOmtleSBvciByZWFjdGl2ZSkgYW5kICEodHlwZSBpc2EgU2VsZilcblx0XHRcdCMgaWYgdGhpcyBpcyBhbiBpdmFyLCB3ZSBzaG91bGQgc2V0IHRoZSByZWZlcmVuY2UgcmVsYXRpdmVcblx0XHRcdCMgdG8gdGhlIG91dGVyIHJlZmVyZW5jZSwgb3IgcG9zc2libHkgcmlnaHQgb24gY29udGV4dD9cblx0XHRcdHZhciBjdHgsIGtleVxuXHRcdFx0dmFyIHBhcnRyZWUgPSBwYXJlbnQgYW5kIHBhcmVudC50cmVlXG5cdFx0XHQjIGN0eCA9ICFvOml2YXIgYW5kIHBhciBhbmQgcGFyLnJlZmVyZW5jZSBvciBzY29wZS5jb250ZXh0XG5cdFx0XHQjIGtleSA9IG86aXZhciBvciB0cmVlIGFuZCB0cmVlLm5leHRDYWNoZUtleVxuXG5cdFx0XHRpZiBvOmtleVxuXHRcdFx0XHQjIGNsb3Nlc3QgdGFnXG5cdFx0XHRcdCMgVE9ETyBpZiB0aGUgZHluYW1pYyBrZXkgc3RhcnRzIHdpdGggYSBzdGF0aWMgc3RyaW5nIHdlIHNob3VsZFxuXHRcdFx0XHQjIGp1c3QgcHJlcGVuZCBfIHRvIHRoZSBzdHJpbmcgaW5zdGVhZCBvZiB3cmFwcGluZyBpbiBPUFxuXHRcdFx0XHRjdHggPSBwYXJlbnQgYW5kIHBhcmVudC5yZWZlcmVuY2Vcblx0XHRcdFx0a2V5ID0gT1AoJysnLFN0ci5uZXcoXCInXydcIiksbzprZXkpXG5cblx0XHRcdGVsaWYgbzppdmFyXG5cdFx0XHRcdGN0eCA9IHNjb3BlLmNvbnRleHRcblx0XHRcdFx0a2V5ID0gbzppdmFyXG5cblx0XHRcdGVsc2Vcblx0XHRcdFx0Y3R4ID0gcGFyZW50IGFuZCBwYXJlbnQucmVmZXJlbmNlXG5cdFx0XHRcdCMgY3R4ID0gcGFydHJlZS5jYWNoZXJcblx0XHRcdFx0a2V5ID0gbzp0cmVlUmVmIG9yIHBhcnRyZWUgYW5kIHBhcnRyZWUubmV4dENhY2hlS2V5XG5cdFx0XHRcdCMga2V5ID0gdHJlZSBhbmQgdHJlZS5uZXh0Q2FjaGVLZXlcblx0XHRcdFx0aWYgbzpsb29wXG5cdFx0XHRcdFx0bGV0IGlkeCA9IG86bG9vcC5vcHRpb24oOnZhcnMpWzppbmRleF1cblx0XHRcdFx0XHRrZXkgPSBPUCgnKycsXCInXCIgKyBrZXkgKyBcIidcIixpZHgpXG5cblxuXG5cdFx0XHQjIG5lZWQgdGhlIGNvbnRleHQgLS0gbWlnaHQgYmUgYmV0dGVyIHRvIHJld3JpdGUgaXQgZm9yIHJlYWw/XG5cdFx0XHQjIHBhcnNlIHRoZSB3aG9sZSB0aGluZyBpbnRvIGNhbGxzIGV0Y1xuXHRcdFx0dmFyIGFjYyA9IE9QKCcuJyxjdHgsa2V5KS5jXG5cblx0XHRcdGlmIEByZWZlcmVuY2Vcblx0XHRcdFx0b3V0ID0gXCIoe3JlZmVyZW5jZS5jfSA9IHthY2N9PXthY2N9IHx8IHtvdXR9KVwiXG5cdFx0XHRlbHNlXG5cdFx0XHRcdG91dCA9IFwiKHthY2N9ID0ge2FjY30gfHwge291dH0pXCJcblxuXHRcdHJldHVybiBvdXQgKyBjYWxscy5qb2luKFwiXCIpXG5cbiMgVGhpcyBpcyBhIGhlbHBlci1ub2RlXG4jIFNob3VsZCBwcm9iYWJseSB1c2UgdGhlIHNhbWUgdHlwZSBvZiBsaXN0bm9kZSBldmVyeXdoZXJlIC0gYW5kIHNpbXBseSBmbGFnIHRoZSB0eXBlIGFzIFRhZ1RyZWUgaW5zdGVhZFxuZXhwb3J0IGNsYXNzIFRhZ1RyZWUgPCBMaXN0Tm9kZVxuXHRcblx0cHJvcCBjb3VudGVyXG5cdHByb3AgY29uZGl0aW9uc1xuXHRwcm9wIGJsb2Nrc1xuXHRwcm9wIGNhY2hlclxuXG5cdGRlZiBpbml0aWFsaXplIG93bmVyLCBsaXN0LCBvcHRpb25zID0ge31cblx0XHRAb3duZXIgPSBvd25lclxuXHRcdEBub2RlcyA9IGxvYWQobGlzdClcblx0XHRAb3B0aW9ucyA9IG9wdGlvbnNcblx0XHRAY29uZGl0aW9ucyA9IFtdXG5cdFx0QGJsb2NrcyA9IFtzZWxmXVxuXHRcdEBjb3VudGVyID0gMFxuXHRcdHNlbGZcblxuXHRkZWYgcGFyZW50XG5cdFx0QHBhcmVudCB8fD0gQG93bmVyLnBhcmVudFxuXG5cdGRlZiBuZXh0Q2FjaGVLZXlcblx0XHR2YXIgcm9vdCA9IEBvd25lclxuXG5cdFx0IyBpZiB3ZSB3YW50IHRvIGNhY2hlIGV2ZXJ5dGhpbmcgb24gcm9vdFxuXHRcdHZhciBudW0gPSArK0Bjb3VudGVyXG5cdFx0dmFyIGJhc2UgPSBcIkFcIi5jaGFyQ29kZUF0KDApXG5cdFx0dmFyIHN0ciA9IFwiXCJcblxuXHRcdHdoaWxlIHRydWVcblx0XHRcdG51bSAtPSAxXG5cdFx0XHRzdHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJhc2UgKyAobnVtICUgMjYpKSArIHN0clxuXHRcdFx0bnVtID0gTWF0aC5mbG9vcihudW0gLyAyNilcblx0XHRcdGJyZWFrIHVubGVzcyBudW0gPiAwXG5cblx0XHRzdHIgPSAoQG93bmVyLnR5cGUgaXNhIFNlbGYgPyBcIiRcIiA6IFwiJCRcIikgKyBzdHIudG9Mb3dlckNhc2Vcblx0XHRyZXR1cm4gc3RyXG5cdFx0cmV0dXJuIG51bVxuXG5cdGRlZiBsb2FkIGxpc3Rcblx0XHRpZiBsaXN0IGlzYSBMaXN0Tm9kZVxuXHRcdFx0IyBwIFwiaXMgYSBsaXN0IG5vZGUhISB7bGlzdC5jb3VudH1cIlxuXHRcdFx0IyB3ZSBzdGlsbCB3YW50IHRoZSBpbmRlbnRhdGlvbiBpZiB3ZSBhcmUgbm90IGluIGEgdGVtcGxhdGVcblx0XHRcdCMgb3IsIHJhdGhlciAtIHdlIHdhbnQgdGhlIGJsb2NrIHRvIGdldCB0aGUgaW5kZW50YXRpb24gLSBub3QgdGhlIHRyZWVcblx0XHRcdEBpbmRlbnRhdGlvbiB8fD0gbGlzdC5AaW5kZW50YXRpb24gIyBpZiBsaXN0LmNvdW50ID4gMVxuXHRcdFx0bGlzdC5ub2Rlc1xuXHRcdGVsc2Vcblx0XHRcdGNvbXBhY3RfXyhsaXN0IGlzYSBBcnJheSA/IGxpc3QgOiBbbGlzdF0pXG5cblx0ZGVmIHJvb3Rcblx0XHRvcHRpb24oOnJvb3QpXG5cblx0ZGVmIHJlYWN0aXZlXG5cdFx0b3B0aW9uKDpyZWFjdGl2ZSlcblxuXHRkZWYgcmVzb2x2ZVxuXHRcdHJlbWFwIGRvIHxjfCBjLmNvbnN1bWUoc2VsZilcblx0XHRzZWxmXG5cblx0ZGVmIHN0YXRpY1xuXHRcdCMgZXZlcnkgcmVhbCBub2RlXG5cdFx0QHN0YXRpYyA/PSBldmVyeSBkbyB8Y3wgKGMgaXNhIFRhZyBvciBjIGlzYSBTdHIgb3IgYyBpc2EgTWV0YSlcblxuXHRkZWYgc2luZ2xlXG5cdFx0QHNpbmdsZSA/PSAocmVhbENvdW50ID09IDEgPyBsYXN0IDogbm8pXG5cblx0ZGVmIGhhc1RhZ3Ncblx0XHRzb21lIGRvIHxjfCBjIGlzYSBUYWdcblxuXHRkZWYgYyBvXG5cdFx0IyBGSVhNRSBURVNUIHdoYXQgYWJvdXQgY29tbWVudHM/Pz9cblx0XHR2YXIgc2luZ2xlID0gc2luZ2xlXG5cblx0XHQjIG5vIGluZGVudGF0aW9uIGlmIHRoaXMgc2hvdWxkIHJldHVyblxuXHRcdGlmIHNpbmdsZSBhbmQgU1RBQ0suY3VycmVudCBpc2EgUmV0dXJuXG5cdFx0XHRAaW5kZW50YXRpb24gPSBudWxsXG5cblx0XHR2YXIgb3V0ID0gc3VwZXIobylcblxuXHRcdGlmICFzaW5nbGUgb3Igc2luZ2xlIGlzYSBJZlxuXHRcdFx0XCJbe291dH1dXCJcblx0XHRlbHNlXG5cdFx0XHRvdXRcblxuZXhwb3J0IGNsYXNzIFRhZ1dyYXBwZXIgPCBWYWx1ZU5vZGVcblxuXHRkZWYgdmlzaXRcblx0XHRpZiB2YWx1ZSBpc2EgQXJyYXlcblx0XHRcdHZhbHVlLm1hcCh8dnwgdi50cmF2ZXJzZSlcblx0XHRlbHNlXG5cdFx0XHR2YWx1ZS50cmF2ZXJzZVxuXHRcdHNlbGZcblx0XHRcblx0ZGVmIGNcblx0XHRcInRhZyR3cmFwKHt2YWx1ZS5jKGV4cHJlc3Npb246IHllcyl9KVwiXG5cblxuZXhwb3J0IGNsYXNzIFRhZ0F0dHJpYnV0ZXMgPCBMaXN0Tm9kZVxuXG5cdGRlZiBnZXQgbmFtZVxuXHRcdGZvciBub2RlIGluIG5vZGVzXG5cdFx0XHRyZXR1cm4gbm9kZSBpZiBub2RlLmtleSA9PSBuYW1lXG5cdFx0XG5cdFx0XG5leHBvcnQgY2xhc3MgVGFnQXR0ciA8IE5vZGVcblxuXHRwcm9wIGtleVxuXHRwcm9wIHZhbHVlXG5cblx0ZGVmIHZpc2l0XG5cdFx0dmFsdWUudHJhdmVyc2UgaWYgdmFsdWVcblx0XHRzZWxmXG5cblx0ZGVmIGluaXRpYWxpemUgaywgdlxuXHRcdCMgcCBcImluaXQgVGFnQXR0cmlidXRlXCIsICQwXG5cdFx0QHRyYXZlcnNlZCA9IG5vXG5cdFx0QGtleSA9IGtcblx0XHRAdmFsdWUgPSB2XG5cblx0ZGVmIHBvcHVsYXRlIG9ialxuXHRcdG9iai5hZGQoa2V5LCB2YWx1ZSlcblx0XHRzZWxmXG5cblx0ZGVmIGNcblx0XHRcImF0dHJpYnV0ZVwiXG5cblxuZXhwb3J0IGNsYXNzIFRhZ0ZsYWcgPCBOb2RlXG5cblx0cHJvcCB2YWx1ZVxuXHRwcm9wIHRvZ2dsZXJcblxuXHRkZWYgaW5pdGlhbGl6ZSB2YWx1ZVxuXHRcdEB0cmF2ZXJzZWQgPSBub1xuXHRcdEB2YWx1ZSA9IHZhbHVlXG5cdFx0c2VsZlxuXG5cdGRlZiB2aXNpdFxuXHRcdHVubGVzcyBAdmFsdWUgaXNhIFN0cmluZ1xuXHRcdFx0QHZhbHVlLnRyYXZlcnNlXG5cdFx0c2VsZlxuXG5cdGRlZiBjXG5cdFx0aWYgdmFsdWUgaXNhIE5vZGVcblx0XHRcdFwiLmZsYWcoe3ZhbHVlLmN9KVwiXG5cdFx0ZWxzZVxuXHRcdFx0XCIuZmxhZyh7aGVscGVycy5zaW5nbGVxdW90ZSh2YWx1ZSl9KVwiXG5cdFx0XG5cdFx0XG5cblxuXG5cbiMgU0VMRUNUT1JTXG5cblxuZXhwb3J0IGNsYXNzIFNlbGVjdG9yIDwgTGlzdE5vZGVcblx0XG5cdGRlZiBpbml0aWFsaXplIGxpc3QsIG9wdGlvbnNcblx0XHRAbm9kZXMgPSBsaXN0IG9yIFtdXG5cdFx0QG9wdGlvbnMgPSBvcHRpb25zXG5cdFx0XG5cdGRlZiBhZGQgcGFydCwgdHlwXG5cdFx0IyBwIFwic2VsZWN0IGFkZCFcIixwYXJ0LHR5cFxuXHRcdCMgbWFyayBpZiBzcGVjaWFsP1xuXHRcdHB1c2gocGFydClcblx0XHRzZWxmXG5cblx0ZGVmIGdyb3VwXG5cdFx0IyBjb25zb2xlLmxvZyBcImdyb3VwZWQhXCJcblx0XHQjIGZvciBub3cgd2Ugc2ltcGx5IGFkZCBhIGNvbW1hXG5cdFx0IyBob3cgd291bGQgdGhpcyB3b3JrIGZvciBkc3Q/XG5cdFx0QG5vZGVzLnB1c2goU2VsZWN0b3JHcm91cC5uZXcoXCIsXCIpKVxuXHRcdHNlbGZcblxuXHRkZWYgcXVlcnlcblx0XHR2YXIgc3RyID0gXCJcIlxuXHRcdHZhciBhcnkgPSBbXVxuXG5cdFx0Zm9yIGl0ZW0gaW4gbm9kZXNcblx0XHRcdHZhciB2YWwgPSBpdGVtLmNcblx0XHRcdGlmIHZhbCBpc2EgU3RyaW5nXG5cdFx0XHRcdHN0ciA9IFwie3N0cn17dmFsfVwiXG5cblx0XHRcIid7c3RyfSdcIlxuXG5cblx0ZGVmIGpzIG9cblx0XHR2YXIgdHlwID0gb3B0aW9uKDp0eXBlKVxuXHRcdHZhciBxID0gY19fKHF1ZXJ5KVxuXG5cdFx0aWYgdHlwID09ICclJ1xuXHRcdFx0XCJxJCh7cX0se28uc2NvcGUuY29udGV4dC5jKGV4cGxpY2l0OiB5ZXMpfSlcIiAjIGV4cGxpY2l0IGNvbnRleHRcblx0XHRlbGlmIHR5cCA9PSAnJSUnXG5cdFx0XHRcInEkJCh7cX0se28uc2NvcGUuY29udGV4dC5jKGV4cGxpY2l0OiB5ZXMpfSlcIlxuXHRcdGVsc2UgXG5cdFx0XHRcInF7dHlwfSh7cX0pXCJcblxuXHRcdCMgcmV0dXJuIFwie3R5cH0ge3Njb3BlZH0gLSB7YWxsfVwiXG5cdFx0XG5cbmV4cG9ydCBjbGFzcyBTZWxlY3RvclBhcnQgPCBWYWx1ZU5vZGVcblxuXHRkZWYgY1xuXHRcdGNfXyhAdmFsdWUpXG5cdFx0IyBcInt2YWx1ZS5jfVwiXG5cbmV4cG9ydCBjbGFzcyBTZWxlY3Rvckdyb3VwIDwgU2VsZWN0b3JQYXJ0XG5cblx0ZGVmIGNcblx0XHRcIixcIlxuXG5leHBvcnQgY2xhc3MgU2VsZWN0b3JUeXBlIDwgU2VsZWN0b3JQYXJ0XG5cblx0ZGVmIGNcblx0XHQjIHN1cHBvcnRcblx0XHQjIHAgXCJzZWxlY3RvcnR5cGUge3ZhbHVlfVwiXG5cdFx0IyB2YXIgb3V0ID0gdmFsdWUuY1xuXHRcdHZhciBuYW1lID0gdmFsdWUubmFtZVxuXHRcblx0XHQjIGF0IGxlYXN0IGJlIHZlcnkgY29uc2VydmF0aXZlIGFib3V0IHdoaWNoIHRhZ3Mgd2Vcblx0XHQjIGNhbiBkcm9wIHRoZSB0YWcgZm9yP1xuXHRcdCMgb3V0IGluIFRBR19UWVBFUy5IVE1MID8gXG5cdFx0bmFtZSBpbiBUQUdfVFlQRVMuSFRNTCA/IG5hbWUgOiB2YWx1ZS5zZWxcblxuXG5leHBvcnQgY2xhc3MgU2VsZWN0b3JVbml2ZXJzYWwgPCBTZWxlY3RvclBhcnRcblxuZXhwb3J0IGNsYXNzIFNlbGVjdG9yTmFtZXNwYWNlIDwgU2VsZWN0b3JQYXJ0XG5cbmV4cG9ydCBjbGFzcyBTZWxlY3RvckNsYXNzIDwgU2VsZWN0b3JQYXJ0XG5cblx0ZGVmIGNcblx0XHRpZiBAdmFsdWUgaXNhIE5vZGVcblx0XHRcdFwiLicre0B2YWx1ZS5jfSsnXCJcblx0XHRlbHNlXG5cdFx0XHRcIi57Y19fKEB2YWx1ZSl9XCJcblxuZXhwb3J0IGNsYXNzIFNlbGVjdG9ySWQgPCBTZWxlY3RvclBhcnRcblxuXHRkZWYgY1xuXHRcdGlmIEB2YWx1ZSBpc2EgTm9kZVxuXHRcdFx0XCIjJyt7QHZhbHVlLmN9KydcIlxuXHRcdGVsc2Vcblx0XHRcdFwiI3tjX18oQHZhbHVlKX1cIlxuXG5leHBvcnQgY2xhc3MgU2VsZWN0b3JDb21iaW5hdG9yIDwgU2VsZWN0b3JQYXJ0XG5cblx0ZGVmIGNcblx0XHRcIntjX18oQHZhbHVlKX1cIlxuXG5leHBvcnQgY2xhc3MgU2VsZWN0b3JQc2V1ZG9DbGFzcyA8IFNlbGVjdG9yUGFydFxuXG5leHBvcnQgY2xhc3MgU2VsZWN0b3JBdHRyaWJ1dGUgPCBTZWxlY3RvclBhcnRcblxuXHQjIHJlbWVtYmVyIHRvIHZpc2l0IG5vZGVzIGluc2lkZSBoZXJlP1xuXHRkZWYgaW5pdGlhbGl6ZSBsZWZ0LG9wLHJpZ2h0XG5cdFx0QGxlZnQgPSBsZWZ0XG5cdFx0QG9wID0gb3Bcblx0XHRAcmlnaHQgPSBAdmFsdWUgPSByaWdodFxuXG5cdGRlZiBjXG5cdFx0IyBUT0RPIHBvc3NpYmx5IHN1cHBvcnQgLnRvU2VsIG9yIHNlbCQodikgZm9yIGl0ZW1zIGluc2lkZSBxdWVyeVxuXHRcdCMgY291bGQgZWFzaWx5IGRvIGl0IHdpdGggYSBoZWxwZXItZnVuY3Rpb24gdGhhdCBpcyBhZGRlZCB0byB0aGUgdG9wIG9mIHRoZSBmaWxlc2NvcGVcblx0XHRpZiBAcmlnaHQgaXNhIFN0clxuXHRcdFx0XCJbe0BsZWZ0LmN9e0BvcH17QHJpZ2h0LmN9XVwiXG5cdFx0ZWxpZiBAcmlnaHRcblx0XHRcdCMgdGhpcyBpcyBub3QgYXQgYWxsIGdvb2Rcblx0XHRcdFwiW3tAbGVmdC5jfXtAb3B9XFxcIicre2NfXyhAcmlnaHQpfSsnXFxcIl1cIlxuXHRcdGVsc2Vcblx0XHRcdFwiW3tAbGVmdC5jfV1cIlxuXHRcdFxuXHRcdFx0IyAuLi5cblx0XHRcblxuXG5cbiMgREVGRVJcblxuZXhwb3J0IGNsYXNzIEF3YWl0IDwgVmFsdWVOb2RlXG5cblx0cHJvcCBmdW5jXG5cblx0ZGVmIGpzIG9cblx0XHQjIGludHJvZHVjZSBhIHV0aWwgaGVyZSwgbm8/XG5cdFx0Q0FMTChPUCgnLicsVXRpbC5Qcm9taXNpZnkubmV3KFt2YWx1ZV0pLCd0aGVuJyksW2Z1bmNdKS5jXG5cdFx0IyB2YWx1ZS5jXG5cdFxuXHRkZWYgdmlzaXQgb1xuXHRcdCMgdGhpbmdzIGFyZSBub3cgdHJhdmVyc2VkIGluIGEgc29tZXdoYXQgY2hhb3RpYyBvcmRlci4gTmVlZCB0byB0aWdodGVuXG5cdFx0IyBDcmVhdGUgYXdhaXQgZnVuY3Rpb24gLSBwdXNoIHRoaXMgdmFsdWUgdXAgdG8gYmxvY2ssIHRha2UgdGhlIG91dGVyXG5cdFx0dmFsdWUudHJhdmVyc2VcblxuXHRcdHZhciBibG9jayA9IG8udXAoQmxvY2spICMgb3IgdXAgdG8gdGhlIGNsb3Nlc3QgRlVOQ1RJT04/XG5cdFx0dmFyIG91dGVyID0gby5yZWxhdGl2ZShibG9jaywxKVxuXHRcdHZhciBwYXIgPSBvLnJlbGF0aXZlKHNlbGYsLTEpXG5cblx0XHQjIHAgXCJCbG9jayB7YmxvY2t9IHtvdXRlcn0ge3Bhcn1cIlxuXG5cdFx0ZnVuYyA9IEFzeW5jRnVuYy5uZXcoW10sW10pXG5cdFx0IyBub3cgd2UgbW92ZSB0aGlzIG5vZGUgdXAgdG8gdGhlIGJsb2NrXG5cdFx0ZnVuYy5ib2R5Lm5vZGVzID0gYmxvY2suZGVmZXJzKG91dGVyLHNlbGYpXG5cblx0XHQjIGlmIHRoZSBvdXRlciBpcyBhIHZhci1hc3NpZ25tZW50LCB3ZSBjYW4gc2ltcGx5IHNldCB0aGUgcGFyYW1zXG5cdFx0aWYgcGFyIGlzYSBBc3NpZ25cblx0XHRcdHBhci5sZWZ0LnRyYXZlcnNlXG5cdFx0XHR2YXIgbGZ0ID0gcGFyLmxlZnQubm9kZVxuXHRcdFx0IyBwIFwiQXN5bmMgYXNzaWdubWVudCB7cGFyfSB7bGZ0fVwiXG5cdFx0XHQjIENhbiBiZSBhIHR1cGxlIGFzIHdlbGwsIG5vP1xuXHRcdFx0aWYgbGZ0IGlzYSBWYXJSZWZlcmVuY2Vcblx0XHRcdFx0IyB0aGUgcGFyYW0gaXMgYWxyZWFkeSByZWdpc3RlcmVkP1xuXHRcdFx0XHQjIHNob3VsZCBub3QgZm9yY2UgdGhlIG5hbWUgYWxyZWFkeT8/XG5cdFx0XHRcdCMgYmV3YXJlIG9mIGJ1Z3Ncblx0XHRcdFx0ZnVuYy5wYXJhbXMuYXQoMCx5ZXMsbGZ0LnZhcmlhYmxlLm5hbWUpXG5cdFx0XHRlbGlmIGxmdCBpc2EgVHVwbGVcblx0XHRcdFx0IyBpZiB0aGlzIGFuIHVuZmFuY3kgdHVwbGUsIHdpdGggb25seSB2YXJzXG5cdFx0XHRcdCMgd2UgY2FuIGp1c3QgdXNlIGFyZ3VtZW50c1xuXG5cdFx0XHRcdGlmIHBhci50eXBlID09ICd2YXInICYmICFsZnQuaGFzU3BsYXRcblx0XHRcdFx0XHQjIHAgXCJTSU1QTElGWSEge2xmdC5ub2Rlc1swXX1cIlxuXHRcdFx0XHRcdGxmdC5tYXAgZG8gfGVsLGl8XG5cdFx0XHRcdFx0XHRmdW5jLnBhcmFtcy5hdChpLHllcyxlbC52YWx1ZSlcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdCMgb3RoZXJ3aXNlLCBkbyB0aGUgd2hvbGUgdHVwbGVcblx0XHRcdFx0XHQjIG1ha2Ugc3VyZSBpdCBpcyBhIHZhciBhc3NpZ25tZW50P1xuXHRcdFx0XHRcdHBhci5yaWdodCA9IEFSR1VNRU5UU1xuXHRcdFx0XHRcdGZ1bmMuYm9keS51bnNoaWZ0KHBhcilcblx0XHRcdGVsc2Vcblx0XHRcdFx0IyByZWd1bGFyIHNldHRlcnNcblx0XHRcdFx0cGFyLnJpZ2h0ID0gZnVuYy5wYXJhbXMuYXQoMCx5ZXMpXG5cdFx0XHRcdGZ1bmMuYm9keS51bnNoaWZ0KHBhcilcblx0XHRcdFx0XG5cdFx0XHRcblxuXHRcdCMgSWYgaXQgaXMgYW4gYWR2YW5jZSB0dXBsZSBvciBzb21ldGhpbmcsIGl0IHNob3VsZCBiZSBwb3NzaWJsZSB0b1xuXHRcdCMgZmVlZCBpbiB0aGUgcGFyYW1saXN0LCBhbmQgbGV0IHRoZSB0dXBsZSBoYW5kbGUgaXQgYXMgaWYgaXQgd2FzIGFueVxuXHRcdCMgb3RoZXIgdmFsdWVcblxuXHRcdCMgQ0FTRSBJZiB0aGlzIGlzIGEgdHVwbGUgLyBtdWx0aXNldCB3aXRoIG1vcmUgdGhhbiBvbmUgYXN5bmMgdmFsdWVcblx0XHQjIHdlIG5lZWQgdG8gdGhpbmsgZGlmZmVyZW50bHkuXG5cblx0XHQjIG5vdyB3ZSBuZWVkIHRvIHZpc2l0IHRoZSBmdW5jdGlvbiBhcyB3ZWxsXG5cdFx0ZnVuYy50cmF2ZXJzZVxuXHRcdCMgcHVsbCB0aGUgb3V0ZXIgaW5cblx0XHRzZWxmXG5cbmV4cG9ydCBjbGFzcyBBc3luY0Z1bmMgPCBGdW5jXG5cblx0ZGVmIGluaXRpYWxpemUgcGFyYW1zLCBib2R5LCBuYW1lLCB0YXJnZXQsIG9wdGlvbnNcblx0XHRzdXBlcihwYXJhbXMsYm9keSxuYW1lLHRhcmdldCxvcHRpb25zKVxuXG5cdGRlZiBzY29wZXR5cGUgZG8gTGFtYmRhU2NvcGVcblxuXHQjIG5lZWQgdG8gb3ZlcnJpZGUsIHNpbmNlIHdlIHdvbnQgZG8gaW1wbGljaXQgcmV0dXJuc1xuXHQjIGRlZiBqc1xuXHQjIFx0dmFyIGNvZGUgPSBzY29wZS5jXG5cdCMgXHRyZXR1cm4gXCJmdW5jdGlvbiAoe3BhcmFtcy5jfSlcIiArIGNvZGUud3JhcFxuXG5cblxuIyBJTVBPUlRTXG5cbmV4cG9ydCBjbGFzcyBJbXBvcnRTdGF0ZW1lbnQgPCBTdGF0ZW1lbnRcblxuXG5cdHByb3AgbnNcblx0cHJvcCBpbXBvcnRzXG5cdHByb3Agc291cmNlXG5cblxuXHRkZWYgaW5pdGlhbGl6ZSBpbXBvcnRzLCBzb3VyY2UsIG5zXG5cdFx0QHRyYXZlcnNlZCA9IG5vXG5cdFx0QGltcG9ydHMgPSBpbXBvcnRzXG5cdFx0QHNvdXJjZSA9IHNvdXJjZVxuXHRcdEBucyA9IG5zXG5cdFx0c2VsZlxuXG5cdGRlZiB2aXNpdFxuXHRcdGlmIEBuc1xuXHRcdFx0QG5zdmFyIHx8PSBzY29wZV9fLnJlZ2lzdGVyKEBucyxzZWxmKVxuXHRcdGVsc2Vcblx0XHRcdHZhciBzcmMgPSBzb3VyY2UuY1xuXHRcdFx0dmFyIG0gPSBzcmMubWF0Y2goLyhcXHcrKShcXC5qc3xpbWJhKT9bXFxcIlxcJ10kLylcblx0XHRcdEBhbGlhcyA9IG0gPyBtWzFdICsgJyQnIDogJ21vZCQnXG5cdFx0XG5cdFx0IyBzaG91bGQgYWxzbyByZWdpc3RlciB0aGUgaW1wb3J0ZWQgaXRlbXMsIG5vP1xuXHRcdGlmIEBpbXBvcnRzXG5cdFx0XHR2YXIgZGVjID0gQGRlY2xhcmF0aW9ucyA9IFZhcmlhYmxlRGVjbGFyYXRpb24ubmV3KFtdKVxuXG5cdFx0XHRpZiBAaW1wb3J0czpsZW5ndGggPT0gMVxuXHRcdFx0XHRAYWxpYXMgPSBAaW1wb3J0c1swXVxuXHRcdFx0XHRkZWMuYWRkKEBhbGlhcyxPUCgnLicsQ0FMTChJZGVudGlmaWVyLm5ldyhcInJlcXVpcmVcIiksW3NvdXJjZV0pLEBhbGlhcykpXG5cdFx0XHRcdGRlYy50cmF2ZXJzZVxuXHRcdFx0XHRyZXR1cm4gc2VsZlxuXHRcdFx0XHRcblx0XHRcdFx0IyBkZWMuYWRkKEBhbGlhcyxDQUxMKElkZW50aWZpZXIubmV3KFwicmVxdWlyZVwiKSxbc291cmNlXSkpXG5cblx0XHRcdCMgcCBcIkltcG9ydFN0YXRlbWVudCBoYXMgaW1wb3J0cyB7QGltcG9ydHM6bGVuZ3RofVwiXG5cdFx0XHQjIEBkZWNsYXJhdGlvbnMgPSBWYXJpYWJsZURlY2xhcmF0aW9uLm5ldyhbXSlcblx0XHRcdEBtb2R1bGVkZWNsID0gZGVjLmFkZChAYWxpYXMsQ0FMTChJZGVudGlmaWVyLm5ldyhcInJlcXVpcmVcIiksW3NvdXJjZV0pKVxuXHRcdFx0QG1vZHVsZWRlY2wudHJhdmVyc2VcblxuXG5cdFx0XHRpZiBAaW1wb3J0czpsZW5ndGggPiAxXG5cdFx0XHRcdGZvciBpbXAgaW4gQGltcG9ydHNcblx0XHRcdFx0XHRAZGVjbGFyYXRpb25zLmFkZChpbXAsT1AoJy4nLEBtb2R1bGVkZWNsLnZhcmlhYmxlLGltcCkpXG5cblx0XHRcdGRlYy50cmF2ZXJzZVxuXHRcdHNlbGZcblxuXG5cdGRlZiBqcyBvXG5cblx0XHRpZiBAZGVjbGFyYXRpb25zXG5cdFx0XHRyZXR1cm4gQGRlY2xhcmF0aW9ucy5jXG5cblx0XHR2YXIgcmVxID0gQ0FMTChJZGVudGlmaWVyLm5ldyhcInJlcXVpcmVcIiksW3NvdXJjZV0pXG5cblx0XHRpZiBAbnNcblx0XHRcdCMgbXVzdCByZWdpc3RlciBucyBhcyBhIHJlYWwgdmFyaWFibGVcblx0XHRcdHJldHVybiBcInZhciB7QG5zdmFyLmN9ID0ge3JlcS5jfVwiXG5cblx0XHRpZiBAaW1wb3J0c1xuXG5cdFx0XHR2YXIgc3JjID0gc291cmNlLmNcblx0XHRcdHZhciBhbGlhcyA9IFtdXG5cdFx0XHR2YXIgdmFycyA9IFZhckJsb2NrLm5ldyhbXSlcblxuXHRcdFx0aWYgdmFyIGZuYW1lID0gc3JjLm1hdGNoKC8oXFx3KykoXFwuanN8aW1iYSk/W1xcXCJcXCddJC8pXG5cdFx0XHRcdGFsaWFzLnB1c2goZm5hbWVbMV0pXG5cblx0XHRcdCMgdmFyIGFsaWFzID0gc3JjLm1hdGNoKC8oXFx3KykoXFwuanN8aW1iYSk/W1xcXCJcXCddJC8pXG5cdFx0XHQjIHAgXCJzb3VyY2UgdHlwZSB7c291cmNlfVwiXG5cdFx0XHQjIGNyZWF0ZSBhIHJlcXVpcmUgZm9yIHRoZSBzb3VyY2UsIHdpdGggYSB0ZW1wb3JhcnkgbmFtZT9cblx0XHRcdHZhciBvdXQgPSBbcmVxLmNhY2hlKG5hbWVzOiBhbGlhcykuY11cblxuXHRcdFx0Zm9yIGltcCBpbiBAaW1wb3J0c1xuXHRcdFx0XHQjIHdlIGFsc28gbmVlZCB0byByZWdpc3RlciB0aGVzZSBpbXBvcnRzIGFzIHZhcmlhYmxlcywgbm8/XG5cdFx0XHRcdHZhciBvID0gT1AoJz0nLGltcCxPUCgnLicscmVxLGltcCkpXG5cdFx0XHRcdG91dC5wdXNoKFwidmFyIHtvLmN9XCIpXG5cblx0XHRcdHJldHVybiBvdXRcblx0XHRlbHNlXG5cdFx0XHRyZXR1cm4gcmVxLmNcblxuXHRkZWYgY29uc3VtZSBub2RlXG5cdFx0cmV0dXJuIHNlbGZcblxuXG4jIEVYUE9SVCBcblxuZXhwb3J0IGNsYXNzIEV4cG9ydFN0YXRlbWVudCA8IFZhbHVlTm9kZVxuXG5cdGRlZiBqcyBvXG5cdFx0dmFyIG5vZGVzID0gQHZhbHVlLm1hcCBkbyB8YXJnfCBcIm1vZHVsZS5leHBvcnRzLnthcmcuY30gPSB7YXJnLmN9XCJcblxuXHRcdGlmIG5vZGVzOmxlbmd0aCA+IDEgYW5kIHVwIGlzYSBSZXR1cm5cblx0XHRcdHJldHVybiAnWycgKyBub2Rlcy5qb2luKCcsJykgKyAnXSdcblxuXHRcdGVsc2Vcblx0XHRcdHJldHVybiBub2Rlcy5qb2luKCc7XFxuJykgKyAnOydcblxuXG4jIFVUSUxTXG5cbmV4cG9ydCBjbGFzcyBVdGlsIDwgTm9kZVxuXG5cdHByb3AgYXJnc1xuXG5cdGRlZiBpbml0aWFsaXplIGFyZ3Ncblx0XHRAYXJncyA9IGFyZ3Ncblx0XHRcblx0IyB0aGlzIGlzIGhvdyB3ZSBkZWFsIHdpdGggaXQgbm93XG5cdGRlZiBzZWxmLmV4dGVuZCBhLGJcblx0XHRVdGlsLkV4dGVuZC5uZXcoW2EsYl0pXG5cblx0ZGVmIHNlbGYuY2FsbEltYmEgbWV0aCwgYXJnc1xuXHRcdENBTEwoT1AoJy4nLENvbnN0Lm5ldyhcIkltYmFcIiksSWRlbnRpZmllci5uZXcobWV0aCkpLGFyZ3MpXG5cblx0ZGVmIHNlbGYucmVwZWF0IHN0ciwgdGltZXNcblx0XHR2YXIgcmVzID0gJydcblx0XHR3aGlsZSB0aW1lcyA+IDBcblx0XHRcdGlmIHRpbWVzICUgMiA9PSAxXG5cdFx0XHRcdHJlcyArPSBzdHJcblx0XHRcdHN0ciArPSBzdHJcblx0XHRcdHRpbWVzID4+PSAxXG5cdFx0cmV0dXJuIHJlc1xuXHRcdFxuXHRcdFxuXG5cdGRlZiBzZWxmLmtleXMgb2JqXG5cdFx0dmFyIGwgPSBDb25zdC5uZXcoXCJPYmplY3RcIilcblx0XHR2YXIgciA9IElkZW50aWZpZXIubmV3KFwia2V5c1wiKVxuXHRcdENBTEwoT1AoJy4nLGwsciksW29ial0pXG5cblx0ZGVmIHNlbGYubGVuIG9iaiwgY2FjaGVcblx0XHQjIHAgXCJMRU4gSEVMUEVSXCIuZ3JlZW5cblx0XHR2YXIgciA9IElkZW50aWZpZXIubmV3KFwibGVuZ3RoXCIpXG5cdFx0dmFyIG5vZGUgPSBPUCgnLicsIG9iaiwgcilcblx0XHRub2RlLmNhY2hlKGZvcmNlOiB5ZXMsIHBvb2w6ICdsZW4nKSBpZiBjYWNoZVxuXHRcdHJldHVybiBub2RlXG5cblx0ZGVmIHNlbGYuaW5kZXhPZiBsZnQsIHJndFxuXHRcdHZhciBub2RlID0gVXRpbC5JbmRleE9mLm5ldyhbbGZ0LHJndF0pXG5cdFx0IyBub2RlLmNhY2hlKGZvcmNlOiB5ZXMsIHR5cGU6ICdpdGVyJykgaWYgY2FjaGVcblx0XHRyZXR1cm4gbm9kZVxuXG5cdGRlZiBzZWxmLnNsaWNlIG9iaiwgYSwgYlxuXHRcdHZhciBzbGljZSA9IElkZW50aWZpZXIubmV3KFwic2xpY2VcIilcblx0XHRjb25zb2xlLmxvZyBcInNsaWNlIHthfSB7Yn1cIlxuXHRcdHJldHVybiBDQUxMKE9QKCcuJyxvYmosc2xpY2UpLGNvbXBhY3RfXyhbYSxiXSkpXG5cdFxuXHRkZWYgc2VsZi5pdGVyYWJsZSBvYmosIGNhY2hlXG5cdFx0dmFyIG5vZGUgPSBVdGlsLkl0ZXJhYmxlLm5ldyhbb2JqXSlcblx0XHRub2RlLmNhY2hlKGZvcmNlOiB5ZXMsIHBvb2w6ICdpdGVyJykgaWYgY2FjaGVcblx0XHRyZXR1cm4gbm9kZVxuXG5cblxuXHRkZWYgc2VsZi51bmlvbiBhLGJcblx0XHRVdGlsLlVuaW9uLm5ldyhbYSxiXSlcblx0XHQjIENBTEwoVU5JT04sW2EsYl0pXG5cblx0ZGVmIHNlbGYuaW50ZXJzZWN0IGEsYlxuXHRcdFV0aWwuSW50ZXJzZWN0Lm5ldyhbYSxiXSlcblx0XHQjIENBTEwoSU5URVJTRUNULFthLGJdKVxuXG5cdGRlZiBzZWxmLmNvdW50ZXIgc3RhcnQsIGNhY2hlXG5cdFx0IyBzaG91bGQgaXQgbm90IHJhdGhlciBiZSBhIHZhcmlhYmxlPyE/XG5cdFx0dmFyIG5vZGUgPSBOdW0ubmV3KHN0YXJ0KSAjIG1ha2Ugc3VyZSBpdCByZWFsbHkgaXMgYSBudW1iZXJcblx0XHRub2RlLmNhY2hlKGZvcmNlOiB5ZXMsIHBvb2w6ICdjb3VudGVyJykgaWYgY2FjaGVcblx0XHRyZXR1cm4gbm9kZVxuXG5cdGRlZiBzZWxmLmFycmF5IHNpemUsIGNhY2hlXG5cdFx0dmFyIG5vZGUgPSBVdGlsLkFycmF5Lm5ldyhbc2l6ZV0pXG5cdFx0bm9kZS5jYWNoZShmb3JjZTogeWVzLCBwb29sOiAnbGlzdCcpIGlmIGNhY2hlXG5cdFx0cmV0dXJuIG5vZGVcblxuXHRkZWYgc2VsZi5kZWZpbmVUYWcgdHlwZSwgY3Rvciwgc3VwclxuXHRcdENBTEwoVEFHREVGLFt0eXBlLGN0b3Isc3Vwcl0pXG5cblxuXHRkZWYgc2VsZi5kZWZpbmVDbGFzcyBuYW1lLCBzdXByLCBpbml0b3Jcblx0XHRDQUxMKENMQVNTREVGLFtuYW1lIG9yIGluaXRvcixzdXBdKVxuXG5cdGRlZiBpc1N0YW5kYWxvbmVcblx0XHRPUFRTOnN0YW5kYWxvbmUgIT09IG5vXG5cblx0ZGVmIGpzIG9cblx0XHRcImhlbHBlclwiXG5cbiMgVE9ETyBEZXByZWNhdGUgYW5kIHJlbW92ZVxuZXhwb3J0IGNsYXNzIFV0aWwuVW5pb24gPCBVdGlsXG5cblx0ZGVmIGhlbHBlclxuXHRcdCcnJ1xuXHRcdGZ1bmN0aW9uIHVuaW9uJChhLGIpe1xuXHRcdFx0aWYoYSAmJiBhLl9fdW5pb24pIHJldHVybiBhLl9fdW5pb24oYik7XG5cblx0XHRcdHZhciB1ID0gYS5zbGljZSgwKTtcblx0XHRcdGZvcih2YXIgaT0wLGw9Yi5sZW5ndGg7aTxsO2krKykgaWYodS5pbmRleE9mKGJbaV0pID09IC0xKSB1LnB1c2goYltpXSk7XG5cdFx0XHRyZXR1cm4gdTtcblx0XHR9O1xuXG5cdFx0JycnXG5cblx0ZGVmIGpzIG9cblx0XHRzY29wZV9fLnJvb3QuaGVscGVyKHNlbGYsaGVscGVyKVxuXHRcdCMgV2hlbiB0aGlzIGlzIHRyaWdnZXJlZCwgd2UgbmVlZCB0byBhZGQgaXQgdG8gdGhlIHRvcCBvZiBmaWxlP1xuXHRcdFwidW5pb24kKHthcmdzLm1hcCh8dnwgdi5jICkuam9pbignLCcpfSlcIlxuXG4jIFRPRE8gRGVwcmVjYXRlIGFuZCByZW1vdmVcbmV4cG9ydCBjbGFzcyBVdGlsLkludGVyc2VjdCA8IFV0aWxcblxuXHRkZWYgaGVscGVyXG5cdFx0JycnXG5cdFx0ZnVuY3Rpb24gaW50ZXJzZWN0JChhLGIpe1xuXHRcdFx0aWYoYSAmJiBhLl9faW50ZXJzZWN0KSByZXR1cm4gYS5fX2ludGVyc2VjdChiKTtcblx0XHRcdHZhciByZXMgPSBbXTtcblx0XHRcdGZvcih2YXIgaT0wLCBsPWEubGVuZ3RoOyBpPGw7IGkrKykge1xuXHRcdFx0XHR2YXIgdiA9IGFbaV07XG5cdFx0XHRcdGlmKGIuaW5kZXhPZih2KSAhPSAtMSkgcmVzLnB1c2godik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzO1xuXHRcdH07XG5cblx0XHQnJydcblxuXHRkZWYganMgb1xuXHRcdCMgV2hlbiB0aGlzIGlzIHRyaWdnZXJlZCwgd2UgbmVlZCB0byBhZGQgaXQgdG8gdGhlIHRvcCBvZiBmaWxlP1xuXHRcdHNjb3BlX18ucm9vdC5oZWxwZXIoc2VsZixoZWxwZXIpXG5cdFx0XCJpbnRlcnNlY3QkKHthcmdzLm1hcCh8dnwgdi5jICkuam9pbignLCcpfSlcIlxuXG5leHBvcnQgY2xhc3MgVXRpbC5FeHRlbmQgPCBVdGlsXG5cblx0ZGVmIGpzIG9cblx0XHQjIFdoZW4gdGhpcyBpcyB0cmlnZ2VyZWQsIHdlIG5lZWQgdG8gYWRkIGl0IHRvIHRoZSB0b3Agb2YgZmlsZT9cblx0XHRcImV4dGVuZCQoe2NvbXBhY3RfXyhjYXJ5X18oYXJncykpLmpvaW4oJywnKX0pXCJcblxuZXhwb3J0IGNsYXNzIFV0aWwuSW5kZXhPZiA8IFV0aWxcblxuXHRkZWYgaGVscGVyXG5cdFx0JycnXG5cdFx0ZnVuY3Rpb24gaWR4JChhLGIpe1xuXHRcdFx0cmV0dXJuIChiICYmIGIuaW5kZXhPZikgPyBiLmluZGV4T2YoYSkgOiBbXS5pbmRleE9mLmNhbGwoYSxiKTtcblx0XHR9O1xuXG5cdFx0JycnXG5cblx0ZGVmIGpzIG9cblx0XHRpZiBpc1N0YW5kYWxvbmVcblx0XHRcdHNjb3BlX18ucm9vdC5oZWxwZXIoc2VsZixoZWxwZXIpXG5cdFx0XHQjIFdoZW4gdGhpcyBpcyB0cmlnZ2VyZWQsIHdlIG5lZWQgdG8gYWRkIGl0IHRvIHRoZSB0b3Agb2YgZmlsZT9cblx0XHRcdFwiaWR4JCh7YXJncy5tYXAofHZ8IHYuYyApLmpvaW4oJywnKX0pXCJcblx0XHRlbHNlXG5cdFx0XHRcIkltYmEuaW5kZXhPZih7YXJncy5tYXAofHZ8IHYuYyApLmpvaW4oJywnKX0pXCJcblx0XHRcblxuZXhwb3J0IGNsYXNzIFV0aWwuU3ViY2xhc3MgPCBVdGlsXG5cblx0ZGVmIGhlbHBlclxuXHRcdCMgc2hvdWxkIGFsc28gY2hlY2sgaWYgaXQgaXMgYSByZWFsIHByb21pc2Vcblx0XHQnJydcblx0XHQvLyBoZWxwZXIgZm9yIHN1YmNsYXNzaW5nXG5cdFx0ZnVuY3Rpb24gc3ViY2xhc3MkKG9iaixzdXApIHtcblx0XHRcdGZvciAodmFyIGsgaW4gc3VwKSB7XG5cdFx0XHRcdGlmIChzdXAuaGFzT3duUHJvcGVydHkoaykpIG9ialtrXSA9IHN1cFtrXTtcblx0XHRcdH07XG5cdFx0XHQvLyBvYmouX19zdXBlcl9fID0gc3VwO1xuXHRcdFx0b2JqLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwLnByb3RvdHlwZSk7XG5cdFx0XHRvYmouX19zdXBlcl9fID0gb2JqLnByb3RvdHlwZS5fX3N1cGVyX18gPSBzdXAucHJvdG90eXBlO1xuXHRcdFx0b2JqLnByb3RvdHlwZS5pbml0aWFsaXplID0gb2JqLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG9iajtcblx0XHR9O1xuXG5cdFx0JycnXG5cblx0ZGVmIGpzIG9cblx0XHRpZiBpc1N0YW5kYWxvbmVcblx0XHRcdCMgV2hlbiB0aGlzIGlzIHRyaWdnZXJlZCwgd2UgbmVlZCB0byBhZGQgaXQgdG8gdGhlIHRvcCBvZiBmaWxlP1xuXHRcdFx0c2NvcGVfXy5yb290LmhlbHBlcihzZWxmLGhlbHBlcilcblx0XHRcdFwic3ViY2xhc3MkKHthcmdzLm1hcCh8dnwgdi5jKS5qb2luKCcsJyl9KTtcXG5cIlxuXHRcdGVsc2Vcblx0XHRcdFwiSW1iYS5zdWJjbGFzcyh7YXJncy5tYXAofHZ8IHYuYykuam9pbignLCcpfSk7XFxuXCJcblxuZXhwb3J0IGNsYXNzIFV0aWwuUHJvbWlzaWZ5IDwgVXRpbFxuXG5cdGRlZiBoZWxwZXJcblx0XHQjIHNob3VsZCBhbHNvIGNoZWNrIGlmIGl0IGlzIGEgcmVhbCBwcm9taXNlXG5cdFx0XCJmdW5jdGlvbiBwcm9taXNlJChhKVxceyByZXR1cm4gYSBpbnN0YW5jZW9mIEFycmF5ID8gUHJvbWlzZS5hbGwoYSkgOiAoYSAmJiBhLnRoZW4gPyBhIDogUHJvbWlzZS5yZXNvbHZlKGEpKTsgXFx9XCJcblx0XHRcblx0ZGVmIGpzIG9cblx0XHRpZiBpc1N0YW5kYWxvbmVcblx0XHRcdCMgV2hlbiB0aGlzIGlzIHRyaWdnZXJlZCwgd2UgbmVlZCB0byBhZGQgaXQgdG8gdGhlIHRvcCBvZiBmaWxlP1xuXHRcdFx0c2NvcGVfXy5yb290LmhlbHBlcihzZWxmLGhlbHBlcilcblx0XHRcdFwicHJvbWlzZSQoe2FyZ3MubWFwKHx2fCB2LmMpLmpvaW4oJywnKX0pXCJcblx0XHRlbHNlXG5cdFx0XHRcIkltYmEuYXdhaXQoe2FyZ3MubWFwKHx2fCB2LmMpLmpvaW4oJywnKX0pXCJcblx0XHRcbiMgVE9ETyBkZXByZWNhdGVkOiBjYW4gcmVtb3ZlXG5leHBvcnQgY2xhc3MgVXRpbC5DbGFzcyA8IFV0aWxcblxuXHRkZWYganMgb1xuXHRcdCMgV2hlbiB0aGlzIGlzIHRyaWdnZXJlZCwgd2UgbmVlZCB0byBhZGQgaXQgdG8gdGhlIHRvcCBvZiBmaWxlP1xuXHRcdFwiY2xhc3MkKHthcmdzLm1hcCh8dnwgdi5jKS5qb2luKCcsJyl9KVwiXG5cbmV4cG9ydCBjbGFzcyBVdGlsLkl0ZXJhYmxlIDwgVXRpbFxuXG5cdGRlZiBoZWxwZXJcblx0XHQjIG5vdyB3ZSB3YW50IHRvIGFsbG93IG51bGwgdmFsdWVzIGFzIHdlbGwgLSBqdXN0IHJldHVybiBhcyBlbXB0eSBjb2xsZWN0aW9uXG5cdFx0IyBzaG91bGQgYmUgdGhlIHNhbWUgZm9yIGZvciBvd24gb2YgSSBndWVzc1xuXHRcdFwiZnVuY3Rpb24gaXRlciQoYSlcXHsgcmV0dXJuIGEgPyAoYS50b0FycmF5ID8gYS50b0FycmF5KCkgOiBhKSA6IFtdOyBcXH07XCJcblx0XHRcblx0ZGVmIGpzIG9cblx0XHRyZXR1cm4gYXJnc1swXS5jIGlmIGFyZ3NbMF0gaXNhIEFyciAjIG9yIGlmIHdlIGtub3cgZm9yIHN1cmUgdGhhdCBpdCBpcyBhbiBhcnJheVxuXG5cdFx0aWYgaXNTdGFuZGFsb25lXG5cdFx0XHRzY29wZV9fLnJvb3QuaGVscGVyKHNlbGYsaGVscGVyKVxuXHRcdFx0cmV0dXJuIFwiaXRlciQoe2FyZ3NbMF0uY30pXCJcblx0XHRlbHNlXG5cdFx0XHRyZXR1cm4gXCJJbWJhLml0ZXJhYmxlKHthcmdzWzBdLmN9KVwiXG5cdFx0XG5leHBvcnQgY2xhc3MgVXRpbC5Jc0Z1bmN0aW9uIDwgVXRpbFxuXG5cdGRlZiBqcyBvXG5cdFx0XCJ7YXJnc1swXS5jfVwiXG5cbmV4cG9ydCBjbGFzcyBVdGlsLkFycmF5IDwgVXRpbFxuXG5cdGRlZiBqcyBvXG5cdFx0IyBXaGVuIHRoaXMgaXMgdHJpZ2dlcmVkLCB3ZSBuZWVkIHRvIGFkZCBpdCB0byB0aGUgdG9wIG9mIGZpbGU/XG5cdFx0XCJuZXcgQXJyYXkoe2FyZ3MubWFwKHx2fCB2LmMpfSlcIlxuXG5cblxuXG5jbGFzcyBFbnRpdGllc1xuXG5cdGRlZiBpbml0aWFsaXplIHJvb3Rcblx0XHRAcm9vdCA9IHJvb3Rcblx0XHRAbWFwID0ge31cblx0XHRyZXR1cm4gc2VsZlxuXG5cdGRlZiBhZGQgcGF0aCwgb2JqZWN0XG5cdFx0QG1hcFtwYXRoXSA9IG9iamVjdFxuXHRcdHNlbGZcblxuXHRkZWYgcmVnaXN0ZXIgZW50aXR5XG5cdFx0dmFyIHBhdGggPSBlbnRpdHkubmFtZXBhdGhcblx0XHRAbWFwW3BhdGhdIHx8PSBlbnRpdHlcblx0XHRzZWxmXG5cblx0ZGVmIHBsYWluXG5cdFx0SlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShAbWFwKSlcblxuXHRkZWYgdG9KU09OXG5cdFx0QG1hcFxuXG4jIFNDT1BFU1xuXG4jIGhhbmRsZXMgbG9jYWwgdmFyaWFibGVzLCBzZWxmIGV0Yy4gU2hvdWxkIGNyZWF0ZSByZWZlcmVuY2VzIHRvIG91dGVyIHNjb3Blc1xuIyB3aGVuIG5lZWRlZCBldGMuXG5cbiMgYWRkIGNsYXNzIGZvciBhbm5vdGF0aW9ucyAvIHJlZ2lzdGVyaW5nIG1ldGhvZHMsIGV0Yz9cbiMgY2xhc3MgSW50ZXJmYWNlXG5cbiMgc2hvdWxkIG1vdmUgdGhlIHdob2xlIGNvbnRleHQtdGhpbmdpZSByaWdodCBpbnRvIHNjb3BlXG5leHBvcnQgY2xhc3MgU2NvcGVcblxuXHRwcm9wIGxldmVsXG5cdHByb3AgY29udGV4dFxuXHRwcm9wIG5vZGVcblx0cHJvcCBwYXJlbnRcblx0cHJvcCB2YXJtYXBcblx0cHJvcCB2YXJwb29sXG5cdHByb3AgcGFyYW1zXG5cdHByb3AgaGVhZFxuXHRwcm9wIHZhcnNcblx0cHJvcCBjb3VudGVyXG5cblx0ZGVmIHBcblx0XHRpZiBTVEFDSy5sb2dsZXZlbCA+IDBcblx0XHRcdGNvbnNvbGUubG9nKCphcmd1bWVudHMpXG5cdFx0c2VsZlxuXG5cdGRlZiBzdGFja1xuXHRcdFNUQUNLXG5cblx0ZGVmIGluaXRpYWxpemUgbm9kZSwgcGFyZW50XG5cdFx0QG5yID0gU1RBQ0suaW5jcignc2NvcGVzJylcblx0XHRAaGVhZCA9IFtdXG5cdFx0QG5vZGUgPSBub2RlXG5cdFx0QHBhcmVudCA9IHBhcmVudFxuXHRcdEB2YXJzID0gVmFyaWFibGVEZWNsYXJhdGlvbi5uZXcoW10pXG5cdFx0QG1ldGEgPSB7fVxuXHRcdEBhbm5vdGF0aW9ucyA9IFtdXG5cdFx0QGNsb3N1cmUgPSBzZWxmXG5cdFx0QHZpcnR1YWwgPSBub1xuXHRcdEBjb3VudGVyID0gMFxuXHRcdEB2YXJtYXAgID0ge31cblx0XHRAdmFycG9vbCA9IFtdXG5cblx0ZGVmIG1ldGEga2V5LCB2YWx1ZVxuXHRcdGlmIHZhbHVlICE9IHVuZGVmaW5lZFxuXHRcdFx0QG1ldGFba2V5XSA9IHZhbHVlXG5cdFx0XHRyZXR1cm4gc2VsZlxuXHRcdEBtZXRhW2tleV1cblxuXHRkZWYgbmFtZXBhdGhcblx0XHQnPydcblxuXHRkZWYgdGFnQ29udGV4dFBhdGhcblx0XHQjIGJ5cGFzc2luZyBmb3Igbm93XG5cdFx0QHRhZ0NvbnRleHRQYXRoIHx8PSBcInRhZyRcIiAjIHBhcmVudC50YWdDb250ZXh0UGF0aFxuXG5cdGRlZiBjb250ZXh0XG5cdFx0QGNvbnRleHQgfHw9IFNjb3BlQ29udGV4dC5uZXcoc2VsZilcblxuXHRkZWYgdHJhdmVyc2Vcblx0XHRzZWxmXG5cblx0ZGVmIHZpc2l0XG5cdFx0cmV0dXJuIHNlbGYgaWYgQHBhcmVudFxuXHRcdCMgcCBcInZpc2l0ZWQgc2NvcGUhXCJcblx0XHRAcGFyZW50ID0gU1RBQ0suc2NvcGUoMSkgIyB0aGUgcGFyZW50IHNjb3BlXG5cdFx0QGxldmVsID0gU1RBQ0suc2NvcGVzOmxlbmd0aCAtIDFcblxuXHRcdCMgcCBcInBhcmVudCBpc1wiLEBwYXJlbnRcblx0XHRTVEFDSy5hZGRTY29wZShzZWxmKVxuXHRcdHJvb3Quc2NvcGVzLnB1c2goc2VsZilcblx0XHRzZWxmXG5cblx0ZGVmIHdyYXAgc2NvcGVcblx0XHRAcGFyZW50ID0gc2NvcGUuQHBhcmVudFxuXHRcdHNjb3BlLkBwYXJlbnQgPSBzZWxmXG5cdFx0c2VsZlxuXG5cdCMgY2FsbGVkIGZvciBzY29wZXMgdGhhdCBhcmUgbm90IHJlYWwgc2NvcGVzIGluIGpzXG5cdCMgbXVzdCBlbnN1cmUgdGhhdCB0aGUgbG9jYWwgdmFyaWFibGVzIGluc2lkZSBvZiB0aGUgc2NvcGVzIGRvIG5vdFxuXHQjIGNvbGxpZGUgd2l0aCB2YXJpYWJsZXMgaW4gb3V0ZXIgc2NvcGVzIC0tIHJlbmFtZSBpZiBuZWVkZWRcblx0ZGVmIHZpcnR1YWxpemVcblx0XHRzZWxmXG5cblx0ZGVmIHJvb3Rcblx0XHR2YXIgc2NvcGUgPSBzZWxmXG5cdFx0d2hpbGUgc2NvcGVcblx0XHRcdHJldHVybiBzY29wZSBpZiBzY29wZSBpc2EgUm9vdFNjb3BlXG5cdFx0XHRzY29wZSA9IHNjb3BlLnBhcmVudFxuXHRcdHJldHVybiBudWxsXG5cblx0ZGVmIHJlZ2lzdGVyIG5hbWUsIGRlY2wgPSBudWxsLCBvID0ge31cblx0XHQjIEZJWE1FIHJlLXJlZ2lzdGVyaW5nIGEgdmFyaWFibGUgc2hvdWxkIHJlYWxseSByZXR1cm4gdGhlIGV4aXN0aW5nIG9uZVxuXHRcdCMgQWdhaW4sIGhlcmUgd2Ugc2hvdWxkIG5vdCByZWFsbHkgaGF2ZSB0byBkZWFsIHdpdGggc3lzdGVtLWdlbmVyYXRlZCB2YXJzXG5cdFx0IyBCdXQgYWdhaW4sIGl0IGlzIGltcG9ydGFudFxuXG5cdFx0IyBwIFwicmVnaXN0ZXJpbmcge25hbWV9XCJcblx0XHRuYW1lID0gaGVscGVycy5zeW1ib2xpemUobmFtZSlcblxuXHRcdCMgYWxzbyBsb29rIGF0IG91dGVyIHNjb3BlcyBpZiB0aGlzIGlzIG5vdCBjbG9zZWQ/XG5cdFx0dmFyIGV4aXN0aW5nID0gQHZhcm1hcC5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBAdmFybWFwW25hbWVdXG5cdFx0cmV0dXJuIGV4aXN0aW5nIGlmIGV4aXN0aW5nXG5cblx0XHR2YXIgaXRlbSA9IFZhcmlhYmxlLm5ldyhzZWxmLG5hbWUsZGVjbCxvKVxuXHRcdCMgbmVlZCB0byBjaGVjayBmb3IgZHVwbGljYXRlcywgYW5kIGhhbmRsZSB0aGlzIGdyYWNlZnVsbHkgLVxuXHRcdCMgZ29pbmcgdG8gcmVmYWN0b3IgbGF0ZXJcblx0XHRAdmFybWFwW25hbWVdID0gaXRlbSB1bmxlc3MgbzpzeXN0ZW0gIyBkb250IGV2ZW4gYWRkIHRvIHRoZSB2YXJtYXAgaWYgaXQgaXMgYSBzeXN2YXJcblx0XHRyZXR1cm4gaXRlbVxuXG5cdGRlZiBhbm5vdGF0ZSBvYmpcblx0XHRAYW5ub3RhdGlvbnMucHVzaChvYmopXG5cdFx0c2VsZlxuXG5cdCMganVzdCBsaWtlIHJlZ2lzdGVyLCBidXQgd2UgYXV0b21hdGljYWxseSBcblx0ZGVmIGRlY2xhcmUgbmFtZSwgaW5pdCA9IG51bGwsIG8gPSB7fVxuXHRcdHZhciB2YXJpYWJsZSA9IHJlZ2lzdGVyKG5hbWUsbnVsbCxvKVxuXHRcdCMgVE9ETyBjcmVhdGUgdGhlIHZhcmlhYmxlZGVjbGFyYXRpb24gaGVyZSBpbnN0ZWFkP1xuXHRcdCMgaWYgdGhpcyBpcyBhIHN5c3ZhciB3ZSBuZWVkIGl0IHRvIGJlIHJlbmFtZWFibGVcblx0XHR2YXIgZGVjID0gQHZhcnMuYWRkKHZhcmlhYmxlLGluaXQpXG5cdFx0dmFyaWFibGUuZGVjbGFyYXRvciB8fD0gZGVjXG5cdFx0cmV0dXJuIHZhcmlhYmxlXG5cblx0XHQjIHAgXCJkZWNsYXJlIHZhcmlhYmxlIHtuYW1lfSB7b31cIlxuXHRcdCMgaWYgbmFtZSBpc2EgVmFyaWFibGVcblx0XHQjIHAgXCJTQ09QRSBkZWNsYXJlIHZhclwiLmdyZWVuXG5cdFx0bmFtZSA9IGhlbHBlcnMuc3ltYm9saXplKG5hbWUpXG5cdFx0IyB3ZSB3aWxsIHNlZSBoZXJlXG5cdFx0QHZhcnMuYWRkKG5hbWUsaW5pdCkgIyAubGFzdCAtLSBcblx0XHR2YXIgZGVjbCA9IEB2YXJzLmxhc3QgIyBidWcoISlcblx0XHR2YXIgaXRlbVxuXHRcdCMgaXRlbSA9IFZhcmlhYmxlLm5ldyhzZWxmLG5hbWUsZGVjbClcblxuXHRcdCMgaWYgbzpzeXN0ZW1cblx0XHQjIFx0aXRlbSA9IFN5c3RlbVZhcmlhYmxlLm5ldyhzZWxmLG5hbWUsZGVjbCxvKVxuXHRcdCMgXHRkZWNsLnZhcmlhYmxlID0gaXRlbVxuXHRcdCMgZWxzZVxuXHRcdGl0ZW0gPSBWYXJpYWJsZS5uZXcoc2VsZixuYW1lLGRlY2wsbylcblx0XHRkZWNsLnZhcmlhYmxlID0gaXRlbVxuXHRcdGl0ZW0ucmVzb2x2ZSAjIHdoeSBvbiBlYXJ0aCBzaG91bGQgaXQgcmVzb2x2ZSBpbW1lZGlhdGVseT9cblx0XHRcblx0XHQjIGRlY2wudmFyaWFibGUgPSBpdGVtXG5cdFx0IyBpdGVtLnJlc29sdmUgIyB3aHkgb24gZWFydGggc2hvdWxkIGl0IHJlc29sdmUgaW1tZWRpYXRlbHk/XG5cdFx0cmV0dXJuIGl0ZW1cblxuXHRcdCMgc2hvdWxkIGJlIHBvc3NpYmxlIHRvIGZvcmNlLWRlY2xhcmUgZm9yIHRoaXMgc2NvcGUsIG5vP1xuXHRcdCMgaWYgdGhpcyBpcyBhIHN5c3RlbS12YXJpYWJsZSBcblxuXHQjIGRlY2xhcmVzIGEgdmFyaWFibGUgKGhhcyBubyByZWFsIGRlY2xhcmF0aW9uIGJlZm9yZWhhbmQpXG5cblxuXHQjIHdoYXQgYXJlIHRoZSBkaWZmZXJlbmNlcyBoZXJlPyBvbWpcblx0IyB3ZSBvbmx5IG5lZWQgYSB0ZW1wb3JhcnkgdGhpbmcgd2l0aCBkZWZhdWx0cyAtLSB0aGF0IGlzIGFsbFxuXHQjIGNoYW5nZSB0aGVzZSB2YWx1ZXMsIG5vP1xuXHRkZWYgdGVtcG9yYXJ5IHJlZm5vZGUsIG8gPSB7fSwgbmFtZSA9IG51bGxcblxuXHRcdCMgcCBcInJlZ2lzdGVyaW5nIHRlbXBvcmFyeSB7cmVmbm9kZX0ge25hbWV9XCJcblx0XHQjIHJldXNlIHZhcmlhYmxlcyAtLSBobW1cblx0XHRpZiBvOnBvb2xcblx0XHRcdGZvciB2IGluIEB2YXJwb29sXG5cdFx0XHRcdGlmIHYucG9vbCA9PSBvOnBvb2wgJiYgdi5kZWNsYXJhdG9yID09IG51bGxcblx0XHRcdFx0XHRyZXR1cm4gdi5yZXVzZShyZWZub2RlKVxuXG5cdFx0IyBzaG91bGQgb25seSAncmVnaXN0ZXInIGFzIGFoaWRkZW4gdmFyaWFibGUsIG5vP1xuXHRcdCMgaWYgdGhlcmUgYXJlIHJlYWwgbm9kZXMgaW5zaWRlIHRoYXQgdHJpZXMgdG8gcmVmZXIgdG8gdmFyc1xuXHRcdCMgZGVmaW5lZCBpbiBvdXRlciBzY29wZXMsIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoZXkgYXJlIG5vdCBuYW1lZCBhZnRlciB0aGlzXG5cdFx0dmFyIGl0ZW0gPSBTeXN0ZW1WYXJpYWJsZS5uZXcoc2VsZixuYW1lLHJlZm5vZGUsbylcblx0XHRAdmFycG9vbC5wdXNoKGl0ZW0pICMgV0hBVD8gSXQgc2hvdWxkIG5vdCBiZSBpbiB0aGUgcG9vbCB1bmxlc3MgZXhwbGljaXRseSBwdXQgdGhlcmU/XG5cdFx0QHZhcnMucHVzaChpdGVtKSAjIFdBUk4gdmFyaWFibGVzIHNob3VsZCBub3QgZ28gZGlyZWN0bHkgaW50byBhIGRlY2xhcmF0aW9uLWxpc3Rcblx0XHRyZXR1cm4gaXRlbVxuXHRcdCMgcmV0dXJuIHJlZ2lzdGVyKG5hbWUgfHwgXCJfX1wiLG51bGwsc3lzdGVtOiB5ZXMsIHRlbXBvcmFyeTogeWVzKVxuXG5cdFxuXG5cdGRlZiBsb29rdXAgbmFtZVxuXHRcdHZhciByZXQgPSBudWxsXG5cdFx0bmFtZSA9IGhlbHBlcnMuc3ltYm9saXplKG5hbWUpXG5cdFx0aWYgQHZhcm1hcC5oYXNPd25Qcm9wZXJ0eShuYW1lKVxuXHRcdFx0cmV0ID0gQHZhcm1hcFtuYW1lXSBcblx0XHRlbHNlXG5cdFx0XHQjIGxvb2sgdXAgYW55IHBhcmVudCBzY29wZSA/PyBzZWVtcyBva2F5XG5cdFx0XHQjICFpc0Nsb3NlZCAmJiBcblx0XHRcdHJldCA9IHBhcmVudCAmJiBwYXJlbnQubG9va3VwKG5hbWUpXG5cdFx0XHQjIG9yIC0tIG5vdCBhbGwgc2NvcGVzIGhhdmUgYSBwYXJlbnQ/XG5cdFx0XG5cdFx0IyBzaG91bGQgdGhpcyBub3QgaGFwcGVuIGJ5IGl0c2VsZj9cblx0XHQjIGlmICFyZXQgYW5kIFxuXHRcdCNcdHJldCA9IFxuXHRcdCMgcmV0IHx8PSAoZy5sb29rdXAobmFtZSkgaWYgdmFyIGcgPSByb290KVxuXHRcdCMgZyA9IHJvb3Rcblx0XHRyZXRcblxuXHRkZWYgYXV0b2RlY2xhcmUgdmFyaWFibGVcblx0XHR2YXJzLnB1c2godmFyaWFibGUpICMgb25seSBpZiBpdCBkb2VzIG5vdCBleGlzdCBoZXJlISEhXG5cblx0ZGVmIGZyZWUgdmFyaWFibGVcblx0XHQjIHAgXCJmcmVlIHZhcmlhYmxlXCJcblx0XHR2YXJpYWJsZS5mcmVlICMgOm93bmVyID0gbnVsbFxuXHRcdCMgQHZhcnBvb2wucHVzaCh2YXJpYWJsZSlcblx0XHRzZWxmXG5cdFxuXHRkZWYgaXNDbG9zZWRcblx0XHRub1xuXG5cdGRlZiBjbG9zdXJlXG5cdFx0QGNsb3N1cmVcblxuXHRkZWYgZmluYWxpemVcblx0XHRzZWxmXG5cblx0ZGVmIGtsYXNzXG5cdFx0dmFyIHNjb3BlID0gc2VsZlxuXHRcdHdoaWxlIHNjb3BlXG5cdFx0XHRzY29wZSA9IHNjb3BlLnBhcmVudFxuXHRcdFx0cmV0dXJuIHNjb3BlIGlmIHNjb3BlIGlzYSBDbGFzc1Njb3BlXG5cdFx0cmV0dXJuIG51bGxcblxuXHRkZWYgaGVhZFxuXHRcdFtAdmFycyxAcGFyYW1zXVxuXG5cdGRlZiBjIG8gPSB7fVxuXHRcdG86ZXhwcmVzc2lvbiA9IG5vXG5cdFx0IyBuZWVkIHRvIGZpeCB0aGlzXG5cdFx0bm9kZS5ib2R5LmhlYWQgPSBoZWFkXG5cdFx0dmFyIGJvZHkgPSBub2RlLmJvZHkuYyhvKVxuXG5cdFx0IyB2YXIgaGVhZCA9IFtAdmFycyxAcGFyYW1zXS5ibG9jay5jKGV4cHJlc3Npb246IG5vKVxuXHRcdCMgcCBcImhlYWQgZnJvbSBzY29wZSBpcyAoe2hlYWR9KVwiXG5cdFx0IyB2YXIgb3V0ID0gW2hlYWQgb3IgbnVsbCxib2R5XS5mbGF0dGVuX18uY29tcGFjdC5qb2luKFwiXFxuXCIpXG5cdFx0IyBvdXRcblx0XHQjIG91dCA9ICd7JyArIG91dCArIFxuXG5cdGRlZiByZWdpb25cblx0XHRub2RlLmJvZHkucmVnaW9uXG5cblx0ZGVmIGxvY1xuXHRcdG5vZGUubG9jXG5cblx0ZGVmIGR1bXBcblx0XHR2YXIgdmFycyA9IE9iamVjdC5rZXlzKEB2YXJtYXApLm1hcCBkbyB8a3wgXG5cdFx0XHR2YXIgdiA9IEB2YXJtYXBba11cblx0XHRcdHYucmVmZXJlbmNlczpsZW5ndGggPyBkdW1wX18odikgOiBudWxsXG5cblx0XHR2YXIgZGVzYyA9IFxuXHRcdFx0bnI6IEBuclxuXHRcdFx0dHlwZTogc2VsZjpjb25zdHJ1Y3RvcjpuYW1lXG5cdFx0XHRsZXZlbDogKGxldmVsIG9yIDApXG5cdFx0XHR2YXJzOiBjb21wYWN0X18odmFycylcblx0XHRcdGxvYzogbG9jXG5cblx0XHRyZXR1cm4gZGVzY1xuXG5cdGRlZiB0b0pTT05cblx0XHRkdW1wXG5cblx0ZGVmIHRvU3RyaW5nXG5cdFx0XCJ7c2VsZjpjb25zdHJ1Y3RvcjpuYW1lfVwiXG5cdFxuXG4jIFJvb3RTY29wZSBpcyB3cm9uZz8gUmF0aGVyIFRvcFNjb3BlIG9yIFByb2dyYW1TY29wZVxuZXhwb3J0IGNsYXNzIFJvb3RTY29wZSA8IFNjb3BlXG5cblx0cHJvcCB3YXJuaW5nc1xuXHRwcm9wIHNjb3Blc1xuXHRwcm9wIGVudGl0aWVzXG5cblx0ZGVmIGluaXRpYWxpemVcblx0XHRzdXBlclxuXG5cdFx0cmVnaXN0ZXIgJ2dsb2JhbCcsIHNlbGYsIHR5cGU6ICdnbG9iYWwnXG5cdFx0cmVnaXN0ZXIgJ21vZHVsZScsIHNlbGYsIHR5cGU6ICdnbG9iYWwnXG5cdFx0cmVnaXN0ZXIgJ3dpbmRvdycsIHNlbGYsIHR5cGU6ICdnbG9iYWwnXG5cdFx0cmVnaXN0ZXIgJ2RvY3VtZW50Jywgc2VsZiwgdHlwZTogJ2dsb2JhbCdcblx0XHRyZWdpc3RlciAnZXhwb3J0cycsIHNlbGYsIHR5cGU6ICdnbG9iYWwnXG5cdFx0cmVnaXN0ZXIgJ2NvbnNvbGUnLCBzZWxmLCB0eXBlOiAnZ2xvYmFsJ1xuXHRcdHJlZ2lzdGVyICdwcm9jZXNzJywgc2VsZiwgdHlwZTogJ2dsb2JhbCdcblx0XHRyZWdpc3RlciAncGFyc2VJbnQnLCBzZWxmLCB0eXBlOiAnZ2xvYmFsJ1xuXHRcdHJlZ2lzdGVyICdwYXJzZUZsb2F0Jywgc2VsZiwgdHlwZTogJ2dsb2JhbCdcblx0XHRyZWdpc3RlciAnc2V0VGltZW91dCcsIHNlbGYsIHR5cGU6ICdnbG9iYWwnXG5cdFx0cmVnaXN0ZXIgJ3NldEludGVydmFsJywgc2VsZiwgdHlwZTogJ2dsb2JhbCdcblx0XHRyZWdpc3RlciAnY2xlYXJUaW1lb3V0Jywgc2VsZiwgdHlwZTogJ2dsb2JhbCdcblx0XHRyZWdpc3RlciAnY2xlYXJJbnRlcnZhbCcsIHNlbGYsIHR5cGU6ICdnbG9iYWwnXG5cdFx0cmVnaXN0ZXIgJ19fZGlybmFtZScsIHNlbGYsIHR5cGU6ICdnbG9iYWwnXG5cblx0XHQjIHByZXJlZ2lzdGVyIGdsb2JhbCBzcGVjaWFsIHZhcmlhYmxlcyBoZXJlXG5cdFx0QHdhcm5pbmdzID0gW11cblx0XHRAc2NvcGVzICAgPSBbXVxuXHRcdEBoZWxwZXJzICA9IFtdXG5cdFx0QGVudGl0aWVzID0gRW50aXRpZXMubmV3KHNlbGYpXG5cdFx0QGhlYWQgPSBbQHZhcnNdXG5cblx0ZGVmIGNvbnRleHRcblx0XHRAY29udGV4dCB8fD0gUm9vdFNjb3BlQ29udGV4dC5uZXcoc2VsZilcblxuXHRkZWYgdGFnQ29udGV4dFBhdGhcblx0XHRAdGFnQ29udGV4dFBhdGggfHw9IFwidGFnJFwiXG5cblx0ZGVmIGxvb2t1cCBuYW1lXG5cdFx0IyBwIFwibG9va3VwIGZpbGVzY29wZVwiXG5cdFx0bmFtZSA9IGhlbHBlcnMuc3ltYm9saXplKG5hbWUpXG5cdFx0QHZhcm1hcFtuYW1lXSBpZiBAdmFybWFwLmhhc093blByb3BlcnR5KG5hbWUpXG5cblx0ZGVmIHZpc2l0XG5cdFx0U1RBQ0suYWRkU2NvcGUoc2VsZilcblx0XHRzZWxmXG5cblx0ZGVmIGhlbHBlciB0eXAsIHZhbHVlXG5cdFx0IyBsb2cgXCJhZGQgaGVscGVyXCIsdHlwLHZhbHVlXG5cdFx0aWYgQGhlbHBlcnMuaW5kZXhPZih2YWx1ZSkgPT0gLTFcblx0XHRcdEBoZWxwZXJzLnB1c2godmFsdWUpXG5cdFx0XHRAaGVhZC51bnNoaWZ0KHZhbHVlKVxuXG5cdFx0cmV0dXJuIHNlbGZcblxuXHRkZWYgaGVhZFxuXHRcdEBoZWFkXG5cblx0ZGVmIHdhcm4gZGF0YVxuXHRcdCMgaGFja3lcblx0XHRkYXRhOm5vZGUgPSBudWxsXG5cdFx0IyBwIFwid2FybmluZ1wiLEpTT04uc3RyaW5naWZ5KGRhdGEpXG5cdFx0QHdhcm5pbmdzLnB1c2goZGF0YSlcblx0XHRzZWxmXG5cblx0ZGVmIGR1bXBcblx0XHR2YXIgb2JqID0ge3dhcm5pbmdzOiBkdW1wX18oQHdhcm5pbmdzKX1cblxuXHRcdGlmIE9QVFM6YW5hbHlzaXM6c2NvcGVzXG5cdFx0XHR2YXIgc2NvcGVzID0gQHNjb3Blcy5tYXAofHN8IHMuZHVtcClcblx0XHRcdHNjb3Blcy51bnNoaWZ0KHN1cGVyLmR1bXApXG5cdFx0XHRvYmo6c2NvcGVzID0gc2NvcGVzIFxuXG5cdFx0aWYgT1BUUzphbmFseXNpczplbnRpdGllc1xuXHRcdFx0b2JqOmVudGl0aWVzID0gQGVudGl0aWVzXG5cblx0XHRyZXR1cm4gb2JqXG5cdFx0XG5cbmV4cG9ydCBjbGFzcyBDbGFzc1Njb3BlIDwgU2NvcGVcblxuXHRkZWYgbmFtZXBhdGhcblx0XHRAbm9kZS5uYW1lcGF0aFxuXHRcblxuXHQjIGNhbGxlZCBmb3Igc2NvcGVzIHRoYXQgYXJlIG5vdCByZWFsIHNjb3BlcyBpbiBqc1xuXHQjIG11c3QgZW5zdXJlIHRoYXQgdGhlIGxvY2FsIHZhcmlhYmxlcyBpbnNpZGUgb2YgdGhlIHNjb3BlcyBkbyBub3Rcblx0IyBjb2xsaWRlIHdpdGggdmFyaWFibGVzIGluIG91dGVyIHNjb3BlcyAtLSByZW5hbWUgaWYgbmVlZGVkXG5cdGRlZiB2aXJ0dWFsaXplXG5cdFx0IyBjb25zb2xlLmxvZyBcInZpcnR1YWxpemluZyBDbGFzc1Njb3BlXCJcblx0XHR2YXIgdXAgPSBwYXJlbnRcblx0XHRmb3Igb3duIGssdiBvZiBAdmFybWFwXG5cdFx0XHR0cnVlXG5cdFx0XHR2LnJlc29sdmUodXAseWVzKSAjIGZvcmNlIG5ldyByZXNvbHZlXG5cdFx0c2VsZlxuXG5cdGRlZiBpc0Nsb3NlZFxuXHRcdHllc1xuXG5leHBvcnQgY2xhc3MgVGFnU2NvcGUgPCBDbGFzc1Njb3BlXG5cbmV4cG9ydCBjbGFzcyBDbG9zdXJlU2NvcGUgPCBTY29wZVxuXG5leHBvcnQgY2xhc3MgRnVuY3Rpb25TY29wZSA8IFNjb3BlXG5cbmV4cG9ydCBjbGFzcyBNZXRob2RTY29wZSA8IFNjb3BlXG5cdFxuXG5cdGRlZiBpc0Nsb3NlZFxuXHRcdHllc1xuXG5leHBvcnQgY2xhc3MgTGFtYmRhU2NvcGUgPCBTY29wZVxuXG5cdGRlZiBjb250ZXh0XG5cblx0XHQjIHdoZW4gYWNjZXNzaW5nIHRoZSBvdXRlciBjb250ZXh0IHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgaXQgaXMgY2FjaGVkXG5cdFx0IyBzbyB0aGlzIGlzIHdyb25nIC0gYnV0IHRlbXAgb2theVxuXHRcdEBjb250ZXh0IHx8PSBwYXJlbnQuY29udGV4dC5yZWZlcmVuY2Uoc2VsZilcblxuZXhwb3J0IGNsYXNzIEZsb3dTY29wZSA8IFNjb3BlXG5cblx0IyB0aGVzZSBoYXZlIG5vIHBhcmFtcyB0aGVtc2VsdmVzLCByZWZlciB0byBvdXRlciBzY29wZXMgLS0gaGptbVxuXHRkZWYgcGFyYW1zXG5cdFx0QHBhcmVudC5wYXJhbXMgaWYgQHBhcmVudFxuXG5cdGRlZiByZWdpc3RlciBuYW1lLCBkZWNsID0gbnVsbCwgbyA9IHt9XG5cdFx0aWYgbzp0eXBlICE9ICdsZXQnIGFuZCAoY2xvc3VyZSAhPSBzZWxmKVxuXHRcdFx0aWYgdmFyIGZvdW5kID0gbG9va3VwKG5hbWUpXG5cdFx0XHRcdCMgcCBcImFscmVhZHkgZm91bmQgdmFyaWFibGUge2ZvdW5kLnR5cGV9XCJcblx0XHRcdFx0aWYgZm91bmQudHlwZSA9PSAnbGV0J1xuXHRcdFx0XHRcdHAgXCJ7bmFtZX0gYWxyZWFkeSBleGlzdHMgYXMgYSBibG9jay12YXJpYWJsZSB7ZGVjbH1cIlxuXHRcdFx0XHRcdCMgVE9ETyBzaG91bGQgdGhyb3cgZXJyb3IgaW5zdGVhZFxuXHRcdFx0XHRcdGRlY2wud2FybiBcIlZhcmlhYmxlIGFscmVhZHkgZXhpc3RzIGluIGJsb2NrXCIgaWYgZGVjbFxuXHRcdFx0XHRcdCMgcm9vdC53YXJuIG1lc3NhZ2U6IFwiSG9seSBzaGl0XCJcblx0XHRcdFx0IyBpZiBmb3VuZC5cblx0XHRcdCMgcCBcIkZsb3dTY29wZSByZWdpc3RlciB2YXIgLS0gZG8gaXQgcmlnaHQgaW4gdGhlIG91dGVyIHNjb3BlXCJcblx0XHRcdGNsb3N1cmUucmVnaXN0ZXIobmFtZSxkZWNsLG8pXG5cdFx0ZWxzZVxuXHRcdFx0IyBwIFwiUmVnaXN0ZXIgbG9jYWwgdmFyaWFibGUgZm9yIEZsb3dTY29wZSB7bmFtZX1cIlxuXHRcdFx0IyBvOmNsb3N1cmUgPSBwYXJlbnRcblx0XHRcdCMgcCBcIkZsb3dTY29wZSByZWdpc3RlclwiLCBhcmd1bWVudHNcblx0XHRcdHN1cGVyKG5hbWUsZGVjbCxvKVxuXG5cdCMgRklYTUUgc2hvdWxkIG92ZXJyaWRlIHRlbXBvcmFyeSBhcyB3ZWxsXG5cblx0ZGVmIGF1dG9kZWNsYXJlIHZhcmlhYmxlXG5cdFx0cGFyZW50LmF1dG9kZWNsYXJlKHZhcmlhYmxlKVxuXG5cdGRlZiBjbG9zdXJlXG5cdFx0IyByYXRoZXIgYWxsIHRoZSB3YXk/XG5cdFx0QHBhcmVudC5jbG9zdXJlICMgdGhpcyBpcyBpbXBvcnRhbnQ/XG5cblx0ZGVmIGNvbnRleHRcblx0XHQjIGlmIHdlIGFyZSB3cmFwcGluZyBpbiBhbiBleHByZXNzaW9uIC0gd2UgZG8gbmVlZCB0byBhZGQgYSByZWZlcmVuY2Vcblx0XHQjIEByZWZlcmVuY2VkID0geWVzXG5cdFx0cGFyZW50LmNvbnRleHRcblx0XHQjIHVzdWFsbHkgLSBpZiB0aGUgcGFyZW50IHNjb3BlIGlzIGEgY2xvc2VkIHNjb3BlIHdlIGRvbnQgcmVhbGx5IG5lZWRcblx0XHQjIHRvIGZvcmNlIGEgcmVmZXJlbmNlXG5cdFx0IyBAY29udGV4dCB8fD0gcGFyZW50LmNvbnRleHQucmVmZXJlbmNlKHNlbGYpXG5cbmV4cG9ydCBjbGFzcyBDYXRjaFNjb3BlIDwgRmxvd1Njb3BlXG5cbmV4cG9ydCBjbGFzcyBXaGlsZVNjb3BlIDwgRmxvd1Njb3BlXG5cblx0ZGVmIGF1dG9kZWNsYXJlIHZhcmlhYmxlXG5cdFx0dmFycy5wdXNoKHZhcmlhYmxlKVxuXG5leHBvcnQgY2xhc3MgRm9yU2NvcGUgPCBGbG93U2NvcGVcblx0XG5cdGRlZiBhdXRvZGVjbGFyZSB2YXJpYWJsZVxuXHRcdHZhcnMucHVzaCh2YXJpYWJsZSlcblx0XHQjIHBhcmVudC5hdXRvZGVjbGFyZSh2YXJpYWJsZSlcblxuXHQjIGRlZiBjbG9zdXJlXG5cdCMgXHRzZWxmXG5cbmV4cG9ydCBjbGFzcyBJZlNjb3BlIDwgRmxvd1Njb3BlXG5cblx0ZGVmIHRlbXBvcmFyeSByZWZub2RlLCBvID0ge30sIG5hbWUgPSBudWxsXG5cdFx0cGFyZW50LnRlbXBvcmFyeShyZWZub2RlLG8sbmFtZSlcblxuZXhwb3J0IGNsYXNzIEJsb2NrU2NvcGUgPCBGbG93U2NvcGVcblxuXHRkZWYgdGVtcG9yYXJ5IHJlZm5vZGUsIG8gPSB7fSwgbmFtZSA9IG51bGxcblx0XHRwYXJlbnQudGVtcG9yYXJ5KHJlZm5vZGUsbyxuYW1lKVxuXG5cdGRlZiByZWdpb25cblx0XHRub2RlLnJlZ2lvblxuXG4jIGxpdmVzIGluIHNjb3BlIC0tIHJlYWxseSBhIG5vZGU/Pz9cbmV4cG9ydCBjbGFzcyBWYXJpYWJsZSA8IE5vZGVcblxuXHRwcm9wIHNjb3BlXG5cdHByb3AgbmFtZVxuXHRwcm9wIGFsaWFzXG5cdHByb3AgdHlwZVxuXHRwcm9wIG9wdGlvbnNcblx0cHJvcCBpbml0aWFsaXplZFxuXHRwcm9wIGRlY2xhcmVkXG5cdHByb3AgZGVjbGFyYXRvclxuXHRwcm9wIGF1dG9kZWNsYXJlXG5cdHByb3AgcmVmZXJlbmNlc1xuXHRwcm9wIGV4cG9ydFxuXG5cdGRlZiBwb29sXG5cdFx0bnVsbFxuXG5cdGRlZiBpbml0aWFsaXplIHNjb3BlLCBuYW1lLCBkZWNsLCBvXG5cdFx0QHJlZiA9IFNUQUNLLkBjb3VudGVyKytcblx0XHRAYyA9IG51bGxcblx0XHRAc2NvcGUgPSBzY29wZVxuXHRcdEBuYW1lICA9IG5hbWVcblx0XHRAYWxpYXMgPSBudWxsXG5cdFx0QGluaXRpYWxpemVkICAgID0geWVzXG5cdFx0QGRlY2xhcmF0b3IgIFx0PSBkZWNsXG5cdFx0QGF1dG9kZWNsYXJlIFx0PSBub1xuXHRcdEBkZWNsYXJlZFx0XHQ9IG8gYW5kIG86ZGVjbGFyZWQgfHwgbm9cblx0XHRAcmVzb2x2ZWRcdFx0PSBub1xuXHRcdEBvcHRpb25zIFx0XHQ9IG8gfHwge31cblx0XHRAdHlwZVx0XHRcdD0gbyBhbmQgbzp0eXBlIHx8ICd2YXInICMgd2hhdCBhYm91dCBsZXQgaGVyZT1cblx0XHRAZXhwb3J0XHRcdFx0PSBub1xuXHRcdEByZWZlcmVuY2VzIFx0PSBbXSAjIG9ubHkgbmVlZGVkIHdoZW4gcHJvZmlsaW5nXG5cdFx0QGFzc2lnbm1lbnRzIFx0PSBbXVxuXHRcdHNlbGZcblxuXHRkZWYgY2xvc3VyZVxuXHRcdEBzY29wZS5jbG9zdXJlXG5cblx0ZGVmIGFzc2lnbm1lbnRzXG5cdFx0QGFzc2lnbm1lbnRzXG5cblx0IyBIZXJlIHdlIGNhbiBjb2xsZWN0IGxvdHMgb2YgdHlwZS1pbmZvIGFib3V0IHZhcmlhYmxlc1xuXHQjIGFuZCBzaG93IHdhcm5pbmdzIC8gZ2l2ZSBhZHZpY2UgaWYgdmFyaWFibGVzIGFyZSBhbWJpZ3VvdXMgZXRjXG5cdGRlZiBhc3NpZ25lZCB2YWwsIHNvdXJjZVxuXHRcdEBhc3NpZ25tZW50cy5wdXNoKHZhbClcblx0XHQjIHAgXCJWYXJpYWJsZSB3YXMgYXNzaWduZWQge3ZhbH1cIlxuXHRcdGlmIHZhbCBpc2EgQXJyXG5cdFx0XHQjIGp1c3QgZm9yIHRlc3RpbmcgcmVhbGx5XG5cdFx0XHRAaXNBcnJheSA9IHllc1xuXHRcdGVsc2Vcblx0XHRcdEBpc0FycmF5ID0gbm9cblx0XHRzZWxmXG5cblx0ZGVmIHJlc29sdmUgc2NvcGUgPSBzY29wZSwgZm9yY2UgPSBub1xuXHRcdHJldHVybiBzZWxmIGlmIEByZXNvbHZlZCBhbmQgIWZvcmNlXG5cblx0XHRAcmVzb2x2ZWQgPSB5ZXNcblx0XHR2YXIgY2xvc3VyZSA9IEBzY29wZS5jbG9zdXJlXG5cdFx0dmFyIGl0ZW0gPSBzY29wZS5sb29rdXAoQG5hbWUpXG5cblx0XHQjIGlmIHRoaXMgaXMgYSBsZXQtZGVmaW5pdGlvbiBpbnNpZGUgYSB2aXJ0dWFsIHNjb3BlIHdlIGRvIG5lZWRcblx0XHQjIFxuXHRcdGlmIEBzY29wZSAhPSBjbG9zdXJlIGFuZCBAdHlwZSA9PSAnbGV0JyAjIG9yIGlmIGl0IGlzIGEgc3lzdGVtLXZhcmlhYmxlXG5cdFx0XHQjIHAgXCJzY29wZSBpcyBub3QgdGhlIGNsb3N1cmUgLS0gbmVlZCB0byByZXNvbHZlIHtAbmFtZX1cIlxuXHRcdFx0aXRlbSA9IGNsb3N1cmUubG9va3VwKEBuYW1lKVxuXG5cdFx0XHQjIHdlIG5vdyBuZWVkIHRvIGVuc3VyZSB0aGF0IHRoaXMgdmFyaWFibGUgaXMgdW5pcXVlIGluc2lkZVxuXHRcdFx0IyB0aGUgd2hvbGUgY2xvc3VyZS5cblx0XHRcdHNjb3BlID0gY2xvc3VyZVxuXG5cdFx0IyBwIFwic2NvcGUgaXMgbm90IHRoZSBjbG9zdXJlIC0tIG5lZWQgdG8gcmVzb2x2ZSB7QG5hbWV9IHtAdHlwZX1cIlxuXG5cdFx0aWYgaXRlbSA9PSBzZWxmXG5cdFx0XHRzY29wZS52YXJtYXBbQG5hbWVdID0gc2VsZlxuXHRcdFx0cmV0dXJuIHNlbGZcblxuXHRcdCMgcCBcIm5lZWQgdG8gcmVzb2x2ZSFcIi5jeWFuXG5cdFx0ZWxpZiBpdGVtXG5cdFx0XHQjIHAgXCJ2YXJpYWJsZSBhbHJlYWR5IGV4aXN0cyB7QG5hbWV9XCJcblxuXHRcdFx0IyBwb3NzaWJseSByZWRlZmluZSB0aGlzIGluc2lkZSwgdXNlIGl0IG9ubHkgaW4gdGhpcyBzY29wZVxuXHRcdFx0IyBpZiB0aGUgaXRlbSBpcyBkZWZpbmVkIGluIGFuIG91dGVyIHNjb3BlIC0gd2UgcmVzZXJ2ZSB0aGVcblx0XHRcdGlmIGl0ZW0uc2NvcGUgIT0gc2NvcGUgJiYgKG9wdGlvbnM6bGV0IG9yIEB0eXBlID09ICdsZXQnKVxuXHRcdFx0XHQjIHAgXCJvdmVycmlkZSB2YXJpYWJsZSBpbnNpZGUgdGhpcyBzY29wZSB7QG5hbWV9XCJcblx0XHRcdFx0c2NvcGUudmFybWFwW0BuYW1lXSA9IHNlbGZcblxuXHRcdFx0IyBkaWZmZXJlbnQgcnVsZXMgZm9yIGRpZmZlcmVudCB2YXJpYWJsZXM/XG5cdFx0XHRpZiBAb3B0aW9uczpwcm94eVxuXHRcdFx0XHQjIHAgXCJpcyBwcm94eSAtLSBubyBuZWVkIHRvIGNoYW5nZSBuYW1lISEhIHtuYW1lfVwiLmN5YW5cblx0XHRcdFx0eWVzXG5cdFx0XHRlbHNlXG5cdFx0XHRcdHZhciBpID0gMFxuXHRcdFx0XHR2YXIgb3JpZyA9IEBuYW1lXG5cdFx0XHRcdCMgaXQgaXMgdGhlIGNsb3N1cmUgdGhhdCB3ZSBzaG91bGQgdXNlXG5cdFx0XHRcdHdoaWxlIHNjb3BlLmxvb2t1cChAbmFtZSlcblx0XHRcdFx0XHRAbmFtZSA9IFwie29yaWd9e2kgKz0gMX1cIlxuXG5cdFx0IyBpbmVmZmljaWVudCBkb3VibGUgc2V0dGluZ1xuXHRcdHNjb3BlLnZhcm1hcFtAbmFtZV0gPSBzZWxmXG5cdFx0Y2xvc3VyZS52YXJtYXBbQG5hbWVdID0gc2VsZlxuXHRcdHJldHVybiBzZWxmXG5cdFx0IyBwIFwicmVzb2x2ZSB2YXJpYWJsZVwiLmN5YW5cblxuXHRkZWYgcmVmZXJlbmNlXG5cdFx0c2VsZlxuXG5cdGRlZiBub2RlXG5cdFx0c2VsZlxuXG5cdGRlZiB0cmF2ZXJzZVxuXHRcdCMgTk9ERVMucHVzaChzZWxmKVxuXHRcdHNlbGZcblxuXHRkZWYgZnJlZSByZWZcblx0XHQjIHAgXCJmcmVlIHZhcmlhYmxlIVwiXG5cdFx0QGRlY2xhcmF0b3IgPSBudWxsXG5cdFx0c2VsZlxuXG5cdGRlZiByZXVzZSByZWZcblx0XHRAZGVjbGFyYXRvciA9IHJlZlxuXHRcdHNlbGZcblxuXHRkZWYgcHJveHkgcGFyLCBpbmRleFxuXHRcdEBwcm94eSA9IFtwYXIsaW5kZXhdXG5cdFx0c2VsZlxuXG5cdGRlZiByZWZjb3VudFxuXHRcdEByZWZlcmVuY2VzOmxlbmd0aFxuXG5cdGRlZiBjXG5cdFx0cmV0dXJuIEBjIGlmIEBjXG5cdFx0IyBvcHRpb25zIC0gcHJveHk/P1xuXHRcdGlmIEBwcm94eVxuXHRcdFx0IyBwIFwidmFyIGlzIHByb3hpZWQhXCIsQHByb3h5XG5cdFx0XHRAYyA9IEBwcm94eVswXS5jICsgJ1snICsgQHByb3h5WzFdLmMgKyAnXSdcblx0XHRlbHNlXG5cdFx0XHRyZXNvbHZlIHVubGVzcyBAcmVzb2x2ZWRcblx0XHRcdHZhciB2ID0gKGFsaWFzIG9yIG5hbWUpXG5cdFx0XHRAYyA9IHR5cGVvZiB2ID09ICdzdHJpbmcnID8gdiA6IHYuY1xuXHRcdFx0IyBhbGxvdyBjZXJ0YWluIHJlc2VydmVkIHdvcmRzXG5cdFx0XHQjIHNob3VsZCB3YXJuIG9uIG90aGVycyB0aG91Z2ggKCEhISlcblx0XHRcdCMgaWYgQGMgPT0gJ25ldydcblx0XHRcdCMgXHRAYyA9ICdfbmV3J1xuXHRcdFx0IyBcdCMgc2hvdWxkIGhhcHBlbiBhdCBlYXJsaWVyIHN0YWdlIHRvXG5cdFx0XHQjIFx0IyBnZXQgYXJvdW5kIG5hbWluZyBjb252ZW50aW9uc1xuXHRcdFx0QGMgPSBcIntjfSRcIiBpZiBSRVNFUlZFRF9SRUdFWC50ZXN0KEBjKSAjIEBjLm1hdGNoKC9eKGRlZmF1bHQpJC8pXG5cdFx0cmV0dXJuIEBjXG5cblx0IyB2YXJpYWJsZXMgc2hvdWxkIHByb2JhYmx5IGluaGVyaXQgZnJvbSBub2RlKCEpXG5cdGRlZiBjb25zdW1lIG5vZGVcblx0XHQjIHAgXCJ2YXJpYWJsZSBhc3NpZ25pZnkhISFcIlxuXHRcdHJldHVybiBzZWxmXG5cblx0IyB0aGlzIHNob3VsZCBvbmx5IGdlbmVyYXRlIHRoZSBhY2Nlc3NvcnMgLSBub3QgZGFlbCB3aXRoIHJlZmVyZW5jZXNcblx0ZGVmIGFjY2Vzc29yIHJlZlxuXHRcdHZhciBub2RlID0gTG9jYWxWYXJBY2Nlc3MubmV3KFwiLlwiLG51bGwsc2VsZikgIyB0aGlzIGlzIGp1c3Qgd3JvbmcgLi4gc2hvdWxkIG5vdCBiZSBhIHJlZ3VsYXIgYWNjZXNzb3Jcblx0XHQjIEByZWZlcmVuY2VzLnB1c2goW3JlZixlbF0pIGlmIHJlZiAjIHdlaXJkIHRlbXAgZm9ybWF0XG5cdFx0cmV0dXJuIG5vZGVcblxuXHRkZWYgYXNzaWdubWVudCB2YWxcblx0XHRBc3NpZ24ubmV3KCc9JyxzZWxmLHZhbClcblxuXHRkZWYgYWRkUmVmZXJlbmNlIHJlZlxuXHRcdGlmIHJlZiBpc2EgSWRlbnRpZmllclxuXHRcdFx0cmVmLnJlZmVyZW5jZXMoc2VsZilcblxuXHRcdGlmIHJlZjpyZWdpb24gYW5kIHJlZi5yZWdpb25cblx0XHRcdEByZWZlcmVuY2VzLnB1c2gocmVmKVxuXG5cdFx0IyBwIFwicmVmZXJlbmNlIGlzIHtyZWY6cmVnaW9uIGFuZCByZWYucmVnaW9ufVwiXG5cdFx0c2VsZlxuXG5cdGRlZiBhdXRvZGVjbGFyZVxuXHRcdHJldHVybiBzZWxmIGlmIEBkZWNsYXJlZFxuXHRcdCMgcCBcInZhcmlhYmxlIHNob3VsZCBhdXRvZGVjbGFyZSghKSB7bmFtZX1cIlxuXHRcdEBhdXRvZGVjbGFyZSA9IHllc1xuXHRcdHNjb3BlLmF1dG9kZWNsYXJlKHNlbGYpXG5cdFx0QGRlY2xhcmVkID0geWVzXG5cdFx0c2VsZlxuXG5cdGRlZiBwcmVkZWNsYXJlZFxuXHRcdEBkZWNsYXJlZCA9IHllc1xuXHRcdHNlbGZcblx0XHRcblxuXHRkZWYgdG9TdHJpbmdcblx0XHRTdHJpbmcobmFtZSlcblxuXHRkZWYgZHVtcCB0eXBcblx0XHR2YXIgbmFtZSA9IG5hbWVcblx0XHRyZXR1cm4gbnVsbCBpZiBuYW1lWzBdLm1hdGNoKC9bQS1aXS8pXG5cdFx0IyBjb25zb2xlLmxvZyBcImR1bXAgdmFyaWFibGUgb2YgdHlwZSB7dHlwZX0gLSB7bmFtZX1cIlxuXHRcdHJldHVybiB7XG5cdFx0XHR0eXBlOiB0eXBlXG5cdFx0XHRuYW1lOiBuYW1lXG5cdFx0XHRyZWZzOiBkdW1wX18oQHJlZmVyZW5jZXMsIHR5cClcblx0XHR9XG5cblxuZXhwb3J0IGNsYXNzIFN5c3RlbVZhcmlhYmxlIDwgVmFyaWFibGVcblx0XG5cdGRlZiBwb29sXG5cdFx0QG9wdGlvbnM6cG9vbFxuXHRcdFxuXHQjIHdlaXJkIG5hbWUgZm9yIHRoaXNcblx0ZGVmIHByZWRlY2xhcmVkXG5cdFx0IyBwIFwicmVtb3ZlIHZhciBmcm9tIHNjb3BlKCEpXCJcblx0XHRzY29wZS52YXJzLnJlbW92ZShzZWxmKVxuXHRcdHNlbGZcblx0XG5cdGRlZiByZXNvbHZlXG5cdFx0cmV0dXJuIHNlbGYgaWYgQHJlc29sdmVkIHx8IEBuYW1lXG5cdFx0IyBwIFwiUkVTT0xWRSBTWVNURU0gVkFSSUFCTEVcIi5yZWRcblx0XHRAcmVzb2x2ZWQgPSB5ZXNcblx0XHQjIHVubGVzcyBAbmFtZVxuXHRcdCMgYWRkcyBhIHZlcnkgcmFuZG9tIGluaXRpYWwgbmFtZVxuXHRcdCMgdGhlIGF1dG8tbWFnaWNhbCBnb2VzIGxhc3QsIG9yIGF0IGxlYXN0LCBwb3NzaWJseSByZXVzZSBvdGhlciBuYW1lc1xuXHRcdCMgXCIke01hdGguZmxvb3IoTWF0aC5yYW5kb20gKiAxMDAwKX1cIlxuXG5cdFx0dmFyIHR5cCA9IEBvcHRpb25zOnBvb2xcblx0XHR2YXIgbmFtZXMgPSBbXS5jb25jYXQoQG9wdGlvbnM6bmFtZXMpXG5cdFx0dmFyIGFsdCA9IG51bGxcblx0XHR2YXIgbm9kZSA9IG51bGxcblxuXHRcdHZhciBzY29wZSA9IHNlbGYuc2NvcGVcblxuXHRcdGlmIHR5cCA9PSAndGFnJ1xuXHRcdFx0dmFyIGkgPSAwXG5cdFx0XHR3aGlsZSAhQG5hbWVcblx0XHRcdFx0dmFyIGFsdCA9IFwidHtpKyt9XCJcblx0XHRcdFx0QG5hbWUgPSBhbHQgdW5sZXNzIHNjb3BlLmxvb2t1cChhbHQpXG5cblx0XHRlbGlmIHR5cCA9PSAnaXRlcidcblx0XHRcdG5hbWVzID0gWydhcnlfXycsJ2FyeV8nLCdjb2xsJywnYXJyYXknLCdpdGVtcycsJ2FyeSddXG5cblx0XHRlbGlmIHR5cCA9PSAndmFsJ1xuXHRcdFx0bmFtZXMgPSBbJ3ZfJ11cblxuXHRcdGVsaWYgdHlwID09ICdhcmd1bWVudHMnXG5cdFx0XHRuYW1lcyA9IFsnJF8nLCckMCddXG5cblx0XHRlbGlmIHR5cCA9PSAna2V5cGFycydcblx0XHRcdG5hbWVzID0gWydvcHRzJywnb3B0aW9ucycsJ3BhcnMnXVxuXG5cdFx0ZWxpZiB0eXAgPT0gJ2NvdW50ZXInXG5cdFx0XHRuYW1lcyA9IFsnaV9fJywnaV8nLCdrJywnaicsJ2knXVxuXG5cdFx0ZWxpZiB0eXAgPT0gJ2xlbidcblx0XHRcdG5hbWVzID0gWydsZW5fXycsJ2xlbl8nLCdsZW4nXVxuXG5cdFx0ZWxpZiB0eXAgPT0gJ2xpc3QnXG5cdFx0XHRuYW1lcyA9IFsndG1wbGlzdF8nLCd0bXBsaXN0JywndG1wJ11cblx0XHQjIG9yIGlmIHR5cGUgcGxhY2Vob2xkZXIgLyBjYWNoZXIgKGFkZCAwKVxuXG5cdFx0d2hpbGUgIUBuYW1lICYmIGFsdCA9IG5hbWVzLnBvcFxuXHRcdFx0QG5hbWUgPSBhbHQgdW5sZXNzIHNjb3BlLmxvb2t1cChhbHQpXG5cblx0XHRpZiAhQG5hbWUgYW5kIEBkZWNsYXJhdG9yXG5cdFx0XHRpZiBub2RlID0gZGVjbGFyYXRvci5ub2RlXG5cdFx0XHRcdG5hbWVzLnB1c2goYWxpYXMgKyBcIl9cIikgaWYgdmFyIGFsaWFzID0gbm9kZS5hbGlhc1xuXG5cdFx0d2hpbGUgIUBuYW1lICYmIGFsdCA9IG5hbWVzLnBvcFxuXHRcdFx0QG5hbWUgPSBhbHQgdW5sZXNzIHNjb3BlLmxvb2t1cChhbHQpXG5cblx0XHQjIHAgXCJzdWdnZXN0ZWQgbmFtZXMge25hbWVzLmpvaW4oXCIgLCBcIil9IHtub2RlfVwiLmN5YW5cblx0XHQjICBNYXRoLmZsb29yKE1hdGgucmFuZG9tICogMTAwMClcblx0XHRAbmFtZSB8fD0gXCIke3Njb3BlLmNvdW50ZXIgKz0gMX1cIlxuXHRcdCMgcCBcIm5hbWUgZm9yIHZhcmlhYmxlIGlzIHtAbmFtZX1cIlxuXHRcdHNjb3BlLnZhcm1hcFtAbmFtZV0gPSBzZWxmXG5cdFx0c2VsZlxuXG5cdGRlZiBuYW1lXG5cdFx0cmVzb2x2ZVxuXHRcdEBuYW1lXG5cblxuZXhwb3J0IGNsYXNzIFNjb3BlQ29udGV4dCA8IE5vZGVcblxuXHRwcm9wIHNjb3BlXG5cdHByb3AgdmFsdWVcblxuXHRkZWYgaW5pdGlhbGl6ZSBzY29wZSwgdmFsdWVcblx0XHRAc2NvcGUgPSBzY29wZVxuXHRcdEB2YWx1ZSA9IHZhbHVlXG5cdFx0QHJlZmVyZW5jZSA9IG51bGxcblx0XHRzZWxmXG5cblx0ZGVmIG5hbWVwYXRoXG5cdFx0QHNjb3BlLm5hbWVwYXRoXG5cblx0IyBpbnN0ZWFkIG9mIGFsbCB0aGVzZSByZWZlcmVuY2VzIHdlIHNob3VsZCBwcm9iYWJseVxuXHQjIGp1c3QgcmVnaXN0ZXIgd2hlbiBpdCBpcyBhY2Nlc3NlZCAvIGxvb2tlZCB1cCBmcm9tXG5cdCMgYSBkZWVwZXIgZnVuY3Rpb24tc2NvcGUsIGFuZCB3aGVuIGl0IGlzLCB3ZSBzaG91bGRcblx0IyByZWdpc3RlciB0aGUgdmFyaWFibGUgaW4gc2NvcGUsIGFuZCB0aGVuIHN0YXJ0IHRvXG5cdCMgdXNlIHRoYXQgZm9yIGZ1cnRoZXIgcmVmZXJlbmNlcy4gTWlnaHQgY2xlYW4gdGhpbmdzXG5cdCMgdXAgZm9yIHRoZSBjYXNlcyB3aGVyZSB3ZSBoYXZlIHlldCB0byBkZWNpZGUgdGhlXG5cdCMgbmFtZSBvZiB0aGUgdmFyaWFibGUgZXRjP1xuXG5cdGRlZiByZWZlcmVuY2Vcblx0XHQjIHAgXCJwIHJlZmVyZW5jZSB7U1RBQ0suc2NvcGluZ31cIlxuXHRcdCMgc2hvdWxkIGJlIGEgc3BlY2lhbCBjb250ZXh0LXZhcmlhYmxlISEhXG5cdFx0QHJlZmVyZW5jZSB8fD0gc2NvcGUuZGVjbGFyZShcInNlbGZcIixUaGlzLm5ldylcblxuXHRkZWYgY1xuXHRcdHZhciB2YWwgPSBAdmFsdWUgfHwgQHJlZmVyZW5jZVxuXHRcdCh2YWwgPyB2YWwuYyA6IFwidGhpc1wiKVxuXG5cdGRlZiBjYWNoZVxuXHRcdHNlbGZcblxuZXhwb3J0IGNsYXNzIFJvb3RTY29wZUNvbnRleHQgPCBTY29wZUNvbnRleHRcblxuXHQjIGRlZiByZWZlcmVuY2Ugc2NvcGVcblx0IyBcdHNlbGZcblxuXHRkZWYgYyBvXG5cdFx0IyByZXR1cm4gXCJcIiBpZiBvIGFuZCBvOmV4cGxpY2l0XG5cdFx0dmFyIHZhbCA9IEB2YWx1ZSB8fCBAcmVmZXJlbmNlXG5cdFx0cmV0dXJuICh2YWwgYW5kIHZhbCAhPSB0aGlzKSA/IHZhbC5jIDogXCJ0aGlzXCJcblx0XHQjIHNob3VsZCBiZSB0aGUgb3RoZXIgd2F5IGFyb3VuZCwgbm8/XG5cdFx0IyBvIGFuZCBvOmV4cGxpY2l0ID8gc3VwZXIgOiBcIlwiXG5cdFx0XG5leHBvcnQgY2xhc3MgU3VwZXIgPCBOb2RlXG5cblx0ZGVmIGNcblx0XHQjIG5lZWQgdG8gZmluZCB0aGUgc3R1ZmYgaGVyZVxuXHRcdCMgdGhpcyBpcyByZWFsbHkgbm90IHRoYXQgZ29vZDhcblx0XHR2YXIgbSA9IFNUQUNLLm1ldGhvZFxuXHRcdHZhciBvdXQgPSBudWxsXG5cdFx0dmFyIHVwID0gU1RBQ0suY3VycmVudFxuXHRcdHZhciBkZWVwID0gdXAgaXNhIEFjY2Vzc1xuXG5cdFx0IyBUT0RPIG9wdGltaXphdGlvbiBmb3IgbGF0ZXIgLSBwcm9ibGVtYXRpYyBpZiB0aGVyZSBpcyBhIGRpZmZlcmVudCByZWZlcmVuY2UgaW4gdGhlIGVuZFxuXHRcdGlmIGZhbHNlICYmIG0gJiYgbS50eXBlID09IDpjb25zdHJ1Y3RvclxuXHRcdFx0b3V0ID0gXCJ7bS50YXJnZXQuY30uc3VwZXJjbGFzc1wiXG5cdFx0XHRvdXQgKz0gXCIuYXBwbHkoe20uc2NvcGUuY29udGV4dC5jfSxhcmd1bWVudHMpXCIgdW5sZXNzIGRlZXBcblx0XHRlbHNlXG5cdFx0XHRvdXQgPSBcInttLnRhcmdldC5jfS5fX3N1cGVyX19cIlxuXHRcdFx0dW5sZXNzIHVwIGlzYSBBY2Nlc3Ncblx0XHRcdFx0b3V0ICs9IFwiLntjX18obS5zdXBlcm5hbWUpfVwiIFxuXHRcdFx0XHR1bmxlc3MgdXAgaXNhIENhbGwgIyBhdXRvY2FsbD9cblx0XHRcdFx0XHRvdXQgKz0gXCIuYXBwbHkoe20uc2NvcGUuY29udGV4dC5jfSxhcmd1bWVudHMpXCIgXG5cdFx0b3V0XG5cbiMgY29uc3RhbnRzXG5cbmV4cG9ydCB2YXIgQlIgPSBOZXdsaW5lLm5ldygnXFxuJylcbmV4cG9ydCB2YXIgQlIyID0gTmV3bGluZS5uZXcoJ1xcblxcbicpXG5leHBvcnQgdmFyIFNFTEYgPSBTZWxmLm5ld1xuZXhwb3J0IHZhciBTVVBFUiA9IFN1cGVyLm5ld1xuXG5leHBvcnQgdmFyIFRSVUUgPSBUcnVlLm5ldygndHJ1ZScpXG5leHBvcnQgdmFyIEZBTFNFID0gRmFsc2UubmV3KCdmYWxzZScpXG5leHBvcnQgdmFyIFVOREVGSU5FRCA9IFVuZGVmaW5lZC5uZXdcbmV4cG9ydCB2YXIgTklMID0gTmlsLm5ld1xuXG5leHBvcnQgdmFyIEFSR1VNRU5UUyA9IEFyZ3NSZWZlcmVuY2UubmV3KCdhcmd1bWVudHMnKVxuZXhwb3J0IHZhciBFTVBUWSA9ICcnXG5leHBvcnQgdmFyIE5VTEwgPSAnbnVsbCdcblxuZXhwb3J0IHZhciBSRVNFUlZFRCA9IFsnZGVmYXVsdCcsJ25hdGl2ZScsJ2VudW0nLCd3aXRoJ11cbmV4cG9ydCB2YXIgUkVTRVJWRURfUkVHRVggPSAvXihkZWZhdWx0fG5hdGl2ZXxlbnVtfHdpdGh8bmV3fGNoYXIpJC9cblxuZXhwb3J0IHZhciBVTklPTiA9IENvbnN0Lm5ldygndW5pb24kJylcbmV4cG9ydCB2YXIgSU5URVJTRUNUID0gQ29uc3QubmV3KCdpbnRlcnNlY3QkJylcbmV4cG9ydCB2YXIgQ0xBU1NERUYgPSBDb25zdC5uZXcoJ2ltYmEkY2xhc3MnKVxuZXhwb3J0IHZhciBUQUdERUYgPSBDb25zdC5uZXcoJ0ltYmEuVEFHUy5kZWZpbmUnKVxuZXhwb3J0IHZhciBORVdUQUcgPSBJZGVudGlmaWVyLm5ldyhcInRhZyRcIilcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogc3JjL2NvbXBpbGVyL25vZGVzLmltYmFcbiAqKi8iLCJcbmV4cG9ydCBkZWYgYnJhY2Ugc3RyXG5cdHZhciBsaW5lcyA9IHN0ci5tYXRjaCgvXFxuLylcblx0IyB3aGF0IGFib3V0IGluZGVudGF0aW9uP1xuXG5cdGlmIGxpbmVzXG5cdFx0J3snICsgc3RyICsgJ1xcbn0nXG5cdGVsc2Vcblx0XHQne1xcbicgKyBzdHIgKyAnXFxufSdcblxuZXhwb3J0IGRlZiBub3JtYWxpemVJbmRlbnRhdGlvbiBzdHJcblx0dmFyIG1cblx0dmFyIHJlZyA9IC9cXG4rKFteXFxuXFxTXSopL2dcblx0dmFyIGluZCA9IG51bGxcblxuXHR3aGlsZSBtID0gcmVnLmV4ZWMoc3RyKVxuXHRcdHZhciBhdHRlbXB0ID0gbVsxXVxuXHRcdGlmIGluZCBpcyBudWxsIG9yIDAgPCBhdHRlbXB0Omxlbmd0aCA8IGluZDpsZW5ndGhcblx0XHRcdGluZCA9IGF0dGVtcHRcblxuXHRzdHIgPSBzdHIucmVwbGFjZShSZWdFeHAoXCJcXFxcbntpbmR9XCIsXCJnXCIpLCAnXFxuJykgaWYgaW5kXG5cdHJldHVybiBzdHJcblxuXG5leHBvcnQgZGVmIGZsYXR0ZW4gYXJyXG5cdHZhciBvdXQgPSBbXVxuXHRhcnIuZm9yRWFjaCBkbyB8dnwgdiBpc2EgQXJyYXkgPyBvdXQ6cHVzaC5hcHBseShvdXQsZmxhdHRlbih2KSkgOiBvdXQucHVzaCh2KVxuXHRyZXR1cm4gb3V0XG5cblxuZXhwb3J0IGRlZiBwYXNjYWxDYXNlIHN0clxuXHRzdHIucmVwbGFjZSgvKF58W1xcLVxcX1xcc10pKFxcdykvZykgZG8gfG0sdixsfCBsLnRvVXBwZXJDYXNlXG5cbmV4cG9ydCBkZWYgY2FtZWxDYXNlIHN0clxuXHRzdHIgPSBTdHJpbmcoc3RyKVxuXHQjIHNob3VsZCBhZGQgc2hvcnRjdXQgb3V0XG5cdHN0ci5yZXBsYWNlKC8oW1xcLVxcX1xcc10pKFxcdykvZykgZG8gfG0sdixsfCBsLnRvVXBwZXJDYXNlXG5cbmV4cG9ydCBkZWYgc25ha2VDYXNlIHN0clxuXHR2YXIgc3RyID0gc3RyLnJlcGxhY2UoLyhbXFwtXFxzXSkoXFx3KS9nLCdfJylcblx0c3RyLnJlcGxhY2UoLygpKFtBLVpdKS9nLFwiXyQxXCIpIGRvIHxtLHYsbHwgbC50b1VwcGVyQ2FzZVxuXG5leHBvcnQgZGVmIHNldHRlclN5bSBzeW1cblx0Y2FtZWxDYXNlKFwic2V0LXtzeW19XCIpXG5cbmV4cG9ydCBkZWYgcXVvdGUgc3RyXG5cdCdcIicgKyBzdHIgKyAnXCInXG5cbmV4cG9ydCBkZWYgc2luZ2xlcXVvdGUgc3RyXG5cdFwiJ1wiICsgc3RyICsgXCInXCJcblxuZXhwb3J0IGRlZiBzeW1ib2xpemUgc3RyXG5cdHN0ciA9IFN0cmluZyhzdHIpXG5cdHZhciBlbmQgPSBzdHIuY2hhckF0KHN0cjpsZW5ndGggLSAxKVxuXG5cdGlmIGVuZCA9PSAnPSdcblx0XHRzdHIgPSAnc2V0JyArIHN0clswXS50b1VwcGVyQ2FzZSArIHN0ci5zbGljZSgxLC0xKVxuXG5cdGlmIHN0ci5pbmRleE9mKFwiLVwiKSA+PSAwXG5cdFx0c3RyID0gc3RyLnJlcGxhY2UoLyhbXFwtXFxzXSkoXFx3KS9nKSBkbyB8bSx2LGx8IGwudG9VcHBlckNhc2Vcblx0XHRcdFxuXHRyZXR1cm4gc3RyXG5cblxuZXhwb3J0IGRlZiBpbmRlbnQgc3RyXG5cdFN0cmluZyhzdHIpLnJlcGxhY2UoL14vZyxcIlxcdFwiKS5yZXBsYWNlKC9cXG4vZyxcIlxcblxcdFwiKS5yZXBsYWNlKC9cXG5cXHQkL2csXCJcXG5cIilcblxuZXhwb3J0IGRlZiBicmFja2V0aXplIHN0ciwgaW5kID0geWVzXG5cdHN0ciA9IFwiXFxuXCIgKyBpbmRlbnQoc3RyKSArIFwiXFxuXCIgaWYgaW5kXG5cdCd7JyArIHN0ciArICd9J1xuXHRcbmV4cG9ydCBkZWYgcGFyZW50aGVzaXplIHN0clxuXHQnKCcgKyBTdHJpbmcoc3RyKSArICcpJ1xuXG5leHBvcnQgZGVmIGxvY2F0aW9uVG9MaW5lQ29sTWFwIGNvZGVcblx0dmFyIGxpbmVzID0gY29kZS5zcGxpdCgvXFxuL2cpXG5cdHZhciBtYXAgPSBbXVxuXG5cdHZhciBjaHJcblx0dmFyIGxvYyA9IDBcblx0dmFyIGNvbCA9IDBcblx0dmFyIGxpbmUgPSAwXG5cblx0d2hpbGUgY2hyID0gY29kZVtsb2NdXG5cdFx0bWFwW2xvY10gPSBbbGluZSxjb2xdXG5cblx0XHRpZiBjaHIgPT0gJ1xcbidcblx0XHRcdGxpbmUrK1xuXHRcdFx0Y29sID0gMFxuXHRcdGVsc2Vcblx0XHRcdGNvbCsrXG5cblx0XHRsb2MrK1xuXG5cdHJldHVybiBtYXBcblxuZXhwb3J0IGRlZiBtYXJrTGluZUNvbEZvclRva2VucyB0b2tlbnMsIGNvZGVcblx0c2VsZlxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHNyYy9jb21waWxlci9oZWxwZXJzLmltYmFcbiAqKi8iLCJcbmltcG9ydCAncGF0aCcgYXMgcGF0aFxuaW1wb3J0ICcuL2hlbHBlcnMnIGFzIHV0aWxcblxuZXhwb3J0IGNsYXNzIFNvdXJjZU1hcFxuXG5cdGRlZiBzb3VyY2Vcblx0XHRAc291cmNlXG5cblx0ZGVmIG9wdGlvbnNcblx0XHRAc291cmNlXG5cblx0ZGVmIGluaXRpYWxpemUgc291cmNlXG5cdFx0QHNvdXJjZSA9IHNvdXJjZVxuXHRcdEBtYXBzID0gW11cblx0XHRAbWFwID0gXCJcIlxuXHRcdEBqcyA9IFwiXCJcblxuXHRkZWYgZmlsZW5hbWVcblx0XHRvcHRpb25zOm9wdGlvbnM6ZmlsZW5hbWVcblxuXHRkZWYgc291cmNlQ29kZVxuXHRcdG9wdGlvbnM6b3B0aW9ucy5Ac291cmNlXG5cblx0ZGVmIHRhcmdldFBhdGhcblx0XHRvcHRpb25zOm9wdGlvbnM6dGFyZ2V0UGF0aFxuXG5cdGRlZiBzb3VyY2VQYXRoXG5cdFx0b3B0aW9uczpvcHRpb25zOnNvdXJjZVBhdGhcblxuXHRkZWYgc291cmNlTmFtZVxuXHRcdHBhdGguYmFzZW5hbWUoc291cmNlUGF0aClcblxuXHRkZWYgdGFyZ2V0TmFtZVxuXHRcdHBhdGguYmFzZW5hbWUodGFyZ2V0UGF0aClcblx0XHRcblxuXHRkZWYgc291cmNlRmlsZXNcblx0XHRbc291cmNlTmFtZV1cblxuXHRkZWYgcGFyc2Vcblx0XHR2YXIgbWF0Y2hlciA9IC9cXCVcXCQoXFxkKilcXCRcXCUvXG5cdFx0dmFyIHJlcGxhY2VyID0gL14oLio/KVxcJVxcJChcXGQqKVxcJFxcJS9cblx0XHR2YXIgbGluZXMgPSBvcHRpb25zOmpzLnNwbGl0KC9cXG4vZykgIyB3aGF0IGFib3V0IGpzP1xuXHRcdCMgcmV0dXJuIHNlbGZcblx0XHR2YXIgbG9jbWFwID0gdXRpbC5sb2NhdGlvblRvTGluZUNvbE1hcChzb3VyY2VDb2RlKVxuXHRcdEBtYXBzID0gW11cblxuXHRcdCMgY29uc29sZS5sb2cgb3B0aW9uczpqc1xuXHRcdFxuXHRcdHZhciBtYXRjaFxuXHRcdCMgc3BsaXQgdGhlIGNvZGUgaW4gbGluZXMuIGdvIHRocm91Z2ggZWFjaCBsaW5lIFxuXHRcdCMgZ28gdGhyb3VnaCB0aGUgY29kZSBsb29raW5nIGZvciBMT0MgbWFya2Vyc1xuXHRcdCMgcmVtb3ZlIG1hcmtlcnMgYWxvbmcgdGhlIHdheSBhbmQga2VlcCB0cmFjayBvZlxuXHRcdCMgY29uc29sZS5sb2cgc291cmNlOmpzXG5cblx0XHRmb3IgbGluZSxpIGluIGxpbmVzXG5cdFx0XHQjIGNvdWxkIHNwbGl0IG9uIHRoZXNlP1xuXHRcdFx0dmFyIGNvbCA9IDBcblx0XHRcdHZhciBjYXJldCA9IDBcblxuXHRcdFx0QG1hcHNbaV0gPSBbXVxuXHRcdFx0d2hpbGUgbGluZS5tYXRjaChtYXRjaGVyKVxuXHRcdFx0XHRsaW5lID0gbGluZS5yZXBsYWNlKHJlcGxhY2VyKSBkbyB8bSxwcmUsbG9jfFxuXHRcdFx0XHRcdHZhciBsYyA9IGxvY21hcFtwYXJzZUludChsb2MpXVxuXHRcdFx0XHRcdGNhcmV0ID0gcHJlOmxlbmd0aFxuXHRcdFx0XHRcdHZhciBtYXBwaW5nID0gWyBbbGNbMF0sbGNbMV1dLCBbaSxjYXJldF0gXSAjIHNvdXJjZSBhbmQgb3V0cHV0XG5cdFx0XHRcdFx0QG1hcHNbaV0ucHVzaChtYXBwaW5nKVxuXHRcdFx0XHRcdHJldHVybiBwcmVcblx0XHRcdGxpbmVzW2ldID0gbGluZVxuXG5cdFx0XG5cdFx0c291cmNlOmpzID0gbGluZXMuam9pbignXFxuJylcblx0XHRzZWxmXG5cblx0ZGVmIGdlbmVyYXRlXG5cdFx0cGFyc2VcblxuXHRcdHZhciBsYXN0Q29sdW1uICAgICAgICA9IDBcblx0XHR2YXIgbGFzdFNvdXJjZUxpbmUgICAgPSAwXG5cdFx0dmFyIGxhc3RTb3VyY2VDb2x1bW4gID0gMFxuXHRcdHZhciBidWZmZXIgICAgICAgICAgICA9IFwiXCJcblxuXHRcdGZvciBsaW5lLGxpbmVOdW1iZXIgaW4gQG1hcHNcblx0XHRcdGxhc3RDb2x1bW4gPSAwXG5cblx0XHRcdGZvciBtYXAsbnIgaW4gbGluZVxuXHRcdFx0XHRidWZmZXIgKz0gJywnIHVubGVzcyBuciA9PSAwXG5cdFx0XHRcdHZhciBzcmMgPSBtYXBbMF1cblx0XHRcdFx0dmFyIGRlc3QgPSBtYXBbMV1cblx0XHRcdFx0XG5cdFx0XHRcdGJ1ZmZlciArPSBlbmNvZGVWbHEoZGVzdFsxXSAtIGxhc3RDb2x1bW4pXG5cdFx0XHRcdGxhc3RDb2x1bW4gPSBkZXN0WzFdXG5cdFx0XHRcdCMgYWRkIGluZGV4XG5cdFx0XHRcdGJ1ZmZlciArPSBlbmNvZGVWbHEoMClcblxuXHRcdFx0XHQjIFRoZSBzdGFydGluZyBsaW5lIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIHJlbGF0aXZlIHRvIHRoZSBwcmV2aW91cyBzb3VyY2UgbGluZS5cblx0XHRcdFx0YnVmZmVyICs9IGVuY29kZVZscShzcmNbMF0gLSBsYXN0U291cmNlTGluZSlcblx0XHRcdFx0bGFzdFNvdXJjZUxpbmUgPSBzcmNbMF1cblx0XHRcdFx0IyBUaGUgc3RhcnRpbmcgY29sdW1uIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIHJlbGF0aXZlIHRvIHRoZSBwcmV2aW91cyBjb2x1bW4uXG5cdFx0XHRcdGJ1ZmZlciArPSBlbmNvZGVWbHEoc3JjWzFdIC0gbGFzdFNvdXJjZUNvbHVtbilcblx0XHRcdFx0bGFzdFNvdXJjZUNvbHVtbiA9IHNyY1sxXVxuXG5cdFx0XHRidWZmZXIgKz0gXCI7XCJcblxuXG5cdFx0dmFyIHJlbCA9IHBhdGgucmVsYXRpdmUocGF0aC5kaXJuYW1lKHRhcmdldFBhdGgpLHNvdXJjZVBhdGgpXG5cblx0XHR2YXIgbWFwID1cblx0XHRcdHZlcnNpb246IDNcblx0XHRcdGZpbGU6IHNvdXJjZU5hbWUucmVwbGFjZSgvXFwuaW1iYS8sJy5qcycpIG9yICcnXG5cdFx0XHRzb3VyY2VSb290OiBvcHRpb25zOnNvdXJjZVJvb3Qgb3IgJydcblx0XHRcdHNvdXJjZXM6ICAgIFtyZWxdXG5cdFx0XHRzb3VyY2VzQ29udGVudDogW3NvdXJjZUNvZGVdXG5cdFx0XHRuYW1lczogICAgICBbXVxuXHRcdFx0bWFwcGluZ3M6ICAgYnVmZmVyXG5cblx0XHQjIHNvdXJjZTpzb3VyY2VtYXAgPSBzb3VyY2VtYXBcblx0XHQjIHZhciBiYXNlNjQgPSBCdWZmZXIubmV3KEpTT04uc3RyaW5naWZ5KG1hcCkpLnRvU3RyaW5nKFwiYmFzZTY0XCIpXG5cdFx0IyBzb3VyY2U6anMgKz0gXCJcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LHtiYXNlNjR9XCJcblx0XHRyZXR1cm4gbWFwXG5cblx0VkxRX1NISUZUID0gNVxuXHRWTFFfQ09OVElOVUFUSU9OX0JJVCA9IDEgPDwgVkxRX1NISUZUXG5cdFZMUV9WQUxVRV9NQVNLID0gVkxRX0NPTlRJTlVBVElPTl9CSVQgLSAxXG5cdEJBU0U2NF9DSEFSUyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuXG5cdCMgYm9ycm93ZWQgZnJvbSBDb2ZmZWVTY3JpcHRcblx0ZGVmIGVuY29kZVZscSB2YWx1ZVxuXHRcdHZhciBhbnN3ZXIgPSAnJ1xuXHRcdCMgTGVhc3Qgc2lnbmlmaWNhbnQgYml0IHJlcHJlc2VudHMgdGhlIHNpZ24uXG5cdFx0dmFyIHNpZ25CaXQgPSB2YWx1ZSA8IDAgPyAxIDogMFxuXHRcdHZhciBuZXh0Q2h1bmtcblx0XHQjIFRoZSBuZXh0IGJpdHMgYXJlIHRoZSBhY3R1YWwgdmFsdWUuXG5cdFx0dmFyIHZhbHVlVG9FbmNvZGUgPSAoTWF0aC5hYnModmFsdWUpIDw8IDEpICsgc2lnbkJpdFxuXHRcdCMgTWFrZSBzdXJlIHdlIGVuY29kZSBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyLCBldmVuIGlmIHZhbHVlVG9FbmNvZGUgaXMgMC5cblx0XHR3aGlsZSB2YWx1ZVRvRW5jb2RlIG9yICFhbnN3ZXJcblx0XHRcdHZhciBuZXh0Q2h1bmsgPSB2YWx1ZVRvRW5jb2RlICYgVkxRX1ZBTFVFX01BU0tcblx0XHRcdHZhbHVlVG9FbmNvZGUgPSB2YWx1ZVRvRW5jb2RlID4+IFZMUV9TSElGVFxuXHRcdFx0aWYgdmFsdWVUb0VuY29kZVxuXHRcdFx0XHRuZXh0Q2h1bmsgfD0gVkxRX0NPTlRJTlVBVElPTl9CSVRcblxuXHRcdFx0YW5zd2VyICs9IGVuY29kZUJhc2U2NChuZXh0Q2h1bmspXG5cblx0XHRhbnN3ZXJcblxuXHRkZWYgZW5jb2RlQmFzZTY0IHZhbHVlXG5cdFx0QkFTRTY0X0NIQVJTW3ZhbHVlXSAjIG9yIHRocm93IEVycm9yLm5ldyhcIkNhbm5vdCBCYXNlNjQgZW5jb2RlIHZhbHVlOiB7dmFsdWV9XCIpXG5cblx0XHRcblx0XHRcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBzcmMvY29tcGlsZXIvc291cmNlbWFwLmltYmFcbiAqKi8iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gcmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIGFycmF5IHdpdGggZGlyZWN0b3J5IG5hbWVzIHRoZXJlXG4vLyBtdXN0IGJlIG5vIHNsYXNoZXMsIGVtcHR5IGVsZW1lbnRzLCBvciBkZXZpY2UgbmFtZXMgKGM6XFwpIGluIHRoZSBhcnJheVxuLy8gKHNvIGFsc28gbm8gbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcyAtIGl0IGRvZXMgbm90IGRpc3Rpbmd1aXNoXG4vLyByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgcGF0aHMpXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheShwYXJ0cywgYWxsb3dBYm92ZVJvb3QpIHtcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGxhc3QgPSBwYXJ0c1tpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG4vLyBTcGxpdCBhIGZpbGVuYW1lIGludG8gW3Jvb3QsIGRpciwgYmFzZW5hbWUsIGV4dF0sIHVuaXggdmVyc2lvblxuLy8gJ3Jvb3QnIGlzIGp1c3QgYSBzbGFzaCwgb3Igbm90aGluZy5cbnZhciBzcGxpdFBhdGhSZSA9XG4gICAgL14oXFwvP3wpKFtcXHNcXFNdKj8pKCg/OlxcLnsxLDJ9fFteXFwvXSs/fCkoXFwuW14uXFwvXSp8KSkoPzpbXFwvXSopJC87XG52YXIgc3BsaXRQYXRoID0gZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aFJlLmV4ZWMoZmlsZW5hbWUpLnNsaWNlKDEpO1xufTtcblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKSxcbiAgICAgIHRyYWlsaW5nU2xhc2ggPSBzdWJzdHIocGF0aCwgLTEpID09PSAnLyc7XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9KS5qb2luKCcvJykpO1xufTtcblxuXG4vLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICB0byA9IGV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuXG4gIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICB9XG5cbiAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICB9XG5cbiAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcblxuICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xufTtcblxuZXhwb3J0cy5zZXAgPSAnLyc7XG5leHBvcnRzLmRlbGltaXRlciA9ICc6JztcblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgcmVzdWx0ID0gc3BsaXRQYXRoKHBhdGgpLFxuICAgICAgcm9vdCA9IHJlc3VsdFswXSxcbiAgICAgIGRpciA9IHJlc3VsdFsxXTtcblxuICBpZiAoIXJvb3QgJiYgIWRpcikge1xuICAgIC8vIE5vIGRpcm5hbWUgd2hhdHNvZXZlclxuICAgIHJldHVybiAnLic7XG4gIH1cblxuICBpZiAoZGlyKSB7XG4gICAgLy8gSXQgaGFzIGEgZGlybmFtZSwgc3RyaXAgdHJhaWxpbmcgc2xhc2hcbiAgICBkaXIgPSBkaXIuc3Vic3RyKDAsIGRpci5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIHJldHVybiByb290ICsgZGlyO1xufTtcblxuXG5leHBvcnRzLmJhc2VuYW1lID0gZnVuY3Rpb24ocGF0aCwgZXh0KSB7XG4gIHZhciBmID0gc3BsaXRQYXRoKHBhdGgpWzJdO1xuICAvLyBUT0RPOiBtYWtlIHRoaXMgY29tcGFyaXNvbiBjYXNlLWluc2Vuc2l0aXZlIG9uIHdpbmRvd3M/XG4gIGlmIChleHQgJiYgZi5zdWJzdHIoLTEgKiBleHQubGVuZ3RoKSA9PT0gZXh0KSB7XG4gICAgZiA9IGYuc3Vic3RyKDAsIGYubGVuZ3RoIC0gZXh0Lmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGY7XG59O1xuXG5cbmV4cG9ydHMuZXh0bmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aChwYXRoKVszXTtcbn07XG5cbmZ1bmN0aW9uIGZpbHRlciAoeHMsIGYpIHtcbiAgICBpZiAoeHMuZmlsdGVyKSByZXR1cm4geHMuZmlsdGVyKGYpO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmKHhzW2ldLCBpLCB4cykpIHJlcy5wdXNoKHhzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gU3RyaW5nLnByb3RvdHlwZS5zdWJzdHIgLSBuZWdhdGl2ZSBpbmRleCBkb24ndCB3b3JrIGluIElFOFxudmFyIHN1YnN0ciA9ICdhYicuc3Vic3RyKC0xKSA9PT0gJ2InXG4gICAgPyBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7IHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pIH1cbiAgICA6IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHtcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBzdHIubGVuZ3RoICsgc3RhcnQ7XG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pO1xuICAgIH1cbjtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogKHdlYnBhY2spL34vbm9kZS1saWJzLWJyb3dzZXIvfi9wYXRoLWJyb3dzZXJpZnkvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==