var ImbaWorker =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		// externs;
		
		var ImbaParseError = __webpack_require__(1).ImbaParseError;
		
		var lexer = __webpack_require__(2);
		var rewriter = __webpack_require__(4);
		var parser = __webpack_require__(5).parser;
		var ast = __webpack_require__(8);
		
		// Instantiate a Lexer for our use here.
		var lex = new (lexer.Lexer)();
		var Rewriter = rewriter.Rewriter;
		
		parser.lexer = lex.jisonBridge();
		parser.yy = ast; // everything is exported right here now
		
		var api = {};
		
		api.tokenize = function (code,o){
			if(o === undefined) o = {};
			try {
				o._source = code;
				lex.reset();
				return lex.tokenize(code,o);
			} catch (err) {
				// makes no sense?
				throw err;
			};
		};
		
		api.parse = function (code,o){
			// code will never be an array in worker?
			if(o === undefined) o = {};
			var tokens = code instanceof Array ? (code) : (api.tokenize(code,o));
			
			try {
				o._source = code;
				o._tokens = tokens;
				return parser.parse(tokens);
			} catch (err) {
				if (o.filename) { err._filename = o.filename };
				throw err;
			};
		};
		
		
		api.compile = function (code,o){
			if(o === undefined) o = {};
			try {
				// console.log 'try compile'
				var ast = api.parse(code,o);
				var res = ast.compile(o);
				return {code: res.toString(),sourcemap: res.sourcemap};
			} catch (e) {
				// console.log 'compile error',e:message
				// normalize somewhere else
				if (!((e instanceof ImbaParseError))) {
					if (e.lexer) {
						e = new ImbaParseError(e,{tokens: e.lexer.tokens,pos: e.lexer.pos});
					} else {
						e = {message: e.message};
					};
				};
				
				if (e instanceof ImbaParseError) { e = e.toJSON() };
				
				return {error: e};
			};
		};
		
		api.analyze = function (code,o){
			if(o === undefined) o = {};
			var meta;
			try {
				var ast = this.parse(code,o);
				meta = ast.analyze({loglevel: 0});
			} catch (e) {
				// console.log "something wrong {e:message}"
				if (!((e instanceof ImbaParseError))) {
					if (e.lexer) {
						e = new ImbaParseError(e,{tokens: e.lexer.tokens,pos: e.lexer.pos});
					} else {
						e = {message: e.message};
					};
				};
				
				if (e instanceof ImbaParseError) { e = e.toJSON() };
				
				meta = {warnings: [e]};
			};
			return meta;
		};
		
		
		return onmessage = function onmessage(e){
			// console.log 'message to webworker'
			var params = e.data;
			var id = params.id;
			
			if (api[params[0]] instanceof Function) {
				var fn = api[params[0]];
				var result = fn.apply(api,params.slice(1));
				return postMessage({id: id,data: result});
			};
		};
		
		
	
	})()

/***/ },
/* 1 */
/***/ function(module, exports) {

	(function(){
		// helper for subclassing
		function subclass$(obj,sup) {
			for (var k in sup) {
				if (sup.hasOwnProperty(k)) obj[k] = sup[k];
			};
			// obj.__super__ = sup;
			obj.prototype = Object.create(sup.prototype);
			obj.__super__ = obj.prototype.__super__ = sup.prototype;
			obj.prototype.initialize = obj.prototype.constructor = obj;
		};
		
		// create separate error-types with all the logic
		
		function ImbaParseError(e,o){
			this.error = e;
			this.message = e.message;
			this.filename = e.filename;
			this.line = e.line;
			this._options = o || {};
			this;
		};
		
		subclass$(ImbaParseError,Error);
		exports.ImbaParseError = ImbaParseError; // export class 
		ImbaParseError.wrap = function (err){
			// what about the stacktrace?
			return new ImbaParseError(err);
		};
		
		ImbaParseError.prototype.set = function (opts){
			this._options || (this._options = {});
			for (var i = 0, keys = Object.keys(opts), l = keys.length; i < l; i++){
				this._options[keys[i]] = opts[keys[i]];
			};
			return this;
		};
		
		ImbaParseError.prototype.start = function (){
			var o = this._options;
			var idx = o.pos - 1;
			var tok = o.tokens && o.tokens[idx];
			while (tok && tok._loc == -1){
				tok = o.tokens[--idx];
			};
			return tok;
		};
		
		ImbaParseError.prototype.desc = function (){
			var o = this._options;
			var msg = this.message;
			if (o.token && o.token._loc == -1) {
				return 'Syntax Error';
			} else {
				return msg;
			};
		};
		
		ImbaParseError.prototype.loc = function (){
			var start_;
			return (start_ = this.start()) && start_.region  &&  start_.region();
		};
		
		ImbaParseError.prototype.toJSON = function (){
			var o = this._options;
			var tok = this.start();
			// var tok = o:tokens and o:tokens[o:pos - 1]
			// var loc = tok and [tok.@loc,tok.@loc + (tok.@len or tok.@value:length)] or [0,0]
			// , col: tok.@col, line: tok.@line
			// get the token itself?
			return {warn: true,message: this.desc(),loc: this.loc()};
		};
		return ImbaParseError;
	
	})()

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function idx$(a,b){
			return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
		};
		
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		// helper for subclassing
		function subclass$(obj,sup) {
			for (var k in sup) {
				if (sup.hasOwnProperty(k)) obj[k] = sup[k];
			};
			// obj.__super__ = sup;
			obj.prototype = Object.create(sup.prototype);
			obj.__super__ = obj.prototype.__super__ = sup.prototype;
			obj.prototype.initialize = obj.prototype.constructor = obj;
		};
		
		var ALL_KEYWORDS;
		
		var T = __webpack_require__(3);
		var Token = T.Token;
		
		var rw = __webpack_require__(4);
		var Rewriter = rw.Rewriter;
		var INVERSES = rw.INVERSES;
		
		var K = 0;
		
		var ERR = __webpack_require__(1);
		
		// Constants
		// ---------
		
		// Keywords that Imba shares in common with JavaScript.
		var JS_KEYWORDS = [
			'true','false','null','this',
			'delete','typeof','in','instanceof',
			'throw','break','continue','debugger',
			'if','else','switch','for','while','do','try','catch','finally',
			'class','extends','super','return'
		];
		
		// new can be used as a keyword in imba, since object initing is done through
		// MyObject.new. new is a very useful varname.
		
		// We want to treat return like any regular call for now
		// Must be careful to throw the exceptions in AST, since the parser
		// wont
		
		// Imba-only keywords. var should move to JS_Keywords
		// some words (like tokid) should be context-specific
		var IMBA_KEYWORDS = [
			'undefined','then','unless','until','loop','of','by',
			'when','def','tag','do','elif','begin','var','let','self','await','import'
		];
		
		var IMBA_CONTEXTUAL_KEYWORDS = ['extend','static','local','export','global','prop'];
		
		var IMBA_ALIAS_MAP = {
			'and': '&&',
			'or': '||',
			'is': '==',
			'isnt': '!=',
			'not': '!',
			'yes': 'true',
			'no': 'false',
			'isa': 'instanceof',
			'case': 'switch',
			'nil': 'null'
		};
		
		var IMBA_ALIASES = Object.keys(IMBA_ALIAS_MAP);
		IMBA_KEYWORDS = IMBA_KEYWORDS.concat(IMBA_ALIASES);
		
		// FixedArray for performance
		// var ALL_KEYWORDS = JS_KEYWORDS.concat(IMBA_KEYWORDS)
		module.exports.ALL_KEYWORDS = ALL_KEYWORDS = [
			'true','false','null','this',
			'delete','typeof','in','instanceof',
			'throw','break','continue','debugger',
			'if','else','switch','for','while','do','try','catch','finally',
			'class','extends','super','return',
			'undefined','then','unless','until','loop','of','by',
			'when','def','tag','do','elif','begin','var','let','self','await','import',
			'and','or','is','isnt','not','yes','no','isa','case','nil'
		];
		
		// The list of keywords that are reserved by JavaScript, but not used, or are
		// used by Imba internally. We throw an error when these are encountered,
		// to avoid having a JavaScript error at runtime.  # 'var', 'let', - not inside here
		var RESERVED = ['case','default','function','void','with','const','enum','native'];
		var STRICT_RESERVED = ['case','function','void','const'];
		
		// The superset of both JavaScript keywords and reserved words, none of which may
		// be used as identifiers or properties.
		var JS_FORBIDDEN = JS_KEYWORDS.concat(RESERVED);
		
		var METHOD_IDENTIFIER = /^((([\x23]?[\$A-Za-z_\x7f-\uffff][$\-\w\x7f-\uffff]*)([\=]?))|(<=>|\|(?![\|=])))/;
		// removed ~=|~| |&(?![&=])
		
		// Token matching regexes.
		// added hyphens to identifiers now - to test
		var IDENTIFIER = /^((\$|@@|@|\#)[\wA-Za-z_\-\x7f-\uffff][$\w\x7f-\uffff]*(\-[$\w\x7f-\uffff]+)*|[$A-Za-z_][$\w\x7f-\uffff]*(\-[$\w\x7f-\uffff]+)*)([^\n\S]*:(?![\*\=:$\w\x7f-\uffff]))?/;
		
		var OBJECT_KEY = /^((\$|@@|@|)[$A-Za-z_\x7f-\uffff\-][$\w\x7f-\uffff\-]*)([^\n\S\s]*:(?![\*\=:$\w\x7f-\uffff]))/;
		
		var TAG = /^(\<|%)(?=[A-Za-z\#\.\{\@\>])/;
		
		var TAG_TYPE = /^(\w[\w\d]*:)?(\w[\w\d]*)(-[\w\d]+)*/;
		var TAG_ID = /^#((\w[\w\d]*)(-[\w\d]+)*)/;
		
		var TAG_ATTR = /^([\.\:]?[\w\_]+([\-\:][\w]+)*)(\s)*\=/;
		
		var SELECTOR = /^([%\$]{1,2})([\(\w\#\.\[])/;
		var SELECTOR_PART = /^(\#|\.|:|::)?([\w]+(\-[\w]+)*)/;
		var SELECTOR_COMBINATOR = /^ (\+|\>|\~)*\s*(?=[\w\.\#\:\{\*\[])/;
		
		var SELECTOR_PSEUDO_CLASS = /^(::?)([\w]+(\-[\w]+)*)/;
		var SELECTOR_ATTR_OP = /^(\$=|\~=|\^=|\*=|\|=|=|\!=)/;
		var SELECTOR_ATTR = /^\[([\w\_\-]+)(\$=|\~=|\^=|\*=|\|=|=|\!=)/;
		
		var SYMBOL = /^\:((([\*\@$\w\x7f-\uffff]+)+([\-\\/\\\:][\w\x7f-\uffff]+)*)|==|\<=\>|\[\]|\[\]\=|\*|[\\/,\\])/;
		
		
		var NUMBER = /^0x[\da-f]+|^0b[01]+|^\d*\.?\d+(?:e[+-]?\d+)?/i;
		
		var HEREDOC = /^("""|''')([\s\S]*?)(?:\n[^\n\S]*)?\1/;
		
		var OPERATOR = /^(?:[-=]=>|===|->|!==|[-+*\/%<>&|^!?=]=|=<|>>>=?|([-+:])\1|([&|<>])\2=?|\?\.|\?\:|\.{2,3}|\*(?=[a-zA-Z\_]))/;
		
		// FIXME splat should only be allowed when the previous thing is spaced or inside call?
		
		var WHITESPACE = /^[^\n\S]+/;
		
		var COMMENT = /^###([^#][\s\S]*?)(?:###[^\n\S]*|(?:###)?$)/;
		// COMMENT    = /^###([^#][\s\S]*?)(?:###[^\n\S]*|(?:###)?$)|^(?:\s*(#\s.*|#\s*$))+/
		var INLINE_COMMENT = /^(\s*)(#[ \t\!](.*)|#[ \t]?(?=\n|$))+/;
		
		var CODE = /^[-=]=>/;
		
		var MULTI_DENT = /^(?:\n[^\n\S]*)+/;
		
		var SIMPLESTR = /^'[^\\']*(?:\\.[^\\']*)*'/;
		
		var JSTOKEN = /^`[^\\`]*(?:\\.[^\\`]*)*`/;
		
		// Regex-matching-regexes.
		var REGEX = /^(\/(?![\s=])[^[\/\n\\]*(?:(?:\\[\s\S]|\[[^\]\n\\]*(?:\\[\s\S][^\]\n\\]*)*])[^[\/\n\\]*)*\/)([imgy]{0,4})(?!\w)/;
		
		var HEREGEX = /^\/{3}([\s\S]+?)\/{3}([imgy]{0,4})(?!\w)/;
		
		var HEREGEX_OMIT = /\s+(?:#.*)?/g;
		
		// Token cleaning regexes.
		var MULTILINER = /\n/g;
		
		var HEREDOC_INDENT = /\n+([^\n\S]*)/g;
		
		var HEREDOC_ILLEGAL = /\*\//;
		
		// expensive?
		var LINE_CONTINUER = /^\s*(?:,|\??\.(?![.\d])|::)/;
		
		var TRAILING_SPACES = /\s+$/;
		
		var CONST_IDENTIFIER = /^[A-Z]/;
		
		var ARGVAR = /^\$\d$/;
		
		// Compound assignment tokens.
		var COMPOUND_ASSIGN = ['-=','+=','/=','*=','%=','||=','&&=','?=','<<=','>>=','>>>=','&=','^=','|=','=<'];
		
		// Unary tokens.
		var UNARY = ['!','~','NEW','TYPEOF','DELETE'];
		
		// Logical tokens.
		var LOGIC = ['&&','||','&','|','^'];
		
		// Bit-shifting tokens.
		var SHIFT = ['<<','>>','>>>'];
		
		// Comparison tokens.
		var COMPARE = ['===','!==','==','!=','<','>','<=','>=','===','!=='];
		
		// Overideable methods
		var OP_METHODS = ['<=>','<<','..'];
		
		// Mathematical tokens.
		var MATH = ['*','/','%','∪','∩','√'];
		
		// Relational tokens that are negatable with `not` prefix.
		var RELATION = ['IN','OF','INSTANCEOF','ISA'];
		
		// Boolean tokens.
		var BOOL = ['TRUE','FALSE','NULL','UNDEFINED'];
		
		// Our list is shorter, due to sans-parentheses method calls.
		var NOT_REGEX = ['NUMBER','REGEX','BOOL','TRUE','FALSE','++','--',']'];
		
		// If the previous token is not spaced, there are more preceding tokens that
		// force a division parse:
		var NOT_SPACED_REGEX = ['NUMBER','REGEX','BOOL','TRUE','FALSE','++','--',']',')','}','THIS','SELF','IDENTIFIER','STRING'];
		
		// Tokens which could legitimately be invoked or indexed. An opening
		// parentheses or bracket following these tokens will be recorded as the start
		// of a function invocation or indexing operation.
		// really?!
		
		var UNFINISHED = ['\\','.','?.','?:','UNARY','MATH','+','-','SHIFT','RELATION','COMPARE','LOGIC','COMPOUND_ASSIGN','THROW','EXTENDS'];
		
		// } should not be callable anymore!!! '}', '::',
		var CALLABLE = ['IDENTIFIER','STRING','REGEX',')',']','THIS','SUPER','TAG_END','IVAR','GVAR','SELF','CONST','NEW','ARGVAR','SYMBOL','RETURN'];
		// var INDEXABLE = CALLABLE.concat 'NUMBER', 'BOOL', 'TAG_SELECTOR', 'IDREF', 'ARGUMENTS','}' # are booleans indexable? really?
		// optimize for FixedArray
		var INDEXABLE = [
			'IDENTIFIER','STRING','REGEX',')',']','THIS','SUPER','TAG_END','IVAR','GVAR','SELF','CONST','NEW','ARGVAR','SYMBOL','RETURN',
			'NUMBER','BOOL','TAG_SELECTOR','IDREF','ARGUMENTS','}','TAG_TYPE'
		];
		
		var GLOBAL_IDENTIFIERS = ['global','exports','require'];
		
		// Tokens that, when immediately preceding a `WHEN`, indicate that the `WHEN`
		// occurs at the start of a line. We disambiguate these from trailing whens to
		// avoid an ambiguity in the grammar.
		var LINE_BREAK = ['INDENT','OUTDENT','TERMINATOR'];
		
		
		function LexerError(message,file,line){
			this.message = message;
			this.file = file;
			this.line = line;
			return this;
		};
		subclass$(LexerError,SyntaxError);
		exports.LexerError = LexerError; // export class 
		
		
		
		function last(array,back){
			if(back === undefined) back = 0;
			return array[array.length - back - 1];
		};
		
		function count(str,substr){
			return str.split(substr).length - 1;
		};
		
		function repeatString(str,times){
			var res = '';
			while (times > 0){
				if (times % 2 == 1) {
					res += str;
				};
				str += str;
				times >>= 1;
			};
			return res;
		};
		
		var tT = T.typ;
		var tV = T.val;
		var tTs = T.setTyp;
		var tVs = T.setVal;
		
		// The Lexer class reads a stream of Imba and divvies it up into tokidged
		// tokens. Some potential ambiguity in the grammar has been avoided by
		// pushing some extra smarts into the Lexer.
		
		// Based on the original lexer.coffee from CoffeeScript
		function Lexer(){
			this.reset();
			this;
		};
		
		exports.Lexer = Lexer; // export class 
		Lexer.prototype.reset = function (){
			this._code = null;
			this._chunk = null; // The remainder of the source code.
			this._opts = null;
			
			this._indent = 0; // The current indentation level.
			this._indebt = 0; // The over-indentation at the current level.
			this._outdebt = 0; // The under-outdentation at the current level.
			
			this._indents = []; // The stack of all current indentation levels.
			this._ends = []; // The stack for pairing up tokens.
			this._contexts = []; // suplements @ends
			this._scopes = [];
			this._nextScope = null; // the scope to add on the next indent
			// should rather make it like a statemachine that moves from CLASS_DEF to CLASS_BODY etc
			// Things should compile differently when you are in a CLASS_BODY than when in a DEF_BODY++
			
			this._indentStyle = null;
			
			this._tokens = []; // Stream of parsed tokens in the form `['TYPE', value, line]`.
			this._seenFor = false;
			this._loc = 0;
			this._locOffset = 0;
			
			this._end = null;
			this._char = null;
			this._bridge = null;
			this._last = null;
			this._lastTyp = '';
			this._lastVal = null;
			return this;
		};
		
		Lexer.prototype.jisonBridge = function (jison){
			return this._bridge = {
				lex: T.lex,
				setInput: function(tokens) {
					this.tokens = tokens;
					return this.pos = 0;
				},
				
				upcomingInput: function() { return ""; }
			};
		};
		
		
		Lexer.prototype.tokenize = function (code,o){
			
			if(o === undefined) o = {};
			if (code.length == 0) {
				return [];
			};
			
			if (!o.inline) {
				if (WHITESPACE.test(code)) {
					code = ("\n" + code);
					if (code.match(/^\s*$/g)) { return [] };
				};
				
				code = code.replace(/\r/g,'').replace(/[\t ]+$/g,'');
			};
			
			this._last = null;
			this._lastTyp = null;
			this._lastVal = null;
			
			this._code = code;
			this._opts = o;
			this._locOffset = o.loc || 0;
			
			o.indent || (o.indent = {style: null,size: null});
			// add a reference to the options object
			o._tokens = this._tokens;
			// what about col here?
			
			// @indent  = 0 # The current indentation level.
			// @indebt  = 0 # The over-indentation at the current level.
			// @outdebt = 0 # The under-outdentation at the current level.
			// @indents = [] # The stack of all current indentation levels.
			// @ends    = [] # The stack for pairing up tokens.
			// @tokens  = [] # Stream of parsed tokens in the form `['TYPE', value, line]`.
			// @char = nil
			
			if (o.profile) { console.time("tokenize:lexer") };
			this.parse(code);
			if (!o.inline) this.closeIndentation();
			if (!o.silent && this._ends.length) {
				this.error(("missing " + (this._ends.pop())));
			};
			
			if (o.profile) { console.timeEnd("tokenize:lexer") };
			if (o.rewrite == false || o.norewrite) { return this._tokens };
			return new Rewriter().rewrite(this._tokens,o);
		};
		
		Lexer.prototype.parse = function (code){
			var i = 0;
			var pi = 0;
			
			while (this._chunk = code.slice(i)){
				this._loc = this._locOffset + i;
				pi = (this._end == 'TAG' && this.tagDefContextToken()) || (this._inTag && this.tagContextToken()) || this.basicContext();
				i += pi;
			};
			
			return;
		};
		
		Lexer.prototype.basicContext = function (){
			return this.selectorToken() || this.symbolToken() || this.methodNameToken() || this.identifierToken() || this.whitespaceToken() || this.lineToken() || this.commentToken() || this.heredocToken() || this.tagToken() || this.stringToken() || this.numberToken() || this.regexToken() || this.jsToken() || this.literalToken() || 0;
		};
		
		Lexer.prototype.moveCaret = function (i){
			return this._loc += i;
		};
		
		Lexer.prototype.context = function (){
			return this._ends[this._ends.length - 1];
		};
		
		Lexer.prototype.inContext = function (key){
			var o = this._contexts[this._contexts.length - 1];
			return o && o[key];
		};
		
		Lexer.prototype.pushEnd = function (val){
			// console.log "pushing end",val
			this._ends.push(val);
			this._contexts.push(null);
			this._end = val;
			this.refreshScope();
			return this;
		};
		
		Lexer.prototype.popEnd = function (val){
			this._ends.pop();
			this._contexts.pop();
			this._end = this._ends[this._ends.length - 1];
			this.refreshScope();
			return this;
		};
		
		Lexer.prototype.refreshScope = function (){
			var ctx0 = this._ends[this._ends.length - 1];
			var ctx1 = this._ends[this._ends.length - 2];
			return this._inTag = ctx0 == 'TAG_END' || (ctx1 == 'TAG_END' && ctx0 == 'OUTDENT');
		};
		
		
		
		Lexer.prototype.queueScope = function (val){
			// console.log("pushing scope {val} - {@indents} {@indents:length}")
			// @scopes.push(val) # no no
			this._scopes[this._indents.length] = val;
			return this;
		};
		
		Lexer.prototype.popScope = function (val){
			this._scopes.pop();
			return this;
		};
		
		Lexer.prototype.getScope = function (){
			return this._scopes[this._indents.length - 1];
		};
		
		Lexer.prototype.scope = function (sym,opts){
			var len = this._ends.push(this._end = sym);
			this._contexts.push(opts || null);
			return sym;
		};
		
		
		Lexer.prototype.closeSelector = function (){
			if (this._end == '%') {
				this.token('SELECTOR_END','%',0);
				return this.pair('%');
			};
		};
		
		
		Lexer.prototype.openDef = function (){
			return this.pushEnd('DEF');
		};
		
		
		Lexer.prototype.closeDef = function (){
			if (this.context() == 'DEF') {
				var prev = last(this._tokens);
				// console.log "close def {prev}"
				// console.log('closeDef with last>',prev)
				if (tT(prev) == 'DEF_FRAGMENT') {
					true;
				} else if (tT(prev) == 'TERMINATOR') {
					// console.log "here?!??"
					var n = this._tokens.pop();
					// console.log n
					this.token('DEF_BODY','DEF_BODY',0);
					// token('TERMINATOR', '',0) unless n.@value.indexOf('//') >= 0
					this._tokens.push(n);
				} else {
					this.token('DEF_BODY','DEF_BODY',0);
				};
				
				this.pair('DEF');
			};
			return;
		};
		
		Lexer.prototype.tagContextToken = function (){
			var match;
			if (this._chunk[0] == '#') {
				// console.log('found id # in tagContextToken')
				this.token('#','#',1);
				return 1;
			};
			
			if (match = TAG_ATTR.exec(this._chunk)) {
				// console.log 'TAG_SDDSATTR IN tokid',match
				// var prev = last @tokens
				// if the prev is a terminator, we dont really need to care?
				if (this._lastTyp != 'TAG_NAME') {
					if (this._lastTyp == 'TERMINATOR') {
						// console.log('prev was terminator -- drop it?')
						true;
					} else {
						this.token(",",",");
					};
				};
				
				var l = match[0].length;
				
				this.token('TAG_ATTR',match[1],l - 1); // add to loc?
				this._loc += l - 1;
				this.token('=','=',1);
				return l;
			};
			return 0;
		};
		
		Lexer.prototype.tagDefContextToken = function (){
			// console.log "tagContextToken"
			var match;
			if (match = TAG_TYPE.exec(this._chunk)) {
				this.token('TAG_TYPE',match[0],match[0].length);
				return match[0].length;
			};
			
			if (match = TAG_ID.exec(this._chunk)) {
				var input = match[0];
				this.token('TAG_ID',input,input.length);
				return input.length;
			};
			
			return 0;
		};
		
		
		Lexer.prototype.tagToken = function (){
			var match, ary;
			if (!(match = TAG.exec(this._chunk))) { return 0 };
			var ary = iter$(match);var input = ary[0],type = ary[1],identifier = ary[2];
			
			if (type == '<') {
				this.token('TAG_START','<',1);
				this.pushEnd(INVERSES.TAG_START);
				
				if (match = TAG_TYPE.exec(this._chunk.substr(1,40))) {
					// special case should probably be handled in AST
					if (match[0] != 'self') {
						this.token('TAG_TYPE',match[0],match[0].length,1);
						return input.length + match[0].length;
					};
				};
				
				if (identifier) {
					if (identifier.substr(0,1) == '{') {
						return type.length;
					} else {
						this.token('TAG_NAME',input.substr(1),0);
					};
				};
			};
			
			return input.length;
		};
		
		
		Lexer.prototype.selectorToken = function (){
			var ary;
			var match;
			
			// special handling if we are in this context
			if (this._end == '%') {
				var chr = this._chunk.charAt(0);
				var open = this.inContext('open');
				
				// should add for +, ~ etc
				// should maybe rather look for the correct type of character?
				
				if (open && (chr == ' ' || chr == '\n' || chr == ',' || chr == '+' || chr == '~' || chr == ')' || chr == ']')) {
					// console.log "close this selector directly"
					this.token('SELECTOR_END','%',0);
					this.pair('%');
					return 0;
				};
				
				if (match = SELECTOR_COMBINATOR.exec(this._chunk)) {
					// spaces between? -- include the whole
					this.token('SELECTOR_COMBINATOR',match[1] || " ",match[0].length);
					return match[0].length;
				} else if (match = SELECTOR_PART.exec(this._chunk)) {
					var type = match[1];
					var id = match[2];
					
					switch (type) {
						case '.':
							tokid = 'SELECTOR_CLASS';break;
						
						case '#':
							tokid = 'SELECTOR_ID';break;
						
						case ':':
							tokid = 'SELECTOR_PSEUDO_CLASS';break;
						
						case '::':
							tokid = 'SELECTOR_PSEUDO_CLASS';break;
						
						default:
						
							var tokid = 'SELECTOR_TAG';
					
					};
					
					this.token(tokid,match[2],match[0].length);
					return match[0].length;
				} else if (chr == '[') {
					this.token('[','[',1);
					this.pushEnd(']');
					if (match = SELECTOR_ATTR.exec(this._chunk)) {
						// fuck this length shit
						var idoffset = match[0].indexOf(match[1]);
						var opoffset = match[0].indexOf(match[2]);
						this.token('IDENTIFIER',match[1],match[1].length,idoffset);
						this.token('SELECTOR_ATTR_OP',match[2],match[2].length,opoffset);
						return match[0].length;
					};
					return 1;
				} else if (chr == '|') {
					var tok = this._tokens[this._tokens.length - 1];
					tTs(tok,'SELECTOR_NS');
					// tok[0] = 'SELECTOR_NS' # FIX
					return 1;
				} else if (chr == ',') {
					this.token('SELECTOR_GROUP',',',1);
					return 1;
				} else if (chr == '*') {
					this.token('UNIVERSAL_SELECTOR','*',1);
					return 1;
				} else if (chr == ')') {
					this.pair('%');
					this.token('SELECTOR_END',')',1);
					return 1;
				} else if (idx$(chr,[')','}',']','']) >= 0) {
					this.pair('%');
					return 0;
				};
			};
			
			if (!(match = SELECTOR.exec(this._chunk))) { return 0 };
			var ary = iter$(match);var input = ary[0],id = ary[1],kind = ary[2];
			
			// this is a closed selector
			if (kind == '(') {
				// token '(','('
				this.token('SELECTOR_START',id,id.length + 1);
				// self.pushEnd(')') # are we so sure about this?
				this.pushEnd('%');
				
				// @ends.push ')'
				// @ends.push '%'
				return id.length + 1;
			} else if (id == '%') {
				// we are already scoped in on a selector
				if (this.context() == '%') { return 1 };
				this.token('SELECTOR_START',id,id.length);
				// this is a separate - scope. Full selector should rather be $, and keep the single selector as %
				
				this.scope('%',{open: true});
				// @ends.push '%'
				// make sure a terminator breaks out
				return id.length;
			} else {
				return 0;
			};
		};
		
		// is this really needed? Should be possible to
		// parse the identifiers and = etc i jison?
		// what is special about methodNameToken? really?
		Lexer.prototype.methodNameToken = function (){
			// we can optimize this by after a def simply
			// fetching all the way after the def until a space or (
			// and then add this to the def-token itself (as with fragment)
			if (this._chunk.charAt(0) == ' ') { return 0 };
			
			var match;
			
			if (this._end == ')') {
				var outerctx = this._ends[this._ends.length - 2];
				// weird assumption, no?
				// console.log 'context is inside!!!'
				if (outerctx == '%' && (match = TAG_ATTR.exec(this._chunk))) {
					this.token('TAG_ATTR_SET',match[1]);
					return match[0].length;
				};
			};
			
			if (!(match = METHOD_IDENTIFIER.exec(this._chunk))) {
				return 0;
			};
			// var prev = last @tokens
			var length = match[0].length;
			
			var id = match[0];
			var ltyp = this._lastTyp;
			var typ = 'IDENTIFIER';
			var pre = id.charAt(0);
			var space = false;
			
			var m4 = match[4]; // might be out of bounds? should rather check charAt
			// drop match 4??
			
			// should this not quit here in practically all cases?
			if (!((ltyp == '.' || ltyp == 'DEF') || (m4 == '!' || m4 == '?') || match[5])) {
				return 0;
			};
			
			// again, why?
			if (id == 'self' || id == 'this' || id == 'super') { // in ['SELF','THIS']
				return 0;
			};
			
			if (id == 'new') {
				typ = 'NEW';
			};
			
			if (id == '...' && [',','(','CALL_START','BLOCK_PARAM_START','PARAM_START'].indexOf(ltyp) >= 0) {
				return 0;
			};
			
			if (id == '|') {
				// hacky way to implement this
				// with new lexer we'll use { ... } instead, and assume object-context,
				// then go back and correct when we see the context is invalid
				if (ltyp == '(' || ltyp == 'CALL_START') {
					this.token('DO','DO',0);
					this.pushEnd('|');
					// @ends.push '|'
					this.token('BLOCK_PARAM_START',id,1);
					return length;
				} else if (ltyp == 'DO' || ltyp == '{') {
					// @ends.push '|'
					this.pushEnd('|');
					this.token('BLOCK_PARAM_START',id,1);
					return length;
				} else if (this._ends[this._ends.length - 1] == '|') {
					this.token('BLOCK_PARAM_END','|',1);
					this.pair('|');
					return length;
				} else {
					return 0;
				};
			};
			
			// whaat?
			// console.log("method identifier",id)
			if ((['&','^','<<','<<<','>>'].indexOf(id) >= 0 || (id == '|' && this.context() != '|'))) {
				return 0;
			};
			
			if (OP_METHODS.indexOf(id) >= 0) {
				space = true;
			};
			
			// not even anything we should use?!?
			if (pre == '@') {
				typ = 'IVAR';
			} else if (pre == '$') {
				true;
				// typ = 'GVAR'
			} else if (pre == '#') {
				typ = 'TAGID';
			} else if (CONST_IDENTIFIER.test(pre) || id == 'require' || id == 'global' || id == 'exports') {
				// really? seems very strange
				// console.log('global!!',typ,id)
				typ = 'CONST';
			};
			
			// what is this really for?
			if (match[5] && ['IDENTIFIER','CONST','GVAR','CVAR','IVAR','SELF','THIS',']','}',')','NUMBER','STRING','IDREF'].indexOf(ltyp) >= 0) {
				this.token('.','.',0);
			};
			
			this.token(typ,id,length);
			
			if (space) {
				this._last.spaced = true;
			};
			
			return length;
		};
		
		
		Lexer.prototype.inTag = function (){
			var len = this._ends.length;
			if (len > 0) {
				var ctx0 = this._ends[len - 1];
				var ctx1 = len > 1 ? (this._ends[len - 2]) : (ctx0);
				return ctx0 == 'TAG_END' || (ctx1 == 'TAG_END' && ctx0 == 'OUTDENT');
			};
			return false;
		};
		
		Lexer.prototype.isKeyword = function (id){
			if ((id == 'attr' || id == 'prop')) {
				var scop = this.getScope();
				var incls = scop == 'CLASS' || scop == 'TAG';
				// var scopes = @indents.map(|ind,i| @scopes[i] or 'NONE')
				// console.log "id is prop: {scopes.join(" -> ")} | {@indents.join(" -> ")}"
				if (incls) { return true };
			};
			
			return ALL_KEYWORDS.indexOf(id) >= 0;
		};
		
		// Matches identifying literals: variables, keywords, method names, etc.
		// Check to ensure that JavaScript reserved words aren't being used as
		// identifiers. Because Imba reserves a handful of keywords that are
		// allowed in JavaScript, we're careful not to tokid them as keywords when
		// referenced as property names here, so you can still do `jQuery.is()` even
		// though `is` means `===` otherwise.
		Lexer.prototype.identifierToken = function (){
			var ary;
			var match;
			
			var ctx0 = this._ends[this._ends.length - 1];
			var ctx1 = this._ends[this._ends.length - 2];
			var innerctx = ctx0;
			var typ;
			var reserved = false;
			
			var addLoc = false;
			var inTag = ctx0 == 'TAG_END' || (ctx1 == 'TAG_END' && ctx0 == 'OUTDENT');
			
			// console.log ctx1,ctx0
			
			if (inTag && (match = TAG_ATTR.exec(this._chunk))) {
				// console.log 'TAG_ATTR IN tokid',match
				// var prev = last @tokens
				// if the prev is a terminator, we dont really need to care?
				if (this._lastTyp != 'TAG_NAME') {
					if (this._lastTyp == 'TERMINATOR') {
						// console.log('prev was terminator -- drop it?')
						true;
					} else {
						this.token(",",",");
					};
				};
				
				var l = match[0].length;
				
				this.token('TAG_ATTR',match[1],l - 1); // add to loc?
				this._loc += l - 1;
				this.token('=','=',1);
				return l;
			};
			
			// see if this is a plain object-key
			// way too much logic going on here?
			// the ast should normalize whether keys
			// are accessable as keys or strings etc
			if (match = OBJECT_KEY.exec(this._chunk)) {
				var id = match[1];
				typ = 'IDENTIFIER';
				
				// FIXME loc of key includes colon
				// moveCaret(id:length)
				// console.log "ok"
				if (true) {
					// console.log "got here? {match}"
					this.token(typ,id,id.length);
					this.moveCaret(id.length);
					this.token(':',':',match[3].length);
					this.moveCaret(-id.length);
					// moveCaret(match[3]:length)
					return match[0].length;
				};
				
				// moveCaret(match[2]:length)
				// return 0
				// console.log match[3]:length
				this.token(typ,id,match[0].length);
				this.token(':',':',1);
				return match[0].length;
			};
			
			if (!(match = IDENTIFIER.exec(this._chunk))) {
				return 0;
			};
			
			var ary = iter$(match);var input = ary[0],id = ary[1],typ = ary[2],m3 = ary[3],m4 = ary[4],colon = ary[5];
			var idlen = id.length;
			
			// What is the logic here?
			if (id == 'own' && this.lastTokenType() == 'FOR') {
				this.token('OWN',id,id.length);
				return id.length;
			};
			
			var prev = last(this._tokens);
			var lastTyp = this._lastTyp;
			
			// should we force this to be an identifier even if it is a reserved word?
			// this should only happen for when part of object etc
			// will prev ever be @???
			var forcedIdentifier;
			
			// again
			forcedIdentifier = colon || lastTyp == '.' || lastTyp == '?.'; // in ['.', '?.'
			
			
			// temp hack! need to solve for other keywords etc as well
			// problem appears with ternary conditions.
			
			// well -- it should still be an indentifier if in object?
			// forcedIdentifier = no if id in ['undefined','break']
			
			if (colon && lastTyp == '?') { forcedIdentifier = false }; // for ternary
			
			// if we are not at the top level? -- hacky
			if (id == 'tag' && this._chunk.indexOf("tag(") == 0) { // @chunk.match(/^tokid\(/)
				forcedIdentifier = true;
			};
			
			var isKeyword = false;
			
			// console.log "match",match
			// console.log "typ is {typ}"
			// little reason to check for this right here? but I guess it is only a simple check
			if (typ == '$' && ARGVAR.test(id)) { // id.match(/^\$\d$/)
				// console.log "TYP $"
				if (id == '$0') {
					typ = 'ARGUMENTS';
				} else {
					typ = 'ARGVAR';
					id = id.substr(1);
				};
			} else if (typ == '@') {
				typ = 'IVAR';
				
				// id:reserved = yes if colon
			} else if (typ == '#') {
				// we are trying to move to generic tokens,
				// so we are starting to splitting up the symbols and the items
				// we'll see if that works
				typ = 'IDENTIFIER';
				this.token('#','#');
				id = id.substr(1);
			} else if (typ == '@@') {
				typ = 'CVAR';
			} else if (typ == '$' && !colon) {
				typ = 'IDENTIFIER';
				// typ = 'GVAR'
			} else if (CONST_IDENTIFIER.test(id) || id == 'require' || id == 'global' || id == 'exports') {
				// thous should really be handled by the ast instead
				typ = 'CONST';
			} else if (id == 'elif') {
				this.token('ELSE','elif',id.length);
				this.token('IF','if');
				return id.length;
			} else {
				typ = 'IDENTIFIER';
			};
			
			
			
			// this catches all 
			if (!forcedIdentifier && (isKeyword = this.isKeyword(id))) {
				// (id in JS_KEYWORDS or id in IMBA_KEYWORDS)
				typ = id.toUpperCase();
				addLoc = true;
				
				// clumsy - but testing performance
				if (typ == 'YES') {
					typ = 'TRUE';
				} else if (typ == 'NO') {
					typ = 'FALSE';
				} else if (typ == 'NIL') {
					typ = 'NULL';
				} else if (typ == 'VAR') {
					if (this._lastVal == 'export') {
						tTs(prev,'EXPORT');
					};
				} else if (typ == 'IF' || typ == 'ELSE' || typ == 'TRUE' || typ == 'FALSE' || typ == 'NULL') {
					true;
				} else if (typ == 'TAG') {
					this.pushEnd('TAG');
					// @ends.push('TAG')
				} else if (typ == 'DEF') {
					// should probably shift context and optimize this
					this.openDef();
				} else if (typ == 'DO') {
					if (this.context() == 'DEF') this.closeDef();
				} else if (typ == 'WHEN' && LINE_BREAK.indexOf(this.lastTokenType()) >= 0) {
					typ = 'LEADING_WHEN';
				} else if (typ == 'FOR') {
					this._seenFor = true;
				} else if (typ == 'UNLESS') {
					typ = 'IF'; // WARN
				} else if (UNARY.indexOf(typ) >= 0) {
					typ = 'UNARY';
				} else if (RELATION.indexOf(typ) >= 0) {
					if (typ != 'INSTANCEOF' && typ != 'ISA' && this._seenFor) {
						typ = 'FOR' + typ; // ?
						this._seenFor = false;
					} else {
						typ = 'RELATION';
						if (String(this.value()) == '!') {
							this._tokens.pop(); // is fucked up??!
							// WARN we need to keep the loc, no?
							id = '!' + id;
						};
					};
				};
			};
			
			if (id == 'super') {
				typ = 'SUPER';
			};
			
			// do we really want to check this here
			if (!forcedIdentifier) {
				// should already have dealt with this
				
				if (isKeyword && IMBA_ALIASES.indexOf(id) >= 0) { id = IMBA_ALIAS_MAP[id] };
				// these really should not go here?!?
				switch (id) {
					case '!':
						typ = 'UNARY';break;
					
					case '==':
					case '!=':
					case '===':
					case '!==':
						typ = 'COMPARE';break;
					
					case '&&':
					case '||':
						typ = 'LOGIC';break;
					
					case 'break':
					case 'continue':
					case 'debugger':
					case 'arguments':
						typ = id.toUpperCase();break;
				
				};
			};
			
			// prev = last @tokens
			var len = input.length;
			
			// should be strict about the order, check this manually instead
			if (typ == 'CLASS' || typ == 'DEF' || typ == 'TAG') {
				this.queueScope(typ);
				
				var i = this._tokens.length;
				
				while (i){
					prev = this._tokens[--i];
					var ctrl = "" + tV(prev);
					// console.log("ctrl is {ctrl}")
					// need to coerce to string because of stupid CS ===
					// console.log("prev is",prev[0],prev[1])
					if (idx$(ctrl,IMBA_CONTEXTUAL_KEYWORDS) >= 0) {
						tTs(prev,ctrl.toUpperCase());
						// prev[0] = ctrl.toUpperCase # FIX
					} else {
						break;
					};
				};
			} else if (typ == 'IF') {
				this.queueScope(typ);
			} else if (typ == 'IMPORT') {
				// could manually parse the whole ting here?
				this.pushEnd('IMPORT');
				// @ends.push 'IMPORT'
			} else if (id == 'from' && ctx0 == 'IMPORT') {
				typ = 'FROM';
				this.pair('IMPORT');
			} else if (id == 'as' && ctx0 == 'IMPORT') {
				typ = 'AS';
				this.pair('IMPORT');
			};
			
			if (typ == 'IDENTIFIER') {
				// see if previous was catch -- belongs in rewriter?
				if (lastTyp == 'CATCH') {
					typ = 'CATCH_VAR';
				};
			};
			
			if (colon) {
				this.token(typ,id,idlen);
				this.moveCaret(idlen);
				// console.log "add colon?"
				this.token(':',':',colon.length);
				this.moveCaret(-idlen);
			} else {
				this.token(typ,id,idlen);
			};
			
			return len;
		};
		
		// Matches numbers, including decimals, hex, and exponential notation.
		// Be careful not to interfere with ranges-in-progress.
		Lexer.prototype.numberToken = function (){
			var binaryLiteral;
			var match,number,lexedLength;
			
			if (!(match = NUMBER.exec(this._chunk))) { return 0 };
			
			number = match[0];
			lexedLength = number.length;
			
			if (binaryLiteral = /0b([01]+)/.exec(number)) {
				
				number = "" + parseInt(binaryLiteral[1],2);
			};
			
			var prev = last(this._tokens);
			
			if (match[0][0] == '.' && prev && !prev.spaced && ['IDENTIFIER',')','}',']','NUMBER'].indexOf(tT(prev)) >= 0) {
				// console.log "got here"
				this.token(".",".");
				number = number.substr(1);
			};
			
			
			this.token('NUMBER',number,lexedLength);
			return lexedLength;
		};
		
		Lexer.prototype.symbolToken = function (){
			var match,symbol,prev;
			
			if (!(match = SYMBOL.exec(this._chunk))) { return 0 };
			symbol = match[0].substr(1);
			prev = last(this._tokens);
			
			// is this a property-access?
			// should invert this -- only allow when prev IS .. 
			
			// : should be a token itself, with a specification of spacing (LR,R,L,NONE)
			
			// FIX
			if (prev && !prev.spaced && idx$(tT(prev),['(','{','[','.','CALL_START','INDEX_START',',','=','INDENT','TERMINATOR']) == -1) {
				this.token('.:',':',1);
				var sym = symbol.split(/[\:\\\/]/)[0]; // really?
				// token 'SYMBOL', "'#{symbol}'"
				this.token('IDENTIFIER',sym,sym.length,1);
				return (sym.length + 1);
			} else {
				// token 'SYMBOL', "'#{symbol}'"
				this.token('SYMBOL',symbol,match[0].length);
				return match[0].length;
			};
		};
		
		Lexer.prototype.escapeStr = function (str,heredoc,q){
			str = str.replace(MULTILINER,(heredoc ? ('\\n') : ('')));
			if (q) {
				var r = RegExp(("\\\\[" + q + "]"),"g");
				str = str.replace(r,q);
				str = str.replace(RegExp(("" + q),"g"),'\\$&');
			};
			return str;
			
			// str = str.replace(MULTILINER, '\\n')
			// str = str.replace(/\t/g, '\\t')
		};
		// Matches strings, including multi-line strings. Ensures that quotation marks
		// are balanced within the string's contents, and within nested interpolations.
		Lexer.prototype.stringToken = function (){
			var match,string;
			
			switch (this._chunk.charAt(0)) {
				case "'":
					if (!(match = SIMPLESTR.exec(this._chunk))) { return 0 };
					string = match[0];
					this.token('STRING',this.escapeStr(string),string.length);
					// token 'STRING', (string = match[0]).replace(MULTILINER, '\\\n'), string:length
					break;
				
				case '"':
					if (!(string = this.balancedString(this._chunk,'"'))) { return 0 };
					// what about tripe quoted strings?
					
					if (string.indexOf('{') >= 0) {
						var len = string.length;
						// if this has no interpolation?
						// we are now messing with locations - beware
						this.token('STRING_START',string.charAt(0),1);
						this.interpolateString(string.slice(1,-1));
						this.token('STRING_END',string.charAt(len - 1),1,string.length - 1);
					} else {
						len = string.length;
						// string = string.replace(MULTILINER, '\\\n')
						this.token('STRING',this.escapeStr(string),len);
					};
					break;
				
				default:
				
					return 0;
			
			};
			
			this.moveHead(string);
			return string.length;
		};
		
		// Matches heredocs, adjusting indentation to the correct level, as heredocs
		// preserve whitespace, but ignore indentation to the left.
		Lexer.prototype.heredocToken = function (){
			var match,heredoc,quote,doc;
			
			if (!(match = HEREDOC.exec(this._chunk))) { return 0 };
			
			heredoc = match[0];
			quote = heredoc.charAt(0);
			doc = this.sanitizeHeredoc(match[2],{quote: quote,indent: null});
			// console.log "found heredoc {match[0]:length} {doc:length}"
			
			if (quote == '"' && doc.indexOf('{') >= 0) {
				var open = match[1];
				// console.log doc.substr(0,3),match[1]
				this.token('STRING_START',open,open.length);
				this.interpolateString(doc,{heredoc: true,offset: open.length,quote: quote});
				this.token('STRING_END',open,open.length,heredoc.length - open.length);
			} else {
				this.token('STRING',this.makeString(doc,quote,true),0);
			};
			
			this.moveHead(heredoc);
			return heredoc.length;
		};
		
		// Matches and consumes comments.
		Lexer.prototype.commentToken = function (){
			var match,length,comment,indent,prev;
			
			var typ = 'HERECOMMENT';
			
			if (match = INLINE_COMMENT.exec(this._chunk)) { // .match(INLINE_COMMENT)
				// console.log "match inline comment"
				length = match[0].length;
				indent = match[1];
				comment = match[2];
				
				prev = last(this._tokens);
				var pt = prev && tT(prev);
				var note = '//' + comment.substr(1);
				
				if (this._last && this._last.spaced) {
					note = ' ' + note;
					// console.log "the previous node was SPACED"
				};
				// console.log "comment {note} - indent({indent}) - {length} {comment:length}"
				
				if ((pt && pt != 'INDENT' && pt != 'TERMINATOR') || !pt) {
					// console.log "skip comment"
					// token 'INLINECOMMENT', comment.substr(2)
					// console.log "adding as terminator"
					this.token('TERMINATOR',note,length); // + '\n'
				} else {
					// console.log "add comment ({note})"
					if (pt == 'TERMINATOR') {
						tVs(prev,tV(prev) + note);
						// prev[1] += note
					} else if (pt == 'INDENT') {
						// console.log "adding comment to INDENT: {note}" # why not add directly here?
						this.addLinebreaks(1,note);
					} else {
						// console.log "comment here"
						// should we ever get here?
						this.token(typ,comment.substr(2),length); // are we sure?
					};
				};
				
				return length; // disable now while compiling
			};
			
			// should use exec?
			if (!(match = COMMENT.exec(this._chunk))) { return 0 };
			
			comment = match[0];
			var here = match[1];
			
			if (here) {
				this.token('HERECOMMENT',this.sanitizeHeredoc(here,{herecomment: true,indent: Array(this._indent + 1).join(' ')}),comment.length);
				this.token('TERMINATOR','\n');
			} else {
				this.token('HERECOMMENT',comment,comment.length);
				this.token('TERMINATOR','\n'); // auto? really?
			};
			
			this.moveHead(comment);
			return comment.length;
		};
		
		// Matches JavaScript interpolated directly into the source via backticks.
		Lexer.prototype.jsToken = function (){
			var match,script;
			
			if (!(this._chunk.charAt(0) == '`' && (match = JSTOKEN.exec(this._chunk)))) { return 0 };
			this.token('JS',(script = match[0]).slice(1,-1));
			return script.length;
		};
		
		// Matches regular expression literals. Lexing regular expressions is difficult
		// to distinguish from division, so we borrow some basic heuristics from
		// JavaScript and Ruby.
		Lexer.prototype.regexToken = function (){
			var ary;
			var match,length,prev;
			
			if (this._chunk.charAt(0) != '/') { return 0 };
			if (match = HEREGEX.exec(this._chunk)) {
				length = this.heregexToken(match);
				this.moveHead(match[0]);
				return length;
			};
			
			prev = last(this._tokens);
			// FIX
			if (prev && (idx$(tT(prev),(prev.spaced ? (
				NOT_REGEX
			) : (
				NOT_SPACED_REGEX
			))) >= 0)) { return 0 };
			if (!(match = REGEX.exec(this._chunk))) { return 0 };
			var ary = iter$(match);var m = ary[0],regex = ary[1],flags = ary[2];
			
			// FIXME
			// if regex[..1] is '/*'
			//	error 'regular expressions cannot begin with `*`'
			
			if (regex == '//') {
				regex = '/(?:)/';
			};
			
			this.token('REGEX',("" + regex + flags),m.length);
			return m.length;
		};
		
		// Matches multiline extended regular expressions.
		// The escaping should rather happen in AST - possibly as an additional flag?
		Lexer.prototype.heregexToken = function (match){
			var ary;
			var ary = iter$(match);var heregex = ary[0],body = ary[1],flags = ary[2];
			
			if (0 > body.indexOf('#{')) {
				
				var re = body.replace(HEREGEX_OMIT,'').replace(/\//g,'\\/');
				
				if (re.match(/^\*/)) {
					this.error('regular expressions cannot begin with `*`');
				};
				
				this.token('REGEX',("/" + (re || '(?:)') + "/" + flags),heregex.length);
				return heregex.length;
			};
			
			// use more basic regex type
			
			this.token('CONST','RegExp');
			this._tokens.push(T.token('CALL_START','(',0));
			var tokens = [];
			
			for (var i = 0, items = iter$(this.interpolateString(body,{regex: true})), len = items.length, pair; i < len; i++) {
				
				pair = items[i];
				var tok = tT(pair); // FIX
				var value = tV(pair); // FIX
				
				if (tok == 'TOKENS') {
					// FIXME what is this?
					tokens.push.apply(tokens,value);
				} else {
					if (!value) {
						console.log("what??");
					};
					
					if (!(value = value.replace(HEREGEX_OMIT,''))) { continue; };
					
					value = value.replace(/\\/g,'\\\\');
					tokens.push(T.token('STRING',this.makeString(value,'"',true),0)); // FIX
				};
				
				tokens.push(T.token('+','+',0)); // FIX
			};
			
			tokens.pop();
			
			// FIX
			if (!(tokens[0] && tT(tokens[0]) == 'STRING')) {
				// FIX
				this._tokens.push(T.token('STRING','""'),T.token('+','+'));
			};
			
			this._tokens.push.apply(this._tokens,tokens); // what is this?
			// FIX
			
			if (flags) {
				this._tokens.push(T.token(',',',',0));
				this._tokens.push(T.token('STRING','"' + flags + '"',0));
			};
			
			this.token(')',')',0);
			
			return heregex.length;
		};
		
		// Matches newlines, indents, and outdents, and determines which is which.
		// If we can detect that the current line is continued onto the the next line,
		// then the newline is suppressed:
		//
		//     elements
		//       .each( ... )
		//       .map( ... )
		//
		// Keeps track of the level of indentation, because a single outdent token
		// can close multiple indents, so we need to know how far in we happen to be.
		Lexer.prototype.lineToken = function (){
			var match;
			
			if (!(match = MULTI_DENT.exec(this._chunk))) { return 0 };
			
			var indent = match[0];
			var brCount = this.moveHead(indent);
			
			this._seenFor = false;
			// reset column as well?
			
			var prev = last(this._tokens,1);
			var whitespace = indent.substr(indent.lastIndexOf('\n') + 1);
			var size = whitespace.length;
			var noNewlines = this.unfinished();
			
			if ((/^\n#\s/).test(this._chunk)) {
				this.addLinebreaks(1);
				return 0;
			};
			
			if (size > 0) {
				if (!this._indentStyle) {
					this._opts.indent = this._indentStyle = whitespace;
				};
				
				var indentSize = 0;
				var offset = 0;
				
				while (true){
					var idx = whitespace.indexOf(this._indentStyle,offset);
					if (idx == offset) {
						indentSize++;
						offset += this._indentStyle.length;
					} else if (offset == whitespace.length) {
						break;
					} else {
						// workaround to report correct location
						this._loc += indent.length - whitespace.length;
						this.token('INDENT',whitespace,whitespace.length);
						return this.error('inconsistent indentation');
					};
				};
				
				size = indentSize;
			};
			
			
			if (size - this._indebt == this._indent) {
				if (noNewlines) {
					this.suppressNewlines();
				} else {
					this.newlineToken(brCount);
				};
				return indent.length;
			};
			
			if (size > this._indent) {
				if (noNewlines) {
					this._indebt = size - this._indent;
					this.suppressNewlines();
					return indent.length;
				};
				
				if (this.inTag()) {
					// console.log "indent inside tokid?!?"
					// @indebt = size - @indent
					// suppressNewlines()
					return indent.length;
				};
				
				
				var diff = size - this._indent + this._outdebt;
				this.closeDef();
				
				var immediate = last(this._tokens);
				
				if (immediate && tT(immediate) == 'TERMINATOR') {
					tTs(immediate,'INDENT');
					immediate._meta || (immediate._meta = {pre: tV(immediate),post: ''});
					
					// should rather add to meta somehow?!?
					// tVs(immediate,tV(immediate) + '%|%') # crazy
				} else {
					this.token('INDENT',"" + diff,0);
				};
				
				// console.log "indenting", prev, last(@tokens,1)
				// if prev and prev[0] == 'TERMINATOR'
				//   console.log "terminator before indent??"
				
				// check for comments as well ?
				
				this._indents.push(diff);
				this.pushEnd('OUTDENT');
				// @ends.push 'OUTDENT'
				this._outdebt = this._indebt = 0;
				this.addLinebreaks(brCount);
			} else {
				this._indebt = 0;
				this.outdentToken(this._indent - size,noNewlines,brCount);
				this.addLinebreaks(brCount - 1);
				// console.log "outdent",noNewlines,tokid()
			};
			
			this._indent = size;
			return indent.length;
		};
		
		// Record an outdent token or multiple tokens, if we happen to be moving back
		// inwards past several recorded indents.
		Lexer.prototype.outdentToken = function (moveOut,noNewlines,newlineCount){
			// here we should also take care to pop / reset the scope-body
			// or context-type for indentation 
			var dent = 0;
			while (moveOut > 0){
				var len = this._indents.length - 1;
				if (this._indents[len] == undefined) {
					moveOut = 0;
				} else if (this._indents[len] == this._outdebt) {
					moveOut -= this._outdebt;
					this._outdebt = 0;
				} else if (this._indents[len] < this._outdebt) {
					this._outdebt -= this._indents[len];
					moveOut -= this._indents[len];
				} else {
					dent = this._indents.pop() - this._outdebt;
					moveOut -= dent;
					this._outdebt = 0;
					
					if (!noNewlines) { this.addLinebreaks(1) };
					
					this.pair('OUTDENT');
					this.token('OUTDENT',"" + dent,0);
				};
			};
			
			if (dent) { this._outdebt -= moveOut };
			
			while (this.lastTokenValue() == ';'){
				this._tokens.pop();
			};
			
			if (!(this.lastTokenType() == 'TERMINATOR' || noNewlines)) { this.token('TERMINATOR','\n',0) };
			
			// capping scopes so they dont hang around 
			this._scopes.length = this._indents.length;
			
			var ctx = this.context();
			if (ctx == '%' || ctx == 'TAG') { this.pair(ctx) }; // really?
			this.closeDef();
			return this;
		};
		
		// Matches and consumes non-meaningful whitespace. tokid the previous token
		// as being "spaced", because there are some cases where it makes a difference.
		Lexer.prototype.whitespaceToken = function (){
			var match,nline,prev;
			if (!((match = WHITESPACE.exec(this._chunk)) || (nline = this._chunk.charAt(0) == '\n'))) { return 0 };
			prev = last(this._tokens);
			
			// FIX - why oh why?
			if (prev) {
				if (match) {
					prev.spaced = true;
					return match[0].length;
				} else {
					prev.newLine = true;
					return 0;
				};
			};
		};
		
		Lexer.prototype.addNewline = function (){
			return this.token('TERMINATOR','\n');
		};
		
		Lexer.prototype.moveHead = function (str){
			var br = count(str,'\n');
			return br;
		};
		
		
		Lexer.prototype.addLinebreaks = function (count,raw){
			var br;
			
			if (!raw && count == 0) { return this }; // no terminators?
			
			var prev = this._last;
			
			if (!raw) {
				if (count == 1) {
					br = '\n';
				} else if (count == 2) {
					br = '\n\n';
				} else if (count == 3) {
					br = '\n\n\n';
				} else {
					br = repeatString('\n',count);
				};
			};
			// FIX
			if (prev) {
				var t = prev._type; // @lastTyp
				var v = tV(prev);
				
				// we really want to add this
				if (t == 'INDENT') {
					// TODO we want to add to the indent
					// console.log "add the comment to the indent -- pre? {raw} {br}"
					
					var meta = prev._meta || (prev._meta = {pre: '',post: ''});
					meta.post += (raw || br);
					// tVs(v + (raw or br))
					return this;
				} else if (t == 'TERMINATOR') {
					// console.log "already exists terminator {br} {raw}"
					tVs(prev,v + (raw || br));
					return this;
				};
			};
			
			this.token('TERMINATOR',br,0);
			return;
		};
		
		// Generate a newline token. Consecutive newlines get merged together.
		Lexer.prototype.newlineToken = function (lines){
			// console.log "newlineToken"
			while (this.lastTokenValue() == ';'){
				console.log("pop token",this._tokens[this._tokens.length - 1]);
				this._tokens.pop();
			};
			
			this.addLinebreaks(lines);
			
			var ctx = this.context();
			// WARN now import cannot go over multiple lines
			if (ctx == 'TAG' || ctx == 'IMPORT') { this.pair(ctx) };
			this.closeDef(); // close def -- really?
			return this;
		};
		
		// Use a `\` at a line-ending to suppress the newline.
		// The slash is removed here once its job is done.
		Lexer.prototype.suppressNewlines = function (){
			if (this.value() == '\\') { this._tokens.pop() };
			return this;
		};
		
		// We treat all other single characters as a token. E.g.: `( ) , . !`
		// Multi-character operators are also literal tokens, so that Jison can assign
		// the proper order of operations. There are some symbols that we tokid specially
		// here. `;` and newlines are both treated as a `TERMINATOR`, we distinguish
		// parentheses that indicate a method call from regular parentheses, and so on.
		Lexer.prototype.literalToken = function (){
			var match,value;
			if (match = OPERATOR.exec(this._chunk)) {
				value = match[0];
				if (CODE.test(value)) this.tagParameters();
			} else {
				value = this._chunk.charAt(0);
			};
			
			var end1 = this._ends[this._ends.length - 1];
			var end2 = this._ends[this._ends.length - 2];
			
			var inTag = end1 == 'TAG_END' || end1 == 'OUTDENT' && end2 == 'TAG_END';
			
			var tokid = value;
			var prev = last(this._tokens);
			var pt = prev && tT(prev);
			var pv = prev && tV(prev);
			var length = value.length;
			
			// is this needed?
			if (value == '=' && prev) {
				
				if (pv == '||' || pv == '&&') { // in ['||', '&&']
					tTs(prev,'COMPOUND_ASSIGN');
					tVs(prev,pv + '=');
					// prev[0] = 'COMPOUND_ASSIGN'
					// prev[1] += '='
					return value.length;
				};
			};
			
			if (value == ';') {
				this._seenFor = false;
				tokid = 'TERMINATOR';
			} else if (value == '(' && inTag && pt != '=' && prev.spaced) { // FIXed
				// console.log 'spaced before ( in tokid'
				// FIXME - should rather add a special token like TAG_PARAMS_START
				this.token(',',',');
			} else if (value == '->' && inTag) {
				tokid = 'TAG_END';
				this.pair('TAG_END');
			} else if (value == '/>' && inTag) {
				tokid = 'TAG_END';
				this.pair('TAG_END');
			} else if (value == '>' && inTag) {
				tokid = 'TAG_END';
				this.pair('TAG_END');
			} else if (value == '>' && this.context() == 'DEF') {
				// console.log('picked up >!!')
				tokid = 'DEF_FRAGMENT';
				
				// elif value is 'TERMINATOR' and end1 is '%' 
				// 	closeSelector()
			} else if (value == 'TERMINATOR' && end1 == 'DEF') {
				this.closeDef();
			} else if (value == '&' && this.context() == 'DEF') {
				// console.log("okay!")
				tokid = 'BLOCK_ARG';
				// change the next identifier instead?
			} else if (value == '*' && this._chunk.charAt(1).match(/[A-Za-z\_\@\[]/) && (prev.spaced || [',','(','[','{','|','\n','\t'].indexOf(pv) >= 0)) {
				tokid = "SPLAT";
			} else if (value == '√') {
				tokid = 'SQRT';
			} else if (value == 'ƒ') {
				tokid = 'FUNC';
			} else if (idx$(value,MATH) >= 0) {
				tokid = 'MATH';
			} else if (idx$(value,COMPARE) >= 0) {
				tokid = 'COMPARE';
			} else if (idx$(value,COMPOUND_ASSIGN) >= 0) {
				tokid = 'COMPOUND_ASSIGN';
			} else if (idx$(value,UNARY) >= 0) {
				tokid = 'UNARY';
			} else if (idx$(value,SHIFT) >= 0) {
				tokid = 'SHIFT';
			} else if (idx$(value,LOGIC) >= 0) {
				tokid = 'LOGIC'; // or value is '?' and prev?:spaced 
			} else if (prev && !prev.spaced) {
				// need a better way to do these
				if (value == '(' && end1 == '%') {
					tokid = 'TAG_ATTRS_START';
				} else if (value == '(' && idx$(pt,CALLABLE) >= 0) {
					// not using this ???
					// prev[0] = 'FUNC_EXIST' if prev[0] is '?'
					tokid = 'CALL_START';
				} else if (value == '[' && idx$(pt,INDEXABLE) >= 0) {
					tokid = 'INDEX_START';
					if (pt == '?') { tTs(prev,'INDEX_SOAK') };
					// prev[0] = 'INDEX_SOAK' if prev[0] == '?'
				};
			};
			
			switch (value) {
				case '(':
				case '{':
				case '[':
					this.pushEnd(INVERSES[value]);break;
				
				case ')':
				case '}':
				case ']':
					this.pair(value);break;
			
			};
			
			// hacky rule to try to allow for tuple-assignments in blocks
			// if value is ',' and prev[0] is 'IDENTIFIER' and @tokens[@tokens:length - 2][0] in ['TERMINATOR','INDENT']
			//   # token "TUPLE", "tuple" # should rather insert it somewhere else, no?
			//   console.log("found comma")
			
			this.token(tokid,value,value.length);
			return value.length;
		};
		
		// Token Manipulators
		// ------------------
		
		// Sanitize a heredoc or herecomment by
		// erasing all external indentation on the left-hand side.
		Lexer.prototype.sanitizeHeredoc = function (doc,options){
			var match;
			var indent = options.indent;
			var herecomment = options.herecomment;
			
			if (herecomment) {
				if (HEREDOC_ILLEGAL.test(doc)) {
					this.error("block comment cannot contain '*/' starting");
				};
				if (doc.indexOf('\n') <= 0) { return doc };
			} else {
				var length_;while (match = HEREDOC_INDENT.exec(doc)){
					var attempt = match[1];
					if (indent == null || 0 < (length_ = attempt.length) && length_ < indent.length) {
						indent = attempt;
					};
				};
			};
			
			if (indent) { doc = doc.replace(RegExp(("\\n" + indent),"g"),'\n') };
			if (!herecomment) { doc = doc.replace(/^\n/,'') };
			return doc;
		};
		
		// A source of ambiguity in our grammar used to be parameter lists in function
		// definitions versus argument lists in function calls. Walk backwards, tokidging
		// parameters specially in order to make things easier for the parser.
		Lexer.prototype.tagParameters = function (){
			var tok;
			if (this.lastTokenType() != ')') { return this };
			var stack = [];
			var tokens = this._tokens;
			var i = tokens.length;
			
			tTs(tokens[--i],'PARAM_END');
			
			while (tok = tokens[--i]){
				var t = tT(tok);
				switch (t) {
					case ')':
						stack.push(tok);
						break;
					
					case '(':
					case 'CALL_START':
						if (stack.length) {
							stack.pop();
						} else if (t == '(') {
							tTs(tok,'PARAM_START');
							return this;
						} else {
							return this;
						};
						break;
				
				};
			};
			
			return this;
		};
		
		// Close up all remaining open blocks at the end of the file.
		Lexer.prototype.closeIndentation = function (){
			// ctx = context
			// pair(ctx) if ctx in ['%','DEF']
			this.closeDef();
			this.closeSelector();
			return this.outdentToken(this._indent,false,0);
		};
		
		// Matches a balanced group such as a single or double-quoted string. Pass in
		// a series of delimiters, all of which must be nested correctly within the
		// contents of the string. This method allows us to have strings within
		// interpolations within strings, ad infinitum.
		Lexer.prototype.balancedString = function (str,end){
			var match,letter,prev;
			
			// console.log 'balancing string!', str, end
			var stack = [end];
			var i = 0;
			
			// could it not happen here?
			while (i < (str.length - 1)){
				i++;
				letter = str.charAt(i);
				switch (letter) {
					case '\\':
						i++;
						continue;
						break;
					
					case end:
						stack.pop();
						if (!stack.length) {
							var v = str.slice(0,i + 1);
							return v;
						};
						end = stack[stack.length - 1];
						continue;
						break;
				
				};
				
				if (end == '}' && (letter == '"' || letter == "'")) {
					stack.push(end = letter);
				} else if (end == '}' && letter == '/' && (match = (HEREGEX.exec(str.slice(i)) || REGEX.exec(str.slice(i))))) {
					i += match[0].length - 1;
				} else if (end == '}' && letter == '{') {
					stack.push(end = '}');
				} else if (end == '"' && letter == '{') {
					stack.push(end = '}');
				};
				prev = letter;
			};
			
			if (!this._opts.silent) { return this.error(("missing " + (stack.pop()) + ", starting")) };
		};
		
		// Expand variables and expressions inside double-quoted strings using
		// Ruby-like notation for substitution of arbitrary expressions.
		//
		//     "Hello #{name.capitalize()}."
		//
		// If it encounters an interpolation, this method will recursively create a
		// new Lexer, tokenize the interpolated contents, and merge them into the
		// token stream.
		Lexer.prototype.interpolateString = function (str,options){
			// console.log "interpolate string"
			if(options === undefined) options = {};
			var heredoc = options.heredoc;
			var quote = options.quote;
			var regex = options.regex;
			var prefix = options.prefix;
			
			var startLoc = this._loc;
			var tokens = [];
			var pi = 0;
			var i = -1;
			var locOffset = options.offset || 1;
			var strlen = str.length;
			var letter;
			var expr;
			
			var isInterpolated = false;
			// out of bounds
			while (letter = str.charAt(i += 1)){
				if (letter == '\\') {
					i += 1;
					continue;
				};
				
				if (!(str.charAt(i) == '{' && (expr = this.balancedString(str.slice(i),'}')))) {
					continue;
				};
				
				isInterpolated = true;
				
				// these have no real sense of location or anything?
				if (pi < i) {
					// this is the prefix-string - before any item
					var tok = new Token('NEOSTRING',this.escapeStr(str.slice(pi,i),heredoc,quote),this._loc + pi + locOffset,i - pi);
					// tok.@loc = @loc + pi
					// tok.@len = i - pi + 2
					tokens.push(tok);
				};
				
				tokens.push(new Token('{{','{',this._loc + i + locOffset,1));
				
				var inner = expr.slice(1,-1);
				// console.log 'inner is',inner
				// remove leading spaces 
				// need to keep track of how much whitespace we dropped from the start
				inner = inner.replace(/^[^\n\S]+/,'');
				
				if (inner.length) {
					// we need to remember the loc we start at
					// console.log('interpolate from loc',@loc,i)
					// really? why not just add to the stack??
					// what about the added 
					// should share with the selector no?
					// console.log "tokenize inner parts of string",inner
					var spaces = 0;
					var offset = this._loc + i + (expr.length - inner.length) - 1;
					// why create a whole new lexer? Should rather reuse one
					// much better to simply move into interpolation mode where
					// we continue parsing until we meet unpaired }
					var nested = new Lexer().tokenize(inner,{inline: true,rewrite: false,loc: offset + locOffset});
					// console.log nested.pop
					
					if (nested[0] && tT(nested[0]) == 'TERMINATOR') {
						nested.shift();
					};
					
					if (nested.length) {
						tokens.push.apply(tokens,nested); // T.token('TOKENS',nested,0)
					};
				};
				
				// should rather add the amount by which our lexer has moved?
				i += expr.length - 1;
				tokens.push(new Token('}}','}',this._loc + i + locOffset,1));
				pi = i + 1;
			};
			
			// adding the last part of the string here
			if (i >= pi && pi < str.length) {
				// set the length as well - or?
				// the string after?
				// console.log 'push neostring'
				tokens.push(new Token('NEOSTRING',this.escapeStr(str.slice(pi),heredoc,quote),this._loc + pi + locOffset,str.length - pi));
			};
			
			// console.log tokens:length
			if (regex) { return tokens };
			
			if (!tokens.length) { return this.token('NEOSTRING','""') };
			
			for (var j = 0, len = tokens.length; j < len; j++) {
				this._tokens.push(tokens[j]);
			};
			
			return tokens;
		};
		
		// Matches a balanced group such as a single or double-quoted string. Pass in
		// a series of delimiters, all of which must be nested correctly within the
		// contents of the string. This method allows us to have strings within
		// interpolations within strings, ad infinitum.
		Lexer.prototype.balancedSelector = function (str,end){
			var prev;
			var letter;
			var stack = [end];
			// FIXME
			for (var len = str.length, i = 1; i < len; i++) {
				switch (letter = str.charAt(i)) {
					case '\\':
						i++;
						continue;
						break;
					
					case end:
						stack.pop();
						if (!stack.length) {
							return str.slice(0,i + 1);
						};
						
						end = stack[stack.length - 1];
						continue;
						break;
				
				};
				if (end == '}' && letter == [')']) {
					stack.push(end = letter);
				} else if (end == '}' && letter == '{') {
					stack.push(end = '}');
				} else if (end == ')' && letter == '{') {
					stack.push(end = '}');
				};
				prev = letter; // what, why?
			};
			
			return this.error(("missing " + (stack.pop()) + ", starting"));
		};
		
		// Pairs up a closing token, ensuring that all listed pairs of tokens are
		// correctly balanced throughout the course of the token stream.
		Lexer.prototype.pair = function (tok){
			var wanted = last(this._ends);
			if (tok != wanted) {
				if ('OUTDENT' != wanted) { this.error(("unmatched " + tok)) };
				var size = last(this._indents);
				this._indent -= size;
				this.outdentToken(size,true,0);
				return this.pair(tok);
			};
			return this.popEnd();
		};
		
		
		// Helpers
		// -------
		
		// Add a token to the results, taking note of the line number.
		Lexer.prototype.token = function (id,value,len,offset){
			this._lastTyp = id;
			this._lastVal = value;
			var tok = this._last = new Token(id,value,this._loc + (offset || 0),len || 0);
			this._tokens.push(tok);
			return;
		};
		
		Lexer.prototype.lastTokenType = function (){
			var token = this._tokens[this._tokens.length - 1];
			return token ? (tT(token)) : ('NONE');
		};
		
		Lexer.prototype.lastTokenValue = function (){
			var token = this._tokens[this._tokens.length - 1];
			return token ? (token._value) : ('');
		};
		
		// Peek at a tokid in the current token stream.
		Lexer.prototype.tokid = function (index,val){
			var tok;
			if (tok = last(this._tokens,index)) {
				if (val) { tTs(tok,val) };
				return tT(tok);
				// tok.@type = tokid if tokid # why?
				// tok.@type
			} else {
				return null;
			};
		};
		
		// Peek at a value in the current token stream.
		Lexer.prototype.value = function (index,val){
			var tok;
			if (tok = last(this._tokens,index)) {
				if (val) { tVs(tok,val) };
				return tV(tok);
				// tok.@value = val if val # why?
				// tok.@value
			} else {
				return null;
			};
		};
		
		
		// Are we in the midst of an unfinished expression?
		Lexer.prototype.unfinished = function (){
			if (LINE_CONTINUER.test(this._chunk)) { return true };
			return UNFINISHED.indexOf(this._lastTyp) >= 0;
		};
		
		// var tokens = ['\\','.', '?.', 'UNARY', 'MATH', '+', '-', 'SHIFT', 'RELATION', 'COMPARE', 'LOGIC', 'COMPOUND_ASSIGN', 'THROW', 'EXTENDS']
		
		// Converts newlines for string literals.
		Lexer.prototype.escapeLines = function (str,heredoc){
			return str.replace(MULTILINER,(heredoc ? ('\\n') : ('')));
		};
		
		// Constructs a string token by escaping quotes and newlines.
		Lexer.prototype.makeString = function (body,quote,heredoc){
			if (!body) { return quote + quote };
			body = body.replace(/\\([\s\S])/g,function(match,contents) {
				return (contents == '\n' || contents == quote) ? (contents) : (match);
			});
			// Does not work now
			body = body.replace(RegExp(("" + quote),"g"),'\\$&');
			return quote + this.escapeLines(body,heredoc) + quote;
		};
		
		// Throws a syntax error on the current `@line`.
		Lexer.prototype.error = function (message,len){
			if ((typeof this._line=='number'||this._line instanceof Number)) { message = ("" + message + " on line " + (this._line)) };
			
			if (len) {
				message += (" [" + (this._loc) + ":" + (this._loc + len) + "]");
			};
			
			var err = new SyntaxError(message);
			err.line = this._line;
			// err:columnNumber
			err = new ERR.ImbaParseError(err,{tokens: this._tokens,pos: this._tokens.length});
			err.region = [this._loc,this._loc + (len || 0)];
			throw err;
		};
		return Lexer;
	
	})()

/***/ },
/* 3 */
/***/ function(module, exports) {

	(function(){
		var TOK, LBRACKET, RBRACKET, LPAREN, RPAREN, INDENT, OUTDENT;
		
		
		module.exports.TOK = TOK = {};
		var TTERMINATOR = TOK.TERMINATOR = 1;
		var TIDENTIFIER = TOK.IDENTIFIER = TOK.IVAR = 2;
		var CONST = TOK.CONST = 3;
		var VAR = TOK.VAR = 4;
		var IF = TOK.IF = 5;
		var ELSE = TOK.ELSE = 6;
		var DEF = TOK.DEF = 7;
		
		function Token(type,value,loc,len){
			this._type = type;
			this._value = value;
			this._loc = loc != null ? (loc) : (-1);
			this._len = len || 0;
			this._meta = null;
			this.generated = false;
			this.newLine = false;
			this.spaced = false;
			return this;
		};
		
		exports.Token = Token; // export class 
		Token.prototype.type = function (){
			return this._type;
		};
		
		Token.prototype.value = function (){
			return this._value;
		};
		
		Token.prototype.traverse = function (){
			return;
		};
		
		Token.prototype.c = function (){
			return "" + this._value;
		};
		
		Token.prototype.toString = function (){
			return this._value;
		};
		
		Token.prototype.charAt = function (i){
			return this._value.charAt(i);
		};
		
		Token.prototype.slice = function (i){
			return this._value.slice(i);
		};
		
		Token.prototype.region = function (){
			return [this._loc,this._loc + (this._len || this._value.length)];
		};
		
		Token.prototype.sourceMapMarker = function (){
			return this._loc == -1 ? (':') : (("%$" + (this._loc) + "$%"));
			// @col == -1 ? '' : "%%{@line}${@col}%%"
		};
		
		
		function lex(){
			var token = this.tokens[this.pos++];
			var ttag;
			
			if (token) {
				ttag = token._type;
				this.yytext = token;
			} else {
				ttag = '';
			};
			
			return ttag;
		}; exports.lex = lex;
		
		
		// export def token typ, val, line, col, len do Token.new(typ,val,line, col or 0, len or 0) # [null,typ,val,loc]
		function token(typ,val){
			return new Token(typ,val,-1,0);
		}; exports.token = token;
		
		function typ(tok){
			return tok._type;
		}; exports.typ = typ;
		function val(tok){
			return tok._value;
		}; exports.val = val; // tok[offset + 1]
		function line(tok){
			return tok._line;
		}; exports.line = line; // tok[offset + 2]
		function loc(tok){
			return tok._loc;
		}; exports.loc = loc; // tok[offset + 2]
		
		function setTyp(tok,v){
			return tok._type = v;
		}; exports.setTyp = setTyp;
		function setVal(tok,v){
			return tok._value = v;
		}; exports.setVal = setVal;
		function setLine(tok,v){
			return tok._line = v;
		}; exports.setLine = setLine;
		function setLoc(tok,v){
			return tok._loc = v;
		}; exports.setLoc = setLoc;
		
		
		module.exports.LBRACKET = LBRACKET = new Token('{','{',0,0,0);
		module.exports.RBRACKET = RBRACKET = new Token('}','}',0,0,0);
		
		module.exports.LPAREN = LPAREN = new Token('(','(',0,0,0);
		module.exports.RPAREN = RPAREN = new Token(')',')',0,0,0);
		
		LBRACKET.generated = true;
		RBRACKET.generated = true;
		LPAREN.generated = true;
		RPAREN.generated = true;
		
		module.exports.INDENT = INDENT = new Token('INDENT','2',0,0,0);
		return module.exports.OUTDENT = OUTDENT = new Token('OUTDENT','2',0,0,0);
	
	})()

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function idx$(a,b){
			return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
		};
		
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		var INVERSES, LINEBREAKS;
		
		// The Imba language has a good deal of optional syntax, implicit syntax,
		// and shorthand syntax. This can greatly complicate a grammar and bloat
		// the resulting parse table. Instead of making the parser handle it all, we take
		// a series of passes over the token stream, using this **Rewriter** to convert
		// shorthand into the unambiguous long form, add implicit indentation and
		// parentheses, and generally clean things up.
		
		var T = __webpack_require__(3);
		var Token = T.Token;
		
		// Based on the original rewriter.coffee from CoffeeScript
		function Rewriter(){ };
		
		exports.Rewriter = Rewriter; // export class 
		Rewriter.prototype.tokens = function (){
			return this._tokens;
		};
		
		// Helpful snippet for debugging:
		//     console.log (t[0] + '/' + t[1] for t in @tokens).join ' '
		// Rewrite the token stream in multiple passes, one logical filter at
		// a time. This could certainly be changed into a single pass through the
		// stream, with a big ol' efficient switch, but it's much nicer to work with
		// like this. The order of these passes matters -- indentation must be
		// corrected before implicit parentheses can be wrapped around blocks of code.
		Rewriter.prototype.rewrite = function (tokens,opts){
			var token;
			if(opts === undefined) opts = {};
			this._tokens = tokens;
			this._options = opts;
			
			// console.log "tokens in: " + tokens:length
			if (opts.profile) { console.time("tokenize:rewrite") };
			
			var i = 0;
			// flag empty methods
			while (token = tokens[i]){
				var next = tokens[i + 1];
				if (token._type == 'DEF_BODY' && next && next._type == 'TERMINATOR') {
					token._type = 'DEF_EMPTY';
				};
				i++;
			};
			
			this.step("ensureFirstLine");
			this.step("removeLeadingNewlines");
			this.step("removeMidExpressionNewlines");
			this.step("tagDefArguments");
			this.step("closeOpenCalls");
			this.step("closeOpenIndexes");
			this.step("closeOpenTags");
			this.step("closeOpenTagAttrLists");
			this.step("addImplicitIndentation");
			this.step("tagPostfixConditionals");
			this.step("addImplicitBraces");
			this.step("addImplicitParentheses");
			
			if (opts.profile) { console.timeEnd("tokenize:rewrite") };
			// console.log "tokens out: " + @tokens:length
			return this._tokens;
		};
		
		Rewriter.prototype.step = function (fn){
			if (this._options.profile) {
				console.log(("---- starting " + fn + " ---- "));
				console.time(fn);
			};
			
			this[fn]();
			
			if (this._options.profile) {
				console.timeEnd(fn);
				console.log("\n\n");
			};
			return;
		};
		
		// Rewrite the token stream, looking one token ahead and behind.
		// Allow the return value of the block to tell us how many tokens to move
		// forwards (or backwards) in the stream, to make sure we don't miss anything
		// as tokens are inserted and removed, and the stream changes length under
		// our feet.
		Rewriter.prototype.scanTokens = function (block){
			var token;
			var tokens = this._tokens;
			
			var i = 0;
			while (token = tokens[i]){
				i += block.call(this,token,i,tokens);
			};
			
			return true;
		};
		
		Rewriter.prototype.detectEnd = function (i,condition,action){
			var tokens = this._tokens;
			var levels = 0;
			var starts = [];
			var token;
			var t,v;
			
			while (token = tokens[i]){
				if (levels == 0 && condition.call(this,token,i,starts)) {
					return action.call(this,token,i);
				};
				if (!token || levels < 0) {
					return action.call(this,token,i - 1);
				};
				
				t = T.typ(token);
				
				if (EXPRESSION_START.indexOf(t) >= 0) {
					if (levels == 0) { starts.push(i) };
					levels += 1;
				} else if (EXPRESSION_END.indexOf(t) >= 0) {
					levels -= 1;
				};
				i += 1;
			};
			return i - 1;
		};
		
		Rewriter.prototype.ensureFirstLine = function (){
			var tok = this._tokens[0];
			
			if (T.typ(tok) == 'TERMINATOR') {
				// console.log "adding bodystart"
				this._tokens = [T.token('BODYSTART','BODYSTART')].concat(this._tokens);
				// T.setTyp(tok,'HEADER')
			};
			return;
		};
		
		// Leading newlines would introduce an ambiguity in the grammar, so we
		// dispatch them here.
		Rewriter.prototype.removeLeadingNewlines = function (){
			var at = 0;
			
			for (var i = 0, ary = iter$(this._tokens), len = ary.length; i < len; i++) {
				if (T.typ(ary[i]) != 'TERMINATOR') {
					at = i;break;
				};
			};
			
			if (at) { this._tokens.splice(0,at) };
			
			return;
		};
		
		// Some blocks occur in the middle of expressions -- when we're expecting
		// this, remove their trailing newlines.
		Rewriter.prototype.removeMidExpressionNewlines = function (){
			var self = this;
			return self.scanTokens(function(token,i,tokens) { // do |token,i,tokens|
				var next = self.tokenType(i + 1);
				
				if (!(T.typ(token) == 'TERMINATOR' && EXPRESSION_CLOSE.indexOf(next) >= 0)) { return 1 };
				if (next == 'OUTDENT') { return 1 };
				tokens.splice(i,1);
				return 0;
			});
		};
		
		
		Rewriter.prototype.tagDefArguments = function (){
			return true;
		};
		
		// The lexer has tagged the opening parenthesis of a method call. Match it with
		// its paired close. We have the mis-nested outdent case included here for
		// calls that close on the same line, just before their outdent.
		Rewriter.prototype.closeOpenCalls = function (){
			var self = this;
			var condition = function(token,i) {
				var t = T.typ(token);
				return (t == ')' || t == 'CALL_END') || t == 'OUTDENT' && self.tokenType(i - 1) == ')';
			};
			
			var action = function(token,i) {
				var t = T.typ(token);
				var tok = self._tokens[t == 'OUTDENT' ? (i - 1) : (i)];
				return T.setTyp(tok,'CALL_END');
			};
			
			return self.scanTokens(function(token,i) {
				if (T.typ(token) == 'CALL_START') { self.detectEnd(i + 1,condition,action) };
				return 1;
			});
		};
		
		// The lexer has tagged the opening parenthesis of an indexing operation call.
		// Match it with its paired close.
		Rewriter.prototype.closeOpenIndexes = function (){
			var self = this;
			var condition = function(token,i) { return idx$(T.typ(token),[']','INDEX_END']) >= 0; };
			var action = function(token,i) { return T.setTyp(token,'INDEX_END'); };
			
			return self.scanTokens(function(token,i) {
				if (T.typ(token) == 'INDEX_START') { self.detectEnd(i + 1,condition,action) };
				return 1;
			});
		};
		
		
		Rewriter.prototype.closeOpenTagAttrLists = function (){
			var self = this;
			var condition = function(token,i) { return idx$(T.typ(token),[')','TAG_ATTRS_END']) >= 0; };
			var action = function(token,i) { return T.setTyp(token,'TAG_ATTRS_END'); }; // 'TAG_ATTRS_END'
			
			return self.scanTokens(function(token,i) {
				if (T.typ(token) == 'TAG_ATTRS_START') { self.detectEnd(i + 1,condition,action) };
				return 1;
			});
		};
		
		// The lexer has tagged the opening parenthesis of an indexing operation call.
		// Match it with its paired close. Should be done in lexer directly
		Rewriter.prototype.closeOpenTags = function (){
			var self = this;
			var condition = function(token,i) { return idx$(T.typ(token),['>','TAG_END']) >= 0; };
			var action = function(token,i) { return T.setTyp(token,'TAG_END'); }; // token[0] = 'TAG_END'
			
			return self.scanTokens(function(token,i) {
				if (T.typ(token) == 'TAG_START') { self.detectEnd(i + 1,condition,action) };
				return 1;
			});
		};
		
		Rewriter.prototype.addImplicitCommas = function (){
			return;
		};
		
		Rewriter.prototype.addImplicitBlockCalls = function (){
			var token;
			var i = 1;
			var tokens = this._tokens;
			
			while (token = tokens[i]){
				var t = token._type;
				var v = token._value;
				// hmm
				if (t == 'DO' && (v == 'INDEX_END' || v == 'IDENTIFIER' || v == 'NEW')) {
					tokens.splice(i + 1,0,T.token('CALL_END',')'));
					tokens.splice(i + 1,0,T.token('CALL_START','('));
					i++;
				};
				i++;
			};
			
			return;
		};
		
		// Object literals may be written with implicit braces, for simple cases.
		// Insert the missing braces here, so that the parser doesn't have to.
		Rewriter.prototype.addImplicitBraces = function (){
			var self = this;
			var stack = [];
			var start = null;
			var startIndent = 0;
			var startIdx = null;
			
			var noBraceTag = ['CLASS','IF','UNLESS','TAG','WHILE','FOR','UNTIL','CATCH','FINALLY','MODULE','LEADING_WHEN'];
			var noBraceContext = ['IF','TERNARY','FOR'];
			
			var noBrace = false;
			
			var scope = function() {
				return stack[stack.length - 1] || [];
			};
			
			var action = function(token,i) {
				return self._tokens.splice(i,0,T.RBRACKET);
			};
			
			var open = function(token,i) {
				return self._tokens.splice(i,0,T.LBRACKET);
			};
			
			var close = function(token,i) {
				return self._tokens.splice(i,0,T.RBRACKET);
			};
			
			var stackToken = function(a,b) {
				return [a,b];
			};
			
			return self.scanTokens(function(token,i,tokens) {
				var type = T.typ(token);
				var v = T.val(token);
				var ctx = stack[stack.length - 1] || [];
				var idx;
				
				if (noBraceContext.indexOf(type) >= 0) {
					// console.log "found noBraceTag {type}"
					stack.push(stackToken(type,i));
					return 1;
				};
				
				if (v == '?') {
					// console.log('TERNARY OPERATOR!')
					stack.push(stackToken('TERNARY',i));
					return 1;
				};
				
				// no need to test for this here as well as in
				if (EXPRESSION_START.indexOf(type) >= 0) {
					if (type == 'INDENT' && noBraceContext.indexOf(ctx[0]) >= 0) {
						stack.pop();
					};
					
					// console.log('expression start',type,ctx[0])
					if (type == 'INDENT' && self.tokenType(i - 1) == '{') {
						// stack ?!? no token
						stack.push(stackToken('{',i)); // should not autogenerate another?
					} else {
						stack.push(stackToken(type,i));
					};
					return 1;
				};
				
				if (EXPRESSION_END.indexOf(type) >= 0) {
					// console.log "EXPRESSION_END at {type} - stack is {ctx[0]}"
					if (ctx[0] == 'TERNARY') { // FIX?
						stack.pop();
					};
					
					start = stack.pop();
					if (!start) {
						console.log("NO STACK!!");
					};
					start[2] = i;
					
					// seems like the stack should use tokens, no?)
					if (start[0] == '{' && start.generated) { //  # type != '}' # and start:generated
						close(token,i);
						return 1;
					};
					
					return 1;
				};
				
				// is this correct? same for if/class etc?
				if (ctx[0] == 'TERNARY' && (type == 'TERMINATOR' || type == 'OUTDENT')) {
					stack.pop();
					return 1;
				};
				
				if (noBraceContext.indexOf(ctx[0]) >= 0 && type == 'INDENT') {
					console.log("popping noBraceContext");
					stack.pop();
					return 1;
				};
				
				
				if (type == ',') {
					// automatically add an ending here if inside:generated scope?
					// it is important that this is:generated(!)
					if (ctx[0] == '{' && ctx.generated) {
						tokens.splice(i,0,T.RBRACKET);
						stack.pop();
						return 2;
					} else {
						return 1;
					};
					true;
				};
				
				// found a type
				if (type == ':' && ctx[0] != '{' && ctx[0] != 'TERNARY' && (noBraceContext.indexOf(ctx[0]) == -1)) {
					// could just check if the end was right before this?
					
					if (start && start[2] == i - 1) {
						// console.log('this expression was just ending before colon!')
						idx = start[1] - 1; // these are the stackTokens
					} else {
						// console.log "rewrite here? #{i}"
						idx = i - 2; // if start then start[1] - 1 else i - 2
						// idx = idx - 1 if tokenType(idx) is 'TERMINATOR'
					};
					
					while (self.tokenType(idx - 1) == 'HERECOMMENT'){
						idx -= 2;
					};
					
					var t0 = tokens[idx - 1];
					
					if (t0 && T.typ(t0) == '}' && t0.generated) {
						tokens.splice(idx - 1,1);
						var s = stackToken('{');
						s.generated = true;
						stack.push(s);
						return 0;
					} else if (t0 && T.typ(t0) == ',' && self.tokenType(idx - 2) == '}') {
						tokens.splice(idx - 2,1);
						s = stackToken('{');
						s.generated = true;
						stack.push(s);
						return 0;
					} else {
						s = stackToken('{');
						s.generated = true;
						stack.push(s);
						open(token,idx + 1);
						return 2;
					};
				};
				
				// we probably need to run through autocall first?!
				
				if (type == 'DO') { // and ctx:generated
					var prev = T.typ(tokens[i - 1]); // [0]
					if (['NUMBER','STRING','REGEX','SYMBOL',']','}',')','STRING_END'].indexOf(prev) >= 0) {
						
						var tok = T.token(',',',');
						tok.generated = true;
						tokens.splice(i,0,tok);
						
						if (ctx.generated) {
							close(token,i);
							stack.pop();
							return 2;
						};
					};
				};
				
				if ((type == 'TERMINATOR' || type == 'OUTDENT' || type == 'DEF_BODY') && ctx.generated) {
					close(token,i);
					stack.pop();
					return 2;
				};
				
				return 1;
			});
		};
		
		// Methods may be optionally called without parentheses, for simple cases.
		// Insert the implicit parentheses here, so that the parser doesn't have to
		// deal with them.
		// Practically everything will now be callable this way (every identifier)
		Rewriter.prototype.addImplicitParentheses = function (){
			
			var self = this, token;
			var noCallTag = ['CLASS','IF','UNLESS','TAG','WHILE','FOR','UNTIL','CATCH','FINALLY','MODULE','LEADING_WHEN'];
			
			var action = function(token,i) {
				return self._tokens.splice(i,0,T.token('CALL_END',')'));
			};
			
			// console.log "adding implicit parenthesis" # ,self:scanTokens
			var tokens = self._tokens;
			
			var noCall = false;
			var seenFor = false;
			var endCallAtTerminator = false;
			
			var i = 0;
			while (token = tokens[i]){
				
				// to handle cases like:
				// if a(do yes).test
				// 	yes
				// we need to keep a stack for balanced pairs
				// until then you must explicitly end the call like
				// if a(do yes).test()
				// 	yes
				
				var type = token._type;
				
				var prev = tokens[i - 1];
				var current = tokens[i];
				var next = tokens[i + 1];
				
				var pt = prev && prev._type;
				var nt = next && next._type;
				
				// if pt == 'WHEN'
				// Never make these tags implicitly call
				// should we not just remove these from IMPLICIT_FUNC?
				if ((pt == ')' || pt == ']') && type == 'INDENT') {
					noCall = true;
				};
				
				if (noCallTag.indexOf(pt) >= 0) {
					// console.log("seen nocall tag {pt} ({pt} {type} {nt})")
					endCallAtTerminator = true;
					noCall = true;
					if (pt == 'FOR') { seenFor = true };
				};
				
				
				var callObject = false;
				var callIndent = false;
				
				// [prev, current, next] = tokens[i - 1 .. i + 1]
				
				// check for comments
				// console.log "detect end??"
				if (!noCall && type == 'INDENT' && next) {
					var prevImpFunc = pt && IMPLICIT_FUNC.indexOf(pt) >= 0;
					var nextImpCall = nt && IMPLICIT_CALL.indexOf(nt) >= 0;
					callObject = ((next.generated && nt == '{') || nextImpCall) && prevImpFunc;
					callIndent = nextImpCall && prevImpFunc;
				};
				
				var seenSingle = false;
				var seenControl = false;
				// Hmm ?
				
				// this is not correct if this is inside a block,no?
				if ((type == 'TERMINATOR' || type == 'OUTDENT' || type == 'INDENT')) {
					endCallAtTerminator = false;
					noCall = false;
				};
				
				if (type == '?' && prev && !prev.spaced) { token.call = true };
				
				// where does fromThem come from?
				if (token.fromThen) {
					i += 1;continue;
				};
				// here we deal with :spaced and :newLine
				if (!(callObject || callIndent || (prev && prev.spaced) && (prev.call || IMPLICIT_FUNC.indexOf(pt) >= 0) && (IMPLICIT_CALL.indexOf(type) >= 0 || !(token.spaced || token.newLine) && IMPLICIT_UNSPACED_CALL.indexOf(type) >= 0))) {
					i += 1;continue;
				};
				
				
				tokens.splice(i,0,T.token('CALL_START','('));
				// console.log "added ( {prev}"
				var cond = function(token,i) {
					var type = T.typ(token);
					if (!seenSingle && token.fromThen) { return true };
					var ifelse = type == 'IF' || type == 'UNLESS' || type == 'ELSE';
					if (ifelse || type == 'CATCH') { seenSingle = true };
					if (ifelse || type == 'SWITCH' || type == 'TRY') { seenControl = true };
					var prev = self.tokenType(i - 1);
					
					if ((type == '.' || type == '?.' || type == '::') && prev == 'OUTDENT') { return true };
					if (endCallAtTerminator && (type == 'INDENT' || type == 'TERMINATOR')) { return true };
					if ((type == 'WHEN' || type == 'BY') && !seenFor) {
						// console.log "dont close implicit call outside for"
						return false;
					};
					
					var post = tokens[i + 1];
					var postTyp = post && T.typ(post);
					// WTF
					return !token.generated && prev != ',' && (IMPLICIT_END.indexOf(type) >= 0 || (type == 'INDENT' && !seenControl) || (type == 'DOS' && prev != '=')) && (type != 'INDENT' || (self.tokenType(i - 2) != 'CLASS' && IMPLICIT_BLOCK.indexOf(prev) == -1 && !(post && ((post.generated && postTyp == '{') || IMPLICIT_CALL.indexOf(postTyp) >= 0))));
				};
				
				// The action for detecting when the call should end
				// console.log "detect end??"
				self.detectEnd(i + 1,cond,action);
				if (T.typ(prev) == '?') { T.setTyp(prev,'FUNC_EXIST') };
				i += 2;
				// need to reset after a match
				endCallAtTerminator = false;
				noCall = false;
				seenFor = false;
			};
			
			
			return;
		};
		
		// Because our grammar is LALR(1), it can't handle some single-line
		// expressions that lack ending delimiters. The **Rewriter** adds the implicit
		// blocks, so it doesn't need to. ')' can close a single-line block,
		// but we need to make sure it's balanced.
		Rewriter.prototype.addImplicitIndentation = function (){
			
			
			var self = this, token;
			var i = 0;
			var tokens = self._tokens;
			while (token = tokens[i]){
				var type = T.typ(token);
				var next = self.tokenType(i + 1);
				
				// why are we removing terminators after then? should be able to handle
				if (type == 'TERMINATOR' && next == 'THEN') {
					tokens.splice(i,1);
					continue;
				};
				
				if (type == 'CATCH' && idx$(self.tokenType(i + 2),['OUTDENT','TERMINATOR','FINALLY']) >= 0) {
					tokens.splice.apply(tokens,[].concat([i + 2,0], [].slice.call(self.indentation(token))));
					i += 4;continue;
				};
				
				if (SINGLE_LINERS.indexOf(type) >= 0 && (next != 'INDENT' && next != 'BLOCK_PARAM_START') && !(type == 'ELSE' && next == 'IF') && type != 'ELIF') {
					
					var starter = type;
					
					var indent = T.token('INDENT','2');
					var outdent = T.OUTDENT;
					// var indent, outdent = indentation(token)
					if (starter == 'THEN') { indent.fromThen = true }; // setting special values for these -- cannot really reuse?
					indent.generated = true;
					// outdent:generated = true
					tokens.splice(i + 1,0,indent);
					
					var condition = function(token,i) {
						var t = T.typ(token);
						return T.val(token) != ';' && SINGLE_CLOSERS.indexOf(t) >= 0 && !(t == 'ELSE' && starter != 'IF' && starter != 'THEN');
					};
					
					var action = function(token,i) {
						var idx = self.tokenType(i - 1) == ',' ? (i - 1) : (i);
						return tokens.splice(idx,0,outdent);
					};
					
					self.detectEnd(i + 2,condition,action);
					if (type == 'THEN') { tokens.splice(i,1) };
				};
				
				i++;
			};
			
			return;
		};
		
		// Tag postfix conditionals as such, so that we can parse them with a
		// different precedence.
		Rewriter.prototype.tagPostfixConditionals = function (){
			var self = this;
			var condition = function(token,i) { return idx$(T.typ(token),['TERMINATOR','INDENT']) >= 0; };
			
			return self.scanTokens(function(token,i) {
				var typ = T.typ(token);
				if (!(typ == 'IF' || typ == 'FOR')) { return 1 };
				var original = token;
				self.detectEnd(i + 1,condition,function(token,i) {
					if (T.typ(token) != 'INDENT') { return T.setTyp(original,'POST_' + T.typ(original)) };
				});
				return 1;
			});
		};
		
		// Generate the indentation tokens, based on another token on the same line.
		Rewriter.prototype.indentation = function (token){
			return [T.token('INDENT','2'),T.token('OUTDENT','2')];
		};
		
		// Look up a type by token index.
		Rewriter.prototype.type = function (i){
			// if i < 0 then return null
			var tok = this._tokens[i];
			return tok && T.typ(tok);
			// if tok then tok[0] else null
		};
		
		Rewriter.prototype.tokenType = function (i){
			var tok = this._tokens[i];
			return tok && T.typ(tok);
			// return tok and tok[0]
		};
		
		// Constants
		// ---------
		
		// List of the token pairs that must be balanced.
		var BALANCED_PAIRS = [
			['(',')'],
			['[',']'],
			['{','}'],
			['{{','}}'],
			['INDENT','OUTDENT'],
			['CALL_START','CALL_END'],
			['PARAM_START','PARAM_END'],
			['INDEX_START','INDEX_END'],
			['TAG_START','TAG_END'],
			['TAG_PARAM_START','TAG_PARAM_END'],
			['TAG_ATTRS_START','TAG_ATTRS_END'],
			['BLOCK_PARAM_START','BLOCK_PARAM_END']
		];
		
		// The inverse mappings of `BALANCED_PAIRS` we're trying to fix up, so we can
		// look things up from either end.
		module.exports.INVERSES = INVERSES = {};
		
		// The tokens that signal the start/end of a balanced pair.
		// var EXPRESSION_START = []
		// var EXPRESSION_END   = []
		
		for (var i = 0, ary = iter$(BALANCED_PAIRS), len = ary.length, pair; i < len; i++) {
			pair = ary[i];
			var left = pair[0];
			var rite = pair[1];
			INVERSES[rite] = left;
			INVERSES[left] = rite;
		};
		
		var EXPRESSION_START = ['(','[','{','INDENT','CALL_START','PARAM_START','INDEX_START','TAG_PARAM_START','BLOCK_PARAM_START','STRING_START','{{','TAG_START'];
		var EXPRESSION_END = [')',']','}','OUTDENT','CALL_END','PARAM_END','INDEX_END','TAG_PARAM_END','BLOCK_PARAM_END','STRING_END','}}','TAG_END'];
		
		var IDENTIFIERS = ['IDENTIFIER','GVAR','IVAR','CVAR','CONST','ARGVAR'];
		
		// Tokens that indicate the close of a clause of an expression.
		var EXPRESSION_CLOSE = ['CATCH','WHEN','ELSE','FINALLY'].concat(EXPRESSION_END);
		
		// Tokens that, if followed by an `IMPLICIT_CALL`, indicate a function invocation.
		var IMPLICIT_FUNC = ['IDENTIFIER','SUPER','@','THIS','SELF','EVENT','TRIGGER','TAG_END','IVAR',
		'GVAR','CONST','ARGVAR','NEW','BREAK','CONTINUE','RETURN'];
		
		// If preceded by an `IMPLICIT_FUNC`, indicates a function invocation.
		var IMPLICIT_CALL = [
			'SELECTOR','IDENTIFIER','NUMBER','STRING','SYMBOL','JS','REGEX','NEW','PARAM_START','CLASS',
			'IF','UNLESS','TRY','SWITCH','THIS','BOOL','TRUE','FALSE','NULL','UNDEFINED','UNARY','SUPER','IVAR','GVAR','CONST','ARGVAR','SELF',
			'@','[','(','{','--','++','SELECTOR','TAG_START','TAGID','#','SELECTOR_START','IDREF','SPLAT','DO','BLOCK_ARG',
			'FOR','STRING_START','CONTINUE','BREAK'
		]; // '->', '=>', why does it not work with symbol?
		
		var IMPLICIT_INDENT_CALL = [
			'FOR'
		];
		// is not do an implicit call??
		
		var IMPLICIT_UNSPACED_CALL = ['+','-'];
		
		// Tokens indicating that the implicit call must enclose a block of expressions.
		var IMPLICIT_BLOCK = ['{','[',',','BLOCK_PARAM_END','DO']; // '->', '=>', 
		
		var CONDITIONAL_ASSIGN = ['||=','&&=','?=','&=','|='];
		var COMPOUND_ASSIGN = ['-=','+=','/=','*=','%=','||=','&&=','?=','<<=','>>=','>>>=','&=','^=','|='];
		var UNARY = ['!','~','NEW','TYPEOF','DELETE'];
		var LOGIC = ['&&','||','&','|','^'];
		
		// optimize for fixed arrays
		var NO_IMPLICIT_BLOCK_CALL = [
			'CALL_END','=','DEF_BODY','(','CALL_START',',',':','RETURN',
			'-=','+=','/=','*=','%=','||=','&&=','?=','<<=','>>=','>>>=','&=','^=','|='
		]; // .concat(COMPOUND_ASSIGN)
		
		
		// console.log NO_IMPLICIT_BLOCK_CALL:length
		// NO_IMPLICIT_BLOCK_CALL
		// IMPLICIT_COMMA = ['->', '=>', '{', '[', 'NUMBER', 'STRING', 'SYMBOL', 'IDENTIFIER','DO']
		
		var IMPLICIT_COMMA = ['DO'];
		
		// Tokens that always mark the end of an implicit call for single-liners.
		var IMPLICIT_END = ['POST_IF','POST_UNLESS','POST_FOR','WHILE','UNTIL','WHEN','BY','LOOP','TERMINATOR','DEF_BODY','DEF_FRAGMENT'];
		
		// Single-line flavors of block expressions that have unclosed endings.
		// The grammar can't disambiguate them, so we insert the implicit indentation.
		var SINGLE_LINERS = ['ELSE','TRY','FINALLY','THEN','BLOCK_PARAM_END','DO','BEGIN','CATCH_VAR']; // '->', '=>', really?
		var SINGLE_CLOSERS = ['TERMINATOR','CATCH','FINALLY','ELSE','OUTDENT','LEADING_WHEN'];
		
		// Tokens that end a line.
		return LINEBREAKS = ['TERMINATOR','INDENT','OUTDENT'];
	
	})()

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module, process) {/* parser generated by jison-fork */
	var parser = (function(){
	var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,4],$V1=[1,6],$V2=[1,32],$V3=[1,33],$V4=[1,34],$V5=[1,35],$V6=[1,75],$V7=[1,115],$V8=[1,128],$V9=[1,121],$Va=[1,122],$Vb=[1,123],$Vc=[1,120],$Vd=[1,124],$Ve=[1,131],$Vf=[1,114],$Vg=[1,132],$Vh=[1,80],$Vi=[1,81],$Vj=[1,82],$Vk=[1,83],$Vl=[1,84],$Vm=[1,85],$Vn=[1,86],$Vo=[1,73],$Vp=[1,118],$Vq=[1,95],$Vr=[1,91],$Vs=[1,88],$Vt=[1,71],$Vu=[1,65],$Vv=[1,66],$Vw=[1,111],$Vx=[1,90],$Vy=[1,87],$Vz=[1,28],$VA=[1,29],$VB=[1,96],$VC=[1,94],$VD=[1,112],$VE=[1,113],$VF=[1,126],$VG=[1,67],$VH=[1,68],$VI=[1,119],$VJ=[1,11],$VK=[1,127],$VL=[1,78],$VM=[1,37],$VN=[1,43],$VO=[1,110],$VP=[1,69],$VQ=[1,89],$VR=[1,125],$VS=[1,59],$VT=[1,74],$VU=[1,105],$VV=[1,106],$VW=[1,107],$VX=[1,129],$VY=[1,130],$VZ=[1,63],$V_=[1,104],$V$=[1,51],$V01=[1,52],$V11=[1,53],$V21=[1,54],$V31=[1,55],$V41=[1,56],$V51=[1,134],$V61=[1,6,11,137],$V71=[1,136],$V81=[1,6,11,14,137],$V91=[1,144],$Va1=[1,145],$Vb1=[1,147],$Vc1=[1,148],$Vd1=[1,141],$Ve1=[1,140],$Vf1=[1,142],$Vg1=[1,143],$Vh1=[1,146],$Vi1=[1,151],$Vj1=[1,6,10,11,14,22,71,90,97,106,112,126,135,137,147,171,200,201,212,213,214,219,220,229,238,239,242,243,246,247,248],$Vk1=[2,263],$Vl1=[1,158],$Vm1=[1,164],$Vn1=[1,162],$Vo1=[1,160],$Vp1=[1,161],$Vq1=[1,165],$Vr1=[1,163],$Vs1=[1,6,10,11,14,22,90,97,137],$Vt1=[1,6,11,14,137,212,214,219,220,238],$Vu1=[1,6,10,11,14,21,22,71,88,89,90,97,106,111,112,126,135,137,144,147,171,180,181,183,196,200,201,212,213,214,219,220,229,238,239,242,243,246,247,248],$Vv1=[2,231],$Vw1=[1,178],$Vx1=[1,176],$Vy1=[1,6,10,11,14,21,22,71,88,89,90,97,106,111,112,117,126,135,137,144,147,171,180,181,183,196,200,201,212,213,214,219,220,229,238,239,242,243,246,247,248],$Vz1=[2,227],$VA1=[6,14,53,54,88,91,106,111,113,116],$VB1=[1,212],$VC1=[1,217],$VD1=[1,6,10,11,14,21,22,71,88,89,90,97,106,111,112,117,126,135,137,144,147,171,180,181,183,196,200,201,212,213,214,219,220,229,238,239,242,243,244,245,246,247,248,249],$VE1=[1,227],$VF1=[1,224],$VG1=[1,229],$VH1=[6,10,14,90],$VI1=[2,244],$VJ1=[1,257],$VK1=[1,247],$VL1=[1,276],$VM1=[1,277],$VN1=[51,89],$VO1=[85,86,87,88,91,92,93,94,95,96,100,102],$VP1=[1,289],$VQ1=[1,6,10,11,14,21,22,53,54,71,88,89,90,91,97,106,111,112,113,116,117,126,135,137,144,147,171,180,181,183,196,200,201,212,213,214,219,220,229,238,239,242,243,244,245,246,247,248,249],$VR1=[1,295],$VS1=[51,89,96,225],$VT1=[1,6,10,11,14,21,22,67,69,70,71,88,89,90,97,106,111,112,126,135,137,144,147,171,180,181,183,196,200,201,212,213,214,219,220,229,238,239,242,243,246,247,248],$VU1=[1,6,10,11,14,21,22,71,88,89,90,97,106,111,112,126,135,137,144,147,171,180,181,183,196,200,201,207,208,212,213,214,219,220,229,232,234,237,238,239,242,243,246,247,248],$VV1=[51,53,54,58],$VW1=[1,326],$VX1=[1,327],$VY1=[1,6,10,11,14,22,71,90,97,106,112,135,137,147,200,201,212,213,214,219,220,229,238],$VZ1=[1,340],$V_1=[1,344],$V$1=[1,6,11,14,22,71,90,97,106,112,126,135,137,147,171,200,201,212,213,214,219,220,229,238,239,242,243,246,247,248],$V02=[6,14,106],$V12=[1,354],$V22=[1,6,10,11,14,21,22,71,89,90,97,106,112,126,135,137,147,171,200,201,212,213,214,219,220,229,238,239,242,243,246,247,248],$V32=[14,28],$V42=[1,6,11,14,28,137,212,214,219,220,238],$V52=[2,284],$V62=[1,6,10,11,14,21,22,71,88,89,90,97,106,111,112,117,126,135,137,144,147,171,180,181,183,196,200,201,212,213,214,219,220,227,228,229,238,239,242,243,244,245,246,247,248,249],$V72=[2,184],$V82=[1,369],$V92=[6,10,11,14,22,97],$Va2=[14,147],$Vb2=[2,186],$Vc2=[1,379],$Vd2=[1,380],$Ve2=[1,381],$Vf2=[1,385],$Vg2=[6,10,11,14,90],$Vh2=[6,10,11,14,90,135],$Vi2=[1,6,10,11,14,22,71,90,97,106,112,135,137,147,200,201,220,229,238],$Vj2=[1,6,10,11,14,22,71,90,97,106,112,135,137,147,200,201,213,220,229,238],$Vk2=[227,228],$Vl2=[14,227,228],$Vm2=[1,6,11,14,22,71,90,97,106,112,135,137,147,171,200,201,212,213,214,219,220,229,238,239,242,243,246,247,248],$Vn2=[88,91],$Vo2=[1,406],$Vp2=[1,407],$Vq2=[21,88,91,164,165],$Vr2=[1,6,10,11,14,22,71,90,97,106,112,126,135,137,147,171,200,201,212,213,214,219,220,229,238,239,242,243,247,248],$Vs2=[1,6,10,11,14,22,71,90,97,106,112,135,137,147,200,201,213,229],$Vt2=[19,20,23,24,26,32,51,53,54,56,58,60,62,64,66,73,74,75,76,77,78,79,80,83,89,91,96,103,112,122,123,124,130,136,143,144,151,152,154,156,157,158,175,184,185,188,193,194,197,198,204,210,212,214,216,219,220,230,236,240,241,242,243,244,245],$Vu2=[1,6,10,11,14,22,71,90,97,106,112,126,135,137,147,171,200,201,212,213,214,219,220,229,232,237,238,239,242,243,246,247,248],$Vv2=[11,232,234],$Vw2=[1,453],$Vx2=[2,185],$Vy2=[6,10,11],$Vz2=[1,461],$VA2=[14,22,147],$VB2=[1,469],$VC2=[1,6,10,11,14,22,71,90,97,106,112,135,137,147,200,201,212,214,219,220,229,238],$VD2=[51,58,89],$VE2=[14,22],$VF2=[1,492],$VG2=[10,14],$VH2=[1,542],$VI2=[6,10];
	var parser = {trace: function trace() { },
	yy: {},
	symbols_: {"error":2,"Root":3,"Body":4,"Block":5,"TERMINATOR":6,"BODYSTART":7,"Line":8,"Terminator":9,"INDENT":10,"OUTDENT":11,"Splat":12,"Expression":13,",":14,"Comment":15,"Statement":16,"Return":17,"Throw":18,"STATEMENT":19,"BREAK":20,"CALL_START":21,"CALL_END":22,"CONTINUE":23,"DEBUGGER":24,"ImportStatement":25,"IMPORT":26,"ImportArgList":27,"FROM":28,"ImportFrom":29,"AS":30,"ImportArg":31,"STRING":32,"VarIdentifier":33,"Await":34,"Value":35,"Code":36,"Operation":37,"Assign":38,"If":39,"Ternary":40,"Try":41,"While":42,"For":43,"Switch":44,"Class":45,"Module":46,"TagDeclaration":47,"Tag":48,"Property":49,"Identifier":50,"IDENTIFIER":51,"Ivar":52,"IVAR":53,"CVAR":54,"Gvar":55,"GVAR":56,"Const":57,"CONST":58,"Argvar":59,"ARGVAR":60,"Symbol":61,"SYMBOL":62,"AlphaNumeric":63,"NUMBER":64,"InterpolatedString":65,"STRING_START":66,"NEOSTRING":67,"Interpolation":68,"STRING_END":69,"{{":70,"}}":71,"Literal":72,"JS":73,"REGEX":74,"BOOL":75,"TRUE":76,"FALSE":77,"NULL":78,"UNDEFINED":79,"RETURN":80,"Arguments":81,"TagSelector":82,"SELECTOR_START":83,"TagSelectorType":84,"SELECTOR_NS":85,"SELECTOR_ID":86,"SELECTOR_CLASS":87,".":88,"{":89,"}":90,"#":91,"SELECTOR_COMBINATOR":92,"SELECTOR_PSEUDO_CLASS":93,"SELECTOR_GROUP":94,"UNIVERSAL_SELECTOR":95,"[":96,"]":97,"SELECTOR_ATTR_OP":98,"TagSelectorAttrValue":99,"SELECTOR_TAG":100,"Selector":101,"SELECTOR_END":102,"TAG_START":103,"TagOptions":104,"TagAttributes":105,"TAG_END":106,"TagBody":107,"TagTypeName":108,"Self":109,"TAG_TYPE":110,"INDEX_START":111,"INDEX_END":112,"@":113,"TagAttr":114,"OptComma":115,"TAG_ATTR":116,"=":117,"TagAttrValue":118,"ArgList":119,"TagTypeDef":120,"TagDeclarationBlock":121,"EXTEND":122,"LOCAL":123,"TAG":124,"TagType":125,"COMPARE":126,"TagDeclKeywords":127,"TAG_ID":128,"TagId":129,"IDREF":130,"Assignable":131,"Outdent":132,"AssignObj":133,"ObjAssignable":134,":":135,"(":136,")":137,"HERECOMMENT":138,"COMMENT":139,"Method":140,"Do":141,"Begin":142,"BEGIN":143,"DO":144,"BLOCK_PARAM_START":145,"ParamList":146,"BLOCK_PARAM_END":147,"PropType":148,"PropertyIdentifier":149,"Object":150,"PROP":151,"ATTR":152,"TupleAssign":153,"VAR":154,"MethodDeclaration":155,"GLOBAL":156,"EXPORT":157,"DEF":158,"MethodScope":159,"MethodScopeType":160,"MethodIdentifier":161,"MethodBody":162,"MethodReceiver":163,"DEF_BODY":164,"DEF_EMPTY":165,"This":166,"Param":167,"Array":168,"ParamVar":169,"SPLAT":170,"LOGIC":171,"BLOCK_ARG":172,"VarReference":173,"VarAssignable":174,"LET":175,"SimpleAssignable":176,"NEW":177,"Super":178,"SoakableOp":179,"?:":180,".:":181,"IndexValue":182,"?.":183,"SUPER":184,"AWAIT":185,"Parenthetical":186,"Range":187,"ARGUMENTS":188,"Invocation":189,"Slice":190,"AssignList":191,"ClassStart":192,"CLASS":193,"MODULE":194,"OptFuncExist":195,"FUNC_EXIST":196,"THIS":197,"SELF":198,"RangeDots":199,"..":200,"...":201,"Arg":202,"SimpleArgs":203,"TRY":204,"Catch":205,"Finally":206,"FINALLY":207,"CATCH":208,"CATCH_VAR":209,"THROW":210,"WhileSource":211,"WHILE":212,"WHEN":213,"UNTIL":214,"Loop":215,"LOOP":216,"ForBody":217,"ForKeyword":218,"FOR":219,"POST_FOR":220,"ForBlock":221,"ForStart":222,"ForSource":223,"ForVariables":224,"OWN":225,"ForValue":226,"FORIN":227,"FOROF":228,"BY":229,"SWITCH":230,"Whens":231,"ELSE":232,"When":233,"LEADING_WHEN":234,"IfBlock":235,"IF":236,"ELIF":237,"POST_IF":238,"?":239,"UNARY":240,"SQRT":241,"-":242,"+":243,"--":244,"++":245,"MATH":246,"SHIFT":247,"RELATION":248,"COMPOUND_ASSIGN":249,"$accept":0,"$end":1},
	terminals_: {2:"error",6:"TERMINATOR",7:"BODYSTART",10:"INDENT",11:"OUTDENT",14:",",19:"STATEMENT",20:"BREAK",21:"CALL_START",22:"CALL_END",23:"CONTINUE",24:"DEBUGGER",26:"IMPORT",28:"FROM",30:"AS",32:"STRING",51:"IDENTIFIER",53:"IVAR",54:"CVAR",56:"GVAR",58:"CONST",60:"ARGVAR",62:"SYMBOL",64:"NUMBER",66:"STRING_START",67:"NEOSTRING",69:"STRING_END",70:"{{",71:"}}",73:"JS",74:"REGEX",75:"BOOL",76:"TRUE",77:"FALSE",78:"NULL",79:"UNDEFINED",80:"RETURN",83:"SELECTOR_START",85:"SELECTOR_NS",86:"SELECTOR_ID",87:"SELECTOR_CLASS",88:".",89:"{",90:"}",91:"#",92:"SELECTOR_COMBINATOR",93:"SELECTOR_PSEUDO_CLASS",94:"SELECTOR_GROUP",95:"UNIVERSAL_SELECTOR",96:"[",97:"]",98:"SELECTOR_ATTR_OP",100:"SELECTOR_TAG",102:"SELECTOR_END",103:"TAG_START",106:"TAG_END",110:"TAG_TYPE",111:"INDEX_START",112:"INDEX_END",113:"@",116:"TAG_ATTR",117:"=",122:"EXTEND",123:"LOCAL",124:"TAG",126:"COMPARE",128:"TAG_ID",130:"IDREF",135:":",136:"(",137:")",138:"HERECOMMENT",139:"COMMENT",143:"BEGIN",144:"DO",145:"BLOCK_PARAM_START",147:"BLOCK_PARAM_END",151:"PROP",152:"ATTR",154:"VAR",156:"GLOBAL",157:"EXPORT",158:"DEF",164:"DEF_BODY",165:"DEF_EMPTY",170:"SPLAT",171:"LOGIC",172:"BLOCK_ARG",175:"LET",177:"NEW",180:"?:",181:".:",183:"?.",184:"SUPER",185:"AWAIT",188:"ARGUMENTS",193:"CLASS",194:"MODULE",196:"FUNC_EXIST",197:"THIS",198:"SELF",200:"..",201:"...",204:"TRY",207:"FINALLY",208:"CATCH",209:"CATCH_VAR",210:"THROW",212:"WHILE",213:"WHEN",214:"UNTIL",216:"LOOP",219:"FOR",220:"POST_FOR",225:"OWN",227:"FORIN",228:"FOROF",229:"BY",230:"SWITCH",232:"ELSE",234:"LEADING_WHEN",236:"IF",237:"ELIF",238:"POST_IF",239:"?",240:"UNARY",241:"SQRT",242:"-",243:"+",244:"--",245:"++",246:"MATH",247:"SHIFT",248:"RELATION",249:"COMPOUND_ASSIGN"},
	productions_: [0,[3,0],[3,1],[3,2],[4,1],[4,1],[4,3],[4,2],[9,1],[5,2],[5,3],[5,4],[8,1],[8,1],[8,3],[8,3],[8,1],[8,1],[16,1],[16,1],[16,1],[16,1],[16,4],[16,1],[16,4],[16,1],[16,1],[25,4],[25,4],[25,2],[29,1],[27,1],[27,3],[31,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[50,1],[52,1],[52,1],[55,1],[57,1],[59,1],[61,1],[63,1],[63,1],[63,1],[63,1],[65,1],[65,2],[65,2],[65,2],[68,2],[68,3],[72,1],[72,1],[72,1],[72,1],[72,1],[72,1],[72,1],[72,1],[17,2],[17,2],[17,1],[82,1],[82,2],[82,2],[82,2],[82,2],[82,5],[82,5],[82,2],[82,2],[82,2],[82,2],[82,4],[82,6],[84,1],[101,2],[99,1],[99,1],[99,3],[48,4],[48,5],[48,5],[108,1],[108,1],[108,1],[108,0],[104,1],[104,3],[104,4],[104,3],[104,5],[104,5],[104,3],[104,2],[104,5],[105,0],[105,1],[105,3],[105,4],[114,1],[114,3],[118,1],[107,3],[107,3],[120,1],[120,3],[47,1],[47,2],[47,2],[121,2],[121,3],[121,4],[121,5],[127,0],[127,1],[125,1],[125,1],[129,1],[129,2],[38,3],[38,5],[133,1],[133,3],[133,5],[133,1],[134,1],[134,1],[134,1],[134,1],[134,1],[134,3],[15,1],[15,1],[36,1],[36,1],[36,1],[142,2],[141,2],[141,5],[141,6],[49,3],[49,5],[49,2],[148,1],[148,1],[149,1],[149,3],[153,4],[140,1],[140,2],[140,2],[155,8],[155,5],[155,6],[155,3],[160,1],[160,1],[161,1],[161,1],[161,3],[162,2],[162,2],[162,1],[159,1],[159,1],[159,1],[159,1],[115,0],[115,1],[146,0],[146,1],[146,3],[167,1],[167,1],[167,1],[167,2],[167,2],[167,2],[167,3],[169,1],[12,2],[173,3],[173,2],[173,2],[173,3],[173,2],[33,1],[33,1],[174,1],[174,1],[174,1],[176,1],[176,1],[176,1],[176,1],[176,1],[176,1],[176,1],[176,3],[176,3],[176,3],[176,3],[176,3],[176,3],[176,3],[176,3],[176,4],[179,1],[179,1],[178,1],[131,1],[131,1],[131,1],[34,2],[35,1],[35,1],[35,1],[35,1],[35,1],[35,1],[35,1],[35,1],[35,1],[35,1],[182,1],[182,1],[150,4],[191,0],[191,1],[191,3],[191,4],[191,6],[45,1],[45,2],[45,2],[45,2],[45,2],[45,3],[192,2],[192,3],[192,4],[192,5],[46,2],[46,3],[189,3],[189,2],[195,0],[195,1],[81,2],[81,4],[166,1],[109,1],[168,2],[168,4],[199,1],[199,1],[187,5],[190,3],[190,2],[190,2],[119,1],[119,3],[119,4],[119,4],[119,6],[132,2],[132,1],[202,1],[202,1],[202,1],[202,1],[203,1],[203,3],[41,2],[41,3],[41,3],[41,4],[206,2],[205,3],[18,2],[186,3],[186,5],[211,2],[211,4],[211,2],[211,4],[42,2],[42,2],[42,2],[42,1],[215,2],[215,2],[43,2],[43,2],[43,2],[218,1],[218,1],[221,2],[217,2],[217,2],[222,2],[222,3],[226,1],[226,1],[226,1],[224,1],[224,3],[223,2],[223,2],[223,4],[223,4],[223,4],[223,6],[223,6],[44,5],[44,7],[44,4],[44,6],[231,1],[231,2],[233,3],[233,4],[235,3],[235,5],[235,4],[235,3],[39,1],[39,3],[39,3],[40,5],[37,2],[37,2],[37,2],[37,2],[37,2],[37,2],[37,2],[37,2],[37,3],[37,3],[37,3],[37,3],[37,3],[37,3],[37,3],[37,3],[37,5]],
	performAction: function performAction(self, yytext, yy, yystate /* action[1] */, $$ /* vstack */) {
	/* self == yyval */
	
	var $0 = $$.length - 1;
	switch (yystate) {
	case 1:
	return self.$ = new yy.Root([]);
	break;
	case 2:
	return self.$ = new yy.Root($$[$0]);
	break;
	case 3:
	return self.$ = $$[$0-1];
	break;
	case 4:
	self.$ = new yy.Block([]);
	break;
	case 5:
	self.$ = new yy.Block([$$[$0]]);
	break;
	case 6:
	self.$ = $$[$0-2].break($$[$0-1]).add($$[$0]);
	break;
	case 7:
	self.$ = $$[$0-1].break($$[$0]);
	break;
	case 8:
	self.$ = new yy.Terminator($$[$0]);
	break;
	case 9:
	self.$ = new yy.Block([]).indented($$[$0-1],$$[$0]);
	break;
	case 10: case 119:
	self.$ = $$[$0-1].indented($$[$0-2],$$[$0]);
	break;
	case 11:
	self.$ = $$[$0-1].prebreak($$[$0-2]).indented($$[$0-3],$$[$0]);
	break;
	case 12: case 13: case 16: case 17: case 18: case 19: case 26: case 30: case 33: case 34: case 35: case 36: case 37: case 38: case 39: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 48: case 49: case 59: case 60: case 67: case 93: case 94: case 99: case 118: case 123: case 130: case 141: case 142: case 143: case 144: case 145: case 146: case 150: case 151: case 152: case 160: case 161: case 162: case 165: case 174: case 175: case 177: case 180: case 181: case 182: case 183: case 184: case 185: case 196: case 203: case 204: case 205: case 206: case 207: case 208: case 210: case 211: case 212: case 213: case 227: case 228: case 229: case 231: case 232: case 233: case 234: case 235: case 237: case 238: case 239: case 240: case 249: case 283: case 284: case 285: case 286: case 287: case 288: case 306: case 312: case 313: case 319: case 335: case 343:
	self.$ = $$[$0];
	break;
	case 14: case 15:
	self.$ = $$[$0-2].addExpression($$[$0]);
	break;
	case 20: case 68:
	self.$ = new yy.Literal($$[$0]);
	break;
	case 21:
	self.$ = new yy.BreakStatement($$[$0]);
	break;
	case 22:
	self.$ = new yy.BreakStatement($$[$0-3],$$[$0-1]);
	break;
	case 23:
	self.$ = new yy.ContinueStatement($$[$0]);
	break;
	case 24:
	self.$ = new yy.ContinueStatement($$[$0-3],$$[$0-1]);
	break;
	case 25:
	self.$ = new yy.DebuggerStatement($$[$0]);
	break;
	case 27:
	self.$ = new yy.ImportStatement($$[$0-2],$$[$0]);
	break;
	case 28:
	self.$ = new yy.ImportStatement(null,$$[$0-2],$$[$0]);
	break;
	case 29:
	self.$ = new yy.ImportStatement(null,$$[$0]);
	break;
	case 31: case 113: case 187: case 322:
	self.$ = [$$[$0]];
	break;
	case 32: case 114: case 188:
	self.$ = $$[$0-2].concat($$[$0]);
	break;
	case 50:
	self.$ = new yy.Identifier($$[$0]);
	break;
	case 51: case 52:
	self.$ = new yy.Ivar($$[$0]);
	break;
	case 53:
	self.$ = new yy.Gvar($$[$0]);
	break;
	case 54:
	self.$ = new yy.Const($$[$0]);
	break;
	case 55:
	self.$ = new yy.Argvar($$[$0]);
	break;
	case 56:
	self.$ = new yy.Symbol($$[$0]);
	break;
	case 57:
	self.$ = new yy.Num($$[$0]);
	break;
	case 58:
	self.$ = new yy.Str($$[$0]);
	break;
	case 61:
	self.$ = new yy.InterpolatedString([],{open: $$[$0]});
	break;
	case 62:
	self.$ = $$[$0-1].add($$[$0]);
	break;
	case 63:
	self.$ = $$[$0] ? ($$[$0-1].add($$[$0])) : ($$[$0-1]);
	break;
	case 64:
	self.$ = $$[$0-1].option('close',$$[$0]);
	break;
	case 65:
	self.$ = null;
	break;
	case 66: case 92: case 95: case 120: case 147: case 163: case 176: case 282:
	self.$ = $$[$0-1];
	break;
	case 69:
	self.$ = new yy.RegExp($$[$0]);
	break;
	case 70:
	self.$ = new yy.Bool($$[$0]);
	break;
	case 71:
	self.$ = yy.TRUE;
	break;
	case 72:
	self.$ = yy.FALSE;
	break;
	case 73:
	self.$ = yy.NIL;
	break;
	case 74:
	self.$ = yy.UNDEFINED;
	break;
	case 75: case 76:
	self.$ = new yy.Return($$[$0]);
	break;
	case 77:
	self.$ = new yy.Return();
	break;
	case 78:
	self.$ = new yy.Selector([],{type: $$[$0]});
	break;
	case 79:
	self.$ = $$[$0-1].add(new yy.SelectorType($$[$0]),'tag');
	break;
	case 80:
	self.$ = $$[$0-1].add(new yy.SelectorNamespace($$[$0]),'ns');
	break;
	case 81:
	self.$ = $$[$0-1].add(new yy.SelectorId($$[$0]),'id');
	break;
	case 82:
	self.$ = $$[$0-1].add(new yy.SelectorClass($$[$0]),'class');
	break;
	case 83:
	self.$ = $$[$0-4].add(new yy.SelectorClass($$[$0-1]),'class');
	break;
	case 84:
	self.$ = $$[$0-4].add(new yy.SelectorId($$[$0-1]),'id');
	break;
	case 85:
	self.$ = $$[$0-1].add(new yy.SelectorCombinator($$[$0]),'sep');
	break;
	case 86:
	self.$ = $$[$0-1].add(new yy.SelectorPseudoClass($$[$0]),'pseudoclass');
	break;
	case 87:
	self.$ = $$[$0-1].group();
	break;
	case 88:
	self.$ = $$[$0-1].add(new yy.SelectorUniversal($$[$0]),'universal');
	break;
	case 89:
	self.$ = $$[$0-3].add(new yy.SelectorAttribute($$[$0-1]),'attr');
	break;
	case 90:
	self.$ = $$[$0-5].add(new yy.SelectorAttribute($$[$0-3],$$[$0-2],$$[$0-1]),'attr');
	break;
	case 91: case 100: case 101: case 132: case 133:
	self.$ = new yy.TagTypeIdentifier($$[$0]);
	break;
	case 96:
	self.$ = $$[$0-2].set({attributes: $$[$0-1],open: $$[$0-3],close: $$[$0]});
	break;
	case 97:
	self.$ = $$[$0-3].set({attributes: $$[$0-2],body: $$[$0],open: $$[$0-4],close: $$[$0-1]});
	break;
	case 98:
	self.$ = new yy.TagWrapper($$[$0-2],$$[$0-4],$$[$0]);
	break;
	case 102:
	self.$ = new yy.TagTypeIdentifier('div');
	break;
	case 103:
	self.$ = new yy.Tag({type: $$[$0]});
	break;
	case 104:
	self.$ = $$[$0-2].addSymbol($$[$0]);
	break;
	case 105:
	self.$ = $$[$0-3].addIndex($$[$0-1]);
	break;
	case 106:
	self.$ = $$[$0-2].addClass($$[$0]);
	break;
	case 107:
	self.$ = $$[$0-4].addClass($$[$0-1]);
	break;
	case 108:
	self.$ = $$[$0-4].set({key: $$[$0-1]});
	break;
	case 109:
	self.$ = $$[$0-2].set({id: $$[$0]});
	break;
	case 110:
	self.$ = $$[$0-1].set({ivar: $$[$0]});
	break;
	case 111:
	self.$ = $$[$0-4].set({id: $$[$0-1]});
	break;
	case 112: case 179: case 186:
	self.$ = [];
	break;
	case 115:
	self.$ = $$[$0-3].concat($$[$0]);
	break;
	case 116:
	self.$ = new yy.TagAttr($$[$0],$$[$0]);
	break;
	case 117:
	self.$ = new yy.TagAttr($$[$0-2],$$[$0],$$[$0-1]);
	break;
	case 121:
	self.$ = new yy.TagDesc($$[$0]);
	break;
	case 122:
	self.$ = $$[$0-2].classes($$[$0]);
	break;
	case 124:
	self.$ = $$[$0].set({extension: true});
	break;
	case 125:
	self.$ = $$[$0].set({local: true});
	break;
	case 126:
	self.$ = new yy.TagDeclaration($$[$0]).set({keyword: $$[$0-1]});
	break;
	case 127:
	self.$ = new yy.TagDeclaration($$[$0-1],null,$$[$0]).set({keyword: $$[$0-2]});
	break;
	case 128:
	self.$ = new yy.TagDeclaration($$[$0-2],$$[$0]).set({keyword: $$[$0-3]});
	break;
	case 129:
	self.$ = new yy.TagDeclaration($$[$0-3],$$[$0-1],$$[$0]).set({keyword: $$[$0-4]});
	break;
	case 131:
	self.$ = ['yy.extend'];
	break;
	case 134: case 135:
	self.$ = new yy.TagId($$[$0]);
	break;
	case 136:
	self.$ = new yy.Assign($$[$0-1],$$[$0-2],$$[$0]);
	break;
	case 137:
	self.$ = new yy.Assign($$[$0-3],$$[$0-4],$$[$0-1].indented($$[$0-2],$$[$0]));
	break;
	case 138:
	self.$ = new yy.ObjAttr($$[$0]);
	break;
	case 139:
	self.$ = new yy.ObjAttr($$[$0-2],$$[$0],'object');
	break;
	case 140:
	self.$ = new yy.ObjAttr($$[$0-4],$$[$0-1].indented($$[$0-2],$$[$0]),'object');
	break;
	case 148:
	self.$ = new yy.Comment($$[$0],true);
	break;
	case 149:
	self.$ = new yy.Comment($$[$0],false);
	break;
	case 153:
	self.$ = new yy.Begin($$[$0]);
	break;
	case 154:
	self.$ = new yy.Lambda([],$$[$0],null,null,{bound: true});
	break;
	case 155:
	self.$ = new yy.Lambda($$[$0-2],$$[$0],null,null,{bound: true});
	break;
	case 156:
	self.$ = new yy.Lambda($$[$0-3],$$[$0-1],null,null,{bound: true});
	break;
	case 157:
	self.$ = new yy.PropertyDeclaration($$[$0-1],$$[$0],$$[$0-2]);
	break;
	case 158:
	self.$ = new yy.PropertyDeclaration($$[$0-3],$$[$0-1],$$[$0-4]);
	break;
	case 159:
	self.$ = new yy.PropertyDeclaration($$[$0],null,$$[$0-1]);
	break;
	case 164:
	self.$ = $$[$0-3];
	break;
	case 166: case 252:
	self.$ = $$[$0].set({global: $$[$0-1]});
	break;
	case 167: case 202: case 253:
	self.$ = $$[$0].set({export: $$[$0-1]});
	break;
	case 168:
	self.$ = new yy.MethodDeclaration($$[$0-2],$$[$0],$$[$0-4],$$[$0-6],$$[$0-5]).set({def: $$[$0-7]});
	break;
	case 169:
	self.$ = new yy.MethodDeclaration([],$$[$0],$$[$0-1],$$[$0-3],$$[$0-2]).set({def: $$[$0-4]});
	break;
	case 170:
	self.$ = new yy.MethodDeclaration($$[$0-2],$$[$0],$$[$0-4],null).set({def: $$[$0-5]});
	break;
	case 171:
	self.$ = new yy.MethodDeclaration([],$$[$0],$$[$0-1],null).set({def: $$[$0-2]});
	break;
	case 172:
	self.$ = {static: true};
	break;
	case 173:
	self.$ = {};
	break;
	case 178:
	self.$ = $$[$0].body();
	break;
	case 189:
	self.$ = new yy.NamedParams($$[$0]);
	break;
	case 190:
	self.$ = new yy.ArrayParams($$[$0]);
	break;
	case 191:
	self.$ = new yy.RequiredParam($$[$0]);
	break;
	case 192:
	self.$ = new yy.SplatParam($$[$0],null,$$[$0-1]);
	break;
	case 193: case 194:
	self.$ = new yy.BlockParam($$[$0],null,$$[$0-1]);
	break;
	case 195:
	self.$ = new yy.OptionalParam($$[$0-2],$$[$0],$$[$0-1]);
	break;
	case 197:
	self.$ = yy.SPLAT($$[$0]);
	break;
	case 198: case 201:
	self.$ = yy.SPLAT(new yy.VarReference($$[$0],$$[$0-2]),$$[$0-1]);
	break;
	case 199: case 200:
	self.$ = new yy.VarReference($$[$0],$$[$0-1]);
	break;
	case 209:
	self.$ = new yy.IvarAccess('.',null,$$[$0]);
	break;
	case 214:
	self.$ = new yy.VarOrAccess($$[$0]);
	break;
	case 215:
	self.$ = new yy.New($$[$0-2]);
	break;
	case 216:
	self.$ = new yy.SuperAccess('.',$$[$0-2],$$[$0]);
	break;
	case 217:
	self.$ = new yy.PropertyAccess($$[$0-1],$$[$0-2],$$[$0]);
	break;
	case 218: case 219: case 220: case 222:
	self.$ = new yy.Access($$[$0-1],$$[$0-2],$$[$0]);
	break;
	case 221:
	self.$ = new yy.Access('.',$$[$0-2],new yy.Identifier($$[$0].value()));
	break;
	case 223:
	self.$ = new yy.IndexAccess('.',$$[$0-3],$$[$0-1]);
	break;
	case 226:
	self.$ = yy.SUPER;
	break;
	case 230:
	self.$ = new yy.Await($$[$0]).set({keyword: $$[$0-1]});
	break;
	case 236:
	self.$ = yy.ARGUMENTS;
	break;
	case 241:
	self.$ = new yy.Index($$[$0]);
	break;
	case 242:
	self.$ = new yy.Slice($$[$0]);
	break;
	case 243:
	self.$ = new yy.Obj($$[$0-2],$$[$0-3].generated);
	break;
	case 244:
	self.$ = new yy.AssignList([]);
	break;
	case 245:
	self.$ = new yy.AssignList([$$[$0]]);
	break;
	case 246: case 278:
	self.$ = $$[$0-2].add($$[$0]);
	break;
	case 247: case 279:
	self.$ = $$[$0-3].add($$[$0-1]).add($$[$0]);
	break;
	case 248:
	self.$ = $$[$0-5].concat($$[$0-2].indented($$[$0-3],$$[$0]));
	break;
	case 250:
	self.$ = $$[$0].set({extension: $$[$0-1]});
	break;
	case 251:
	self.$ = $$[$0].set({local: $$[$0-1]});
	break;
	case 254:
	self.$ = $$[$0].set({export: $$[$0-2],local: $$[$0-1]});
	break;
	case 255:
	self.$ = new yy.ClassDeclaration($$[$0],null,[]).set({keyword: $$[$0-1]});
	break;
	case 256:
	self.$ = new yy.ClassDeclaration($$[$0-1],null,$$[$0]).set({keyword: $$[$0-2]});
	break;
	case 257:
	self.$ = new yy.ClassDeclaration($$[$0-2],$$[$0],[]).set({keyword: $$[$0-3]});
	break;
	case 258:
	self.$ = new yy.ClassDeclaration($$[$0-3],$$[$0-1],$$[$0]).set({keyword: $$[$0-4]});
	break;
	case 259:
	self.$ = new yy.Module($$[$0]);
	break;
	case 260:
	self.$ = new yy.Module($$[$0-1],null,$$[$0]);
	break;
	case 261:
	self.$ = new yy.Call($$[$0-2],$$[$0],$$[$0-1]);
	break;
	case 262:
	self.$ = $$[$0-1].addBlock($$[$0]);
	break;
	case 263:
	self.$ = false;
	break;
	case 264:
	self.$ = true;
	break;
	case 265:
	self.$ = new yy.ArgList([]);
	break;
	case 266:
	self.$ = $$[$0-2];
	break;
	case 267:
	self.$ = new yy.This($$[$0]);
	break;
	case 268:
	self.$ = new yy.Self($$[$0]);
	break;
	case 269:
	self.$ = new yy.Arr(new yy.ArgList([]));
	break;
	case 270:
	self.$ = new yy.Arr($$[$0-2]);
	break;
	case 271:
	self.$ = '..';
	break;
	case 272:
	self.$ = '...';
	break;
	case 273:
	self.$ = yy.OP($$[$0-2],$$[$0-3],$$[$0-1]);
	break;
	case 274:
	self.$ = new yy.Range($$[$0-2],$$[$0],$$[$0-1]);
	break;
	case 275:
	self.$ = new yy.Range($$[$0-1],null,$$[$0]);
	break;
	case 276:
	self.$ = new yy.Range(null,$$[$0],$$[$0-1]);
	break;
	case 277:
	self.$ = new yy.ArgList([$$[$0]]);
	break;
	case 280:
	self.$ = $$[$0-2].indented($$[$0-3],$$[$0]);
	break;
	case 281:
	self.$ = $$[$0-5].concat($$[$0-2]);
	break;
	case 289:
	self.$ = [].concat($$[$0-2],$$[$0]);
	break;
	case 290:
	self.$ = new yy.Try($$[$0]);
	break;
	case 291:
	self.$ = new yy.Try($$[$0-1],$$[$0]);
	break;
	case 292:
	self.$ = new yy.Try($$[$0-1],null,$$[$0]);
	break;
	case 293:
	self.$ = new yy.Try($$[$0-2],$$[$0-1],$$[$0]);
	break;
	case 294:
	self.$ = new yy.Finally($$[$0]);
	break;
	case 295:
	self.$ = new yy.Catch($$[$0],$$[$0-1]);
	break;
	case 296:
	self.$ = new yy.Throw($$[$0]);
	break;
	case 297:
	self.$ = new yy.Parens($$[$0-1],$$[$0-2],$$[$0]);
	break;
	case 298:
	self.$ = new yy.Parens($$[$0-2],$$[$0-4],$$[$0]);
	break;
	case 299:
	self.$ = new yy.While($$[$0]);
	break;
	case 300:
	self.$ = new yy.While($$[$0-2],{guard: $$[$0]});
	break;
	case 301:
	self.$ = new yy.While($$[$0],{invert: true});
	break;
	case 302:
	self.$ = new yy.While($$[$0-2],{invert: true,guard: $$[$0]});
	break;
	case 303: case 311: case 314:
	self.$ = $$[$0-1].addBody($$[$0]);
	break;
	case 304: case 305:
	self.$ = $$[$0].addBody(yy.Block.wrap([$$[$0-1]]));
	break;
	case 307:
	self.$ = new yy.While(new yy.Literal('true')).addBody($$[$0]);
	break;
	case 308:
	self.$ = new yy.While(new yy.Literal('true')).addBody(yy.Block.wrap([$$[$0]]));
	break;
	case 309: case 310:
	self.$ = $$[$0].addBody([$$[$0-1]]);
	break;
	case 315:
	self.$ = {source: new yy.ValueNode($$[$0])};
	break;
	case 316:
	self.$ = $$[$0].configure({own: $$[$0-1].own,name: $$[$0-1][0],index: $$[$0-1][1],keyword: $$[$0-1].keyword});
	break;
	case 317:
	self.$ = ($$[$0].keyword = $$[$0-1]) && $$[$0];
	break;
	case 318:
	self.$ = ($$[$0].own = true) && ($$[$0].keyword = $$[$0-2]) && $$[$0];
	break;
	case 320: case 321:
	self.$ = new yy.ValueNode($$[$0]);
	break;
	case 323:
	self.$ = [$$[$0-2],$$[$0]];
	break;
	case 324:
	self.$ = new yy.ForIn({source: $$[$0]});
	break;
	case 325:
	self.$ = new yy.ForOf({source: $$[$0],object: true});
	break;
	case 326:
	self.$ = new yy.ForIn({source: $$[$0-2],guard: $$[$0]});
	break;
	case 327:
	self.$ = new yy.ForOf({source: $$[$0-2],guard: $$[$0],object: true});
	break;
	case 328:
	self.$ = new yy.ForIn({source: $$[$0-2],step: $$[$0]});
	break;
	case 329:
	self.$ = new yy.ForIn({source: $$[$0-4],guard: $$[$0-2],step: $$[$0]});
	break;
	case 330:
	self.$ = new yy.ForIn({source: $$[$0-4],step: $$[$0-2],guard: $$[$0]});
	break;
	case 331:
	self.$ = new yy.Switch($$[$0-3],$$[$0-1]);
	break;
	case 332:
	self.$ = new yy.Switch($$[$0-5],$$[$0-3],$$[$0-1]);
	break;
	case 333:
	self.$ = new yy.Switch(null,$$[$0-1]);
	break;
	case 334:
	self.$ = new yy.Switch(null,$$[$0-3],$$[$0-1]);
	break;
	case 336:
	self.$ = $$[$0-1].concat($$[$0]);
	break;
	case 337:
	self.$ = [new yy.SwitchCase($$[$0-1],$$[$0])];
	break;
	case 338:
	self.$ = [new yy.SwitchCase($$[$0-2],$$[$0-1])];
	break;
	case 339:
	self.$ = new yy.If($$[$0-1],$$[$0],{type: $$[$0-2]});
	break;
	case 340:
	self.$ = $$[$0-4].addElse(new yy.If($$[$0-1],$$[$0],{type: $$[$0-2]}));
	break;
	case 341:
	self.$ = $$[$0-3].addElse(new yy.If($$[$0-1],$$[$0],{type: $$[$0-2]}));
	break;
	case 342:
	self.$ = $$[$0-2].addElse($$[$0]);
	break;
	case 344:
	self.$ = new yy.If($$[$0],new yy.Block([$$[$0-2]]),{type: $$[$0-1],statement: true});
	break;
	case 345:
	self.$ = new yy.If($$[$0],new yy.Block([$$[$0-2]]),{type: $$[$0-1]});
	break;
	case 346:
	self.$ = yy.If.ternary($$[$0-4],$$[$0-2],$$[$0]);
	break;
	case 347: case 348:
	self.$ = yy.OP($$[$0-1],$$[$0]);
	break;
	case 349:
	self.$ = new yy.Op('-',$$[$0]);
	break;
	case 350:
	self.$ = new yy.Op('+',$$[$0]);
	break;
	case 351:
	self.$ = new yy.UnaryOp('--',null,$$[$0]);
	break;
	case 352:
	self.$ = new yy.UnaryOp('++',null,$$[$0]);
	break;
	case 353:
	self.$ = new yy.UnaryOp('--',$$[$0-1],null,true);
	break;
	case 354:
	self.$ = new yy.UnaryOp('++',$$[$0-1],null,true);
	break;
	case 355: case 356:
	self.$ = new yy.Op($$[$0-1],$$[$0-2],$$[$0]);
	break;
	case 357: case 358: case 359: case 360:
	self.$ = yy.OP($$[$0-1],$$[$0-2],$$[$0]);
	break;
	case 361:
	self.$ = (function () {
					if ($$[$0-1].charAt(0) == '!') {
						return yy.OP($$[$0-1].slice(1),$$[$0-2],$$[$0]).invert();
					} else {
						return yy.OP($$[$0-1],$$[$0-2],$$[$0]);
					};
				}());
	break;
	case 362:
	self.$ = yy.OP_COMPOUND($$[$0-1]._value,$$[$0-1],$$[$0-2],$$[$0]);
	break;
	case 363:
	self.$ = yy.OP_COMPOUND($$[$0-3]._value,$$[$0-4],$$[$0-1].indented($$[$0-2],$$[$0]));
	break;
	}
	},
	table: [{1:[2,1],3:1,4:2,5:3,7:$V0,8:5,10:$V1,12:7,13:8,15:9,16:10,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{1:[3]},{1:[2,2],6:$V51,9:133},{6:[1,135]},o($V61,[2,4]),o($V61,[2,5],{14:$V71}),{4:138,6:[1,139],7:$V0,8:5,11:[1,137],12:7,13:8,15:9,16:10,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($V81,[2,12]),o($V81,[2,13],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($V81,[2,16]),o($V81,[2,17],{218:108,222:109,211:152,217:153,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vi1}),{13:154,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vj1,[2,34]),o($Vj1,[2,35],{195:156,141:157,179:159,21:$Vk1,88:$Vl1,89:$Vm1,111:$Vn1,144:$VC,180:$Vo1,181:$Vp1,183:$Vq1,196:$Vr1}),o($Vj1,[2,36]),o($Vj1,[2,37]),o($Vj1,[2,38]),o($Vj1,[2,39]),o($Vj1,[2,40]),o($Vj1,[2,41]),o($Vj1,[2,42]),o($Vj1,[2,43]),o($Vj1,[2,44]),o($Vj1,[2,45]),o($Vj1,[2,46]),o($Vj1,[2,47]),o($Vj1,[2,48]),o($Vj1,[2,49]),o($Vs1,[2,148]),o($Vs1,[2,149]),o($Vt1,[2,18]),o($Vt1,[2,19]),o($Vt1,[2,20]),o($Vt1,[2,21],{21:[1,166]}),o($Vt1,[2,23],{21:[1,167]}),o($Vt1,[2,25]),o($Vt1,[2,26]),{13:168,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vu1,$Vv1,{117:[1,169]}),o($Vu1,[2,232]),o($Vu1,[2,233]),o($Vu1,[2,234]),o($Vu1,[2,235]),o($Vu1,[2,236]),o($Vu1,[2,237]),o($Vu1,[2,238]),o($Vu1,[2,239]),o($Vu1,[2,240]),o($Vj1,[2,150]),o($Vj1,[2,151]),o($Vj1,[2,152]),{13:170,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:171,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:172,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:173,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{32:$V7,35:175,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,82:92,83:$Vp,89:$Vw1,91:$Vr,96:$Vs,101:46,109:101,129:45,130:$Vx,131:177,136:$Vy,150:77,154:$VF,157:$Vx1,166:44,168:76,173:102,175:$VK,176:174,178:39,184:$VL,186:41,187:42,188:$VN,189:47,197:$VQ,198:$VR},{32:$V7,35:175,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,82:92,83:$Vp,89:$Vw1,91:$Vr,96:$Vs,101:46,109:101,129:45,130:$Vx,131:177,136:$Vy,150:77,154:$VF,157:$Vx1,166:44,168:76,173:102,175:$VK,176:179,178:39,184:$VL,186:41,187:42,188:$VN,189:47,197:$VQ,198:$VR},o($Vy1,$Vz1,{244:[1,180],245:[1,181],249:[1,182]}),o($Vj1,[2,343],{232:[1,183],237:[1,184]}),{5:185,10:$V1},{5:186,10:$V1},o($Vj1,[2,306]),{5:187,10:$V1},{10:[1,189],13:188,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vj1,[2,249]),{121:191,124:$Vw,192:190,193:$VO},{121:193,124:$Vw,192:192,193:$VO},{155:195,158:$VI,192:194,193:$VO},{123:[1,197],154:$VF,155:198,157:$Vx1,158:$VI,173:199,175:$VK,192:196,193:$VO},{32:$V7,35:175,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,82:92,83:$Vp,89:$Vw1,91:$Vr,96:$Vs,101:46,109:101,129:45,130:$Vx,131:177,136:$Vy,150:77,154:$VF,157:$Vx1,166:44,168:76,173:102,175:$VK,176:200,178:39,184:$VL,186:41,187:42,188:$VN,189:47,197:$VQ,198:$VR},o($Vj1,[2,123]),o($VA1,[2,102],{104:201,108:203,109:204,51:[1,205],89:[1,202],110:[1,206],198:$VR}),{50:208,51:$V8,89:[1,209],149:207},o($Vt1,[2,77],{34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,17:30,18:31,25:36,131:38,178:39,72:40,186:41,187:42,166:44,129:45,101:46,189:47,140:48,141:49,142:50,176:57,235:58,211:60,215:61,217:62,192:64,121:70,148:72,168:76,150:77,63:79,82:92,155:93,57:97,52:98,55:99,59:100,109:101,173:102,50:103,218:108,222:109,61:116,65:117,16:155,13:210,81:211,19:$V2,20:$V3,21:$VB1,23:$V4,24:$V5,26:$V6,32:$V7,51:$V8,53:$V9,54:$Va,56:$Vb,58:$Vc,60:$Vd,62:$Ve,64:$Vf,66:$Vg,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,83:$Vp,89:$Vq,91:$Vr,96:$Vs,103:$Vt,122:$Vu,123:$Vv,124:$Vw,130:$Vx,136:$Vy,143:$VB,144:$VC,151:$VD,152:$VE,154:$VF,156:$VG,157:$VH,158:$VI,175:$VK,184:$VL,185:$VM,188:$VN,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,216:$VW,230:$VZ,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41}),{13:213,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{27:214,29:215,31:216,32:$VC1,33:218,50:220,51:$V8,57:219,58:$Vc},o($Vy1,[2,228]),o($Vy1,[2,229]),o($VD1,[2,226]),o($Vu1,[2,67]),o($Vu1,[2,68]),o($Vu1,[2,69]),o($Vu1,[2,70]),o($Vu1,[2,71]),o($Vu1,[2,72]),o($Vu1,[2,73]),o($Vu1,[2,74]),{4:221,7:$V0,8:5,10:[1,222],12:7,13:8,15:9,16:10,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{10:$VE1,12:228,13:223,15:230,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,97:$VF1,101:46,103:$Vt,109:101,119:225,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,171:$VG1,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,202:226,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o([1,6,10,11,14,21,22,71,88,89,90,91,97,106,111,112,126,135,137,144,147,171,180,181,183,196,200,201,212,213,214,219,220,229,238,239,242,243,246,247,248],[2,267]),o($Vu1,[2,134]),{50:231,51:$V8},{84:233,85:[1,234],86:[1,235],87:[1,236],88:[1,237],91:[1,238],92:[1,239],93:[1,240],94:[1,241],95:[1,242],96:[1,243],100:[1,244],102:[1,232]},o($Vj1,[2,165]),{5:245,10:$V1,145:[1,246]},o($VH1,$VI1,{61:116,65:117,191:248,133:249,134:250,15:251,50:252,57:253,63:254,52:255,55:256,32:$V7,51:$V8,53:$V9,54:$Va,56:$Vb,58:$Vc,62:$Ve,64:$Vf,66:$Vg,136:$VJ1,138:$Vz,139:$VA,145:$VK1}),{5:258,10:$V1},o($VD1,[2,208]),o($VD1,[2,209]),o($VD1,[2,210]),o($VD1,[2,211]),o($VD1,[2,212]),o($VD1,[2,213]),o($VD1,[2,214]),{13:259,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:260,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:261,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{5:262,10:$V1,13:263,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{50:268,51:$V8,89:$Vw1,96:$Vs,150:270,168:269,187:264,224:265,225:[1,266],226:267},{223:271,227:[1,272],228:[1,273]},{32:$V7,35:175,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,82:92,83:$Vp,89:$Vw1,91:$Vr,96:$Vs,101:46,109:101,129:45,130:$Vx,131:177,136:$Vy,150:77,154:$VF,157:$Vx1,166:44,168:76,173:102,175:$VK,176:274,178:39,184:$VL,186:41,187:42,188:$VN,189:47,197:$VQ,198:$VR},{110:$VL1,125:275,128:$VM1},o($VN1,[2,160]),o($VN1,[2,161]),o($Vu1,[2,57]),o($Vu1,[2,58]),o($Vu1,[2,59]),o($Vu1,[2,60],{68:279,67:[1,278],69:[1,280],70:[1,281]}),o($VO1,[2,78]),{50:287,51:$V8,55:286,56:$Vb,57:288,58:$Vc,89:$VP1,109:285,159:282,161:283,166:284,197:$VQ,198:$VR},o([1,6,10,11,14,21,22,28,71,88,89,90,91,97,106,111,112,117,126,135,137,144,147,164,165,171,180,181,183,196,200,201,212,213,214,219,220,229,238,239,242,243,244,245,246,247,248,249],[2,54]),o($VQ1,[2,51]),o($VQ1,[2,52]),o([1,6,10,11,14,21,22,71,88,89,90,91,97,106,111,112,117,126,135,137,144,147,171,180,181,183,196,200,201,212,213,214,219,220,229,238,239,242,243,244,245,246,247,248,249],[2,53]),o($VD1,[2,55]),o($VQ1,[2,268]),{50:293,51:$V8,57:292,58:$Vc,96:$VR1,168:294,170:[1,290],174:291},{50:293,51:$V8,57:292,58:$Vc,96:$VR1,168:294,170:[1,297],174:296},o([1,6,10,11,14,21,22,28,71,88,89,90,91,97,98,106,111,112,117,126,135,137,144,147,164,165,171,180,181,183,196,200,201,212,213,214,219,220,227,228,229,238,239,242,243,244,245,246,247,248,249],[2,50]),o($VS1,[2,312]),o($VS1,[2,313]),o($VD1,[2,56]),o($VT1,[2,61]),o($V61,[2,7],{12:7,13:8,15:9,16:10,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,17:30,18:31,25:36,131:38,178:39,72:40,186:41,187:42,166:44,129:45,101:46,189:47,140:48,141:49,142:50,176:57,235:58,211:60,215:61,217:62,192:64,121:70,148:72,168:76,150:77,63:79,82:92,155:93,57:97,52:98,55:99,59:100,109:101,173:102,50:103,218:108,222:109,61:116,65:117,8:298,19:$V2,20:$V3,23:$V4,24:$V5,26:$V6,32:$V7,51:$V8,53:$V9,54:$Va,56:$Vb,58:$Vc,60:$Vd,62:$Ve,64:$Vf,66:$Vg,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,83:$Vp,89:$Vq,91:$Vr,96:$Vs,103:$Vt,122:$Vu,123:$Vv,124:$Vw,130:$Vx,136:$Vy,138:$Vz,139:$VA,143:$VB,144:$VC,151:$VD,152:$VE,154:$VF,156:$VG,157:$VH,158:$VI,170:$VJ,175:$VK,184:$VL,185:$VM,188:$VN,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,212:$VU,214:$VV,216:$VW,219:$VX,220:$VY,230:$VZ,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41}),o([1,6,11,19,20,23,24,26,32,51,53,54,56,58,60,62,64,66,73,74,75,76,77,78,79,80,83,89,91,96,103,122,123,124,130,136,137,138,139,143,144,151,152,154,156,157,158,170,171,175,184,185,188,193,194,197,198,204,210,212,214,216,219,220,230,236,240,241,242,243,244,245],[2,8]),{1:[2,3]},{12:300,13:299,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($VU1,[2,9]),{6:$V51,9:133,11:[1,301]},{4:302,7:$V0,8:5,12:7,13:8,15:9,16:10,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:303,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:304,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:305,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:306,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:307,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:308,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:309,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:310,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:311,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vj1,[2,305]),o($Vj1,[2,310]),{13:312,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vj1,[2,304]),o($Vj1,[2,309]),o([1,6,10,11,14,22,97,137],[2,197],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),{211:152,212:$VU,214:$VV,217:153,218:108,219:$VX,220:$VY,222:109,238:$Vi1},{21:$VB1,81:313},o($Vu1,[2,262]),o($VV1,[2,224],{178:315,61:316,62:$Ve,177:[1,314],184:$VL}),{50:317,51:$V8,52:318,53:$V9,54:$Va,57:319,58:$Vc},{50:320,51:$V8},{50:321,51:$V8},{13:323,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,182:322,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,190:324,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,199:325,200:$VW1,201:$VX1,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{21:[2,264]},{145:$VK1},o($VV1,[2,225]),{13:328,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:329,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($VY1,[2,230],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),{10:[1,331],13:330,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vj1,[2,347],{218:108,222:109,211:149,217:150}),o($Vj1,[2,348],{218:108,222:109,211:149,217:150}),o($Vj1,[2,349],{218:108,222:109,211:149,217:150}),o($Vj1,[2,350],{218:108,222:109,211:149,217:150}),o($Vj1,[2,351],{21:$Vz1,88:$Vz1,89:$Vz1,111:$Vz1,144:$Vz1,180:$Vz1,181:$Vz1,183:$Vz1,196:$Vz1}),{21:$Vk1,88:$Vl1,89:$Vm1,111:$Vn1,141:157,144:$VC,179:159,180:$Vo1,181:$Vp1,183:$Vq1,195:156,196:$Vr1},{154:$VF,157:$Vx1,173:199,175:$VK},o([21,88,89,111,144,180,181,183,196],$Vv1),o($VH1,$VI1,{61:116,65:117,191:248,133:249,134:250,15:251,50:252,57:253,63:254,52:255,55:256,32:$V7,51:$V8,53:$V9,54:$Va,56:$Vb,58:$Vc,62:$Ve,64:$Vf,66:$Vg,136:$VJ1,138:$Vz,139:$VA}),o($Vj1,[2,352],{21:$Vz1,88:$Vz1,89:$Vz1,111:$Vz1,144:$Vz1,180:$Vz1,181:$Vz1,183:$Vz1,196:$Vz1}),o($Vj1,[2,353]),o($Vj1,[2,354]),{10:[1,333],13:332,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{5:335,10:$V1,236:[1,334]},{13:336,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vj1,[2,290],{205:337,206:338,207:$VZ1,208:[1,339]}),o($Vj1,[2,303]),o($Vj1,[2,311]),{10:[1,341],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},{231:342,233:343,234:$V_1},o($Vj1,[2,250]),o($Vj1,[2,124]),o($Vj1,[2,251]),o($Vj1,[2,125]),o($Vj1,[2,252]),o($Vj1,[2,166]),o($Vj1,[2,253]),{192:345,193:$VO},o($Vj1,[2,167]),o($VD1,[2,202]),o($V$1,[2,259],{5:346,10:$V1,21:$Vz1,88:$Vz1,89:$Vz1,111:$Vz1,144:$Vz1,180:$Vz1,181:$Vz1,183:$Vz1,196:$Vz1}),o($V02,[2,112],{105:347,52:352,114:353,53:$V9,54:$Va,88:[1,348],91:[1,351],111:[1,349],113:[1,350],116:$V12}),{13:355,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($VA1,[2,103]),o($VA1,[2,99]),o($VA1,[2,100]),o($VA1,[2,101]),o($Vj1,[2,159],{150:356,21:[1,357],89:$Vw1}),o($V22,[2,162]),{13:358,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vt1,[2,75],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($Vt1,[2,76]),{10:$VE1,12:228,13:361,15:230,16:155,17:30,18:31,19:$V2,20:$V3,22:[1,359],23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,119:360,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,171:$VG1,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,202:226,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vt1,[2,296],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),{14:[1,363],28:[1,362]},o($Vt1,[2,29],{30:[1,364]}),o($V32,[2,31]),o([1,6,11,14,30,137,212,214,219,220,238],[2,30]),o($V42,[2,33]),o($V42,[2,203]),o($V42,[2,204]),{6:$V51,9:133,137:[1,365]},{4:366,7:$V0,8:5,12:7,13:8,15:9,16:10,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o([6,10,14,97],$V52,{218:108,222:109,211:149,217:150,199:367,126:$V91,171:$Va1,200:$VW1,201:$VX1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($V62,[2,269]),o([6,10,97],$V72,{115:368,14:$V82}),o($V92,[2,277]),{10:$VE1,12:228,13:361,15:230,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,119:370,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,171:$VG1,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,202:226,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($V92,[2,285]),o($V92,[2,286]),o($V92,[2,287]),o($Vu1,[2,135]),o($Vu1,[2,92]),o($VO1,[2,79]),o($VO1,[2,80]),o($VO1,[2,81]),o($VO1,[2,82]),{89:[1,371]},{89:[1,372]},o($VO1,[2,85]),o($VO1,[2,86]),o($VO1,[2,87]),o($VO1,[2,88]),{50:373,51:$V8},o($VO1,[2,91]),o($Vu1,[2,154]),o($Va2,$Vb2,{146:374,167:375,150:376,168:377,169:378,50:382,51:$V8,89:$Vw1,96:$VR1,170:$Vc2,171:$Vd2,172:$Ve2}),o($Va2,$Vb2,{167:375,150:376,168:377,169:378,50:382,146:383,51:$V8,89:$Vw1,96:$VR1,170:$Vc2,171:$Vd2,172:$Ve2}),o([6,10,90],$V72,{115:384,14:$Vf2}),o($Vg2,[2,245]),o($Vg2,[2,138],{135:[1,386]}),o($Vg2,[2,141]),o($Vh2,[2,142]),o($Vh2,[2,143]),o($Vh2,[2,144]),o($Vh2,[2,145]),o($Vh2,[2,146]),{13:387,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vj1,[2,153]),{5:388,10:$V1,126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($Vi2,[2,299],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,213:[1,389],214:$VV,219:$VX,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($Vi2,[2,301],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,213:[1,390],214:$VV,219:$VX,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($Vj1,[2,307]),o($Vj2,[2,308],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($Vj1,[2,315]),o($Vk2,[2,317]),{50:268,51:$V8,89:$Vw1,96:$VR1,150:270,168:269,224:391,226:267},o($Vk2,[2,322],{14:[1,392]}),o($Vl2,[2,319]),o($Vl2,[2,320]),o($Vl2,[2,321]),o($Vj1,[2,316]),{13:393,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:394,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vm2,[2,255],{5:395,10:$V1,21:$Vz1,88:$Vz1,89:$Vz1,111:$Vz1,144:$Vz1,180:$Vz1,181:$Vz1,183:$Vz1,196:$Vz1,126:[1,396]}),o($Vm2,[2,126],{5:397,10:$V1,126:[1,398]}),o($Vj1,[2,132]),o($Vj1,[2,133]),o($VT1,[2,62]),o($VT1,[2,63]),o($VT1,[2,64]),{13:400,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,71:[1,399],72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{88:[1,402],91:[1,403],160:401},o($Vn2,[2,180],{162:405,21:[1,404],164:$Vo2,165:$Vp2}),o($Vn2,[2,181]),o($Vn2,[2,182]),o($Vn2,[2,183]),o($Vq2,[2,174]),o($Vq2,[2,175]),{13:408,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{50:293,51:$V8,57:292,58:$Vc,96:$VR1,168:294,174:409},o($VD1,[2,199]),o($VD1,[2,205]),o($VD1,[2,206]),o($VD1,[2,207]),{10:$VE1,12:228,13:361,15:230,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,97:$VF1,101:46,103:$Vt,109:101,119:225,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,171:$VG1,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,202:226,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($VD1,[2,200]),{50:293,51:$V8,57:292,58:$Vc,96:$VR1,168:294,174:410},o($V61,[2,6],{14:$V71}),o($V81,[2,14],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($V81,[2,15]),o($VU1,[2,10]),{6:$V51,9:133,11:[1,411]},o($Vr2,[2,355],{218:108,222:109,211:149,217:150,246:$Vf1}),o($Vr2,[2,356],{218:108,222:109,211:149,217:150,246:$Vf1}),o($Vj1,[2,357],{218:108,222:109,211:149,217:150}),o([1,6,10,11,14,22,71,90,97,106,112,126,135,137,147,171,200,201,212,213,214,219,220,229,238,239,247,248],[2,358],{218:108,222:109,211:149,217:150,242:$Vd1,243:$Ve1,246:$Vf1}),o([1,6,10,11,14,22,71,90,97,106,112,126,135,137,147,171,200,201,212,213,214,219,220,229,238,239],[2,359],{218:108,222:109,211:149,217:150,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o([1,6,10,11,14,22,71,90,97,106,112,135,137,147,171,200,201,212,213,214,219,220,229,238,239],[2,360],{218:108,222:109,211:149,217:150,126:$V91,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o([1,6,10,11,14,22,71,90,97,106,112,126,135,137,147,171,200,201,212,213,214,219,220,229,238,239,248],[2,361],{218:108,222:109,211:149,217:150,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1}),o($Vs2,[2,345],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),{126:$V91,135:[1,412],171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($Vs2,[2,344],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($Vu1,[2,261]),o($VD1,[2,215]),o($VD1,[2,216]),o($VD1,[2,221]),o($VD1,[2,217]),o($VD1,[2,220]),o($VD1,[2,222]),o($VD1,[2,218]),o($VD1,[2,219]),{112:[1,413]},{112:[2,241],126:$V91,171:$Va1,199:414,200:$VW1,201:$VX1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},{112:[2,242]},{13:415,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vt2,[2,271]),o($Vt2,[2,272]),{22:[1,416],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},{22:[1,417],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($VY1,[2,136],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),{13:418,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($VY1,[2,362],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),{13:419,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:420,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vu2,[2,342]),{5:421,10:$V1,126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($Vj1,[2,291],{206:422,207:$VZ1}),o($Vj1,[2,292]),{209:[1,423]},{5:424,10:$V1},{231:425,233:343,234:$V_1},{11:[1,426],232:[1,427],233:428,234:$V_1},o($Vv2,[2,335]),{13:430,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,203:429,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vj1,[2,254]),o($Vj1,[2,260]),{6:$V72,14:[1,432],106:[1,431],115:433},{51:[1,435],62:[1,434],89:[1,436]},{13:437,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{89:[1,438]},{51:[1,439],89:[1,440]},o($VA1,[2,110]),o($V02,[2,113]),o($V02,[2,116],{117:[1,441]}),{90:[1,442],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($Vj1,[2,157]),{89:$Vw1,150:443},{90:[1,444],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($Vu1,[2,265]),o([6,10,22],$V72,{115:445,14:$V82}),o($V92,$V52,{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),{29:446,32:$VC1},{31:447,33:218,50:220,51:$V8,57:219,58:$Vc},{31:448,33:218,50:220,51:$V8,57:219,58:$Vc},o($Vu1,[2,297]),{6:$V51,9:133,11:[1,449]},{13:450,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{6:$V51,9:452,10:$Vw2,97:[1,451]},o([6,10,11,22,97],$Vx2,{34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,17:30,18:31,25:36,131:38,178:39,72:40,186:41,187:42,166:44,129:45,101:46,189:47,140:48,141:49,142:50,176:57,235:58,211:60,215:61,217:62,192:64,121:70,148:72,168:76,150:77,63:79,82:92,155:93,57:97,52:98,55:99,59:100,109:101,173:102,50:103,218:108,222:109,61:116,65:117,16:155,12:228,15:230,13:361,202:454,19:$V2,20:$V3,23:$V4,24:$V5,26:$V6,32:$V7,51:$V8,53:$V9,54:$Va,56:$Vb,58:$Vc,60:$Vd,62:$Ve,64:$Vf,66:$Vg,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,83:$Vp,89:$Vq,91:$Vr,96:$Vs,103:$Vt,122:$Vu,123:$Vv,124:$Vw,130:$Vx,136:$Vy,138:$Vz,139:$VA,143:$VB,144:$VC,151:$VD,152:$VE,154:$VF,156:$VG,157:$VH,158:$VI,170:$VJ,171:$VG1,175:$VK,184:$VL,185:$VM,188:$VN,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,212:$VU,214:$VV,216:$VW,219:$VX,220:$VY,230:$VZ,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41}),o($Vy2,$V72,{115:455,14:$V82}),{13:456,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:457,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{97:[1,458],98:[1,459]},{14:$Vz2,147:[1,460]},o($VA2,[2,187]),o($VA2,[2,189]),o($VA2,[2,190]),o($VA2,[2,191],{117:[1,462]}),{50:382,51:$V8,169:463},{50:382,51:$V8,169:464},{50:382,51:$V8,169:465},o([14,22,117,147],[2,196]),{14:$Vz2,147:[1,466]},{6:$V51,9:468,10:$VB2,90:[1,467]},o([6,10,11,90],$Vx2,{61:116,65:117,134:250,15:251,50:252,57:253,63:254,52:255,55:256,133:470,32:$V7,51:$V8,53:$V9,54:$Va,56:$Vb,58:$Vc,62:$Ve,64:$Vf,66:$Vg,136:$VJ1,138:$Vz,139:$VA}),{10:[1,472],13:471,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{126:$V91,137:[1,473],171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($Vu2,[2,339]),{13:474,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:475,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vk2,[2,318]),{50:268,51:$V8,89:$Vw1,96:$VR1,150:270,168:269,226:476},o([1,6,10,11,14,22,71,90,97,106,112,135,137,147,200,201,212,214,219,220,238],[2,324],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,213:[1,477],229:[1,478],239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($VC2,[2,325],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,213:[1,479],239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($Vj1,[2,256]),{13:480,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vj1,[2,127]),{110:$VL1,125:481,128:$VM1},o($VT1,[2,65]),{71:[1,482],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},{50:287,51:$V8,57:288,58:$Vc,89:$VP1,161:483},o($VD2,[2,172]),o($VD2,[2,173]),o($VE2,$Vb2,{167:375,150:376,168:377,169:378,50:382,146:484,51:$V8,89:$Vw1,96:$VR1,170:$Vc2,171:$Vd2,172:$Ve2}),o($Vj1,[2,171]),{5:485,10:$V1,89:$Vm1,141:486,144:$VC},o($Vj1,[2,179]),{90:[1,487],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($VD1,[2,198]),o($VD1,[2,201]),o($VU1,[2,11]),{13:488,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($VD1,[2,223]),{13:489,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,112:[2,275],121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{112:[2,276],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($Vt1,[2,22]),o($Vt1,[2,24]),{6:$V51,9:491,11:$VF2,126:$V91,132:490,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},{6:$V51,9:491,11:$VF2,126:$V91,132:493,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},{5:494,10:$V1,126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($Vu2,[2,341]),o($Vj1,[2,293]),{5:495,10:$V1},o($Vj1,[2,294]),{11:[1,496],232:[1,497],233:428,234:$V_1},o($Vj1,[2,333]),{5:498,10:$V1},o($Vv2,[2,336]),{5:499,10:$V1,14:[1,500]},o($VG2,[2,288],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($V$1,[2,96],{107:501,10:[1,502],21:[1,503]}),{6:$Vx2,114:504,116:$V12},{6:[1,505]},o($VA1,[2,104]),o($VA1,[2,106]),{13:506,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{112:[1,507],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},{13:508,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($VA1,[2,109]),{13:509,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:511,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,118:510,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{106:[1,512]},{22:[1,513]},o($V22,[2,163]),{6:$V51,9:452,10:$Vw2,22:[1,514]},o($Vt1,[2,27]),o($V32,[2,32]),o($Vt1,[2,28]),{137:[1,515]},{97:[1,516],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($V62,[2,270]),{12:228,13:361,15:230,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,171:$VG1,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,202:517,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{10:$VE1,12:228,13:361,15:230,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,119:518,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,171:$VG1,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,202:226,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($V92,[2,278]),{6:$V51,9:520,10:$Vw2,11:$VF2,132:519},{90:[1,521],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},{90:[1,522],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($VO1,[2,89]),{32:$V7,51:[1,524],61:116,62:$Ve,63:525,64:$Vf,65:117,66:$Vg,89:[1,526],99:523},{5:527,10:$V1},{50:382,51:$V8,89:$Vw1,96:$VR1,150:376,167:528,168:377,169:378,170:$Vc2,171:$Vd2,172:$Ve2},{13:529,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($VA2,[2,192]),o($VA2,[2,193]),o($VA2,[2,194]),{5:530,10:$V1},o([1,6,10,11,14,21,22,71,88,89,90,97,106,111,112,117,126,135,137,144,147,171,180,181,183,196,200,201,212,213,214,219,220,227,228,229,238,239,242,243,246,247,248],[2,243]),{15:251,32:$V7,50:252,51:$V8,52:255,53:$V9,54:$Va,55:256,56:$Vb,57:253,58:$Vc,61:116,62:$Ve,63:254,64:$Vf,65:117,66:$Vg,133:531,134:250,136:$VJ1,138:$Vz,139:$VA},o([6,10,11,14],$VI1,{61:116,65:117,133:249,134:250,15:251,50:252,57:253,63:254,52:255,55:256,191:532,32:$V7,51:$V8,53:$V9,54:$Va,56:$Vb,58:$Vc,62:$Ve,64:$Vf,66:$Vg,136:$VJ1,138:$Vz,139:$VA}),o($Vg2,[2,246]),o($Vg2,[2,139],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),{13:533,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vh2,[2,147]),o($Vj2,[2,300],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($Vj2,[2,302],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($Vk2,[2,323]),{13:534,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:535,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:536,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o([1,6,11,14,22,71,90,97,106,112,135,137,147,200,201,213,220,229,238],[2,257],{218:108,222:109,211:149,217:150,5:537,10:$V1,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($V$1,[2,128],{5:538,10:$V1}),o($VT1,[2,66]),{21:[1,539],162:540,164:$Vo2,165:$Vp2},{14:$Vz2,22:[1,541]},o($Vj1,[2,177]),o($Vj1,[2,178]),o($Vq2,[2,176]),o([1,6,10,11,14,22,71,90,97,106,112,135,137,147,200,201,212,213,214,219,220,229,238,239],[2,346],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),{112:[2,274],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($Vj1,[2,137]),{11:$VH2},o($Vj1,[2,283]),o($Vj1,[2,363]),o($Vu2,[2,340]),o([1,6,10,11,14,22,71,90,97,106,112,126,135,137,147,171,200,201,207,212,213,214,219,220,229,238,239,242,243,246,247,248],[2,295]),o($Vj1,[2,331]),{5:543,10:$V1},{11:[1,544]},o($Vv2,[2,337],{6:[1,545]}),{13:546,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vj1,[2,97]),{10:$VE1,12:228,13:361,15:230,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,119:547,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,171:$VG1,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,202:226,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{10:$VE1,12:228,13:361,15:230,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,119:548,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,171:$VG1,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,202:226,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($V02,[2,114]),{114:549,116:$V12},{90:[1,550],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($VA1,[2,105]),{90:[1,551],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},{90:[1,552],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($V02,[2,117]),o($V02,[2,118],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($Vj1,[2,98]),o($Vj1,[2,158]),o($Vu1,[2,266]),o($Vu1,[2,298]),o($Vu1,[2,273]),o($V92,[2,279]),o($Vy2,$V72,{115:553,14:$V82}),o($V92,[2,280]),{11:$VH2,12:228,13:361,15:230,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,138:$Vz,139:$VA,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,170:$VJ,171:$VG1,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,202:517,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($VO1,[2,83]),o($VO1,[2,84]),{97:[1,554]},{97:[2,93]},{97:[2,94]},{13:555,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},o($Vu1,[2,155]),o($VA2,[2,188]),o($VA2,[2,195],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),{90:[1,556]},o($Vg2,[2,247]),o($Vy2,$V72,{115:557,14:$Vf2}),{6:$V51,9:491,11:$VF2,126:$V91,132:558,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o([1,6,10,11,14,22,71,90,97,106,112,135,137,147,200,201,212,213,214,219,220,238],[2,326],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,229:[1,559],239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($VC2,[2,328],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,213:[1,560],239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($VY1,[2,327],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($Vj1,[2,258]),o($Vj1,[2,129]),o($VE2,$Vb2,{167:375,150:376,168:377,169:378,50:382,146:561,51:$V8,89:$Vw1,96:$VR1,170:$Vc2,171:$Vd2,172:$Ve2}),o($Vj1,[2,169]),{162:562,164:$Vo2,165:$Vp2},o($Vj1,[2,282]),{6:$V51,9:491,11:$VF2,132:563},o($Vj1,[2,334]),o($Vv2,[2,338]),o($VG2,[2,289],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,212:$VU,214:$VV,219:$VX,220:$VY,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($VI2,$V72,{115:565,11:[1,564],14:$V82}),o($VI2,$V72,{115:565,14:$V82,22:[1,566]}),o($V02,[2,115]),o($VA1,[2,107]),o($VA1,[2,108]),o($VA1,[2,111]),{6:$V51,9:520,10:$Vw2,11:$VF2,132:567},o($VO1,[2,90]),{90:[1,568],126:$V91,171:$Va1,211:149,212:$VU,214:$VV,217:150,218:108,219:$VX,220:$VY,222:109,238:$Vb1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1},o($Vu1,[2,156]),{6:$V51,9:570,10:$VB2,11:$VF2,132:569},o($Vg2,[2,140]),{13:571,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{13:572,16:155,17:30,18:31,19:$V2,20:$V3,23:$V4,24:$V5,25:36,26:$V6,32:$V7,34:12,35:13,36:14,37:15,38:16,39:17,40:18,41:19,42:20,43:21,44:22,45:23,46:24,47:25,48:26,49:27,50:103,51:$V8,52:98,53:$V9,54:$Va,55:99,56:$Vb,57:97,58:$Vc,59:100,60:$Vd,61:116,62:$Ve,63:79,64:$Vf,65:117,66:$Vg,72:40,73:$Vh,74:$Vi,75:$Vj,76:$Vk,77:$Vl,78:$Vm,79:$Vn,80:$Vo,82:92,83:$Vp,89:$Vq,91:$Vr,96:$Vs,101:46,103:$Vt,109:101,121:70,122:$Vu,123:$Vv,124:$Vw,129:45,130:$Vx,131:38,136:$Vy,140:48,141:49,142:50,143:$VB,144:$VC,148:72,150:77,151:$VD,152:$VE,154:$VF,155:93,156:$VG,157:$VH,158:$VI,166:44,168:76,173:102,175:$VK,176:57,178:39,184:$VL,185:$VM,186:41,187:42,188:$VN,189:47,192:64,193:$VO,194:$VP,197:$VQ,198:$VR,204:$VS,210:$VT,211:60,212:$VU,214:$VV,215:61,216:$VW,217:62,218:108,219:$VX,220:$VY,222:109,230:$VZ,235:58,236:$V_,240:$V$,241:$V01,242:$V11,243:$V21,244:$V31,245:$V41},{14:$Vz2,22:[1,573]},o($Vj1,[2,170]),o($Vj1,[2,332]),o($Vj1,[2,119]),{6:$V51,9:452,10:$Vw2},o($Vj1,[2,120]),o($V92,[2,281]),{97:[2,95]},o($Vg2,[2,248]),{11:$VH2,15:251,32:$V7,50:252,51:$V8,52:255,53:$V9,54:$Va,55:256,56:$Vb,57:253,58:$Vc,61:116,62:$Ve,63:254,64:$Vf,65:117,66:$Vg,133:531,134:250,136:$VJ1,138:$Vz,139:$VA},o($VY1,[2,329],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),o($VY1,[2,330],{218:108,222:109,211:149,217:150,126:$V91,171:$Va1,239:$Vc1,242:$Vd1,243:$Ve1,246:$Vf1,247:$Vg1,248:$Vh1}),{162:574,164:$Vo2,165:$Vp2},o($Vj1,[2,168])],
	defaultActions: {135:[2,3],163:[2,264],324:[2,242],524:[2,93],525:[2,94],568:[2,95]},
	parseError: function parseError(str, hash) {
	    if (hash.recoverable) {
	        this.trace(str);
	    } else {
	        throw new Error(str);
	    }
	},
	parse: function parse(input) {
	
	    // For Imba we are going to drop most of the features that are not used
	    // Locations are provided by the tokens from the lexer directly - so drop yylloc
	    // We dont really need the shared state (it seems)
	
	    var self = this,
	        stack = [0],
	        tstack = [], // token stack
	        vstack = [null], // semantic value stack
	        table = this.table,
	        yytext = '',
	        yylineno = 0,
	        yyleng = 0,
	        recovering = 0,
	        TERROR = 2,
	        EOF = 1;
	
	    // var args = lstack.slice.call(arguments, 1);
	    //this.reductionCount = this.shiftCount = 0;
	
	    var lexer = Object.create(this.lexer);
	    var yy = this.yy;
	
	    lexer.setInput(input,yy);
	
	    if (typeof yy.parseError === 'function') {
	        this.parseError = yy.parseError;
	    } else {
	        this.parseError = Object.getPrototypeOf(this).parseError; // what?
	    }
	
	    function popStack (n) {
	        stack.length = stack.length - 2 * n;
	        vstack.length = vstack.length - n;
	    }
	
	    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
	
	    function handleError(){
	        var error_rule_depth;
	        var errStr = '';
	
	        // Return the rule stack depth where the nearest error rule can be found.
	        // Return FALSE when no error recovery rule was found.
	        // we have no rules now
	        function locateNearestErrorRecoveryRule(state) {
	            var stack_probe = stack.length - 1;
	            var depth = 0;
	
	            // try to recover from error
	            for(;;) {
	                // check for error recovery rule in this state
	                if ((TERROR.toString()) in table[state]) {
	                    return depth;
	                }
	                if (state === 0 || stack_probe < 2) {
	                    return false; // No suitable error recovery rule available.
	                }
	                stack_probe -= 2; // popStack(1): [symbol, action]
	                state = stack[stack_probe];
	                ++depth;
	            }
	        }
	
	        if (!recovering) {
	            // first see if there's any chance at hitting an error recovery rule:
	            error_rule_depth = locateNearestErrorRecoveryRule(state);
	
	            // Report error
	            expected = [];
	
	            var tsym = lexer.yytext;
	            var tok = self.terminals_[symbol] || symbol;
	            var tloc = tsym ? tsym._loc : -1;
	            var tpos = tloc != -1 ? "[" + tsym._loc + ":" + tsym._len + "]" : '[0:0]';
	
	            if (lexer.showPosition) {
	                errStr = 'Parse error at '+(tpos)+":\n"+lexer.showPosition()+"\nExpecting "+expected.join(', ') + ", got '" + (self.terminals_[symbol] || symbol)+ "'";
	            } else {
	                errStr = 'Parse error at '+(tpos)+": Unexpected " + (symbol == EOF ? "end of input" : ("'"+(tok)+"'"));
	            }
	
	            self.parseError(errStr, {
	                lexer: lexer,
	                text: lexer.match,
	                token: tok,
	                line: lexer.yylineno,
	                expected: expected,
	                recoverable: (error_rule_depth !== false)
	            });
	        } else if (preErrorSymbol !== EOF) {
	            error_rule_depth = locateNearestErrorRecoveryRule(state);
	        }
	
	        // just recovered from another error
	        if (recovering == 3) {
	            if (symbol === EOF || preErrorSymbol === EOF) {
	                throw new Error(errStr || 'Parsing halted while starting to recover from another error.');
	            }
	
	            // discard current lookahead and grab another
	            yytext = lexer.yytext;
	        }
	
	        // try to recover from error
	        if (error_rule_depth === false) {
	            throw new Error(errStr || 'Parsing halted. No suitable error recovery rule available.');
	        }
	        popStack(error_rule_depth);
	        preErrorSymbol = (symbol == TERROR ? null : symbol); // save the lookahead token
	        symbol = TERROR;         // insert generic error symbol as new lookahead
	        state = stack[stack.length-1];
	        action = table[state] && table[state][TERROR];
	        recovering = 3; // allow 3 real symbols to be shifted before reporting a new error
	    }
	
	
	    var __sym = this.symbols_;
	    var __prod = this.productions_;
	
	    while (true) {
	        // retreive state number from top of stack
	        state = stack[stack.length - 1];
	
	        if (symbol === null || typeof symbol == 'undefined') {
	            symbol = __sym[lexer.lex()] || EOF;
	        }
	        action = table[state] && table[state][symbol];
	
	_handle_error:
	        if (typeof action === 'undefined' || !action.length || !action[0]) {
	            handleError();
	        }
	
	        switch (action[0]) {
	            case 1: // shift
	                stack.push(symbol);
	                stack.push(action[1]); // push state
	                vstack.push(lexer.yytext);
	                
	                symbol = null;
	                if (!preErrorSymbol) { // normal execution/no error
	                    yytext = lexer.yytext;
	                    if (recovering > 0) {
	                        recovering--;
	                    }
	                } else {
	                    // error just occurred, resume old lookahead f/ before error
	                    symbol = preErrorSymbol;
	                    preErrorSymbol = null;
	                }
	                break;
	
	            case 2:
	                len = __prod[action[1]][1];
	                // perform semantic action
	                yyval.$ = vstack[vstack.length-len];
	                r = this.performAction(yyval, yytext, yy, action[1], vstack);
	                if (typeof r !== 'undefined') {
	                    return r;
	                }
	
	                while(len > 0) {
	                    stack.pop();
	                    stack.pop();
	                    vstack.pop();
	                    len--;
	                }
	
	                stack.push(__prod[action[1]][0]);
	                newState = table[stack[stack.length-2]][stack[stack.length-1]];
	                stack.push(newState);
	                vstack.push(yyval.$);
	                break;
	
	            case 3:
	                return true;
	        }
	    }
	
	    return true;
	}};
	
	function Parser () {
	  this.yy = {};
	}
	Parser.prototype = parser;parser.Parser = Parser;
	return new Parser;
	})();
	
	
	if (true) {
	exports.parser = parser;
	exports.Parser = parser.Parser;
	exports.parse = function () { return parser.parse.apply(parser, arguments); };
	// exports.main = function commonjsMain(args) {
	//     if (!args[1]) {
	//         console.log('Usage: '+args[0]+' FILE');
	//         process.exit(1);
	//     }
	//     var source = require('fs').readFileSync(require('path').normalize(args[1]), "utf8");
	//     return exports.parser.parse(source);
	// };
	if (typeof module !== 'undefined' && __webpack_require__.c[0] === module) {
	  exports.main(process.argv.slice(1));
	}
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)(module), __webpack_require__(7)))

/***/ },
/* 6 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 7 */
/***/ function(module, exports) {

	// shim for using process in browser
	
	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function idx$(a,b){
			return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
		};
		
		// helper for subclassing
		function subclass$(obj,sup) {
			for (var k in sup) {
				if (sup.hasOwnProperty(k)) obj[k] = sup[k];
			};
			// obj.__super__ = sup;
			obj.prototype = Object.create(sup.prototype);
			obj.__super__ = obj.prototype.__super__ = sup.prototype;
			obj.prototype.initialize = obj.prototype.constructor = obj;
		};
		
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		var AST, OP, OP_COMPOUND, NODES, SPLAT, STACK, K_IVAR, K_SYM, K_STR, K_PROP, BR, BR2, SELF, SUPER, TRUE, FALSE, UNDEFINED, NIL, ARGUMENTS, EMPTY, NULL, RESERVED, RESERVED_REGEX, UNION, INTERSECT, CLASSDEF, TAGDEF, NEWTAG;
		// TODO Create Expression - make all expressions inherit from these?
		
		// externs;
		
		var helpers = __webpack_require__(9);
		var ERR = __webpack_require__(1);
		var v8 = null; // require 'v8-natives'
		
		var T = __webpack_require__(3);
		var Token = T.Token;
		
		var SourceMap = __webpack_require__(10).SourceMap;
		
		module.exports.AST = AST = {};
		
		// Helpers for operators
		module.exports.OP = OP = function(op,l,r) {
			var o = String(op);
			// console.log "operator",o
			switch (o) {
				case '.':
					if ((typeof r=='string'||r instanceof String)) { r = new Identifier(r) };
					// r = r.value if r isa VarOrAccess
					return new Access(op,l,r);
					break;
				
				case '=':
					if (l instanceof Tuple) { return new TupleAssign(op,l,r) };
					return new Assign(op,l,r);
					break;
				
				case '?=':
				case '||=':
				case '&&=':
					return new ConditionalAssign(op,l,r);
					break;
				
				case '+=':
				case '-=':
				case '*=':
				case '/=':
				case '^=':
				case '%=':
					return new CompoundAssign(op,l,r);
					break;
				
				case '?.':
					if (r instanceof VarOrAccess) {
						// console.log "is var or access"
						r = r.value();
					};
					// depends on the right side - this is wrong
					return new PropertyAccess(op,l,r);
					break;
				
				case 'instanceof':
					return new InstanceOf(op,l,r);
					break;
				
				case 'in':
					return new In(op,l,r);
					break;
				
				case 'typeof':
					return new TypeOf(op,l,r);
					break;
				
				case 'delete':
					return new Delete(op,l,r);
					break;
				
				case '--':
				case '++':
				case '!':
				case '√':
					return new UnaryOp(op,l,r);
					break;
				
				case '>':
				case '<':
				case '>=':
				case '<=':
				case '==':
				case '===':
				case '!=':
				case '!==':
					return new ComparisonOp(op,l,r);
					break;
				
				case '∩':
				case '∪':
					return new MathOp(op,l,r);
					break;
				
				case '..':
				case '...':
					return new Range(op,l,r);
					break;
				
				default:
				
					return new Op(op,l,r);
			
			};
		};
		
		module.exports.OP_COMPOUND = OP_COMPOUND = function(sym,op,l,r) {
			// console.log "?. soak operator",sym
			if (sym == '?.') {
				console.log("?. soak operator");
				return null;
			};
			if (sym == '?=' || sym == '||=' || sym == '&&=') {
				return new ConditionalAssign(op,l,r);
			} else {
				return new CompoundAssign(op,l,r);
			};
		};
		
		var OPTS = {};
		var ROOT = null;
		
		module.exports.NODES = NODES = [];
		
		var LIT = function(val) {
			return new Literal(val);
		};
		
		var SYM = function(val) {
			return new Symbol(val);
		};
		
		var IF = function(cond,body,alt) {
			var node = new If(cond,body);
			if (alt) { node.addElse(alt) };
			return node;
		};
		
		var FN = function(pars,body) {
			return new Func(pars,body);
		};
		
		var CALL = function(callee,pars) {
			// possibly return instead(!)
			if(pars === undefined) pars = [];
			return new Call(callee,pars);
		};
		
		var CALLSELF = function(name,pars) {
			if(pars === undefined) pars = [];
			var ref = new Identifier(name);
			return new Call(OP('.',SELF,ref),pars);
		};
		
		var BLOCK = function() {
			return Block.wrap([].slice.call(arguments));
		};
		
		var WHILE = function(test,code) {
			return new While(test).addBody(code);
		};
		
		module.exports.SPLAT = SPLAT = function(value) {
			if (value instanceof Assign) {
				// p "WARN"
				value.setLeft(new Splat(value.left()));
				return value;
			} else {
				return new Splat(value);
				// not sure about this
			};
		};
		
		// OP.ASSIGNMENT = [ "=" , "+=" , "-=" , "*=" , "/=" , "%=", "<<=" , ">>=" , ">>>=", "|=" , "^=" , "&=" ]
		// OP.LOGICAL = [ "||" , "&&" ]
		// OP.UNARY = [ "++" , "--" ]
		
		var SEMICOLON_TEST = /;(\s*\/\/.*)?[\n\s\t]*$/;
		var RESERVED_TEST = /^(default|char)$/;
		
		// captures error from parser
		function parseError(str,o){
			// console.log 'parseError',o:token
			
			// find nearest token
			var err;
			
			if (o.lexer) {
				var token = o.lexer.yytext;
				// console.log o:lexer:pos,token.@loc
				err = new ERR.ImbaParseError({message: str},{
					pos: o.lexer.pos,
					tokens: o.lexer.tokens,
					token: o.lexer.yytext,
					meta: o
				});
				
				throw err;
				
				// should find the closest token with actual position
				// str = "[{token.@loc}:{token.@len || String(token):length}] {str}"
			};
			var e = new Error(str);
			e.lexer = o.lexer;
			e.options = o;
			throw e;
		}; exports.parseError = parseError;
		
		function c__(obj){
			return typeof obj == 'string' ? (obj) : (obj.c());
		};
		
		function mark__(tok){
			if (tok && (OPTS.sourceMapInline || OPTS.sourceMap) && tok.sourceMapMarker) {
				return tok.sourceMapMarker();
			} else {
				return '';
			};
		};
		
		function num__(num){
			return new Num(num);
		};
		
		function str__(str){
			// should pack in token?!?
			return new Str(str);
		};
		
		function blk__(obj){
			return obj instanceof Array ? (Block.wrap(obj)) : (obj);
		};
		
		function sym__(obj){
			// console.log "sym {obj}"
			return helpers.symbolize(String(obj));
		};
		
		function cary__(ary){
			return ary.map(function(v) { return typeof v == 'string' ? (v) : (v.c()); });
		};
		
		function dump__(obj,key){
			if (obj instanceof Array) {
				return obj.map(function(v) { return v && v.dump ? (v.dump(key)) : (v); });
			} else if (obj && obj.dump) {
				return obj.dump();
			};
		};
		
		function compact__(ary){
			if (ary instanceof ListNode) {
				return ary.compact();
			};
			
			return ary.filter(function(v) { return v != undefined && v != null; });
		};
		
		function reduce__(res,ary){
			for (var i = 0, items = iter$(ary), len = items.length, v; i < len; i++) {
				v = items[i];
				v instanceof Array ? (reduce__(res,v)) : (res.push(v));
			};
			return;
		};
		
		function flatten__(ary,compact){
			if(compact === undefined) compact = false;
			var out = [];
			for (var i = 0, items = iter$(ary), len = items.length, v; i < len; i++) {
				v = items[i];
				v instanceof Array ? (reduce__(out,v)) : (out.push(v));
			};
			return out;
		};
		
		AST.parse = function (str,opts){
			if(opts === undefined) opts = {};
			var indent = str.match(/\t+/)[0];
			// really? Require the compiler, not this
			return Imbac.parse(str,opts);
		};
		
		AST.inline = function (str,opts){
			if(opts === undefined) opts = {};
			return this.parse(str,opts).body();
		};
		
		AST.node = function (typ,pars){
			if (typ == 'call') {
				if (pars[0].c() == 'return') {
					pars[0] = 'tata';
				};
				return new Call(pars[0],pars[1],pars[2]);
			};
		};
		
		
		AST.escapeComments = function (str){
			if (!str) { return '' };
			return str;
		};
		
		function Indentation(a,b){
			this._open = a;
			this._close = b;
			this;
		};
		
		exports.Indentation = Indentation; // export class 
		Indentation.prototype.open = function(v){ return this._open; }
		Indentation.prototype.setOpen = function(v){ this._open = v; return this; };
		Indentation.prototype.close = function(v){ return this._close; }
		Indentation.prototype.setClose = function(v){ this._close = v; return this; };
		
		Indentation.prototype.isGenerated = function (){
			return this._open && this._open.generated;
		};
		
		Indentation.prototype.aloc = function (){
			return this._open && this._open._loc || 0;
		};
		
		Indentation.prototype.bloc = function (){
			return this._close && this._close._loc || 0;
		};
		
		// should rather parse and extract the comments, no?
		Indentation.prototype.wrap = function (str){
			// var pre, post
			
			// console.log "INDENT {@open and JSON.stringify(@open.@meta)}"
			// console.log "OUTDENT {@close}"
			// var ov = @open and @open.@value
			// if ov and ov:length > 1
			// 	console.log "value for indent",ov
			// 	if ov.indexOf('%|%')
			// 		pre = ov.substr
			var om = this._open && this._open._meta;
			var pre = om && om.pre || '';
			var post = om && om.post || '';
			var esc = AST.escapeComments;
			var out = this._close;
			
			// the first newline should not be indented?
			str = post.replace(/^\n/,'') + str;
			str = str.replace(/^/g,"\t").replace(/\n/g,"\n\t").replace(/\n\t$/g,"\n");
			
			str = pre + '\n' + str;
			if (out instanceof Terminator) { str += out.c() };
			if (str[str.length - 1] != '\n') { str = str + '\n' };
			return str;
		};
		
		var INDENT = new Indentation({},{});
		
		function Stash(){
			this._entities = [];
		};
		
		Stash.prototype.add = function (item){
			this._entities.unshift(item);
			return this;
		};
		
		Stash.prototype.pluck = function (item){
			var match = null;
			for (var i = 0, ary = iter$(this._entities), len = ary.length, entity; i < len; i++) {
				entity = ary[i];
				if (entity == item || (entity instanceof item)) {
					match = entity;
					this._entities.splice(i,1);
					return match;
				};
			};
			return null;
		};
		
		
		function Stack(){
			this.reset();
		};
		
		exports.Stack = Stack; // export class 
		Stack.prototype.loglevel = function(v){ return this._loglevel; }
		Stack.prototype.setLoglevel = function(v){ this._loglevel = v; return this; };
		Stack.prototype.nodes = function(v){ return this._nodes; }
		Stack.prototype.setNodes = function(v){ this._nodes = v; return this; };
		Stack.prototype.scopes = function(v){ return this._scopes; }
		Stack.prototype.setScopes = function(v){ this._scopes = v; return this; };
		
		Stack.prototype.reset = function (){
			this._nodes = [];
			this._scoping = [];
			this._scopes = []; // for analysis - should rename
			this._stash = new Stash(this);
			this._loglevel = 3;
			this._counter = 0;
			this._counters = {};
			return this;
		};
		
		Stack.prototype.incr = function (name){
			var $1;
			this._counters[($1 = name)] || (this._counters[$1] = 0);
			return this._counters[name] += 1;
		};
		
		Stack.prototype.stash = function (){
			return this._stash;
		};
		
		Stack.prototype.option = function (key){
			return this._options && this._options[key];
		};
		
		Stack.prototype.addScope = function (scope){
			this._scopes.push(scope);
			return this;
		};
		
		Stack.prototype.traverse = function (node){
			return this;
		};
		
		Stack.prototype.push = function (node){
			this._nodes.push(node);
			// not sure if we have already defined a scope?
			return this;
		};
		
		Stack.prototype.pop = function (node){
			this._nodes.pop(); // (node)
			return this;
		};
		
		Stack.prototype.parent = function (){
			return this._nodes[this._nodes.length - 2];
		};
		
		Stack.prototype.current = function (){
			return this._nodes[this._nodes.length - 1];
		};
		
		Stack.prototype.up = function (test){
			test || (test = function(v) { return !(v instanceof VarOrAccess); });
			
			if (test.prototype instanceof Node) {
				var typ = test;
				test = function(v) { return v instanceof typ; };
			};
			
			var i = this._nodes.length - 2; // key
			while (i >= 0){
				var node = this._nodes[i];
				if (test(node)) { return node };
				i -= 1;
			};
			return null;
		};
		
		Stack.prototype.relative = function (node,offset){
			if(offset === undefined) offset = 0;
			var idx = this._nodes.indexOf(node);
			return idx >= 0 ? (this._nodes[idx + offset]) : (null);
		};
		
		Stack.prototype.scope = function (lvl){
			if(lvl === undefined) lvl = 0;
			var i = this._nodes.length - 1 - lvl;
			while (i >= 0){
				var node = this._nodes[i];
				if (node._scope) { return node._scope };
				i -= 1;
			};
			return null;
		};
		
		Stack.prototype.scopes = function (){
			// include deeper scopes as well?
			var scopes = [];
			var i = this._nodes.length - 1;
			while (i >= 0){
				var node = this._nodes[i];
				if (node._scope) { scopes.push(node._scope) };
				i -= 1;
			};
			return scopes;
		};
		
		Stack.prototype.method = function (){
			return this.up(MethodDeclaration);
		};
		
		Stack.prototype.block = function (){
			return this.up(Block);
		};
		
		Stack.prototype.isExpression = function (){
			var i = this._nodes.length - 1;
			while (i >= 0){
				var node = this._nodes[i];
				// why are we not using isExpression here as well?
				if ((node instanceof Code) || (node instanceof Loop)) {
					return false;
				};
				if (node.isExpression()) {
					return true;
				};
				// probably not the right test - need to be more explicit
				i -= 1;
			};
			return false;
		};
		
		Stack.prototype.toString = function (){
			return ("Stack(" + this._nodes.join(" -> ") + ")");
		};
		
		Stack.prototype.scoping = function (){
			return this._nodes.filter(function(n) { return n._scope; }).map(function(n) { return n._scope; });
		};
		
		// Lots of globals -- really need to deal with one stack per file / context
		module.exports.STACK = STACK = new Stack();
		
		GLOBSTACK = STACK;
		
		// use a bitmask for these
		
		function Node(){
			this.setup();
			this;
		};
		
		exports.Node = Node; // export class 
		Node.prototype.o = function(v){ return this._o; }
		Node.prototype.setO = function(v){ this._o = v; return this; };
		Node.prototype.options = function(v){ return this._options; }
		Node.prototype.setOptions = function(v){ this._options = v; return this; };
		Node.prototype.traversed = function(v){ return this._traversed; }
		Node.prototype.setTraversed = function(v){ this._traversed = v; return this; };
		
		Node.prototype.safechain = function (){
			return false;
		};
		
		// def dom
		// 	var name = "ast_" + self:constructor:name.replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase
		// 	# p "try to get the dom-node for this ast-node",name
		// 	if Imba.TAGS[name]
		// 		var node = Imba.tag(name)
		// 		node.bind(self).build
		// 		return node
		// 	else
		// 		return "[{name}]"
		
		Node.prototype.p = function (){
			
			// allow controlling this from commandline
			if (STACK.loglevel() > 0) {
				console.log.apply(console,arguments);
			};
			return this;
		};
		
		Node.prototype.typeName = function (){
			return this.constructor.name;
		};
		
		Node.prototype.namepath = function (){
			return this.typeName();
		};
		
		Node.prototype.setup = function (){
			this._expression = false;
			this._traversed = false;
			this._parens = false;
			this._cache = null;
			this._value = null;
			return this;
		};
		
		Node.prototype.set = function (obj){
			// console.log "setting options {JSON.stringify(obj)}"
			this._options || (this._options = {});
			for (var i = 0, keys = Object.keys(obj), l = keys.length; i < l; i++){
				this._options[keys[i]] = obj[keys[i]];
			};
			return this;
		};
		
		// get and set
		Node.prototype.option = function (key,val){
			if (val != undefined) {
				// console.log "setting option {key} {val}"
				this._options || (this._options = {});
				this._options[key] = val;
				return this;
			};
			
			return this._options && this._options[key];
		};
		
		Node.prototype.configure = function (obj){
			return this.set(obj);
		};
		
		Node.prototype.region = function (){
			return [0,0];
		};
		
		Node.prototype.loc = function (){
			return [0,0];
		};
		
		Node.prototype.token = function (){
			return null;
		};
		
		Node.prototype.compile = function (){
			return this;
		};
		
		Node.prototype.visit = function (){
			return this;
		};
		
		Node.prototype.stack = function (){
			return STACK;
		};
		
		Node.prototype.isString = function (){
			return false;
		};
		
		Node.prototype.isPrimitive = function (deep){
			return false;
		};
		
		Node.prototype.isReserved = function (){
			return false;
		};
		
		// should rather do traversals
		// o = {}, up, key, index
		Node.prototype.traverse = function (){
			if (this._traversed) {
				return this;
			};
			// NODES.push(self)
			this._traversed = true;
			STACK.push(this);
			this.visit(STACK);
			STACK.pop(this);
			return this;
		};
		
		Node.prototype.inspect = function (){
			return {type: this.constructor.toString()};
		};
		
		Node.prototype.js = function (o){
			return "NODE";
		};
		
		Node.prototype.toString = function (){
			return ("" + (this.constructor.name));
		};
		
		// swallow might be better name
		Node.prototype.consume = function (node){
			if (node instanceof PushAssign) {
				return new PushAssign(node.op(),node.left(),this);
			};
			
			if (node instanceof Assign) {
				// p "consume assignment".cyan
				// node.right = self
				return OP(node.op(),node.left(),this);
			} else if (node instanceof Op) {
				return OP(node.op(),node.left(),this);
			} else if (node instanceof Return) {
				// p "consume return".cyan
				return new Return(this);
			};
			return this;
		};
		
		Node.prototype.toExpression = function (){
			this._expression = true;
			return this;
		};
		
		Node.prototype.forceExpression = function (){
			this._expression = true;
			return this;
		};
		
		Node.prototype.isExpressable = function (){
			return true;
		};
		
		Node.prototype.isExpression = function (){
			return this._expression || false;
		};
		
		Node.prototype.hasSideEffects = function (){
			return true;
		};
		
		Node.prototype.isUsed = function (){
			return true;
		};
		
		Node.prototype.shouldParenthesize = function (){
			return false;
		};
		
		Node.prototype.block = function (){
			return Block.wrap([this]);
		};
		
		Node.prototype.node = function (){
			return this;
		};
		
		Node.prototype.scope__ = function (){
			return STACK.scope();
		};
		
		Node.prototype.up = function (){
			return STACK.parent();
		};
		
		Node.prototype.util = function (){
			return Util;
		};
		
		Node.prototype.receiver = function (){
			return this;
		};
		
		Node.prototype.addExpression = function (expr){
			// might be better to nest this up after parsing is done?
			// p "addExpression {self} <- {expr}"
			var node = new ExpressionBlock([this]);
			return node.addExpression(expr);
		};
		
		
		Node.prototype.indented = function (a,b){
			
			if (a instanceof Indentation) {
				this._indentation = a;
				return this;
			};
			
			// this is a _BIG_ hack
			if (b instanceof Array) {
				this.add(b[0]);
				b = b[1];
			};
			
			// if indent and indent.match(/\:/)
			this._indentation || (this._indentation = a && b ? (new Indentation(a,b)) : (INDENT));
			return this;
		};
		
		Node.prototype.prebreak = function (term){
			// in options instead?
			// console.log "prebreak!!!!"
			// @prebreak = @prebreak or term
			if(term === undefined) term = '\n';
			return this;
		};
		
		Node.prototype.invert = function (){
			return OP('!',this);
		};
		
		Node.prototype.cache = function (o){
			if(o === undefined) o = {};
			this._cache = o;
			o.var = this.scope__().temporary(this,o);
			o.lookups = 0;
			return this;
		};
		
		Node.prototype.cachevar = function (){
			return this._cache && this._cache.var;
		};
		
		Node.prototype.decache = function (){
			if (this._cache) {
				this.cachevar().free();
				this._cache = null;
			};
			return this;
		};
		
		// is this without side-effects? hmm - what does it even do?
		Node.prototype.predeclare = function (){
			if (this._cache) {
				this.scope__().vars().swap(this._cache.var,this);
			};
			return this;
		};
		
		// the "name-suggestion" for nodes if they need to be cached
		Node.prototype.alias = function (){
			return null;
		};
		
		Node.prototype.warn = function (text,opts){
			if(opts === undefined) opts = {};
			opts.message = text;
			opts.loc || (opts.loc = this.loc());
			this.scope__().root().warn(opts);
			return this;
		};
		
		Node.prototype.c = function (o){
			var indent;
			var s = STACK;
			var ch = this._cache;
			if (ch && ch.cached) { return this.c_cached(ch) };
			
			s.push(this);
			if (o && o.expression) this.forceExpression();
			
			v8 && console.log(v8.hasFastObjectElements(this));
			
			if (o && o.indent) {
				this._indentation || (this._indentation = INDENT);
			};
			
			var out = this.js(s,o);
			
			// really? why not call this somewhere else?
			var paren = this.shouldParenthesize();
			
			if (indent = this._indentation) {
				out = indent.wrap(out,o);
			};
			
			// should move this somewhere else really
			if (paren) { out = ("(" + out + ")") };
			if (o && o.braces) {
				if (indent) {
					out = '{' + out + '}';
				} else {
					out = '{ ' + out + ' }';
				};
			};
			
			s.pop(this);
			
			if (ch = this._cache) {
				if (!ch.manual) { out = ("" + (ch.var.c()) + " = " + out) };
				var par = s.current();
				if ((par instanceof Access) || (par instanceof Op)) { out = '(' + out + ')' }; // others? # 
				ch.cached = true;
			};
			return out;
		};
		
		Node.prototype.c_cached = function (cache){
			cache.lookups++;
			if (cache.uses == cache.lookups) { cache.var.free() };
			return cache.var.c(); // recompile every time??
		};
		
		function ValueNode(value){
			this.setup();
			this._value = this.load(value);
		};
		
		subclass$(ValueNode,Node);
		exports.ValueNode = ValueNode; // export class 
		ValueNode.prototype.value = function(v){ return this._value; }
		ValueNode.prototype.setValue = function(v){ this._value = v; return this; };
		
		ValueNode.prototype.load = function (value){
			return value;
		};
		
		ValueNode.prototype.js = function (o){
			return typeof this._value == 'string' ? (this._value) : (this._value.c());
		};
		
		ValueNode.prototype.visit = function (){
			
			if (this._value instanceof Node) { this._value.traverse() }; //  && @value:traverse
			return this;
		};
		
		ValueNode.prototype.region = function (){
			return [this._value._loc,this._value._loc + this._value._len];
		};
		
		
		function Statement(){ return ValueNode.apply(this,arguments) };
		
		subclass$(Statement,ValueNode);
		exports.Statement = Statement; // export class 
		Statement.prototype.isExpressable = function (){
			return false;
		};
		
		
		function Meta(){ return ValueNode.apply(this,arguments) };
		
		subclass$(Meta,ValueNode);
		exports.Meta = Meta; // export class 
		Meta.prototype.isPrimitive = function (deep){
			return true;
		};
		
		function Comment(){ return Meta.apply(this,arguments) };
		
		subclass$(Comment,Meta);
		exports.Comment = Comment; // export class 
		Comment.prototype.visit = function (){
			// stack.stash.add(self)
			
			var block, next;
			if (block = this.up()) {
				var idx = block.indexOf(this) + 1;
				if (block.index(idx) instanceof Terminator) { idx += 1 };
				if (next = block.index(idx)) {
					next._desc = this;
				};
				
				// console.log "Next item after comment is {block.index(idx)}"
			};
			
			return this;
		};
		
		Comment.prototype.toDoc = function (){
			return helpers.normalizeIndentation("" + this._value._value);
		};
		
		Comment.prototype.toJSON = function (){
			return helpers.normalizeIndentation("" + this._value._value);
		};
		
		Comment.prototype.c = function (o){
			var v = this._value._value;
			// p @value.type
			if (o && o.expression || v.match(/\n/) || this._value.type() == 'HERECOMMENT') { // multiline?
				return ("/*" + v + "*/");
			} else {
				return ("// " + v);
			};
		};
		
		function Terminator(v){
			this._value = v;
			this;
		};
		
		subclass$(Terminator,Meta);
		exports.Terminator = Terminator; // export class 
		Terminator.prototype.traverse = function (){
			return this;
		};
		
		Terminator.prototype.c = function (){
			// TODO this can contain several newlines
			// for sourcemaps it would be nice to parse this
			// and fix it up mark__(@value) + 
			return this._value.c();
			// var v = value.replace(/\\n/g,'\n')
			// v # .split()
			// v.split("\n").map(|v| v ? " // {v}" : v).join("\n")
		};
		
		function Newline(v){
			this._traversed = false;
			this._value = v || '\n';
		};
		
		subclass$(Newline,Terminator);
		exports.Newline = Newline; // export class 
		Newline.prototype.c = function (){
			return c__(this._value);
		};
		
		
		// weird place?
		function Index(){ return ValueNode.apply(this,arguments) };
		
		subclass$(Index,ValueNode);
		exports.Index = Index; // export class 
		Index.prototype.js = function (o){
			return this._value.c();
		};
		
		function ListNode(list){
			this.setup();
			this._nodes = this.load(list || []);
			this._indentation = null;
		};
		
		// PERF acces @nodes directly?
		subclass$(ListNode,Node);
		exports.ListNode = ListNode; // export class 
		ListNode.prototype.nodes = function(v){ return this._nodes; }
		ListNode.prototype.setNodes = function(v){ this._nodes = v; return this; };
		
		ListNode.prototype.list = function (){
			return this._nodes;
		};
		
		ListNode.prototype.compact = function (){
			this._nodes = compact__(this._nodes);
			return this;
		};
		
		ListNode.prototype.load = function (list){
			return list;
		};
		
		ListNode.prototype.concat = function (other){
			// need to store indented content as well?
			this._nodes = this.nodes().concat(other instanceof Array ? (other) : (other.nodes()));
			return this;
		};
		
		ListNode.prototype.swap = function (item,other){
			var idx = this.indexOf(item);
			if (idx >= 0) { this.nodes()[idx] = other };
			return this;
		};
		
		ListNode.prototype.push = function (item){
			this._nodes.push(item);
			return this;
		};
		
		ListNode.prototype.pop = function (){
			var end = this._nodes.pop();
			return end;
		};
		
		ListNode.prototype.add = function (item){
			this._nodes.push(item);
			return this;
		};
		
		ListNode.prototype.unshift = function (item,br){
			if (br) { this._nodes.unshift(BR) };
			this._nodes.unshift(item);
			return this;
		};
		
		// test
		ListNode.prototype.slice = function (a,b){
			return new this.constructor(this._nodes.slice(a,b));
		};
		
		
		
		ListNode.prototype.break = function (br,pre){
			if(pre === undefined) pre = false;
			if (typeof br == 'string') { br = new Terminator(br) };
			pre ? (this.unshift(br)) : (this.push(br));
			return this;
		};
		
		ListNode.prototype.some = function (cb){
			for (var i = 0, ary = iter$(this._nodes), len = ary.length; i < len; i++) {
				if (cb(ary[i])) { return true };
			};
			return false;
		};
		
		ListNode.prototype.every = function (cb){
			for (var i = 0, ary = iter$(this._nodes), len = ary.length; i < len; i++) {
				if (!cb(ary[i])) { return false };
			};
			return true;
		};
		
		ListNode.prototype.filter = function (cb){
			return this._nodes.filter(cb);
		};
		
		ListNode.prototype.pluck = function (cb){
			var item = this.filter(cb)[0];
			if (item) { this.remove(item) };
			return item;
		};
		
		ListNode.prototype.indexOf = function (item){
			return this._nodes.indexOf(item);
		};
		
		ListNode.prototype.index = function (i){
			return this._nodes[i];
		};
		
		ListNode.prototype.remove = function (item){
			var idx = this._nodes.indexOf(item);
			if (idx >= 0) { this._nodes.splice(idx,1) };
			return this;
		};
		
		ListNode.prototype.removeAt = function (idx){
			var item = this._nodes[idx];
			if (idx >= 0) { this._nodes.splice(idx,1) };
			return item;
		};
		
		
		ListNode.prototype.replace = function (original,replacement){
			var idx = this._nodes.indexOf(original);
			if (idx >= 0) {
				if (replacement instanceof Array) {
					// p "replaceing with array of items"
					this._nodes.splice.apply(this._nodes,[].concat([idx,1], [].slice.call(replacement)));
				} else {
					this._nodes[idx] = replacement;
				};
			};
			return this;
		};
		
		ListNode.prototype.first = function (){
			return this._nodes[0];
		};
		
		ListNode.prototype.last = function (){
			var i = this._nodes.length;
			while (i){
				i = i - 1;
				var v = this._nodes[i];
				if (!((v instanceof Meta))) { return v };
			};
			return null;
		};
		
		ListNode.prototype.map = function (fn){
			return this._nodes.map(fn);
		};
		
		ListNode.prototype.forEach = function (fn){
			return this._nodes.forEach(fn);
		};
		
		ListNode.prototype.remap = function (fn){
			this._nodes = this.map(fn);
			return this;
		};
		
		ListNode.prototype.count = function (){
			return this._nodes.length;
		};
		
		ListNode.prototype.realCount = function (){
			var k = 0;
			for (var i = 0, ary = iter$(this._nodes), len = ary.length, node; i < len; i++) {
				node = ary[i];
				if (node && !(node instanceof Meta)) { k++ };
			};
			return k;
		};
		
		ListNode.prototype.visit = function (){
			for (var i = 0, ary = iter$(this._nodes), len = ary.length, node; i < len; i++) {
				node = ary[i];
				node && node.traverse();
			};
			return this;
		};
		
		ListNode.prototype.isExpressable = function (){
			for (var i = 0, ary = iter$(this.nodes()), len = ary.length, node; i < len; i++) {
				node = ary[i];
				if (node && !node.isExpressable()) { return false };
			};
			// return no unless nodes.every(|v| v.isExpressable )
			return true;
		};
		
		ListNode.prototype.toArray = function (){
			return this._nodes;
		};
		
		ListNode.prototype.delimiter = function (){
			return this._delimiter || ",";
		};
		
		ListNode.prototype.js = function (o,pars){
			if(!pars||pars.constructor !== Object) pars = {};
			var nodes = pars.nodes !== undefined ? pars.nodes : this._nodes;
			var delim = ',';
			var express = delim != ';';
			var last = this.last();
			
			var i = 0;
			var l = nodes.length;
			var str = "";
			
			for (var j = 0, ary = iter$(nodes), len = ary.length, arg; j < len; j++) {
				arg = ary[j];
				var part = typeof arg == 'string' ? (arg) : ((arg ? (arg.c({expression: express})) : ('')));
				str += part;
				if (part && (!express || arg != last) && !(arg instanceof Meta)) { str += delim };
			};
			
			return str;
		};
		
		ListNode.prototype.indented = function (a,b){
			if (a instanceof Indentation) {
				this._indentation = a;
				return this;
			};
			
			this._indentation || (this._indentation = a && b ? (new Indentation(a,b)) : (INDENT));
			return this;
		};
		
		
		function ArgList(){ return ListNode.apply(this,arguments) };
		
		subclass$(ArgList,ListNode);
		exports.ArgList = ArgList; // export class 
		
		
		//	def indented a,b
		//		if a isa Indentation
		//			@indentation = a
		//			return self
		//
		//		@indentation ||= a and b ? Indentation.new(a,b) : INDENT
		//		self
		
		// def hasSplat
		// 	@nodes.some do |v| v isa Splat
		// def delimiter
		// 	","
		
		
		function AssignList(){ return ArgList.apply(this,arguments) };
		
		subclass$(AssignList,ArgList);
		exports.AssignList = AssignList; // export class 
		AssignList.prototype.concat = function (other){
			if (this._nodes.length == 0 && (other instanceof AssignList)) {
				return other;
			} else {
				AssignList.__super__.concat.call(this,other);
			};
			// need to store indented content as well?
			// @nodes = nodes.concat(other isa Array ? other : other.nodes)
			return this;
		};
		
		
		function Block(list){
			this.setup();
			// @nodes = compact__(flatten__(list)) or []
			this._nodes = list || [];
			this._head = null;
			this._indentation = null;
		};
		
		subclass$(Block,ListNode);
		exports.Block = Block; // export class 
		Block.prototype.head = function(v){ return this._head; }
		Block.prototype.setHead = function(v){ this._head = v; return this; };
		
		Block.wrap = function (ary){
			if (!((ary instanceof Array))) {
				throw new SyntaxError("what");
			};
			return ary.length == 1 && (ary[0] instanceof Block) ? (ary[0]) : (new Block(ary));
		};
		
		Block.prototype.visit = function (){
			if (this._scope) { this._scope.visit() };
			
			for (var i = 0, ary = iter$(this._nodes), len = ary.length, node; i < len; i++) {
				node = ary[i];
				node && node.traverse();
			};
			return this;
		};
		
		Block.prototype.block = function (){
			return this;
		};
		
		// def indented a,b
		// 	@indentation ||= a and b ? Indentation.new(a,b) : INDENT
		// 	self
		
		Block.prototype.loc = function (){
			// rather indents, no?
			var opt, ind;
			if (opt = this.option('ends')) {
				// p "location is",opt
				var a = opt[0].loc();
				var b = opt[1].loc();
				
				if (!a) { this.p(("no loc for " + (opt[0]))) };
				if (!b) { this.p(("no loc for " + (opt[1]))) };
				
				return [a[0],b[1]];
			} else if (ind = this._indentation) {
				return [ind.aloc(),ind.bloc()];
			} else {
				return [0,0];
			};
		};
		
		// go through children and unwrap inner nodes
		Block.prototype.unwrap = function (){
			var ary = [];
			for (var i = 0, items = iter$(this.nodes()), len = items.length, node; i < len; i++) {
				node = items[i];
				if (node instanceof Block) {
					// p "unwrapping inner block"
					ary.push.apply(ary,node.unwrap());
				} else {
					ary.push(node);
				};
			};
			return ary;
		};
		
		Block.prototype.push = function (item){
			this._nodes.push(item);
			return this;
		};
		
		Block.prototype.add = function (item){
			this._nodes.push(item);
			return this;
		};
		
		// This is just to work as an inplace replacement of nodes.coffee
		// After things are working okay we'll do bigger refactorings
		Block.prototype.compile = function (o){
			if(o === undefined) o = {};
			var root = new Root(this,o);
			return root.compile(o);
		};
		
		
		// Not sure if we should create a separate block?
		Block.prototype.analyze = function (o){
			// p "analyzing block!!!",o
			if(o === undefined) o = {};
			return this;
		};
		
		Block.prototype.cpart = function (node){
			var out = typeof node == 'string' ? (node) : ((node ? (node.c()) : ("")));
			if (out == null || out == undefined || out == "") { return "" };
			
			if (out instanceof Array) {
				var str = "";
				var l = out.length;
				var i = 0;
				while (i < l){
					str += this.cpart(out[i++]);
				};
				return str;
			};
			
			var hasSemiColon = SEMICOLON_TEST.test(out);
			if (!(hasSemiColon || (node instanceof Meta))) { out += ";" };
			return out;
		};
		
		Block.prototype.js = function (o,opts){
			var ast = this._nodes;
			var l = ast.length;
			// really?
			var express = this.isExpression() || o.isExpression() || (this.option('express') && this.isExpressable());
			if (ast.length == 0) { return '' };
			
			if (express) {
				return Block.__super__.js.call(this,o,{nodes: ast});
			};
			
			var str = "";
			for (var i = 0, ary = iter$(ast), len = ary.length; i < len; i++) {
				str += this.cpart(ary[i]);
			};
			
			// now add the head items as well
			if (this._head && this._head.length > 0) {
				var prefix = "";
				for (var i = 0, ary = iter$(this._head), len = ary.length; i < len; i++) {
					var hv = this.cpart(ary[i]);
					if (hv) { prefix += hv + '\n' };
				};
				str = prefix + str;
			};
			return str;
		};
		
		
		// Should this create the function as well?
		Block.prototype.defers = function (original,replacement){
			var idx = this._nodes.indexOf(original);
			if (idx >= 0) { this._nodes[idx] = replacement };
			var rest = this._nodes.splice(idx + 1);
			return rest;
		};
		
		Block.prototype.expressions = function (){
			var expressions = [];
			for (var i = 0, ary = iter$(this.nodes()), len = ary.length, node; i < len; i++) {
				node = ary[i];
				if (!((node instanceof Terminator))) { expressions.push(node) };
			};
			return expressions;
		};
		
		
		Block.prototype.consume = function (node){
			var before;
			if (node instanceof TagTree) { // special case?!?
				this._nodes = this._nodes.map(function(child) {
					return child.consume(node);
				});
				
				var real = this.expressions();
				// FIXME should not include terminators and comments when counting
				// should only wrap the content in array (returning all parts)
				// for if/else blocks -- not loops
				
				// we need to compare the real length
				if (!node._loop && real.length > 1) {
					// p "lengths",@nodes:length,expressions:length
					var nr = node.blocks().push(this);
					var arr = new Arr(new ArgList(this._nodes));
					arr.indented(this._indentation);
					this._indentation = null;
					
					if (node.reactive()) {
						this._nodes = [Util.callImba("static",[arr,new Num(nr)])];
					} else {
						this._nodes = [arr];
					};
				};
				
				
				
				return this;
			};
			
			// can also return super if it is expressable, but should we really?
			if (before = this.last()) {
				var after = before.consume(node);
				if (after != before) {
					// p "replace node in block {before} -> {after}"
					if (after instanceof Block) {
						// p "replaced with block -- should basically add it instead?"
						after = after.nodes();
					};
					
					this.replace(before,after);
				};
			};
			// really?
			return this;
		};
		
		
		Block.prototype.isExpressable = function (){
			if (!this._nodes.every(function(v) { return v.isExpressable(); })) { return false };
			return true;
		};
		
		Block.prototype.isExpression = function (){
			
			return this.option('express') || this._expression;
		};
		
		
		// this is almost like the old VarDeclarations but without the values
		function VarBlock(){ return ListNode.apply(this,arguments) };
		
		subclass$(VarBlock,ListNode);
		exports.VarBlock = VarBlock; // export class 
		VarBlock.prototype.load = function (list){
			var first = list[0];
			
			if (first instanceof Assign) {
				this._type = first.left()._type;
			} else if (first instanceof VarReference) {
				this._type = first._type;
			};
			// p "here {list[0]} - {@type}"
			// @type = list[0] and list[0].type
			return list;
		};
		
		// TODO All these inner items should rather be straight up literals
		// or basic localvars - without any care whatsoever about adding var to the
		// beginning etc. 
		VarBlock.prototype.addExpression = function (expr){
			// p "VarBlock.addExpression {self} <- {expr}"
			
			if (expr instanceof Assign) {
				// make sure the left-side is a var-reference
				// this should be a different type of assign, no?
				if (expr.left() instanceof VarOrAccess) {
					expr.setLeft(new VarReference(expr.left().value(),this._type));
				};
				
				this.push(expr);
			} else if (expr instanceof Assign) {
				this.addExpression(expr.left()); // make sure this is a valid thing?
				// make this into a tuple instead
				// does not need to be a tuple?
				return new TupleAssign('=',new Tuple(this.nodes()),expr.right());
			} else if (expr instanceof VarOrAccess) {
				// this is really a VarReference
				this.push(new VarReference(expr.value(),this._type));
			} else if ((expr instanceof Splat) && (expr.node() instanceof VarOrAccess)) {
				// p "is a splat - only allowed in tuple-assignment"
				// what?
				expr.setValue(new VarReference(expr.node().value(),this._type));
				this.push(expr);
			} else {
				this.p(("VarBlock.addExpression " + this + " <- " + expr));
				throw "VarBlock does not allow non-variable expressions";
			};
			return this;
		};
		
		
		VarBlock.prototype.isExpressable = function (){
			// we would need to force-drop the variables, makes little sense
			// but, it could be, could just push the variables out?
			return false;
		};
		
		VarBlock.prototype.js = function (o){
			// p "VarBlock"
			// for n in @nodes
			// 	p "VarBlock child {n}"
			var code = compact__(flatten__(cary__(this.nodes())));
			code = code.filter(function(n) { return n != null && n != undefined && n != EMPTY; });
			var out = code.join(",");
			// we just need to trust that the variables have been autodeclared beforehand
			// if we are inside an expression
			if (!o.isExpression()) { out = "var " + out };
			return out;
		};
		
		
		VarBlock.prototype.consume = function (node){
			// It doesnt make much sense for a VarBlock to consume anything
			// it should probably return void for methods
			return this;
		};
		
		
		// Could inherit from valueNode
		function Parens(value,open,close){
			this.setup();
			this._open = open;
			this._close = close;
			this._value = this.load(value);
		};
		
		subclass$(Parens,ValueNode);
		exports.Parens = Parens; // export class 
		Parens.prototype.load = function (value){
			this._noparen = false;
			return (value instanceof Block) && value.count() == 1 ? (value.first()) : (value);
		};
		
		Parens.prototype.isString = function (){
			// checking if this is an interpolated string
			return this._open && String(this._open) == '("' || this.value().isString();
		};
		
		Parens.prototype.js = function (o){
			
			var par = this.up();
			var v = this._value;
			var str = null;
			
			if (v instanceof Func) { this._noparen = true };
			// p "compile parens {v} {v isa Block and v.count}"
			// p "Parens up {par} {o.isExpression}"
			if (par instanceof Block) {
				// is it worth it?
				if (!o.isExpression()) { this._noparen = true };
				str = v instanceof Array ? (cary__(v)) : (v.c({expression: o.isExpression()}));
			} else {
				str = v instanceof Array ? (cary__(v)) : (v.c({expression: true}));
			};
			
			// check if we really need parens here?
			return str;
		};
		
		Parens.prototype.set = function (obj){
			console.log(("Parens set " + JSON.stringify(obj)));
			return Parens.__super__.set.call(this,obj);
		};
		
		
		Parens.prototype.shouldParenthesize = function (){
			// no need to parenthesize if this is a line in a block
			if (this._noparen) { return false }; //  or par isa ArgList
			return true;
		};
		
		
		Parens.prototype.prebreak = function (br){
			Parens.__super__.prebreak.call(this,br);
			console.log("PREBREAK");
			if (this._value) { this._value.prebreak(br) };
			return this;
		};
		
		
		Parens.prototype.isExpressable = function (){
			return this._value.isExpressable();
		};
		
		Parens.prototype.consume = function (node){
			return this._value.consume(node);
		};
		
		
		// Could inherit from valueNode
		// an explicit expression-block (with parens) is somewhat different
		// can be used to return after an expression
		function ExpressionBlock(){ return ListNode.apply(this,arguments) };
		
		subclass$(ExpressionBlock,ListNode);
		exports.ExpressionBlock = ExpressionBlock; // export class 
		ExpressionBlock.prototype.c = function (){
			return this.map(function(item) { return item.c(); }).join(",");
		};
		
		ExpressionBlock.prototype.consume = function (node){
			return this.value().consume(node);
		};
		
		ExpressionBlock.prototype.addExpression = function (expr){
			// Need to take care of the splat here to.. hazzle
			if (expr.node() instanceof Assign) {
				// p "is assignment!"
				this.push(expr.left());
				// make this into a tuple instead
				// possibly fix this as well?!?
				return new TupleAssign('=',new Tuple(this.nodes()),expr.right());
			} else {
				this.push(expr);
			};
			return this;
		};
		
		
		
		// STATEMENTS
		
		function Return(v){
			this._traversed = false;
			this._value = (v instanceof ArgList) && v.count() == 1 ? (v.last()) : (v);
			// @prebreak = v and v.@prebreak
			// console.log "return?!? {v}",@prebreak
			// if v isa ArgList and v.count == 1
			return this;
		};
		
		subclass$(Return,Statement);
		exports.Return = Return; // export class 
		Return.prototype.value = function(v){ return this._value; }
		Return.prototype.setValue = function(v){ this._value = v; return this; };
		
		Return.prototype.visit = function (){
			if (this._value && this._value.traverse) { return this._value.traverse() };
		};
		
		Return.prototype.js = function (o){
			var v = this._value;
			
			if (v instanceof ArgList) {
				return ("return [" + v.c({expression: true}) + "]");
			} else if (v) {
				return ("return " + v.c({expression: true}));
			} else {
				return "return";
			};
		};
		
		Return.prototype.c = function (){
			if (!(this.value()) || this.value().isExpressable()) { return Return.__super__.c.apply(this,arguments) };
			// p "return must cascade into value".red
			return this.value().consume(this).c();
		};
		
		Return.prototype.consume = function (node){
			return this;
		};
		
		function ImplicitReturn(){ return Return.apply(this,arguments) };
		
		subclass$(ImplicitReturn,Return);
		exports.ImplicitReturn = ImplicitReturn; // export class 
		
		
		function GreedyReturn(){ return ImplicitReturn.apply(this,arguments) };
		
		subclass$(GreedyReturn,ImplicitReturn);
		exports.GreedyReturn = GreedyReturn; // export class 
		
		
		// cannot live inside an expression(!)
		function Throw(){ return Statement.apply(this,arguments) };
		
		subclass$(Throw,Statement);
		exports.Throw = Throw; // export class 
		Throw.prototype.js = function (o){
			return ("throw " + (this.value().c()));
		};
		
		Throw.prototype.consume = function (node){
			// ROADMAP should possibly consume to the value of throw and then throw?
			return this;
		};
		
		
		function LoopFlowStatement(lit,expr){
			this.setLiteral(lit);
			this.setExpression(expr); // && ArgList.new(expr) # really?
		};
		
		subclass$(LoopFlowStatement,Statement);
		exports.LoopFlowStatement = LoopFlowStatement; // export class 
		LoopFlowStatement.prototype.literal = function(v){ return this._literal; }
		LoopFlowStatement.prototype.setLiteral = function(v){ this._literal = v; return this; };
		LoopFlowStatement.prototype.expression = function(v){ return this._expression; }
		LoopFlowStatement.prototype.setExpression = function(v){ this._expression = v; return this; };
		
		LoopFlowStatement.prototype.visit = function (){
			if (this.expression()) { return this.expression().traverse() };
		};
		
		LoopFlowStatement.prototype.consume = function (node){
			// p "break/continue should consume?!"
			return this;
		};
		
		LoopFlowStatement.prototype.c = function (){
			if (!(this.expression())) { return LoopFlowStatement.__super__.c.apply(this,arguments) };
			// get up to the outer loop
			var _loop = STACK.up(Loop);
			// p "found loop?",_loop
			
			// need to fix the grammar for this. Right now it 
			// is like a fake call, but should only care about the first argument
			var expr = this.expression();
			
			if (_loop.catcher()) {
				expr = expr.consume(_loop.catcher());
				var copy = new this.constructor(this.literal());
				return new Block([expr,copy]).c();
			} else if (expr) {
				copy = new this.constructor(this.literal());
				return new Block([expr,copy]).c();
			} else {
				return LoopFlowStatement.__super__.c.apply(this,arguments);
			};
			// return "loopflow"
		};
		
		
		function BreakStatement(){ return LoopFlowStatement.apply(this,arguments) };
		
		subclass$(BreakStatement,LoopFlowStatement);
		exports.BreakStatement = BreakStatement; // export class 
		BreakStatement.prototype.js = function (o){
			return "break";
		};
		
		function ContinueStatement(){ return LoopFlowStatement.apply(this,arguments) };
		
		subclass$(ContinueStatement,LoopFlowStatement);
		exports.ContinueStatement = ContinueStatement; // export class 
		ContinueStatement.prototype.js = function (o){
			return "continue";
		};
		
		function DebuggerStatement(){ return Statement.apply(this,arguments) };
		
		subclass$(DebuggerStatement,Statement);
		exports.DebuggerStatement = DebuggerStatement; // export class 
		
		
		
		// PARAMS
		
		function Param(name,defaults,typ){
			// could have introduced bugs by moving back to identifier here
			this._traversed = false;
			this._name = name; // .value # this is an identifier(!)
			this._defaults = defaults;
			this._typ = typ;
			this._variable = null;
		};
		
		subclass$(Param,Node);
		exports.Param = Param; // export class 
		Param.prototype.name = function(v){ return this._name; }
		Param.prototype.setName = function(v){ this._name = v; return this; };
		Param.prototype.index = function(v){ return this._index; }
		Param.prototype.setIndex = function(v){ this._index = v; return this; };
		Param.prototype.defaults = function(v){ return this._defaults; }
		Param.prototype.setDefaults = function(v){ this._defaults = v; return this; };
		Param.prototype.splat = function(v){ return this._splat; }
		Param.prototype.setSplat = function(v){ this._splat = v; return this; };
		Param.prototype.variable = function(v){ return this._variable; }
		Param.prototype.setVariable = function(v){ this._variable = v; return this; };
		
		// what about object-params?
		
		Param.prototype.varname = function (){
			return this._variable ? (this._variable.c()) : (this.name());
		};
		
		Param.prototype.js = function (o){
			if (this._variable) { return this._variable.c() };
			
			if (this.defaults()) {
				// should not include any source-mapping here?
				return ("if(" + (this.name().c()) + " == null) " + (this.name().c()) + " = " + (this.defaults().c()));
			};
			// see if this is the initial declarator?
		};
		
		Param.prototype.visit = function (){
			var variable_, v_;
			if (this._defaults) { this._defaults.traverse() };
			(variable_ = this.variable()) || ((this.setVariable(v_ = this.scope__().register(this.name(),this)),v_));
			
			if (this._name instanceof Identifier) {
				// change type here?
				if (this._name._value) { this._name._value._type = "PARAMVAR" };
				this._name.references(this._variable);
				// console.log "got here!! {@name:constructor}"
				// @name.@token.@variable = @variable if @name.@token
			};
			
			return this;
		};
		
		Param.prototype.assignment = function (){
			return OP('=',this.variable().accessor(),this.defaults());
		};
		
		Param.prototype.isExpressable = function (){
			return !(this.defaults()) || this.defaults().isExpressable();
			// p "visiting param!!!"
		};
		
		Param.prototype.dump = function (){
			return {loc: this.loc()};
		};
		
		Param.prototype.loc = function (){
			return this._name && this._name.region();
		};
		
		Param.prototype.toJSON = function (){
			return {
				type: this.typeName(),
				name: this.name(),
				defaults: this.defaults()
			};
		};
		
		
		function SplatParam(){ return Param.apply(this,arguments) };
		
		subclass$(SplatParam,Param);
		exports.SplatParam = SplatParam; // export class 
		SplatParam.prototype.loc = function (){
			// hacky.. cannot know for sure that this is right?
			var r = this.name().region();
			return [r[0] - 1,r[1]];
		};
		
		function BlockParam(){ return Param.apply(this,arguments) };
		
		subclass$(BlockParam,Param);
		exports.BlockParam = BlockParam; // export class 
		BlockParam.prototype.c = function (){
			return "blockparam";
		};
		
		BlockParam.prototype.loc = function (){
			// hacky.. cannot know for sure that this is right?
			var r = this.name().region();
			return [r[0] - 1,r[1]];
		};
		
		
		function OptionalParam(){ return Param.apply(this,arguments) };
		
		subclass$(OptionalParam,Param);
		exports.OptionalParam = OptionalParam; // export class 
		
		
		function NamedParam(){ return Param.apply(this,arguments) };
		
		subclass$(NamedParam,Param);
		exports.NamedParam = NamedParam; // export class 
		
		
		function RequiredParam(){ return Param.apply(this,arguments) };
		
		subclass$(RequiredParam,Param);
		exports.RequiredParam = RequiredParam; // export class 
		
		
		function NamedParams(){ return ListNode.apply(this,arguments) };
		
		subclass$(NamedParams,ListNode);
		exports.NamedParams = NamedParams; // export class 
		NamedParams.prototype.index = function(v){ return this._index; }
		NamedParams.prototype.setIndex = function(v){ this._index = v; return this; };
		NamedParams.prototype.variable = function(v){ return this._variable; }
		NamedParams.prototype.setVariable = function(v){ this._variable = v; return this; };
		
		NamedParams.prototype.load = function (list){
			var load = function(k) { return new NamedParam(k.key(),k.value()); };
			return list instanceof Obj ? (list.value().map(load)) : (list);
		};
		
		NamedParams.prototype.visit = function (){
			var s = this.scope__();
			this._variable || (this._variable = s.temporary(this,{pool: 'keypars'}));
			this._variable.predeclared();
			
			// this is a listnode, which will automatically traverse
			// and visit all children
			NamedParams.__super__.visit.apply(this,arguments);
			// register the inner variables as well(!)
			return this;
		};
		
		
		NamedParams.prototype.varname = function (){
			return this.variable().c();
		};
		
		NamedParams.prototype.name = function (){
			return this.varname();
		};
		
		NamedParams.prototype.js = function (o){
			return "namedpar";
		};
		
		NamedParams.prototype.toJSON = function (){
			return {
				type: this.typeName(),
				nodes: this.filter(function(v) { return v instanceof NamedParam; })
			};
		};
		
		
		function IndexedParam(){ return Param.apply(this,arguments) };
		
		subclass$(IndexedParam,Param);
		exports.IndexedParam = IndexedParam; // export class 
		IndexedParam.prototype.parent = function(v){ return this._parent; }
		IndexedParam.prototype.setParent = function(v){ this._parent = v; return this; };
		IndexedParam.prototype.subindex = function(v){ return this._subindex; }
		IndexedParam.prototype.setSubindex = function(v){ this._subindex = v; return this; };
		
		IndexedParam.prototype.visit = function (){
			// p "VISIT PARAM {name}!"
			// ary.[-1] # possible
			// ary.(-1) # possible
			// str(/ok/,-1)
			// scope.register(@name,self)
			// BUG The defaults should probably be looked up like vars
			var variable_, v_;
			(variable_ = this.variable()) || ((this.setVariable(v_ = this.scope__().register(this.name(),this)),v_));
			this.variable().proxy(this.parent().variable(),this.subindex());
			return this;
		};
		
		
		function ArrayParams(){ return ListNode.apply(this,arguments) };
		
		subclass$(ArrayParams,ListNode);
		exports.ArrayParams = ArrayParams; // export class 
		ArrayParams.prototype.index = function(v){ return this._index; }
		ArrayParams.prototype.setIndex = function(v){ this._index = v; return this; };
		ArrayParams.prototype.variable = function(v){ return this._variable; }
		ArrayParams.prototype.setVariable = function(v){ this._variable = v; return this; };
		
		ArrayParams.prototype.visit = function (){
			var s = this.scope__();
			this._variable || (this._variable = s.temporary(this,{pool: 'keypars'}));
			this._variable.predeclared();
			
			// now when we loop through these inner params - we create the pars
			// with the correct name, but bind them to the parent
			return ArrayParams.__super__.visit.apply(this,arguments);
		};
		
		ArrayParams.prototype.name = function (){
			return this.variable().c();
		};
		
		ArrayParams.prototype.load = function (list){
			var self = this;
			if (!((list instanceof Arr))) { return null };
			// p "loading arrayparams"
			// try the basic first
			if (!list.splat()) {
				return list.value().map(function(v,i) {
					// must make sure the params are supported here
					// should really not parse any array at all(!)
					var name = v;
					if (v instanceof VarOrAccess) {
						// p "varoraccess {v.value}"
						// FIX?
						name = v.value().value();
						// this is accepted
					};
					return self.parse(name,v,i);
				});
			};
		};
		
		ArrayParams.prototype.parse = function (name,child,i){
			var param = new IndexedParam(name,null);
			
			param.setParent(this);
			param.setSubindex(i);
			return param;
		};
		
		ArrayParams.prototype.head = function (ast){
			// "arrayparams"
			return this;
		};
		
		function ParamList(){ return ListNode.apply(this,arguments) };
		
		subclass$(ParamList,ListNode);
		exports.ParamList = ParamList; // export class 
		ParamList.prototype.splat = function(v){ return this._splat; }
		ParamList.prototype.setSplat = function(v){ this._splat = v; return this; };
		ParamList.prototype.block = function(v){ return this._block; }
		ParamList.prototype.setBlock = function(v){ this._block = v; return this; };
		
		ParamList.prototype.at = function (index,force,name){
			if(force === undefined) force = false;
			if(name === undefined) name = null;
			if (force) {
				while (this.count() <= index){
					this.add(new Param(this.count() == index && name || ("_" + this.count())));
				};
				// need to visit at the same time, no?
			};
			return this.list()[index];
		};
		
		ParamList.prototype.metadata = function (){
			return this.filter(function(par) { return !(par instanceof Meta); });
		};
		
		ParamList.prototype.toJSON = function (){
			return this.metadata();
		};
		
		ParamList.prototype.visit = function (){
			this._splat = this.filter(function(par) { return par instanceof SplatParam; })[0];
			var blk = this.filter(function(par) { return par instanceof BlockParam; });
			
			if (blk.length > 1) {
				blk[1].warn("a method can only have one &block parameter");
			} else if (blk[0] && blk[0] != this.last()) {
				blk[0].warn("&block must be the last parameter of a method");
				// warn "&block must be the last parameter of a method", blk[0]
			};
			
			// add more warnings later(!)
			// should probably throw error as well to stop compilation
			
			// need to register the required-pars as variables
			return ParamList.__super__.visit.apply(this,arguments);
		};
		
		ParamList.prototype.js = function (o){
			if (this.count() == 0) { return EMPTY };
			if (o.parent() instanceof Block) { return this.head(o) };
			
			// items = map(|arg| arg.name.c ).compact
			// return null unless items[0]
			
			if (o.parent() instanceof Code) {
				// remove the splat, for sure.. need to handle the other items as well
				// this is messy with references to argvars etc etc. Fix
				var pars = this.nodes();
				// pars = filter(|arg| arg != @splat && !(arg isa BlockParam)) if @splat
				if (this._splat) { pars = this.filter(function(arg) { return (arg instanceof RequiredParam) || (arg instanceof OptionalParam); }) };
				return compact__(pars.map(function(arg) { return c__(arg.varname()); })).join(",");
			} else {
				throw "not implemented paramlist js";
				return "ta" + compact__(this.map(function(arg) { return arg.c(); })).join(",");
			};
		};
		
		ParamList.prototype.head = function (o){
			var reg = [];
			var opt = [];
			var blk = null;
			var splat = null;
			var named = null;
			var arys = [];
			var signature = [];
			var idx = 0;
			
			this.nodes().forEach(function(par,i) {
				par.setIndex(idx);
				if (par instanceof NamedParams) {
					signature.push('named');
					named = par;
				} else if (par instanceof OptionalParam) {
					signature.push('opt');
					opt.push(par);
				} else if (par instanceof BlockParam) {
					signature.push('blk');
					blk = par;
				} else if (par instanceof SplatParam) {
					signature.push('splat');
					splat = par;
					idx -= 1; // this should really be removed from the list, no?
				} else if (par instanceof ArrayParams) {
					arys.push(par);
					signature.push('ary');
				} else {
					signature.push('reg');
					reg.push(par);
				};
				return idx++;
			});
			
			if (named) {
				var namedvar = named.variable();
			};
			
			// var opt = nodes.filter(|n| n isa OptionalParam)
			// var blk = nodes.filter(|n| n isa BlockParam)[0]
			// var splat = nodes.filter(|n| n isa SplatParam)[0]
			
			// simple situation where we simply switch
			// can probably optimize by not looking at arguments at all
			var ast = [];
			var isFunc = function(js) { return ("typeof " + js + " == 'function'"); };
			
			// This is broken when dealing with iframes anc XSS scripting
			// but for now it is the best test for actual arguments
			// can also do constructor.name == 'Object'
			var isObj = function(js) { return ("" + js + ".constructor === Object"); };
			var isntObj = function(js) { return ("" + js + ".constructor !== Object"); };
			// should handle some common cases in a cleaner (less verbose) manner
			// does this work with default params after optional ones? Is that even worth anything?
			// this only works in one direction now, unlike TupleAssign
			
			// we dont really check the length etc now -- so it is buggy for lots of arguments
			
			// if we have optional params in the regular order etc we can go the easy route
			// slightly hacky now. Should refactor all of these to use the signature?
			if (!named && !splat && !blk && opt.length > 0 && signature.join(" ").match(/opt$/)) {
				for (var i = 0, len_ = opt.length, par; i < len_; i++) {
					par = opt[i];
					ast.push(("if(" + (par.name().c()) + " === undefined) " + (par.name().c()) + " = " + (par.defaults().c())));
				};
			} else if (named && !splat && !blk && opt.length == 0) { // and no block?!
				// different shorthands
				// if named
				ast.push(("if(!" + (namedvar.c()) + "||" + isntObj(namedvar.c()) + ") " + (namedvar.c()) + " = \{\}"));
			} else if (blk && opt.length == 1 && !splat && !named) {
				var op = opt[0];
				var opn = op.name().c();
				var bn = blk.name().c();
				ast.push(("if(" + bn + "==undefined && " + isFunc(opn) + ") " + bn + " = " + opn + "," + opn + " = " + (op.defaults().c())));
				ast.push(("if(" + opn + "==undefined) " + opn + " = " + (op.defaults().c())));
			} else if (blk && named && opt.length == 0 && !splat) {
				bn = blk.name().c();
				ast.push(("if(" + bn + "==undefined && " + isFunc(namedvar.c()) + ") " + bn + " = " + (namedvar.c()) + "," + (namedvar.c()) + " = \{\}"));
				ast.push(("else if(!" + (namedvar.c()) + "||" + isntObj(namedvar.c()) + ") " + (namedvar.c()) + " = \{\}"));
			} else if (opt.length > 0 || splat) { // && blk  # && !splat
				
				var argvar = this.scope__().temporary(this,{pool: 'arguments'}).predeclared().c();
				var len = this.scope__().temporary(this,{pool: 'counter'}).predeclared().c();
				
				var last = ("" + argvar + "[" + len + "-1]");
				var pop = ("" + argvar + "[--" + len + "]");
				ast.push(("var " + argvar + " = arguments, " + len + " = " + argvar + ".length"));
				
				if (blk) {
					bn = blk.name().c();
					if (splat) {
						ast.push(("var " + bn + " = " + isFunc(last) + " ? " + pop + " : null"));
					} else if (reg.length > 0) {
						// ast.push "// several regs really?"
						ast.push(("var " + bn + " = " + len + " > " + (reg.length) + " && " + isFunc(last) + " ? " + pop + " : null"));
					} else {
						ast.push(("var " + bn + " = " + isFunc(last) + " ? " + pop + " : null"));
					};
				};
				
				// if we have named params - look for them before splat
				// should probably loop through pars in the same order they were added
				// should it be prioritized above optional objects??
				if (named) {
					// should not include it when there is a splat?
					ast.push(("var " + (namedvar.c()) + " = " + last + "&&" + isObj(last) + " ? " + pop + " : \{\}"));
				};
				
				for (var i1 = 0, len_ = opt.length, par1; i1 < len_; i1++) {
					par1 = opt[i1];
					ast.push(("if(" + len + " < " + (par1.index() + 1) + ") " + (par1.name().c()) + " = " + (par1.defaults().c())));
				};
				
				// add the splat
				if (splat) {
					var sn = splat.name().c();
					var si = splat.index();
					
					if (si == 0) {
						ast.push(("var " + sn + " = new Array(" + len + ">" + si + " ? " + len + " : 0)"));
						ast.push(("while(" + len + ">" + si + ") " + sn + "[" + len + "-1] = " + pop));
					} else {
						ast.push(("var " + sn + " = new Array(" + len + ">" + si + " ? " + len + "-" + si + " : 0)"));
						ast.push(("while(" + len + ">" + si + ") " + sn + "[--" + len + " - " + si + "] = " + argvar + "[" + len + "]"));
					};
				};
				
				// if named
				// 	for k,i in named.nodes
				// 		# OP('.',namedvar) <- this is the right way, with invalid names etc
				// 		var op = OP('.',namedvar,k.key).c
				// 		ast.push "var {k.key.c} = {op} !== undefined ? {op} : {k.value.c}"
				
				// if named
				
				// return ast.join(";\n") + ";"
				// return "if({opt[0].name.c} instanceof Function) {blk.c} = {opt[0].c};"
			} else if (opt.length > 0) {
				for (var i2 = 0, len_ = opt.length, par2; i2 < len_; i2++) {
					par2 = opt[i2];
					ast.push(("if(" + (par2.name().c()) + " === undefined) " + (par2.name().c()) + " = " + (par2.defaults().c())));
				};
			};
			
			// now set stuff if named params(!)
			
			if (named) {
				for (var i3 = 0, ary = iter$(named.nodes()), len_ = ary.length, k; i3 < len_; i3++) {
					// console.log "named var {k.c}"
					k = ary[i3];
					op = OP('.',namedvar,k.c()).c();
					ast.push(("var " + (k.c()) + " = " + op + " !== undefined ? " + op + " : " + (k.defaults().c())));
				};
			};
			
			if (arys.length) {
				for (var i4 = 0, len_ = arys.length; i4 < len_; i4++) {
					// create tuples
					// p "adding arrayparams"
					arys[i4].head(o,ast,this);
					// ast.push v.c
				};
			};
			
			
			
			// if opt:length == 0
			return ast.length > 0 ? ((ast.join(";\n") + ";")) : (EMPTY);
		};
		
		
		// Legacy. Should move away from this?
		function VariableDeclaration(){ return ListNode.apply(this,arguments) };
		
		subclass$(VariableDeclaration,ListNode);
		exports.VariableDeclaration = VariableDeclaration; // export class 
		VariableDeclaration.prototype.kind = function(v){ return this._kind; }
		VariableDeclaration.prototype.setKind = function(v){ this._kind = v; return this; };
		
		// we want to register these variables in
		VariableDeclaration.prototype.add = function (name,init,pos){
			if(pos === undefined) pos = -1;
			var vardec = new VariableDeclarator(name,init);
			if (name instanceof Variable) { (vardec.setVariable(name),name) };
			pos == 0 ? (this.unshift(vardec)) : (this.push(vardec));
			return vardec;
			
			// TODO (target) << (node) rewrites to a caching push which returns node
		};
		
		// def remove item
		// 	if item isa Variable
		// 		map do |v,i|
		// 			if v.variable == item
		// 				p "found variable to remove"
		// 				super.remove(v)
		// 	else
		// 		super.remove(item)
		// 	self
		
		VariableDeclaration.prototype.load = function (list){
			// temporary solution!!!
			return list.map(function(par) { return new VariableDeclarator(par.name(),par.defaults(),par.splat()); });
		};
		
		VariableDeclaration.prototype.isExpressable = function (){
			return this.nodes().every(function(item) { return item.isExpressable(); });
		};
		
		VariableDeclaration.prototype.js = function (o){
			if (this.count() == 0) { return EMPTY };
			
			if (this.count() == 1 && !(this.isExpressable())) {
				// p "SHOULD ALTER VARDEC!!!".cyan
				this.first().variable().autodeclare();
				var node = this.first().assignment();
				return node.c();
			};
			
			// FIX PERFORMANCE
			var out = compact__(cary__(this.nodes())).join(", ");
			return out ? (("var " + out)) : ("");
			// "var " + compact__(cary__(nodes)).join(", ") + ""
		};
		
		function VariableDeclarator(){ return Param.apply(this,arguments) };
		
		subclass$(VariableDeclarator,Param);
		exports.VariableDeclarator = VariableDeclarator; // export class 
		VariableDeclarator.prototype.visit = function (){
			// even if we should traverse the defaults as if this variable does not exist
			// we need to preregister it and then activate it later
			var variable_, v_;
			(variable_ = this.variable()) || ((this.setVariable(v_ = this.scope__().register(this.name(),null)),v_));
			if (this.defaults()) { this.defaults().traverse() };
			// WARN what if it is already declared?
			this.variable().setDeclarator(this);
			this.variable().addReference(this.name());
			return this;
		};
		
		// needs to be linked up to the actual scoped variables, no?
		VariableDeclarator.prototype.js = function (o){
			if (this.variable()._proxy) { return null };
			
			var defs = this.defaults();
			// FIXME need to deal with var-defines within other statements etc
			// FIXME need better syntax for this
			if (defs != null && defs != undefined) {
				// console.log "defaults is {defaults}"
				if (defs instanceof Node) { defs = defs.c({expression: true}) };
				
				return ("" + (this.variable().c()) + " = " + defs);
			} else {
				return ("" + (this.variable().c()));
			};
		};
		
		VariableDeclarator.prototype.accessor = function (){
			return this;
		};
		
		
		// TODO clean up and refactor all the different representations of vars
		// VarName, VarReference, LocalVarAccess?
		function VarName(a,b){
			VarName.__super__.constructor.apply(this,arguments);
			this._splat = b;
		};
		
		subclass$(VarName,ValueNode);
		exports.VarName = VarName; // export class 
		VarName.prototype.variable = function(v){ return this._variable; }
		VarName.prototype.setVariable = function(v){ this._variable = v; return this; };
		VarName.prototype.splat = function(v){ return this._splat; }
		VarName.prototype.setSplat = function(v){ this._splat = v; return this; };
		
		VarName.prototype.visit = function (){
			// p "visiting varname(!)", value.c
			// should we not lookup instead?
			// FIXME p "register value {value.c}"
			var variable_, v_;
			(variable_ = this.variable()) || ((this.setVariable(v_ = this.scope__().register(this.value().c(),null)),v_));
			this.variable().setDeclarator(this);
			this.variable().addReference(this.value());
			return this;
		};
		
		VarName.prototype.js = function (o){
			return this.variable().c();
		};
		
		VarName.prototype.c = function (){
			return this.variable().c();
		};
		
		
		function VarList(t,l,r){
			this._traversed = false;
			this._type = this.type();
			this._left = l;
			this._right = r;
		};
		
		subclass$(VarList,Node);
		exports.VarList = VarList; // export class 
		VarList.prototype.type = function(v){ return this._type; }
		VarList.prototype.setType = function(v){ this._type = v; return this; }; // let / var / const
		VarList.prototype.left = function(v){ return this._left; }
		VarList.prototype.setLeft = function(v){ this._left = v; return this; };
		VarList.prototype.right = function(v){ return this._right; }
		VarList.prototype.setRight = function(v){ this._right = v; return this; };
		
		// format :type, :left, :right
		
		// should throw error if there are more values on right than left
		
		VarList.prototype.visit = function (){
			
			// we need to carefully traverse children in the right order
			// since we should be able to reference
			var r;
			for (var i = 0, ary = iter$(this.left()), len = ary.length; i < len; i++) {
				ary[i].traverse(); // this should really be a var-declaration
				if (r = this.right()[i]) { r.traverse() };
			};
			return this;
		};
		
		VarList.prototype.js = function (o){
			// for the regular items 
			var pairs = [];
			var ll = this.left().length;
			var rl = this.right().length;
			var v = null;
			
			// splatting here we come
			if (ll > 1 && rl == 1) {
				this.p("multiassign!");
				var r = this.right()[0];
				r.cache();
				for (var i = 0, ary = iter$(this.left()), len = ary.length, l; i < len; i++) {
					l = ary[i];
					if (l.splat()) {
						throw "not supported?";
						this.p("splat"); // FIX reimplement slice?
						if (i == ll - 1) {
							v = this.util().slice(r,i);
							this.p("last");
						} else {
							v = this.util().slice(r,i,-(ll - i) + 1);
						};
					} else {
						v = OP('.',r,num__(i));
					};
					
					pairs.push(OP('=',l,v));
				};
			} else {
				for (var i1 = 0, ary = iter$(this.left()), len = ary.length, l1; i1 < len; i1++) {
					l1 = ary[i1];
					r = this.right()[i1];
					pairs.push(r ? (OP('=',l1.variable().accessor(),r)) : (l1));
				};
			};
			
			return ("var " + (pairs.c()));
		};
		
		
		// CODE
		
		function Code(){ return Node.apply(this,arguments) };
		
		subclass$(Code,Node);
		exports.Code = Code; // export class 
		Code.prototype.head = function(v){ return this._head; }
		Code.prototype.setHead = function(v){ this._head = v; return this; };
		Code.prototype.body = function(v){ return this._body; }
		Code.prototype.setBody = function(v){ this._body = v; return this; };
		Code.prototype.scope = function(v){ return this._scope; }
		Code.prototype.setScope = function(v){ this._scope = v; return this; };
		Code.prototype.params = function(v){ return this._params; }
		Code.prototype.setParams = function(v){ this._params = v; return this; };
		
		Code.prototype.scopetype = function (){
			return Scope;
		};
		
		Code.prototype.visit = function (){
			if (this._scope) { this._scope.visit() };
			// @scope.parent = STACK.scope(1) if @scope
			return this;
		};
		
		
		// Rename to Program?
		function Root(body,opts){
			// p "create root!"
			this._traversed = false;
			this._body = blk__(body);
			this._scope = new RootScope(this,null);
			this._options = {};
		};
		
		subclass$(Root,Code);
		exports.Root = Root; // export class 
		Root.prototype.visit = function (){
			ROOT = STACK.ROOT = this._scope;
			this.scope().visit();
			return this.body().traverse();
		};
		
		Root.prototype.compile = function (o){
			STACK.reset(); // -- nested compilation does not work now
			OPTS = STACK._options = this._options = o || {};
			
			this.traverse();
			
			var out = this.c();
			var result = {
				js: out,
				ast: this,
				warnings: this.scope().warnings(),
				options: o,
				toString: function() { return this.js; }
			};
			if (o.sourceMapInline || o.sourceMap) {
				result.sourcemap = new SourceMap(result).generate();
			};
			
			return result;
		};
		
		Root.prototype.js = function (o){
			var out;
			if (this._options.bare) {
				out = this.scope().c();
			} else {
				this.body().consume(new ImplicitReturn());
				out = this.scope().c({indent: true});
				out = out.replace(/^\n?/,'\n');
				out = out.replace(/\n?$/,'\n\n');
				out = '(function(){' + out + '})()';
			};
			
			// find and replace shebangs
			var shebangs = [];
			out = out.replace(/^[ \t]*\/\/(\!.+)$/mg,function(m,shebang) {
				// p "found shebang {shebang}"
				shebang = shebang.replace(/\bimba\b/g,'node');
				shebangs.push(("#" + shebang + "\n"));
				return "";
			});
			
			out = shebangs.join('') + out;
			
			return out;
		};
		
		
		Root.prototype.analyze = function (pars){
			if(!pars||pars.constructor !== Object) pars = {};
			var loglevel = pars.loglevel !== undefined ? pars.loglevel : 0;
			var entities = pars.entities !== undefined ? pars.entities : false;
			var scopes = pars.scopes !== undefined ? pars.scopes : true;
			STACK.setLoglevel(loglevel);
			STACK._analyzing = true;
			ROOT = STACK.ROOT = this._scope;
			
			OPTS = {
				analysis: {
					entities: entities,
					scopes: scopes
				}
			};
			
			this.traverse();
			STACK._analyzing = false;
			
			return this.scope().dump();
		};
		
		Root.prototype.inspect = function (){
			return true;
		};
		
		function ClassDeclaration(name,superclass,body){
			// what about the namespace?
			this._traversed = false;
			this._name = name;
			this._superclass = superclass;
			this._scope = new ClassScope(this);
			this._body = blk__(body);
			this;
		};
		
		subclass$(ClassDeclaration,Code);
		exports.ClassDeclaration = ClassDeclaration; // export class 
		ClassDeclaration.prototype.name = function(v){ return this._name; }
		ClassDeclaration.prototype.setName = function(v){ this._name = v; return this; };
		ClassDeclaration.prototype.superclass = function(v){ return this._superclass; }
		ClassDeclaration.prototype.setSuperclass = function(v){ this._superclass = v; return this; };
		ClassDeclaration.prototype.initor = function(v){ return this._initor; }
		ClassDeclaration.prototype.setInitor = function(v){ this._initor = v; return this; };
		
		ClassDeclaration.prototype.consume = function (node){
			if (node instanceof Return) {
				this.option('return',true);
				return this;
			};
			return ClassDeclaration.__super__.consume.apply(this,arguments);
		};
		
		ClassDeclaration.prototype.namepath = function (){
			return this._namepath || (this._namepath = ("" + (this.name().c())));
		};
		
		ClassDeclaration.prototype.metadata = function (){
			var superclass_;
			return {
				type: 'class',
				namepath: this.namepath(),
				inherits: (superclass_ = this.superclass()) && superclass_.namepath  &&  superclass_.namepath(),
				path: this.name().c().toString(),
				desc: this._desc,
				loc: this.loc()
			};
		};
		
		ClassDeclaration.prototype.toJSON = function (){
			return this.metadata();
		};
		
		ClassDeclaration.prototype.visit = function (){
			// replace with some advanced lookup?
			ROOT.entities().add(this.namepath(),this);
			this.scope().visit();
			this.body().traverse();
			return this;
		};
		
		ClassDeclaration.prototype.js = function (o){
			this.scope().virtualize(); // is this always needed?
			this.scope().context().setValue(this.name());
			
			// should probably also warn about stuff etc
			if (this.option('extension')) {
				return this.body().c();
			};
			
			var head = [];
			var o = this._options || {};
			var cname = this.name() instanceof Access ? (this.name().right()) : (this.name());
			var namespaced = this.name() != cname;
			var initor = null;
			var sup = this.superclass();
			
			var bodyindex = -1;
			var spaces = this.body().filter(function(item) { return item instanceof Terminator; });
			var mark = mark__(this.option('keyword'));
			
			this.body().map(function(c,i) {
				if ((c instanceof MethodDeclaration) && c.type() == 'constructor') {
					return bodyindex = i;
				};
			});
			
			if (bodyindex >= 0) {
				initor = this.body().removeAt(bodyindex);
			};
			
			// var initor = body.pluck do |c| c isa MethodDeclaration && c.type == :constructor
			// compile the cname
			if (typeof cname != 'string') { cname = cname.c() };
			
			var cpath = typeof this.name() == 'string' ? (this.name()) : (this.name().c());
			
			if (!initor) {
				if (sup) {
					initor = ("" + mark + "function " + cname + "()\{ return " + (sup.c()) + ".apply(this,arguments) \};\n\n");
				} else {
					initor = ("" + mark + "function " + cname + "()") + '{ };\n\n';
				};
			} else {
				initor.setName(cname);
				initor = initor.c() + ';';
			};
			
			// if we are defining a class inside a namespace etc -- how should we set up the class?
			
			if (namespaced) {
				// should use Nodes to build this instead
				initor = ("" + cpath + " = " + initor); // OP('=',name,initor)
			};
			
			head.push(initor); // // @class {cname}\n
			
			if (bodyindex >= 0) {
				// add the space after initor?
				if (this.body().index(bodyindex) instanceof Terminator) {
					head.push(this.body().removeAt(bodyindex));
				};
			} else {
				// head.push(Terminator.new('\n\n'))
				true;
			};
			
			
			
			if (sup) {
				// console.log "deal with superclass!"
				// head.push("// extending the superclass\nimba$class({name.c},{sup.c});\n\n")
				head.push(new Util.Subclass([this.name(),sup]));
			};
			
			// only if it is not namespaced
			if (o.global && !namespaced) { // option(:global)
				head.push(("global." + cname + " = " + cpath + "; // global class \n"))
			};
			
			if (o.export && !namespaced) {
				head.push(("exports." + cname + " = " + cpath + "; // export class \n"))
			};
			
			// FIXME
			// if namespaced and (o:local or o:export)
			// 	console.log "namespaced classes are implicitly local/global depending on the namespace"
			
			if (this.option('return')) {
				this.body().push(("return " + cpath + ";"));
			};
			
			for (var i = 0, ary = iter$(head.reverse()), len = ary.length; i < len; i++) {
				this.body().unshift(ary[i]);
			};
			this.body()._indentation = null;
			var end = this.body().index(this.body().count() - 1);
			if ((end instanceof Terminator) && end.c().length == 1) { this.body().pop() };
			
			var out = this.body().c();
			
			return out;
		};
		
		
		function TagDeclaration(name,superclass,body){
			// what about the namespace?
			// @name = TagTypeRef.new(name)
			this._traversed = false;
			this._name = name;
			this._superclass = superclass;
			this._scope = new TagScope(this);
			this._body = blk__(body || []);
		};
		
		subclass$(TagDeclaration,Code);
		exports.TagDeclaration = TagDeclaration; // export class 
		TagDeclaration.prototype.name = function(v){ return this._name; }
		TagDeclaration.prototype.setName = function(v){ this._name = v; return this; };
		TagDeclaration.prototype.superclass = function(v){ return this._superclass; }
		TagDeclaration.prototype.setSuperclass = function(v){ this._superclass = v; return this; };
		TagDeclaration.prototype.initor = function(v){ return this._initor; }
		TagDeclaration.prototype.setInitor = function(v){ this._initor = v; return this; };
		
		TagDeclaration.prototype.namepath = function (){
			return ("<" + this.name() + ">");
		};
		
		TagDeclaration.prototype.toJSON = function (){
			return {
				type: 'tag',
				namepath: this.namepath(),
				inherits: this.superclass() ? (("<" + (this.superclass().name()) + ">")) : (null),
				loc: this.loc(),
				desc: this._desc
			};
		};
		
		TagDeclaration.prototype.visit = function (){
			ROOT.entities().register(this); // what if this is not local?
			
			for (var i = 0, ary = iter$(STACK.scopes()), len = ary.length, scope; i < len; i++) {
				scope = ary[i];
				if (i > 0 && (scope instanceof TagScope)) {
					// register inside here?
					scope.node().option('hasLocalTags',true);
					this.option('parent',scope.node());
					break;
					// console.log "tag is local!!!"
				};
			};
			// replace with some advanced lookup?
			this.scope().visit();
			return this.body().traverse();
		};
		
		TagDeclaration.prototype.id = function (){
			return this.name().id();
		};
		
		TagDeclaration.prototype.tagspace = function (){
			var ctx = this.scope().closure().tagContextPath();
			return this.name().ns() ? (("" + ctx + "." + (this.name().ns().toUpperCase()))) : (ctx);
		};
		
		TagDeclaration.prototype.js = function (o){
			this.scope().context().setValue(this._ctx = this.scope().declare('tag',null,{system: true}));
			
			var ns = this.name().ns();
			var mark = mark__(this.option('keyword'));
			
			var params = [helpers.singlequote(this.name().name())];
			var cbody = this.body().c();
			// var outbody = body.count ? ", function({@ctx.c})\{{cbody}\}" : ''
			
			if (this.superclass()) {
				// WARN what if the superclass has a namespace?
				params.push(helpers.singlequote(this.superclass().name()));
			};
			
			if (this.body().count()) {
				if (this.option('hasLocalTags')) {
					params.push(("function(" + (this._ctx.c()) + "," + (this.scope().closure().tagContextPath()) + ")\{" + cbody + "\}"));
				} else {
					params.push(("function(" + (this._ctx.c()) + ")\{" + cbody + "\}"));
				};
			};
			
			var meth = this.option('extension') ? ('extendTag') : ('defineTag');
			// return "{mark}{tagspace}.extendTag('{name.name}'{outbody})"
			
			// var sup = superclass and "," + helpers.singlequote(superclass.func) or ""
			
			// var out = if name.id
			//	"{mark}{tagspace}.defineSingleton('{name.name}'{sup}{outbody})"
			// else
			
			return ("" + mark + this.tagspace() + "." + meth + "(" + params.join(', ') + ")");
			
			// return out
		};
		
		function Func(params,body,name,target,o){
			// p "INIT Function!!",params,body,name
			var typ = this.scopetype();
			this._traversed = false;
			this._body = blk__(body);
			this._scope || (this._scope = (o && o.scope) || new typ(this));
			this._scope.setParams(this._params = new ParamList(params));
			this._name = name || '';
			this._target = target;
			this._options = o;
			this._type = 'function';
			this._variable = null;
			this;
		};
		
		subclass$(Func,Code);
		exports.Func = Func; // export class 
		Func.prototype.name = function(v){ return this._name; }
		Func.prototype.setName = function(v){ this._name = v; return this; };
		Func.prototype.params = function(v){ return this._params; }
		Func.prototype.setParams = function(v){ this._params = v; return this; };
		Func.prototype.target = function(v){ return this._target; }
		Func.prototype.setTarget = function(v){ this._target = v; return this; };
		Func.prototype.options = function(v){ return this._options; }
		Func.prototype.setOptions = function(v){ this._options = v; return this; };
		Func.prototype.type = function(v){ return this._type; }
		Func.prototype.setType = function(v){ this._type = v; return this; };
		Func.prototype.context = function(v){ return this._context; }
		Func.prototype.setContext = function(v){ this._context = v; return this; };
		
		Func.prototype.scopetype = function (){
			return FunctionScope;
		};
		
		Func.prototype.visit = function (){
			this.scope().visit();
			this._context = this.scope().parent();
			this._params.traverse();
			return this._body.traverse(); // so soon?
		};
		
		
		Func.prototype.js = function (o){
			if (!this.option('noreturn')) { this.body().consume(new ImplicitReturn()) };
			var ind = this.body()._indentation;
			// var s = ind and ind.@open
			// p "indent function? {body.@indentation} {s} {s:generated} {body.count}"
			if (ind && ind.isGenerated()) { this.body()._indentation = null };
			var code = this.scope().c({indent: (!ind || !ind.isGenerated()),braces: true});
			
			// args = params.map do |par| par.name
			// head = params.map do |par| par.c
			// code = [head,body.c(expression: no)].flatten__.compact.join("\n").wrap
			// FIXME creating the function-name this way is prone to create naming-collisions
			// will need to wrap the value in a FunctionName which takes care of looking up scope
			// and possibly dealing with it
			var name = typeof this._name == 'string' ? (this._name) : (this._name.c());
			name = name ? (' ' + name.replace(/\./g,'_')) : ('');
			var out = ("function" + name + "(" + (this.params().c()) + ") ") + code;
			if (this.option('eval')) { out = ("(" + out + ")()") };
			return out;
		};
		
		Func.prototype.shouldParenthesize = function (par){
			if(par === undefined) par = this.up();
			return (par instanceof Call) && par.callee() == this;
			// if up as a call? Only if we are 
		};
		
		function Lambda(){ return Func.apply(this,arguments) };
		
		subclass$(Lambda,Func);
		exports.Lambda = Lambda; // export class 
		Lambda.prototype.scopetype = function (){
			return LambdaScope;
		};
		
		function TagFragmentFunc(){ return Func.apply(this,arguments) };
		
		subclass$(TagFragmentFunc,Func);
		exports.TagFragmentFunc = TagFragmentFunc; // export class 
		
		
		// MethodDeclaration
		// Create a shared body?
		
		function MethodDeclaration(){ return Func.apply(this,arguments) };
		
		subclass$(MethodDeclaration,Func);
		exports.MethodDeclaration = MethodDeclaration; // export class 
		MethodDeclaration.prototype.variable = function(v){ return this._variable; }
		MethodDeclaration.prototype.setVariable = function(v){ this._variable = v; return this; };
		
		MethodDeclaration.prototype.scopetype = function (){
			return MethodScope;
		};
		
		MethodDeclaration.prototype.consume = function (node){
			if (node instanceof Return) {
				this.option('return',true);
				return this;
			};
			return MethodDeclaration.__super__.consume.apply(this,arguments);
		};
		
		MethodDeclaration.prototype.metadata = function (){
			return {
				type: "method",
				name: "" + this.name(),
				namepath: this.namepath(),
				params: this._params.metadata(),
				desc: this._desc,
				scopenr: this.scope()._nr,
				loc: this.loc()
			};
		};
		
		MethodDeclaration.prototype.loc = function (){
			var d;
			if (d = this.option('def')) {
				return [d._loc,this.body().loc()[1]];
			} else {
				return [0,0];
			};
		};
		
		
		MethodDeclaration.prototype.toJSON = function (){
			return this.metadata();
		};
		
		MethodDeclaration.prototype.namepath = function (){
			if (this._namepath) { return this._namepath };
			
			var name = String(this.name());
			var sep = (this.option('static') ? ('.') : ('#'));
			if (this.target()) {
				return this._namepath = this._target.namepath() + sep + name;
			} else {
				return this._namepath = '&' + name;
			};
		};
		
		MethodDeclaration.prototype.visit = function (){
			// @desc = stack.stash.pluck(Comment)
			// @desc = stack.stash.pluck(Comment)
			// prebreak # make sure this has a break?
			this.scope().visit();
			
			if (String(this.name()) == 'initialize') {
				this.setType('constructor');
			};
			
			if (this.option('greedy')) {
				this.warn("deprecated");
				// set(greedy: true)
				// p "BODY EXPRESSIONS!! This is a fragment"
				var tree = new TagTree();
				this._body = this.body().consume(tree);
				// body.nodes = [Arr.new(body.nodes)]
			};
			
			this._context = this.scope().parent().closure();
			this._params.traverse();
			
			if (this.target() instanceof Self) {
				this._target = this._context.context();
				this.set({static: true});
			};
			
			if (this.context() instanceof ClassScope) {
				this.context().annotate(this);
				this._target || (this._target = this.context().context());
				// register as class-method?
				// should register for this
				// console.log "context is classscope {@name}"
			};
			
			if (!this._target) {
				// should not be registered on the outermost closure?
				this._variable = this.context().register(this.name(),this,{type: 'meth'});
			};
			
			ROOT.entities().add(this.namepath(),this);
			this._body.traverse(); // so soon?
			return this;
		};
		
		MethodDeclaration.prototype.supername = function (){
			return this.type() == 'constructor' ? (this.type()) : (this.name());
		};
		
		
		// FIXME export global etc are NOT valid for methods inside any other scope than
		// the outermost scope (root)
		
		MethodDeclaration.prototype.js = function (o){
			// FIXME Do this in the grammar - remnants of old implementation
			if (!(this.type() == 'constructor' || this.option('noreturn'))) {
				if (this.option('greedy')) {
					// haaack
					this.body().consume(new GreedyReturn());
				} else {
					this.body().consume(new ImplicitReturn());
				};
			};
			
			var code = this.scope().c({indent: true,braces: true});
			
			// same for Func -- should generalize
			var name = typeof this._name == 'string' ? (this._name) : (this._name.c());
			name = name.replace(/\./g,'_');
			
			// var name = self.name.c.replace(/\./g,'_') # WHAT?
			var foot = [];
			
			var left = "";
			var func = ("(" + (this.params().c()) + ")") + code; // .wrap
			var target = this.target();
			var decl = !this.option('global') && !this.option('export');
			
			if (target instanceof ScopeContext) {
				// the target is a scope context
				target = null;
			};
			
			var ctx = this.context();
			var out = "";
			var mark = mark__(this.option('def'));
			// if ctx 
			
			var fname = sym__(this.name());
			// console.log "symbolize {self.name} -- {fname}"
			var fdecl = fname; // decl ? fname : ''
			
			if ((ctx instanceof ClassScope) && !target) {
				if (this.type() == 'constructor') {
					out = ("" + mark + "function " + fname + func);
				} else if (this.option('static')) {
					out = ("" + mark + (ctx.context().c()) + "." + fname + " = function " + func);
				} else {
					out = ("" + mark + (ctx.context().c()) + ".prototype." + fname + " = function " + func);
				};
			} else if ((ctx instanceof RootScope) && !target) {
				// register method as a root-function, but with auto-call? hmm
				// should probably set using variable directly instead, no?
				out = ("" + mark + "function " + fdecl + func);
			} else if (target && this.option('static')) {
				out = ("" + mark + (target.c()) + "." + fname + " = function " + func);
			} else if (target) {
				out = ("" + mark + (target.c()) + ".prototype." + fname + " = function " + func);
			} else {
				out = ("" + mark + "function " + fdecl + func);
			};
			
			if (this.option('global')) {
				out = ("" + fname + " = " + out);
			};
			
			if (this.option('export')) {
				out = ("" + out + "; exports." + fname + " = " + fname + ";");
				if (this.option('return')) { out = ("" + out + "; return " + fname + ";") };
			} else if (this.option('return')) {
				out = ("return " + out);
			};
			
			return out;
		};
		
		
		function TagFragmentDeclaration(){ return MethodDeclaration.apply(this,arguments) };
		
		subclass$(TagFragmentDeclaration,MethodDeclaration);
		exports.TagFragmentDeclaration = TagFragmentDeclaration; // export class 
		
		
		
		function PropertyDeclaration(name,options,token){
			this._token = token;
			this._traversed = false;
			this._name = name;
			this._options = options || new Obj(new AssignList());
		};
		
		subclass$(PropertyDeclaration,Node);
		exports.PropertyDeclaration = PropertyDeclaration; // export class 
		var propTemplate = '${headers}\n${path}.${getter} = function(v){ return ${get}; }\n${path}.${setter} = function(v){ ${set}; return this; }\n${init}';
		
		var propWatchTemplate = '${headers}\n${path}.${getter} = function(v){ return ${get}; }\n${path}.${setter} = function(v){\n	var a = this.${getter}();\n	if(v != a) { ${set}; }\n	if(v != a) { ${ondirty} }\n	return this;\n}\n${init}';
		
		PropertyDeclaration.prototype.name = function(v){ return this._name; }
		PropertyDeclaration.prototype.setName = function(v){ this._name = v; return this; };
		PropertyDeclaration.prototype.options = function(v){ return this._options; }
		PropertyDeclaration.prototype.setOptions = function(v){ this._options = v; return this; };
		
		PropertyDeclaration.prototype.visit = function (){
			this._options.traverse();
			return this;
		};
		
		// This will soon support bindings / listeners etc, much more
		// advanced generated code based on options passed in.
		PropertyDeclaration.prototype.c = function (){
			var o = this.options();
			var ast = "";
			var key = this.name().js();
			var scope = STACK.scope();
			
			var addDesc = o.keys().length;
			
			var pars = o.hash();
			
			var isAttr = (this._token && String(this._token) == 'attr') || o.key('attr');
			
			var js = {
				key: key,
				getter: key,
				setter: sym__(("set-" + key)),
				scope: ("" + (scope.context().c())),
				path: '${scope}.prototype',
				set: ("this._" + key + " = v"),
				get: ("this._" + key),
				init: "",
				headers: "",
				ondirty: ""
			};
			
			
			if (pars.inline) {
				if ((pars.inline instanceof Bool) && !pars.inline.truthy()) {
					o.remove('inline');
					// p "dont make attr inline(!)"
					return ("Imba." + (this._token) + "(" + (js.scope) + ",'" + (this.name().value()) + "'," + (o.c()) + ")").replace(',{})',')');
				};
				
				// p "pars inline?!? {pars:inline}", typeof pars:inline
			};
			
			var tpl = propTemplate;
			
			o.add('name',new Symbol(key));
			
			if (pars.watch) {
				// p "watch is a property {pars:watch}"
				if (!((pars.watch instanceof Bool) && !pars.watch.truthy())) { tpl = propWatchTemplate };
				var wfn = ("" + key + "DidSet");
				
				if (pars.watch instanceof Symbol) {
					wfn = pars.watch;
				} else if (pars.watch instanceof Bool) {
					o.key('watch').setValue(new Symbol(("" + key + "DidSet")));
				};
				
				var fn = OP('.',new This(),wfn);
				js.ondirty = OP('&&',fn,CALL(fn,['v','a',("this.__" + key)])).c();
			};
			
			if (pars.observe) {
				if (pars.observe instanceof Bool) {
					o.key('observe').setValue(new Symbol(("" + key + "DidEmit")));
				};
				
				tpl = propWatchTemplate;
				js.ondirty = ("Imba.observeProperty(this,'" + key + "'," + (o.key('observe').value().c()) + ",v,a);") + (js.ondirty || '');
				// OP('&&',fn,CALL(fn,['v','a',"this.__{key}"])).c
			};
			
			if ((this._token && String(this._token) == 'attr') || o.key('dom') || o.key('attr')) {
				var attrKey = o.key('dom') instanceof Str ? (o.key('dom')) : (this.name().value());
				// need to make sure o has a key for attr then - so that the delegate can know?
				js.set = ("this.setAttribute('" + attrKey + "',v)");
				js.get = ("this.getAttribute('" + attrKey + "')");
			} else if (o.key('delegate')) {
				// if we have a delegate
				js.set = ("v = this.__" + key + ".delegate.set(this,'" + key + "',v,this.__" + key + ")");
				js.get = ("this.__" + key + ".delegate.get(this,'" + key + "',this.__" + key + ")");
			};
			
			
			
			if (pars.default) {
				if (o.key('dom')) {
					// FIXME go through class-method setAttribute instead
					js.init = ("" + (js.scope) + ".dom().setAttribute('" + key + "'," + (pars.default.c()) + ");");
				} else {
					// if this is not a primitive - it MUST be included in the
					// getter / setter instead
					js.init = ("" + (js.scope) + ".prototype._" + key + " = " + (pars.default.c()) + ";");
				};
			};
			
			if (o.key('chainable')) {
				js.get = ("v !== undefined ? (this." + (js.setter) + "(v),this) : " + (js.get));
			};
			
			
			js.options = o.c();
			
			if (addDesc) {
				js.headers = ("" + (js.path) + ".__" + (js.getter) + " = " + (js.options) + ";");
			};
			
			var reg = /\$\{(\w+)\}/gm;
			// var tpl = o.key(:watch) ? propWatchTemplate : propTemplate
			var out = tpl.replace(reg,function(m,a) { return js[a]; });
			// run another time for nesting. hacky
			out = out.replace(reg,function(m,a) { return js[a]; });
			// out = out.replace(/\n\s*$/,'')
			out = out.replace(/^\s+|\s+$/g,'');
			
			// if o.key(:v)
			return out;
		};
		
		
		
		// Literals should probably not inherit from the same parent
		// as arrays, tuples, objects would be better off inheriting
		// from listnode.
		
		function Literal(v){
			this._traversed = false;
			this._expression = true;
			this._cache = null;
			this._raw = null;
			this._value = v;
		};
		
		subclass$(Literal,ValueNode);
		exports.Literal = Literal; // export class 
		Literal.prototype.toString = function (){
			return "" + this.value();
		};
		
		Literal.prototype.hasSideEffects = function (){
			return false;
		};
		
		
		function Bool(v){
			this._value = v;
			this._raw = String(v) == "true" ? (true) : (false);
		};
		
		subclass$(Bool,Literal);
		exports.Bool = Bool; // export class 
		Bool.prototype.cache = function (){
			return this;
		};
		
		Bool.prototype.isPrimitive = function (){
			return true;
		};
		
		Bool.prototype.truthy = function (){
			// p "bool is truthy? {value}"
			return String(this.value()) == "true";
			// yes
		};
		
		Bool.prototype.js = function (o){
			return String(this._value);
		};
		
		Bool.prototype.c = function (){
			STACK._counter += 1;
			// undefined should not be a bool
			return String(this._value);
			// @raw ? "true" : "false"
		};
		
		Bool.prototype.toJSON = function (){
			return {type: 'Bool',value: this._value};
		};
		
		function Undefined(){ return Literal.apply(this,arguments) };
		
		subclass$(Undefined,Literal);
		exports.Undefined = Undefined; // export class 
		Undefined.prototype.isPrimitive = function (){
			return true;
		};
		
		Undefined.prototype.c = function (){
			return mark__(this._value) + "undefined";
		};
		
		function Nil(){ return Literal.apply(this,arguments) };
		
		subclass$(Nil,Literal);
		exports.Nil = Nil; // export class 
		Nil.prototype.isPrimitive = function (){
			return true;
		};
		
		Nil.prototype.c = function (){
			return mark__(this._value) + "null";
		};
		
		function True(){ return Bool.apply(this,arguments) };
		
		subclass$(True,Bool);
		exports.True = True; // export class 
		True.prototype.raw = function (){
			return true;
		};
		
		True.prototype.c = function (){
			return mark__(this._value) + "true";
		};
		
		function False(){ return Bool.apply(this,arguments) };
		
		subclass$(False,Bool);
		exports.False = False; // export class 
		False.prototype.raw = function (){
			return false;
		};
		
		False.prototype.c = function (){
			return mark__(this._value) + "false";
		};
		
		function Num(v){
			this._traversed = false;
			this._value = v;
		};
		
		subclass$(Num,Literal);
		exports.Num = Num; // export class 
		Num.prototype.toString = function (){
			return String(this._value);
		};
		
		Num.prototype.isPrimitive = function (deep){
			return true;
		};
		
		Num.prototype.shouldParenthesize = function (par){
			if(par === undefined) par = this.up();
			return (par instanceof Access) && par.left() == this;
		};
		
		Num.prototype.js = function (o){
			var num = String(this._value);
			// console.log "compiled num to {num}"
			return num;
		};
		
		Num.prototype.c = function (o){
			if (this._cache) { return Num.__super__.c.call(this,o) };
			var js = String(this._value);
			var par = STACK.current();
			var paren = (par instanceof Access) && par.left() == this;
			// only if this is the right part of teh acces
			// console.log "should paren?? {shouldParenthesize}"
			return paren ? (("(" + mark__(this._value)) + js + ")") : ((mark__(this._value) + js));
			// @cache ? super(o) : String(@value)
		};
		
		Num.prototype.cache = function (o){
			// p "cache num",o
			if (!(o && (o.cache || o.pool))) { return this };
			return Num.__super__.cache.call(this,o);
		};
		
		Num.prototype.raw = function (){
			// really?
			return JSON.parse(String(this.value()));
		};
		
		Num.prototype.toJSON = function (){
			return {type: this.typeName(),value: this.raw()};
		};
		
		// should be quoted no?
		// what about strings in object-literals?
		// we want to be able to see if the values are allowed
		function Str(v){
			this._traversed = false;
			this._expression = true;
			this._cache = null;
			this._value = v;
			// should grab the actual value immediately?
		};
		
		subclass$(Str,Literal);
		exports.Str = Str; // export class 
		Str.prototype.isString = function (){
			return true;
		};
		
		Str.prototype.isPrimitive = function (deep){
			return true;
		};
		
		Str.prototype.raw = function (){
			// JSON.parse requires double-quoted strings,
			// while eval also allows single quotes. 
			// NEXT eval is not accessible like this
			// WARNING TODO be careful! - should clean up
			
			return this._raw || (this._raw = String(this.value()).slice(1,-1)); // incredibly stupid solution
		};
		
		Str.prototype.isValidIdentifier = function (){
			// there are also some values we cannot use
			return this.raw().match(/^[a-zA-Z\$\_]+[\d\w\$\_]*$/) ? (true) : (false);
		};
		
		Str.prototype.js = function (o){
			return String(this._value);
		};
		
		Str.prototype.c = function (o){
			return this._cache ? (Str.__super__.c.call(this,o)) : (String(this._value));
		};
		
		
		function Interpolation(){ return ValueNode.apply(this,arguments) };
		
		subclass$(Interpolation,ValueNode);
		exports.Interpolation = Interpolation; // export class 
		
		
		// Currently not used - it would be better to use this
		// for real interpolated strings though, than to break
		// them up into their parts before parsing
		function InterpolatedString(nodes,o){
			if(o === undefined) o = {};
			this._nodes = nodes;
			this._options = o;
			this;
		};
		
		subclass$(InterpolatedString,Node);
		exports.InterpolatedString = InterpolatedString; // export class 
		InterpolatedString.prototype.add = function (part){
			if (part) { this._nodes.push(part) };
			return this;
		};
		
		InterpolatedString.prototype.visit = function (){
			for (var i = 0, ary = iter$(this._nodes), len = ary.length; i < len; i++) {
				ary[i].traverse();
			};
			return this;
		};
		
		InterpolatedString.prototype.escapeString = function (str){
			// var idx = 0
			// var len = str:length
			// var chr
			// while chr = str[idx++]
			return str = str.replace(/\n/g,'\\\n');
		};
		
		InterpolatedString.prototype.js = function (o){
			// creating the string
			var self = this;
			var parts = [];
			var str = '(';
			
			self._nodes.map(function(part,i) {
				if ((part instanceof Token) && part._type == 'NEOSTRING') {
					// esca
					return parts.push('"' + self.escapeString(part._value) + '"');
				} else if (part) {
					if (i == 0) {
						// force first part to be string
						parts.push('""');
					};
					part._parens = true;
					return parts.push(part.c({expression: true}));
				};
			});
			
			str += parts.join(" + ");
			str += ')';
			return str;
		};
		
		
		function Tuple(){ return ListNode.apply(this,arguments) };
		
		subclass$(Tuple,ListNode);
		exports.Tuple = Tuple; // export class 
		Tuple.prototype.c = function (){
			// compiles as an array
			return new Arr(this.nodes()).c();
		};
		
		Tuple.prototype.hasSplat = function (){
			return this.filter(function(v) { return v instanceof Splat; })[0];
		};
		
		Tuple.prototype.consume = function (node){
			if (this.count() == 1) {
				return this.first().consume(node);
			} else {
				throw "multituple cannot consume";
			};
		};
		
		
		// Because we've dropped the Str-wrapper it is kinda difficult
		function Symbol(){ return Literal.apply(this,arguments) };
		
		subclass$(Symbol,Literal);
		exports.Symbol = Symbol; // export class 
		Symbol.prototype.isValidIdentifier = function (){
			return this.raw().match(/^[a-zA-Z\$\_]+[\d\w\$\_]*$/) ? (true) : (false);
		};
		
		Symbol.prototype.isPrimitive = function (deep){
			return true;
		};
		
		Symbol.prototype.raw = function (){
			return this._raw || (this._raw = sym__(this.value()));
		};
		
		Symbol.prototype.js = function (o){
			return ("'" + sym__(this.value()) + "'");
		};
		
		function RegExp(){ return Literal.apply(this,arguments) };
		
		subclass$(RegExp,Literal);
		exports.RegExp = RegExp; // export class 
		RegExp.prototype.isPrimitive = function (){
			return true;
		};
		
		// def toString
		// 	"" + value
		;
		
		// Should inherit from ListNode - would simplify
		function Arr(){ return Literal.apply(this,arguments) };
		
		subclass$(Arr,Literal);
		exports.Arr = Arr; // export class 
		Arr.prototype.load = function (value){
			return value instanceof Array ? (new ArgList(value)) : (value);
		};
		
		Arr.prototype.push = function (item){
			this.value().push(item);
			return this;
		};
		
		Arr.prototype.count = function (){
			return this.value().length;
		};
		
		Arr.prototype.nodes = function (){
			var val = this.value();
			return val instanceof Array ? (val) : (val.nodes());
		};
		
		Arr.prototype.splat = function (){
			return this.value().some(function(v) { return v instanceof Splat; });
		};
		
		Arr.prototype.visit = function (){
			if (this._value && this._value.traverse) { this._value.traverse() };
			return this;
		};
		
		Arr.prototype.isPrimitive = function (deep){
			return !this.value().some(function(v) { return !v.isPrimitive(true); });
		};
		
		Arr.prototype.js = function (o){
			
			var val = this._value;
			if (!val) { return "[]" };
			
			var splat = this.splat();
			var nodes = val instanceof Array ? (val) : (val.nodes());
			// p "value of array isa {@value}"
			
			// for v in @value
			// 	break splat = yes if v isa Splat
			// var splat = value.some(|v| v isa Splat)
			
			if (splat) {
				// "SPLATTED ARRAY!"
				// if we know for certain that the splats are arrays we can drop the slice?
				// p "array is splat?!?"
				var slices = [];
				var group = null;
				
				for (var i = 0, ary = iter$(nodes), len = ary.length, v; i < len; i++) {
					v = ary[i];
					if (v instanceof Splat) {
						slices.push(v);
						group = null;
					} else {
						if (!group) { slices.push(group = new Arr([])) };
						group.push(v);
					};
				};
				
				return ("[].concat(" + cary__(slices).join(", ") + ")");
			} else {
				// very temporary. need a more generic way to prettify code
				// should depend on the length of the inner items etc
				// if @indented or option(:indent) or value.@indented
				//	"[\n{value.c.join(",\n").indent}\n]"
				var out = val instanceof Array ? (cary__(val)) : (val.c());
				return ("[" + out + "]");
			};
		};
		
		Arr.prototype.hasSideEffects = function (){
			return this.value().some(function(v) { return v.hasSideEffects(); });
		};
		
		Arr.prototype.toString = function (){
			return "Arr";
		};
		
		Arr.prototype.indented = function (a,b){
			this._value.indented(a,b);
			return this;
		};
		
		Arr.wrap = function (val){
			return new Arr(val);
		};
		
		// should not be cklassified as a literal?
		function Obj(){ return Literal.apply(this,arguments) };
		
		subclass$(Obj,Literal);
		exports.Obj = Obj; // export class 
		Obj.prototype.load = function (value){
			return value instanceof Array ? (new AssignList(value)) : (value);
		};
		
		Obj.prototype.visit = function (){
			if (this._value) { this._value.traverse() };
			// for v in value
			// 	v.traverse
			return this;
		};
		
		Obj.prototype.js = function (o){
			var dyn = this.value().filter(function(v) { return (v instanceof ObjAttr) && ((v.key() instanceof Op) || (v.key() instanceof InterpolatedString)); });
			
			if (dyn.length > 0) {
				var idx = this.value().indexOf(dyn[0]);
				// p "dynamic keys! {dyn}"
				// create a temp variable
				
				var tmp = this.scope__().temporary(this);
				// set the temporary object to the same
				var first = this.value().slice(0,idx);
				var obj = new Obj(first);
				var ast = [OP('=',tmp,obj)];
				
				this.value().slice(idx).forEach(function(atr) {
					return ast.push(OP('=',OP('.',tmp,atr.key()),atr.value()));
				});
				ast.push(tmp); // access the tmp at in the last part
				return new Parens(ast).c();
			};
			
			// for objects with expression-keys we need to think differently
			return '{' + this.value().c() + '}';
		};
		
		Obj.prototype.add = function (k,v){
			if ((typeof k=='string'||k instanceof String)) { k = new Identifier(k) };
			var kv = new ObjAttr(k,v);
			this.value().push(kv);
			return kv;
		};
		
		Obj.prototype.remove = function (key){
			for (var i = 0, ary = iter$(this.value()), len = ary.length, k; i < len; i++) {
				k = ary[i];
				if (k.key().symbol() == key) { this.value().remove(k) };
			};
			return this;
		};
		
		Obj.prototype.keys = function (){
			return Object.keys(this.hash());
		};
		
		Obj.prototype.hash = function (){
			var hash = {};
			for (var i = 0, ary = iter$(this.value()), len = ary.length, k; i < len; i++) {
				k = ary[i];
				if (k instanceof ObjAttr) { hash[k.key().symbol()] = k.value() };
			};
			return hash;
			// return k if k.key.symbol == key
		};
		
		// add method for finding properties etc?
		Obj.prototype.key = function (key){
			for (var i = 0, ary = iter$(this.value()), len = ary.length, k; i < len; i++) {
				k = ary[i];
				if ((k instanceof ObjAttr) && k.key().symbol() == key) { return k };
			};
			return null;
		};
		
		Obj.prototype.indented = function (a,b){
			this._value.indented(a,b);
			return this;
		};
		
		Obj.prototype.hasSideEffects = function (){
			return this.value().some(function(v) { return v.hasSideEffects(); });
		};
		
		// for converting a real object into an ast-representation
		Obj.wrap = function (obj){
			var attrs = [];
			for (var v, i = 0, keys = Object.keys(obj), l = keys.length; i < l; i++){
				v = obj[keys[i]];if (v instanceof Array) {
					v = Arr.wrap(v);
				} else if (v.constructor == Object) {
					v = Obj.wrap(v);
				};
				attrs.push(new ObjAttr(keys[i],v));
			};
			return new Obj(attrs);
		};
		
		Obj.prototype.toString = function (){
			return "Obj";
		};
		
		function ObjAttr(key,value){
			this._traversed = false;
			this._key = key;
			this._value = value;
			this._dynamic = (key instanceof Op);
			this;
		};
		
		subclass$(ObjAttr,Node);
		exports.ObjAttr = ObjAttr; // export class 
		ObjAttr.prototype.key = function(v){ return this._key; }
		ObjAttr.prototype.setKey = function(v){ this._key = v; return this; };
		ObjAttr.prototype.value = function(v){ return this._value; }
		ObjAttr.prototype.setValue = function(v){ this._value = v; return this; };
		ObjAttr.prototype.options = function(v){ return this._options; }
		ObjAttr.prototype.setOptions = function(v){ this._options = v; return this; };
		
		ObjAttr.prototype.visit = function (){
			// should probably traverse key as well, unless it is a dead simple identifier
			this.key().traverse();
			return this.value().traverse();
		};
		
		ObjAttr.prototype.js = function (o){
			var k = this.key().isReserved() ? (("'" + (this.key().c()) + "'")) : (this.key().c());
			return ("" + k + ": " + (this.value().c()));
		};
		
		ObjAttr.prototype.hasSideEffects = function (){
			return true;
		};
		
		
		
		function ArgsReference(){ return Node.apply(this,arguments) };
		
		subclass$(ArgsReference,Node);
		exports.ArgsReference = ArgsReference; // export class 
		ArgsReference.prototype.c = function (){
			return "arguments";
		};
		
		// should be a separate Context or something
		function Self(scope){
			this._scope = scope;
		};
		
		subclass$(Self,Literal);
		exports.Self = Self; // export class 
		Self.prototype.scope = function(v){ return this._scope; }
		Self.prototype.setScope = function(v){ this._scope = v; return this; };
		
		Self.prototype.cache = function (){
			return this;
		};
		
		Self.prototype.reference = function (){
			return this;
		};
		
		Self.prototype.c = function (){
			var s = this.scope__();
			return s ? (s.context().c()) : ("this");
		};
		
		function ImplicitSelf(){ return Self.apply(this,arguments) };
		
		subclass$(ImplicitSelf,Self);
		exports.ImplicitSelf = ImplicitSelf; // export class 
		
		
		function This(){ return Self.apply(this,arguments) };
		
		subclass$(This,Self);
		exports.This = This; // export class 
		This.prototype.cache = function (){
			return this;
		};
		
		This.prototype.reference = function (){
			// p "referencing this"
			return this;
		};
		
		This.prototype.c = function (){
			return "this";
		};
		
		
		
		
		// OPERATORS
		
		function Op(o,l,r){
			// set expression yes, no?
			this._expression = false;
			this._traversed = false;
			this._parens = false;
			this._cache = null;
			this._invert = false;
			this._opToken = o;
			this._op = o && o._value || o;
			this._left = l;
			this._right = r;
			return this;
		};
		
		subclass$(Op,Node);
		exports.Op = Op; // export class 
		Op.prototype.op = function(v){ return this._op; }
		Op.prototype.setOp = function(v){ this._op = v; return this; };
		Op.prototype.left = function(v){ return this._left; }
		Op.prototype.setLeft = function(v){ this._left = v; return this; };
		Op.prototype.right = function(v){ return this._right; }
		Op.prototype.setRight = function(v){ this._right = v; return this; };
		
		Op.prototype.visit = function (){
			if (this._right) { this._right.traverse() };
			if (this._left) { this._left.traverse() };
			return this;
		};
		
		Op.prototype.isExpressable = function (){
			// what if right is a string?!?
			return !(this.right()) || this.right().isExpressable();
		};
		
		Op.prototype.js = function (o){
			var out = null;
			var op = this._op;
			
			var l = this._left;
			var r = this._right;
			
			if (l instanceof Node) { l = l.c() };
			if (r instanceof Node) { r = r.c() };
			
			if (l && r) {
				out = ("" + l + " " + mark__(this._opToken) + op + " " + r);
			} else if (l) {
				out = ("" + mark__(this._opToken) + op + l);
			};
			// out = out.parenthesize if up isa Op # really?
			return out;
		};
		
		Op.prototype.shouldParenthesize = function (){
			return this._parens;
			// option(:parens)
		};
		
		Op.prototype.precedence = function (){
			return 10;
		};
		
		Op.prototype.consume = function (node){
			// p 'assignify if?!'
			// if it is possible, convert into expression
			if (node instanceof TagTree) {
				if (this._left) { this._left.consume(node) };
				if (this._right) { this._right.consume(node) };
				// @body = @body.consume(node)
				// @alt = @alt.consume(node) if @alt
				return this;
			};
			// p "Op.consume {node}".cyan
			if (this.isExpressable()) { return Op.__super__.consume.apply(this,arguments) };
			
			// TODO can rather use global caching?
			var tmpvar = this.scope__().declare('tmp',null,{system: true});
			var clone = OP(this.op(),this.left(),null);
			var ast = this.right().consume(clone);
			if (node) { ast.consume(node) };
			return ast;
		};
		
		function ComparisonOp(){ return Op.apply(this,arguments) };
		
		subclass$(ComparisonOp,Op);
		exports.ComparisonOp = ComparisonOp; // export class 
		ComparisonOp.prototype.invert = function (){
			// are there other comparison ops?
			// what about a chain?
			var op = this._op;
			var pairs = ["==","!=","===","!==",">","<=","<",">="];
			var idx = pairs.indexOf(op);
			idx += (idx % 2 ? (-1) : (1));
			
			// p "invert {@op}"
			// p "inverted comparison(!) {idx} {op} -> {pairs[idx]}"
			this.setOp(pairs[idx]);
			this._invert = !this._invert;
			return this;
		};
		
		ComparisonOp.prototype.c = function (){
			if (this.left() instanceof ComparisonOp) {
				this.left().right().cache();
				return OP('&&',this.left(),OP(this.op(),this.left().right(),this.right())).c();
			} else {
				return ComparisonOp.__super__.c.apply(this,arguments);
			};
		};
		
		ComparisonOp.prototype.js = function (o){
			var op = this._op;
			var l = this._left;
			var r = this._right;
			
			if (l instanceof Node) { l = l.c() };
			if (r instanceof Node) { r = r.c() };
			return ("" + l + " " + mark__(this._opToken) + op + " " + r);
		};
		
		
		function MathOp(){ return Op.apply(this,arguments) };
		
		subclass$(MathOp,Op);
		exports.MathOp = MathOp; // export class 
		MathOp.prototype.c = function (){
			if (this.op() == '∪') {
				return this.util().union(this.left(),this.right()).c();
			} else if (this.op() == '∩') {
				return this.util().intersect(this.left(),this.right()).c();
			};
		};
		
		
		function UnaryOp(){ return Op.apply(this,arguments) };
		
		subclass$(UnaryOp,Op);
		exports.UnaryOp = UnaryOp; // export class 
		UnaryOp.prototype.invert = function (){
			if (this.op() == '!') {
				return this.left();
			} else {
				return UnaryOp.__super__.invert.apply(this,arguments); // regular invert
			};
		};
		
		UnaryOp.prototype.js = function (o){
			var l = this._left;
			var r = this._right;
			// all of this could really be done i a much
			// cleaner way.
			// l.set(parens: yes) if l # are we really sure about this?
			// r.set(parens: yes) if r
			
			if (this.op() == '!') {
				// l.@parens = yes
				var str = l.c();
				var paren = l.shouldParenthesize(this);
				// p "check for parens in !: {str} {l} {l.@parens} {l.shouldParenthesize(self)}"
				// FIXME this is a very hacky workaround. Need to handle all this
				// in the child instead, problems arise due to automatic caching
				if (!(str.match(/^\!?([\w\.]+)$/) || (l instanceof Parens) || paren || (l instanceof Access) || (l instanceof Call))) { str = '(' + str + ')' };
				// l.set(parens: yes) # sure?
				return ("" + this.op() + str);
			} else if (this.op() == '√') {
				return ("Math.sqrt(" + (l.c()) + ")");
			} else if (this.left()) {
				return ("" + (l.c()) + this.op());
			} else {
				return ("" + this.op() + (r.c()));
			};
		};
		
		UnaryOp.prototype.normalize = function (){
			if (this.op() == '!' || this.op() == '√') { return this };
			var node = (this.left() || this.right()).node();
			// for property-accessors we need to rewrite the ast
			if (!((node instanceof PropertyAccess))) { return this };
			
			// ask to cache the path
			if ((node instanceof Access) && node.left()) { node.left().cache() };
			
			var num = new Num(1);
			var ast = OP('=',node,OP(this.op()[0],node,num));
			if (this.left()) { ast = OP(this.op()[0] == '-' ? ('+') : ('-'),ast,num) };
			
			return ast;
		};
		
		UnaryOp.prototype.consume = function (node){
			var norm = this.normalize();
			return norm == this ? (UnaryOp.__super__.consume.apply(this,arguments)) : (norm.consume(node));
		};
		
		UnaryOp.prototype.c = function (){
			var norm = this.normalize();
			return norm == this ? (UnaryOp.__super__.c.apply(this,arguments)) : (norm.c());
		};
		
		function InstanceOf(){ return Op.apply(this,arguments) };
		
		subclass$(InstanceOf,Op);
		exports.InstanceOf = InstanceOf; // export class 
		InstanceOf.prototype.js = function (o){
			// fix checks for String and Number
			// p right.inspect
			
			if (this.right() instanceof Const) {
				// WARN otherwise - what do we do? does not work with dynamic
				// classes etc? Should probably send to utility function isa$
				var name = c__(this.right().value());
				var obj = this.left().node();
				// TODO also check for primitive-constructor
				if (idx$(name,['String','Number','Boolean']) >= 0) {
					if (!((obj instanceof LocalVarAccess))) {
						obj.cache();
					};
					// need a double check for these (cache left) - possibly
					return ("(typeof " + (obj.c()) + "=='" + (name.toLowerCase()) + "'||" + (obj.c()) + " instanceof " + name + ")");
					
					// convert
				};
			};
			var out = ("" + (this.left().c()) + " " + this.op() + " " + (this.right().c()));
			
			// should this not happen in #c?
			if (o.parent() instanceof Op) { out = helpers.parenthesize(out) };
			return out;
		};
		
		function TypeOf(){ return Op.apply(this,arguments) };
		
		subclass$(TypeOf,Op);
		exports.TypeOf = TypeOf; // export class 
		TypeOf.prototype.js = function (o){
			return ("typeof " + (this.left().c()));
		};
		
		function Delete(){ return Op.apply(this,arguments) };
		
		subclass$(Delete,Op);
		exports.Delete = Delete; // export class 
		Delete.prototype.js = function (o){
			// TODO this will execute calls several times if the path is not directly to an object
			// need to cache the receiver
			var l = this.left();
			var tmp = this.scope__().temporary(this,{pool: 'val'});
			var o = OP('=',tmp,l);
			// FIXME
			return ("(" + (o.c()) + ",delete " + (l.c()) + ", " + (tmp.c()) + ")"); // oh well
			// var ast = [OP('=',tmp,left),"delete {left.c}",tmp]
			// should parenthesize directly no?
			// ast.c
		};
		
		Delete.prototype.shouldParenthesize = function (){
			return true;
		};
		
		function In(){ return Op.apply(this,arguments) };
		
		subclass$(In,Op);
		exports.In = In; // export class 
		In.prototype.invert = function (){
			this._invert = !this._invert;
			return this;
		};
		
		In.prototype.js = function (o){
			var cond = this._invert ? ("== -1") : (">= 0");
			var idx = Util.indexOf(this.left(),this.right());
			return ("" + (idx.c()) + " " + cond);
		};
		
		
		
		
		
		
		
		// ACCESS
		
		module.exports.K_IVAR = K_IVAR = 1;
		module.exports.K_SYM = K_SYM = 2;
		module.exports.K_STR = K_STR = 3;
		module.exports.K_PROP = K_PROP = 4;
		
		function Access(o,l,r){
			// set expression yes, no?
			this._expression = false;
			this._traversed = false;
			this._parens = false;
			this._cache = null;
			this._invert = false;
			this._op = o && o._value || o;
			this._left = l;
			this._right = r;
			return this;
		};
		
		subclass$(Access,Op);
		exports.Access = Access; // export class 
		Access.prototype.clone = function (left,right){
			var ctor = this.constructor;
			return new ctor(this.op(),left,right);
		};
		
		Access.prototype.js = function (o){
			var r;
			var raw = null;
			var rgt = this.right();
			var ctx = (this.left() || this.scope__().context());
			var pre = "";
			var mark = '';
			
			// if safechain
			//	p "Access is safechained {rgt.c}"
			
			
			if (rgt instanceof Num) {
				return ctx.c() + "[" + rgt.c() + "]";
			};
			
			// is this right? Should not the index compile the brackets
			// or value is a symbol -- should be the same, no?
			if ((rgt instanceof Index) && ((rgt.value() instanceof Str) || (rgt.value() instanceof Symbol))) {
				rgt = rgt.value();
			};
			
			// TODO do the identifier-validation in a central place instead
			if ((rgt instanceof Str) && rgt.isValidIdentifier()) {
				raw = rgt.raw();
			} else if ((rgt instanceof Symbol) && rgt.isValidIdentifier()) {
				raw = rgt.raw();
			} else if ((rgt instanceof Identifier) && rgt.isValidIdentifier()) {
				mark = mark__(rgt._value);
				raw = rgt.c();
			};
			
			if (this.safechain() && ctx) {
				ctx.cache({force: true});
				pre = ctx.c() + " && ";
			};
			
			// really?
			// var ctx = (left || scope__.context)
			var out = raw ? (
				// see if it needs quoting
				// need to check to see if it is legal
				ctx ? (("" + (ctx.c()) + "." + mark + raw)) : (raw)
			) : (
				r = rgt instanceof Node ? (rgt.c({expression: true})) : (rgt),
				("" + (ctx.c()) + "[" + r + "]")
			);
			
			// if safechain and ctx
			// 	out = "{ctx.c} && {out}"
			
			return pre + out;
		};
		
		Access.prototype.visit = function (){
			if (this.left()) { this.left().traverse() };
			if (this.right()) { this.right().traverse() };
			return;
		};
		
		Access.prototype.isExpressable = function (){
			return true;
		};
		
		Access.prototype.alias = function (){
			return this.right() instanceof Identifier ? (this.right().alias()) : (Access.__super__.alias.call(this));
		};
		
		Access.prototype.safechain = function (){
			// right.safechain
			return String(this._op) == '?.' || String(this._op) == '?:';
		};
		
		Access.prototype.cache = function (o){
			return ((this.right() instanceof Ivar) && !(this.left())) ? (this) : (Access.__super__.cache.call(this,o));
		};
		
		
		
		// Should change this to just refer directly to the variable? Or VarReference
		function LocalVarAccess(){ return Access.apply(this,arguments) };
		
		subclass$(LocalVarAccess,Access);
		exports.LocalVarAccess = LocalVarAccess; // export class 
		LocalVarAccess.prototype.safechain = function(v){ return this._safechain; }
		LocalVarAccess.prototype.setSafechain = function(v){ this._safechain = v; return this; };
		
		LocalVarAccess.prototype.js = function (o){
			if ((this.right() instanceof Variable) && this.right().type() == 'meth') {
				if (!((this.up() instanceof Call))) { return ("" + (this.right().c()) + "()") };
			};
			
			return this.right().c();
		};
		
		LocalVarAccess.prototype.variable = function (){
			return this.right();
		};
		
		LocalVarAccess.prototype.cache = function (o){
			if(o === undefined) o = {};
			if (o.force) { LocalVarAccess.__super__.cache.call(this,o) };
			return this;
		};
		
		LocalVarAccess.prototype.alias = function (){
			return this.variable()._alias || LocalVarAccess.__super__.alias.call(this);
		};
		
		
		function GlobalVarAccess(){ return ValueNode.apply(this,arguments) };
		
		subclass$(GlobalVarAccess,ValueNode);
		exports.GlobalVarAccess = GlobalVarAccess; // export class 
		GlobalVarAccess.prototype.js = function (o){
			return this.value().c();
		};
		
		
		function ObjectAccess(){ return Access.apply(this,arguments) };
		
		subclass$(ObjectAccess,Access);
		exports.ObjectAccess = ObjectAccess; // export class 
		
		
		
		function PropertyAccess(o,l,r){
			this._traversed = false;
			this._invert = false;
			this._parens = false;
			this._expression = false; // yes?
			this._cache = null;
			this._op = o;
			this._left = l;
			this._right = r;
			return this;
		};
		
		subclass$(PropertyAccess,Access);
		exports.PropertyAccess = PropertyAccess; // export class 
		PropertyAccess.prototype.visit = function (){
			if (this._right) { this._right.traverse() };
			if (this._left) { this._left.traverse() };
			return this;
		};
		
		// right in c we should possibly override
		// to create a call and regular access instead
		
		PropertyAccess.prototype.js = function (o){
			
			var rec;
			if (rec = this.receiver()) {
				// p "converting to call"
				var ast = CALL(OP('.',this.left(),this.right()),[]); // convert to ArgList or null
				ast.setReceiver(rec);
				return ast.c();
			};
			
			var up = this.up();
			
			if (!((up instanceof Call))) {
				// p "convert to call instead"
				ast = CALL(new Access(this.op(),this.left(),this.right()),[]);
				return ast.c();
			};
			
			// really need to fix this - for sure
			// should be possible for the function to remove this this instead?
			var js = ("" + PropertyAccess.__super__.js.call(this,o));
			
			if (!((up instanceof Call) || (up instanceof Util.IsFunction))) {
				// p "Called"
				js += "()";
			};
			
			return js;
		};
		
		
		PropertyAccess.prototype.receiver = function (){
			if ((this.left() instanceof SuperAccess) || (this.left() instanceof Super)) {
				return SELF;
			} else {
				return null;
			};
		};
		
		
		function IvarAccess(){ return Access.apply(this,arguments) };
		
		subclass$(IvarAccess,Access);
		exports.IvarAccess = IvarAccess; // export class 
		IvarAccess.prototype.cache = function (){
			// WARN hmm, this is not right... when accessing on another object it will need to be cached
			return this;
		};
		
		
		function ConstAccess(){ return Access.apply(this,arguments) };
		
		subclass$(ConstAccess,Access);
		exports.ConstAccess = ConstAccess; // export class 
		
		
		
		function IndexAccess(){ return Access.apply(this,arguments) };
		
		subclass$(IndexAccess,Access);
		exports.IndexAccess = IndexAccess; // export class 
		IndexAccess.prototype.cache = function (o){
			if(o === undefined) o = {};
			if (o.force) { return IndexAccess.__super__.cache.apply(this,arguments) };
			this.right().cache();
			return this;
		};
		
		
		function SuperAccess(){ return Access.apply(this,arguments) };
		
		subclass$(SuperAccess,Access);
		exports.SuperAccess = SuperAccess; // export class 
		SuperAccess.prototype.js = function (o){
			var m = o.method();
			var up = o.parent();
			var deep = (o.parent() instanceof Access);
			
			var out = ("" + (this.left().c()) + ".__super__");
			
			if (!((up instanceof Access))) {
				out += ("." + (m.supername().c()));
				if (!((up instanceof Call))) { // autocall?
					out += (".apply(" + (m.scope().context().c()) + ",arguments)");
				};
			};
			
			return out;
		};
		
		SuperAccess.prototype.receiver = function (){
			return SELF;
		};
		
		
		function VarOrAccess(value){
			// should rather call up to valuenode?
			this._traversed = false;
			this._parens = false;
			this._value = value;
			this._identifier = value;
			this._token = value._value;
			this._variable = null;
			this;
		};
		
		// Shortcircuit traverse so that it is not added to the stack?!
		subclass$(VarOrAccess,ValueNode);
		exports.VarOrAccess = VarOrAccess; // export class 
		VarOrAccess.prototype.visit = function (){
			// @identifier = value # this is not a real identifier?
			// console.log "VarOrAccess {@identifier}"
			// p "visit {self}"
			
			
			var scope = this.scope__();
			
			var variable = scope.lookup(this.value());
			
			// does not really need to have a declarator already? -- tricky
			if (variable && variable.declarator()) {
				// var decl = variable.declarator
				
				// if the variable is not initialized just yet and we are
				// in the same scope - we should not treat this as a var-lookup
				// ie.  var x = x would resolve to var x = this.x() if x
				// was not previously defined
				
				// should do this even if we are not in the same scope?
				// we only need to be in the same closure(!)
				
				if (variable._initialized || (scope.closure() != variable.scope().closure())) {
					this._variable = variable;
					variable.addReference(this);
					this._value = variable; // variable.accessor(self)
					this._token._variable = variable;
					return this;
				};
				
				// p "var is not yet initialized!"
				// p "declarator for var {decl.@declared}"
				// FIX
				// @value.safechain = safechain
			};
			
			// TODO deprecate and remove
			if (this.value().symbol().indexOf('$') >= 0) {
				// big hack - should disable
				// major hack here, no?
				// console.log "GlobalVarAccess"
				this._value = new GlobalVarAccess(this.value());
				return this;
			};
			
			// really? what about just mimicking the two diffrent instead?
			// Should we not return a call directly instead?
			this._value = new PropertyAccess(".",scope.context(),this.value());
			// mark the scope / context -- so we can show correct implicit
			this._token._meta = {type: 'ACCESS'};
			// @value.traverse # nah
			return this;
		};
		
		VarOrAccess.prototype.c = function (){
			return mark__(this._token) + (this._variable ? (VarOrAccess.__super__.c.call(this)) : (this.value().c()));
		};
		
		VarOrAccess.prototype.js = function (o){
			
			var v;
			if (v = this._variable) {
				var out = v.c();
				if (v._type == 'meth' && !(o.up() instanceof Call)) { out += "()" };
				return out;
			};
			return "NONO";
		};
		
		VarOrAccess.prototype.node = function (){
			return this._variable ? (this) : (this.value());
		};
		
		VarOrAccess.prototype.symbol = function (){
			return this._identifier.symbol();
			// value and value.symbol
		};
		
		VarOrAccess.prototype.cache = function (o){
			if(o === undefined) o = {};
			return this._variable ? ((o.force && VarOrAccess.__super__.cache.call(this,o))) : (this.value().cache(o));
			// should we really cache this?
			// value.cache(o)
		};
		
		VarOrAccess.prototype.decache = function (){
			this._variable ? (VarOrAccess.__super__.decache.call(this)) : (this.value().decache());
			return this;
		};
		
		VarOrAccess.prototype.dom = function (){
			return this.value().dom();
		};
		
		VarOrAccess.prototype.safechain = function (){
			return this._identifier.safechain();
		};
		
		VarOrAccess.prototype.dump = function (){
			return {loc: this.loc()};
		};
		
		VarOrAccess.prototype.loc = function (){
			var loc = this._identifier.region();
			return loc || [0,0];
		};
		
		VarOrAccess.prototype.region = function (){
			return this._identifier.region();
		};
		
		VarOrAccess.prototype.toString = function (){
			return ("VarOrAccess(" + this.value() + ")");
		};
		
		VarOrAccess.prototype.toJSON = function (){
			return {type: this.typeName(),value: this._identifier.toString()};
		};
		
		//	def js
		//		if right isa Variable and right.type == 'meth'
		//			return "{right.c}()" unless up isa Call
		//
		//		right.c
		//
		//	def variable
		//		right
		//
		//	def cache o = {}
		//		super if o:force
		//		self
		//
		//	def alias
		//		variable.@alias or super # if resolved?
		//
		
		function VarReference(value,type){
			if (value instanceof VarOrAccess) {
				value = value.value();
			};
			// for now - this can happen
			VarReference.__super__.constructor.call(this,value);
			this._export = false;
			this._type = type && String(type);
			this._variable = null;
			this._declared = true; // just testing now
		};
		
		
		subclass$(VarReference,ValueNode);
		exports.VarReference = VarReference; // export class 
		VarReference.prototype.variable = function(v){ return this._variable; }
		VarReference.prototype.setVariable = function(v){ this._variable = v; return this; };
		VarReference.prototype.declared = function(v){ return this._declared; }
		VarReference.prototype.setDeclared = function(v){ this._declared = v; return this; };
		VarReference.prototype.type = function(v){ return this._type; }
		VarReference.prototype.setType = function(v){ this._type = v; return this; };
		
		VarReference.prototype.loc = function (){
			// p "loc for VarReference {@value:constructor} {@value.@value:constructor} {@value.region}"
			return this._value.region();
		};
		
		VarReference.prototype.set = function (o){
			// hack - workaround for hidden classes perf
			if (o.export) { this._export = true };
			return this;
		};
		
		VarReference.prototype.js = function (o){
			// experimental fix
			
			// what about resolving?
			var ref = this._variable;
			var out = ("" + mark__(this._value) + (ref.c()));
			
			// p "VarReference {out} - {o.up} {o.up == self}\n{o}"
			
			if (ref && !ref._declared) { // .option(:declared)
				if (o.up(VarBlock)) { // up varblock??
					ref._declared = true;
					
					// ref.set(declared: yes)
				} else if (o.isExpression() || this._export) { // why?
					// p "autodeclare"
					ref.autodeclare();
				} else {
					out = ("var " + out);
					ref._declared = true;
					// ref.set(declared: yes)
				};
			};
			
			// need to think the export through -- like registering somehow
			// should register in scope - export on analysis++
			if (this._export) {
				out = ("module.exports." + (ref.c()) + " = " + (ref.c()));
			};
			
			return out;
		};
		
		VarReference.prototype.declare = function (){
			return this;
		};
		
		VarReference.prototype.consume = function (node){
			// really? the consumed node dissappear?
			this._variable && this._variable.autodeclare();
			return this;
		};
		
		VarReference.prototype.visit = function (){
			
			// console.log "value type for VarReference {@value} {@value.@loc} {@value:constructor}"
			
			// should be possible to have a VarReference without a name as well? for a system-variable
			// name should not set this way.
			// p "varname {value} {value:constructor}"
			var name = this.value().c();
			// p "visit vardecl {name} {value}"
			
			// what about looking up? - on register we want to mark
			var v = this._variable || (this._variable = this.scope__().register(name,this,{type: this._type}));
			// FIXME -- should not simply override the declarator here(!)
			
			if (!v.declarator()) {
				v.setDeclarator(this);
			};
			
			if (this._value) { v.addReference(this._value) }; // is this the first reference?
			
			// only needed when analyzing?
			this._value._value._variable = v;
			return this;
		};
		
		VarReference.prototype.refnr = function (){
			return this.variable().references().indexOf(this.value());
		};
		
		// convert this into a list of references
		VarReference.prototype.addExpression = function (expr){
			
			return new VarBlock([this]).addExpression(expr);
		};
		
		
		// ASSIGN
		
		function Assign(o,l,r){
			
			// workaround until we complete transition from lua-style assignments
			// to always use explicit tuples - then we can move assignments out etc
			// this will not be needed after we remove support for var a,b,c = 1,2,3
			if ((l instanceof VarReference) && (l.value() instanceof Arr)) {
				// converting all nodes to var-references ?
				// do we need to keep it in a varblock at all?
				var vars = l.value().nodes().map(function(v) {
					// what about inner tuples etc?
					// keep the splats -- clumsy but true
					var v_;
					if (v instanceof Splat) {
						// p "value is a splat!!"
						if (!((v.value() instanceof VarReference))) { (v.setValue(v_ = new VarReference(v.value(),l.type())),v_) };
					} else if (v instanceof VarReference) {
						true;
					} else {
						// what about retaining location?
						// v = v.value if v isa VarOrAccess
						v = new VarReference(v,l.type());
					};
					
					return v;
					
					// v isa VarReference ? v : VarReference.new(v)
				});
				return new TupleAssign(o,new Tuple(vars),r);
			};
			
			if (l instanceof Arr) {
				return new TupleAssign(o,new Tuple(l.nodes()),r);
				// p "left is array in assign - in init"
			};
			
			
			// set expression yes, no?
			this._expression = false;
			this._traversed = false;
			this._parens = false;
			this._cache = null;
			this._invert = false;
			this._opToken = o;
			this._op = o && o._value || o;
			this._left = l;
			this._right = r;
			return this;
		};
		
		subclass$(Assign,Op);
		exports.Assign = Assign; // export class 
		Assign.prototype.isExpressable = function (){
			return !(this.right()) || this.right().isExpressable();
		};
		
		Assign.prototype.isUsed = function (){
			// really?
			// if up is a block in general this should not be used -- since it should already have received implicit self?
			if (this.up() instanceof Block) { // && up.last != self
				return false;
			};
			return true;
		};
		
		// FIXME optimize
		Assign.prototype.visit = function (){
			var l = this._left;
			var r = this._right;
			
			// WARNING - slightly undefined
			// MARK THE STACK
			if (l) { l.traverse() };
			
			var lvar = (l instanceof VarReference) && l.variable();
			
			// how does this work with constants that are really var references?
			// should work when things are not described as well - but this is for testing
			// but if it refers to something else 
			if (!lvar && this._desc) {
				// entities should be able to extract the needed info instead
				ROOT.entities().add(l.namepath(),{namepath: l.namepath(),type: r.typeName(),desc: this._desc});
			};
			
			// this should probably be done in a different manner
			if (lvar && lvar.declarator() == l) {
				lvar._initialized = false;
				if (r) { r.traverse() };
				lvar._initialized = true;
			} else {
				if (r) { r.traverse() };
			};
			
			if ((l instanceof VarReference) || l._variable) {
				l._variable.assigned(r,this);
			};
			
			return this;
		};
		
		Assign.prototype.c = function (o){
			if (!this.right().isExpressable()) {
				// p "Assign#c right is not expressable "
				return this.right().consume(this).c(o);
			};
			// testing this
			return Assign.__super__.c.call(this,o);
		};
		
		Assign.prototype.js = function (o){
			if (!this.right().isExpressable()) {
				this.p("Assign#js right is not expressable ");
				// here this should be go out of the stack(!)
				// it should already be consumed?
				return this.right().consume(this).c();
			};
			
			// p "assign left {left:contrstru}"
			var l = this.left().node();
			var r = this.right();
			
			// We are setting self(!)
			// TODO document functionality
			if (l instanceof Self) {
				var ctx = this.scope__().context();
				l = ctx.reference();
			};
			
			
			if (l instanceof PropertyAccess) {
				var ast = CALL(OP('.',l.left(),l.right().setter()),[this.right()]);
				ast.setReceiver(l.receiver());
				
				if (this.isUsed()) {
					// p "Assign is used {stack}"
					// dont cache it again if it is already cached(!)
					if (!this.right().cachevar()) { this.right().cache({pool: 'val',uses: 1}) }; // 
					// this is only when used.. should be more clever about it
					ast = new Parens(blk__([ast,this.right()]));
				};
				
				// should check the up-value no?
				return ast.c({expression: true});
			};
			
			// if l isa VarReference
			// 	p "assign var-ref"
			// 	l.@variable.assigned(r)
			
			// FIXME -- does not always need to be an expression?
			// p "typeof op {@opToken and @opToken:constructor}"
			var out = ("" + (l.c()) + " " + mark__(this._opToken) + this.op() + " " + this.right().c({expression: true}));
			
			return out;
		};
		
		// FIXME op is a token? _FIX_
		// this (and similar cases) is broken when called from
		// another position in the stack, since 'up' is dynamic
		// should maybe freeze up?
		Assign.prototype.shouldParenthesize = function (par){
			if(par === undefined) par = this.up();
			return this._parens || (par instanceof Op) && par.op() != '=';
		};
		
		Assign.prototype.consume = function (node){
			if (this.isExpressable()) {
				this.forceExpression();
				return Assign.__super__.consume.call(this,node);
			};
			
			var ast = this.right().consume(this);
			return ast.consume(node);
		};
		
		// more workaround during transition away from a,b,c = 1,2,3 style assign
		Assign.prototype.addExpression = function (expr){
			var typ = ExpressionBlock;
			if (this._left && (this._left instanceof VarReference)) {
				typ = VarBlock;
			};
			// might be better to nest this up after parsing is done?
			// p "Assign.addExpression {self} <- {expr}"
			var node = new typ([this]);
			return node.addExpression(expr);
		};
		
		
		function PushAssign(){ return Assign.apply(this,arguments) };
		
		subclass$(PushAssign,Assign);
		exports.PushAssign = PushAssign; // export class 
		PushAssign.prototype.js = function (o){
			return ("" + (this.left().c()) + ".push(" + (this.right().c()) + ")");
		};
		
		PushAssign.prototype.consume = function (node){
			return this;
		};
		
		
		function ConditionalAssign(){ return Assign.apply(this,arguments) };
		
		subclass$(ConditionalAssign,Assign);
		exports.ConditionalAssign = ConditionalAssign; // export class 
		ConditionalAssign.prototype.consume = function (node){
			return this.normalize().consume(node);
		};
		
		ConditionalAssign.prototype.normalize = function (){
			var l = this.left().node();
			var ls = l;
			
			if (l instanceof Access) {
				// p "conditional-assign {l} {l.left} {l.right}"
				if (l.left()) {
					// p "cache l.left {l.left:constructor}̋"
					l.left().cache();
				};
				ls = l.clone(l.left(),l.right()); // this should still be cached?
				if (l instanceof PropertyAccess) { l.cache() }; // correct now, to a certain degree
				if (l instanceof IndexAccess) {
					// p "cache the right side of indexAccess!!! {l.right}"
					l.right().cache();
				};
				
				// we should only cache the value itself if it is dynamic?
				// l.cache # cache the value as well -- we cannot use this in assigns them
			};
			
			// some ops are less messy
			// need op to support consume then?
			var expr = this.right().isExpressable();
			var ast = null;
			// here we should use ast = if ...
			if (expr && this.op() == '||=') {
				ast = OP('||',l,OP('=',ls,this.right()));
			} else if (expr && this.op() == '&&=') {
				ast = OP('&&',l,OP('=',ls,this.right()));
			} else {
				ast = IF(this.condition(),OP('=',ls,this.right()),l); // do we need a scope for these?
				ast.setScope(null);
				// drop the scope
				// touch scope -- should probably visit the whole thing?
				// ast.scope.visit
			};
			if (ast.isExpressable()) { ast.toExpression() };
			return ast;
		};
		
		
		ConditionalAssign.prototype.c = function (){
			// WARN what if we return the same?
			return this.normalize().c();
		};
		
		ConditionalAssign.prototype.condition = function (){
			
			// use switch instead to cache op access
			if (this.op() == '?=') {
				return OP('==',this.left(),NULL);
			} else if (this.op() == '||=') {
				return OP('!',this.left());
			} else if (this.op() == '&&=') {
				return this.left();
			} else if (this.op() == '!?=') {
				return OP('!=',this.left(),NULL);
			} else {
				return this.left();
			};
		};
		
		ConditionalAssign.prototype.js = function (o){
			// p "ConditionalAssign.js".red
			var ast = IF(this.condition(),OP('=',this.left(),this.right()),this.left());
			ast.setScope(null); // not sure about this
			if (ast.isExpressable()) { ast.toExpression() }; // forced expression already
			return ast.c();
		};
		
		function CompoundAssign(){ return Assign.apply(this,arguments) };
		
		subclass$(CompoundAssign,Assign);
		exports.CompoundAssign = CompoundAssign; // export class 
		CompoundAssign.prototype.consume = function (node){
			if (this.isExpressable()) { return CompoundAssign.__super__.consume.apply(this,arguments) };
			
			var ast = this.normalize();
			if (ast != this) { return ast.consume(node) };
			
			ast = this.right().consume(this);
			return ast.consume(node);
		};
		
		CompoundAssign.prototype.normalize = function (){
			var ln = this.left().node();
			// we dont need to change this at all
			if (!((ln instanceof PropertyAccess))) {
				return this;
			};
			
			if (ln instanceof Access) {
				// left might be zero?!?!
				if (ln.left()) { ln.left().cache() };
			};
			// TODO FIXME we want to cache the context of the assignment
			// p "normalize compound assign {left}"
			var ast = OP('=',this.left(),OP(this.op()[0],this.left(),this.right()));
			if (ast.isExpressable()) { ast.toExpression() };
			
			return ast;
		};
		
		CompoundAssign.prototype.c = function (){
			var ast = this.normalize();
			if (ast == this) { return CompoundAssign.__super__.c.apply(this,arguments) };
			
			// otherwise it is important that we actually replace this node in the outer block
			// whenever we normalize and override c it is important that we can pass on caching
			// etc -- otherwise there WILL be issues.
			var up = STACK.current();
			if (up instanceof Block) {
				// p "parent is block, should replace!"
				// an alternative would be to just pass
				up.replace(this,ast);
			};
			return ast.c();
		};
		
		
		function AsyncAssign(){ return Assign.apply(this,arguments) };
		
		subclass$(AsyncAssign,Assign);
		exports.AsyncAssign = AsyncAssign; // export class 
		
		
		
		function TupleAssign(a,b,c){
			this._traversed = false;
			this._op = a;
			this._left = b;
			this._right = c;
			this._temporary = [];
		};
		
		subclass$(TupleAssign,Assign);
		exports.TupleAssign = TupleAssign; // export class 
		TupleAssign.prototype.op = function(v){ return this._op; }
		TupleAssign.prototype.setOp = function(v){ this._op = v; return this; };
		TupleAssign.prototype.left = function(v){ return this._left; }
		TupleAssign.prototype.setLeft = function(v){ this._left = v; return this; };
		TupleAssign.prototype.right = function(v){ return this._right; }
		TupleAssign.prototype.setRight = function(v){ this._right = v; return this; };
		TupleAssign.prototype.type = function(v){ return this._type; }
		TupleAssign.prototype.setType = function(v){ this._type = v; return this; };
		
		TupleAssign.prototype.isExpressable = function (){
			return this.right().isExpressable();
		};
		
		TupleAssign.prototype.addExpression = function (expr){
			if (this.right() instanceof Tuple) {
				this.right().push(expr);
			} else {
				// p "making child become a tuple?"
				this.setRight(new Tuple([this.right(),expr]));
			};
			
			return this;
		};
		
		TupleAssign.prototype.visit = function (){
			// if the first left-value is a var-reference, then
			// all the variables should be declared as variables.
			// but if we have complex items in the other list - it does become much harder
			
			// if the first is a var-reference, they should all be(!) .. or splats?
			// this is really a hacky wao to do it though
			if (this.left().first().node() instanceof VarReference) {
				this.setType('var');
				// should possibly allow real vars as well, no?
				this._vars = this.left().nodes().filter(function(n) { return n instanceof VarReference; });
				// collect the vars for tuple for easy access
				
				// NOTE can improve.. should rather make the whole left be a VarBlock or TupleVarBlock
				// p "type is var -- skip the rest"
			};
			
			this.right().traverse();
			this.left().traverse();
			return this;
		};
		
		TupleAssign.prototype.js = function (o){
			// only for actual inner expressions, otherwise cache the whole array, no?
			var self = this;
			if (!self.right().isExpressable()) {
				// p "TupleAssign.consume! {right}".blue
				
				return self.right().consume(self).c();
			};
			
			// p "TUPLE {type}"
			
			/* a,b,c = arguments */
			
			// - direct. no matter if lvalues are variables or not. Make fake arguments up to the same count as tuple
			
			/* a,*b,b = arguments */
			
			// Need to convert arguments to an array. IF arguments is not referenced anywhere else in scope, 
			// we can do the assignment directly while rolling through arguments
			
			/* a,b = b,a */
			
			// ideally we only need to cache the first value (or n - 1), assign directly when possible.
			
			/* a,b,c = (method | expression) */
			
			// convert res into array, assign from array. Can cache the variable when assigning first value
			
			// First we need to find out whether we are required to store the result in an array before assigning
			// If this needs to be an expression (returns?, we need to fall back to the CS-wa)
			
			var ast = new Block([]);
			var lft = self.left();
			var rgt = self.right();
			var typ = self.type();
			var via = null;
			
			var li = 0;
			var ri = lft.count();
			var llen = ri;
			
			
			// if @vars
			// 	p "tuple has {@vars:length} vars"
			
			// if we have a splat on the left it is much more likely that we need to store right
			// in a temporary array, but if the right side has a known length, it should still not be needed
			var lsplat = lft.filter(function(v) { return v instanceof Splat; })[0];
			
			// if right is an array without any splats (or inner tuples?), normalize it to tuple
			if ((rgt instanceof Arr) && !rgt.splat()) { rgt = new Tuple(rgt.nodes()) };
			var rlen = rgt instanceof Tuple ? (rgt.count()) : (null);
			
			// if any values are statements we need to handle this before continuing
			
			/* a,b,c = 10,20,ary */
			
			// ideally we only need to cache the first value (or n - 1), assign directly when possible.
			// only if the variables are not predefined or predeclared can be we certain that we can do it without caching
			// if rlen && typ == 'var' && !lsplat
			// 	# this can be dangerous in edgecases that are very hard to detect
			// 	# if it becomes an issue, fall back to simpler versions
			// 	# does not even matter if there is a splat?
			
			// special case for arguments(!)
			if (!lsplat && rgt == ARGUMENTS) {
				
				var pars = self.scope__().params();
				// p "special case with arguments {pars}"
				// forcing the arguments to be named
				// p "got here??? {pars}"
				lft.map(function(l,i) { return ast.push(OP('=',l.node(),pars.at(i,true).visit().variable())); }); // s.params.at(value - 1,yes)
			} else if (rlen) {
				// we have several items in the right part. what about splats here?
				
				// pre-evaluate rvalues that might be reference from other assignments
				// we need to check if the rightside values has no side-effects. Cause if
				// they dont, we really do not need temporary variables.
				
				// some of these optimizations are quite petty - makes things more complicated
				// in the compiler only to get around adding a few temp-variables here and there
				
				// var firstUnsafe = 0
				// lft.map do |v,i|
				// 	if v isa VarReference
				// 		p "left side {i} {v} {v.refnr}"
				
				// rgt.map do |v,i|
				// 	if v.hasSideEffects
				// 		# return if i == 0 or !v.hasSideEffects
				// 		# return if v isa Num || v isa Str || i == 0
				// 		# we could explicitly create a temporary variable and adding nodes for accessing etc
				// 		# but the builtin caching should really take care of this for us
				// 		# we need to really force the caching though -- since we need a copy of it even if it is a local
				// 		# we need to predeclare the variables at the top of scope if this does not take care of it
				// 		
				// 		# these are the declarations -- we need to add them somewhere smart
				// 		@temporary.push(v) # need a generalized way to do this type of thing
				// 		ast.push(v.cache(force: yes, type: 'swap', declared: typ == 'var'))
				// 		# they do need to be declared, no?
				
				// now we can free the cached variables
				// ast.map do |n| n.decache
				
				var pre = [];
				var rest = [];
				
				var pairs = lft.map(function(l,i) {
					var v = null;
					// determine if this needs to be precached?
					// if l isa VarReference
					// 	# this is the first time the variable is referenced
					// 	# should also count even if it is predeclared at the top
					// 	if l.refnr == 0
					
					if (l == lsplat) {
						v = new ArgList([]);
						var to = (rlen - (ri - i));
						// p "assing splat at index {i} to slice {li} - {to}".cyan
						while (li <= to){
							v.push(rgt.index(li++));
						};
						v = new Arr(v);
						// ast.push OP('=',l.node,Arr.new(v))
					} else {
						v = rgt.index(li++);
					};
					return [l.node(),v];
					
					// if l isa VarReference && l.refnr 
				});
				var clean = true;
				
				pairs.map(function(v,i) {
					var l = v[0];
					var r = v[1];
					
					if (clean) {
						if ((l instanceof VarReference) && l.refnr() == 0) {
							// still clean
							clean = true;
						} else {
							clean = false;
							// p "now cache"
							pairs.slice(i).map(function(part) {
								if (part[1].hasSideEffects()) {
									self._temporary.push(part[1]); // need a generalized way to do this type of thing
									return ast.push(part[1].cache({force: true,pool: 'swap',declared: typ == 'var'}));
								};
							});
							// p "from {i} - cache all remaining with side-effects"
						};
					};
					
					// if the previous value in ast is a reference to our value - the caching was not needed
					if (ast.last() == r) {
						r.decache();
						// p "was cached - not needed"
						// simple assign
						return ast.replace(r,OP('=',l,r));
					} else {
						return ast.push(OP('=',l,r));
					};
				});
				
				// WARN FIXME Is there not an issue with VarBlock vs not here?
			} else {
				// this is where we need to cache the right side before assigning
				// if the right side is a for loop, we COULD try to be extra clever, but
				// for now it is not worth the added compiler complexity
				
				// iter.cache(force: yes, type: 'iter')
				var top = new VarBlock();
				var iter = self.util().iterable(rgt,true);
				// could set the vars inside -- most likely
				ast.push(top);
				top.push(iter);
				
				if (lsplat) {
					var len = self.util().len(iter,true);
					var idx = self.util().counter(0,true);
					// cache the length of the array
					top.push(len); // preassign the length
					// cache counter to loop through
					top.push(idx);
				};
				
				// only if the block is variable based, no?
				// ast.push(blk = VarBlock.new)
				// blk = null
				
				var blktype = typ == 'var' ? (VarBlock) : (Block);
				var blk = new blktype([]);
				// blk = top if typ == 'var'
				ast.push(blk);
				
				// if the lvals are not variables - we need to preassign
				// can also use slice here for simplicity, but try with while now			
				lft.map(function(l,i) {
					if (l == lsplat) {
						var lvar = l.node();
						var rem = llen - i - 1; // remaining after splat
						
						if (typ != 'var') {
							var arr = self.util().array(OP('-',len,num__(i + rem)),true);
							top.push(arr);
							lvar = arr.cachevar();
						} else {
							if (!blk) { ast.push(blk = new blktype()) };
							arr = self.util().array(OP('-',len,num__(i + rem)));
							blk.push(OP('=',lvar,arr));
						};
						
						// if !lvar:variable || !lvar.variable # lvar = 
						// 	top.push()
						//	p "has variable - no need to create a temp"
						// blk.push(OP('=',lvar,Arr.new([]))) # dont precalculate size now
						// max = to = (rlen - (llen - i))
						
						
						var test = rem ? (OP('-',len,rem)) : (len);
						
						var set = OP('=',OP('.',lvar,OP('-',idx,num__(i))),
						OP('.',iter,OP('++',idx)));
						
						ast.push(WHILE(OP('<',idx,test),set));
						
						if (typ != 'var') {
							ast.push(blk = new Block());
							return blk.push(OP('=',l.node(),lvar));
						} else {
							return blk = null;
						};
						
						// not if splat was last?
						// ast.push(blk = VarBlock.new)
					} else if (lsplat) {
						if (!blk) { ast.push(blk = new blktype()) };
						// we could cache the raw code of this node for better performance
						return blk.push(OP('=',l,OP('.',iter,OP('++',idx))));
					} else {
						if (!blk) { ast.push(blk = new blktype()) };
						return blk.push(OP('=',l,OP('.',iter,num__(i))));
					};
				});
			};
			
			// if we are in an expression we really need to 
			if (o.isExpression() && self._vars) {
				// p "tuple is expression" # variables MUST be autodeclared outside of the expression
				for (var i = 0, ary = iter$(self._vars), len_ = ary.length; i < len_; i++) {
					ary[i].variable().autodeclare();
				};
			} else if (self._vars) {
				for (var i = 0, ary = iter$(self._vars), len_ = ary.length; i < len_; i++) {
					// p "predeclare variable before compilation"
					ary[i].variable().predeclared();
				};
			};
			
			// is there any reason to make it into an expression?
			if (ast.isExpressable()) { // NO!
				// p "express"
				// if this is an expression
				var out = ast.c({expression: true});
				if (typ && !o.isExpression()) { out = ("" + typ + " " + out) }; // not in expression
				return out;
			} else {
				out = ast.c();
				// if this is a varblock 
				return out;
			};
		};
		
		
		TupleAssign.prototype.c = function (o){
			var out = TupleAssign.__super__.c.call(this,o);
			// this is only used in tuple -- better to let the tuple hav a separate #c
			if (this._temporary && this._temporary.length) {
				this._temporary.map(function(temp) { return temp.decache(); });
			};
			return out;
		};
		
		
		
		// IDENTIFIERS
		
		// really need to clean this up
		// Drop the token?
		function Identifier(value){
			this._value = this.load(value);
			this._symbol = null;
			this._setter = null;
			
			if (("" + value).indexOf("?") >= 0) {
				this._safechain = true;
			};
			// @safechain = ("" + value).indexOf("?") >= 0
			this;
		};
		
		subclass$(Identifier,Node);
		exports.Identifier = Identifier; // export class 
		Identifier.prototype.safechain = function(v){ return this._safechain; }
		Identifier.prototype.setSafechain = function(v){ this._safechain = v; return this; };
		Identifier.prototype.value = function(v){ return this._value; }
		Identifier.prototype.setValue = function(v){ this._value = v; return this; };
		
		Identifier.prototype.references = function (variable){
			if (this._value) { this._value._variable = variable };
			return this;
		};
		
		Identifier.prototype.sourceMapMarker = function (){
			return this._value.sourceMapMarker();
		};
		
		Identifier.prototype.load = function (v){
			return (v instanceof Identifier ? (v.value()) : (v));
		};
		
		Identifier.prototype.traverse = function (){
			// NODES.push(self)
			return this;
		};
		
		Identifier.prototype.visit = function (){
			
			if (this._value instanceof Node) {
				// console.log "IDENTIFIER VALUE IS NODE"
				this._value.traverse();
			};
			return this;
		};
		
		Identifier.prototype.region = function (){
			return [this._value._loc,this._value._loc + this._value._len];
		};
		
		Identifier.prototype.isValidIdentifier = function (){
			return true;
		};
		
		Identifier.prototype.isReserved = function (){
			return this._value.reserved || RESERVED_TEST.test(String(this._value));
		};
		
		Identifier.prototype.symbol = function (){
			// console.log "Identifier#symbol {value}"
			return this._symbol || (this._symbol = sym__(this.value()));
		};
		
		Identifier.prototype.setter = function (){
			// console.log "Identifier#setter"
			var tok;
			return this._setter || (this._setter = (true) && (
				tok = new Token('IDENTIFIER',sym__('set-' + this._value),this._value._loc || -1),
				new Identifier(tok)
				// Identifier.new("set-{symbol}")
			));
		};
		
		Identifier.prototype.toString = function (){
			return String(this._value);
		};
		
		Identifier.prototype.toJSON = function (){
			return this.toString();
		};
		
		Identifier.prototype.alias = function (){
			return sym__(this._value);
		};
		
		Identifier.prototype.js = function (o){
			return this.symbol();
		};
		
		Identifier.prototype.c = function (){
			return '' + this.symbol(); // mark__(@value) + 
		};
		
		Identifier.prototype.dump = function (){
			return {loc: this.region()};
		};
		
		Identifier.prototype.namepath = function (){
			return this.toString();
		};
		
		function TagId(v){
			this._value = v instanceof Identifier ? (v.value()) : (v);
			this;
		};
		
		subclass$(TagId,Identifier);
		exports.TagId = TagId; // export class 
		TagId.prototype.c = function (){
			return ("id$('" + (this.value().c()) + "')");
		};
		
		// This is not an identifier - it is really a string
		// Is this not a literal?
		
		// FIXME Rename to IvarLiteral? or simply Literal with type Ivar
		function Ivar(v){
			this._value = v instanceof Identifier ? (v.value()) : (v);
			this;
		};
		
		subclass$(Ivar,Identifier);
		exports.Ivar = Ivar; // export class 
		Ivar.prototype.name = function (){
			return helpers.camelCase(this._value).replace(/^@/,'');
			// value.c.camelCase.replace(/^@/,'')
		};
		
		Ivar.prototype.alias = function (){
			return '_' + this.name();
		};
		
		// the @ should possibly be gone from the start?
		Ivar.prototype.js = function (o){
			return '_' + this.name();
		};
		
		Ivar.prototype.c = function (){
			return '_' + helpers.camelCase(this._value).slice(1); // .replace(/^@/,'') # mark__(@value) + 
		};
		
		
		
		// Ambiguous - We need to be consistent about Const vs ConstAccess
		// Becomes more important when we implement typeinference and code-analysis
		function Const(){ return Identifier.apply(this,arguments) };
		
		subclass$(Const,Identifier);
		exports.Const = Const; // export class 
		Const.prototype.symbol = function (){
			// console.log "Identifier#symbol {value}"
			return this._symbol || (this._symbol = sym__(this.value()));
		};
		
		Const.prototype.js = function (o){
			return this.symbol();
		};
		
		Const.prototype.c = function (){
			return mark__(this._value) + this.symbol();
		};
		
		function TagTypeIdentifier(value){
			this._value = this.load(value);
			this;
		};
		
		subclass$(TagTypeIdentifier,Identifier);
		exports.TagTypeIdentifier = TagTypeIdentifier; // export class 
		TagTypeIdentifier.prototype.name = function(v){ return this._name; }
		TagTypeIdentifier.prototype.setName = function(v){ this._name = v; return this; };
		TagTypeIdentifier.prototype.ns = function(v){ return this._ns; }
		TagTypeIdentifier.prototype.setNs = function(v){ this._ns = v; return this; };
		
		TagTypeIdentifier.prototype.load = function (val){
			this._str = ("" + val);
			var parts = this._str.split(":");
			this._raw = val;
			this._name = parts.pop();
			this._ns = parts.shift(); // if any?
			return this._str;
		};
		
		TagTypeIdentifier.prototype.js = function (o){
			return ("Imba.TAGS." + this._str.replace(":","$"));
		};
		
		TagTypeIdentifier.prototype.c = function (){
			return this.js();
		};
		
		TagTypeIdentifier.prototype.func = function (){
			var name = this._name.replace(/-/g,'_').replace(/\#/,'');
			if (this._ns) { name += ("$" + (this._ns.toLowerCase())) };
			return name;
		};
		
		TagTypeIdentifier.prototype.spawner = function (){
			if (this._ns) {
				return ("" + (this._ns.toUpperCase()) + ".$" + this._name.replace(/-/g,'_'));
			} else {
				return ("$" + this._name.replace(/-/g,'_'));
			};
		};
		
		TagTypeIdentifier.prototype.id = function (){
			var m = this._str.match(/\#([\w\-\d\_]+)\b/);
			return m ? (m[1]) : (null);
		};
		
		
		TagTypeIdentifier.prototype.flag = function (){
			return "_" + this.name().replace(/--/g,'_').toLowerCase();
		};
		
		TagTypeIdentifier.prototype.sel = function (){
			return ("." + this.flag()); // + name.replace(/-/g,'_').toLowerCase
		};
		
		TagTypeIdentifier.prototype.string = function (){
			return this.value();
		};
		
		
		function Argvar(){ return ValueNode.apply(this,arguments) };
		
		subclass$(Argvar,ValueNode);
		exports.Argvar = Argvar; // export class 
		Argvar.prototype.c = function (){
			// NEXT -- global.parseInt or Number.parseInt (better)
			var v = parseInt(String(this.value()));
			// FIXME Not needed anymore? I think the lexer handles this
			if (v == 0) { return "arguments" };
			
			var s = this.scope__();
			// params need to go up to the closeste method-scope
			var par = s.params().at(v - 1,true);
			return ("" + c__(par.name())); // c
		};
		
		
		// CALL
		
		function Call(callee,args,opexists){
			this._traversed = false;
			this._expression = false;
			this._parens = false;
			this._cache = null;
			this._receiver = null;
			this._opexists = opexists;
			// some axioms that share the same syntax as calls will be redirected from here
			
			if (callee instanceof VarOrAccess) {
				var str = callee.value().symbol();
				// p "Call callee {callee} - {str}"
				if (str == 'extern') {
					// p "returning extern instead!"
					callee.value().value()._type = 'EXTERN';
					return new ExternDeclaration(args);
				};
				if (str == 'tag') {
					// console.log "ERROR - access args by some method"
					return new TagWrapper(args && args.index ? (args.index(0)) : (args[0]));
				};
				if (str == 'export') {
					return new ExportStatement(args);
				};
			};
			
			this._callee = callee;
			this._args = args || new ArgList([]);
			
			if (args instanceof Array) {
				this._args = new ArgList(args);
				// console.log "ARGUMENTS IS ARRAY - error {args}"
			};
			// p "call opexists {opexists}"
			this;
		};
		
		subclass$(Call,Node);
		exports.Call = Call; // export class 
		Call.prototype.callee = function(v){ return this._callee; }
		Call.prototype.setCallee = function(v){ this._callee = v; return this; };
		Call.prototype.receiver = function(v){ return this._receiver; }
		Call.prototype.setReceiver = function(v){ this._receiver = v; return this; };
		Call.prototype.args = function(v){ return this._args; }
		Call.prototype.setArgs = function(v){ this._args = v; return this; };
		Call.prototype.block = function(v){ return this._block; }
		Call.prototype.setBlock = function(v){ this._block = v; return this; };
		
		Call.prototype.visit = function (){
			// console.log "visit args {args}"
			this.args().traverse();
			this.callee().traverse();
			
			// if the callee is a PropertyAccess - better to immediately change it
			
			return this._block && this._block.traverse();
		};
		
		Call.prototype.addBlock = function (block){
			var pos = this._args.filter(function(n,i) { return n == '&'; })[0]; // WOULD BE TOKEN - CAREFUL
			pos ? (this.args().replace(pos,block)) : (this.args().push(block));
			return this;
		};
		
		Call.prototype.receiver = function (){
			return this._receiver || (this._receiver = ((this.callee() instanceof Access) && this.callee().left() || NULL));
		};
		
		// check if all arguments are expressions - otherwise we have an issue
		
		Call.prototype.safechain = function (){
			return this.callee().safechain(); // really?
		};
		
		Call.prototype.js = function (o){
			var opt = {expression: true};
			var rec = null;
			// var args = compact__(args) # really?
			var args = this.args();
			
			// drop this?
			
			var splat = args.some(function(v) { return v instanceof Splat; });
			
			var out = null;
			var lft = null;
			var rgt = null;
			var wrap = null;
			
			var callee = this._callee = this._callee.node(); // drop the var or access?
			
			// if callee isa Call && callee.safechain
			//	yes
			
			if (callee instanceof Access) {
				lft = callee.left();
				rgt = callee.right();
			};
			
			if ((callee instanceof Super) || (callee instanceof SuperAccess)) {
				this._receiver = this.scope__().context();
				// return "supercall"
			};
			
			// never call the property-access directly?
			if (callee instanceof PropertyAccess) { // && rec = callee.receiver
				// p "unwrapping property-access in call"
				this._receiver = callee.receiver();
				callee = this._callee = new Access(callee.op(),callee.left(),callee.right());
				// p "got here? {callee}"
				// console.log "unwrapping the propertyAccess"
			};
			
			if (callee.safechain()) {
				// p "callee is safechained?!?"
				// if lft isa Call
				// if lft isa Call # could be a property access as well - it is the same?
				// if it is a local var access we simply check if it is a function, then call
				// but it should be safechained outside as well?
				// lft.cache if lft
				// the outer safechain should not cache the whole call - only ask to cache
				// the result? -- chain onto
				// p "Call safechain {callee} {lft}.{rgt}"
				var isfn = new Util.IsFunction([callee]);
				wrap = [("" + (isfn.c()) + "  &&  "),""];
				callee = OP('.',callee.left(),callee.right());
				// callee should already be cached now - 
			};
			
			// should just force expression from the start, no?
			if (splat) {
				// important to wrap the single value in a value, to keep implicit call
				// this is due to the way we check for an outer Call without checking if
				// we are the receiver (in PropertyAccess). Should rather wrap in CallArguments
				var rec1 = this.receiver();
				var ary = (args.count() == 1 ? (new ValueNode(args.first().value())) : (new Arr(args.list())));
				
				rec1.cache(); // need to cache the context as it will be referenced in apply
				out = ("" + callee.c({expression: true}) + ".apply(" + (rec1.c()) + "," + ary.c({expression: true}) + ")");
			} else if (this._receiver) {
				// quick workaround
				if (!((this._receiver instanceof ScopeContext))) { this._receiver.cache() };
				args.unshift(this.receiver());
				// should rather rewrite to a new call?
				out = ("" + callee.c({expression: true}) + ".call(" + args.c({expression: true}) + ")");
			} else {
				out = ("" + callee.c({expression: true}) + "(" + args.c({expression: true}) + ")");
			};
			
			if (wrap) {
				// we set the cachevar inside
				// p "special caching for call"
				if (this._cache) {
					this._cache.manual = true;
					out = ("(" + (this.cachevar().c()) + "=" + out + ")");
				};
				
				out = [wrap[0],out,wrap[1]].join("");
			};
			
			return out;
		};
		
		
		
		
		function ImplicitCall(){ return Call.apply(this,arguments) };
		
		subclass$(ImplicitCall,Call);
		exports.ImplicitCall = ImplicitCall; // export class 
		ImplicitCall.prototype.js = function (o){
			return ("" + (this.callee().c()) + "()");
		};
		
		function New(){ return Call.apply(this,arguments) };
		
		subclass$(New,Call);
		exports.New = New; // export class 
		New.prototype.js = function (o){
			var target = this.callee();
			
			while (target instanceof Access){
				var left = target.left();
				
				if ((left instanceof PropertyAccess) || (left instanceof VarOrAccess)) {
					this.callee()._parens = true;
					break;
				};
				
				target = left;
			};
			
			var out = ("new " + (this.callee().c()));
			if (!((o.parent() instanceof Call))) { out += '()' };
			return out;
		};
		
		function SuperCall(){ return Call.apply(this,arguments) };
		
		subclass$(SuperCall,Call);
		exports.SuperCall = SuperCall; // export class 
		SuperCall.prototype.js = function (o){
			var m = o.method();
			this.setReceiver(SELF);
			this.setCallee(("" + (m.target().c()) + ".super$.prototype." + (m.name().c())));
			return SuperCall.__super__.js.apply(this,arguments);
		};
		
		
		
		function ExternDeclaration(){ return ListNode.apply(this,arguments) };
		
		subclass$(ExternDeclaration,ListNode);
		exports.ExternDeclaration = ExternDeclaration; // export class 
		ExternDeclaration.prototype.visit = function (){
			
			// p "visiting externdeclaration"
			this.setNodes(this.map(function(item) { return item.node(); })); // drop var or access really
			// only in global scope?
			var root = this.scope__();
			for (var i = 0, ary = iter$(this.nodes()), len = ary.length, item; i < len; i++) {
				item = ary[i];
				var variable = root.register(item.symbol(),item,{type: 'global'});
				variable.addReference(item);
			};
			return this;
		};
		
		ExternDeclaration.prototype.c = function (){
			return "// externs";
		};
		
		
		// FLOW
		
		function ControlFlow(){ return Node.apply(this,arguments) };
		
		subclass$(ControlFlow,Node);
		exports.ControlFlow = ControlFlow; // export class 
		
		
		
		
		function ControlFlowStatement(){ return ControlFlow.apply(this,arguments) };
		
		subclass$(ControlFlowStatement,ControlFlow);
		exports.ControlFlowStatement = ControlFlowStatement; // export class 
		ControlFlowStatement.prototype.isExpressable = function (){
			return false;
		};
		
		
		
		function If(cond,body,o){
			if(o === undefined) o = {};
			this.setup();
			this._test = cond; // (o:type == 'unless' ? UnaryOp.new('!',cond,null) : cond)
			this._body = body;
			this._alt = null;
			this._type = o.type;
			if (this._type == 'unless') this.invert();
			this._scope = new IfScope(this);
			this;
		};
		
		subclass$(If,ControlFlow);
		exports.If = If; // export class 
		If.prototype.test = function(v){ return this._test; }
		If.prototype.setTest = function(v){ this._test = v; return this; };
		If.prototype.body = function(v){ return this._body; }
		If.prototype.setBody = function(v){ this._body = v; return this; };
		If.prototype.alt = function(v){ return this._alt; }
		If.prototype.setAlt = function(v){ this._alt = v; return this; };
		If.prototype.scope = function(v){ return this._scope; }
		If.prototype.setScope = function(v){ this._scope = v; return this; };
		
		If.ternary = function (cond,body,alt){
			// prefer to compile it this way as well
			var obj = new If(cond,new Block([body]),{type: '?'});
			obj.addElse(new Block([alt]));
			return obj;
		};
		
		If.prototype.addElse = function (add){
			// p "add else!",add
			if (this.alt() && (this.alt() instanceof If)) {
				// p 'add to the inner else(!)',add
				this.alt().addElse(add);
			} else {
				this.setAlt(add);
			};
			return this;
		};
		
		
		If.prototype.invert = function (){
			if (this._test instanceof ComparisonOp) {
				return this._test = this._test.invert();
			} else {
				return this._test = new UnaryOp('!',this._test,null);
			};
		};
		
		If.prototype.visit = function (){
			var alt = this.alt();
			
			if (this._scope) { this._scope.visit() };
			if (this.test()) { this.test().traverse() };
			if (this.body()) { this.body().traverse() };
			
			// should skip the scope in alt.
			if (alt) {
				// p "scoping {STACK.scopes:length}"
				STACK.pop(this);
				alt._scope || (alt._scope = new BlockScope(alt));
				alt.traverse();
				STACK.push(this);
			};
			
			// force it as expression?
			if (this._type == '?' && this.isExpressable()) this.toExpression();
			return this;
		};
		
		
		If.prototype.js = function (o){
			var body = this.body();
			// would possibly want to look up / out 
			var brace = {braces: true,indent: true};
			
			var cond = this.test().c({expression: true}); // the condition is always an expression
			
			if (o.isExpression()) {
				var code = body.c(); // (braces: yes)
				code = '(' + code + ')'; // if code.indexOf(',') >= 0
				// is expression!
				if (this.alt()) {
					// console.log "type of ternary {test}"
					// be safe - wrap condition as well
					// ask for parens
					return ("" + cond + " ? " + code + " : (" + (this.alt().c()) + ")");
				} else {
					// again - we need a better way to decide what needs parens
					// maybe better if we rewrite this to an OP('&&'), and put
					// the parens logic there
					// cond should possibly have parens - but where do we decide?
					if (this._tagtree) {
						return ("(" + cond + ") ? " + code + " : void(0)");
					} else {
						return ("(" + cond + ") && " + code);
					};
				};
			} else {
				// if there is only a single item - and it is an expression?
				code = null;
				// if body.count == 1 # dont indent by ourselves?
				
				if ((body instanceof Block) && body.count() == 1 && !(body.first() instanceof LoopFlowStatement)) {
					// p "body to body first {body.first}"
					body = body.first();
				};
				
				// if body.count == 1
				//	p "one item only!"
				//	body = body.first
				
				code = body.c({braces: true}); // (braces: yes)
				
				// don't wrap if it is only a single expression?
				var out = ("" + mark__(this._type) + "if (" + cond + ") ") + code; // ' {' + code + '}' # '{' + code + '}'
				if (this.alt()) { out += (" else " + this.alt().c(this.alt() instanceof If ? ({}) : (brace))) };
				return out;
			};
		};
		
		If.prototype.sourceMapMarker = function (){
			return this;
		};
		
		If.prototype.consume = function (node){
			// p 'assignify if?!'
			// if it is possible, convert into expression
			if (node instanceof TagTree) {
				this._body = this._body.consume(node);
				if (this._alt) { this._alt = this._alt.consume(node) };
				this._tagtree = node;
				return this;
			};
			
			// special case for If created from conditional assign as well?
			// @type == '?' and 
			// ideally we dont really want to make any expression like this by default
			var isRet = (node instanceof Return);
			
			// might have been forced to expression already
			// if it was originally a ternary - why not
			if (this._expression || ((!isRet || this._type == '?') && this.isExpressable())) {
				this.toExpression(); // mark as expression(!) - is this needed?
				return If.__super__.consume.call(this,node);
			} else {
				this._body = this._body.consume(node);
				if (this._alt) { this._alt = this._alt.consume(node) };
			};
			return this;
		};
		
		
		If.prototype.isExpressable = function (){
			// process:stdout.write 'x'
			var exp = this.body().isExpressable() && (!(this.alt()) || this.alt().isExpressable());
			return exp;
		};
		
		
		
		function Loop(options){
			if(options === undefined) options = {};
			this._traversed = false;
			this._options = options;
			this._body = null;
			this;
		};
		
		
		subclass$(Loop,Statement);
		exports.Loop = Loop; // export class 
		Loop.prototype.scope = function(v){ return this._scope; }
		Loop.prototype.setScope = function(v){ this._scope = v; return this; };
		Loop.prototype.options = function(v){ return this._options; }
		Loop.prototype.setOptions = function(v){ this._options = v; return this; };
		Loop.prototype.body = function(v){ return this._body; }
		Loop.prototype.setBody = function(v){ this._body = v; return this; };
		Loop.prototype.catcher = function(v){ return this._catcher; }
		Loop.prototype.setCatcher = function(v){ this._catcher = v; return this; };
		
		
		Loop.prototype.set = function (obj){
			// p "configure for!"
			this._options || (this._options = {});
			var keys = Object.keys(obj);
			for (var i = 0, ary = iter$(keys), len = ary.length, k; i < len; i++) {
				k = ary[i];
				this._options[k] = obj[k];
			};
			return this;
		};
		
		
		Loop.prototype.addBody = function (body){
			this.setBody(blk__(body));
			return this;
		};
		
		
		Loop.prototype.c = function (o){
			
			var s = this.stack();
			var curr = s.current();
			// p "Loop.c - {isExpressable} {stack} {stack.isExpression}"
			// p "stack is expression? {o} {isExpression}"
			
			
			
			if (this.stack().isExpression() || this.isExpression()) {
				// p "the stack is an expression for loop now(!)"
				// what the inner one should not be an expression though?
				// this will resut in an infinite loop, no?!?
				var ast = CALL(FN([],[this]),[]);
				return ast.c(o);
			} else if ((this.stack().current() instanceof Block) || ((s.up() instanceof Block) && s.current()._consumer == this)) {
				
				// p "what is the current stack of loop? {stack.current}"
				return Loop.__super__.c.call(this,o);
			} else {
				// p "Should never get here?!?"
				ast = CALL(FN([],[this]),[]);
				return ast.c(o);
				// need to wrap in function
			};
		};
		
		
		
		function While(test,opts){
			this._traversed = false;
			this._test = test;
			this._options = opts || {};
			this._scope = new WhileScope(this);
			// set(opts) if opts
			// p "invert test for while? {@test}"
			if (this.option('invert')) {
				// "invert test for while {@test}"
				this._test = test.invert();
			};
			// invert the test
		};
		
		
		subclass$(While,Loop);
		exports.While = While; // export class 
		While.prototype.test = function(v){ return this._test; }
		While.prototype.setTest = function(v){ this._test = v; return this; };
		
		
		While.prototype.visit = function (){
			this.scope().visit();
			if (this.test()) { this.test().traverse() };
			if (this.body()) { return this.body().traverse() };
		};
		
		
		// TODO BUG -- when we declare a var like: while var y = ...
		// the variable will be declared in the WhileScope which never
		// force-declares the inner variables in the scope
		
		While.prototype.consume = function (node){
			// p "While.consume {node}".cyan
			// This is never expressable, but at some point
			// we might want to wrap it in a function (like CS)
			if (this.isExpressable()) { return While.__super__.consume.apply(this,arguments) };
			
			if (node instanceof TagTree) {
				// WARN this is a hack to allow references coming through the wrapping scope 
				// will result in unneeded self-declarations and other oddities
				this.scope().context().reference();
				return CALL(FN([],[this]),[]);
			};
			
			var reuse = false;
			// WARN Optimization - might have untended side-effects
			// if we are assigning directly to a local variable, we simply
			// use said variable for the inner res
			// if reuse
			// 	resvar = scope.declare(node.left.node.variable,Arr.new([]),proxy: yes)
			// 	node = null
			// 	p "consume variable declarator!?".cyan
			// else
			// declare the variable we will use to soak up results
			// p "Creating value to store the result of loop".cyan
			// TODO Use a special vartype for this?
			var resvar = this.scope().declare('res',new Arr([]),{system: true});
			// WHAT -- fix this --
			this._catcher = new PushAssign("push",resvar,null); // the value is not preset # what
			this.body().consume(this._catcher); // should still return the same body
			
			// scope vars must not be compiled before this -- this is important
			var ast = new Block([this,resvar.accessor()]); // should be varaccess instead?
			return ast.consume(node);
			// NOTE Here we can find a way to know wheter or not we even need to 
			// return the resvar. Often it will not be needed
			// FIXME what happens if there is no node?!?
		};
		
		
		While.prototype.js = function (o){
			var out = ("while (" + this.test().c({expression: true}) + ")") + this.body().c({braces: true,indent: true}); // .wrap
			
			if (this.scope().vars().count() > 0) {
				// p "while-block has declared variables(!)"
				return [this.scope().vars().c(),out];
			};
			return out;
		};
		
		
		
		// This should define an open scope
		// should rather 
		function For(o){
			if(o === undefined) o = {};
			this._traversed = false;
			this._options = o;
			this._scope = new ForScope(this);
			this._catcher = null;
		};
		
		subclass$(For,Loop);
		exports.For = For; // export class 
		For.prototype.visit = function (){
			this.scope().visit();
			this.options().source.traverse(); // what about awakening the vars here?
			this.declare();
			// should be able to toggle whether to keep the results here already(!)
			
			// add guard to body
			if (this.options().guard) {
				var op = IF(this.options().guard.invert(),Block.wrap([new ContinueStatement("continue")]));
				this.body().unshift(op,BR);
			};
			
			return this.body().traverse();
		};
		
		For.prototype.isBare = function (src){
			return src && src._variable && src._variable._isArray;
		};
		
		For.prototype.declare = function (){
			var o = this.options();
			var scope = this.scope();
			var src = o.source;
			var vars = o.vars = {};
			var oi = o.index;
			
			var bare = this.isBare(src);
			// p "source is a {src} - {bare}"
			// var i = vars:index = oi ? scope.declare(oi,0) : util.counter(0,yes).predeclare
			
			// what about a range where we also include an index?
			if (src instanceof Range) {
				// p "range for-loop"
				
				// really? declare? 
				// are we sure? _really_?
				vars.len = scope.declare('len',src.right()); // util.len(o,yes).predeclare
				// make the scope be the declarator
				// TODO would like to be able to have counter in range as well
				vars.index = scope.register(o.name,scope,{type: 'let',declared: true});
				// p "registered {vars:index:constructor}"
				// p "index-var is declareod?!?! {vars:index.@declared}"
				scope.vars().push(vars.index.assignment(src.left()));
				// scope.declare(options:name,src.left)
				vars.value = vars.index;
			} else {
				// vars:value = scope.declare(options:name,null,let: yes)
				// we are using automatic caching far too much here
				
				// we should simply change how declare works
				var i = vars.index = oi ? (scope.declare(oi,0,{type: 'let'})) : (this.util().counter(0,true,scope).predeclare());
				
				vars.source = bare ? (src) : (this.util().iterable(src,true).predeclare());
				vars.len = this.util().len(vars.source,true).predeclare();
				
				vars.value = scope.declare(o.name,null,{type: 'let'});
				vars.value.addReference(o.name); // adding reference!
				if (oi) { i.addReference(oi) };
			};
			
			return this;
		};
		
		
		For.prototype.consume = function (node){
			
			var receiver;
			if (this.isExpressable()) {
				return For.__super__.consume.apply(this,arguments);
			};
			
			// other cases as well, no?
			if (node instanceof TagTree) {
				this.scope().context().reference();
				var ref = node.root().reference();
				node._loop = this;
				
				// Should not be consumed the same way
				this.body().consume(node);
				node._loop = null;
				var fn = new Lambda([new Param(ref)],[this]);
				fn.scope().wrap(this.scope());
				// TODO Scope of generated lambda should be added into stack for
				// variable naming / resolution
				return CALL(fn,[ref]);
			};
			
			
			if (this._resvar) {
				// p "already have a resvar -- change consume? {node}"
				var ast = new Block([this,BR,this._resvar.accessor()]);
				ast.consume(node);
				return ast;
			};
			
			// if node isa return -- do something else
			
			var resvar = null;
			var reuseable = false; // node isa Assign && node.left.node isa LocalVarAccess
			var assignee = null;
			// might only work for locals?
			if (node instanceof Assign) {
				// p "node isa assign {node} {node.left}"
				if (receiver = node.left()) {
					if (assignee = receiver._variable) {
						// we can only pull the var reference into the scope
						// if we know that the variable is declared in this scope
						reuseable = (receiver instanceof VarReference);
					};
				};
			};
			
			// p "reusable?!?! {node} {node}"
			
			// WARN Optimization - might have untended side-effects
			// if we are assigning directly to a local variable, we simply
			// use said variable for the inner res
			if (reuseable && assignee) {
				// instead of declaring it in the scope - why not declare it outside?
				// it might already exist in the outer scope no?
				// p "reuseable {assignee} {scope} {scope.parent.lookup(assignee)}"
				// assignee.resolve
				// should probably instead alter the assign-node to set value to a blank array
				// resvar = scope.parent.declare(assignee,Arr.new([]),proxy: yes,pos: 0)
				
				// this variable should really not be redeclared inside here at all
				assignee.resolve();
				// resvar = @resvar = scope.declare(assignee,Arr.new([]),proxy: yes)
				
				// dont declare it - simply push an assign into the vardecl of scope
				this.scope().vars().unshift(OP('=',assignee,new Arr([])));
				resvar = this._resvar = assignee;
				
				node._consumer = this;
				node = null;
				
				// p "consume variable declarator!?".cyan
			} else {
				// declare the variable we will use to soak up results
				// p "Creating value to store the result of loop".cyan
				// what about a pool here?
				resvar = this._resvar = this.scope().declare('res',new Arr([]),{system: true});
			};
			
			this._catcher = new PushAssign("push",resvar,null); // the value is not preset
			this.body().consume(this._catcher); // should still return the same body
			
			
			
			if (node) {
				// p "returning new ast where Loop is first"
				ast = new Block([this,BR,resvar.accessor().consume(node)]);
				return ast;
			};
			// var ast = Block.new([self,BR,resvar.accessor])
			// ast.consume(node) if node
			// return ast
			// p "Loop did consume successfully"
			return this;
			
			// this is never an expression (for now -- but still)
			// return ast
		};
		
		
		For.prototype.js = function (o){
			var v_;
			var vars = this.options().vars;
			var i = vars.index;
			var val = vars.value;
			var cond = OP('<',i,vars.len);
			var src = this.options().source;
			
			// p "references for value",val.references:length
			
			var final = this.options().step ? (
				OP('=',i,OP('+',i,this.options().step))
			) : (
				OP('++',i)
			);
			
			// if there are few references to the value - we can drop
			// the actual variable and instead make it proxy through the index
			if (src instanceof Range) {
				if (src.inclusive()) { (cond.setOp(v_ = '<='),v_) };
			} else if (val.refcount() < 3 && val.assignments().length == 0) {
				// p "proxy the value {val.assignments:length}"
				// p "should proxy value-variable instead"
				val.proxy(vars.source,i);
			} else {
				this.body().unshift(OP('=',val,OP('.',vars.source,i)),BR);
				// body.unshift(head)
				// TODO check lengths - intelligently decide whether to brace and indent
			};
			var head = ("" + mark__(this.options().keyword) + "for (" + (this.scope().vars().c()) + "; " + (cond.c()) + "; " + (final.c()) + ") ");
			return head + this.body().c({braces: true,indent: true}); // .wrap
		};
		
		
		For.prototype.head = function (){
			var vars = this.options().vars;
			return OP('=',vars.value,OP('.',vars.source,vars.index));
		};
		
		
		
		function ForIn(){ return For.apply(this,arguments) };
		
		subclass$(ForIn,For);
		exports.ForIn = ForIn; // export class 
		
		
		
		
		function ForOf(){ return For.apply(this,arguments) };
		
		subclass$(ForOf,For);
		exports.ForOf = ForOf; // export class 
		ForOf.prototype.declare = function (){
			var o = this.options();
			var vars = o.vars = {};
			
			// see if 
			
			// p "ForOf source isa {o:source}"
			
			// if o:source is a variable -- refer directly # variable? is this the issue?
			// p scope.@varmap['o'], scope.parent.@varmap['o']
			
			var src = vars.source = o.source._variable || this.scope().declare('o',o.source,{system: true,type: 'let'});
			if (o.index) { var v = vars.value = this.scope().declare(o.index,null,{let: true}) };
			
			// p "ForOf o:index {o:index} o:name {o:name}"
			// if o:index
			
			// possibly proxy the index-variable?
			
			if (o.own) {
				// var i = vars:index = scope.declare('i',0,system: true, type: 'let') # mark as a counter?
				var i = vars.index = this.util().counter(0,true,this.scope()).predeclare();
				// systemvariable -- should not really be added to the map
				var keys = vars.keys = this.scope().declare('keys',Util.keys(src.accessor()),{system: true,type: 'let'}); // the outer one should resolve first
				var l = vars.len = this.scope().declare('l',Util.len(keys.accessor()),{system: true,type: 'let'});
				var k = vars.key = this.scope().register(o.name,o.name,{type: 'let'}); // scope.declare(o:name,null,system: yes)
			} else {
				// we set the var -- why even declare it
				// no need to declare -- it will declare itself in the loop - no?
				k = vars.key = this.scope().register(o.name,o.name,{type: 'let'});
			};
			
			// TODO use util - why add references already? Ah -- this is for the highlighting
			if (v && o.index) { v.addReference(o.index) };
			if (k && o.name) { k.addReference(o.name) };
			
			return this;
		};
		
		ForOf.prototype.js = function (o){
			var vars = this.options().vars;
			
			var o = vars.source;
			var k = vars.key;
			var v = vars.value;
			var i = vars.index;
			
			
			if (v) {
				// set value as proxy of object[key]
				// possibly make it a ref? what is happening?
				v.refcount() < 3 ? (v.proxy(o,k)) : (this.body().unshift(OP('=',v,OP('.',o,k))));
			};
			
			if (this.options().own) {
				
				if (k.refcount() < 3) { // should probably adjust these
					k.proxy(vars.keys,i);
				} else {
					this.body().unshift(OP('=',k,OP('.',vars.keys,i)));
				};
				
				var head = ("" + mark__(this.options().keyword) + "for (" + (this.scope().vars().c()) + "; " + (OP('<',i,vars.len).c()) + "; " + (OP('++',i).c()) + ")");
				return head + this.body().c({indent: true,braces: true}); // .wrap
			};
			
			var code = this.body().c({braces: true,indent: true});
			// it is really important that this is a treated as a statement
			return this.scope().vars().c() + (";\n" + mark__(this.options().keyword) + "for (var " + (k.c()) + " in " + (o.c()) + ")") + code;
		};
		
		ForOf.prototype.head = function (){
			var v = this.options().vars;
			
			return [
				OP('=',v.key,OP('.',v.keys,v.index)),
				(v.value) && (OP('=',v.value,OP('.',v.source,v.key)))
			];
		};
		
		// NO NEED?
		function Begin(body){
			this._nodes = blk__(body).nodes();
		};
		
		
		subclass$(Begin,Block);
		exports.Begin = Begin; // export class 
		Begin.prototype.shouldParenthesize = function (){
			return this.isExpression();
		};
		
		
		
		function Switch(a,b,c){
			this._traversed = false;
			this._source = a;
			this._cases = b;
			this._fallback = c;
		};
		
		
		subclass$(Switch,ControlFlowStatement);
		exports.Switch = Switch; // export class 
		Switch.prototype.source = function(v){ return this._source; }
		Switch.prototype.setSource = function(v){ this._source = v; return this; };
		Switch.prototype.cases = function(v){ return this._cases; }
		Switch.prototype.setCases = function(v){ this._cases = v; return this; };
		Switch.prototype.fallback = function(v){ return this._fallback; }
		Switch.prototype.setFallback = function(v){ this._fallback = v; return this; };
		
		
		Switch.prototype.visit = function (){
			for (var i = 0, ary = iter$(this.cases()), len = ary.length; i < len; i++) {
				ary[i].traverse();
			};
			if (this.fallback()) { this.fallback().visit() };
			if (this.source()) { this.source().visit() };
			return;
		};
		
		
		Switch.prototype.consume = function (node){
			// TODO work inside tags (like loops)
			this._cases = this._cases.map(function(item) { return item.consume(node); });
			if (this._fallback) { this._fallback = this._fallback.consume(node) };
			return this;
		};
		
		Switch.prototype.c = function (o){
			if (this.stack().isExpression() || this.isExpression()) {
				var ast = CALL(FN([],[this]),[]);
				return ast.c(o);
			};
			
			return Switch.__super__.c.call(this,o);
		};
		
		
		Switch.prototype.js = function (o){
			var body = [];
			
			for (var i = 0, ary = iter$(this.cases()), len = ary.length, part; i < len; i++) {
				part = ary[i];
				part.autobreak();
				body.push(part);
			};
			
			if (this.fallback()) {
				body.push("default:\n" + this.fallback().c({indent: true}));
			};
			
			return ("switch (" + (this.source().c()) + ") ") + helpers.bracketize(cary__(body).join("\n"),true);
		};
		
		
		
		function SwitchCase(test,body){
			this._traversed = false;
			this._test = test;
			this._body = blk__(body);
		};
		
		subclass$(SwitchCase,ControlFlowStatement);
		exports.SwitchCase = SwitchCase; // export class 
		SwitchCase.prototype.test = function(v){ return this._test; }
		SwitchCase.prototype.setTest = function(v){ this._test = v; return this; };
		SwitchCase.prototype.body = function(v){ return this._body; }
		SwitchCase.prototype.setBody = function(v){ this._body = v; return this; };
		
		
		SwitchCase.prototype.visit = function (){
			return this.body().traverse();
		};
		
		
		SwitchCase.prototype.consume = function (node){
			this.body().consume(node);
			return this;
		};
		
		
		SwitchCase.prototype.autobreak = function (){
			if (!((this.body().last() instanceof BreakStatement))) { this.body().push(new BreakStatement()) };
			return this;
		};
		
		
		SwitchCase.prototype.js = function (o){
			if (!((this._test instanceof Array))) { this._test = [this._test] };
			var cases = this._test.map(function(item) { return ("case " + (item.c()) + ":"); });
			return cases.join("\n") + this.body().c({indent: true}); // .indent
		};
		
		
		
		function Try(body,c,f){
			this._traversed = false;
			this._body = blk__(body);
			this._catch = c;
			this._finally = f;
		};
		
		
		subclass$(Try,ControlFlowStatement);
		exports.Try = Try; // export class 
		Try.prototype.body = function(v){ return this._body; }
		Try.prototype.setBody = function(v){ this._body = v; return this; };
		// prop ncatch
		// prop nfinally
		
		Try.prototype.consume = function (node){
			this._body = this._body.consume(node);
			if (this._catch) { this._catch = this._catch.consume(node) };
			if (this._finally) { this._finally = this._finally.consume(node) };
			return this;
		};
		
		
		Try.prototype.visit = function (){
			this._body.traverse();
			if (this._catch) { this._catch.traverse() };
			if (this._finally) { return this._finally.traverse() };
			// no blocks - add an empty catch
		};
		
		
		Try.prototype.js = function (o){
			var out = "try " + this.body().c({braces: true,indent: true});
			if (this._catch) { out += " " + this._catch.c() };
			if (this._finally) { out += " " + this._finally.c() };
			
			if (!(this._catch || this._finally)) {
				out += (" catch (e) \{ \}");
			};
			out += ";";
			return out;
		};
		
		
		
		function Catch(body,varname){
			this._traversed = false;
			this._body = blk__(body || []);
			this._scope = new CatchScope(this);
			this._varname = varname;
			this;
		};
		
		subclass$(Catch,ControlFlowStatement);
		exports.Catch = Catch; // export class 
		Catch.prototype.body = function(v){ return this._body; }
		Catch.prototype.setBody = function(v){ this._body = v; return this; };
		
		Catch.prototype.consume = function (node){
			this._body = this._body.consume(node);
			return this;
		};
		
		
		Catch.prototype.visit = function (){
			this._scope.visit();
			this._variable = this._scope.register(this._varname,this,{pool: 'catchvar'});
			return this._body.traverse();
		};
		
		
		Catch.prototype.js = function (o){
			// only indent if indented by default?
			return ("catch (" + (this._variable.c()) + ") ") + this._body.c({braces: true,indent: true});
		};
		
		
		// repeating myself.. don't deal with it until we move to compact tuple-args
		// for all astnodes
		
		
		function Finally(body){
			this._traversed = false;
			this._body = blk__(body || []);
		};
		
		
		subclass$(Finally,ControlFlowStatement);
		exports.Finally = Finally; // export class 
		Finally.prototype.visit = function (){
			return this._body.traverse();
		};
		
		
		Finally.prototype.consume = function (node){
			// swallow silently
			return this;
		};
		
		
		Finally.prototype.js = function (o){
			return "finally " + this._body.c({braces: true,indent: true});
		};
		
		
		// RANGE
		
		function Range(){ return Op.apply(this,arguments) };
		
		subclass$(Range,Op);
		exports.Range = Range; // export class 
		Range.prototype.inclusive = function (){
			return this.op() == '..';
		};
		
		Range.prototype.c = function (){
			return "range";
		};
		
		
		function Splat(){ return ValueNode.apply(this,arguments) };
		
		subclass$(Splat,ValueNode);
		exports.Splat = Splat; // export class 
		Splat.prototype.js = function (o){
			var par = this.stack().parent();
			if ((par instanceof ArgList) || (par instanceof Arr)) {
				return ("[].slice.call(" + (this.value().c()) + ")");
			} else {
				this.p(("what is the parent? " + par));
				return "SPLAT";
			};
		};
		
		Splat.prototype.node = function (){
			return this.value();
		};
		
		
		
		
		
		// TAGS
		
		
		TAG_TYPES = {};
		TAG_ATTRS = {};
		
		
		TAG_TYPES.HTML = "a abbr address area article aside audio b base bdi bdo big blockquote body br button canvas caption cite code col colgroup data datalist dd del details dfn div dl dt em embed fieldset figcaption figure footer form h1 h2 h3 h4 h5 h6 head header hr html i iframe img input ins kbd keygen label legend li link main map mark menu menuitem meta meter nav noscript object ol optgroup option output p param pre progress q rp rt ruby s samp script section select small source span strong style sub summary sup table tbody td textarea tfoot th thead time title tr track u ul var video wbr".split(" ");
		
		TAG_TYPES.SVG = "circle defs ellipse g line linearGradient mask path pattern polygon polyline radialGradient rect stop svg text tspan".split(" ");
		
		TAG_ATTRS.HTML = "accept accessKey action allowFullScreen allowTransparency alt async autoComplete autoFocus autoPlay cellPadding cellSpacing charSet checked className cols colSpan content contentEditable contextMenu controls coords crossOrigin data dateTime defer dir disabled download draggable encType form formNoValidate frameBorder height hidden href hrefLang htmlFor httpEquiv icon id label lang list loop max maxLength mediaGroup method min multiple muted name noValidate pattern placeholder poster preload radioGroup readOnly rel required role rows rowSpan sandbox scope scrollLeft scrolling scrollTop seamless selected shape size span spellCheck src srcDoc srcSet start step style tabIndex target title type useMap value width wmode";
		
		TAG_ATTRS.SVG = "cx cy d dx dy fill fillOpacity fontFamily fontSize fx fy gradientTransform gradientUnits markerEnd markerMid markerStart offset opacity patternContentUnits patternUnits points preserveAspectRatio r rx ry spreadMethod stopColor stopOpacity stroke strokeDasharray strokeLinecap strokeOpacity strokeWidth textAnchor transform version viewBox x1 x2 x y1 y2 y";
		
		
		function TagDesc(){
			this.p('TagDesc!!!',arguments);
			this;
		};
		
		subclass$(TagDesc,Node);
		exports.TagDesc = TagDesc; // export class 
		TagDesc.prototype.classes = function (){
			this.p('TagDescClasses',arguments);
			return this;
		};
		
		function Tag(o){
			if(o === undefined) o = {};
			this._traversed = false;
			this._parts = [];
			o.classes || (o.classes = []);
			o.attributes || (o.attributes = []);
			o.classes || (o.classes = []);
			this._options = o;
			this._reference = null;
			this._object = null;
			this._tree = null;
			this;
		};
		
		subclass$(Tag,Node);
		exports.Tag = Tag; // export class 
		Tag.prototype.parts = function(v){ return this._parts; }
		Tag.prototype.setParts = function(v){ this._parts = v; return this; };
		Tag.prototype.object = function(v){ return this._object; }
		Tag.prototype.setObject = function(v){ this._object = v; return this; };
		Tag.prototype.reactive = function(v){ return this._reactive; }
		Tag.prototype.setReactive = function(v){ this._reactive = v; return this; };
		Tag.prototype.parent = function(v){ return this._parent; }
		Tag.prototype.setParent = function(v){ this._parent = v; return this; };
		Tag.prototype.tree = function(v){ return this._tree; }
		Tag.prototype.setTree = function(v){ this._tree = v; return this; };
		
		Tag.prototype.set = function (obj){
			for (var v, i = 0, keys = Object.keys(obj), l = keys.length; i < l; i++){
				k = keys[i];v = obj[k];if (k == 'attributes') {
					// p "attributs!"
					for (var j = 0, ary = iter$(v), len = ary.length; j < len; j++) {
						this.addAttribute(ary[j]);
					};
					continue;
				};
				
				this._options[k] = v;
			};
			return this;
		};
		
		Tag.prototype.addClass = function (node){
			if (!((node instanceof TagFlag))) {
				node = new TagFlag(node);
			};
			this._options.classes.push(node);
			this._parts.push(node);
			
			// p "add class!!!"
			return this;
		};
		
		Tag.prototype.addIndex = function (node){
			this._parts.push(node);
			this._object = node;
			return this;
		};
		
		Tag.prototype.addSymbol = function (node){
			// p "addSymbol to the tag",node
			if (this._parts.length == 0) {
				this._parts.push(node);
				this._options.ns = node;
			};
			return this;
		};
		
		
		Tag.prototype.addAttribute = function (atr){
			// p "add attribute!!!", key, value
			this._parts.push(atr); // what?
			this._options.attributes.push(atr);
			return this;
		};
		
		Tag.prototype.enclosing = function (){
			return this._options.close && this._options.close.value();
		};
		
		Tag.prototype.type = function (){
			return this._options.type || 'div';
		};
		
		Tag.prototype.consume = function (node){
			var o = this._options;
			
			
			if (node instanceof TagTree) {
				// p "tag consume tagtree? {node.reactive}"
				this.setParent(node.root());
				// o:treeRef = node.nextCacheKey
				
				if (node._loop) {
					// alwatys make items in loop reactive
					this.setReactive(node.reactive() || this.option('key'));
					this.option('loop',node._loop);
					
					if (this.option('ivar')) {
						this.warn(("Tag inside loop can not have a static reference " + this.option('ivar')),{type: 'error',token: this.option('ivar').value()});
					};
				} else {
					this.setReactive(node.reactive() || !(!this.option('ivar')));
				};
				
				return this;
			};
			
			return Tag.__super__.consume.apply(this,arguments);
		};
		
		
		Tag.prototype.visit = function (){
			
			var o = this._options;
			
			if (o.ivar || o.key) {
				this.setReactive(true);
			};
			
			var typ = this.enclosing();
			
			// look for outer tag here?
			
			if (typ == '->' || typ == '=>') {
				// console.log "tag is template?!? {typ}"
				this._tree = new TagTree(this,o.body,{root: this,reactive: this.reactive()});
				o.body = new TagFragmentFunc([],Block.wrap([this._tree]));
				// console.log "made o body a function?"
			};
			
			if (o.key) { o.key.traverse() };
			
			if (o.body) {
				o.body.traverse();
			};
			
			// id should also be a regular part
			
			if (o.id) { o.id.traverse() };
			
			
			for (var i = 0, ary = iter$(this._parts), len = ary.length; i < len; i++) {
				ary[i].traverse();
			};
			
			// for atr in @options:attributes
			// 	atr.traverse
			
			return this;
		};
		
		Tag.prototype.reference = function (){
			return this._reference || (this._reference = this.scope__().closure().temporary(this,{pool: 'tag'}).resolve());
		};
		
		// should this not happen in js?
		// should this not happen in js?
		Tag.prototype.js = function (o){
			// p JSON.stringify(@options)
			// var attrs = TagAttributes.new(o:attributes)
			// p "got here?"
			var body;
			var o = this._options;
			var a = {};
			var enc = this.enclosing();
			
			var setup = [];
			var calls = [];
			var statics = [];
			
			var scope = this.scope__();
			var commit = "end";
			var content = o.body;
			
			var isSelf = (this.type() instanceof Self);
			var bodySetter = isSelf ? ("setChildren") : ("setContent");
			
			// should not cache statics if the node itself is not cached
			// that would only mangle the order in which we set the properties
			var cacheStatics = true;
			
			for (var i = 0, ary = iter$(o.attributes), len = ary.length, atr; i < len; i++) {
				atr = ary[i];
				a[atr.key()] = atr.value(); // .populate(obj)
			};
			
			var quote = function(str) { return helpers.singlequote(str); };
			var id = o.id instanceof Node ? (o.id.c()) : ((o.id && quote(o.id.c())));
			var tree = this._tree || null;
			var parent = this.parent();
			// var parTree = parent and parent.tree
			
			
			//  "scope is", !!scope
			// p "type is {type}"
			var out = isSelf ? (
				commit = "synced",
				// p "got here"
				// setting correct context directly
				this.setReactive(true),
				this._reference = scope.context(),
				scope.context().c()
			) : (
				("" + mark__(o.open) + (scope.tagContextPath()) + "." + (this.type().spawner()) + "()")
			);
			
			if (o.id) {
				statics.push((".setId(" + quote(o.id) + ")"));
			};
			// this is reactive if it has an ivar
			if (o.ivar) {
				this.setReactive(true);
				statics.push((".setRef(" + quote(o.ivar.name()) + "," + (scope.context().c()) + ")"));
			};
			
			if (o.body instanceof Func) {
				// console.log "o:body isa function!"
				bodySetter = "setTemplate";
			} else if (o.body) {
				if ((o.body instanceof ArgList) && o.body.count() == 1 && o.body.first().isString()) {
					bodySetter = "setText";
				} else {
					// would probably be better to convert to a tagtree during the initial visit
					tree = new TagTree(this,o.body,{root: this,reactive: this.reactive()});
					content = tree;
					this.setTree(tree);
				};
			};
			
			if (tree) {
				// this is the point where we traverse the inner nodes with our tree
				// should rather happen in visit - long before.
				tree.resolve();
			};
			
			for (var i = 0, ary = iter$(this._parts), len = ary.length, part; i < len; i++) {
				part = ary[i];
				var pjs;
				var pcache = false;
				
				if (part instanceof TagAttr) {
					var akey = String(part.key());
					var aval = part.value();
					// p "part value {aval} {aval.isPrimitive(yes)}"
					
					// the attr should compile itself instead -- really
					pcache = aval.isPrimitive();
					
					if (akey[0] == '.') { // should check in a better way
						pcache = false;
						pjs = (".flag(" + quote(akey.substr(1)) + "," + (aval.c()) + ")");
					} else if (akey[0] == ':') {
						// need to analyze whether this is static or not
						pjs = (".setHandler(" + quote(akey.substr(1)) + "," + (aval.c()) + "," + (scope.context().c()) + ")");
					} else if (akey.substr(0,5) == 'data-') {
						pjs = (".dataset('" + akey.slice(5) + "'," + (aval.c()) + ")");
					} else {
						pjs = ("." + mark__(part.key()) + helpers.setterSym(akey) + "(" + (aval.c()) + ")");
					};
				} else if (part instanceof TagFlag) {
					pjs = part.c();
					pcache = true;
				};
				
				if (pjs) {
					cacheStatics && pcache ? (statics.push(pjs)) : (calls.push(pjs));
				};
			};
			
			
			
			if (this.object()) {
				calls.push((".setObject(" + (this.object().c()) + ")"));
			};
			
			// p "tagtree is static? {tree.static}"
			
			// we need to trigger our own reference before the body does
			// but we do not need a reference if we have no body (no nodes will refer it)
			if (this.reactive() && tree) { // and tree.hasTags
				this.reference();
			};
			
			if (this.reactive() && parent && parent.tree()) {
				o.treeRef = parent.tree().nextCacheKey(this);
			};
			
			if (body = content && content.c({expression: true})) { // force it to be an expression, no?
				var typ = 0;
				
				if (tree) {
					if (tree.static()) {
						typ = 2;
					} else if (this.reactive() || tree.reactive()) {
						if (!tree.single() || (tree.single() instanceof If)) {
							typ = 1;
						} else {
							typ = 3;
						};
					};
				};
				
				
				if (bodySetter == 'setChildren' || bodySetter == 'setContent') {
					calls.push(("." + bodySetter + "(" + body + "," + typ + ")"));
				} else {
					calls.push(("." + bodySetter + "(" + body + ")"));
				};
				
				// out += ".body({body})"
			};
			
			// if o:attributes:length # or -- always?
			// adds lots of extra calls - but okay for now
			calls.push(("." + commit + "()"));
			
			if (statics.length) {
				out = out + statics.join("");
			};
			
			
			if ((o.ivar || o.key || this.reactive()) && !(this.type() instanceof Self)) {
				// if this is an ivar, we should set the reference relative
				// to the outer reference, or possibly right on context?
				var ctx,key;
				var partree = parent && parent.tree();
				// ctx = !o:ivar and par and par.reference or scope.context
				// key = o:ivar or tree and tree.nextCacheKey
				
				if (o.key) {
					// closest tag
					// TODO if the dynamic key starts with a static string we should
					// just prepend _ to the string instead of wrapping in OP
					ctx = parent && parent.reference();
					key = OP('+',new Str("'_'"),o.key);
				} else if (o.ivar) {
					ctx = scope.context();
					key = o.ivar;
				} else {
					ctx = parent && parent.reference();
					// ctx = partree.cacher
					key = o.treeRef || partree && partree.nextCacheKey();
					// key = tree and tree.nextCacheKey
					if (o.loop) {
						var idx = o.loop.option('vars').index;
						key = OP('+',"'" + key + "'",idx);
					};
				};
				
				
				
				// need the context -- might be better to rewrite it for real?
				// parse the whole thing into calls etc
				var acc = OP('.',ctx,key).c();
				
				if (this._reference) {
					out = ("(" + (this.reference().c()) + " = " + acc + "=" + acc + " || " + out + ")");
				} else {
					out = ("(" + acc + " = " + acc + " || " + out + ")");
				};
			};
			
			return out + calls.join("");
		};
		
		// This is a helper-node
		// Should probably use the same type of listnode everywhere - and simply flag the type as TagTree instead
		function TagTree(owner,list,options){
			if(options === undefined) options = {};
			this._owner = owner;
			this._nodes = this.load(list);
			this._options = options;
			this._conditions = [];
			this._blocks = [this];
			this._counter = 0;
			this;
		};
		
		subclass$(TagTree,ListNode);
		exports.TagTree = TagTree; // export class 
		TagTree.prototype.counter = function(v){ return this._counter; }
		TagTree.prototype.setCounter = function(v){ this._counter = v; return this; };
		TagTree.prototype.conditions = function(v){ return this._conditions; }
		TagTree.prototype.setConditions = function(v){ this._conditions = v; return this; };
		TagTree.prototype.blocks = function(v){ return this._blocks; }
		TagTree.prototype.setBlocks = function(v){ this._blocks = v; return this; };
		TagTree.prototype.cacher = function(v){ return this._cacher; }
		TagTree.prototype.setCacher = function(v){ this._cacher = v; return this; };
		
		TagTree.prototype.parent = function (){
			return this._parent || (this._parent = this._owner.parent());
		};
		
		TagTree.prototype.nextCacheKey = function (){
			var root = this._owner;
			
			// if we want to cache everything on root
			var num = ++this._counter;
			var base = "A".charCodeAt(0);
			var str = "";
			
			while (true){
				num -= 1;
				str = String.fromCharCode(base + (num % 26)) + str;
				num = Math.floor(num / 26);
				if (num <= 0) { break; };
			};
			
			str = (this._owner.type() instanceof Self ? ("$") : ("$$")) + str.toLowerCase();
			return str;
			return num;
		};
		
		TagTree.prototype.load = function (list){
			if (list instanceof ListNode) {
				// p "is a list node!! {list.count}"
				// we still want the indentation if we are not in a template
				// or, rather - we want the block to get the indentation - not the tree
				this._indentation || (this._indentation = list._indentation); // if list.count > 1
				return list.nodes();
			} else {
				return compact__(list instanceof Array ? (list) : ([list]));
			};
		};
		
		TagTree.prototype.root = function (){
			return this.option('root');
		};
		
		TagTree.prototype.reactive = function (){
			return this.option('reactive');
		};
		
		TagTree.prototype.resolve = function (){
			var self = this;
			this.remap(function(c) { return c.consume(self); });
			return self;
		};
		
		TagTree.prototype.static = function (){
			// every real node
			return this._static == null ? (this._static = this.every(function(c) { return (c instanceof Tag) || (c instanceof Str) || (c instanceof Meta); })) : (this._static);
		};
		
		TagTree.prototype.single = function (){
			return this._single == null ? (this._single = (this.realCount() == 1 ? (this.last()) : (false))) : (this._single);
		};
		
		TagTree.prototype.hasTags = function (){
			return this.some(function(c) { return c instanceof Tag; });
		};
		
		TagTree.prototype.c = function (o){
			// FIXME TEST what about comments???
			var single = this.single();
			
			// no indentation if this should return
			if (single && (STACK.current() instanceof Return)) {
				this._indentation = null;
			};
			
			var out = TagTree.__super__.c.call(this,o);
			
			if (!single || (single instanceof If)) {
				return ("[" + out + "]");
			} else {
				return out;
			};
		};
		
		function TagWrapper(){ return ValueNode.apply(this,arguments) };
		
		subclass$(TagWrapper,ValueNode);
		exports.TagWrapper = TagWrapper; // export class 
		TagWrapper.prototype.visit = function (){
			if (this.value() instanceof Array) {
				this.value().map(function(v) { return v.traverse(); });
			} else {
				this.value().traverse();
			};
			return this;
		};
		
		TagWrapper.prototype.c = function (){
			return ("tag$wrap(" + this.value().c({expression: true}) + ")");
		};
		
		
		function TagAttributes(){ return ListNode.apply(this,arguments) };
		
		subclass$(TagAttributes,ListNode);
		exports.TagAttributes = TagAttributes; // export class 
		TagAttributes.prototype.get = function (name){
			for (var i = 0, ary = iter$(this.nodes()), len = ary.length, node, res = []; i < len; i++) {
				node = ary[i];
				if (node.key() == name) { return node };
			};
			return res;
		};
		
		
		function TagAttr(k,v){
			// p "init TagAttribute", $0
			this._traversed = false;
			this._key = k;
			this._value = v;
		};
		
		subclass$(TagAttr,Node);
		exports.TagAttr = TagAttr; // export class 
		TagAttr.prototype.key = function(v){ return this._key; }
		TagAttr.prototype.setKey = function(v){ this._key = v; return this; };
		TagAttr.prototype.value = function(v){ return this._value; }
		TagAttr.prototype.setValue = function(v){ this._value = v; return this; };
		
		TagAttr.prototype.visit = function (){
			if (this.value()) { this.value().traverse() };
			return this;
		};
		
		TagAttr.prototype.populate = function (obj){
			obj.add(this.key(),this.value());
			return this;
		};
		
		TagAttr.prototype.c = function (){
			return "attribute";
		};
		
		
		function TagFlag(value){
			this._traversed = false;
			this._value = value;
			this;
		};
		
		subclass$(TagFlag,Node);
		exports.TagFlag = TagFlag; // export class 
		TagFlag.prototype.value = function(v){ return this._value; }
		TagFlag.prototype.setValue = function(v){ this._value = v; return this; };
		TagFlag.prototype.toggler = function(v){ return this._toggler; }
		TagFlag.prototype.setToggler = function(v){ this._toggler = v; return this; };
		
		TagFlag.prototype.visit = function (){
			if (!((typeof this._value=='string'||this._value instanceof String))) {
				this._value.traverse();
			};
			return this;
		};
		
		TagFlag.prototype.c = function (){
			if (this.value() instanceof Node) {
				return (".flag(" + (this.value().c()) + ")");
			} else {
				return (".flag(" + helpers.singlequote(this.value()) + ")");
			};
		};
		
		
		
		
		
		
		// SELECTORS
		
		
		function Selector(list,options){
			this._nodes = list || [];
			this._options = options;
		};
		
		subclass$(Selector,ListNode);
		exports.Selector = Selector; // export class 
		Selector.prototype.add = function (part,typ){
			// p "select add!",part,typ
			// mark if special?
			this.push(part);
			return this;
		};
		
		Selector.prototype.group = function (){
			// console.log "grouped!"
			// for now we simply add a comma
			// how would this work for dst?
			this._nodes.push(new SelectorGroup(","));
			return this;
		};
		
		Selector.prototype.query = function (){
			var str = "";
			var ary = [];
			
			for (var i = 0, items = iter$(this.nodes()), len = items.length; i < len; i++) {
				var val = items[i].c();
				if ((typeof val=='string'||val instanceof String)) {
					str = ("" + str + val);
				};
			};
			
			return ("'" + str + "'");
		};
		
		
		Selector.prototype.js = function (o){
			var typ = this.option('type');
			var q = c__(this.query());
			
			if (typ == '%') {
				return ("q$(" + q + "," + o.scope().context().c({explicit: true}) + ")"); // explicit context
			} else if (typ == '%%') {
				return ("q$$(" + q + "," + o.scope().context().c({explicit: true}) + ")");
			} else {
				return ("q" + typ + "(" + q + ")");
			};
			
			// return "{typ} {scoped} - {all}"
		};
		
		
		function SelectorPart(){ return ValueNode.apply(this,arguments) };
		
		subclass$(SelectorPart,ValueNode);
		exports.SelectorPart = SelectorPart; // export class 
		SelectorPart.prototype.c = function (){
			return c__(this._value);
			// "{value.c}"
		};
		
		function SelectorGroup(){ return SelectorPart.apply(this,arguments) };
		
		subclass$(SelectorGroup,SelectorPart);
		exports.SelectorGroup = SelectorGroup; // export class 
		SelectorGroup.prototype.c = function (){
			return ",";
		};
		
		function SelectorType(){ return SelectorPart.apply(this,arguments) };
		
		subclass$(SelectorType,SelectorPart);
		exports.SelectorType = SelectorType; // export class 
		SelectorType.prototype.c = function (){
			// support
			// p "selectortype {value}"
			// var out = value.c
			var name = this.value().name();
			
			// at least be very conservative about which tags we
			// can drop the tag for?
			// out in TAG_TYPES.HTML ? 
			return idx$(name,TAG_TYPES.HTML) >= 0 ? (name) : (this.value().sel());
		};
		
		
		function SelectorUniversal(){ return SelectorPart.apply(this,arguments) };
		
		subclass$(SelectorUniversal,SelectorPart);
		exports.SelectorUniversal = SelectorUniversal; // export class 
		
		
		function SelectorNamespace(){ return SelectorPart.apply(this,arguments) };
		
		subclass$(SelectorNamespace,SelectorPart);
		exports.SelectorNamespace = SelectorNamespace; // export class 
		
		
		function SelectorClass(){ return SelectorPart.apply(this,arguments) };
		
		subclass$(SelectorClass,SelectorPart);
		exports.SelectorClass = SelectorClass; // export class 
		SelectorClass.prototype.c = function (){
			if (this._value instanceof Node) {
				return (".'+" + (this._value.c()) + "+'");
			} else {
				return ("." + c__(this._value));
			};
		};
		
		function SelectorId(){ return SelectorPart.apply(this,arguments) };
		
		subclass$(SelectorId,SelectorPart);
		exports.SelectorId = SelectorId; // export class 
		SelectorId.prototype.c = function (){
			if (this._value instanceof Node) {
				return ("#'+" + (this._value.c()) + "+'");
			} else {
				return ("#" + c__(this._value));
			};
		};
		
		function SelectorCombinator(){ return SelectorPart.apply(this,arguments) };
		
		subclass$(SelectorCombinator,SelectorPart);
		exports.SelectorCombinator = SelectorCombinator; // export class 
		SelectorCombinator.prototype.c = function (){
			return ("" + c__(this._value));
		};
		
		function SelectorPseudoClass(){ return SelectorPart.apply(this,arguments) };
		
		subclass$(SelectorPseudoClass,SelectorPart);
		exports.SelectorPseudoClass = SelectorPseudoClass; // export class 
		
		
		function SelectorAttribute(left,op,right){
			this._left = left;
			this._op = op;
			this._right = this._value = right;
		};
		
		subclass$(SelectorAttribute,SelectorPart);
		exports.SelectorAttribute = SelectorAttribute; // export class 
		SelectorAttribute.prototype.c = function (){
			// TODO possibly support .toSel or sel$(v) for items inside query
			// could easily do it with a helper-function that is added to the top of the filescope
			if (this._right instanceof Str) {
				return ("[" + (this._left.c()) + (this._op) + (this._right.c()) + "]");
			} else if (this._right) {
				// this is not at all good
				return ("[" + (this._left.c()) + (this._op) + "\"'+" + c__(this._right) + "+'\"]");
			} else {
				return ("[" + (this._left.c()) + "]");
				
				// ...
			};
		};
		
		
		
		
		// DEFER
		
		function Await(){ return ValueNode.apply(this,arguments) };
		
		subclass$(Await,ValueNode);
		exports.Await = Await; // export class 
		Await.prototype.func = function(v){ return this._func; }
		Await.prototype.setFunc = function(v){ this._func = v; return this; };
		
		Await.prototype.js = function (o){
			// introduce a util here, no?
			return CALL(OP('.',new Util.Promisify([this.value()]),'then'),[this.func()]).c();
			// value.c
		};
		
		Await.prototype.visit = function (o){
			// things are now traversed in a somewhat chaotic order. Need to tighten
			// Create await function - push this value up to block, take the outer
			var self = this;
			self.value().traverse();
			
			var block = o.up(Block); // or up to the closest FUNCTION?
			var outer = o.relative(block,1);
			var par = o.relative(self,-1);
			
			// p "Block {block} {outer} {par}"
			
			self.setFunc(new AsyncFunc([],[]));
			// now we move this node up to the block
			self.func().body().setNodes(block.defers(outer,self));
			
			// if the outer is a var-assignment, we can simply set the params
			if (par instanceof Assign) {
				par.left().traverse();
				var lft = par.left().node();
				// p "Async assignment {par} {lft}"
				// Can be a tuple as well, no?
				if (lft instanceof VarReference) {
					// the param is already registered?
					// should not force the name already??
					// beware of bugs
					self.func().params().at(0,true,lft.variable().name());
				} else if (lft instanceof Tuple) {
					// if this an unfancy tuple, with only vars
					// we can just use arguments
					
					if (par.type() == 'var' && !lft.hasSplat()) {
						// p "SIMPLIFY! {lft.nodes[0]}"
						lft.map(function(el,i) {
							return self.func().params().at(i,true,el.value());
						});
					} else {
						// otherwise, do the whole tuple
						// make sure it is a var assignment?
						par.setRight(ARGUMENTS);
						self.func().body().unshift(par);
					};
				} else {
					// regular setters
					par.setRight(self.func().params().at(0,true));
					self.func().body().unshift(par);
				};
			};
			
			
			
			// If it is an advance tuple or something, it should be possible to
			// feed in the paramlist, and let the tuple handle it as if it was any
			// other value
			
			// CASE If this is a tuple / multiset with more than one async value
			// we need to think differently.
			
			// now we need to visit the function as well
			self.func().traverse();
			// pull the outer in
			return self;
		};
		
		function AsyncFunc(params,body,name,target,options){
			AsyncFunc.__super__.constructor.call(this,params,body,name,target,options);
		};
		
		subclass$(AsyncFunc,Func);
		exports.AsyncFunc = AsyncFunc; // export class 
		AsyncFunc.prototype.scopetype = function (){
			return LambdaScope;
		};
		
		// need to override, since we wont do implicit returns
		// def js
		// 	var code = scope.c
		// 	return "function ({params.c})" + code.wrap
		;
		
		
		
		// IMPORTS
		
		function ImportStatement(imports,source,ns){
			this._traversed = false;
			this._imports = imports;
			this._source = source;
			this._ns = ns;
			this;
		};
		
		subclass$(ImportStatement,Statement);
		exports.ImportStatement = ImportStatement; // export class 
		ImportStatement.prototype.ns = function(v){ return this._ns; }
		ImportStatement.prototype.setNs = function(v){ this._ns = v; return this; };
		ImportStatement.prototype.imports = function(v){ return this._imports; }
		ImportStatement.prototype.setImports = function(v){ this._imports = v; return this; };
		ImportStatement.prototype.source = function(v){ return this._source; }
		ImportStatement.prototype.setSource = function(v){ this._source = v; return this; };
		
		
		ImportStatement.prototype.visit = function (){
			if (this._ns) {
				this._nsvar || (this._nsvar = this.scope__().register(this._ns,this));
			} else {
				var src = this.source().c();
				var m = src.match(/(\w+)(\.js|imba)?[\"\']$/);
				this._alias = m ? (m[1] + '$') : ('mod$');
			};
			
			// should also register the imported items, no?
			if (this._imports) {
				var dec = this._declarations = new VariableDeclaration([]);
				
				if (this._imports.length == 1) {
					this._alias = this._imports[0];
					dec.add(this._alias,OP('.',CALL(new Identifier("require"),[this.source()]),this._alias));
					dec.traverse();
					return this;
					
					// dec.add(@alias,CALL(Identifier.new("require"),[source]))
				};
				
				// p "ImportStatement has imports {@imports:length}"
				// @declarations = VariableDeclaration.new([])
				this._moduledecl = dec.add(this._alias,CALL(new Identifier("require"),[this.source()]));
				this._moduledecl.traverse();
				
				
				if (this._imports.length > 1) {
					for (var i = 0, ary = iter$(this._imports), len = ary.length, imp; i < len; i++) {
						imp = ary[i];
						this._declarations.add(imp,OP('.',this._moduledecl.variable(),imp));
					};
				};
				
				dec.traverse();
			};
			return this;
		};
		
		
		ImportStatement.prototype.js = function (o){
			
			var fname;
			if (this._declarations) {
				return this._declarations.c();
			};
			
			var req = CALL(new Identifier("require"),[this.source()]);
			
			if (this._ns) {
				// must register ns as a real variable
				return ("var " + (this._nsvar.c()) + " = " + (req.c()));
			};
			
			if (this._imports) {
				
				var src = this.source().c();
				var alias = [];
				var vars = new VarBlock([]);
				
				if (fname = src.match(/(\w+)(\.js|imba)?[\"\']$/)) {
					alias.push(fname[1]);
				};
				
				// var alias = src.match(/(\w+)(\.js|imba)?[\"\']$/)
				// p "source type {source}"
				// create a require for the source, with a temporary name?
				var out = [req.cache({names: alias}).c()];
				
				for (var i = 0, ary = iter$(this._imports), len = ary.length, imp; i < len; i++) {
					// we also need to register these imports as variables, no?
					imp = ary[i];
					var o = OP('=',imp,OP('.',req,imp));
					out.push(("var " + (o.c())));
				};
				
				return out;
			} else {
				return req.c();
			};
		};
		
		ImportStatement.prototype.consume = function (node){
			return this;
		};
		
		
		// EXPORT 
		
		function ExportStatement(){ return ValueNode.apply(this,arguments) };
		
		subclass$(ExportStatement,ValueNode);
		exports.ExportStatement = ExportStatement; // export class 
		ExportStatement.prototype.js = function (o){
			var nodes = this._value.map(function(arg) { return ("module.exports." + (arg.c()) + " = " + (arg.c())); });
			
			if (nodes.length > 1 && (this.up() instanceof Return)) {
				return '[' + nodes.join(',') + ']';
			} else {
				return nodes.join(';\n') + ';';
			};
		};
		
		
		// UTILS
		
		function Util(args){
			this._args = args;
		};
		
		// this is how we deal with it now
		subclass$(Util,Node);
		exports.Util = Util; // export class 
		Util.prototype.args = function(v){ return this._args; }
		Util.prototype.setArgs = function(v){ this._args = v; return this; };
		
		Util.extend = function (a,b){
			return new Util.Extend([a,b]);
		};
		
		Util.callImba = function (meth,args){
			return CALL(OP('.',new Const("Imba"),new Identifier(meth)),args);
		};
		
		Util.repeat = function (str,times){
			var res = '';
			while (times > 0){
				if (times % 2 == 1) {
					res += str;
				};
				str += str;
				times >>= 1;
			};
			return res;
		};
		
		
		
		Util.keys = function (obj){
			var l = new Const("Object");
			var r = new Identifier("keys");
			return CALL(OP('.',l,r),[obj]);
		};
		
		Util.len = function (obj,cache){
			// p "LEN HELPER".green
			var r = new Identifier("length");
			var node = OP('.',obj,r);
			if (cache) { node.cache({force: true,pool: 'len'}) };
			return node;
		};
		
		Util.indexOf = function (lft,rgt){
			var node = new Util.IndexOf([lft,rgt]);
			// node.cache(force: yes, type: 'iter') if cache
			return node;
		};
		
		Util.slice = function (obj,a,b){
			var slice = new Identifier("slice");
			console.log(("slice " + a + " " + b));
			return CALL(OP('.',obj,slice),compact__([a,b]));
		};
		
		Util.iterable = function (obj,cache){
			var node = new Util.Iterable([obj]);
			if (cache) { node.cache({force: true,pool: 'iter'}) };
			return node;
		};
		
		
		
		Util.union = function (a,b){
			return new Util.Union([a,b]);
			// CALL(UNION,[a,b])
		};
		
		Util.intersect = function (a,b){
			return new Util.Intersect([a,b]);
			// CALL(INTERSECT,[a,b])
		};
		
		Util.counter = function (start,cache){
			// should it not rather be a variable?!?
			var node = new Num(start); // make sure it really is a number
			if (cache) { node.cache({force: true,pool: 'counter'}) };
			return node;
		};
		
		Util.array = function (size,cache){
			var node = new Util.Array([size]);
			if (cache) { node.cache({force: true,pool: 'list'}) };
			return node;
		};
		
		Util.defineTag = function (type,ctor,supr){
			return CALL(TAGDEF,[type,ctor,supr]);
		};
		
		
		Util.defineClass = function (name,supr,initor){
			return CALL(CLASSDEF,[name || initor,this.sup()]);
		};
		
		Util.prototype.isStandalone = function (){
			return OPTS.standalone !== false;
		};
		
		Util.prototype.js = function (o){
			return "helper";
		};
		
		// TODO Deprecate and remove
		Util.Union = function Union(){ return Util.apply(this,arguments) };
		
		subclass$(Util.Union,Util);
		Util.Union.prototype.helper = function (){
			return 'function union$(a,b){\n	if(a && a.__union) return a.__union(b);\n\n	var u = a.slice(0);\n	for(var i=0,l=b.length;i<l;i++) if(u.indexOf(b[i]) == -1) u.push(b[i]);\n	return u;\n};\n';
		};
		
		Util.Union.prototype.js = function (o){
			this.scope__().root().helper(this,this.helper());
			// When this is triggered, we need to add it to the top of file?
			return ("union$(" + this.args().map(function(v) { return v.c(); }).join(',') + ")");
		};
		
		// TODO Deprecate and remove
		Util.Intersect = function Intersect(){ return Util.apply(this,arguments) };
		
		subclass$(Util.Intersect,Util);
		Util.Intersect.prototype.helper = function (){
			return 'function intersect$(a,b){\n	if(a && a.__intersect) return a.__intersect(b);\n	var res = [];\n	for(var i=0, l=a.length; i<l; i++) {\n		var v = a[i];\n		if(b.indexOf(v) != -1) res.push(v);\n	}\n	return res;\n};\n';
		};
		
		Util.Intersect.prototype.js = function (o){
			// When this is triggered, we need to add it to the top of file?
			this.scope__().root().helper(this,this.helper());
			return ("intersect$(" + this.args().map(function(v) { return v.c(); }).join(',') + ")");
		};
		
		Util.Extend = function Extend(){ return Util.apply(this,arguments) };
		
		subclass$(Util.Extend,Util);
		Util.Extend.prototype.js = function (o){
			// When this is triggered, we need to add it to the top of file?
			return ("extend$(" + compact__(cary__(this.args())).join(',') + ")");
		};
		
		Util.IndexOf = function IndexOf(){ return Util.apply(this,arguments) };
		
		subclass$(Util.IndexOf,Util);
		Util.IndexOf.prototype.helper = function (){
			return 'function idx$(a,b){\n	return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);\n};\n';
		};
		
		Util.IndexOf.prototype.js = function (o){
			if (this.isStandalone()) {
				this.scope__().root().helper(this,this.helper());
				// When this is triggered, we need to add it to the top of file?
				return ("idx$(" + this.args().map(function(v) { return v.c(); }).join(',') + ")");
			} else {
				return ("Imba.indexOf(" + this.args().map(function(v) { return v.c(); }).join(',') + ")");
			};
		};
		
		
		Util.Subclass = function Subclass(){ return Util.apply(this,arguments) };
		
		subclass$(Util.Subclass,Util);
		Util.Subclass.prototype.helper = function (){
			// should also check if it is a real promise
			return '// helper for subclassing\nfunction subclass$(obj,sup) {\n	for (var k in sup) {\n		if (sup.hasOwnProperty(k)) obj[k] = sup[k];\n	};\n	// obj.__super__ = sup;\n	obj.prototype = Object.create(sup.prototype);\n	obj.__super__ = obj.prototype.__super__ = sup.prototype;\n	obj.prototype.initialize = obj.prototype.constructor = obj;\n};\n';
		};
		
		Util.Subclass.prototype.js = function (o){
			if (this.isStandalone()) {
				// When this is triggered, we need to add it to the top of file?
				this.scope__().root().helper(this,this.helper());
				return ("subclass$(" + this.args().map(function(v) { return v.c(); }).join(',') + ");\n");
			} else {
				return ("Imba.subclass(" + this.args().map(function(v) { return v.c(); }).join(',') + ");\n");
			};
		};
		
		Util.Promisify = function Promisify(){ return Util.apply(this,arguments) };
		
		subclass$(Util.Promisify,Util);
		Util.Promisify.prototype.helper = function (){
			// should also check if it is a real promise
			return ("function promise$(a)\{ return a instanceof Array ? Promise.all(a) : (a && a.then ? a : Promise.resolve(a)); \}");
		};
		
		Util.Promisify.prototype.js = function (o){
			if (this.isStandalone()) {
				// When this is triggered, we need to add it to the top of file?
				this.scope__().root().helper(this,this.helper());
				return ("promise$(" + this.args().map(function(v) { return v.c(); }).join(',') + ")");
			} else {
				return ("Imba.await(" + this.args().map(function(v) { return v.c(); }).join(',') + ")");
			};
		};
		
		// TODO deprecated: can remove
		Util.Class = function Class(){ return Util.apply(this,arguments) };
		
		subclass$(Util.Class,Util);
		Util.Class.prototype.js = function (o){
			// When this is triggered, we need to add it to the top of file?
			return ("class$(" + this.args().map(function(v) { return v.c(); }).join(',') + ")");
		};
		
		Util.Iterable = function Iterable(){ return Util.apply(this,arguments) };
		
		subclass$(Util.Iterable,Util);
		Util.Iterable.prototype.helper = function (){
			// now we want to allow null values as well - just return as empty collection
			// should be the same for for own of I guess
			return ("function iter$(a)\{ return a ? (a.toArray ? a.toArray() : a) : []; \};");
		};
		
		Util.Iterable.prototype.js = function (o){
			if (this.args()[0] instanceof Arr) { return this.args()[0].c() }; // or if we know for sure that it is an array
			
			if (this.isStandalone()) {
				this.scope__().root().helper(this,this.helper());
				return ("iter$(" + (this.args()[0].c()) + ")");
			} else {
				return ("Imba.iterable(" + (this.args()[0].c()) + ")");
			};
		};
		
		Util.IsFunction = function IsFunction(){ return Util.apply(this,arguments) };
		
		subclass$(Util.IsFunction,Util);
		Util.IsFunction.prototype.js = function (o){
			return ("" + (this.args()[0].c()));
		};
		
		Util.Array = function Array(){ return Util.apply(this,arguments) };
		
		subclass$(Util.Array,Util);
		Util.Array.prototype.js = function (o){
			// When this is triggered, we need to add it to the top of file?
			return ("new Array(" + this.args().map(function(v) { return v.c(); }) + ")");
		};
		
		
		
		
		function Entities(root){
			this._root = root;
			this._map = {};
			return this;
		};
		
		Entities.prototype.add = function (path,object){
			this._map[path] = object;
			return this;
		};
		
		Entities.prototype.register = function (entity){
			var $1;
			var path = entity.namepath();
			this._map[($1 = path)] || (this._map[$1] = entity);
			return this;
		};
		
		Entities.prototype.plain = function (){
			return JSON.parse(JSON.stringify(this._map));
		};
		
		Entities.prototype.toJSON = function (){
			return this._map;
		};
		
		// SCOPES
		
		// handles local variables, self etc. Should create references to outer scopes
		// when needed etc.
		
		// add class for annotations / registering methods, etc?
		// class Interface
		
		// should move the whole context-thingie right into scope
		function Scope(node,parent){
			this._nr = STACK.incr('scopes');
			this._head = [];
			this._node = node;
			this._parent = parent;
			this._vars = new VariableDeclaration([]);
			this._meta = {};
			this._annotations = [];
			this._closure = this;
			this._virtual = false;
			this._counter = 0;
			this._varmap = {};
			this._varpool = [];
		};
		
		exports.Scope = Scope; // export class 
		Scope.prototype.level = function(v){ return this._level; }
		Scope.prototype.setLevel = function(v){ this._level = v; return this; };
		Scope.prototype.context = function(v){ return this._context; }
		Scope.prototype.setContext = function(v){ this._context = v; return this; };
		Scope.prototype.node = function(v){ return this._node; }
		Scope.prototype.setNode = function(v){ this._node = v; return this; };
		Scope.prototype.parent = function(v){ return this._parent; }
		Scope.prototype.setParent = function(v){ this._parent = v; return this; };
		Scope.prototype.varmap = function(v){ return this._varmap; }
		Scope.prototype.setVarmap = function(v){ this._varmap = v; return this; };
		Scope.prototype.varpool = function(v){ return this._varpool; }
		Scope.prototype.setVarpool = function(v){ this._varpool = v; return this; };
		Scope.prototype.params = function(v){ return this._params; }
		Scope.prototype.setParams = function(v){ this._params = v; return this; };
		Scope.prototype.head = function(v){ return this._head; }
		Scope.prototype.setHead = function(v){ this._head = v; return this; };
		Scope.prototype.vars = function(v){ return this._vars; }
		Scope.prototype.setVars = function(v){ this._vars = v; return this; };
		Scope.prototype.counter = function(v){ return this._counter; }
		Scope.prototype.setCounter = function(v){ this._counter = v; return this; };
		
		Scope.prototype.p = function (){
			if (STACK.loglevel() > 0) {
				console.log.apply(console,arguments);
			};
			return this;
		};
		
		Scope.prototype.stack = function (){
			return STACK;
		};
		
		Scope.prototype.meta = function (key,value){
			if (value != undefined) {
				this._meta[key] = value;
				return this;
			};
			return this._meta[key];
		};
		
		Scope.prototype.namepath = function (){
			return '?';
		};
		
		Scope.prototype.tagContextPath = function (){
			// bypassing for now
			return this._tagContextPath || (this._tagContextPath = "tag$"); // parent.tagContextPath
		};
		
		Scope.prototype.context = function (){
			return this._context || (this._context = new ScopeContext(this));
		};
		
		Scope.prototype.traverse = function (){
			return this;
		};
		
		Scope.prototype.visit = function (){
			if (this._parent) { return this };
			// p "visited scope!"
			this._parent = STACK.scope(1); // the parent scope
			this._level = STACK.scopes().length - 1;
			
			// p "parent is",@parent
			STACK.addScope(this);
			this.root().scopes().push(this);
			return this;
		};
		
		Scope.prototype.wrap = function (scope){
			this._parent = scope._parent;
			scope._parent = this;
			return this;
		};
		
		// called for scopes that are not real scopes in js
		// must ensure that the local variables inside of the scopes do not
		// collide with variables in outer scopes -- rename if needed
		Scope.prototype.virtualize = function (){
			return this;
		};
		
		Scope.prototype.root = function (){
			var scope = this;
			while (scope){
				if (scope instanceof RootScope) { return scope };
				scope = scope.parent();
			};
			return null;
		};
		
		Scope.prototype.register = function (name,decl,o){
			// FIXME re-registering a variable should really return the existing one
			// Again, here we should not really have to deal with system-generated vars
			// But again, it is important
			
			// p "registering {name}"
			if(decl === undefined) decl = null;
			if(o === undefined) o = {};
			name = helpers.symbolize(name);
			
			// also look at outer scopes if this is not closed?
			var existing = this._varmap.hasOwnProperty(name) && this._varmap[name];
			if (existing) { return existing };
			
			var item = new Variable(this,name,decl,o);
			// need to check for duplicates, and handle this gracefully -
			// going to refactor later
			if (!o.system) { this._varmap[name] = item }; // dont even add to the varmap if it is a sysvar
			return item;
		};
		
		Scope.prototype.annotate = function (obj){
			this._annotations.push(obj);
			return this;
		};
		
		// just like register, but we automatically 
		Scope.prototype.declare = function (name,init,o){
			var declarator_;
			if(init === undefined) init = null;
			if(o === undefined) o = {};
			var variable = this.register(name,null,o);
			// TODO create the variabledeclaration here instead?
			// if this is a sysvar we need it to be renameable
			var dec = this._vars.add(variable,init);
			(declarator_ = variable.declarator()) || ((variable.setDeclarator(dec),dec));
			return variable;
			
			// p "declare variable {name} {o}"
			// if name isa Variable
			// p "SCOPE declare var".green
			name = helpers.symbolize(name);
			// we will see here
			this._vars.add(name,init); // .last -- 
			var decl = this._vars.last(); // bug(!)
			var item;
			// item = Variable.new(self,name,decl)
			
			// if o:system
			// 	item = SystemVariable.new(self,name,decl,o)
			// 	decl.variable = item
			// else
			item = new Variable(this,name,decl,o);
			decl.setVariable(item);
			item.resolve(); // why on earth should it resolve immediately?
			
			// decl.variable = item
			// item.resolve # why on earth should it resolve immediately?
			return item;
			
			// should be possible to force-declare for this scope, no?
			// if this is a system-variable 
		};
		
		// declares a variable (has no real declaration beforehand)
		
		
		// what are the differences here? omj
		// we only need a temporary thing with defaults -- that is all
		// change these values, no?
		Scope.prototype.temporary = function (refnode,o,name){
			
			// p "registering temporary {refnode} {name}"
			// reuse variables -- hmm
			if(o === undefined) o = {};
			if(name === undefined) name = null;
			if (o.pool) {
				for (var i = 0, ary = iter$(this._varpool), len = ary.length, v; i < len; i++) {
					v = ary[i];
					if (v.pool() == o.pool && v.declarator() == null) {
						return v.reuse(refnode);
					};
				};
			};
			
			// should only 'register' as ahidden variable, no?
			// if there are real nodes inside that tries to refer to vars
			// defined in outer scopes, we need to make sure they are not named after this
			var item = new SystemVariable(this,name,refnode,o);
			this._varpool.push(item); // WHAT? It should not be in the pool unless explicitly put there?
			this._vars.push(item); // WARN variables should not go directly into a declaration-list
			return item;
			// return register(name || "__",null,system: yes, temporary: yes)
		};
		
		
		
		Scope.prototype.lookup = function (name){
			var ret = null;
			name = helpers.symbolize(name);
			if (this._varmap.hasOwnProperty(name)) {
				ret = this._varmap[name];
			} else {
				// look up any parent scope ?? seems okay
				// !isClosed && 
				ret = this.parent() && this.parent().lookup(name);
				// or -- not all scopes have a parent?
			};
			
			// should this not happen by itself?
			// if !ret and 
			//	ret = 
			// ret ||= (g.lookup(name) if var g = root)
			// g = root
			return ret;
		};
		
		Scope.prototype.autodeclare = function (variable){
			return this.vars().push(variable); // only if it does not exist here!!!
		};
		
		Scope.prototype.free = function (variable){
			// p "free variable"
			variable.free(); // :owner = null
			// @varpool.push(variable)
			return this;
		};
		
		Scope.prototype.isClosed = function (){
			return false;
		};
		
		Scope.prototype.closure = function (){
			return this._closure;
		};
		
		Scope.prototype.finalize = function (){
			return this;
		};
		
		Scope.prototype.klass = function (){
			var scope = this;
			while (scope){
				scope = scope.parent();
				if (scope instanceof ClassScope) { return scope };
			};
			return null;
		};
		
		Scope.prototype.head = function (){
			return [this._vars,this._params];
		};
		
		Scope.prototype.c = function (o){
			var body;
			if(o === undefined) o = {};
			o.expression = false;
			// need to fix this
			this.node().body().setHead(this.head());
			return body = this.node().body().c(o);
			
			// var head = [@vars,@params].block.c(expression: no)
			// p "head from scope is ({head})"
			// var out = [head or null,body].flatten__.compact.join("\n")
			// out
			// out = '{' + out + 
		};
		
		Scope.prototype.region = function (){
			return this.node().body().region();
		};
		
		Scope.prototype.loc = function (){
			return this.node().loc();
		};
		
		Scope.prototype.dump = function (){
			var self = this;
			var vars = Object.keys(this._varmap).map(function(k) {
				var v = self._varmap[k];
				return v.references().length ? (dump__(v)) : (null);
			});
			
			var desc = {
				nr: self._nr,
				type: self.constructor.name,
				level: (self.level() || 0),
				vars: compact__(vars),
				loc: self.loc()
			};
			
			return desc;
		};
		
		Scope.prototype.toJSON = function (){
			return this.dump();
		};
		
		Scope.prototype.toString = function (){
			return ("" + (this.constructor.name));
		};
		
		
		// RootScope is wrong? Rather TopScope or ProgramScope
		function RootScope(){
			RootScope.__super__.constructor.apply(this,arguments);
			
			this.register('global',this,{type: 'global'});
			this.register('module',this,{type: 'global'});
			this.register('window',this,{type: 'global'});
			this.register('document',this,{type: 'global'});
			this.register('exports',this,{type: 'global'});
			this.register('console',this,{type: 'global'});
			this.register('process',this,{type: 'global'});
			this.register('parseInt',this,{type: 'global'});
			this.register('parseFloat',this,{type: 'global'});
			this.register('setTimeout',this,{type: 'global'});
			this.register('setInterval',this,{type: 'global'});
			this.register('clearTimeout',this,{type: 'global'});
			this.register('clearInterval',this,{type: 'global'});
			this.register('__dirname',this,{type: 'global'});
			
			// preregister global special variables here
			this._warnings = [];
			this._scopes = [];
			this._helpers = [];
			this._entities = new Entities(this);
			this._head = [this._vars];
		};
		
		subclass$(RootScope,Scope);
		exports.RootScope = RootScope; // export class 
		RootScope.prototype.warnings = function(v){ return this._warnings; }
		RootScope.prototype.setWarnings = function(v){ this._warnings = v; return this; };
		RootScope.prototype.scopes = function(v){ return this._scopes; }
		RootScope.prototype.setScopes = function(v){ this._scopes = v; return this; };
		RootScope.prototype.entities = function(v){ return this._entities; }
		RootScope.prototype.setEntities = function(v){ this._entities = v; return this; };
		
		RootScope.prototype.context = function (){
			return this._context || (this._context = new RootScopeContext(this));
		};
		
		RootScope.prototype.tagContextPath = function (){
			return this._tagContextPath || (this._tagContextPath = "tag$");
		};
		
		RootScope.prototype.lookup = function (name){
			// p "lookup filescope"
			name = helpers.symbolize(name);
			if (this._varmap.hasOwnProperty(name)) { return this._varmap[name] };
		};
		
		RootScope.prototype.visit = function (){
			STACK.addScope(this);
			return this;
		};
		
		RootScope.prototype.helper = function (typ,value){
			// log "add helper",typ,value
			if (this._helpers.indexOf(value) == -1) {
				this._helpers.push(value);
				this._head.unshift(value);
			};
			
			return this;
		};
		
		RootScope.prototype.head = function (){
			return this._head;
		};
		
		RootScope.prototype.warn = function (data){
			// hacky
			data.node = null;
			// p "warning",JSON.stringify(data)
			this._warnings.push(data);
			return this;
		};
		
		RootScope.prototype.dump = function (){
			var obj = {warnings: dump__(this._warnings)};
			
			if (OPTS.analysis.scopes) {
				var scopes = this._scopes.map(function(s) { return s.dump(); });
				scopes.unshift(RootScope.__super__.dump.call(this));
				obj.scopes = scopes;
			};
			
			if (OPTS.analysis.entities) {
				obj.entities = this._entities;
			};
			
			return obj;
		};
		
		
		function ClassScope(){ return Scope.apply(this,arguments) };
		
		subclass$(ClassScope,Scope);
		exports.ClassScope = ClassScope; // export class 
		ClassScope.prototype.namepath = function (){
			return this._node.namepath();
		};
		
		
		// called for scopes that are not real scopes in js
		// must ensure that the local variables inside of the scopes do not
		// collide with variables in outer scopes -- rename if needed
		ClassScope.prototype.virtualize = function (){
			// console.log "virtualizing ClassScope"
			var up = this.parent();
			for (var o = this._varmap, i = 0, keys = Object.keys(o), l = keys.length; i < l; i++){
				true;
				o[keys[i]].resolve(up,true); // force new resolve
			};
			return this;
		};
		
		ClassScope.prototype.isClosed = function (){
			return true;
		};
		
		function TagScope(){ return ClassScope.apply(this,arguments) };
		
		subclass$(TagScope,ClassScope);
		exports.TagScope = TagScope; // export class 
		
		
		function ClosureScope(){ return Scope.apply(this,arguments) };
		
		subclass$(ClosureScope,Scope);
		exports.ClosureScope = ClosureScope; // export class 
		
		
		function FunctionScope(){ return Scope.apply(this,arguments) };
		
		subclass$(FunctionScope,Scope);
		exports.FunctionScope = FunctionScope; // export class 
		
		
		function MethodScope(){ return Scope.apply(this,arguments) };
		
		subclass$(MethodScope,Scope);
		exports.MethodScope = MethodScope; // export class 
		MethodScope.prototype.isClosed = function (){
			return true;
		};
		
		function LambdaScope(){ return Scope.apply(this,arguments) };
		
		subclass$(LambdaScope,Scope);
		exports.LambdaScope = LambdaScope; // export class 
		LambdaScope.prototype.context = function (){
			
			// when accessing the outer context we need to make sure that it is cached
			// so this is wrong - but temp okay
			return this._context || (this._context = this.parent().context().reference(this));
		};
		
		function FlowScope(){ return Scope.apply(this,arguments) };
		
		subclass$(FlowScope,Scope);
		exports.FlowScope = FlowScope; // export class 
		FlowScope.prototype.params = function (){
			if (this._parent) { return this._parent.params() };
		};
		
		FlowScope.prototype.register = function (name,decl,o){
			var found;
			if(decl === undefined) decl = null;
			if(o === undefined) o = {};
			if (o.type != 'let' && (this.closure() != this)) {
				if (found = this.lookup(name)) {
					// p "already found variable {found.type}"
					if (found.type() == 'let') {
						this.p(("" + name + " already exists as a block-variable " + decl));
						// TODO should throw error instead
						if (decl) { decl.warn("Variable already exists in block") };
						// root.warn message: "Holy shit"
					};
					// if found.
				};
				// p "FlowScope register var -- do it right in the outer scope"
				return this.closure().register(name,decl,o);
			} else {
				// p "Register local variable for FlowScope {name}"
				// o:closure = parent
				// p "FlowScope register", arguments
				return FlowScope.__super__.register.call(this,name,decl,o);
			};
		};
		
		// FIXME should override temporary as well
		
		FlowScope.prototype.autodeclare = function (variable){
			return this.parent().autodeclare(variable);
		};
		
		FlowScope.prototype.closure = function (){
			// rather all the way?
			return this._parent.closure(); // this is important?
		};
		
		FlowScope.prototype.context = function (){
			// if we are wrapping in an expression - we do need to add a reference
			// @referenced = yes
			return this.parent().context();
			// usually - if the parent scope is a closed scope we dont really need
			// to force a reference
			// @context ||= parent.context.reference(self)
		};
		
		function CatchScope(){ return FlowScope.apply(this,arguments) };
		
		subclass$(CatchScope,FlowScope);
		exports.CatchScope = CatchScope; // export class 
		
		
		function WhileScope(){ return FlowScope.apply(this,arguments) };
		
		subclass$(WhileScope,FlowScope);
		exports.WhileScope = WhileScope; // export class 
		WhileScope.prototype.autodeclare = function (variable){
			return this.vars().push(variable);
		};
		
		function ForScope(){ return FlowScope.apply(this,arguments) };
		
		subclass$(ForScope,FlowScope);
		exports.ForScope = ForScope; // export class 
		ForScope.prototype.autodeclare = function (variable){
			return this.vars().push(variable);
			// parent.autodeclare(variable)
		};
		
		// def closure
		// 	self
		;
		
		function IfScope(){ return FlowScope.apply(this,arguments) };
		
		subclass$(IfScope,FlowScope);
		exports.IfScope = IfScope; // export class 
		IfScope.prototype.temporary = function (refnode,o,name){
			if(o === undefined) o = {};
			if(name === undefined) name = null;
			return this.parent().temporary(refnode,o,name);
		};
		
		function BlockScope(){ return FlowScope.apply(this,arguments) };
		
		subclass$(BlockScope,FlowScope);
		exports.BlockScope = BlockScope; // export class 
		BlockScope.prototype.temporary = function (refnode,o,name){
			if(o === undefined) o = {};
			if(name === undefined) name = null;
			return this.parent().temporary(refnode,o,name);
		};
		
		BlockScope.prototype.region = function (){
			return this.node().region();
		};
		
		// lives in scope -- really a node???
		function Variable(scope,name,decl,o){
			this._ref = STACK._counter++;
			this._c = null;
			this._scope = scope;
			this._name = name;
			this._alias = null;
			this._initialized = true;
			this._declarator = decl;
			this._autodeclare = false;
			this._declared = o && o.declared || false;
			this._resolved = false;
			this._options = o || {};
			this._type = o && o.type || 'var'; // what about let here=
			this._export = false;
			this._references = []; // only needed when profiling
			this._assignments = [];
			this;
		};
		
		subclass$(Variable,Node);
		exports.Variable = Variable; // export class 
		Variable.prototype.scope = function(v){ return this._scope; }
		Variable.prototype.setScope = function(v){ this._scope = v; return this; };
		Variable.prototype.name = function(v){ return this._name; }
		Variable.prototype.setName = function(v){ this._name = v; return this; };
		Variable.prototype.alias = function(v){ return this._alias; }
		Variable.prototype.setAlias = function(v){ this._alias = v; return this; };
		Variable.prototype.type = function(v){ return this._type; }
		Variable.prototype.setType = function(v){ this._type = v; return this; };
		Variable.prototype.options = function(v){ return this._options; }
		Variable.prototype.setOptions = function(v){ this._options = v; return this; };
		Variable.prototype.initialized = function(v){ return this._initialized; }
		Variable.prototype.setInitialized = function(v){ this._initialized = v; return this; };
		Variable.prototype.declared = function(v){ return this._declared; }
		Variable.prototype.setDeclared = function(v){ this._declared = v; return this; };
		Variable.prototype.declarator = function(v){ return this._declarator; }
		Variable.prototype.setDeclarator = function(v){ this._declarator = v; return this; };
		Variable.prototype.autodeclare = function(v){ return this._autodeclare; }
		Variable.prototype.setAutodeclare = function(v){ this._autodeclare = v; return this; };
		Variable.prototype.references = function(v){ return this._references; }
		Variable.prototype.setReferences = function(v){ this._references = v; return this; };
		Variable.prototype.export = function(v){ return this._export; }
		Variable.prototype.setExport = function(v){ this._export = v; return this; };
		
		Variable.prototype.pool = function (){
			return null;
		};
		
		Variable.prototype.closure = function (){
			return this._scope.closure();
		};
		
		Variable.prototype.assignments = function (){
			return this._assignments;
		};
		
		// Here we can collect lots of type-info about variables
		// and show warnings / give advice if variables are ambiguous etc
		Variable.prototype.assigned = function (val,source){
			this._assignments.push(val);
			// p "Variable was assigned {val}"
			if (val instanceof Arr) {
				// just for testing really
				this._isArray = true;
			} else {
				this._isArray = false;
			};
			return this;
		};
		
		Variable.prototype.resolve = function (scope,force){
			if(scope === undefined) scope = this.scope();
			if(force === undefined) force = false;
			if (this._resolved && !force) { return this };
			
			this._resolved = true;
			var closure = this._scope.closure();
			var item = scope.lookup(this._name);
			
			// if this is a let-definition inside a virtual scope we do need
			// 
			if (this._scope != closure && this._type == 'let') { // or if it is a system-variable
				// p "scope is not the closure -- need to resolve {@name}"
				item = closure.lookup(this._name);
				
				// we now need to ensure that this variable is unique inside
				// the whole closure.
				scope = closure;
			};
			
			// p "scope is not the closure -- need to resolve {@name} {@type}"
			
			if (item == this) {
				scope.varmap()[this._name] = this;
				return this;
			} else if (item) {
				// p "variable already exists {@name}"
				
				// possibly redefine this inside, use it only in this scope
				// if the item is defined in an outer scope - we reserve the
				if (item.scope() != scope && (this.options().let || this._type == 'let')) {
					// p "override variable inside this scope {@name}"
					scope.varmap()[this._name] = this;
				};
				
				// different rules for different variables?
				if (this._options.proxy) {
					// p "is proxy -- no need to change name!!! {name}".cyan
					true;
				} else {
					var i = 0;
					var orig = this._name;
					// it is the closure that we should use
					while (scope.lookup(this._name)){
						this._name = ("" + orig + (i += 1));
					};
				};
			};
			
			// inefficient double setting
			scope.varmap()[this._name] = this;
			closure.varmap()[this._name] = this;
			return this;
			// p "resolve variable".cyan
		};
		
		Variable.prototype.reference = function (){
			return this;
		};
		
		Variable.prototype.node = function (){
			return this;
		};
		
		Variable.prototype.traverse = function (){
			// NODES.push(self)
			return this;
		};
		
		Variable.prototype.free = function (ref){
			// p "free variable!"
			this._declarator = null;
			return this;
		};
		
		Variable.prototype.reuse = function (ref){
			this._declarator = ref;
			return this;
		};
		
		Variable.prototype.proxy = function (par,index){
			this._proxy = [par,index];
			return this;
		};
		
		Variable.prototype.refcount = function (){
			return this._references.length;
		};
		
		Variable.prototype.c = function (){
			if (this._c) { return this._c };
			// options - proxy??
			if (this._proxy) {
				// p "var is proxied!",@proxy
				this._c = this._proxy[0].c() + '[' + this._proxy[1].c() + ']';
			} else {
				if (!this._resolved) this.resolve();
				var v = (this.alias() || this.name());
				this._c = typeof v == 'string' ? (v) : (v.c());
				// allow certain reserved words
				// should warn on others though (!!!)
				// if @c == 'new'
				// 	@c = '_new'
				// 	# should happen at earlier stage to
				// 	# get around naming conventions
				if (RESERVED_REGEX.test(this._c)) { this._c = ("" + this.c() + "$") }; // @c.match(/^(default)$/)
			};
			return this._c;
		};
		
		// variables should probably inherit from node(!)
		Variable.prototype.consume = function (node){
			// p "variable assignify!!!"
			return this;
		};
		
		// this should only generate the accessors - not dael with references
		Variable.prototype.accessor = function (ref){
			var node = new LocalVarAccess(".",null,this); // this is just wrong .. should not be a regular accessor
			// @references.push([ref,el]) if ref # weird temp format
			return node;
		};
		
		Variable.prototype.assignment = function (val){
			return new Assign('=',this,val);
		};
		
		Variable.prototype.addReference = function (ref){
			if (ref instanceof Identifier) {
				ref.references(this);
			};
			
			if (ref.region && ref.region()) {
				this._references.push(ref);
			};
			
			// p "reference is {ref:region and ref.region}"
			return this;
		};
		
		Variable.prototype.autodeclare = function (){
			if (this._declared) { return this };
			// p "variable should autodeclare(!) {name}"
			this._autodeclare = true;
			this.scope().autodeclare(this);
			this._declared = true;
			return this;
		};
		
		Variable.prototype.predeclared = function (){
			this._declared = true;
			return this;
		};
		
		
		Variable.prototype.toString = function (){
			return String(this.name());
		};
		
		Variable.prototype.dump = function (typ){
			var name = this.name();
			if (name[0].match(/[A-Z]/)) { return null };
			// console.log "dump variable of type {type} - {name}"
			return {
				type: this.type(),
				name: name,
				refs: dump__(this._references,typ)
			};
		};
		
		
		function SystemVariable(){ return Variable.apply(this,arguments) };
		
		subclass$(SystemVariable,Variable);
		exports.SystemVariable = SystemVariable; // export class 
		SystemVariable.prototype.pool = function (){
			return this._options.pool;
		};
		
		// weird name for this
		SystemVariable.prototype.predeclared = function (){
			// p "remove var from scope(!)"
			this.scope().vars().remove(this);
			return this;
		};
		
		SystemVariable.prototype.resolve = function (){
			var alias, v_;
			if (this._resolved || this._name) { return this };
			// p "RESOLVE SYSTEM VARIABLE".red
			this._resolved = true;
			// unless @name
			// adds a very random initial name
			// the auto-magical goes last, or at least, possibly reuse other names
			// "${Math.floor(Math.random * 1000)}"
			
			var typ = this._options.pool;
			var names = [].concat(this._options.names);
			var alt = null;
			var node = null;
			
			var scope = this.scope();
			
			if (typ == 'tag') {
				var i = 0;
				while (!this._name){
					alt = ("t" + (i++));
					if (!scope.lookup(alt)) { this._name = alt };
				};
			} else if (typ == 'iter') {
				names = ['ary__','ary_','coll','array','items','ary'];
			} else if (typ == 'val') {
				names = ['v_'];
			} else if (typ == 'arguments') {
				names = ['$_','$0'];
			} else if (typ == 'keypars') {
				names = ['opts','options','pars'];
			} else if (typ == 'counter') {
				names = ['i__','i_','k','j','i'];
			} else if (typ == 'len') {
				names = ['len__','len_','len'];
			} else if (typ == 'list') {
				names = ['tmplist_','tmplist','tmp'];
			};
			// or if type placeholder / cacher (add 0)
			
			while (!this._name && (alt = names.pop())){
				if (!scope.lookup(alt)) { this._name = alt };
			};
			
			if (!this._name && this._declarator) {
				if (node = this.declarator().node()) {
					if (alias = node.alias()) { names.push(alias + "_") };
				};
			};
			
			while (!this._name && (alt = names.pop())){
				if (!scope.lookup(alt)) { this._name = alt };
			};
			
			// p "suggested names {names.join(" , ")} {node}".cyan
			//  Math.floor(Math.random * 1000)
			this._name || (this._name = ("$" + (scope.setCounter(v_ = scope.counter() + 1),v_)));
			// p "name for variable is {@name}"
			scope.varmap()[this._name] = this;
			return this;
		};
		
		SystemVariable.prototype.name = function (){
			this.resolve();
			return this._name;
		};
		
		
		function ScopeContext(scope,value){
			this._scope = scope;
			this._value = value;
			this._reference = null;
			this;
		};
		
		subclass$(ScopeContext,Node);
		exports.ScopeContext = ScopeContext; // export class 
		ScopeContext.prototype.scope = function(v){ return this._scope; }
		ScopeContext.prototype.setScope = function(v){ this._scope = v; return this; };
		ScopeContext.prototype.value = function(v){ return this._value; }
		ScopeContext.prototype.setValue = function(v){ this._value = v; return this; };
		
		ScopeContext.prototype.namepath = function (){
			return this._scope.namepath();
		};
		
		// instead of all these references we should probably
		// just register when it is accessed / looked up from
		// a deeper function-scope, and when it is, we should
		// register the variable in scope, and then start to
		// use that for further references. Might clean things
		// up for the cases where we have yet to decide the
		// name of the variable etc?
		
		ScopeContext.prototype.reference = function (){
			// p "p reference {STACK.scoping}"
			// should be a special context-variable!!!
			return this._reference || (this._reference = this.scope().declare("self",new This()));
		};
		
		ScopeContext.prototype.c = function (){
			var val = this._value || this._reference;
			return val ? (val.c()) : ("this");
		};
		
		ScopeContext.prototype.cache = function (){
			return this;
		};
		
		function RootScopeContext(){ return ScopeContext.apply(this,arguments) };
		
		subclass$(RootScopeContext,ScopeContext);
		exports.RootScopeContext = RootScopeContext; // export class 
		RootScopeContext.prototype.c = function (o){
			// return "" if o and o:explicit
			var val = this._value || this._reference;
			return (val && val != this) ? (val.c()) : ("this");
			// should be the other way around, no?
			// o and o:explicit ? super : ""
		};
		
		function Super(){ return Node.apply(this,arguments) };
		
		subclass$(Super,Node);
		exports.Super = Super; // export class 
		Super.prototype.c = function (){
			// need to find the stuff here
			// this is really not that good8
			var m = STACK.method();
			var out = null;
			var up = STACK.current();
			var deep = (up instanceof Access);
			
			// TODO optimization for later - problematic if there is a different reference in the end
			if (false) {
				out = ("" + (m.target().c()) + ".superclass");
				if (!deep) { out += (".apply(" + (m.scope().context().c()) + ",arguments)") };
			} else {
				out = ("" + (m.target().c()) + ".__super__");
				if (!((up instanceof Access))) {
					out += ("." + c__(m.supername()));
					if (!((up instanceof Call))) { // autocall?
						out += (".apply(" + (m.scope().context().c()) + ",arguments)");
					};
				};
			};
			return out;
		};
		
		// constants
		
		module.exports.BR = BR = new Newline('\n');
		module.exports.BR2 = BR2 = new Newline('\n\n');
		module.exports.SELF = SELF = new Self();
		module.exports.SUPER = SUPER = new Super();
		
		module.exports.TRUE = TRUE = new True('true');
		module.exports.FALSE = FALSE = new False('false');
		module.exports.UNDEFINED = UNDEFINED = new Undefined();
		module.exports.NIL = NIL = new Nil();
		
		module.exports.ARGUMENTS = ARGUMENTS = new ArgsReference('arguments');
		module.exports.EMPTY = EMPTY = '';
		module.exports.NULL = NULL = 'null';
		
		module.exports.RESERVED = RESERVED = ['default','native','enum','with'];
		module.exports.RESERVED_REGEX = RESERVED_REGEX = /^(default|native|enum|with|new|char)$/;
		
		module.exports.UNION = UNION = new Const('union$');
		module.exports.INTERSECT = INTERSECT = new Const('intersect$');
		module.exports.CLASSDEF = CLASSDEF = new Const('imba$class');
		module.exports.TAGDEF = TAGDEF = new Const('Imba.TAGS.define');
		return module.exports.NEWTAG = NEWTAG = new Identifier("tag$");
		
		
		
		
		
		
		
		
		
		
	
	})()

/***/ },
/* 9 */
/***/ function(module, exports) {

	(function(){
		
		function brace(str){
			var lines = str.match(/\n/);
			// what about indentation?
			
			if (lines) {
				return '{' + str + '\n}';
			} else {
				return '{\n' + str + '\n}';
			};
		}; exports.brace = brace;
		
		function normalizeIndentation(str){
			var m;
			var reg = /\n+([^\n\S]*)/g;
			var ind = null;
			
			var length_;while (m = reg.exec(str)){
				var attempt = m[1];
				if (ind == null || 0 < (length_ = attempt.length) && length_ < ind.length) {
					ind = attempt;
				};
			};
			
			if (ind) { str = str.replace(RegExp(("\\n" + ind),"g"),'\n') };
			return str;
		}; exports.normalizeIndentation = normalizeIndentation;
		
		
		function flatten(arr){
			var out = [];
			arr.forEach(function(v) { return v instanceof Array ? (out.push.apply(out,flatten(v))) : (out.push(v)); });
			return out;
		}; exports.flatten = flatten;
		
		
		function pascalCase(str){
			return str.replace(/(^|[\-\_\s])(\w)/g,function(m,v,l) { return l.toUpperCase(); });
		}; exports.pascalCase = pascalCase;
		
		function camelCase(str){
			str = String(str);
			// should add shortcut out
			return str.replace(/([\-\_\s])(\w)/g,function(m,v,l) { return l.toUpperCase(); });
		}; exports.camelCase = camelCase;
		
		function snakeCase(str){
			var str = str.replace(/([\-\s])(\w)/g,'_');
			return str.replace(/()([A-Z])/g,"_$1",function(m,v,l) { return l.toUpperCase(); });
		}; exports.snakeCase = snakeCase;
		
		function setterSym(sym){
			return camelCase(("set-" + sym));
		}; exports.setterSym = setterSym;
		
		function quote(str){
			return '"' + str + '"';
		}; exports.quote = quote;
		
		function singlequote(str){
			return "'" + str + "'";
		}; exports.singlequote = singlequote;
		
		function symbolize(str){
			str = String(str);
			var end = str.charAt(str.length - 1);
			
			if (end == '=') {
				str = 'set' + str[0].toUpperCase() + str.slice(1,-1);
			};
			
			if (str.indexOf("-") >= 0) {
				str = str.replace(/([\-\s])(\w)/g,function(m,v,l) { return l.toUpperCase(); });
			};
			
			return str;
		}; exports.symbolize = symbolize;
		
		
		function indent(str){
			return String(str).replace(/^/g,"\t").replace(/\n/g,"\n\t").replace(/\n\t$/g,"\n");
		}; exports.indent = indent;
		
		function bracketize(str,ind){
			if(ind === undefined) ind = true;
			if (ind) { str = "\n" + indent(str) + "\n" };
			return '{' + str + '}';
		}; exports.bracketize = bracketize;
		
		function parenthesize(str){
			return '(' + String(str) + ')';
		}; exports.parenthesize = parenthesize;
		
		function locationToLineColMap(code){
			var lines = code.split(/\n/g);
			var map = [];
			
			var chr;
			var loc = 0;
			var col = 0;
			var line = 0;
			
			while (chr = code[loc]){
				map[loc] = [line,col];
				
				if (chr == '\n') {
					line++;
					col = 0;
				} else {
					col++;
				};
				
				loc++;
			};
			
			return map;
		}; exports.locationToLineColMap = locationToLineColMap;
		
		function markLineColForTokens(tokens,code){
			return this;
		}; exports.markLineColForTokens = markLineColForTokens;; return markLineColForTokens;
	
	})()

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		
		var path = __webpack_require__(11);
		var util = __webpack_require__(9);
		
		function SourceMap(source){
			this._source = source;
			this._maps = [];
			this._map = "";
			this._js = "";
		};
		
		exports.SourceMap = SourceMap; // export class 
		SourceMap.prototype.source = function (){
			return this._source;
		};
		
		SourceMap.prototype.options = function (){
			return this._source;
		};
		
		SourceMap.prototype.filename = function (){
			return this.options().options.filename;
		};
		
		SourceMap.prototype.sourceCode = function (){
			return this.options().options._source;
		};
		
		SourceMap.prototype.targetPath = function (){
			return this.options().options.targetPath;
		};
		
		SourceMap.prototype.sourcePath = function (){
			return this.options().options.sourcePath;
		};
		
		SourceMap.prototype.sourceName = function (){
			return path.basename(this.sourcePath());
		};
		
		SourceMap.prototype.targetName = function (){
			return path.basename(this.targetPath());
		};
		
		
		SourceMap.prototype.sourceFiles = function (){
			return [this.sourceName()];
		};
		
		SourceMap.prototype.parse = function (){
			var self = this;
			var matcher = /\%\$(\d*)\$\%/;
			var replacer = /^(.*?)\%\$(\d*)\$\%/;
			var lines = this.options().js.split(/\n/g); // what about js?
			// return self
			var locmap = util.locationToLineColMap(this.sourceCode());
			this._maps = [];
			
			// console.log options:js
			
			var match;
			// split the code in lines. go through each line 
			// go through the code looking for LOC markers
			// remove markers along the way and keep track of
			// console.log source:js
			
			for (var i = 0, ary = iter$(lines), len = ary.length, line; i < len; i++) {
				// could split on these?
				line = ary[i];
				var col = 0;
				var caret = 0;
				
				this._maps[i] = [];
				while (line.match(matcher)){
					line = line.replace(replacer,function(m,pre,loc) {
						var lc = locmap[parseInt(loc)];
						caret = pre.length;
						var mapping = [[lc[0],lc[1]],[i,caret]]; // source and output
						self._maps[i].push(mapping);
						return pre;
					});
				};
				lines[i] = line;
			};
			
			
			self.source().js = lines.join('\n');
			return self;
		};
		
		SourceMap.prototype.generate = function (){
			this.parse();
			
			var lastColumn = 0;
			var lastSourceLine = 0;
			var lastSourceColumn = 0;
			var buffer = "";
			
			for (var lineNumber = 0, ary = iter$(this._maps), len = ary.length; lineNumber < len; lineNumber++) {
				lastColumn = 0;
				
				for (var nr = 0, items = iter$(ary[lineNumber]), len_ = items.length, map1; nr < len_; nr++) {
					map1 = items[nr];
					if (nr != 0) { buffer += ',' };
					var src = map1[0];
					var dest = map1[1];
					
					buffer += this.encodeVlq(dest[1] - lastColumn);
					lastColumn = dest[1];
					// add index
					buffer += this.encodeVlq(0);
					
					// The starting line in the original source, relative to the previous source line.
					buffer += this.encodeVlq(src[0] - lastSourceLine);
					lastSourceLine = src[0];
					// The starting column in the original source, relative to the previous column.
					buffer += this.encodeVlq(src[1] - lastSourceColumn);
					lastSourceColumn = src[1];
				};
				
				buffer += ";";
			};
			
			
			var rel = path.relative(path.dirname(this.targetPath()),this.sourcePath());
			
			var map = {
				version: 3,
				file: this.sourceName().replace(/\.imba/,'.js') || '',
				sourceRoot: this.options().sourceRoot || '',
				sources: [rel],
				sourcesContent: [this.sourceCode()],
				names: [],
				mappings: buffer
			};
			
			// source:sourcemap = sourcemap
			// var base64 = Buffer.new(JSON.stringify(map)).toString("base64")
			// source:js += "\n//# sourceMappingURL=data:application/json;base64,{base64}"
			return map;
		};
		
		VLQ_SHIFT = 5;
		VLQ_CONTINUATION_BIT = 1 << VLQ_SHIFT;
		VLQ_VALUE_MASK = VLQ_CONTINUATION_BIT - 1;
		BASE64_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
		
		// borrowed from CoffeeScript
		SourceMap.prototype.encodeVlq = function (value){
			var answer = '';
			// Least significant bit represents the sign.
			var signBit = value < 0 ? (1) : (0);
			var nextChunk;
			// The next bits are the actual value.
			var valueToEncode = (Math.abs(value) << 1) + signBit;
			// Make sure we encode at least one character, even if valueToEncode is 0.
			while (valueToEncode || !answer){
				nextChunk = valueToEncode & VLQ_VALUE_MASK;
				valueToEncode = valueToEncode >> VLQ_SHIFT;
				if (valueToEncode) {
					nextChunk |= VLQ_CONTINUATION_BIT;
				};
				
				answer += this.encodeBase64(nextChunk);
			};
			
			return answer;
		};
		
		SourceMap.prototype.encodeBase64 = function (value){
			return BASE64_CHARS[value]; // or throw Error.new("Cannot Base64 encode value: {value}")
		};
		return SourceMap;
		
		
	
	})()

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// resolves . and .. elements in a path array with directory names there
	// must be no slashes, empty elements, or device names (c:\) in the array
	// (so also no leading and trailing slashes - it does not distinguish
	// relative and absolute paths)
	function normalizeArray(parts, allowAboveRoot) {
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = parts.length - 1; i >= 0; i--) {
	    var last = parts[i];
	    if (last === '.') {
	      parts.splice(i, 1);
	    } else if (last === '..') {
	      parts.splice(i, 1);
	      up++;
	    } else if (up) {
	      parts.splice(i, 1);
	      up--;
	    }
	  }
	
	  // if the path is allowed to go above the root, restore leading ..s
	  if (allowAboveRoot) {
	    for (; up--; up) {
	      parts.unshift('..');
	    }
	  }
	
	  return parts;
	}
	
	// Split a filename into [root, dir, basename, ext], unix version
	// 'root' is just a slash, or nothing.
	var splitPathRe =
	    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
	var splitPath = function(filename) {
	  return splitPathRe.exec(filename).slice(1);
	};
	
	// path.resolve([from ...], to)
	// posix version
	exports.resolve = function() {
	  var resolvedPath = '',
	      resolvedAbsolute = false;
	
	  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
	    var path = (i >= 0) ? arguments[i] : process.cwd();
	
	    // Skip empty and invalid entries
	    if (typeof path !== 'string') {
	      throw new TypeError('Arguments to path.resolve must be strings');
	    } else if (!path) {
	      continue;
	    }
	
	    resolvedPath = path + '/' + resolvedPath;
	    resolvedAbsolute = path.charAt(0) === '/';
	  }
	
	  // At this point the path should be resolved to a full absolute path, but
	  // handle relative paths to be safe (might happen when process.cwd() fails)
	
	  // Normalize the path
	  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
	    return !!p;
	  }), !resolvedAbsolute).join('/');
	
	  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
	};
	
	// path.normalize(path)
	// posix version
	exports.normalize = function(path) {
	  var isAbsolute = exports.isAbsolute(path),
	      trailingSlash = substr(path, -1) === '/';
	
	  // Normalize the path
	  path = normalizeArray(filter(path.split('/'), function(p) {
	    return !!p;
	  }), !isAbsolute).join('/');
	
	  if (!path && !isAbsolute) {
	    path = '.';
	  }
	  if (path && trailingSlash) {
	    path += '/';
	  }
	
	  return (isAbsolute ? '/' : '') + path;
	};
	
	// posix version
	exports.isAbsolute = function(path) {
	  return path.charAt(0) === '/';
	};
	
	// posix version
	exports.join = function() {
	  var paths = Array.prototype.slice.call(arguments, 0);
	  return exports.normalize(filter(paths, function(p, index) {
	    if (typeof p !== 'string') {
	      throw new TypeError('Arguments to path.join must be strings');
	    }
	    return p;
	  }).join('/'));
	};
	
	
	// path.relative(from, to)
	// posix version
	exports.relative = function(from, to) {
	  from = exports.resolve(from).substr(1);
	  to = exports.resolve(to).substr(1);
	
	  function trim(arr) {
	    var start = 0;
	    for (; start < arr.length; start++) {
	      if (arr[start] !== '') break;
	    }
	
	    var end = arr.length - 1;
	    for (; end >= 0; end--) {
	      if (arr[end] !== '') break;
	    }
	
	    if (start > end) return [];
	    return arr.slice(start, end - start + 1);
	  }
	
	  var fromParts = trim(from.split('/'));
	  var toParts = trim(to.split('/'));
	
	  var length = Math.min(fromParts.length, toParts.length);
	  var samePartsLength = length;
	  for (var i = 0; i < length; i++) {
	    if (fromParts[i] !== toParts[i]) {
	      samePartsLength = i;
	      break;
	    }
	  }
	
	  var outputParts = [];
	  for (var i = samePartsLength; i < fromParts.length; i++) {
	    outputParts.push('..');
	  }
	
	  outputParts = outputParts.concat(toParts.slice(samePartsLength));
	
	  return outputParts.join('/');
	};
	
	exports.sep = '/';
	exports.delimiter = ':';
	
	exports.dirname = function(path) {
	  var result = splitPath(path),
	      root = result[0],
	      dir = result[1];
	
	  if (!root && !dir) {
	    // No dirname whatsoever
	    return '.';
	  }
	
	  if (dir) {
	    // It has a dirname, strip trailing slash
	    dir = dir.substr(0, dir.length - 1);
	  }
	
	  return root + dir;
	};
	
	
	exports.basename = function(path, ext) {
	  var f = splitPath(path)[2];
	  // TODO: make this comparison case-insensitive on windows?
	  if (ext && f.substr(-1 * ext.length) === ext) {
	    f = f.substr(0, f.length - ext.length);
	  }
	  return f;
	};
	
	
	exports.extname = function(path) {
	  return splitPath(path)[3];
	};
	
	function filter (xs, f) {
	    if (xs.filter) return xs.filter(f);
	    var res = [];
	    for (var i = 0; i < xs.length; i++) {
	        if (f(xs[i], i, xs)) res.push(xs[i]);
	    }
	    return res;
	}
	
	// String.prototype.substr - negative index don't work in IE8
	var substr = 'ab'.substr(-1) === 'b'
	    ? function (str, start, len) { return str.substr(start, len) }
	    : function (str, start, len) {
	        if (start < 0) start = str.length + start;
	        return str.substr(start, len);
	    }
	;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNzcxOGRlYjRjYTk1NTBkMmMwNDIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBpbGVyL3dvcmtlci5pbWJhIiwid2VicGFjazovLy8uL3NyYy9jb21waWxlci9lcnJvcnMuaW1iYSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcGlsZXIvbGV4ZXIuaW1iYSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcGlsZXIvdG9rZW4uaW1iYSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcGlsZXIvcmV3cml0ZXIuaW1iYSIsIndlYnBhY2s6Ly8vLi9saWIvY29tcGlsZXIvcGFyc2VyLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9+L25vZGUtbGlicy1icm93c2VyL34vcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21waWxlci9ub2Rlcy5pbWJhIiwid2VicGFjazovLy8uL3NyYy9jb21waWxlci9oZWxwZXJzLmltYmEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBpbGVyL3NvdXJjZW1hcC5pbWJhIiwid2VicGFjazovLy8od2VicGFjaykvfi9ub2RlLWxpYnMtYnJvd3Nlci9+L3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUN0Q0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBaUI7O0FBRWpCOztBQUVBO0FBQ0E7QUFDQTtBQUNB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QUFJLEVBQUUsSUFBSTtBQUM3Qyx3Q0FBdUM7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXVCLEtBQUssS0FBSyxLQUFLO0FBQ3RDO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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O0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL2Rpc3QvaW1iYWMud29ya2VyLmRldi5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay9ib290c3RyYXAgNzcxOGRlYjRjYTk1NTBkMmMwNDJcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0Ly8gZXh0ZXJucztcblx0XG5cdHZhciBJbWJhUGFyc2VFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3JzJykuSW1iYVBhcnNlRXJyb3I7XG5cdFxuXHR2YXIgbGV4ZXIgPSByZXF1aXJlKCcuL2xleGVyJyk7XG5cdHZhciByZXdyaXRlciA9IHJlcXVpcmUoJy4vcmV3cml0ZXInKTtcblx0dmFyIHBhcnNlciA9IHJlcXVpcmUoJy4uLy4uL2xpYi9jb21waWxlci9wYXJzZXInKS5wYXJzZXI7XG5cdHZhciBhc3QgPSByZXF1aXJlKCcuL25vZGVzJyk7XG5cdFxuXHQvLyBJbnN0YW50aWF0ZSBhIExleGVyIGZvciBvdXIgdXNlIGhlcmUuXG5cdHZhciBsZXggPSBuZXcgKGxleGVyLkxleGVyKSgpO1xuXHR2YXIgUmV3cml0ZXIgPSByZXdyaXRlci5SZXdyaXRlcjtcblx0XG5cdHBhcnNlci5sZXhlciA9IGxleC5qaXNvbkJyaWRnZSgpO1xuXHRwYXJzZXIueXkgPSBhc3Q7IC8vIGV2ZXJ5dGhpbmcgaXMgZXhwb3J0ZWQgcmlnaHQgaGVyZSBub3dcblx0XG5cdHZhciBhcGkgPSB7fTtcblx0XG5cdGFwaS50b2tlbml6ZSA9IGZ1bmN0aW9uIChjb2RlLG8pe1xuXHRcdGlmKG8gPT09IHVuZGVmaW5lZCkgbyA9IHt9O1xuXHRcdHRyeSB7XG5cdFx0XHRvLl9zb3VyY2UgPSBjb2RlO1xuXHRcdFx0bGV4LnJlc2V0KCk7XG5cdFx0XHRyZXR1cm4gbGV4LnRva2VuaXplKGNvZGUsbyk7XG5cdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHQvLyBtYWtlcyBubyBzZW5zZT9cblx0XHRcdHRocm93IGVycjtcblx0XHR9O1xuXHR9O1xuXHRcblx0YXBpLnBhcnNlID0gZnVuY3Rpb24gKGNvZGUsbyl7XG5cdFx0Ly8gY29kZSB3aWxsIG5ldmVyIGJlIGFuIGFycmF5IGluIHdvcmtlcj9cblx0XHRpZihvID09PSB1bmRlZmluZWQpIG8gPSB7fTtcblx0XHR2YXIgdG9rZW5zID0gY29kZSBpbnN0YW5jZW9mIEFycmF5ID8gKGNvZGUpIDogKGFwaS50b2tlbml6ZShjb2RlLG8pKTtcblx0XHRcblx0XHR0cnkge1xuXHRcdFx0by5fc291cmNlID0gY29kZTtcblx0XHRcdG8uX3Rva2VucyA9IHRva2Vucztcblx0XHRcdHJldHVybiBwYXJzZXIucGFyc2UodG9rZW5zKTtcblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdGlmIChvLmZpbGVuYW1lKSB7IGVyci5fZmlsZW5hbWUgPSBvLmZpbGVuYW1lIH07XG5cdFx0XHR0aHJvdyBlcnI7XG5cdFx0fTtcblx0fTtcblx0XG5cdFxuXHRhcGkuY29tcGlsZSA9IGZ1bmN0aW9uIChjb2RlLG8pe1xuXHRcdGlmKG8gPT09IHVuZGVmaW5lZCkgbyA9IHt9O1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyAndHJ5IGNvbXBpbGUnXG5cdFx0XHR2YXIgYXN0ID0gYXBpLnBhcnNlKGNvZGUsbyk7XG5cdFx0XHR2YXIgcmVzID0gYXN0LmNvbXBpbGUobyk7XG5cdFx0XHRyZXR1cm4ge2NvZGU6IHJlcy50b1N0cmluZygpLHNvdXJjZW1hcDogcmVzLnNvdXJjZW1hcH07XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgJ2NvbXBpbGUgZXJyb3InLGU6bWVzc2FnZVxuXHRcdFx0Ly8gbm9ybWFsaXplIHNvbWV3aGVyZSBlbHNlXG5cdFx0XHRpZiAoISgoZSBpbnN0YW5jZW9mIEltYmFQYXJzZUVycm9yKSkpIHtcblx0XHRcdFx0aWYgKGUubGV4ZXIpIHtcblx0XHRcdFx0XHRlID0gbmV3IEltYmFQYXJzZUVycm9yKGUse3Rva2VuczogZS5sZXhlci50b2tlbnMscG9zOiBlLmxleGVyLnBvc30pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGUgPSB7bWVzc2FnZTogZS5tZXNzYWdlfTtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChlIGluc3RhbmNlb2YgSW1iYVBhcnNlRXJyb3IpIHsgZSA9IGUudG9KU09OKCkgfTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHtlcnJvcjogZX07XG5cdFx0fTtcblx0fTtcblx0XG5cdGFwaS5hbmFseXplID0gZnVuY3Rpb24gKGNvZGUsbyl7XG5cdFx0aWYobyA9PT0gdW5kZWZpbmVkKSBvID0ge307XG5cdFx0dmFyIG1ldGE7XG5cdFx0dHJ5IHtcblx0XHRcdHZhciBhc3QgPSB0aGlzLnBhcnNlKGNvZGUsbyk7XG5cdFx0XHRtZXRhID0gYXN0LmFuYWx5emUoe2xvZ2xldmVsOiAwfSk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgXCJzb21ldGhpbmcgd3Jvbmcge2U6bWVzc2FnZX1cIlxuXHRcdFx0aWYgKCEoKGUgaW5zdGFuY2VvZiBJbWJhUGFyc2VFcnJvcikpKSB7XG5cdFx0XHRcdGlmIChlLmxleGVyKSB7XG5cdFx0XHRcdFx0ZSA9IG5ldyBJbWJhUGFyc2VFcnJvcihlLHt0b2tlbnM6IGUubGV4ZXIudG9rZW5zLHBvczogZS5sZXhlci5wb3N9KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlID0ge21lc3NhZ2U6IGUubWVzc2FnZX07XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAoZSBpbnN0YW5jZW9mIEltYmFQYXJzZUVycm9yKSB7IGUgPSBlLnRvSlNPTigpIH07XG5cdFx0XHRcblx0XHRcdG1ldGEgPSB7d2FybmluZ3M6IFtlXX07XG5cdFx0fTtcblx0XHRyZXR1cm4gbWV0YTtcblx0fTtcblx0XG5cdFxuXHRyZXR1cm4gb25tZXNzYWdlID0gZnVuY3Rpb24gb25tZXNzYWdlKGUpe1xuXHRcdC8vIGNvbnNvbGUubG9nICdtZXNzYWdlIHRvIHdlYndvcmtlcidcblx0XHR2YXIgcGFyYW1zID0gZS5kYXRhO1xuXHRcdHZhciBpZCA9IHBhcmFtcy5pZDtcblx0XHRcblx0XHRpZiAoYXBpW3BhcmFtc1swXV0gaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuXHRcdFx0dmFyIGZuID0gYXBpW3BhcmFtc1swXV07XG5cdFx0XHR2YXIgcmVzdWx0ID0gZm4uYXBwbHkoYXBpLHBhcmFtcy5zbGljZSgxKSk7XG5cdFx0XHRyZXR1cm4gcG9zdE1lc3NhZ2Uoe2lkOiBpZCxkYXRhOiByZXN1bHR9KTtcblx0XHR9O1xuXHR9O1xuXHRcblx0XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2NvbXBpbGVyL3dvcmtlci5pbWJhXG4gKiogbW9kdWxlIGlkID0gMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdC8vIGhlbHBlciBmb3Igc3ViY2xhc3Npbmdcblx0ZnVuY3Rpb24gc3ViY2xhc3MkKG9iaixzdXApIHtcblx0XHRmb3IgKHZhciBrIGluIHN1cCkge1xuXHRcdFx0aWYgKHN1cC5oYXNPd25Qcm9wZXJ0eShrKSkgb2JqW2tdID0gc3VwW2tdO1xuXHRcdH07XG5cdFx0Ly8gb2JqLl9fc3VwZXJfXyA9IHN1cDtcblx0XHRvYmoucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXAucHJvdG90eXBlKTtcblx0XHRvYmouX19zdXBlcl9fID0gb2JqLnByb3RvdHlwZS5fX3N1cGVyX18gPSBzdXAucHJvdG90eXBlO1xuXHRcdG9iai5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IG9iai5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBvYmo7XG5cdH07XG5cdFxuXHQvLyBjcmVhdGUgc2VwYXJhdGUgZXJyb3ItdHlwZXMgd2l0aCBhbGwgdGhlIGxvZ2ljXG5cdFxuXHRmdW5jdGlvbiBJbWJhUGFyc2VFcnJvcihlLG8pe1xuXHRcdHRoaXMuZXJyb3IgPSBlO1xuXHRcdHRoaXMubWVzc2FnZSA9IGUubWVzc2FnZTtcblx0XHR0aGlzLmZpbGVuYW1lID0gZS5maWxlbmFtZTtcblx0XHR0aGlzLmxpbmUgPSBlLmxpbmU7XG5cdFx0dGhpcy5fb3B0aW9ucyA9IG8gfHwge307XG5cdFx0dGhpcztcblx0fTtcblx0XG5cdHN1YmNsYXNzJChJbWJhUGFyc2VFcnJvcixFcnJvcik7XG5cdGV4cG9ydHMuSW1iYVBhcnNlRXJyb3IgPSBJbWJhUGFyc2VFcnJvcjsgLy8gZXhwb3J0IGNsYXNzIFxuXHRJbWJhUGFyc2VFcnJvci53cmFwID0gZnVuY3Rpb24gKGVycil7XG5cdFx0Ly8gd2hhdCBhYm91dCB0aGUgc3RhY2t0cmFjZT9cblx0XHRyZXR1cm4gbmV3IEltYmFQYXJzZUVycm9yKGVycik7XG5cdH07XG5cdFxuXHRJbWJhUGFyc2VFcnJvci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG9wdHMpe1xuXHRcdHRoaXMuX29wdGlvbnMgfHwgKHRoaXMuX29wdGlvbnMgPSB7fSk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGtleXMgPSBPYmplY3Qua2V5cyhvcHRzKSwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKXtcblx0XHRcdHRoaXMuX29wdGlvbnNba2V5c1tpXV0gPSBvcHRzW2tleXNbaV1dO1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhUGFyc2VFcnJvci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgbyA9IHRoaXMuX29wdGlvbnM7XG5cdFx0dmFyIGlkeCA9IG8ucG9zIC0gMTtcblx0XHR2YXIgdG9rID0gby50b2tlbnMgJiYgby50b2tlbnNbaWR4XTtcblx0XHR3aGlsZSAodG9rICYmIHRvay5fbG9jID09IC0xKXtcblx0XHRcdHRvayA9IG8udG9rZW5zWy0taWR4XTtcblx0XHR9O1xuXHRcdHJldHVybiB0b2s7XG5cdH07XG5cdFxuXHRJbWJhUGFyc2VFcnJvci5wcm90b3R5cGUuZGVzYyA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBvID0gdGhpcy5fb3B0aW9ucztcblx0XHR2YXIgbXNnID0gdGhpcy5tZXNzYWdlO1xuXHRcdGlmIChvLnRva2VuICYmIG8udG9rZW4uX2xvYyA9PSAtMSkge1xuXHRcdFx0cmV0dXJuICdTeW50YXggRXJyb3InO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gbXNnO1xuXHRcdH07XG5cdH07XG5cdFxuXHRJbWJhUGFyc2VFcnJvci5wcm90b3R5cGUubG9jID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHN0YXJ0Xztcblx0XHRyZXR1cm4gKHN0YXJ0XyA9IHRoaXMuc3RhcnQoKSkgJiYgc3RhcnRfLnJlZ2lvbiAgJiYgIHN0YXJ0Xy5yZWdpb24oKTtcblx0fTtcblx0XG5cdEltYmFQYXJzZUVycm9yLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgbyA9IHRoaXMuX29wdGlvbnM7XG5cdFx0dmFyIHRvayA9IHRoaXMuc3RhcnQoKTtcblx0XHQvLyB2YXIgdG9rID0gbzp0b2tlbnMgYW5kIG86dG9rZW5zW286cG9zIC0gMV1cblx0XHQvLyB2YXIgbG9jID0gdG9rIGFuZCBbdG9rLkBsb2MsdG9rLkBsb2MgKyAodG9rLkBsZW4gb3IgdG9rLkB2YWx1ZTpsZW5ndGgpXSBvciBbMCwwXVxuXHRcdC8vICwgY29sOiB0b2suQGNvbCwgbGluZTogdG9rLkBsaW5lXG5cdFx0Ly8gZ2V0IHRoZSB0b2tlbiBpdHNlbGY/XG5cdFx0cmV0dXJuIHt3YXJuOiB0cnVlLG1lc3NhZ2U6IHRoaXMuZGVzYygpLGxvYzogdGhpcy5sb2MoKX07XG5cdH07XG5cdHJldHVybiBJbWJhUGFyc2VFcnJvcjtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvY29tcGlsZXIvZXJyb3JzLmltYmFcbiAqKiBtb2R1bGUgaWQgPSAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0ZnVuY3Rpb24gaWR4JChhLGIpe1xuXHRcdHJldHVybiAoYiAmJiBiLmluZGV4T2YpID8gYi5pbmRleE9mKGEpIDogW10uaW5kZXhPZi5jYWxsKGEsYik7XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBpdGVyJChhKXsgcmV0dXJuIGEgPyAoYS50b0FycmF5ID8gYS50b0FycmF5KCkgOiBhKSA6IFtdOyB9O1xuXHQvLyBoZWxwZXIgZm9yIHN1YmNsYXNzaW5nXG5cdGZ1bmN0aW9uIHN1YmNsYXNzJChvYmosc3VwKSB7XG5cdFx0Zm9yICh2YXIgayBpbiBzdXApIHtcblx0XHRcdGlmIChzdXAuaGFzT3duUHJvcGVydHkoaykpIG9ialtrXSA9IHN1cFtrXTtcblx0XHR9O1xuXHRcdC8vIG9iai5fX3N1cGVyX18gPSBzdXA7XG5cdFx0b2JqLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwLnByb3RvdHlwZSk7XG5cdFx0b2JqLl9fc3VwZXJfXyA9IG9iai5wcm90b3R5cGUuX19zdXBlcl9fID0gc3VwLnByb3RvdHlwZTtcblx0XHRvYmoucHJvdG90eXBlLmluaXRpYWxpemUgPSBvYmoucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gb2JqO1xuXHR9O1xuXHRcblx0dmFyIEFMTF9LRVlXT1JEUztcblx0XG5cdHZhciBUID0gcmVxdWlyZSgnLi90b2tlbicpO1xuXHR2YXIgVG9rZW4gPSBULlRva2VuO1xuXHRcblx0dmFyIHJ3ID0gcmVxdWlyZSgnLi9yZXdyaXRlcicpO1xuXHR2YXIgUmV3cml0ZXIgPSBydy5SZXdyaXRlcjtcblx0dmFyIElOVkVSU0VTID0gcncuSU5WRVJTRVM7XG5cdFxuXHR2YXIgSyA9IDA7XG5cdFxuXHR2YXIgRVJSID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcblx0XG5cdC8vIENvbnN0YW50c1xuXHQvLyAtLS0tLS0tLS1cblx0XG5cdC8vIEtleXdvcmRzIHRoYXQgSW1iYSBzaGFyZXMgaW4gY29tbW9uIHdpdGggSmF2YVNjcmlwdC5cblx0dmFyIEpTX0tFWVdPUkRTID0gW1xuXHRcdCd0cnVlJywnZmFsc2UnLCdudWxsJywndGhpcycsXG5cdFx0J2RlbGV0ZScsJ3R5cGVvZicsJ2luJywnaW5zdGFuY2VvZicsXG5cdFx0J3Rocm93JywnYnJlYWsnLCdjb250aW51ZScsJ2RlYnVnZ2VyJyxcblx0XHQnaWYnLCdlbHNlJywnc3dpdGNoJywnZm9yJywnd2hpbGUnLCdkbycsJ3RyeScsJ2NhdGNoJywnZmluYWxseScsXG5cdFx0J2NsYXNzJywnZXh0ZW5kcycsJ3N1cGVyJywncmV0dXJuJ1xuXHRdO1xuXHRcblx0Ly8gbmV3IGNhbiBiZSB1c2VkIGFzIGEga2V5d29yZCBpbiBpbWJhLCBzaW5jZSBvYmplY3QgaW5pdGluZyBpcyBkb25lIHRocm91Z2hcblx0Ly8gTXlPYmplY3QubmV3LiBuZXcgaXMgYSB2ZXJ5IHVzZWZ1bCB2YXJuYW1lLlxuXHRcblx0Ly8gV2Ugd2FudCB0byB0cmVhdCByZXR1cm4gbGlrZSBhbnkgcmVndWxhciBjYWxsIGZvciBub3dcblx0Ly8gTXVzdCBiZSBjYXJlZnVsIHRvIHRocm93IHRoZSBleGNlcHRpb25zIGluIEFTVCwgc2luY2UgdGhlIHBhcnNlclxuXHQvLyB3b250XG5cdFxuXHQvLyBJbWJhLW9ubHkga2V5d29yZHMuIHZhciBzaG91bGQgbW92ZSB0byBKU19LZXl3b3Jkc1xuXHQvLyBzb21lIHdvcmRzIChsaWtlIHRva2lkKSBzaG91bGQgYmUgY29udGV4dC1zcGVjaWZpY1xuXHR2YXIgSU1CQV9LRVlXT1JEUyA9IFtcblx0XHQndW5kZWZpbmVkJywndGhlbicsJ3VubGVzcycsJ3VudGlsJywnbG9vcCcsJ29mJywnYnknLFxuXHRcdCd3aGVuJywnZGVmJywndGFnJywnZG8nLCdlbGlmJywnYmVnaW4nLCd2YXInLCdsZXQnLCdzZWxmJywnYXdhaXQnLCdpbXBvcnQnXG5cdF07XG5cdFxuXHR2YXIgSU1CQV9DT05URVhUVUFMX0tFWVdPUkRTID0gWydleHRlbmQnLCdzdGF0aWMnLCdsb2NhbCcsJ2V4cG9ydCcsJ2dsb2JhbCcsJ3Byb3AnXTtcblx0XG5cdHZhciBJTUJBX0FMSUFTX01BUCA9IHtcblx0XHQnYW5kJzogJyYmJyxcblx0XHQnb3InOiAnfHwnLFxuXHRcdCdpcyc6ICc9PScsXG5cdFx0J2lzbnQnOiAnIT0nLFxuXHRcdCdub3QnOiAnIScsXG5cdFx0J3llcyc6ICd0cnVlJyxcblx0XHQnbm8nOiAnZmFsc2UnLFxuXHRcdCdpc2EnOiAnaW5zdGFuY2VvZicsXG5cdFx0J2Nhc2UnOiAnc3dpdGNoJyxcblx0XHQnbmlsJzogJ251bGwnXG5cdH07XG5cdFxuXHR2YXIgSU1CQV9BTElBU0VTID0gT2JqZWN0LmtleXMoSU1CQV9BTElBU19NQVApO1xuXHRJTUJBX0tFWVdPUkRTID0gSU1CQV9LRVlXT1JEUy5jb25jYXQoSU1CQV9BTElBU0VTKTtcblx0XG5cdC8vIEZpeGVkQXJyYXkgZm9yIHBlcmZvcm1hbmNlXG5cdC8vIHZhciBBTExfS0VZV09SRFMgPSBKU19LRVlXT1JEUy5jb25jYXQoSU1CQV9LRVlXT1JEUylcblx0bW9kdWxlLmV4cG9ydHMuQUxMX0tFWVdPUkRTID0gQUxMX0tFWVdPUkRTID0gW1xuXHRcdCd0cnVlJywnZmFsc2UnLCdudWxsJywndGhpcycsXG5cdFx0J2RlbGV0ZScsJ3R5cGVvZicsJ2luJywnaW5zdGFuY2VvZicsXG5cdFx0J3Rocm93JywnYnJlYWsnLCdjb250aW51ZScsJ2RlYnVnZ2VyJyxcblx0XHQnaWYnLCdlbHNlJywnc3dpdGNoJywnZm9yJywnd2hpbGUnLCdkbycsJ3RyeScsJ2NhdGNoJywnZmluYWxseScsXG5cdFx0J2NsYXNzJywnZXh0ZW5kcycsJ3N1cGVyJywncmV0dXJuJyxcblx0XHQndW5kZWZpbmVkJywndGhlbicsJ3VubGVzcycsJ3VudGlsJywnbG9vcCcsJ29mJywnYnknLFxuXHRcdCd3aGVuJywnZGVmJywndGFnJywnZG8nLCdlbGlmJywnYmVnaW4nLCd2YXInLCdsZXQnLCdzZWxmJywnYXdhaXQnLCdpbXBvcnQnLFxuXHRcdCdhbmQnLCdvcicsJ2lzJywnaXNudCcsJ25vdCcsJ3llcycsJ25vJywnaXNhJywnY2FzZScsJ25pbCdcblx0XTtcblx0XG5cdC8vIFRoZSBsaXN0IG9mIGtleXdvcmRzIHRoYXQgYXJlIHJlc2VydmVkIGJ5IEphdmFTY3JpcHQsIGJ1dCBub3QgdXNlZCwgb3IgYXJlXG5cdC8vIHVzZWQgYnkgSW1iYSBpbnRlcm5hbGx5LiBXZSB0aHJvdyBhbiBlcnJvciB3aGVuIHRoZXNlIGFyZSBlbmNvdW50ZXJlZCxcblx0Ly8gdG8gYXZvaWQgaGF2aW5nIGEgSmF2YVNjcmlwdCBlcnJvciBhdCBydW50aW1lLiAgIyAndmFyJywgJ2xldCcsIC0gbm90IGluc2lkZSBoZXJlXG5cdHZhciBSRVNFUlZFRCA9IFsnY2FzZScsJ2RlZmF1bHQnLCdmdW5jdGlvbicsJ3ZvaWQnLCd3aXRoJywnY29uc3QnLCdlbnVtJywnbmF0aXZlJ107XG5cdHZhciBTVFJJQ1RfUkVTRVJWRUQgPSBbJ2Nhc2UnLCdmdW5jdGlvbicsJ3ZvaWQnLCdjb25zdCddO1xuXHRcblx0Ly8gVGhlIHN1cGVyc2V0IG9mIGJvdGggSmF2YVNjcmlwdCBrZXl3b3JkcyBhbmQgcmVzZXJ2ZWQgd29yZHMsIG5vbmUgb2Ygd2hpY2ggbWF5XG5cdC8vIGJlIHVzZWQgYXMgaWRlbnRpZmllcnMgb3IgcHJvcGVydGllcy5cblx0dmFyIEpTX0ZPUkJJRERFTiA9IEpTX0tFWVdPUkRTLmNvbmNhdChSRVNFUlZFRCk7XG5cdFxuXHR2YXIgTUVUSE9EX0lERU5USUZJRVIgPSAvXigoKFtcXHgyM10/W1xcJEEtWmEtel9cXHg3Zi1cXHVmZmZmXVskXFwtXFx3XFx4N2YtXFx1ZmZmZl0qKShbXFw9XT8pKXwoPD0+fFxcfCg/IVtcXHw9XSkpKS87XG5cdC8vIHJlbW92ZWQgfj18fnwgfCYoPyFbJj1dKVxuXHRcblx0Ly8gVG9rZW4gbWF0Y2hpbmcgcmVnZXhlcy5cblx0Ly8gYWRkZWQgaHlwaGVucyB0byBpZGVudGlmaWVycyBub3cgLSB0byB0ZXN0XG5cdHZhciBJREVOVElGSUVSID0gL14oKFxcJHxAQHxAfFxcIylbXFx3QS1aYS16X1xcLVxceDdmLVxcdWZmZmZdWyRcXHdcXHg3Zi1cXHVmZmZmXSooXFwtWyRcXHdcXHg3Zi1cXHVmZmZmXSspKnxbJEEtWmEtel9dWyRcXHdcXHg3Zi1cXHVmZmZmXSooXFwtWyRcXHdcXHg3Zi1cXHVmZmZmXSspKikoW15cXG5cXFNdKjooPyFbXFwqXFw9OiRcXHdcXHg3Zi1cXHVmZmZmXSkpPy87XG5cdFxuXHR2YXIgT0JKRUNUX0tFWSA9IC9eKChcXCR8QEB8QHwpWyRBLVphLXpfXFx4N2YtXFx1ZmZmZlxcLV1bJFxcd1xceDdmLVxcdWZmZmZcXC1dKikoW15cXG5cXFNcXHNdKjooPyFbXFwqXFw9OiRcXHdcXHg3Zi1cXHVmZmZmXSkpLztcblx0XG5cdHZhciBUQUcgPSAvXihcXDx8JSkoPz1bQS1aYS16XFwjXFwuXFx7XFxAXFw+XSkvO1xuXHRcblx0dmFyIFRBR19UWVBFID0gL14oXFx3W1xcd1xcZF0qOik/KFxcd1tcXHdcXGRdKikoLVtcXHdcXGRdKykqLztcblx0dmFyIFRBR19JRCA9IC9eIygoXFx3W1xcd1xcZF0qKSgtW1xcd1xcZF0rKSopLztcblx0XG5cdHZhciBUQUdfQVRUUiA9IC9eKFtcXC5cXDpdP1tcXHdcXF9dKyhbXFwtXFw6XVtcXHddKykqKShcXHMpKlxcPS87XG5cdFxuXHR2YXIgU0VMRUNUT1IgPSAvXihbJVxcJF17MSwyfSkoW1xcKFxcd1xcI1xcLlxcW10pLztcblx0dmFyIFNFTEVDVE9SX1BBUlQgPSAvXihcXCN8XFwufDp8OjopPyhbXFx3XSsoXFwtW1xcd10rKSopLztcblx0dmFyIFNFTEVDVE9SX0NPTUJJTkFUT1IgPSAvXiAoXFwrfFxcPnxcXH4pKlxccyooPz1bXFx3XFwuXFwjXFw6XFx7XFwqXFxbXSkvO1xuXHRcblx0dmFyIFNFTEVDVE9SX1BTRVVET19DTEFTUyA9IC9eKDo6PykoW1xcd10rKFxcLVtcXHddKykqKS87XG5cdHZhciBTRUxFQ1RPUl9BVFRSX09QID0gL14oXFwkPXxcXH49fFxcXj18XFwqPXxcXHw9fD18XFwhPSkvO1xuXHR2YXIgU0VMRUNUT1JfQVRUUiA9IC9eXFxbKFtcXHdcXF9cXC1dKykoXFwkPXxcXH49fFxcXj18XFwqPXxcXHw9fD18XFwhPSkvO1xuXHRcblx0dmFyIFNZTUJPTCA9IC9eXFw6KCgoW1xcKlxcQCRcXHdcXHg3Zi1cXHVmZmZmXSspKyhbXFwtXFxcXC9cXFxcXFw6XVtcXHdcXHg3Zi1cXHVmZmZmXSspKil8PT18XFw8PVxcPnxcXFtcXF18XFxbXFxdXFw9fFxcKnxbXFxcXC8sXFxcXF0pLztcblx0XG5cdFxuXHR2YXIgTlVNQkVSID0gL14weFtcXGRhLWZdK3xeMGJbMDFdK3xeXFxkKlxcLj9cXGQrKD86ZVsrLV0/XFxkKyk/L2k7XG5cdFxuXHR2YXIgSEVSRURPQyA9IC9eKFwiXCJcInwnJycpKFtcXHNcXFNdKj8pKD86XFxuW15cXG5cXFNdKik/XFwxLztcblx0XG5cdHZhciBPUEVSQVRPUiA9IC9eKD86Wy09XT0+fD09PXwtPnwhPT18Wy0rKlxcLyU8PiZ8XiE/PV09fD08fD4+Pj0/fChbLSs6XSlcXDF8KFsmfDw+XSlcXDI9P3xcXD9cXC58XFw/XFw6fFxcLnsyLDN9fFxcKig/PVthLXpBLVpcXF9dKSkvO1xuXHRcblx0Ly8gRklYTUUgc3BsYXQgc2hvdWxkIG9ubHkgYmUgYWxsb3dlZCB3aGVuIHRoZSBwcmV2aW91cyB0aGluZyBpcyBzcGFjZWQgb3IgaW5zaWRlIGNhbGw/XG5cdFxuXHR2YXIgV0hJVEVTUEFDRSA9IC9eW15cXG5cXFNdKy87XG5cdFxuXHR2YXIgQ09NTUVOVCA9IC9eIyMjKFteI11bXFxzXFxTXSo/KSg/OiMjI1teXFxuXFxTXSp8KD86IyMjKT8kKS87XG5cdC8vIENPTU1FTlQgICAgPSAvXiMjIyhbXiNdW1xcc1xcU10qPykoPzojIyNbXlxcblxcU10qfCg/OiMjIyk/JCl8Xig/OlxccyooI1xccy4qfCNcXHMqJCkpKy9cblx0dmFyIElOTElORV9DT01NRU5UID0gL14oXFxzKikoI1sgXFx0XFwhXSguKil8I1sgXFx0XT8oPz1cXG58JCkpKy87XG5cdFxuXHR2YXIgQ09ERSA9IC9eWy09XT0+Lztcblx0XG5cdHZhciBNVUxUSV9ERU5UID0gL14oPzpcXG5bXlxcblxcU10qKSsvO1xuXHRcblx0dmFyIFNJTVBMRVNUUiA9IC9eJ1teXFxcXCddKig/OlxcXFwuW15cXFxcJ10qKSonLztcblx0XG5cdHZhciBKU1RPS0VOID0gL15gW15cXFxcYF0qKD86XFxcXC5bXlxcXFxgXSopKmAvO1xuXHRcblx0Ly8gUmVnZXgtbWF0Y2hpbmctcmVnZXhlcy5cblx0dmFyIFJFR0VYID0gL14oXFwvKD8hW1xccz1dKVteW1xcL1xcblxcXFxdKig/Oig/OlxcXFxbXFxzXFxTXXxcXFtbXlxcXVxcblxcXFxdKig/OlxcXFxbXFxzXFxTXVteXFxdXFxuXFxcXF0qKSpdKVteW1xcL1xcblxcXFxdKikqXFwvKShbaW1neV17MCw0fSkoPyFcXHcpLztcblx0XG5cdHZhciBIRVJFR0VYID0gL15cXC97M30oW1xcc1xcU10rPylcXC97M30oW2ltZ3ldezAsNH0pKD8hXFx3KS87XG5cdFxuXHR2YXIgSEVSRUdFWF9PTUlUID0gL1xccysoPzojLiopPy9nO1xuXHRcblx0Ly8gVG9rZW4gY2xlYW5pbmcgcmVnZXhlcy5cblx0dmFyIE1VTFRJTElORVIgPSAvXFxuL2c7XG5cdFxuXHR2YXIgSEVSRURPQ19JTkRFTlQgPSAvXFxuKyhbXlxcblxcU10qKS9nO1xuXHRcblx0dmFyIEhFUkVET0NfSUxMRUdBTCA9IC9cXCpcXC8vO1xuXHRcblx0Ly8gZXhwZW5zaXZlP1xuXHR2YXIgTElORV9DT05USU5VRVIgPSAvXlxccyooPzosfFxcPz9cXC4oPyFbLlxcZF0pfDo6KS87XG5cdFxuXHR2YXIgVFJBSUxJTkdfU1BBQ0VTID0gL1xccyskLztcblx0XG5cdHZhciBDT05TVF9JREVOVElGSUVSID0gL15bQS1aXS87XG5cdFxuXHR2YXIgQVJHVkFSID0gL15cXCRcXGQkLztcblx0XG5cdC8vIENvbXBvdW5kIGFzc2lnbm1lbnQgdG9rZW5zLlxuXHR2YXIgQ09NUE9VTkRfQVNTSUdOID0gWyctPScsJys9JywnLz0nLCcqPScsJyU9JywnfHw9JywnJiY9JywnPz0nLCc8PD0nLCc+Pj0nLCc+Pj49JywnJj0nLCdePScsJ3w9JywnPTwnXTtcblx0XG5cdC8vIFVuYXJ5IHRva2Vucy5cblx0dmFyIFVOQVJZID0gWychJywnficsJ05FVycsJ1RZUEVPRicsJ0RFTEVURSddO1xuXHRcblx0Ly8gTG9naWNhbCB0b2tlbnMuXG5cdHZhciBMT0dJQyA9IFsnJiYnLCd8fCcsJyYnLCd8JywnXiddO1xuXHRcblx0Ly8gQml0LXNoaWZ0aW5nIHRva2Vucy5cblx0dmFyIFNISUZUID0gWyc8PCcsJz4+JywnPj4+J107XG5cdFxuXHQvLyBDb21wYXJpc29uIHRva2Vucy5cblx0dmFyIENPTVBBUkUgPSBbJz09PScsJyE9PScsJz09JywnIT0nLCc8JywnPicsJzw9JywnPj0nLCc9PT0nLCchPT0nXTtcblx0XG5cdC8vIE92ZXJpZGVhYmxlIG1ldGhvZHNcblx0dmFyIE9QX01FVEhPRFMgPSBbJzw9PicsJzw8JywnLi4nXTtcblx0XG5cdC8vIE1hdGhlbWF0aWNhbCB0b2tlbnMuXG5cdHZhciBNQVRIID0gWycqJywnLycsJyUnLCfiiKonLCfiiKknLCfiiJonXTtcblx0XG5cdC8vIFJlbGF0aW9uYWwgdG9rZW5zIHRoYXQgYXJlIG5lZ2F0YWJsZSB3aXRoIGBub3RgIHByZWZpeC5cblx0dmFyIFJFTEFUSU9OID0gWydJTicsJ09GJywnSU5TVEFOQ0VPRicsJ0lTQSddO1xuXHRcblx0Ly8gQm9vbGVhbiB0b2tlbnMuXG5cdHZhciBCT09MID0gWydUUlVFJywnRkFMU0UnLCdOVUxMJywnVU5ERUZJTkVEJ107XG5cdFxuXHQvLyBPdXIgbGlzdCBpcyBzaG9ydGVyLCBkdWUgdG8gc2Fucy1wYXJlbnRoZXNlcyBtZXRob2QgY2FsbHMuXG5cdHZhciBOT1RfUkVHRVggPSBbJ05VTUJFUicsJ1JFR0VYJywnQk9PTCcsJ1RSVUUnLCdGQUxTRScsJysrJywnLS0nLCddJ107XG5cdFxuXHQvLyBJZiB0aGUgcHJldmlvdXMgdG9rZW4gaXMgbm90IHNwYWNlZCwgdGhlcmUgYXJlIG1vcmUgcHJlY2VkaW5nIHRva2VucyB0aGF0XG5cdC8vIGZvcmNlIGEgZGl2aXNpb24gcGFyc2U6XG5cdHZhciBOT1RfU1BBQ0VEX1JFR0VYID0gWydOVU1CRVInLCdSRUdFWCcsJ0JPT0wnLCdUUlVFJywnRkFMU0UnLCcrKycsJy0tJywnXScsJyknLCd9JywnVEhJUycsJ1NFTEYnLCdJREVOVElGSUVSJywnU1RSSU5HJ107XG5cdFxuXHQvLyBUb2tlbnMgd2hpY2ggY291bGQgbGVnaXRpbWF0ZWx5IGJlIGludm9rZWQgb3IgaW5kZXhlZC4gQW4gb3BlbmluZ1xuXHQvLyBwYXJlbnRoZXNlcyBvciBicmFja2V0IGZvbGxvd2luZyB0aGVzZSB0b2tlbnMgd2lsbCBiZSByZWNvcmRlZCBhcyB0aGUgc3RhcnRcblx0Ly8gb2YgYSBmdW5jdGlvbiBpbnZvY2F0aW9uIG9yIGluZGV4aW5nIG9wZXJhdGlvbi5cblx0Ly8gcmVhbGx5PyFcblx0XG5cdHZhciBVTkZJTklTSEVEID0gWydcXFxcJywnLicsJz8uJywnPzonLCdVTkFSWScsJ01BVEgnLCcrJywnLScsJ1NISUZUJywnUkVMQVRJT04nLCdDT01QQVJFJywnTE9HSUMnLCdDT01QT1VORF9BU1NJR04nLCdUSFJPVycsJ0VYVEVORFMnXTtcblx0XG5cdC8vIH0gc2hvdWxkIG5vdCBiZSBjYWxsYWJsZSBhbnltb3JlISEhICd9JywgJzo6Jyxcblx0dmFyIENBTExBQkxFID0gWydJREVOVElGSUVSJywnU1RSSU5HJywnUkVHRVgnLCcpJywnXScsJ1RISVMnLCdTVVBFUicsJ1RBR19FTkQnLCdJVkFSJywnR1ZBUicsJ1NFTEYnLCdDT05TVCcsJ05FVycsJ0FSR1ZBUicsJ1NZTUJPTCcsJ1JFVFVSTiddO1xuXHQvLyB2YXIgSU5ERVhBQkxFID0gQ0FMTEFCTEUuY29uY2F0ICdOVU1CRVInLCAnQk9PTCcsICdUQUdfU0VMRUNUT1InLCAnSURSRUYnLCAnQVJHVU1FTlRTJywnfScgIyBhcmUgYm9vbGVhbnMgaW5kZXhhYmxlPyByZWFsbHk/XG5cdC8vIG9wdGltaXplIGZvciBGaXhlZEFycmF5XG5cdHZhciBJTkRFWEFCTEUgPSBbXG5cdFx0J0lERU5USUZJRVInLCdTVFJJTkcnLCdSRUdFWCcsJyknLCddJywnVEhJUycsJ1NVUEVSJywnVEFHX0VORCcsJ0lWQVInLCdHVkFSJywnU0VMRicsJ0NPTlNUJywnTkVXJywnQVJHVkFSJywnU1lNQk9MJywnUkVUVVJOJyxcblx0XHQnTlVNQkVSJywnQk9PTCcsJ1RBR19TRUxFQ1RPUicsJ0lEUkVGJywnQVJHVU1FTlRTJywnfScsJ1RBR19UWVBFJ1xuXHRdO1xuXHRcblx0dmFyIEdMT0JBTF9JREVOVElGSUVSUyA9IFsnZ2xvYmFsJywnZXhwb3J0cycsJ3JlcXVpcmUnXTtcblx0XG5cdC8vIFRva2VucyB0aGF0LCB3aGVuIGltbWVkaWF0ZWx5IHByZWNlZGluZyBhIGBXSEVOYCwgaW5kaWNhdGUgdGhhdCB0aGUgYFdIRU5gXG5cdC8vIG9jY3VycyBhdCB0aGUgc3RhcnQgb2YgYSBsaW5lLiBXZSBkaXNhbWJpZ3VhdGUgdGhlc2UgZnJvbSB0cmFpbGluZyB3aGVucyB0b1xuXHQvLyBhdm9pZCBhbiBhbWJpZ3VpdHkgaW4gdGhlIGdyYW1tYXIuXG5cdHZhciBMSU5FX0JSRUFLID0gWydJTkRFTlQnLCdPVVRERU5UJywnVEVSTUlOQVRPUiddO1xuXHRcblx0XG5cdGZ1bmN0aW9uIExleGVyRXJyb3IobWVzc2FnZSxmaWxlLGxpbmUpe1xuXHRcdHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG5cdFx0dGhpcy5maWxlID0gZmlsZTtcblx0XHR0aGlzLmxpbmUgPSBsaW5lO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRzdWJjbGFzcyQoTGV4ZXJFcnJvcixTeW50YXhFcnJvcik7XG5cdGV4cG9ydHMuTGV4ZXJFcnJvciA9IExleGVyRXJyb3I7IC8vIGV4cG9ydCBjbGFzcyBcblx0XG5cdFxuXHRcblx0ZnVuY3Rpb24gbGFzdChhcnJheSxiYWNrKXtcblx0XHRpZihiYWNrID09PSB1bmRlZmluZWQpIGJhY2sgPSAwO1xuXHRcdHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSBiYWNrIC0gMV07XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBjb3VudChzdHIsc3Vic3RyKXtcblx0XHRyZXR1cm4gc3RyLnNwbGl0KHN1YnN0cikubGVuZ3RoIC0gMTtcblx0fTtcblx0XG5cdGZ1bmN0aW9uIHJlcGVhdFN0cmluZyhzdHIsdGltZXMpe1xuXHRcdHZhciByZXMgPSAnJztcblx0XHR3aGlsZSAodGltZXMgPiAwKXtcblx0XHRcdGlmICh0aW1lcyAlIDIgPT0gMSkge1xuXHRcdFx0XHRyZXMgKz0gc3RyO1xuXHRcdFx0fTtcblx0XHRcdHN0ciArPSBzdHI7XG5cdFx0XHR0aW1lcyA+Pj0gMTtcblx0XHR9O1xuXHRcdHJldHVybiByZXM7XG5cdH07XG5cdFxuXHR2YXIgdFQgPSBULnR5cDtcblx0dmFyIHRWID0gVC52YWw7XG5cdHZhciB0VHMgPSBULnNldFR5cDtcblx0dmFyIHRWcyA9IFQuc2V0VmFsO1xuXHRcblx0Ly8gVGhlIExleGVyIGNsYXNzIHJlYWRzIGEgc3RyZWFtIG9mIEltYmEgYW5kIGRpdnZpZXMgaXQgdXAgaW50byB0b2tpZGdlZFxuXHQvLyB0b2tlbnMuIFNvbWUgcG90ZW50aWFsIGFtYmlndWl0eSBpbiB0aGUgZ3JhbW1hciBoYXMgYmVlbiBhdm9pZGVkIGJ5XG5cdC8vIHB1c2hpbmcgc29tZSBleHRyYSBzbWFydHMgaW50byB0aGUgTGV4ZXIuXG5cdFxuXHQvLyBCYXNlZCBvbiB0aGUgb3JpZ2luYWwgbGV4ZXIuY29mZmVlIGZyb20gQ29mZmVlU2NyaXB0XG5cdGZ1bmN0aW9uIExleGVyKCl7XG5cdFx0dGhpcy5yZXNldCgpO1xuXHRcdHRoaXM7XG5cdH07XG5cdFxuXHRleHBvcnRzLkxleGVyID0gTGV4ZXI7IC8vIGV4cG9ydCBjbGFzcyBcblx0TGV4ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCl7XG5cdFx0dGhpcy5fY29kZSA9IG51bGw7XG5cdFx0dGhpcy5fY2h1bmsgPSBudWxsOyAvLyBUaGUgcmVtYWluZGVyIG9mIHRoZSBzb3VyY2UgY29kZS5cblx0XHR0aGlzLl9vcHRzID0gbnVsbDtcblx0XHRcblx0XHR0aGlzLl9pbmRlbnQgPSAwOyAvLyBUaGUgY3VycmVudCBpbmRlbnRhdGlvbiBsZXZlbC5cblx0XHR0aGlzLl9pbmRlYnQgPSAwOyAvLyBUaGUgb3Zlci1pbmRlbnRhdGlvbiBhdCB0aGUgY3VycmVudCBsZXZlbC5cblx0XHR0aGlzLl9vdXRkZWJ0ID0gMDsgLy8gVGhlIHVuZGVyLW91dGRlbnRhdGlvbiBhdCB0aGUgY3VycmVudCBsZXZlbC5cblx0XHRcblx0XHR0aGlzLl9pbmRlbnRzID0gW107IC8vIFRoZSBzdGFjayBvZiBhbGwgY3VycmVudCBpbmRlbnRhdGlvbiBsZXZlbHMuXG5cdFx0dGhpcy5fZW5kcyA9IFtdOyAvLyBUaGUgc3RhY2sgZm9yIHBhaXJpbmcgdXAgdG9rZW5zLlxuXHRcdHRoaXMuX2NvbnRleHRzID0gW107IC8vIHN1cGxlbWVudHMgQGVuZHNcblx0XHR0aGlzLl9zY29wZXMgPSBbXTtcblx0XHR0aGlzLl9uZXh0U2NvcGUgPSBudWxsOyAvLyB0aGUgc2NvcGUgdG8gYWRkIG9uIHRoZSBuZXh0IGluZGVudFxuXHRcdC8vIHNob3VsZCByYXRoZXIgbWFrZSBpdCBsaWtlIGEgc3RhdGVtYWNoaW5lIHRoYXQgbW92ZXMgZnJvbSBDTEFTU19ERUYgdG8gQ0xBU1NfQk9EWSBldGNcblx0XHQvLyBUaGluZ3Mgc2hvdWxkIGNvbXBpbGUgZGlmZmVyZW50bHkgd2hlbiB5b3UgYXJlIGluIGEgQ0xBU1NfQk9EWSB0aGFuIHdoZW4gaW4gYSBERUZfQk9EWSsrXG5cdFx0XG5cdFx0dGhpcy5faW5kZW50U3R5bGUgPSBudWxsO1xuXHRcdFxuXHRcdHRoaXMuX3Rva2VucyA9IFtdOyAvLyBTdHJlYW0gb2YgcGFyc2VkIHRva2VucyBpbiB0aGUgZm9ybSBgWydUWVBFJywgdmFsdWUsIGxpbmVdYC5cblx0XHR0aGlzLl9zZWVuRm9yID0gZmFsc2U7XG5cdFx0dGhpcy5fbG9jID0gMDtcblx0XHR0aGlzLl9sb2NPZmZzZXQgPSAwO1xuXHRcdFxuXHRcdHRoaXMuX2VuZCA9IG51bGw7XG5cdFx0dGhpcy5fY2hhciA9IG51bGw7XG5cdFx0dGhpcy5fYnJpZGdlID0gbnVsbDtcblx0XHR0aGlzLl9sYXN0ID0gbnVsbDtcblx0XHR0aGlzLl9sYXN0VHlwID0gJyc7XG5cdFx0dGhpcy5fbGFzdFZhbCA9IG51bGw7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRMZXhlci5wcm90b3R5cGUuamlzb25CcmlkZ2UgPSBmdW5jdGlvbiAoamlzb24pe1xuXHRcdHJldHVybiB0aGlzLl9icmlkZ2UgPSB7XG5cdFx0XHRsZXg6IFQubGV4LFxuXHRcdFx0c2V0SW5wdXQ6IGZ1bmN0aW9uKHRva2Vucykge1xuXHRcdFx0XHR0aGlzLnRva2VucyA9IHRva2Vucztcblx0XHRcdFx0cmV0dXJuIHRoaXMucG9zID0gMDtcblx0XHRcdH0sXG5cdFx0XHRcblx0XHRcdHVwY29taW5nSW5wdXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCJcIjsgfVxuXHRcdH07XG5cdH07XG5cdFxuXHRcblx0TGV4ZXIucHJvdG90eXBlLnRva2VuaXplID0gZnVuY3Rpb24gKGNvZGUsbyl7XG5cdFx0XG5cdFx0aWYobyA9PT0gdW5kZWZpbmVkKSBvID0ge307XG5cdFx0aWYgKGNvZGUubGVuZ3RoID09IDApIHtcblx0XHRcdHJldHVybiBbXTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmICghby5pbmxpbmUpIHtcblx0XHRcdGlmIChXSElURVNQQUNFLnRlc3QoY29kZSkpIHtcblx0XHRcdFx0Y29kZSA9IChcIlxcblwiICsgY29kZSk7XG5cdFx0XHRcdGlmIChjb2RlLm1hdGNoKC9eXFxzKiQvZykpIHsgcmV0dXJuIFtdIH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRjb2RlID0gY29kZS5yZXBsYWNlKC9cXHIvZywnJykucmVwbGFjZSgvW1xcdCBdKyQvZywnJyk7XG5cdFx0fTtcblx0XHRcblx0XHR0aGlzLl9sYXN0ID0gbnVsbDtcblx0XHR0aGlzLl9sYXN0VHlwID0gbnVsbDtcblx0XHR0aGlzLl9sYXN0VmFsID0gbnVsbDtcblx0XHRcblx0XHR0aGlzLl9jb2RlID0gY29kZTtcblx0XHR0aGlzLl9vcHRzID0gbztcblx0XHR0aGlzLl9sb2NPZmZzZXQgPSBvLmxvYyB8fCAwO1xuXHRcdFxuXHRcdG8uaW5kZW50IHx8IChvLmluZGVudCA9IHtzdHlsZTogbnVsbCxzaXplOiBudWxsfSk7XG5cdFx0Ly8gYWRkIGEgcmVmZXJlbmNlIHRvIHRoZSBvcHRpb25zIG9iamVjdFxuXHRcdG8uX3Rva2VucyA9IHRoaXMuX3Rva2Vucztcblx0XHQvLyB3aGF0IGFib3V0IGNvbCBoZXJlP1xuXHRcdFxuXHRcdC8vIEBpbmRlbnQgID0gMCAjIFRoZSBjdXJyZW50IGluZGVudGF0aW9uIGxldmVsLlxuXHRcdC8vIEBpbmRlYnQgID0gMCAjIFRoZSBvdmVyLWluZGVudGF0aW9uIGF0IHRoZSBjdXJyZW50IGxldmVsLlxuXHRcdC8vIEBvdXRkZWJ0ID0gMCAjIFRoZSB1bmRlci1vdXRkZW50YXRpb24gYXQgdGhlIGN1cnJlbnQgbGV2ZWwuXG5cdFx0Ly8gQGluZGVudHMgPSBbXSAjIFRoZSBzdGFjayBvZiBhbGwgY3VycmVudCBpbmRlbnRhdGlvbiBsZXZlbHMuXG5cdFx0Ly8gQGVuZHMgICAgPSBbXSAjIFRoZSBzdGFjayBmb3IgcGFpcmluZyB1cCB0b2tlbnMuXG5cdFx0Ly8gQHRva2VucyAgPSBbXSAjIFN0cmVhbSBvZiBwYXJzZWQgdG9rZW5zIGluIHRoZSBmb3JtIGBbJ1RZUEUnLCB2YWx1ZSwgbGluZV1gLlxuXHRcdC8vIEBjaGFyID0gbmlsXG5cdFx0XG5cdFx0aWYgKG8ucHJvZmlsZSkgeyBjb25zb2xlLnRpbWUoXCJ0b2tlbml6ZTpsZXhlclwiKSB9O1xuXHRcdHRoaXMucGFyc2UoY29kZSk7XG5cdFx0aWYgKCFvLmlubGluZSkgdGhpcy5jbG9zZUluZGVudGF0aW9uKCk7XG5cdFx0aWYgKCFvLnNpbGVudCAmJiB0aGlzLl9lbmRzLmxlbmd0aCkge1xuXHRcdFx0dGhpcy5lcnJvcigoXCJtaXNzaW5nIFwiICsgKHRoaXMuX2VuZHMucG9wKCkpKSk7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoby5wcm9maWxlKSB7IGNvbnNvbGUudGltZUVuZChcInRva2VuaXplOmxleGVyXCIpIH07XG5cdFx0aWYgKG8ucmV3cml0ZSA9PSBmYWxzZSB8fCBvLm5vcmV3cml0ZSkgeyByZXR1cm4gdGhpcy5fdG9rZW5zIH07XG5cdFx0cmV0dXJuIG5ldyBSZXdyaXRlcigpLnJld3JpdGUodGhpcy5fdG9rZW5zLG8pO1xuXHR9O1xuXHRcblx0TGV4ZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKGNvZGUpe1xuXHRcdHZhciBpID0gMDtcblx0XHR2YXIgcGkgPSAwO1xuXHRcdFxuXHRcdHdoaWxlICh0aGlzLl9jaHVuayA9IGNvZGUuc2xpY2UoaSkpe1xuXHRcdFx0dGhpcy5fbG9jID0gdGhpcy5fbG9jT2Zmc2V0ICsgaTtcblx0XHRcdHBpID0gKHRoaXMuX2VuZCA9PSAnVEFHJyAmJiB0aGlzLnRhZ0RlZkNvbnRleHRUb2tlbigpKSB8fCAodGhpcy5faW5UYWcgJiYgdGhpcy50YWdDb250ZXh0VG9rZW4oKSkgfHwgdGhpcy5iYXNpY0NvbnRleHQoKTtcblx0XHRcdGkgKz0gcGk7XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm47XG5cdH07XG5cdFxuXHRMZXhlci5wcm90b3R5cGUuYmFzaWNDb250ZXh0ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuc2VsZWN0b3JUb2tlbigpIHx8IHRoaXMuc3ltYm9sVG9rZW4oKSB8fCB0aGlzLm1ldGhvZE5hbWVUb2tlbigpIHx8IHRoaXMuaWRlbnRpZmllclRva2VuKCkgfHwgdGhpcy53aGl0ZXNwYWNlVG9rZW4oKSB8fCB0aGlzLmxpbmVUb2tlbigpIHx8IHRoaXMuY29tbWVudFRva2VuKCkgfHwgdGhpcy5oZXJlZG9jVG9rZW4oKSB8fCB0aGlzLnRhZ1Rva2VuKCkgfHwgdGhpcy5zdHJpbmdUb2tlbigpIHx8IHRoaXMubnVtYmVyVG9rZW4oKSB8fCB0aGlzLnJlZ2V4VG9rZW4oKSB8fCB0aGlzLmpzVG9rZW4oKSB8fCB0aGlzLmxpdGVyYWxUb2tlbigpIHx8IDA7XG5cdH07XG5cdFxuXHRMZXhlci5wcm90b3R5cGUubW92ZUNhcmV0ID0gZnVuY3Rpb24gKGkpe1xuXHRcdHJldHVybiB0aGlzLl9sb2MgKz0gaTtcblx0fTtcblx0XG5cdExleGVyLnByb3RvdHlwZS5jb250ZXh0ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX2VuZHNbdGhpcy5fZW5kcy5sZW5ndGggLSAxXTtcblx0fTtcblx0XG5cdExleGVyLnByb3RvdHlwZS5pbkNvbnRleHQgPSBmdW5jdGlvbiAoa2V5KXtcblx0XHR2YXIgbyA9IHRoaXMuX2NvbnRleHRzW3RoaXMuX2NvbnRleHRzLmxlbmd0aCAtIDFdO1xuXHRcdHJldHVybiBvICYmIG9ba2V5XTtcblx0fTtcblx0XG5cdExleGVyLnByb3RvdHlwZS5wdXNoRW5kID0gZnVuY3Rpb24gKHZhbCl7XG5cdFx0Ly8gY29uc29sZS5sb2cgXCJwdXNoaW5nIGVuZFwiLHZhbFxuXHRcdHRoaXMuX2VuZHMucHVzaCh2YWwpO1xuXHRcdHRoaXMuX2NvbnRleHRzLnB1c2gobnVsbCk7XG5cdFx0dGhpcy5fZW5kID0gdmFsO1xuXHRcdHRoaXMucmVmcmVzaFNjb3BlKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRMZXhlci5wcm90b3R5cGUucG9wRW5kID0gZnVuY3Rpb24gKHZhbCl7XG5cdFx0dGhpcy5fZW5kcy5wb3AoKTtcblx0XHR0aGlzLl9jb250ZXh0cy5wb3AoKTtcblx0XHR0aGlzLl9lbmQgPSB0aGlzLl9lbmRzW3RoaXMuX2VuZHMubGVuZ3RoIC0gMV07XG5cdFx0dGhpcy5yZWZyZXNoU2NvcGUoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdExleGVyLnByb3RvdHlwZS5yZWZyZXNoU2NvcGUgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgY3R4MCA9IHRoaXMuX2VuZHNbdGhpcy5fZW5kcy5sZW5ndGggLSAxXTtcblx0XHR2YXIgY3R4MSA9IHRoaXMuX2VuZHNbdGhpcy5fZW5kcy5sZW5ndGggLSAyXTtcblx0XHRyZXR1cm4gdGhpcy5faW5UYWcgPSBjdHgwID09ICdUQUdfRU5EJyB8fCAoY3R4MSA9PSAnVEFHX0VORCcgJiYgY3R4MCA9PSAnT1VUREVOVCcpO1xuXHR9O1xuXHRcblx0XG5cdFxuXHRMZXhlci5wcm90b3R5cGUucXVldWVTY29wZSA9IGZ1bmN0aW9uICh2YWwpe1xuXHRcdC8vIGNvbnNvbGUubG9nKFwicHVzaGluZyBzY29wZSB7dmFsfSAtIHtAaW5kZW50c30ge0BpbmRlbnRzOmxlbmd0aH1cIilcblx0XHQvLyBAc2NvcGVzLnB1c2godmFsKSAjIG5vIG5vXG5cdFx0dGhpcy5fc2NvcGVzW3RoaXMuX2luZGVudHMubGVuZ3RoXSA9IHZhbDtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdExleGVyLnByb3RvdHlwZS5wb3BTY29wZSA9IGZ1bmN0aW9uICh2YWwpe1xuXHRcdHRoaXMuX3Njb3Blcy5wb3AoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdExleGVyLnByb3RvdHlwZS5nZXRTY29wZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9zY29wZXNbdGhpcy5faW5kZW50cy5sZW5ndGggLSAxXTtcblx0fTtcblx0XG5cdExleGVyLnByb3RvdHlwZS5zY29wZSA9IGZ1bmN0aW9uIChzeW0sb3B0cyl7XG5cdFx0dmFyIGxlbiA9IHRoaXMuX2VuZHMucHVzaCh0aGlzLl9lbmQgPSBzeW0pO1xuXHRcdHRoaXMuX2NvbnRleHRzLnB1c2gob3B0cyB8fCBudWxsKTtcblx0XHRyZXR1cm4gc3ltO1xuXHR9O1xuXHRcblx0XG5cdExleGVyLnByb3RvdHlwZS5jbG9zZVNlbGVjdG9yID0gZnVuY3Rpb24gKCl7XG5cdFx0aWYgKHRoaXMuX2VuZCA9PSAnJScpIHtcblx0XHRcdHRoaXMudG9rZW4oJ1NFTEVDVE9SX0VORCcsJyUnLDApO1xuXHRcdFx0cmV0dXJuIHRoaXMucGFpcignJScpO1xuXHRcdH07XG5cdH07XG5cdFxuXHRcblx0TGV4ZXIucHJvdG90eXBlLm9wZW5EZWYgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5wdXNoRW5kKCdERUYnKTtcblx0fTtcblx0XG5cdFxuXHRMZXhlci5wcm90b3R5cGUuY2xvc2VEZWYgPSBmdW5jdGlvbiAoKXtcblx0XHRpZiAodGhpcy5jb250ZXh0KCkgPT0gJ0RFRicpIHtcblx0XHRcdHZhciBwcmV2ID0gbGFzdCh0aGlzLl90b2tlbnMpO1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgXCJjbG9zZSBkZWYge3ByZXZ9XCJcblx0XHRcdC8vIGNvbnNvbGUubG9nKCdjbG9zZURlZiB3aXRoIGxhc3Q+JyxwcmV2KVxuXHRcdFx0aWYgKHRUKHByZXYpID09ICdERUZfRlJBR01FTlQnKSB7XG5cdFx0XHRcdHRydWU7XG5cdFx0XHR9IGVsc2UgaWYgKHRUKHByZXYpID09ICdURVJNSU5BVE9SJykge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyBcImhlcmU/IT8/XCJcblx0XHRcdFx0dmFyIG4gPSB0aGlzLl90b2tlbnMucG9wKCk7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nIG5cblx0XHRcdFx0dGhpcy50b2tlbignREVGX0JPRFknLCdERUZfQk9EWScsMCk7XG5cdFx0XHRcdC8vIHRva2VuKCdURVJNSU5BVE9SJywgJycsMCkgdW5sZXNzIG4uQHZhbHVlLmluZGV4T2YoJy8vJykgPj0gMFxuXHRcdFx0XHR0aGlzLl90b2tlbnMucHVzaChuKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMudG9rZW4oJ0RFRl9CT0RZJywnREVGX0JPRFknLDApO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dGhpcy5wYWlyKCdERUYnKTtcblx0XHR9O1xuXHRcdHJldHVybjtcblx0fTtcblx0XG5cdExleGVyLnByb3RvdHlwZS50YWdDb250ZXh0VG9rZW4gPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgbWF0Y2g7XG5cdFx0aWYgKHRoaXMuX2NodW5rWzBdID09ICcjJykge1xuXHRcdFx0Ly8gY29uc29sZS5sb2coJ2ZvdW5kIGlkICMgaW4gdGFnQ29udGV4dFRva2VuJylcblx0XHRcdHRoaXMudG9rZW4oJyMnLCcjJywxKTtcblx0XHRcdHJldHVybiAxO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKG1hdGNoID0gVEFHX0FUVFIuZXhlYyh0aGlzLl9jaHVuaykpIHtcblx0XHRcdC8vIGNvbnNvbGUubG9nICdUQUdfU0REU0FUVFIgSU4gdG9raWQnLG1hdGNoXG5cdFx0XHQvLyB2YXIgcHJldiA9IGxhc3QgQHRva2Vuc1xuXHRcdFx0Ly8gaWYgdGhlIHByZXYgaXMgYSB0ZXJtaW5hdG9yLCB3ZSBkb250IHJlYWxseSBuZWVkIHRvIGNhcmU/XG5cdFx0XHRpZiAodGhpcy5fbGFzdFR5cCAhPSAnVEFHX05BTUUnKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9sYXN0VHlwID09ICdURVJNSU5BVE9SJykge1xuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKCdwcmV2IHdhcyB0ZXJtaW5hdG9yIC0tIGRyb3AgaXQ/Jylcblx0XHRcdFx0XHR0cnVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMudG9rZW4oXCIsXCIsXCIsXCIpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dmFyIGwgPSBtYXRjaFswXS5sZW5ndGg7XG5cdFx0XHRcblx0XHRcdHRoaXMudG9rZW4oJ1RBR19BVFRSJyxtYXRjaFsxXSxsIC0gMSk7IC8vIGFkZCB0byBsb2M/XG5cdFx0XHR0aGlzLl9sb2MgKz0gbCAtIDE7XG5cdFx0XHR0aGlzLnRva2VuKCc9JywnPScsMSk7XG5cdFx0XHRyZXR1cm4gbDtcblx0XHR9O1xuXHRcdHJldHVybiAwO1xuXHR9O1xuXHRcblx0TGV4ZXIucHJvdG90eXBlLnRhZ0RlZkNvbnRleHRUb2tlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdC8vIGNvbnNvbGUubG9nIFwidGFnQ29udGV4dFRva2VuXCJcblx0XHR2YXIgbWF0Y2g7XG5cdFx0aWYgKG1hdGNoID0gVEFHX1RZUEUuZXhlYyh0aGlzLl9jaHVuaykpIHtcblx0XHRcdHRoaXMudG9rZW4oJ1RBR19UWVBFJyxtYXRjaFswXSxtYXRjaFswXS5sZW5ndGgpO1xuXHRcdFx0cmV0dXJuIG1hdGNoWzBdLmxlbmd0aDtcblx0XHR9O1xuXHRcdFxuXHRcdGlmIChtYXRjaCA9IFRBR19JRC5leGVjKHRoaXMuX2NodW5rKSkge1xuXHRcdFx0dmFyIGlucHV0ID0gbWF0Y2hbMF07XG5cdFx0XHR0aGlzLnRva2VuKCdUQUdfSUQnLGlucHV0LGlucHV0Lmxlbmd0aCk7XG5cdFx0XHRyZXR1cm4gaW5wdXQubGVuZ3RoO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIDA7XG5cdH07XG5cdFxuXHRcblx0TGV4ZXIucHJvdG90eXBlLnRhZ1Rva2VuID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIG1hdGNoLCBhcnk7XG5cdFx0aWYgKCEobWF0Y2ggPSBUQUcuZXhlYyh0aGlzLl9jaHVuaykpKSB7IHJldHVybiAwIH07XG5cdFx0dmFyIGFyeSA9IGl0ZXIkKG1hdGNoKTt2YXIgaW5wdXQgPSBhcnlbMF0sdHlwZSA9IGFyeVsxXSxpZGVudGlmaWVyID0gYXJ5WzJdO1xuXHRcdFxuXHRcdGlmICh0eXBlID09ICc8Jykge1xuXHRcdFx0dGhpcy50b2tlbignVEFHX1NUQVJUJywnPCcsMSk7XG5cdFx0XHR0aGlzLnB1c2hFbmQoSU5WRVJTRVMuVEFHX1NUQVJUKTtcblx0XHRcdFxuXHRcdFx0aWYgKG1hdGNoID0gVEFHX1RZUEUuZXhlYyh0aGlzLl9jaHVuay5zdWJzdHIoMSw0MCkpKSB7XG5cdFx0XHRcdC8vIHNwZWNpYWwgY2FzZSBzaG91bGQgcHJvYmFibHkgYmUgaGFuZGxlZCBpbiBBU1Rcblx0XHRcdFx0aWYgKG1hdGNoWzBdICE9ICdzZWxmJykge1xuXHRcdFx0XHRcdHRoaXMudG9rZW4oJ1RBR19UWVBFJyxtYXRjaFswXSxtYXRjaFswXS5sZW5ndGgsMSk7XG5cdFx0XHRcdFx0cmV0dXJuIGlucHV0Lmxlbmd0aCArIG1hdGNoWzBdLmxlbmd0aDtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChpZGVudGlmaWVyKSB7XG5cdFx0XHRcdGlmIChpZGVudGlmaWVyLnN1YnN0cigwLDEpID09ICd7Jykge1xuXHRcdFx0XHRcdHJldHVybiB0eXBlLmxlbmd0aDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLnRva2VuKCdUQUdfTkFNRScsaW5wdXQuc3Vic3RyKDEpLDApO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiBpbnB1dC5sZW5ndGg7XG5cdH07XG5cdFxuXHRcblx0TGV4ZXIucHJvdG90eXBlLnNlbGVjdG9yVG9rZW4gPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgYXJ5O1xuXHRcdHZhciBtYXRjaDtcblx0XHRcblx0XHQvLyBzcGVjaWFsIGhhbmRsaW5nIGlmIHdlIGFyZSBpbiB0aGlzIGNvbnRleHRcblx0XHRpZiAodGhpcy5fZW5kID09ICclJykge1xuXHRcdFx0dmFyIGNociA9IHRoaXMuX2NodW5rLmNoYXJBdCgwKTtcblx0XHRcdHZhciBvcGVuID0gdGhpcy5pbkNvbnRleHQoJ29wZW4nKTtcblx0XHRcdFxuXHRcdFx0Ly8gc2hvdWxkIGFkZCBmb3IgKywgfiBldGNcblx0XHRcdC8vIHNob3VsZCBtYXliZSByYXRoZXIgbG9vayBmb3IgdGhlIGNvcnJlY3QgdHlwZSBvZiBjaGFyYWN0ZXI/XG5cdFx0XHRcblx0XHRcdGlmIChvcGVuICYmIChjaHIgPT0gJyAnIHx8IGNociA9PSAnXFxuJyB8fCBjaHIgPT0gJywnIHx8IGNociA9PSAnKycgfHwgY2hyID09ICd+JyB8fCBjaHIgPT0gJyknIHx8IGNociA9PSAnXScpKSB7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nIFwiY2xvc2UgdGhpcyBzZWxlY3RvciBkaXJlY3RseVwiXG5cdFx0XHRcdHRoaXMudG9rZW4oJ1NFTEVDVE9SX0VORCcsJyUnLDApO1xuXHRcdFx0XHR0aGlzLnBhaXIoJyUnKTtcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAobWF0Y2ggPSBTRUxFQ1RPUl9DT01CSU5BVE9SLmV4ZWModGhpcy5fY2h1bmspKSB7XG5cdFx0XHRcdC8vIHNwYWNlcyBiZXR3ZWVuPyAtLSBpbmNsdWRlIHRoZSB3aG9sZVxuXHRcdFx0XHR0aGlzLnRva2VuKCdTRUxFQ1RPUl9DT01CSU5BVE9SJyxtYXRjaFsxXSB8fCBcIiBcIixtYXRjaFswXS5sZW5ndGgpO1xuXHRcdFx0XHRyZXR1cm4gbWF0Y2hbMF0ubGVuZ3RoO1xuXHRcdFx0fSBlbHNlIGlmIChtYXRjaCA9IFNFTEVDVE9SX1BBUlQuZXhlYyh0aGlzLl9jaHVuaykpIHtcblx0XHRcdFx0dmFyIHR5cGUgPSBtYXRjaFsxXTtcblx0XHRcdFx0dmFyIGlkID0gbWF0Y2hbMl07XG5cdFx0XHRcdFxuXHRcdFx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdFx0XHRjYXNlICcuJzpcblx0XHRcdFx0XHRcdHRva2lkID0gJ1NFTEVDVE9SX0NMQVNTJzticmVhaztcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjYXNlICcjJzpcblx0XHRcdFx0XHRcdHRva2lkID0gJ1NFTEVDVE9SX0lEJzticmVhaztcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjYXNlICc6Jzpcblx0XHRcdFx0XHRcdHRva2lkID0gJ1NFTEVDVE9SX1BTRVVET19DTEFTUyc7YnJlYWs7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y2FzZSAnOjonOlxuXHRcdFx0XHRcdFx0dG9raWQgPSAnU0VMRUNUT1JfUFNFVURPX0NMQVNTJzticmVhaztcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0dmFyIHRva2lkID0gJ1NFTEVDVE9SX1RBRyc7XG5cdFx0XHRcdFxuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0dGhpcy50b2tlbih0b2tpZCxtYXRjaFsyXSxtYXRjaFswXS5sZW5ndGgpO1xuXHRcdFx0XHRyZXR1cm4gbWF0Y2hbMF0ubGVuZ3RoO1xuXHRcdFx0fSBlbHNlIGlmIChjaHIgPT0gJ1snKSB7XG5cdFx0XHRcdHRoaXMudG9rZW4oJ1snLCdbJywxKTtcblx0XHRcdFx0dGhpcy5wdXNoRW5kKCddJyk7XG5cdFx0XHRcdGlmIChtYXRjaCA9IFNFTEVDVE9SX0FUVFIuZXhlYyh0aGlzLl9jaHVuaykpIHtcblx0XHRcdFx0XHQvLyBmdWNrIHRoaXMgbGVuZ3RoIHNoaXRcblx0XHRcdFx0XHR2YXIgaWRvZmZzZXQgPSBtYXRjaFswXS5pbmRleE9mKG1hdGNoWzFdKTtcblx0XHRcdFx0XHR2YXIgb3BvZmZzZXQgPSBtYXRjaFswXS5pbmRleE9mKG1hdGNoWzJdKTtcblx0XHRcdFx0XHR0aGlzLnRva2VuKCdJREVOVElGSUVSJyxtYXRjaFsxXSxtYXRjaFsxXS5sZW5ndGgsaWRvZmZzZXQpO1xuXHRcdFx0XHRcdHRoaXMudG9rZW4oJ1NFTEVDVE9SX0FUVFJfT1AnLG1hdGNoWzJdLG1hdGNoWzJdLmxlbmd0aCxvcG9mZnNldCk7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoWzBdLmxlbmd0aDtcblx0XHRcdFx0fTtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9IGVsc2UgaWYgKGNociA9PSAnfCcpIHtcblx0XHRcdFx0dmFyIHRvayA9IHRoaXMuX3Rva2Vuc1t0aGlzLl90b2tlbnMubGVuZ3RoIC0gMV07XG5cdFx0XHRcdHRUcyh0b2ssJ1NFTEVDVE9SX05TJyk7XG5cdFx0XHRcdC8vIHRva1swXSA9ICdTRUxFQ1RPUl9OUycgIyBGSVhcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9IGVsc2UgaWYgKGNociA9PSAnLCcpIHtcblx0XHRcdFx0dGhpcy50b2tlbignU0VMRUNUT1JfR1JPVVAnLCcsJywxKTtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9IGVsc2UgaWYgKGNociA9PSAnKicpIHtcblx0XHRcdFx0dGhpcy50b2tlbignVU5JVkVSU0FMX1NFTEVDVE9SJywnKicsMSk7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fSBlbHNlIGlmIChjaHIgPT0gJyknKSB7XG5cdFx0XHRcdHRoaXMucGFpcignJScpO1xuXHRcdFx0XHR0aGlzLnRva2VuKCdTRUxFQ1RPUl9FTkQnLCcpJywxKTtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9IGVsc2UgaWYgKGlkeCQoY2hyLFsnKScsJ30nLCddJywnJ10pID49IDApIHtcblx0XHRcdFx0dGhpcy5wYWlyKCclJyk7XG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmICghKG1hdGNoID0gU0VMRUNUT1IuZXhlYyh0aGlzLl9jaHVuaykpKSB7IHJldHVybiAwIH07XG5cdFx0dmFyIGFyeSA9IGl0ZXIkKG1hdGNoKTt2YXIgaW5wdXQgPSBhcnlbMF0saWQgPSBhcnlbMV0sa2luZCA9IGFyeVsyXTtcblx0XHRcblx0XHQvLyB0aGlzIGlzIGEgY2xvc2VkIHNlbGVjdG9yXG5cdFx0aWYgKGtpbmQgPT0gJygnKSB7XG5cdFx0XHQvLyB0b2tlbiAnKCcsJygnXG5cdFx0XHR0aGlzLnRva2VuKCdTRUxFQ1RPUl9TVEFSVCcsaWQsaWQubGVuZ3RoICsgMSk7XG5cdFx0XHQvLyBzZWxmLnB1c2hFbmQoJyknKSAjIGFyZSB3ZSBzbyBzdXJlIGFib3V0IHRoaXM/XG5cdFx0XHR0aGlzLnB1c2hFbmQoJyUnKTtcblx0XHRcdFxuXHRcdFx0Ly8gQGVuZHMucHVzaCAnKSdcblx0XHRcdC8vIEBlbmRzLnB1c2ggJyUnXG5cdFx0XHRyZXR1cm4gaWQubGVuZ3RoICsgMTtcblx0XHR9IGVsc2UgaWYgKGlkID09ICclJykge1xuXHRcdFx0Ly8gd2UgYXJlIGFscmVhZHkgc2NvcGVkIGluIG9uIGEgc2VsZWN0b3Jcblx0XHRcdGlmICh0aGlzLmNvbnRleHQoKSA9PSAnJScpIHsgcmV0dXJuIDEgfTtcblx0XHRcdHRoaXMudG9rZW4oJ1NFTEVDVE9SX1NUQVJUJyxpZCxpZC5sZW5ndGgpO1xuXHRcdFx0Ly8gdGhpcyBpcyBhIHNlcGFyYXRlIC0gc2NvcGUuIEZ1bGwgc2VsZWN0b3Igc2hvdWxkIHJhdGhlciBiZSAkLCBhbmQga2VlcCB0aGUgc2luZ2xlIHNlbGVjdG9yIGFzICVcblx0XHRcdFxuXHRcdFx0dGhpcy5zY29wZSgnJScse29wZW46IHRydWV9KTtcblx0XHRcdC8vIEBlbmRzLnB1c2ggJyUnXG5cdFx0XHQvLyBtYWtlIHN1cmUgYSB0ZXJtaW5hdG9yIGJyZWFrcyBvdXRcblx0XHRcdHJldHVybiBpZC5sZW5ndGg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiAwO1xuXHRcdH07XG5cdH07XG5cdFxuXHQvLyBpcyB0aGlzIHJlYWxseSBuZWVkZWQ/IFNob3VsZCBiZSBwb3NzaWJsZSB0b1xuXHQvLyBwYXJzZSB0aGUgaWRlbnRpZmllcnMgYW5kID0gZXRjIGkgamlzb24/XG5cdC8vIHdoYXQgaXMgc3BlY2lhbCBhYm91dCBtZXRob2ROYW1lVG9rZW4/IHJlYWxseT9cblx0TGV4ZXIucHJvdG90eXBlLm1ldGhvZE5hbWVUb2tlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdC8vIHdlIGNhbiBvcHRpbWl6ZSB0aGlzIGJ5IGFmdGVyIGEgZGVmIHNpbXBseVxuXHRcdC8vIGZldGNoaW5nIGFsbCB0aGUgd2F5IGFmdGVyIHRoZSBkZWYgdW50aWwgYSBzcGFjZSBvciAoXG5cdFx0Ly8gYW5kIHRoZW4gYWRkIHRoaXMgdG8gdGhlIGRlZi10b2tlbiBpdHNlbGYgKGFzIHdpdGggZnJhZ21lbnQpXG5cdFx0aWYgKHRoaXMuX2NodW5rLmNoYXJBdCgwKSA9PSAnICcpIHsgcmV0dXJuIDAgfTtcblx0XHRcblx0XHR2YXIgbWF0Y2g7XG5cdFx0XG5cdFx0aWYgKHRoaXMuX2VuZCA9PSAnKScpIHtcblx0XHRcdHZhciBvdXRlcmN0eCA9IHRoaXMuX2VuZHNbdGhpcy5fZW5kcy5sZW5ndGggLSAyXTtcblx0XHRcdC8vIHdlaXJkIGFzc3VtcHRpb24sIG5vP1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgJ2NvbnRleHQgaXMgaW5zaWRlISEhJ1xuXHRcdFx0aWYgKG91dGVyY3R4ID09ICclJyAmJiAobWF0Y2ggPSBUQUdfQVRUUi5leGVjKHRoaXMuX2NodW5rKSkpIHtcblx0XHRcdFx0dGhpcy50b2tlbignVEFHX0FUVFJfU0VUJyxtYXRjaFsxXSk7XG5cdFx0XHRcdHJldHVybiBtYXRjaFswXS5sZW5ndGg7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKCEobWF0Y2ggPSBNRVRIT0RfSURFTlRJRklFUi5leGVjKHRoaXMuX2NodW5rKSkpIHtcblx0XHRcdHJldHVybiAwO1xuXHRcdH07XG5cdFx0Ly8gdmFyIHByZXYgPSBsYXN0IEB0b2tlbnNcblx0XHR2YXIgbGVuZ3RoID0gbWF0Y2hbMF0ubGVuZ3RoO1xuXHRcdFxuXHRcdHZhciBpZCA9IG1hdGNoWzBdO1xuXHRcdHZhciBsdHlwID0gdGhpcy5fbGFzdFR5cDtcblx0XHR2YXIgdHlwID0gJ0lERU5USUZJRVInO1xuXHRcdHZhciBwcmUgPSBpZC5jaGFyQXQoMCk7XG5cdFx0dmFyIHNwYWNlID0gZmFsc2U7XG5cdFx0XG5cdFx0dmFyIG00ID0gbWF0Y2hbNF07IC8vIG1pZ2h0IGJlIG91dCBvZiBib3VuZHM/IHNob3VsZCByYXRoZXIgY2hlY2sgY2hhckF0XG5cdFx0Ly8gZHJvcCBtYXRjaCA0Pz9cblx0XHRcblx0XHQvLyBzaG91bGQgdGhpcyBub3QgcXVpdCBoZXJlIGluIHByYWN0aWNhbGx5IGFsbCBjYXNlcz9cblx0XHRpZiAoISgobHR5cCA9PSAnLicgfHwgbHR5cCA9PSAnREVGJykgfHwgKG00ID09ICchJyB8fCBtNCA9PSAnPycpIHx8IG1hdGNoWzVdKSkge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fTtcblx0XHRcblx0XHQvLyBhZ2Fpbiwgd2h5P1xuXHRcdGlmIChpZCA9PSAnc2VsZicgfHwgaWQgPT0gJ3RoaXMnIHx8IGlkID09ICdzdXBlcicpIHsgLy8gaW4gWydTRUxGJywnVEhJUyddXG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9O1xuXHRcdFxuXHRcdGlmIChpZCA9PSAnbmV3Jykge1xuXHRcdFx0dHlwID0gJ05FVyc7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoaWQgPT0gJy4uLicgJiYgWycsJywnKCcsJ0NBTExfU1RBUlQnLCdCTE9DS19QQVJBTV9TVEFSVCcsJ1BBUkFNX1NUQVJUJ10uaW5kZXhPZihsdHlwKSA+PSAwKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9O1xuXHRcdFxuXHRcdGlmIChpZCA9PSAnfCcpIHtcblx0XHRcdC8vIGhhY2t5IHdheSB0byBpbXBsZW1lbnQgdGhpc1xuXHRcdFx0Ly8gd2l0aCBuZXcgbGV4ZXIgd2UnbGwgdXNlIHsgLi4uIH0gaW5zdGVhZCwgYW5kIGFzc3VtZSBvYmplY3QtY29udGV4dCxcblx0XHRcdC8vIHRoZW4gZ28gYmFjayBhbmQgY29ycmVjdCB3aGVuIHdlIHNlZSB0aGUgY29udGV4dCBpcyBpbnZhbGlkXG5cdFx0XHRpZiAobHR5cCA9PSAnKCcgfHwgbHR5cCA9PSAnQ0FMTF9TVEFSVCcpIHtcblx0XHRcdFx0dGhpcy50b2tlbignRE8nLCdETycsMCk7XG5cdFx0XHRcdHRoaXMucHVzaEVuZCgnfCcpO1xuXHRcdFx0XHQvLyBAZW5kcy5wdXNoICd8J1xuXHRcdFx0XHR0aGlzLnRva2VuKCdCTE9DS19QQVJBTV9TVEFSVCcsaWQsMSk7XG5cdFx0XHRcdHJldHVybiBsZW5ndGg7XG5cdFx0XHR9IGVsc2UgaWYgKGx0eXAgPT0gJ0RPJyB8fCBsdHlwID09ICd7Jykge1xuXHRcdFx0XHQvLyBAZW5kcy5wdXNoICd8J1xuXHRcdFx0XHR0aGlzLnB1c2hFbmQoJ3wnKTtcblx0XHRcdFx0dGhpcy50b2tlbignQkxPQ0tfUEFSQU1fU1RBUlQnLGlkLDEpO1xuXHRcdFx0XHRyZXR1cm4gbGVuZ3RoO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLl9lbmRzW3RoaXMuX2VuZHMubGVuZ3RoIC0gMV0gPT0gJ3wnKSB7XG5cdFx0XHRcdHRoaXMudG9rZW4oJ0JMT0NLX1BBUkFNX0VORCcsJ3wnLDEpO1xuXHRcdFx0XHR0aGlzLnBhaXIoJ3wnKTtcblx0XHRcdFx0cmV0dXJuIGxlbmd0aDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIHdoYWF0P1xuXHRcdC8vIGNvbnNvbGUubG9nKFwibWV0aG9kIGlkZW50aWZpZXJcIixpZClcblx0XHRpZiAoKFsnJicsJ14nLCc8PCcsJzw8PCcsJz4+J10uaW5kZXhPZihpZCkgPj0gMCB8fCAoaWQgPT0gJ3wnICYmIHRoaXMuY29udGV4dCgpICE9ICd8JykpKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9O1xuXHRcdFxuXHRcdGlmIChPUF9NRVRIT0RTLmluZGV4T2YoaWQpID49IDApIHtcblx0XHRcdHNwYWNlID0gdHJ1ZTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIG5vdCBldmVuIGFueXRoaW5nIHdlIHNob3VsZCB1c2U/IT9cblx0XHRpZiAocHJlID09ICdAJykge1xuXHRcdFx0dHlwID0gJ0lWQVInO1xuXHRcdH0gZWxzZSBpZiAocHJlID09ICckJykge1xuXHRcdFx0dHJ1ZTtcblx0XHRcdC8vIHR5cCA9ICdHVkFSJ1xuXHRcdH0gZWxzZSBpZiAocHJlID09ICcjJykge1xuXHRcdFx0dHlwID0gJ1RBR0lEJztcblx0XHR9IGVsc2UgaWYgKENPTlNUX0lERU5USUZJRVIudGVzdChwcmUpIHx8IGlkID09ICdyZXF1aXJlJyB8fCBpZCA9PSAnZ2xvYmFsJyB8fCBpZCA9PSAnZXhwb3J0cycpIHtcblx0XHRcdC8vIHJlYWxseT8gc2VlbXMgdmVyeSBzdHJhbmdlXG5cdFx0XHQvLyBjb25zb2xlLmxvZygnZ2xvYmFsISEnLHR5cCxpZClcblx0XHRcdHR5cCA9ICdDT05TVCc7XG5cdFx0fTtcblx0XHRcblx0XHQvLyB3aGF0IGlzIHRoaXMgcmVhbGx5IGZvcj9cblx0XHRpZiAobWF0Y2hbNV0gJiYgWydJREVOVElGSUVSJywnQ09OU1QnLCdHVkFSJywnQ1ZBUicsJ0lWQVInLCdTRUxGJywnVEhJUycsJ10nLCd9JywnKScsJ05VTUJFUicsJ1NUUklORycsJ0lEUkVGJ10uaW5kZXhPZihsdHlwKSA+PSAwKSB7XG5cdFx0XHR0aGlzLnRva2VuKCcuJywnLicsMCk7XG5cdFx0fTtcblx0XHRcblx0XHR0aGlzLnRva2VuKHR5cCxpZCxsZW5ndGgpO1xuXHRcdFxuXHRcdGlmIChzcGFjZSkge1xuXHRcdFx0dGhpcy5fbGFzdC5zcGFjZWQgPSB0cnVlO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIGxlbmd0aDtcblx0fTtcblx0XG5cdFxuXHRMZXhlci5wcm90b3R5cGUuaW5UYWcgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgbGVuID0gdGhpcy5fZW5kcy5sZW5ndGg7XG5cdFx0aWYgKGxlbiA+IDApIHtcblx0XHRcdHZhciBjdHgwID0gdGhpcy5fZW5kc1tsZW4gLSAxXTtcblx0XHRcdHZhciBjdHgxID0gbGVuID4gMSA/ICh0aGlzLl9lbmRzW2xlbiAtIDJdKSA6IChjdHgwKTtcblx0XHRcdHJldHVybiBjdHgwID09ICdUQUdfRU5EJyB8fCAoY3R4MSA9PSAnVEFHX0VORCcgJiYgY3R4MCA9PSAnT1VUREVOVCcpO1xuXHRcdH07XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXHRcblx0TGV4ZXIucHJvdG90eXBlLmlzS2V5d29yZCA9IGZ1bmN0aW9uIChpZCl7XG5cdFx0aWYgKChpZCA9PSAnYXR0cicgfHwgaWQgPT0gJ3Byb3AnKSkge1xuXHRcdFx0dmFyIHNjb3AgPSB0aGlzLmdldFNjb3BlKCk7XG5cdFx0XHR2YXIgaW5jbHMgPSBzY29wID09ICdDTEFTUycgfHwgc2NvcCA9PSAnVEFHJztcblx0XHRcdC8vIHZhciBzY29wZXMgPSBAaW5kZW50cy5tYXAofGluZCxpfCBAc2NvcGVzW2ldIG9yICdOT05FJylcblx0XHRcdC8vIGNvbnNvbGUubG9nIFwiaWQgaXMgcHJvcDoge3Njb3Blcy5qb2luKFwiIC0+IFwiKX0gfCB7QGluZGVudHMuam9pbihcIiAtPiBcIil9XCJcblx0XHRcdGlmIChpbmNscykgeyByZXR1cm4gdHJ1ZSB9O1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIEFMTF9LRVlXT1JEUy5pbmRleE9mKGlkKSA+PSAwO1xuXHR9O1xuXHRcblx0Ly8gTWF0Y2hlcyBpZGVudGlmeWluZyBsaXRlcmFsczogdmFyaWFibGVzLCBrZXl3b3JkcywgbWV0aG9kIG5hbWVzLCBldGMuXG5cdC8vIENoZWNrIHRvIGVuc3VyZSB0aGF0IEphdmFTY3JpcHQgcmVzZXJ2ZWQgd29yZHMgYXJlbid0IGJlaW5nIHVzZWQgYXNcblx0Ly8gaWRlbnRpZmllcnMuIEJlY2F1c2UgSW1iYSByZXNlcnZlcyBhIGhhbmRmdWwgb2Yga2V5d29yZHMgdGhhdCBhcmVcblx0Ly8gYWxsb3dlZCBpbiBKYXZhU2NyaXB0LCB3ZSdyZSBjYXJlZnVsIG5vdCB0byB0b2tpZCB0aGVtIGFzIGtleXdvcmRzIHdoZW5cblx0Ly8gcmVmZXJlbmNlZCBhcyBwcm9wZXJ0eSBuYW1lcyBoZXJlLCBzbyB5b3UgY2FuIHN0aWxsIGRvIGBqUXVlcnkuaXMoKWAgZXZlblxuXHQvLyB0aG91Z2ggYGlzYCBtZWFucyBgPT09YCBvdGhlcndpc2UuXG5cdExleGVyLnByb3RvdHlwZS5pZGVudGlmaWVyVG9rZW4gPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgYXJ5O1xuXHRcdHZhciBtYXRjaDtcblx0XHRcblx0XHR2YXIgY3R4MCA9IHRoaXMuX2VuZHNbdGhpcy5fZW5kcy5sZW5ndGggLSAxXTtcblx0XHR2YXIgY3R4MSA9IHRoaXMuX2VuZHNbdGhpcy5fZW5kcy5sZW5ndGggLSAyXTtcblx0XHR2YXIgaW5uZXJjdHggPSBjdHgwO1xuXHRcdHZhciB0eXA7XG5cdFx0dmFyIHJlc2VydmVkID0gZmFsc2U7XG5cdFx0XG5cdFx0dmFyIGFkZExvYyA9IGZhbHNlO1xuXHRcdHZhciBpblRhZyA9IGN0eDAgPT0gJ1RBR19FTkQnIHx8IChjdHgxID09ICdUQUdfRU5EJyAmJiBjdHgwID09ICdPVVRERU5UJyk7XG5cdFx0XG5cdFx0Ly8gY29uc29sZS5sb2cgY3R4MSxjdHgwXG5cdFx0XG5cdFx0aWYgKGluVGFnICYmIChtYXRjaCA9IFRBR19BVFRSLmV4ZWModGhpcy5fY2h1bmspKSkge1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgJ1RBR19BVFRSIElOIHRva2lkJyxtYXRjaFxuXHRcdFx0Ly8gdmFyIHByZXYgPSBsYXN0IEB0b2tlbnNcblx0XHRcdC8vIGlmIHRoZSBwcmV2IGlzIGEgdGVybWluYXRvciwgd2UgZG9udCByZWFsbHkgbmVlZCB0byBjYXJlP1xuXHRcdFx0aWYgKHRoaXMuX2xhc3RUeXAgIT0gJ1RBR19OQU1FJykge1xuXHRcdFx0XHRpZiAodGhpcy5fbGFzdFR5cCA9PSAnVEVSTUlOQVRPUicpIHtcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZygncHJldiB3YXMgdGVybWluYXRvciAtLSBkcm9wIGl0PycpXG5cdFx0XHRcdFx0dHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLnRva2VuKFwiLFwiLFwiLFwiKTtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHZhciBsID0gbWF0Y2hbMF0ubGVuZ3RoO1xuXHRcdFx0XG5cdFx0XHR0aGlzLnRva2VuKCdUQUdfQVRUUicsbWF0Y2hbMV0sbCAtIDEpOyAvLyBhZGQgdG8gbG9jP1xuXHRcdFx0dGhpcy5fbG9jICs9IGwgLSAxO1xuXHRcdFx0dGhpcy50b2tlbignPScsJz0nLDEpO1xuXHRcdFx0cmV0dXJuIGw7XG5cdFx0fTtcblx0XHRcblx0XHQvLyBzZWUgaWYgdGhpcyBpcyBhIHBsYWluIG9iamVjdC1rZXlcblx0XHQvLyB3YXkgdG9vIG11Y2ggbG9naWMgZ29pbmcgb24gaGVyZT9cblx0XHQvLyB0aGUgYXN0IHNob3VsZCBub3JtYWxpemUgd2hldGhlciBrZXlzXG5cdFx0Ly8gYXJlIGFjY2Vzc2FibGUgYXMga2V5cyBvciBzdHJpbmdzIGV0Y1xuXHRcdGlmIChtYXRjaCA9IE9CSkVDVF9LRVkuZXhlYyh0aGlzLl9jaHVuaykpIHtcblx0XHRcdHZhciBpZCA9IG1hdGNoWzFdO1xuXHRcdFx0dHlwID0gJ0lERU5USUZJRVInO1xuXHRcdFx0XG5cdFx0XHQvLyBGSVhNRSBsb2Mgb2Yga2V5IGluY2x1ZGVzIGNvbG9uXG5cdFx0XHQvLyBtb3ZlQ2FyZXQoaWQ6bGVuZ3RoKVxuXHRcdFx0Ly8gY29uc29sZS5sb2cgXCJva1wiXG5cdFx0XHRpZiAodHJ1ZSkge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyBcImdvdCBoZXJlPyB7bWF0Y2h9XCJcblx0XHRcdFx0dGhpcy50b2tlbih0eXAsaWQsaWQubGVuZ3RoKTtcblx0XHRcdFx0dGhpcy5tb3ZlQ2FyZXQoaWQubGVuZ3RoKTtcblx0XHRcdFx0dGhpcy50b2tlbignOicsJzonLG1hdGNoWzNdLmxlbmd0aCk7XG5cdFx0XHRcdHRoaXMubW92ZUNhcmV0KC1pZC5sZW5ndGgpO1xuXHRcdFx0XHQvLyBtb3ZlQ2FyZXQobWF0Y2hbM106bGVuZ3RoKVxuXHRcdFx0XHRyZXR1cm4gbWF0Y2hbMF0ubGVuZ3RoO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Ly8gbW92ZUNhcmV0KG1hdGNoWzJdOmxlbmd0aClcblx0XHRcdC8vIHJldHVybiAwXG5cdFx0XHQvLyBjb25zb2xlLmxvZyBtYXRjaFszXTpsZW5ndGhcblx0XHRcdHRoaXMudG9rZW4odHlwLGlkLG1hdGNoWzBdLmxlbmd0aCk7XG5cdFx0XHR0aGlzLnRva2VuKCc6JywnOicsMSk7XG5cdFx0XHRyZXR1cm4gbWF0Y2hbMF0ubGVuZ3RoO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKCEobWF0Y2ggPSBJREVOVElGSUVSLmV4ZWModGhpcy5fY2h1bmspKSkge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgYXJ5ID0gaXRlciQobWF0Y2gpO3ZhciBpbnB1dCA9IGFyeVswXSxpZCA9IGFyeVsxXSx0eXAgPSBhcnlbMl0sbTMgPSBhcnlbM10sbTQgPSBhcnlbNF0sY29sb24gPSBhcnlbNV07XG5cdFx0dmFyIGlkbGVuID0gaWQubGVuZ3RoO1xuXHRcdFxuXHRcdC8vIFdoYXQgaXMgdGhlIGxvZ2ljIGhlcmU/XG5cdFx0aWYgKGlkID09ICdvd24nICYmIHRoaXMubGFzdFRva2VuVHlwZSgpID09ICdGT1InKSB7XG5cdFx0XHR0aGlzLnRva2VuKCdPV04nLGlkLGlkLmxlbmd0aCk7XG5cdFx0XHRyZXR1cm4gaWQubGVuZ3RoO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIHByZXYgPSBsYXN0KHRoaXMuX3Rva2Vucyk7XG5cdFx0dmFyIGxhc3RUeXAgPSB0aGlzLl9sYXN0VHlwO1xuXHRcdFxuXHRcdC8vIHNob3VsZCB3ZSBmb3JjZSB0aGlzIHRvIGJlIGFuIGlkZW50aWZpZXIgZXZlbiBpZiBpdCBpcyBhIHJlc2VydmVkIHdvcmQ/XG5cdFx0Ly8gdGhpcyBzaG91bGQgb25seSBoYXBwZW4gZm9yIHdoZW4gcGFydCBvZiBvYmplY3QgZXRjXG5cdFx0Ly8gd2lsbCBwcmV2IGV2ZXIgYmUgQD8/P1xuXHRcdHZhciBmb3JjZWRJZGVudGlmaWVyO1xuXHRcdFxuXHRcdC8vIGFnYWluXG5cdFx0Zm9yY2VkSWRlbnRpZmllciA9IGNvbG9uIHx8IGxhc3RUeXAgPT0gJy4nIHx8IGxhc3RUeXAgPT0gJz8uJzsgLy8gaW4gWycuJywgJz8uJ1xuXHRcdFxuXHRcdFxuXHRcdC8vIHRlbXAgaGFjayEgbmVlZCB0byBzb2x2ZSBmb3Igb3RoZXIga2V5d29yZHMgZXRjIGFzIHdlbGxcblx0XHQvLyBwcm9ibGVtIGFwcGVhcnMgd2l0aCB0ZXJuYXJ5IGNvbmRpdGlvbnMuXG5cdFx0XG5cdFx0Ly8gd2VsbCAtLSBpdCBzaG91bGQgc3RpbGwgYmUgYW4gaW5kZW50aWZpZXIgaWYgaW4gb2JqZWN0P1xuXHRcdC8vIGZvcmNlZElkZW50aWZpZXIgPSBubyBpZiBpZCBpbiBbJ3VuZGVmaW5lZCcsJ2JyZWFrJ11cblx0XHRcblx0XHRpZiAoY29sb24gJiYgbGFzdFR5cCA9PSAnPycpIHsgZm9yY2VkSWRlbnRpZmllciA9IGZhbHNlIH07IC8vIGZvciB0ZXJuYXJ5XG5cdFx0XG5cdFx0Ly8gaWYgd2UgYXJlIG5vdCBhdCB0aGUgdG9wIGxldmVsPyAtLSBoYWNreVxuXHRcdGlmIChpZCA9PSAndGFnJyAmJiB0aGlzLl9jaHVuay5pbmRleE9mKFwidGFnKFwiKSA9PSAwKSB7IC8vIEBjaHVuay5tYXRjaCgvXnRva2lkXFwoLylcblx0XHRcdGZvcmNlZElkZW50aWZpZXIgPSB0cnVlO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIGlzS2V5d29yZCA9IGZhbHNlO1xuXHRcdFxuXHRcdC8vIGNvbnNvbGUubG9nIFwibWF0Y2hcIixtYXRjaFxuXHRcdC8vIGNvbnNvbGUubG9nIFwidHlwIGlzIHt0eXB9XCJcblx0XHQvLyBsaXR0bGUgcmVhc29uIHRvIGNoZWNrIGZvciB0aGlzIHJpZ2h0IGhlcmU/IGJ1dCBJIGd1ZXNzIGl0IGlzIG9ubHkgYSBzaW1wbGUgY2hlY2tcblx0XHRpZiAodHlwID09ICckJyAmJiBBUkdWQVIudGVzdChpZCkpIHsgLy8gaWQubWF0Y2goL15cXCRcXGQkLylcblx0XHRcdC8vIGNvbnNvbGUubG9nIFwiVFlQICRcIlxuXHRcdFx0aWYgKGlkID09ICckMCcpIHtcblx0XHRcdFx0dHlwID0gJ0FSR1VNRU5UUyc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0eXAgPSAnQVJHVkFSJztcblx0XHRcdFx0aWQgPSBpZC5zdWJzdHIoMSk7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSBpZiAodHlwID09ICdAJykge1xuXHRcdFx0dHlwID0gJ0lWQVInO1xuXHRcdFx0XG5cdFx0XHQvLyBpZDpyZXNlcnZlZCA9IHllcyBpZiBjb2xvblxuXHRcdH0gZWxzZSBpZiAodHlwID09ICcjJykge1xuXHRcdFx0Ly8gd2UgYXJlIHRyeWluZyB0byBtb3ZlIHRvIGdlbmVyaWMgdG9rZW5zLFxuXHRcdFx0Ly8gc28gd2UgYXJlIHN0YXJ0aW5nIHRvIHNwbGl0dGluZyB1cCB0aGUgc3ltYm9scyBhbmQgdGhlIGl0ZW1zXG5cdFx0XHQvLyB3ZSdsbCBzZWUgaWYgdGhhdCB3b3Jrc1xuXHRcdFx0dHlwID0gJ0lERU5USUZJRVInO1xuXHRcdFx0dGhpcy50b2tlbignIycsJyMnKTtcblx0XHRcdGlkID0gaWQuc3Vic3RyKDEpO1xuXHRcdH0gZWxzZSBpZiAodHlwID09ICdAQCcpIHtcblx0XHRcdHR5cCA9ICdDVkFSJztcblx0XHR9IGVsc2UgaWYgKHR5cCA9PSAnJCcgJiYgIWNvbG9uKSB7XG5cdFx0XHR0eXAgPSAnSURFTlRJRklFUic7XG5cdFx0XHQvLyB0eXAgPSAnR1ZBUidcblx0XHR9IGVsc2UgaWYgKENPTlNUX0lERU5USUZJRVIudGVzdChpZCkgfHwgaWQgPT0gJ3JlcXVpcmUnIHx8IGlkID09ICdnbG9iYWwnIHx8IGlkID09ICdleHBvcnRzJykge1xuXHRcdFx0Ly8gdGhvdXMgc2hvdWxkIHJlYWxseSBiZSBoYW5kbGVkIGJ5IHRoZSBhc3QgaW5zdGVhZFxuXHRcdFx0dHlwID0gJ0NPTlNUJztcblx0XHR9IGVsc2UgaWYgKGlkID09ICdlbGlmJykge1xuXHRcdFx0dGhpcy50b2tlbignRUxTRScsJ2VsaWYnLGlkLmxlbmd0aCk7XG5cdFx0XHR0aGlzLnRva2VuKCdJRicsJ2lmJyk7XG5cdFx0XHRyZXR1cm4gaWQubGVuZ3RoO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0eXAgPSAnSURFTlRJRklFUic7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHRcblx0XHQvLyB0aGlzIGNhdGNoZXMgYWxsIFxuXHRcdGlmICghZm9yY2VkSWRlbnRpZmllciAmJiAoaXNLZXl3b3JkID0gdGhpcy5pc0tleXdvcmQoaWQpKSkge1xuXHRcdFx0Ly8gKGlkIGluIEpTX0tFWVdPUkRTIG9yIGlkIGluIElNQkFfS0VZV09SRFMpXG5cdFx0XHR0eXAgPSBpZC50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0YWRkTG9jID0gdHJ1ZTtcblx0XHRcdFxuXHRcdFx0Ly8gY2x1bXN5IC0gYnV0IHRlc3RpbmcgcGVyZm9ybWFuY2Vcblx0XHRcdGlmICh0eXAgPT0gJ1lFUycpIHtcblx0XHRcdFx0dHlwID0gJ1RSVUUnO1xuXHRcdFx0fSBlbHNlIGlmICh0eXAgPT0gJ05PJykge1xuXHRcdFx0XHR0eXAgPSAnRkFMU0UnO1xuXHRcdFx0fSBlbHNlIGlmICh0eXAgPT0gJ05JTCcpIHtcblx0XHRcdFx0dHlwID0gJ05VTEwnO1xuXHRcdFx0fSBlbHNlIGlmICh0eXAgPT0gJ1ZBUicpIHtcblx0XHRcdFx0aWYgKHRoaXMuX2xhc3RWYWwgPT0gJ2V4cG9ydCcpIHtcblx0XHRcdFx0XHR0VHMocHJldiwnRVhQT1JUJyk7XG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2UgaWYgKHR5cCA9PSAnSUYnIHx8IHR5cCA9PSAnRUxTRScgfHwgdHlwID09ICdUUlVFJyB8fCB0eXAgPT0gJ0ZBTFNFJyB8fCB0eXAgPT0gJ05VTEwnKSB7XG5cdFx0XHRcdHRydWU7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cCA9PSAnVEFHJykge1xuXHRcdFx0XHR0aGlzLnB1c2hFbmQoJ1RBRycpO1xuXHRcdFx0XHQvLyBAZW5kcy5wdXNoKCdUQUcnKVxuXHRcdFx0fSBlbHNlIGlmICh0eXAgPT0gJ0RFRicpIHtcblx0XHRcdFx0Ly8gc2hvdWxkIHByb2JhYmx5IHNoaWZ0IGNvbnRleHQgYW5kIG9wdGltaXplIHRoaXNcblx0XHRcdFx0dGhpcy5vcGVuRGVmKCk7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cCA9PSAnRE8nKSB7XG5cdFx0XHRcdGlmICh0aGlzLmNvbnRleHQoKSA9PSAnREVGJykgdGhpcy5jbG9zZURlZigpO1xuXHRcdFx0fSBlbHNlIGlmICh0eXAgPT0gJ1dIRU4nICYmIExJTkVfQlJFQUsuaW5kZXhPZih0aGlzLmxhc3RUb2tlblR5cGUoKSkgPj0gMCkge1xuXHRcdFx0XHR0eXAgPSAnTEVBRElOR19XSEVOJztcblx0XHRcdH0gZWxzZSBpZiAodHlwID09ICdGT1InKSB7XG5cdFx0XHRcdHRoaXMuX3NlZW5Gb3IgPSB0cnVlO1xuXHRcdFx0fSBlbHNlIGlmICh0eXAgPT0gJ1VOTEVTUycpIHtcblx0XHRcdFx0dHlwID0gJ0lGJzsgLy8gV0FSTlxuXHRcdFx0fSBlbHNlIGlmIChVTkFSWS5pbmRleE9mKHR5cCkgPj0gMCkge1xuXHRcdFx0XHR0eXAgPSAnVU5BUlknO1xuXHRcdFx0fSBlbHNlIGlmIChSRUxBVElPTi5pbmRleE9mKHR5cCkgPj0gMCkge1xuXHRcdFx0XHRpZiAodHlwICE9ICdJTlNUQU5DRU9GJyAmJiB0eXAgIT0gJ0lTQScgJiYgdGhpcy5fc2VlbkZvcikge1xuXHRcdFx0XHRcdHR5cCA9ICdGT1InICsgdHlwOyAvLyA/XG5cdFx0XHRcdFx0dGhpcy5fc2VlbkZvciA9IGZhbHNlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHR5cCA9ICdSRUxBVElPTic7XG5cdFx0XHRcdFx0aWYgKFN0cmluZyh0aGlzLnZhbHVlKCkpID09ICchJykge1xuXHRcdFx0XHRcdFx0dGhpcy5fdG9rZW5zLnBvcCgpOyAvLyBpcyBmdWNrZWQgdXA/PyFcblx0XHRcdFx0XHRcdC8vIFdBUk4gd2UgbmVlZCB0byBrZWVwIHRoZSBsb2MsIG5vP1xuXHRcdFx0XHRcdFx0aWQgPSAnIScgKyBpZDtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmIChpZCA9PSAnc3VwZXInKSB7XG5cdFx0XHR0eXAgPSAnU1VQRVInO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gZG8gd2UgcmVhbGx5IHdhbnQgdG8gY2hlY2sgdGhpcyBoZXJlXG5cdFx0aWYgKCFmb3JjZWRJZGVudGlmaWVyKSB7XG5cdFx0XHQvLyBzaG91bGQgYWxyZWFkeSBoYXZlIGRlYWx0IHdpdGggdGhpc1xuXHRcdFx0XG5cdFx0XHRpZiAoaXNLZXl3b3JkICYmIElNQkFfQUxJQVNFUy5pbmRleE9mKGlkKSA+PSAwKSB7IGlkID0gSU1CQV9BTElBU19NQVBbaWRdIH07XG5cdFx0XHQvLyB0aGVzZSByZWFsbHkgc2hvdWxkIG5vdCBnbyBoZXJlPyE/XG5cdFx0XHRzd2l0Y2ggKGlkKSB7XG5cdFx0XHRcdGNhc2UgJyEnOlxuXHRcdFx0XHRcdHR5cCA9ICdVTkFSWSc7YnJlYWs7XG5cdFx0XHRcdFxuXHRcdFx0XHRjYXNlICc9PSc6XG5cdFx0XHRcdGNhc2UgJyE9Jzpcblx0XHRcdFx0Y2FzZSAnPT09Jzpcblx0XHRcdFx0Y2FzZSAnIT09Jzpcblx0XHRcdFx0XHR0eXAgPSAnQ09NUEFSRSc7YnJlYWs7XG5cdFx0XHRcdFxuXHRcdFx0XHRjYXNlICcmJic6XG5cdFx0XHRcdGNhc2UgJ3x8Jzpcblx0XHRcdFx0XHR0eXAgPSAnTE9HSUMnO2JyZWFrO1xuXHRcdFx0XHRcblx0XHRcdFx0Y2FzZSAnYnJlYWsnOlxuXHRcdFx0XHRjYXNlICdjb250aW51ZSc6XG5cdFx0XHRcdGNhc2UgJ2RlYnVnZ2VyJzpcblx0XHRcdFx0Y2FzZSAnYXJndW1lbnRzJzpcblx0XHRcdFx0XHR0eXAgPSBpZC50b1VwcGVyQ2FzZSgpO2JyZWFrO1xuXHRcdFx0XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gcHJldiA9IGxhc3QgQHRva2Vuc1xuXHRcdHZhciBsZW4gPSBpbnB1dC5sZW5ndGg7XG5cdFx0XG5cdFx0Ly8gc2hvdWxkIGJlIHN0cmljdCBhYm91dCB0aGUgb3JkZXIsIGNoZWNrIHRoaXMgbWFudWFsbHkgaW5zdGVhZFxuXHRcdGlmICh0eXAgPT0gJ0NMQVNTJyB8fCB0eXAgPT0gJ0RFRicgfHwgdHlwID09ICdUQUcnKSB7XG5cdFx0XHR0aGlzLnF1ZXVlU2NvcGUodHlwKTtcblx0XHRcdFxuXHRcdFx0dmFyIGkgPSB0aGlzLl90b2tlbnMubGVuZ3RoO1xuXHRcdFx0XG5cdFx0XHR3aGlsZSAoaSl7XG5cdFx0XHRcdHByZXYgPSB0aGlzLl90b2tlbnNbLS1pXTtcblx0XHRcdFx0dmFyIGN0cmwgPSBcIlwiICsgdFYocHJldik7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwiY3RybCBpcyB7Y3RybH1cIilcblx0XHRcdFx0Ly8gbmVlZCB0byBjb2VyY2UgdG8gc3RyaW5nIGJlY2F1c2Ugb2Ygc3R1cGlkIENTID09PVxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcInByZXYgaXNcIixwcmV2WzBdLHByZXZbMV0pXG5cdFx0XHRcdGlmIChpZHgkKGN0cmwsSU1CQV9DT05URVhUVUFMX0tFWVdPUkRTKSA+PSAwKSB7XG5cdFx0XHRcdFx0dFRzKHByZXYsY3RybC50b1VwcGVyQ2FzZSgpKTtcblx0XHRcdFx0XHQvLyBwcmV2WzBdID0gY3RybC50b1VwcGVyQ2FzZSAjIEZJWFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHR9IGVsc2UgaWYgKHR5cCA9PSAnSUYnKSB7XG5cdFx0XHR0aGlzLnF1ZXVlU2NvcGUodHlwKTtcblx0XHR9IGVsc2UgaWYgKHR5cCA9PSAnSU1QT1JUJykge1xuXHRcdFx0Ly8gY291bGQgbWFudWFsbHkgcGFyc2UgdGhlIHdob2xlIHRpbmcgaGVyZT9cblx0XHRcdHRoaXMucHVzaEVuZCgnSU1QT1JUJyk7XG5cdFx0XHQvLyBAZW5kcy5wdXNoICdJTVBPUlQnXG5cdFx0fSBlbHNlIGlmIChpZCA9PSAnZnJvbScgJiYgY3R4MCA9PSAnSU1QT1JUJykge1xuXHRcdFx0dHlwID0gJ0ZST00nO1xuXHRcdFx0dGhpcy5wYWlyKCdJTVBPUlQnKTtcblx0XHR9IGVsc2UgaWYgKGlkID09ICdhcycgJiYgY3R4MCA9PSAnSU1QT1JUJykge1xuXHRcdFx0dHlwID0gJ0FTJztcblx0XHRcdHRoaXMucGFpcignSU1QT1JUJyk7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAodHlwID09ICdJREVOVElGSUVSJykge1xuXHRcdFx0Ly8gc2VlIGlmIHByZXZpb3VzIHdhcyBjYXRjaCAtLSBiZWxvbmdzIGluIHJld3JpdGVyP1xuXHRcdFx0aWYgKGxhc3RUeXAgPT0gJ0NBVENIJykge1xuXHRcdFx0XHR0eXAgPSAnQ0FUQ0hfVkFSJztcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoY29sb24pIHtcblx0XHRcdHRoaXMudG9rZW4odHlwLGlkLGlkbGVuKTtcblx0XHRcdHRoaXMubW92ZUNhcmV0KGlkbGVuKTtcblx0XHRcdC8vIGNvbnNvbGUubG9nIFwiYWRkIGNvbG9uP1wiXG5cdFx0XHR0aGlzLnRva2VuKCc6JywnOicsY29sb24ubGVuZ3RoKTtcblx0XHRcdHRoaXMubW92ZUNhcmV0KC1pZGxlbik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMudG9rZW4odHlwLGlkLGlkbGVuKTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiBsZW47XG5cdH07XG5cdFxuXHQvLyBNYXRjaGVzIG51bWJlcnMsIGluY2x1ZGluZyBkZWNpbWFscywgaGV4LCBhbmQgZXhwb25lbnRpYWwgbm90YXRpb24uXG5cdC8vIEJlIGNhcmVmdWwgbm90IHRvIGludGVyZmVyZSB3aXRoIHJhbmdlcy1pbi1wcm9ncmVzcy5cblx0TGV4ZXIucHJvdG90eXBlLm51bWJlclRva2VuID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIGJpbmFyeUxpdGVyYWw7XG5cdFx0dmFyIG1hdGNoLG51bWJlcixsZXhlZExlbmd0aDtcblx0XHRcblx0XHRpZiAoIShtYXRjaCA9IE5VTUJFUi5leGVjKHRoaXMuX2NodW5rKSkpIHsgcmV0dXJuIDAgfTtcblx0XHRcblx0XHRudW1iZXIgPSBtYXRjaFswXTtcblx0XHRsZXhlZExlbmd0aCA9IG51bWJlci5sZW5ndGg7XG5cdFx0XG5cdFx0aWYgKGJpbmFyeUxpdGVyYWwgPSAvMGIoWzAxXSspLy5leGVjKG51bWJlcikpIHtcblx0XHRcdFxuXHRcdFx0bnVtYmVyID0gXCJcIiArIHBhcnNlSW50KGJpbmFyeUxpdGVyYWxbMV0sMik7XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgcHJldiA9IGxhc3QodGhpcy5fdG9rZW5zKTtcblx0XHRcblx0XHRpZiAobWF0Y2hbMF1bMF0gPT0gJy4nICYmIHByZXYgJiYgIXByZXYuc3BhY2VkICYmIFsnSURFTlRJRklFUicsJyknLCd9JywnXScsJ05VTUJFUiddLmluZGV4T2YodFQocHJldikpID49IDApIHtcblx0XHRcdC8vIGNvbnNvbGUubG9nIFwiZ290IGhlcmVcIlxuXHRcdFx0dGhpcy50b2tlbihcIi5cIixcIi5cIik7XG5cdFx0XHRudW1iZXIgPSBudW1iZXIuc3Vic3RyKDEpO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0dGhpcy50b2tlbignTlVNQkVSJyxudW1iZXIsbGV4ZWRMZW5ndGgpO1xuXHRcdHJldHVybiBsZXhlZExlbmd0aDtcblx0fTtcblx0XG5cdExleGVyLnByb3RvdHlwZS5zeW1ib2xUb2tlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBtYXRjaCxzeW1ib2wscHJldjtcblx0XHRcblx0XHRpZiAoIShtYXRjaCA9IFNZTUJPTC5leGVjKHRoaXMuX2NodW5rKSkpIHsgcmV0dXJuIDAgfTtcblx0XHRzeW1ib2wgPSBtYXRjaFswXS5zdWJzdHIoMSk7XG5cdFx0cHJldiA9IGxhc3QodGhpcy5fdG9rZW5zKTtcblx0XHRcblx0XHQvLyBpcyB0aGlzIGEgcHJvcGVydHktYWNjZXNzP1xuXHRcdC8vIHNob3VsZCBpbnZlcnQgdGhpcyAtLSBvbmx5IGFsbG93IHdoZW4gcHJldiBJUyAuLiBcblx0XHRcblx0XHQvLyA6IHNob3VsZCBiZSBhIHRva2VuIGl0c2VsZiwgd2l0aCBhIHNwZWNpZmljYXRpb24gb2Ygc3BhY2luZyAoTFIsUixMLE5PTkUpXG5cdFx0XG5cdFx0Ly8gRklYXG5cdFx0aWYgKHByZXYgJiYgIXByZXYuc3BhY2VkICYmIGlkeCQodFQocHJldiksWycoJywneycsJ1snLCcuJywnQ0FMTF9TVEFSVCcsJ0lOREVYX1NUQVJUJywnLCcsJz0nLCdJTkRFTlQnLCdURVJNSU5BVE9SJ10pID09IC0xKSB7XG5cdFx0XHR0aGlzLnRva2VuKCcuOicsJzonLDEpO1xuXHRcdFx0dmFyIHN5bSA9IHN5bWJvbC5zcGxpdCgvW1xcOlxcXFxcXC9dLylbMF07IC8vIHJlYWxseT9cblx0XHRcdC8vIHRva2VuICdTWU1CT0wnLCBcIicje3N5bWJvbH0nXCJcblx0XHRcdHRoaXMudG9rZW4oJ0lERU5USUZJRVInLHN5bSxzeW0ubGVuZ3RoLDEpO1xuXHRcdFx0cmV0dXJuIChzeW0ubGVuZ3RoICsgMSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHRva2VuICdTWU1CT0wnLCBcIicje3N5bWJvbH0nXCJcblx0XHRcdHRoaXMudG9rZW4oJ1NZTUJPTCcsc3ltYm9sLG1hdGNoWzBdLmxlbmd0aCk7XG5cdFx0XHRyZXR1cm4gbWF0Y2hbMF0ubGVuZ3RoO1xuXHRcdH07XG5cdH07XG5cdFxuXHRMZXhlci5wcm90b3R5cGUuZXNjYXBlU3RyID0gZnVuY3Rpb24gKHN0cixoZXJlZG9jLHEpe1xuXHRcdHN0ciA9IHN0ci5yZXBsYWNlKE1VTFRJTElORVIsKGhlcmVkb2MgPyAoJ1xcXFxuJykgOiAoJycpKSk7XG5cdFx0aWYgKHEpIHtcblx0XHRcdHZhciByID0gUmVnRXhwKChcIlxcXFxcXFxcW1wiICsgcSArIFwiXVwiKSxcImdcIik7XG5cdFx0XHRzdHIgPSBzdHIucmVwbGFjZShyLHEpO1xuXHRcdFx0c3RyID0gc3RyLnJlcGxhY2UoUmVnRXhwKChcIlwiICsgcSksXCJnXCIpLCdcXFxcJCYnKTtcblx0XHR9O1xuXHRcdHJldHVybiBzdHI7XG5cdFx0XG5cdFx0Ly8gc3RyID0gc3RyLnJlcGxhY2UoTVVMVElMSU5FUiwgJ1xcXFxuJylcblx0XHQvLyBzdHIgPSBzdHIucmVwbGFjZSgvXFx0L2csICdcXFxcdCcpXG5cdH07XG5cdC8vIE1hdGNoZXMgc3RyaW5ncywgaW5jbHVkaW5nIG11bHRpLWxpbmUgc3RyaW5ncy4gRW5zdXJlcyB0aGF0IHF1b3RhdGlvbiBtYXJrc1xuXHQvLyBhcmUgYmFsYW5jZWQgd2l0aGluIHRoZSBzdHJpbmcncyBjb250ZW50cywgYW5kIHdpdGhpbiBuZXN0ZWQgaW50ZXJwb2xhdGlvbnMuXG5cdExleGVyLnByb3RvdHlwZS5zdHJpbmdUb2tlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBtYXRjaCxzdHJpbmc7XG5cdFx0XG5cdFx0c3dpdGNoICh0aGlzLl9jaHVuay5jaGFyQXQoMCkpIHtcblx0XHRcdGNhc2UgXCInXCI6XG5cdFx0XHRcdGlmICghKG1hdGNoID0gU0lNUExFU1RSLmV4ZWModGhpcy5fY2h1bmspKSkgeyByZXR1cm4gMCB9O1xuXHRcdFx0XHRzdHJpbmcgPSBtYXRjaFswXTtcblx0XHRcdFx0dGhpcy50b2tlbignU1RSSU5HJyx0aGlzLmVzY2FwZVN0cihzdHJpbmcpLHN0cmluZy5sZW5ndGgpO1xuXHRcdFx0XHQvLyB0b2tlbiAnU1RSSU5HJywgKHN0cmluZyA9IG1hdGNoWzBdKS5yZXBsYWNlKE1VTFRJTElORVIsICdcXFxcXFxuJyksIHN0cmluZzpsZW5ndGhcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcblx0XHRcdGNhc2UgJ1wiJzpcblx0XHRcdFx0aWYgKCEoc3RyaW5nID0gdGhpcy5iYWxhbmNlZFN0cmluZyh0aGlzLl9jaHVuaywnXCInKSkpIHsgcmV0dXJuIDAgfTtcblx0XHRcdFx0Ly8gd2hhdCBhYm91dCB0cmlwZSBxdW90ZWQgc3RyaW5ncz9cblx0XHRcdFx0XG5cdFx0XHRcdGlmIChzdHJpbmcuaW5kZXhPZigneycpID49IDApIHtcblx0XHRcdFx0XHR2YXIgbGVuID0gc3RyaW5nLmxlbmd0aDtcblx0XHRcdFx0XHQvLyBpZiB0aGlzIGhhcyBubyBpbnRlcnBvbGF0aW9uP1xuXHRcdFx0XHRcdC8vIHdlIGFyZSBub3cgbWVzc2luZyB3aXRoIGxvY2F0aW9ucyAtIGJld2FyZVxuXHRcdFx0XHRcdHRoaXMudG9rZW4oJ1NUUklOR19TVEFSVCcsc3RyaW5nLmNoYXJBdCgwKSwxKTtcblx0XHRcdFx0XHR0aGlzLmludGVycG9sYXRlU3RyaW5nKHN0cmluZy5zbGljZSgxLC0xKSk7XG5cdFx0XHRcdFx0dGhpcy50b2tlbignU1RSSU5HX0VORCcsc3RyaW5nLmNoYXJBdChsZW4gLSAxKSwxLHN0cmluZy5sZW5ndGggLSAxKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsZW4gPSBzdHJpbmcubGVuZ3RoO1xuXHRcdFx0XHRcdC8vIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKE1VTFRJTElORVIsICdcXFxcXFxuJylcblx0XHRcdFx0XHR0aGlzLnRva2VuKCdTVFJJTkcnLHRoaXMuZXNjYXBlU3RyKHN0cmluZyksbGVuKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XG5cdFx0fTtcblx0XHRcblx0XHR0aGlzLm1vdmVIZWFkKHN0cmluZyk7XG5cdFx0cmV0dXJuIHN0cmluZy5sZW5ndGg7XG5cdH07XG5cdFxuXHQvLyBNYXRjaGVzIGhlcmVkb2NzLCBhZGp1c3RpbmcgaW5kZW50YXRpb24gdG8gdGhlIGNvcnJlY3QgbGV2ZWwsIGFzIGhlcmVkb2NzXG5cdC8vIHByZXNlcnZlIHdoaXRlc3BhY2UsIGJ1dCBpZ25vcmUgaW5kZW50YXRpb24gdG8gdGhlIGxlZnQuXG5cdExleGVyLnByb3RvdHlwZS5oZXJlZG9jVG9rZW4gPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgbWF0Y2gsaGVyZWRvYyxxdW90ZSxkb2M7XG5cdFx0XG5cdFx0aWYgKCEobWF0Y2ggPSBIRVJFRE9DLmV4ZWModGhpcy5fY2h1bmspKSkgeyByZXR1cm4gMCB9O1xuXHRcdFxuXHRcdGhlcmVkb2MgPSBtYXRjaFswXTtcblx0XHRxdW90ZSA9IGhlcmVkb2MuY2hhckF0KDApO1xuXHRcdGRvYyA9IHRoaXMuc2FuaXRpemVIZXJlZG9jKG1hdGNoWzJdLHtxdW90ZTogcXVvdGUsaW5kZW50OiBudWxsfSk7XG5cdFx0Ly8gY29uc29sZS5sb2cgXCJmb3VuZCBoZXJlZG9jIHttYXRjaFswXTpsZW5ndGh9IHtkb2M6bGVuZ3RofVwiXG5cdFx0XG5cdFx0aWYgKHF1b3RlID09ICdcIicgJiYgZG9jLmluZGV4T2YoJ3snKSA+PSAwKSB7XG5cdFx0XHR2YXIgb3BlbiA9IG1hdGNoWzFdO1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgZG9jLnN1YnN0cigwLDMpLG1hdGNoWzFdXG5cdFx0XHR0aGlzLnRva2VuKCdTVFJJTkdfU1RBUlQnLG9wZW4sb3Blbi5sZW5ndGgpO1xuXHRcdFx0dGhpcy5pbnRlcnBvbGF0ZVN0cmluZyhkb2Mse2hlcmVkb2M6IHRydWUsb2Zmc2V0OiBvcGVuLmxlbmd0aCxxdW90ZTogcXVvdGV9KTtcblx0XHRcdHRoaXMudG9rZW4oJ1NUUklOR19FTkQnLG9wZW4sb3Blbi5sZW5ndGgsaGVyZWRvYy5sZW5ndGggLSBvcGVuLmxlbmd0aCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMudG9rZW4oJ1NUUklORycsdGhpcy5tYWtlU3RyaW5nKGRvYyxxdW90ZSx0cnVlKSwwKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRoaXMubW92ZUhlYWQoaGVyZWRvYyk7XG5cdFx0cmV0dXJuIGhlcmVkb2MubGVuZ3RoO1xuXHR9O1xuXHRcblx0Ly8gTWF0Y2hlcyBhbmQgY29uc3VtZXMgY29tbWVudHMuXG5cdExleGVyLnByb3RvdHlwZS5jb21tZW50VG9rZW4gPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgbWF0Y2gsbGVuZ3RoLGNvbW1lbnQsaW5kZW50LHByZXY7XG5cdFx0XG5cdFx0dmFyIHR5cCA9ICdIRVJFQ09NTUVOVCc7XG5cdFx0XG5cdFx0aWYgKG1hdGNoID0gSU5MSU5FX0NPTU1FTlQuZXhlYyh0aGlzLl9jaHVuaykpIHsgLy8gLm1hdGNoKElOTElORV9DT01NRU5UKVxuXHRcdFx0Ly8gY29uc29sZS5sb2cgXCJtYXRjaCBpbmxpbmUgY29tbWVudFwiXG5cdFx0XHRsZW5ndGggPSBtYXRjaFswXS5sZW5ndGg7XG5cdFx0XHRpbmRlbnQgPSBtYXRjaFsxXTtcblx0XHRcdGNvbW1lbnQgPSBtYXRjaFsyXTtcblx0XHRcdFxuXHRcdFx0cHJldiA9IGxhc3QodGhpcy5fdG9rZW5zKTtcblx0XHRcdHZhciBwdCA9IHByZXYgJiYgdFQocHJldik7XG5cdFx0XHR2YXIgbm90ZSA9ICcvLycgKyBjb21tZW50LnN1YnN0cigxKTtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuX2xhc3QgJiYgdGhpcy5fbGFzdC5zcGFjZWQpIHtcblx0XHRcdFx0bm90ZSA9ICcgJyArIG5vdGU7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nIFwidGhlIHByZXZpb3VzIG5vZGUgd2FzIFNQQUNFRFwiXG5cdFx0XHR9O1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgXCJjb21tZW50IHtub3RlfSAtIGluZGVudCh7aW5kZW50fSkgLSB7bGVuZ3RofSB7Y29tbWVudDpsZW5ndGh9XCJcblx0XHRcdFxuXHRcdFx0aWYgKChwdCAmJiBwdCAhPSAnSU5ERU5UJyAmJiBwdCAhPSAnVEVSTUlOQVRPUicpIHx8ICFwdCkge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyBcInNraXAgY29tbWVudFwiXG5cdFx0XHRcdC8vIHRva2VuICdJTkxJTkVDT01NRU5UJywgY29tbWVudC5zdWJzdHIoMilcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgXCJhZGRpbmcgYXMgdGVybWluYXRvclwiXG5cdFx0XHRcdHRoaXMudG9rZW4oJ1RFUk1JTkFUT1InLG5vdGUsbGVuZ3RoKTsgLy8gKyAnXFxuJ1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgXCJhZGQgY29tbWVudCAoe25vdGV9KVwiXG5cdFx0XHRcdGlmIChwdCA9PSAnVEVSTUlOQVRPUicpIHtcblx0XHRcdFx0XHR0VnMocHJldix0VihwcmV2KSArIG5vdGUpO1xuXHRcdFx0XHRcdC8vIHByZXZbMV0gKz0gbm90ZVxuXHRcdFx0XHR9IGVsc2UgaWYgKHB0ID09ICdJTkRFTlQnKSB7XG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2cgXCJhZGRpbmcgY29tbWVudCB0byBJTkRFTlQ6IHtub3RlfVwiICMgd2h5IG5vdCBhZGQgZGlyZWN0bHkgaGVyZT9cblx0XHRcdFx0XHR0aGlzLmFkZExpbmVicmVha3MoMSxub3RlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyBcImNvbW1lbnQgaGVyZVwiXG5cdFx0XHRcdFx0Ly8gc2hvdWxkIHdlIGV2ZXIgZ2V0IGhlcmU/XG5cdFx0XHRcdFx0dGhpcy50b2tlbih0eXAsY29tbWVudC5zdWJzdHIoMiksbGVuZ3RoKTsgLy8gYXJlIHdlIHN1cmU/XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gbGVuZ3RoOyAvLyBkaXNhYmxlIG5vdyB3aGlsZSBjb21waWxpbmdcblx0XHR9O1xuXHRcdFxuXHRcdC8vIHNob3VsZCB1c2UgZXhlYz9cblx0XHRpZiAoIShtYXRjaCA9IENPTU1FTlQuZXhlYyh0aGlzLl9jaHVuaykpKSB7IHJldHVybiAwIH07XG5cdFx0XG5cdFx0Y29tbWVudCA9IG1hdGNoWzBdO1xuXHRcdHZhciBoZXJlID0gbWF0Y2hbMV07XG5cdFx0XG5cdFx0aWYgKGhlcmUpIHtcblx0XHRcdHRoaXMudG9rZW4oJ0hFUkVDT01NRU5UJyx0aGlzLnNhbml0aXplSGVyZWRvYyhoZXJlLHtoZXJlY29tbWVudDogdHJ1ZSxpbmRlbnQ6IEFycmF5KHRoaXMuX2luZGVudCArIDEpLmpvaW4oJyAnKX0pLGNvbW1lbnQubGVuZ3RoKTtcblx0XHRcdHRoaXMudG9rZW4oJ1RFUk1JTkFUT1InLCdcXG4nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy50b2tlbignSEVSRUNPTU1FTlQnLGNvbW1lbnQsY29tbWVudC5sZW5ndGgpO1xuXHRcdFx0dGhpcy50b2tlbignVEVSTUlOQVRPUicsJ1xcbicpOyAvLyBhdXRvPyByZWFsbHk/XG5cdFx0fTtcblx0XHRcblx0XHR0aGlzLm1vdmVIZWFkKGNvbW1lbnQpO1xuXHRcdHJldHVybiBjb21tZW50Lmxlbmd0aDtcblx0fTtcblx0XG5cdC8vIE1hdGNoZXMgSmF2YVNjcmlwdCBpbnRlcnBvbGF0ZWQgZGlyZWN0bHkgaW50byB0aGUgc291cmNlIHZpYSBiYWNrdGlja3MuXG5cdExleGVyLnByb3RvdHlwZS5qc1Rva2VuID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIG1hdGNoLHNjcmlwdDtcblx0XHRcblx0XHRpZiAoISh0aGlzLl9jaHVuay5jaGFyQXQoMCkgPT0gJ2AnICYmIChtYXRjaCA9IEpTVE9LRU4uZXhlYyh0aGlzLl9jaHVuaykpKSkgeyByZXR1cm4gMCB9O1xuXHRcdHRoaXMudG9rZW4oJ0pTJywoc2NyaXB0ID0gbWF0Y2hbMF0pLnNsaWNlKDEsLTEpKTtcblx0XHRyZXR1cm4gc2NyaXB0Lmxlbmd0aDtcblx0fTtcblx0XG5cdC8vIE1hdGNoZXMgcmVndWxhciBleHByZXNzaW9uIGxpdGVyYWxzLiBMZXhpbmcgcmVndWxhciBleHByZXNzaW9ucyBpcyBkaWZmaWN1bHRcblx0Ly8gdG8gZGlzdGluZ3Vpc2ggZnJvbSBkaXZpc2lvbiwgc28gd2UgYm9ycm93IHNvbWUgYmFzaWMgaGV1cmlzdGljcyBmcm9tXG5cdC8vIEphdmFTY3JpcHQgYW5kIFJ1YnkuXG5cdExleGVyLnByb3RvdHlwZS5yZWdleFRva2VuID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIGFyeTtcblx0XHR2YXIgbWF0Y2gsbGVuZ3RoLHByZXY7XG5cdFx0XG5cdFx0aWYgKHRoaXMuX2NodW5rLmNoYXJBdCgwKSAhPSAnLycpIHsgcmV0dXJuIDAgfTtcblx0XHRpZiAobWF0Y2ggPSBIRVJFR0VYLmV4ZWModGhpcy5fY2h1bmspKSB7XG5cdFx0XHRsZW5ndGggPSB0aGlzLmhlcmVnZXhUb2tlbihtYXRjaCk7XG5cdFx0XHR0aGlzLm1vdmVIZWFkKG1hdGNoWzBdKTtcblx0XHRcdHJldHVybiBsZW5ndGg7XG5cdFx0fTtcblx0XHRcblx0XHRwcmV2ID0gbGFzdCh0aGlzLl90b2tlbnMpO1xuXHRcdC8vIEZJWFxuXHRcdGlmIChwcmV2ICYmIChpZHgkKHRUKHByZXYpLChwcmV2LnNwYWNlZCA/IChcblx0XHRcdE5PVF9SRUdFWFxuXHRcdCkgOiAoXG5cdFx0XHROT1RfU1BBQ0VEX1JFR0VYXG5cdFx0KSkpID49IDApKSB7IHJldHVybiAwIH07XG5cdFx0aWYgKCEobWF0Y2ggPSBSRUdFWC5leGVjKHRoaXMuX2NodW5rKSkpIHsgcmV0dXJuIDAgfTtcblx0XHR2YXIgYXJ5ID0gaXRlciQobWF0Y2gpO3ZhciBtID0gYXJ5WzBdLHJlZ2V4ID0gYXJ5WzFdLGZsYWdzID0gYXJ5WzJdO1xuXHRcdFxuXHRcdC8vIEZJWE1FXG5cdFx0Ly8gaWYgcmVnZXhbLi4xXSBpcyAnLyonXG5cdFx0Ly9cdGVycm9yICdyZWd1bGFyIGV4cHJlc3Npb25zIGNhbm5vdCBiZWdpbiB3aXRoIGAqYCdcblx0XHRcblx0XHRpZiAocmVnZXggPT0gJy8vJykge1xuXHRcdFx0cmVnZXggPSAnLyg/OikvJztcblx0XHR9O1xuXHRcdFxuXHRcdHRoaXMudG9rZW4oJ1JFR0VYJywoXCJcIiArIHJlZ2V4ICsgZmxhZ3MpLG0ubGVuZ3RoKTtcblx0XHRyZXR1cm4gbS5sZW5ndGg7XG5cdH07XG5cdFxuXHQvLyBNYXRjaGVzIG11bHRpbGluZSBleHRlbmRlZCByZWd1bGFyIGV4cHJlc3Npb25zLlxuXHQvLyBUaGUgZXNjYXBpbmcgc2hvdWxkIHJhdGhlciBoYXBwZW4gaW4gQVNUIC0gcG9zc2libHkgYXMgYW4gYWRkaXRpb25hbCBmbGFnP1xuXHRMZXhlci5wcm90b3R5cGUuaGVyZWdleFRva2VuID0gZnVuY3Rpb24gKG1hdGNoKXtcblx0XHR2YXIgYXJ5O1xuXHRcdHZhciBhcnkgPSBpdGVyJChtYXRjaCk7dmFyIGhlcmVnZXggPSBhcnlbMF0sYm9keSA9IGFyeVsxXSxmbGFncyA9IGFyeVsyXTtcblx0XHRcblx0XHRpZiAoMCA+IGJvZHkuaW5kZXhPZignI3snKSkge1xuXHRcdFx0XG5cdFx0XHR2YXIgcmUgPSBib2R5LnJlcGxhY2UoSEVSRUdFWF9PTUlULCcnKS5yZXBsYWNlKC9cXC8vZywnXFxcXC8nKTtcblx0XHRcdFxuXHRcdFx0aWYgKHJlLm1hdGNoKC9eXFwqLykpIHtcblx0XHRcdFx0dGhpcy5lcnJvcigncmVndWxhciBleHByZXNzaW9ucyBjYW5ub3QgYmVnaW4gd2l0aCBgKmAnKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHRoaXMudG9rZW4oJ1JFR0VYJywoXCIvXCIgKyAocmUgfHwgJyg/OiknKSArIFwiL1wiICsgZmxhZ3MpLGhlcmVnZXgubGVuZ3RoKTtcblx0XHRcdHJldHVybiBoZXJlZ2V4Lmxlbmd0aDtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIHVzZSBtb3JlIGJhc2ljIHJlZ2V4IHR5cGVcblx0XHRcblx0XHR0aGlzLnRva2VuKCdDT05TVCcsJ1JlZ0V4cCcpO1xuXHRcdHRoaXMuX3Rva2Vucy5wdXNoKFQudG9rZW4oJ0NBTExfU1RBUlQnLCcoJywwKSk7XG5cdFx0dmFyIHRva2VucyA9IFtdO1xuXHRcdFxuXHRcdGZvciAodmFyIGkgPSAwLCBpdGVtcyA9IGl0ZXIkKHRoaXMuaW50ZXJwb2xhdGVTdHJpbmcoYm9keSx7cmVnZXg6IHRydWV9KSksIGxlbiA9IGl0ZW1zLmxlbmd0aCwgcGFpcjsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcblx0XHRcdHBhaXIgPSBpdGVtc1tpXTtcblx0XHRcdHZhciB0b2sgPSB0VChwYWlyKTsgLy8gRklYXG5cdFx0XHR2YXIgdmFsdWUgPSB0VihwYWlyKTsgLy8gRklYXG5cdFx0XHRcblx0XHRcdGlmICh0b2sgPT0gJ1RPS0VOUycpIHtcblx0XHRcdFx0Ly8gRklYTUUgd2hhdCBpcyB0aGlzP1xuXHRcdFx0XHR0b2tlbnMucHVzaC5hcHBseSh0b2tlbnMsdmFsdWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCF2YWx1ZSkge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKFwid2hhdD8/XCIpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKCEodmFsdWUgPSB2YWx1ZS5yZXBsYWNlKEhFUkVHRVhfT01JVCwnJykpKSB7IGNvbnRpbnVlOyB9O1xuXHRcdFx0XHRcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFxcL2csJ1xcXFxcXFxcJyk7XG5cdFx0XHRcdHRva2Vucy5wdXNoKFQudG9rZW4oJ1NUUklORycsdGhpcy5tYWtlU3RyaW5nKHZhbHVlLCdcIicsdHJ1ZSksMCkpOyAvLyBGSVhcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHRva2Vucy5wdXNoKFQudG9rZW4oJysnLCcrJywwKSk7IC8vIEZJWFxuXHRcdH07XG5cdFx0XG5cdFx0dG9rZW5zLnBvcCgpO1xuXHRcdFxuXHRcdC8vIEZJWFxuXHRcdGlmICghKHRva2Vuc1swXSAmJiB0VCh0b2tlbnNbMF0pID09ICdTVFJJTkcnKSkge1xuXHRcdFx0Ly8gRklYXG5cdFx0XHR0aGlzLl90b2tlbnMucHVzaChULnRva2VuKCdTVFJJTkcnLCdcIlwiJyksVC50b2tlbignKycsJysnKSk7XG5cdFx0fTtcblx0XHRcblx0XHR0aGlzLl90b2tlbnMucHVzaC5hcHBseSh0aGlzLl90b2tlbnMsdG9rZW5zKTsgLy8gd2hhdCBpcyB0aGlzP1xuXHRcdC8vIEZJWFxuXHRcdFxuXHRcdGlmIChmbGFncykge1xuXHRcdFx0dGhpcy5fdG9rZW5zLnB1c2goVC50b2tlbignLCcsJywnLDApKTtcblx0XHRcdHRoaXMuX3Rva2Vucy5wdXNoKFQudG9rZW4oJ1NUUklORycsJ1wiJyArIGZsYWdzICsgJ1wiJywwKSk7XG5cdFx0fTtcblx0XHRcblx0XHR0aGlzLnRva2VuKCcpJywnKScsMCk7XG5cdFx0XG5cdFx0cmV0dXJuIGhlcmVnZXgubGVuZ3RoO1xuXHR9O1xuXHRcblx0Ly8gTWF0Y2hlcyBuZXdsaW5lcywgaW5kZW50cywgYW5kIG91dGRlbnRzLCBhbmQgZGV0ZXJtaW5lcyB3aGljaCBpcyB3aGljaC5cblx0Ly8gSWYgd2UgY2FuIGRldGVjdCB0aGF0IHRoZSBjdXJyZW50IGxpbmUgaXMgY29udGludWVkIG9udG8gdGhlIHRoZSBuZXh0IGxpbmUsXG5cdC8vIHRoZW4gdGhlIG5ld2xpbmUgaXMgc3VwcHJlc3NlZDpcblx0Ly9cblx0Ly8gICAgIGVsZW1lbnRzXG5cdC8vICAgICAgIC5lYWNoKCAuLi4gKVxuXHQvLyAgICAgICAubWFwKCAuLi4gKVxuXHQvL1xuXHQvLyBLZWVwcyB0cmFjayBvZiB0aGUgbGV2ZWwgb2YgaW5kZW50YXRpb24sIGJlY2F1c2UgYSBzaW5nbGUgb3V0ZGVudCB0b2tlblxuXHQvLyBjYW4gY2xvc2UgbXVsdGlwbGUgaW5kZW50cywgc28gd2UgbmVlZCB0byBrbm93IGhvdyBmYXIgaW4gd2UgaGFwcGVuIHRvIGJlLlxuXHRMZXhlci5wcm90b3R5cGUubGluZVRva2VuID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIG1hdGNoO1xuXHRcdFxuXHRcdGlmICghKG1hdGNoID0gTVVMVElfREVOVC5leGVjKHRoaXMuX2NodW5rKSkpIHsgcmV0dXJuIDAgfTtcblx0XHRcblx0XHR2YXIgaW5kZW50ID0gbWF0Y2hbMF07XG5cdFx0dmFyIGJyQ291bnQgPSB0aGlzLm1vdmVIZWFkKGluZGVudCk7XG5cdFx0XG5cdFx0dGhpcy5fc2VlbkZvciA9IGZhbHNlO1xuXHRcdC8vIHJlc2V0IGNvbHVtbiBhcyB3ZWxsP1xuXHRcdFxuXHRcdHZhciBwcmV2ID0gbGFzdCh0aGlzLl90b2tlbnMsMSk7XG5cdFx0dmFyIHdoaXRlc3BhY2UgPSBpbmRlbnQuc3Vic3RyKGluZGVudC5sYXN0SW5kZXhPZignXFxuJykgKyAxKTtcblx0XHR2YXIgc2l6ZSA9IHdoaXRlc3BhY2UubGVuZ3RoO1xuXHRcdHZhciBub05ld2xpbmVzID0gdGhpcy51bmZpbmlzaGVkKCk7XG5cdFx0XG5cdFx0aWYgKCgvXlxcbiNcXHMvKS50ZXN0KHRoaXMuX2NodW5rKSkge1xuXHRcdFx0dGhpcy5hZGRMaW5lYnJlYWtzKDEpO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoc2l6ZSA+IDApIHtcblx0XHRcdGlmICghdGhpcy5faW5kZW50U3R5bGUpIHtcblx0XHRcdFx0dGhpcy5fb3B0cy5pbmRlbnQgPSB0aGlzLl9pbmRlbnRTdHlsZSA9IHdoaXRlc3BhY2U7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR2YXIgaW5kZW50U2l6ZSA9IDA7XG5cdFx0XHR2YXIgb2Zmc2V0ID0gMDtcblx0XHRcdFxuXHRcdFx0d2hpbGUgKHRydWUpe1xuXHRcdFx0XHR2YXIgaWR4ID0gd2hpdGVzcGFjZS5pbmRleE9mKHRoaXMuX2luZGVudFN0eWxlLG9mZnNldCk7XG5cdFx0XHRcdGlmIChpZHggPT0gb2Zmc2V0KSB7XG5cdFx0XHRcdFx0aW5kZW50U2l6ZSsrO1xuXHRcdFx0XHRcdG9mZnNldCArPSB0aGlzLl9pbmRlbnRTdHlsZS5sZW5ndGg7XG5cdFx0XHRcdH0gZWxzZSBpZiAob2Zmc2V0ID09IHdoaXRlc3BhY2UubGVuZ3RoKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gd29ya2Fyb3VuZCB0byByZXBvcnQgY29ycmVjdCBsb2NhdGlvblxuXHRcdFx0XHRcdHRoaXMuX2xvYyArPSBpbmRlbnQubGVuZ3RoIC0gd2hpdGVzcGFjZS5sZW5ndGg7XG5cdFx0XHRcdFx0dGhpcy50b2tlbignSU5ERU5UJyx3aGl0ZXNwYWNlLHdoaXRlc3BhY2UubGVuZ3RoKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5lcnJvcignaW5jb25zaXN0ZW50IGluZGVudGF0aW9uJyk7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRzaXplID0gaW5kZW50U2l6ZTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdGlmIChzaXplIC0gdGhpcy5faW5kZWJ0ID09IHRoaXMuX2luZGVudCkge1xuXHRcdFx0aWYgKG5vTmV3bGluZXMpIHtcblx0XHRcdFx0dGhpcy5zdXBwcmVzc05ld2xpbmVzKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLm5ld2xpbmVUb2tlbihickNvdW50KTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gaW5kZW50Lmxlbmd0aDtcblx0XHR9O1xuXHRcdFxuXHRcdGlmIChzaXplID4gdGhpcy5faW5kZW50KSB7XG5cdFx0XHRpZiAobm9OZXdsaW5lcykge1xuXHRcdFx0XHR0aGlzLl9pbmRlYnQgPSBzaXplIC0gdGhpcy5faW5kZW50O1xuXHRcdFx0XHR0aGlzLnN1cHByZXNzTmV3bGluZXMoKTtcblx0XHRcdFx0cmV0dXJuIGluZGVudC5sZW5ndGg7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5pblRhZygpKSB7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nIFwiaW5kZW50IGluc2lkZSB0b2tpZD8hP1wiXG5cdFx0XHRcdC8vIEBpbmRlYnQgPSBzaXplIC0gQGluZGVudFxuXHRcdFx0XHQvLyBzdXBwcmVzc05ld2xpbmVzKClcblx0XHRcdFx0cmV0dXJuIGluZGVudC5sZW5ndGg7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRcblx0XHRcdHZhciBkaWZmID0gc2l6ZSAtIHRoaXMuX2luZGVudCArIHRoaXMuX291dGRlYnQ7XG5cdFx0XHR0aGlzLmNsb3NlRGVmKCk7XG5cdFx0XHRcblx0XHRcdHZhciBpbW1lZGlhdGUgPSBsYXN0KHRoaXMuX3Rva2Vucyk7XG5cdFx0XHRcblx0XHRcdGlmIChpbW1lZGlhdGUgJiYgdFQoaW1tZWRpYXRlKSA9PSAnVEVSTUlOQVRPUicpIHtcblx0XHRcdFx0dFRzKGltbWVkaWF0ZSwnSU5ERU5UJyk7XG5cdFx0XHRcdGltbWVkaWF0ZS5fbWV0YSB8fCAoaW1tZWRpYXRlLl9tZXRhID0ge3ByZTogdFYoaW1tZWRpYXRlKSxwb3N0OiAnJ30pO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gc2hvdWxkIHJhdGhlciBhZGQgdG8gbWV0YSBzb21laG93PyE/XG5cdFx0XHRcdC8vIHRWcyhpbW1lZGlhdGUsdFYoaW1tZWRpYXRlKSArICclfCUnKSAjIGNyYXp5XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnRva2VuKCdJTkRFTlQnLFwiXCIgKyBkaWZmLDApO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Ly8gY29uc29sZS5sb2cgXCJpbmRlbnRpbmdcIiwgcHJldiwgbGFzdChAdG9rZW5zLDEpXG5cdFx0XHQvLyBpZiBwcmV2IGFuZCBwcmV2WzBdID09ICdURVJNSU5BVE9SJ1xuXHRcdFx0Ly8gICBjb25zb2xlLmxvZyBcInRlcm1pbmF0b3IgYmVmb3JlIGluZGVudD8/XCJcblx0XHRcdFxuXHRcdFx0Ly8gY2hlY2sgZm9yIGNvbW1lbnRzIGFzIHdlbGwgP1xuXHRcdFx0XG5cdFx0XHR0aGlzLl9pbmRlbnRzLnB1c2goZGlmZik7XG5cdFx0XHR0aGlzLnB1c2hFbmQoJ09VVERFTlQnKTtcblx0XHRcdC8vIEBlbmRzLnB1c2ggJ09VVERFTlQnXG5cdFx0XHR0aGlzLl9vdXRkZWJ0ID0gdGhpcy5faW5kZWJ0ID0gMDtcblx0XHRcdHRoaXMuYWRkTGluZWJyZWFrcyhickNvdW50KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5faW5kZWJ0ID0gMDtcblx0XHRcdHRoaXMub3V0ZGVudFRva2VuKHRoaXMuX2luZGVudCAtIHNpemUsbm9OZXdsaW5lcyxickNvdW50KTtcblx0XHRcdHRoaXMuYWRkTGluZWJyZWFrcyhickNvdW50IC0gMSk7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyBcIm91dGRlbnRcIixub05ld2xpbmVzLHRva2lkKClcblx0XHR9O1xuXHRcdFxuXHRcdHRoaXMuX2luZGVudCA9IHNpemU7XG5cdFx0cmV0dXJuIGluZGVudC5sZW5ndGg7XG5cdH07XG5cdFxuXHQvLyBSZWNvcmQgYW4gb3V0ZGVudCB0b2tlbiBvciBtdWx0aXBsZSB0b2tlbnMsIGlmIHdlIGhhcHBlbiB0byBiZSBtb3ZpbmcgYmFja1xuXHQvLyBpbndhcmRzIHBhc3Qgc2V2ZXJhbCByZWNvcmRlZCBpbmRlbnRzLlxuXHRMZXhlci5wcm90b3R5cGUub3V0ZGVudFRva2VuID0gZnVuY3Rpb24gKG1vdmVPdXQsbm9OZXdsaW5lcyxuZXdsaW5lQ291bnQpe1xuXHRcdC8vIGhlcmUgd2Ugc2hvdWxkIGFsc28gdGFrZSBjYXJlIHRvIHBvcCAvIHJlc2V0IHRoZSBzY29wZS1ib2R5XG5cdFx0Ly8gb3IgY29udGV4dC10eXBlIGZvciBpbmRlbnRhdGlvbiBcblx0XHR2YXIgZGVudCA9IDA7XG5cdFx0d2hpbGUgKG1vdmVPdXQgPiAwKXtcblx0XHRcdHZhciBsZW4gPSB0aGlzLl9pbmRlbnRzLmxlbmd0aCAtIDE7XG5cdFx0XHRpZiAodGhpcy5faW5kZW50c1tsZW5dID09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRtb3ZlT3V0ID0gMDtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5faW5kZW50c1tsZW5dID09IHRoaXMuX291dGRlYnQpIHtcblx0XHRcdFx0bW92ZU91dCAtPSB0aGlzLl9vdXRkZWJ0O1xuXHRcdFx0XHR0aGlzLl9vdXRkZWJ0ID0gMDtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5faW5kZW50c1tsZW5dIDwgdGhpcy5fb3V0ZGVidCkge1xuXHRcdFx0XHR0aGlzLl9vdXRkZWJ0IC09IHRoaXMuX2luZGVudHNbbGVuXTtcblx0XHRcdFx0bW92ZU91dCAtPSB0aGlzLl9pbmRlbnRzW2xlbl07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZW50ID0gdGhpcy5faW5kZW50cy5wb3AoKSAtIHRoaXMuX291dGRlYnQ7XG5cdFx0XHRcdG1vdmVPdXQgLT0gZGVudDtcblx0XHRcdFx0dGhpcy5fb3V0ZGVidCA9IDA7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoIW5vTmV3bGluZXMpIHsgdGhpcy5hZGRMaW5lYnJlYWtzKDEpIH07XG5cdFx0XHRcdFxuXHRcdFx0XHR0aGlzLnBhaXIoJ09VVERFTlQnKTtcblx0XHRcdFx0dGhpcy50b2tlbignT1VUREVOVCcsXCJcIiArIGRlbnQsMCk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKGRlbnQpIHsgdGhpcy5fb3V0ZGVidCAtPSBtb3ZlT3V0IH07XG5cdFx0XG5cdFx0d2hpbGUgKHRoaXMubGFzdFRva2VuVmFsdWUoKSA9PSAnOycpe1xuXHRcdFx0dGhpcy5fdG9rZW5zLnBvcCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKCEodGhpcy5sYXN0VG9rZW5UeXBlKCkgPT0gJ1RFUk1JTkFUT1InIHx8IG5vTmV3bGluZXMpKSB7IHRoaXMudG9rZW4oJ1RFUk1JTkFUT1InLCdcXG4nLDApIH07XG5cdFx0XG5cdFx0Ly8gY2FwcGluZyBzY29wZXMgc28gdGhleSBkb250IGhhbmcgYXJvdW5kIFxuXHRcdHRoaXMuX3Njb3Blcy5sZW5ndGggPSB0aGlzLl9pbmRlbnRzLmxlbmd0aDtcblx0XHRcblx0XHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0KCk7XG5cdFx0aWYgKGN0eCA9PSAnJScgfHwgY3R4ID09ICdUQUcnKSB7IHRoaXMucGFpcihjdHgpIH07IC8vIHJlYWxseT9cblx0XHR0aGlzLmNsb3NlRGVmKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvLyBNYXRjaGVzIGFuZCBjb25zdW1lcyBub24tbWVhbmluZ2Z1bCB3aGl0ZXNwYWNlLiB0b2tpZCB0aGUgcHJldmlvdXMgdG9rZW5cblx0Ly8gYXMgYmVpbmcgXCJzcGFjZWRcIiwgYmVjYXVzZSB0aGVyZSBhcmUgc29tZSBjYXNlcyB3aGVyZSBpdCBtYWtlcyBhIGRpZmZlcmVuY2UuXG5cdExleGVyLnByb3RvdHlwZS53aGl0ZXNwYWNlVG9rZW4gPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgbWF0Y2gsbmxpbmUscHJldjtcblx0XHRpZiAoISgobWF0Y2ggPSBXSElURVNQQUNFLmV4ZWModGhpcy5fY2h1bmspKSB8fCAobmxpbmUgPSB0aGlzLl9jaHVuay5jaGFyQXQoMCkgPT0gJ1xcbicpKSkgeyByZXR1cm4gMCB9O1xuXHRcdHByZXYgPSBsYXN0KHRoaXMuX3Rva2Vucyk7XG5cdFx0XG5cdFx0Ly8gRklYIC0gd2h5IG9oIHdoeT9cblx0XHRpZiAocHJldikge1xuXHRcdFx0aWYgKG1hdGNoKSB7XG5cdFx0XHRcdHByZXYuc3BhY2VkID0gdHJ1ZTtcblx0XHRcdFx0cmV0dXJuIG1hdGNoWzBdLmxlbmd0aDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHByZXYubmV3TGluZSA9IHRydWU7XG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0fTtcblx0XHR9O1xuXHR9O1xuXHRcblx0TGV4ZXIucHJvdG90eXBlLmFkZE5ld2xpbmUgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy50b2tlbignVEVSTUlOQVRPUicsJ1xcbicpO1xuXHR9O1xuXHRcblx0TGV4ZXIucHJvdG90eXBlLm1vdmVIZWFkID0gZnVuY3Rpb24gKHN0cil7XG5cdFx0dmFyIGJyID0gY291bnQoc3RyLCdcXG4nKTtcblx0XHRyZXR1cm4gYnI7XG5cdH07XG5cdFxuXHRcblx0TGV4ZXIucHJvdG90eXBlLmFkZExpbmVicmVha3MgPSBmdW5jdGlvbiAoY291bnQscmF3KXtcblx0XHR2YXIgYnI7XG5cdFx0XG5cdFx0aWYgKCFyYXcgJiYgY291bnQgPT0gMCkgeyByZXR1cm4gdGhpcyB9OyAvLyBubyB0ZXJtaW5hdG9ycz9cblx0XHRcblx0XHR2YXIgcHJldiA9IHRoaXMuX2xhc3Q7XG5cdFx0XG5cdFx0aWYgKCFyYXcpIHtcblx0XHRcdGlmIChjb3VudCA9PSAxKSB7XG5cdFx0XHRcdGJyID0gJ1xcbic7XG5cdFx0XHR9IGVsc2UgaWYgKGNvdW50ID09IDIpIHtcblx0XHRcdFx0YnIgPSAnXFxuXFxuJztcblx0XHRcdH0gZWxzZSBpZiAoY291bnQgPT0gMykge1xuXHRcdFx0XHRiciA9ICdcXG5cXG5cXG4nO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnIgPSByZXBlYXRTdHJpbmcoJ1xcbicsY291bnQpO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdC8vIEZJWFxuXHRcdGlmIChwcmV2KSB7XG5cdFx0XHR2YXIgdCA9IHByZXYuX3R5cGU7IC8vIEBsYXN0VHlwXG5cdFx0XHR2YXIgdiA9IHRWKHByZXYpO1xuXHRcdFx0XG5cdFx0XHQvLyB3ZSByZWFsbHkgd2FudCB0byBhZGQgdGhpc1xuXHRcdFx0aWYgKHQgPT0gJ0lOREVOVCcpIHtcblx0XHRcdFx0Ly8gVE9ETyB3ZSB3YW50IHRvIGFkZCB0byB0aGUgaW5kZW50XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nIFwiYWRkIHRoZSBjb21tZW50IHRvIHRoZSBpbmRlbnQgLS0gcHJlPyB7cmF3fSB7YnJ9XCJcblx0XHRcdFx0XG5cdFx0XHRcdHZhciBtZXRhID0gcHJldi5fbWV0YSB8fCAocHJldi5fbWV0YSA9IHtwcmU6ICcnLHBvc3Q6ICcnfSk7XG5cdFx0XHRcdG1ldGEucG9zdCArPSAocmF3IHx8IGJyKTtcblx0XHRcdFx0Ly8gdFZzKHYgKyAocmF3IG9yIGJyKSlcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9IGVsc2UgaWYgKHQgPT0gJ1RFUk1JTkFUT1InKSB7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nIFwiYWxyZWFkeSBleGlzdHMgdGVybWluYXRvciB7YnJ9IHtyYXd9XCJcblx0XHRcdFx0dFZzKHByZXYsdiArIChyYXcgfHwgYnIpKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0dGhpcy50b2tlbignVEVSTUlOQVRPUicsYnIsMCk7XG5cdFx0cmV0dXJuO1xuXHR9O1xuXHRcblx0Ly8gR2VuZXJhdGUgYSBuZXdsaW5lIHRva2VuLiBDb25zZWN1dGl2ZSBuZXdsaW5lcyBnZXQgbWVyZ2VkIHRvZ2V0aGVyLlxuXHRMZXhlci5wcm90b3R5cGUubmV3bGluZVRva2VuID0gZnVuY3Rpb24gKGxpbmVzKXtcblx0XHQvLyBjb25zb2xlLmxvZyBcIm5ld2xpbmVUb2tlblwiXG5cdFx0d2hpbGUgKHRoaXMubGFzdFRva2VuVmFsdWUoKSA9PSAnOycpe1xuXHRcdFx0Y29uc29sZS5sb2coXCJwb3AgdG9rZW5cIix0aGlzLl90b2tlbnNbdGhpcy5fdG9rZW5zLmxlbmd0aCAtIDFdKTtcblx0XHRcdHRoaXMuX3Rva2Vucy5wb3AoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRoaXMuYWRkTGluZWJyZWFrcyhsaW5lcyk7XG5cdFx0XG5cdFx0dmFyIGN0eCA9IHRoaXMuY29udGV4dCgpO1xuXHRcdC8vIFdBUk4gbm93IGltcG9ydCBjYW5ub3QgZ28gb3ZlciBtdWx0aXBsZSBsaW5lc1xuXHRcdGlmIChjdHggPT0gJ1RBRycgfHwgY3R4ID09ICdJTVBPUlQnKSB7IHRoaXMucGFpcihjdHgpIH07XG5cdFx0dGhpcy5jbG9zZURlZigpOyAvLyBjbG9zZSBkZWYgLS0gcmVhbGx5P1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Ly8gVXNlIGEgYFxcYCBhdCBhIGxpbmUtZW5kaW5nIHRvIHN1cHByZXNzIHRoZSBuZXdsaW5lLlxuXHQvLyBUaGUgc2xhc2ggaXMgcmVtb3ZlZCBoZXJlIG9uY2UgaXRzIGpvYiBpcyBkb25lLlxuXHRMZXhlci5wcm90b3R5cGUuc3VwcHJlc3NOZXdsaW5lcyA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmICh0aGlzLnZhbHVlKCkgPT0gJ1xcXFwnKSB7IHRoaXMuX3Rva2Vucy5wb3AoKSB9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Ly8gV2UgdHJlYXQgYWxsIG90aGVyIHNpbmdsZSBjaGFyYWN0ZXJzIGFzIGEgdG9rZW4uIEUuZy46IGAoICkgLCAuICFgXG5cdC8vIE11bHRpLWNoYXJhY3RlciBvcGVyYXRvcnMgYXJlIGFsc28gbGl0ZXJhbCB0b2tlbnMsIHNvIHRoYXQgSmlzb24gY2FuIGFzc2lnblxuXHQvLyB0aGUgcHJvcGVyIG9yZGVyIG9mIG9wZXJhdGlvbnMuIFRoZXJlIGFyZSBzb21lIHN5bWJvbHMgdGhhdCB3ZSB0b2tpZCBzcGVjaWFsbHlcblx0Ly8gaGVyZS4gYDtgIGFuZCBuZXdsaW5lcyBhcmUgYm90aCB0cmVhdGVkIGFzIGEgYFRFUk1JTkFUT1JgLCB3ZSBkaXN0aW5ndWlzaFxuXHQvLyBwYXJlbnRoZXNlcyB0aGF0IGluZGljYXRlIGEgbWV0aG9kIGNhbGwgZnJvbSByZWd1bGFyIHBhcmVudGhlc2VzLCBhbmQgc28gb24uXG5cdExleGVyLnByb3RvdHlwZS5saXRlcmFsVG9rZW4gPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgbWF0Y2gsdmFsdWU7XG5cdFx0aWYgKG1hdGNoID0gT1BFUkFUT1IuZXhlYyh0aGlzLl9jaHVuaykpIHtcblx0XHRcdHZhbHVlID0gbWF0Y2hbMF07XG5cdFx0XHRpZiAoQ09ERS50ZXN0KHZhbHVlKSkgdGhpcy50YWdQYXJhbWV0ZXJzKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhbHVlID0gdGhpcy5fY2h1bmsuY2hhckF0KDApO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIGVuZDEgPSB0aGlzLl9lbmRzW3RoaXMuX2VuZHMubGVuZ3RoIC0gMV07XG5cdFx0dmFyIGVuZDIgPSB0aGlzLl9lbmRzW3RoaXMuX2VuZHMubGVuZ3RoIC0gMl07XG5cdFx0XG5cdFx0dmFyIGluVGFnID0gZW5kMSA9PSAnVEFHX0VORCcgfHwgZW5kMSA9PSAnT1VUREVOVCcgJiYgZW5kMiA9PSAnVEFHX0VORCc7XG5cdFx0XG5cdFx0dmFyIHRva2lkID0gdmFsdWU7XG5cdFx0dmFyIHByZXYgPSBsYXN0KHRoaXMuX3Rva2Vucyk7XG5cdFx0dmFyIHB0ID0gcHJldiAmJiB0VChwcmV2KTtcblx0XHR2YXIgcHYgPSBwcmV2ICYmIHRWKHByZXYpO1xuXHRcdHZhciBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG5cdFx0XG5cdFx0Ly8gaXMgdGhpcyBuZWVkZWQ/XG5cdFx0aWYgKHZhbHVlID09ICc9JyAmJiBwcmV2KSB7XG5cdFx0XHRcblx0XHRcdGlmIChwdiA9PSAnfHwnIHx8IHB2ID09ICcmJicpIHsgLy8gaW4gWyd8fCcsICcmJiddXG5cdFx0XHRcdHRUcyhwcmV2LCdDT01QT1VORF9BU1NJR04nKTtcblx0XHRcdFx0dFZzKHByZXYscHYgKyAnPScpO1xuXHRcdFx0XHQvLyBwcmV2WzBdID0gJ0NPTVBPVU5EX0FTU0lHTidcblx0XHRcdFx0Ly8gcHJldlsxXSArPSAnPSdcblx0XHRcdFx0cmV0dXJuIHZhbHVlLmxlbmd0aDtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHRpZiAodmFsdWUgPT0gJzsnKSB7XG5cdFx0XHR0aGlzLl9zZWVuRm9yID0gZmFsc2U7XG5cdFx0XHR0b2tpZCA9ICdURVJNSU5BVE9SJztcblx0XHR9IGVsc2UgaWYgKHZhbHVlID09ICcoJyAmJiBpblRhZyAmJiBwdCAhPSAnPScgJiYgcHJldi5zcGFjZWQpIHsgLy8gRklYZWRcblx0XHRcdC8vIGNvbnNvbGUubG9nICdzcGFjZWQgYmVmb3JlICggaW4gdG9raWQnXG5cdFx0XHQvLyBGSVhNRSAtIHNob3VsZCByYXRoZXIgYWRkIGEgc3BlY2lhbCB0b2tlbiBsaWtlIFRBR19QQVJBTVNfU1RBUlRcblx0XHRcdHRoaXMudG9rZW4oJywnLCcsJyk7XG5cdFx0fSBlbHNlIGlmICh2YWx1ZSA9PSAnLT4nICYmIGluVGFnKSB7XG5cdFx0XHR0b2tpZCA9ICdUQUdfRU5EJztcblx0XHRcdHRoaXMucGFpcignVEFHX0VORCcpO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgPT0gJy8+JyAmJiBpblRhZykge1xuXHRcdFx0dG9raWQgPSAnVEFHX0VORCc7XG5cdFx0XHR0aGlzLnBhaXIoJ1RBR19FTkQnKTtcblx0XHR9IGVsc2UgaWYgKHZhbHVlID09ICc+JyAmJiBpblRhZykge1xuXHRcdFx0dG9raWQgPSAnVEFHX0VORCc7XG5cdFx0XHR0aGlzLnBhaXIoJ1RBR19FTkQnKTtcblx0XHR9IGVsc2UgaWYgKHZhbHVlID09ICc+JyAmJiB0aGlzLmNvbnRleHQoKSA9PSAnREVGJykge1xuXHRcdFx0Ly8gY29uc29sZS5sb2coJ3BpY2tlZCB1cCA+ISEnKVxuXHRcdFx0dG9raWQgPSAnREVGX0ZSQUdNRU5UJztcblx0XHRcdFxuXHRcdFx0Ly8gZWxpZiB2YWx1ZSBpcyAnVEVSTUlOQVRPUicgYW5kIGVuZDEgaXMgJyUnIFxuXHRcdFx0Ly8gXHRjbG9zZVNlbGVjdG9yKClcblx0XHR9IGVsc2UgaWYgKHZhbHVlID09ICdURVJNSU5BVE9SJyAmJiBlbmQxID09ICdERUYnKSB7XG5cdFx0XHR0aGlzLmNsb3NlRGVmKCk7XG5cdFx0fSBlbHNlIGlmICh2YWx1ZSA9PSAnJicgJiYgdGhpcy5jb250ZXh0KCkgPT0gJ0RFRicpIHtcblx0XHRcdC8vIGNvbnNvbGUubG9nKFwib2theSFcIilcblx0XHRcdHRva2lkID0gJ0JMT0NLX0FSRyc7XG5cdFx0XHQvLyBjaGFuZ2UgdGhlIG5leHQgaWRlbnRpZmllciBpbnN0ZWFkP1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgPT0gJyonICYmIHRoaXMuX2NodW5rLmNoYXJBdCgxKS5tYXRjaCgvW0EtWmEtelxcX1xcQFxcW10vKSAmJiAocHJldi5zcGFjZWQgfHwgWycsJywnKCcsJ1snLCd7JywnfCcsJ1xcbicsJ1xcdCddLmluZGV4T2YocHYpID49IDApKSB7XG5cdFx0XHR0b2tpZCA9IFwiU1BMQVRcIjtcblx0XHR9IGVsc2UgaWYgKHZhbHVlID09ICfiiJonKSB7XG5cdFx0XHR0b2tpZCA9ICdTUVJUJztcblx0XHR9IGVsc2UgaWYgKHZhbHVlID09ICfGkicpIHtcblx0XHRcdHRva2lkID0gJ0ZVTkMnO1xuXHRcdH0gZWxzZSBpZiAoaWR4JCh2YWx1ZSxNQVRIKSA+PSAwKSB7XG5cdFx0XHR0b2tpZCA9ICdNQVRIJztcblx0XHR9IGVsc2UgaWYgKGlkeCQodmFsdWUsQ09NUEFSRSkgPj0gMCkge1xuXHRcdFx0dG9raWQgPSAnQ09NUEFSRSc7XG5cdFx0fSBlbHNlIGlmIChpZHgkKHZhbHVlLENPTVBPVU5EX0FTU0lHTikgPj0gMCkge1xuXHRcdFx0dG9raWQgPSAnQ09NUE9VTkRfQVNTSUdOJztcblx0XHR9IGVsc2UgaWYgKGlkeCQodmFsdWUsVU5BUlkpID49IDApIHtcblx0XHRcdHRva2lkID0gJ1VOQVJZJztcblx0XHR9IGVsc2UgaWYgKGlkeCQodmFsdWUsU0hJRlQpID49IDApIHtcblx0XHRcdHRva2lkID0gJ1NISUZUJztcblx0XHR9IGVsc2UgaWYgKGlkeCQodmFsdWUsTE9HSUMpID49IDApIHtcblx0XHRcdHRva2lkID0gJ0xPR0lDJzsgLy8gb3IgdmFsdWUgaXMgJz8nIGFuZCBwcmV2PzpzcGFjZWQgXG5cdFx0fSBlbHNlIGlmIChwcmV2ICYmICFwcmV2LnNwYWNlZCkge1xuXHRcdFx0Ly8gbmVlZCBhIGJldHRlciB3YXkgdG8gZG8gdGhlc2Vcblx0XHRcdGlmICh2YWx1ZSA9PSAnKCcgJiYgZW5kMSA9PSAnJScpIHtcblx0XHRcdFx0dG9raWQgPSAnVEFHX0FUVFJTX1NUQVJUJztcblx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPT0gJygnICYmIGlkeCQocHQsQ0FMTEFCTEUpID49IDApIHtcblx0XHRcdFx0Ly8gbm90IHVzaW5nIHRoaXMgPz8/XG5cdFx0XHRcdC8vIHByZXZbMF0gPSAnRlVOQ19FWElTVCcgaWYgcHJldlswXSBpcyAnPydcblx0XHRcdFx0dG9raWQgPSAnQ0FMTF9TVEFSVCc7XG5cdFx0XHR9IGVsc2UgaWYgKHZhbHVlID09ICdbJyAmJiBpZHgkKHB0LElOREVYQUJMRSkgPj0gMCkge1xuXHRcdFx0XHR0b2tpZCA9ICdJTkRFWF9TVEFSVCc7XG5cdFx0XHRcdGlmIChwdCA9PSAnPycpIHsgdFRzKHByZXYsJ0lOREVYX1NPQUsnKSB9O1xuXHRcdFx0XHQvLyBwcmV2WzBdID0gJ0lOREVYX1NPQUsnIGlmIHByZXZbMF0gPT0gJz8nXG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0c3dpdGNoICh2YWx1ZSkge1xuXHRcdFx0Y2FzZSAnKCc6XG5cdFx0XHRjYXNlICd7Jzpcblx0XHRcdGNhc2UgJ1snOlxuXHRcdFx0XHR0aGlzLnB1c2hFbmQoSU5WRVJTRVNbdmFsdWVdKTticmVhaztcblx0XHRcdFxuXHRcdFx0Y2FzZSAnKSc6XG5cdFx0XHRjYXNlICd9Jzpcblx0XHRcdGNhc2UgJ10nOlxuXHRcdFx0XHR0aGlzLnBhaXIodmFsdWUpO2JyZWFrO1xuXHRcdFxuXHRcdH07XG5cdFx0XG5cdFx0Ly8gaGFja3kgcnVsZSB0byB0cnkgdG8gYWxsb3cgZm9yIHR1cGxlLWFzc2lnbm1lbnRzIGluIGJsb2Nrc1xuXHRcdC8vIGlmIHZhbHVlIGlzICcsJyBhbmQgcHJldlswXSBpcyAnSURFTlRJRklFUicgYW5kIEB0b2tlbnNbQHRva2VuczpsZW5ndGggLSAyXVswXSBpbiBbJ1RFUk1JTkFUT1InLCdJTkRFTlQnXVxuXHRcdC8vICAgIyB0b2tlbiBcIlRVUExFXCIsIFwidHVwbGVcIiAjIHNob3VsZCByYXRoZXIgaW5zZXJ0IGl0IHNvbWV3aGVyZSBlbHNlLCBubz9cblx0XHQvLyAgIGNvbnNvbGUubG9nKFwiZm91bmQgY29tbWFcIilcblx0XHRcblx0XHR0aGlzLnRva2VuKHRva2lkLHZhbHVlLHZhbHVlLmxlbmd0aCk7XG5cdFx0cmV0dXJuIHZhbHVlLmxlbmd0aDtcblx0fTtcblx0XG5cdC8vIFRva2VuIE1hbmlwdWxhdG9yc1xuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS1cblx0XG5cdC8vIFNhbml0aXplIGEgaGVyZWRvYyBvciBoZXJlY29tbWVudCBieVxuXHQvLyBlcmFzaW5nIGFsbCBleHRlcm5hbCBpbmRlbnRhdGlvbiBvbiB0aGUgbGVmdC1oYW5kIHNpZGUuXG5cdExleGVyLnByb3RvdHlwZS5zYW5pdGl6ZUhlcmVkb2MgPSBmdW5jdGlvbiAoZG9jLG9wdGlvbnMpe1xuXHRcdHZhciBtYXRjaDtcblx0XHR2YXIgaW5kZW50ID0gb3B0aW9ucy5pbmRlbnQ7XG5cdFx0dmFyIGhlcmVjb21tZW50ID0gb3B0aW9ucy5oZXJlY29tbWVudDtcblx0XHRcblx0XHRpZiAoaGVyZWNvbW1lbnQpIHtcblx0XHRcdGlmIChIRVJFRE9DX0lMTEVHQUwudGVzdChkb2MpKSB7XG5cdFx0XHRcdHRoaXMuZXJyb3IoXCJibG9jayBjb21tZW50IGNhbm5vdCBjb250YWluICcqLycgc3RhcnRpbmdcIik7XG5cdFx0XHR9O1xuXHRcdFx0aWYgKGRvYy5pbmRleE9mKCdcXG4nKSA8PSAwKSB7IHJldHVybiBkb2MgfTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGxlbmd0aF87d2hpbGUgKG1hdGNoID0gSEVSRURPQ19JTkRFTlQuZXhlYyhkb2MpKXtcblx0XHRcdFx0dmFyIGF0dGVtcHQgPSBtYXRjaFsxXTtcblx0XHRcdFx0aWYgKGluZGVudCA9PSBudWxsIHx8IDAgPCAobGVuZ3RoXyA9IGF0dGVtcHQubGVuZ3RoKSAmJiBsZW5ndGhfIDwgaW5kZW50Lmxlbmd0aCkge1xuXHRcdFx0XHRcdGluZGVudCA9IGF0dGVtcHQ7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKGluZGVudCkgeyBkb2MgPSBkb2MucmVwbGFjZShSZWdFeHAoKFwiXFxcXG5cIiArIGluZGVudCksXCJnXCIpLCdcXG4nKSB9O1xuXHRcdGlmICghaGVyZWNvbW1lbnQpIHsgZG9jID0gZG9jLnJlcGxhY2UoL15cXG4vLCcnKSB9O1xuXHRcdHJldHVybiBkb2M7XG5cdH07XG5cdFxuXHQvLyBBIHNvdXJjZSBvZiBhbWJpZ3VpdHkgaW4gb3VyIGdyYW1tYXIgdXNlZCB0byBiZSBwYXJhbWV0ZXIgbGlzdHMgaW4gZnVuY3Rpb25cblx0Ly8gZGVmaW5pdGlvbnMgdmVyc3VzIGFyZ3VtZW50IGxpc3RzIGluIGZ1bmN0aW9uIGNhbGxzLiBXYWxrIGJhY2t3YXJkcywgdG9raWRnaW5nXG5cdC8vIHBhcmFtZXRlcnMgc3BlY2lhbGx5IGluIG9yZGVyIHRvIG1ha2UgdGhpbmdzIGVhc2llciBmb3IgdGhlIHBhcnNlci5cblx0TGV4ZXIucHJvdG90eXBlLnRhZ1BhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgdG9rO1xuXHRcdGlmICh0aGlzLmxhc3RUb2tlblR5cGUoKSAhPSAnKScpIHsgcmV0dXJuIHRoaXMgfTtcblx0XHR2YXIgc3RhY2sgPSBbXTtcblx0XHR2YXIgdG9rZW5zID0gdGhpcy5fdG9rZW5zO1xuXHRcdHZhciBpID0gdG9rZW5zLmxlbmd0aDtcblx0XHRcblx0XHR0VHModG9rZW5zWy0taV0sJ1BBUkFNX0VORCcpO1xuXHRcdFxuXHRcdHdoaWxlICh0b2sgPSB0b2tlbnNbLS1pXSl7XG5cdFx0XHR2YXIgdCA9IHRUKHRvayk7XG5cdFx0XHRzd2l0Y2ggKHQpIHtcblx0XHRcdFx0Y2FzZSAnKSc6XG5cdFx0XHRcdFx0c3RhY2sucHVzaCh0b2spO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcblx0XHRcdFx0Y2FzZSAnKCc6XG5cdFx0XHRcdGNhc2UgJ0NBTExfU1RBUlQnOlxuXHRcdFx0XHRcdGlmIChzdGFjay5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdHN0YWNrLnBvcCgpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodCA9PSAnKCcpIHtcblx0XHRcdFx0XHRcdHRUcyh0b2ssJ1BBUkFNX1NUQVJUJyk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFxuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Ly8gQ2xvc2UgdXAgYWxsIHJlbWFpbmluZyBvcGVuIGJsb2NrcyBhdCB0aGUgZW5kIG9mIHRoZSBmaWxlLlxuXHRMZXhlci5wcm90b3R5cGUuY2xvc2VJbmRlbnRhdGlvbiA9IGZ1bmN0aW9uICgpe1xuXHRcdC8vIGN0eCA9IGNvbnRleHRcblx0XHQvLyBwYWlyKGN0eCkgaWYgY3R4IGluIFsnJScsJ0RFRiddXG5cdFx0dGhpcy5jbG9zZURlZigpO1xuXHRcdHRoaXMuY2xvc2VTZWxlY3RvcigpO1xuXHRcdHJldHVybiB0aGlzLm91dGRlbnRUb2tlbih0aGlzLl9pbmRlbnQsZmFsc2UsMCk7XG5cdH07XG5cdFxuXHQvLyBNYXRjaGVzIGEgYmFsYW5jZWQgZ3JvdXAgc3VjaCBhcyBhIHNpbmdsZSBvciBkb3VibGUtcXVvdGVkIHN0cmluZy4gUGFzcyBpblxuXHQvLyBhIHNlcmllcyBvZiBkZWxpbWl0ZXJzLCBhbGwgb2Ygd2hpY2ggbXVzdCBiZSBuZXN0ZWQgY29ycmVjdGx5IHdpdGhpbiB0aGVcblx0Ly8gY29udGVudHMgb2YgdGhlIHN0cmluZy4gVGhpcyBtZXRob2QgYWxsb3dzIHVzIHRvIGhhdmUgc3RyaW5ncyB3aXRoaW5cblx0Ly8gaW50ZXJwb2xhdGlvbnMgd2l0aGluIHN0cmluZ3MsIGFkIGluZmluaXR1bS5cblx0TGV4ZXIucHJvdG90eXBlLmJhbGFuY2VkU3RyaW5nID0gZnVuY3Rpb24gKHN0cixlbmQpe1xuXHRcdHZhciBtYXRjaCxsZXR0ZXIscHJldjtcblx0XHRcblx0XHQvLyBjb25zb2xlLmxvZyAnYmFsYW5jaW5nIHN0cmluZyEnLCBzdHIsIGVuZFxuXHRcdHZhciBzdGFjayA9IFtlbmRdO1xuXHRcdHZhciBpID0gMDtcblx0XHRcblx0XHQvLyBjb3VsZCBpdCBub3QgaGFwcGVuIGhlcmU/XG5cdFx0d2hpbGUgKGkgPCAoc3RyLmxlbmd0aCAtIDEpKXtcblx0XHRcdGkrKztcblx0XHRcdGxldHRlciA9IHN0ci5jaGFyQXQoaSk7XG5cdFx0XHRzd2l0Y2ggKGxldHRlcikge1xuXHRcdFx0XHRjYXNlICdcXFxcJzpcblx0XHRcdFx0XHRpKys7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFxuXHRcdFx0XHRjYXNlIGVuZDpcblx0XHRcdFx0XHRzdGFjay5wb3AoKTtcblx0XHRcdFx0XHRpZiAoIXN0YWNrLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0dmFyIHYgPSBzdHIuc2xpY2UoMCxpICsgMSk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdjtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGVuZCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAoZW5kID09ICd9JyAmJiAobGV0dGVyID09ICdcIicgfHwgbGV0dGVyID09IFwiJ1wiKSkge1xuXHRcdFx0XHRzdGFjay5wdXNoKGVuZCA9IGxldHRlcik7XG5cdFx0XHR9IGVsc2UgaWYgKGVuZCA9PSAnfScgJiYgbGV0dGVyID09ICcvJyAmJiAobWF0Y2ggPSAoSEVSRUdFWC5leGVjKHN0ci5zbGljZShpKSkgfHwgUkVHRVguZXhlYyhzdHIuc2xpY2UoaSkpKSkpIHtcblx0XHRcdFx0aSArPSBtYXRjaFswXS5sZW5ndGggLSAxO1xuXHRcdFx0fSBlbHNlIGlmIChlbmQgPT0gJ30nICYmIGxldHRlciA9PSAneycpIHtcblx0XHRcdFx0c3RhY2sucHVzaChlbmQgPSAnfScpO1xuXHRcdFx0fSBlbHNlIGlmIChlbmQgPT0gJ1wiJyAmJiBsZXR0ZXIgPT0gJ3snKSB7XG5cdFx0XHRcdHN0YWNrLnB1c2goZW5kID0gJ30nKTtcblx0XHRcdH07XG5cdFx0XHRwcmV2ID0gbGV0dGVyO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKCF0aGlzLl9vcHRzLnNpbGVudCkgeyByZXR1cm4gdGhpcy5lcnJvcigoXCJtaXNzaW5nIFwiICsgKHN0YWNrLnBvcCgpKSArIFwiLCBzdGFydGluZ1wiKSkgfTtcblx0fTtcblx0XG5cdC8vIEV4cGFuZCB2YXJpYWJsZXMgYW5kIGV4cHJlc3Npb25zIGluc2lkZSBkb3VibGUtcXVvdGVkIHN0cmluZ3MgdXNpbmdcblx0Ly8gUnVieS1saWtlIG5vdGF0aW9uIGZvciBzdWJzdGl0dXRpb24gb2YgYXJiaXRyYXJ5IGV4cHJlc3Npb25zLlxuXHQvL1xuXHQvLyAgICAgXCJIZWxsbyAje25hbWUuY2FwaXRhbGl6ZSgpfS5cIlxuXHQvL1xuXHQvLyBJZiBpdCBlbmNvdW50ZXJzIGFuIGludGVycG9sYXRpb24sIHRoaXMgbWV0aG9kIHdpbGwgcmVjdXJzaXZlbHkgY3JlYXRlIGFcblx0Ly8gbmV3IExleGVyLCB0b2tlbml6ZSB0aGUgaW50ZXJwb2xhdGVkIGNvbnRlbnRzLCBhbmQgbWVyZ2UgdGhlbSBpbnRvIHRoZVxuXHQvLyB0b2tlbiBzdHJlYW0uXG5cdExleGVyLnByb3RvdHlwZS5pbnRlcnBvbGF0ZVN0cmluZyA9IGZ1bmN0aW9uIChzdHIsb3B0aW9ucyl7XG5cdFx0Ly8gY29uc29sZS5sb2cgXCJpbnRlcnBvbGF0ZSBzdHJpbmdcIlxuXHRcdGlmKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkgb3B0aW9ucyA9IHt9O1xuXHRcdHZhciBoZXJlZG9jID0gb3B0aW9ucy5oZXJlZG9jO1xuXHRcdHZhciBxdW90ZSA9IG9wdGlvbnMucXVvdGU7XG5cdFx0dmFyIHJlZ2V4ID0gb3B0aW9ucy5yZWdleDtcblx0XHR2YXIgcHJlZml4ID0gb3B0aW9ucy5wcmVmaXg7XG5cdFx0XG5cdFx0dmFyIHN0YXJ0TG9jID0gdGhpcy5fbG9jO1xuXHRcdHZhciB0b2tlbnMgPSBbXTtcblx0XHR2YXIgcGkgPSAwO1xuXHRcdHZhciBpID0gLTE7XG5cdFx0dmFyIGxvY09mZnNldCA9IG9wdGlvbnMub2Zmc2V0IHx8IDE7XG5cdFx0dmFyIHN0cmxlbiA9IHN0ci5sZW5ndGg7XG5cdFx0dmFyIGxldHRlcjtcblx0XHR2YXIgZXhwcjtcblx0XHRcblx0XHR2YXIgaXNJbnRlcnBvbGF0ZWQgPSBmYWxzZTtcblx0XHQvLyBvdXQgb2YgYm91bmRzXG5cdFx0d2hpbGUgKGxldHRlciA9IHN0ci5jaGFyQXQoaSArPSAxKSl7XG5cdFx0XHRpZiAobGV0dGVyID09ICdcXFxcJykge1xuXHRcdFx0XHRpICs9IDE7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKCEoc3RyLmNoYXJBdChpKSA9PSAneycgJiYgKGV4cHIgPSB0aGlzLmJhbGFuY2VkU3RyaW5nKHN0ci5zbGljZShpKSwnfScpKSkpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpc0ludGVycG9sYXRlZCA9IHRydWU7XG5cdFx0XHRcblx0XHRcdC8vIHRoZXNlIGhhdmUgbm8gcmVhbCBzZW5zZSBvZiBsb2NhdGlvbiBvciBhbnl0aGluZz9cblx0XHRcdGlmIChwaSA8IGkpIHtcblx0XHRcdFx0Ly8gdGhpcyBpcyB0aGUgcHJlZml4LXN0cmluZyAtIGJlZm9yZSBhbnkgaXRlbVxuXHRcdFx0XHR2YXIgdG9rID0gbmV3IFRva2VuKCdORU9TVFJJTkcnLHRoaXMuZXNjYXBlU3RyKHN0ci5zbGljZShwaSxpKSxoZXJlZG9jLHF1b3RlKSx0aGlzLl9sb2MgKyBwaSArIGxvY09mZnNldCxpIC0gcGkpO1xuXHRcdFx0XHQvLyB0b2suQGxvYyA9IEBsb2MgKyBwaVxuXHRcdFx0XHQvLyB0b2suQGxlbiA9IGkgLSBwaSArIDJcblx0XHRcdFx0dG9rZW5zLnB1c2godG9rKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHRva2Vucy5wdXNoKG5ldyBUb2tlbigne3snLCd7Jyx0aGlzLl9sb2MgKyBpICsgbG9jT2Zmc2V0LDEpKTtcblx0XHRcdFxuXHRcdFx0dmFyIGlubmVyID0gZXhwci5zbGljZSgxLC0xKTtcblx0XHRcdC8vIGNvbnNvbGUubG9nICdpbm5lciBpcycsaW5uZXJcblx0XHRcdC8vIHJlbW92ZSBsZWFkaW5nIHNwYWNlcyBcblx0XHRcdC8vIG5lZWQgdG8ga2VlcCB0cmFjayBvZiBob3cgbXVjaCB3aGl0ZXNwYWNlIHdlIGRyb3BwZWQgZnJvbSB0aGUgc3RhcnRcblx0XHRcdGlubmVyID0gaW5uZXIucmVwbGFjZSgvXlteXFxuXFxTXSsvLCcnKTtcblx0XHRcdFxuXHRcdFx0aWYgKGlubmVyLmxlbmd0aCkge1xuXHRcdFx0XHQvLyB3ZSBuZWVkIHRvIHJlbWVtYmVyIHRoZSBsb2Mgd2Ugc3RhcnQgYXRcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coJ2ludGVycG9sYXRlIGZyb20gbG9jJyxAbG9jLGkpXG5cdFx0XHRcdC8vIHJlYWxseT8gd2h5IG5vdCBqdXN0IGFkZCB0byB0aGUgc3RhY2s/P1xuXHRcdFx0XHQvLyB3aGF0IGFib3V0IHRoZSBhZGRlZCBcblx0XHRcdFx0Ly8gc2hvdWxkIHNoYXJlIHdpdGggdGhlIHNlbGVjdG9yIG5vP1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyBcInRva2VuaXplIGlubmVyIHBhcnRzIG9mIHN0cmluZ1wiLGlubmVyXG5cdFx0XHRcdHZhciBzcGFjZXMgPSAwO1xuXHRcdFx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5fbG9jICsgaSArIChleHByLmxlbmd0aCAtIGlubmVyLmxlbmd0aCkgLSAxO1xuXHRcdFx0XHQvLyB3aHkgY3JlYXRlIGEgd2hvbGUgbmV3IGxleGVyPyBTaG91bGQgcmF0aGVyIHJldXNlIG9uZVxuXHRcdFx0XHQvLyBtdWNoIGJldHRlciB0byBzaW1wbHkgbW92ZSBpbnRvIGludGVycG9sYXRpb24gbW9kZSB3aGVyZVxuXHRcdFx0XHQvLyB3ZSBjb250aW51ZSBwYXJzaW5nIHVudGlsIHdlIG1lZXQgdW5wYWlyZWQgfVxuXHRcdFx0XHR2YXIgbmVzdGVkID0gbmV3IExleGVyKCkudG9rZW5pemUoaW5uZXIse2lubGluZTogdHJ1ZSxyZXdyaXRlOiBmYWxzZSxsb2M6IG9mZnNldCArIGxvY09mZnNldH0pO1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyBuZXN0ZWQucG9wXG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAobmVzdGVkWzBdICYmIHRUKG5lc3RlZFswXSkgPT0gJ1RFUk1JTkFUT1InKSB7XG5cdFx0XHRcdFx0bmVzdGVkLnNoaWZ0KCk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAobmVzdGVkLmxlbmd0aCkge1xuXHRcdFx0XHRcdHRva2Vucy5wdXNoLmFwcGx5KHRva2VucyxuZXN0ZWQpOyAvLyBULnRva2VuKCdUT0tFTlMnLG5lc3RlZCwwKVxuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Ly8gc2hvdWxkIHJhdGhlciBhZGQgdGhlIGFtb3VudCBieSB3aGljaCBvdXIgbGV4ZXIgaGFzIG1vdmVkP1xuXHRcdFx0aSArPSBleHByLmxlbmd0aCAtIDE7XG5cdFx0XHR0b2tlbnMucHVzaChuZXcgVG9rZW4oJ319JywnfScsdGhpcy5fbG9jICsgaSArIGxvY09mZnNldCwxKSk7XG5cdFx0XHRwaSA9IGkgKyAxO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gYWRkaW5nIHRoZSBsYXN0IHBhcnQgb2YgdGhlIHN0cmluZyBoZXJlXG5cdFx0aWYgKGkgPj0gcGkgJiYgcGkgPCBzdHIubGVuZ3RoKSB7XG5cdFx0XHQvLyBzZXQgdGhlIGxlbmd0aCBhcyB3ZWxsIC0gb3I/XG5cdFx0XHQvLyB0aGUgc3RyaW5nIGFmdGVyP1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgJ3B1c2ggbmVvc3RyaW5nJ1xuXHRcdFx0dG9rZW5zLnB1c2gobmV3IFRva2VuKCdORU9TVFJJTkcnLHRoaXMuZXNjYXBlU3RyKHN0ci5zbGljZShwaSksaGVyZWRvYyxxdW90ZSksdGhpcy5fbG9jICsgcGkgKyBsb2NPZmZzZXQsc3RyLmxlbmd0aCAtIHBpKSk7XG5cdFx0fTtcblx0XHRcblx0XHQvLyBjb25zb2xlLmxvZyB0b2tlbnM6bGVuZ3RoXG5cdFx0aWYgKHJlZ2V4KSB7IHJldHVybiB0b2tlbnMgfTtcblx0XHRcblx0XHRpZiAoIXRva2Vucy5sZW5ndGgpIHsgcmV0dXJuIHRoaXMudG9rZW4oJ05FT1NUUklORycsJ1wiXCInKSB9O1xuXHRcdFxuXHRcdGZvciAodmFyIGogPSAwLCBsZW4gPSB0b2tlbnMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcblx0XHRcdHRoaXMuX3Rva2Vucy5wdXNoKHRva2Vuc1tqXSk7XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gdG9rZW5zO1xuXHR9O1xuXHRcblx0Ly8gTWF0Y2hlcyBhIGJhbGFuY2VkIGdyb3VwIHN1Y2ggYXMgYSBzaW5nbGUgb3IgZG91YmxlLXF1b3RlZCBzdHJpbmcuIFBhc3MgaW5cblx0Ly8gYSBzZXJpZXMgb2YgZGVsaW1pdGVycywgYWxsIG9mIHdoaWNoIG11c3QgYmUgbmVzdGVkIGNvcnJlY3RseSB3aXRoaW4gdGhlXG5cdC8vIGNvbnRlbnRzIG9mIHRoZSBzdHJpbmcuIFRoaXMgbWV0aG9kIGFsbG93cyB1cyB0byBoYXZlIHN0cmluZ3Mgd2l0aGluXG5cdC8vIGludGVycG9sYXRpb25zIHdpdGhpbiBzdHJpbmdzLCBhZCBpbmZpbml0dW0uXG5cdExleGVyLnByb3RvdHlwZS5iYWxhbmNlZFNlbGVjdG9yID0gZnVuY3Rpb24gKHN0cixlbmQpe1xuXHRcdHZhciBwcmV2O1xuXHRcdHZhciBsZXR0ZXI7XG5cdFx0dmFyIHN0YWNrID0gW2VuZF07XG5cdFx0Ly8gRklYTUVcblx0XHRmb3IgKHZhciBsZW4gPSBzdHIubGVuZ3RoLCBpID0gMTsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRzd2l0Y2ggKGxldHRlciA9IHN0ci5jaGFyQXQoaSkpIHtcblx0XHRcdFx0Y2FzZSAnXFxcXCc6XG5cdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcblx0XHRcdFx0Y2FzZSBlbmQ6XG5cdFx0XHRcdFx0c3RhY2sucG9wKCk7XG5cdFx0XHRcdFx0aWYgKCFzdGFjay5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdHJldHVybiBzdHIuc2xpY2UoMCxpICsgMSk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRlbmQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFxuXHRcdFx0fTtcblx0XHRcdGlmIChlbmQgPT0gJ30nICYmIGxldHRlciA9PSBbJyknXSkge1xuXHRcdFx0XHRzdGFjay5wdXNoKGVuZCA9IGxldHRlcik7XG5cdFx0XHR9IGVsc2UgaWYgKGVuZCA9PSAnfScgJiYgbGV0dGVyID09ICd7Jykge1xuXHRcdFx0XHRzdGFjay5wdXNoKGVuZCA9ICd9Jyk7XG5cdFx0XHR9IGVsc2UgaWYgKGVuZCA9PSAnKScgJiYgbGV0dGVyID09ICd7Jykge1xuXHRcdFx0XHRzdGFjay5wdXNoKGVuZCA9ICd9Jyk7XG5cdFx0XHR9O1xuXHRcdFx0cHJldiA9IGxldHRlcjsgLy8gd2hhdCwgd2h5P1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXMuZXJyb3IoKFwibWlzc2luZyBcIiArIChzdGFjay5wb3AoKSkgKyBcIiwgc3RhcnRpbmdcIikpO1xuXHR9O1xuXHRcblx0Ly8gUGFpcnMgdXAgYSBjbG9zaW5nIHRva2VuLCBlbnN1cmluZyB0aGF0IGFsbCBsaXN0ZWQgcGFpcnMgb2YgdG9rZW5zIGFyZVxuXHQvLyBjb3JyZWN0bHkgYmFsYW5jZWQgdGhyb3VnaG91dCB0aGUgY291cnNlIG9mIHRoZSB0b2tlbiBzdHJlYW0uXG5cdExleGVyLnByb3RvdHlwZS5wYWlyID0gZnVuY3Rpb24gKHRvayl7XG5cdFx0dmFyIHdhbnRlZCA9IGxhc3QodGhpcy5fZW5kcyk7XG5cdFx0aWYgKHRvayAhPSB3YW50ZWQpIHtcblx0XHRcdGlmICgnT1VUREVOVCcgIT0gd2FudGVkKSB7IHRoaXMuZXJyb3IoKFwidW5tYXRjaGVkIFwiICsgdG9rKSkgfTtcblx0XHRcdHZhciBzaXplID0gbGFzdCh0aGlzLl9pbmRlbnRzKTtcblx0XHRcdHRoaXMuX2luZGVudCAtPSBzaXplO1xuXHRcdFx0dGhpcy5vdXRkZW50VG9rZW4oc2l6ZSx0cnVlLDApO1xuXHRcdFx0cmV0dXJuIHRoaXMucGFpcih0b2spO1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXMucG9wRW5kKCk7XG5cdH07XG5cdFxuXHRcblx0Ly8gSGVscGVyc1xuXHQvLyAtLS0tLS0tXG5cdFxuXHQvLyBBZGQgYSB0b2tlbiB0byB0aGUgcmVzdWx0cywgdGFraW5nIG5vdGUgb2YgdGhlIGxpbmUgbnVtYmVyLlxuXHRMZXhlci5wcm90b3R5cGUudG9rZW4gPSBmdW5jdGlvbiAoaWQsdmFsdWUsbGVuLG9mZnNldCl7XG5cdFx0dGhpcy5fbGFzdFR5cCA9IGlkO1xuXHRcdHRoaXMuX2xhc3RWYWwgPSB2YWx1ZTtcblx0XHR2YXIgdG9rID0gdGhpcy5fbGFzdCA9IG5ldyBUb2tlbihpZCx2YWx1ZSx0aGlzLl9sb2MgKyAob2Zmc2V0IHx8IDApLGxlbiB8fCAwKTtcblx0XHR0aGlzLl90b2tlbnMucHVzaCh0b2spO1xuXHRcdHJldHVybjtcblx0fTtcblx0XG5cdExleGVyLnByb3RvdHlwZS5sYXN0VG9rZW5UeXBlID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHRva2VuID0gdGhpcy5fdG9rZW5zW3RoaXMuX3Rva2Vucy5sZW5ndGggLSAxXTtcblx0XHRyZXR1cm4gdG9rZW4gPyAodFQodG9rZW4pKSA6ICgnTk9ORScpO1xuXHR9O1xuXHRcblx0TGV4ZXIucHJvdG90eXBlLmxhc3RUb2tlblZhbHVlID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHRva2VuID0gdGhpcy5fdG9rZW5zW3RoaXMuX3Rva2Vucy5sZW5ndGggLSAxXTtcblx0XHRyZXR1cm4gdG9rZW4gPyAodG9rZW4uX3ZhbHVlKSA6ICgnJyk7XG5cdH07XG5cdFxuXHQvLyBQZWVrIGF0IGEgdG9raWQgaW4gdGhlIGN1cnJlbnQgdG9rZW4gc3RyZWFtLlxuXHRMZXhlci5wcm90b3R5cGUudG9raWQgPSBmdW5jdGlvbiAoaW5kZXgsdmFsKXtcblx0XHR2YXIgdG9rO1xuXHRcdGlmICh0b2sgPSBsYXN0KHRoaXMuX3Rva2VucyxpbmRleCkpIHtcblx0XHRcdGlmICh2YWwpIHsgdFRzKHRvayx2YWwpIH07XG5cdFx0XHRyZXR1cm4gdFQodG9rKTtcblx0XHRcdC8vIHRvay5AdHlwZSA9IHRva2lkIGlmIHRva2lkICMgd2h5P1xuXHRcdFx0Ly8gdG9rLkB0eXBlXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cdH07XG5cdFxuXHQvLyBQZWVrIGF0IGEgdmFsdWUgaW4gdGhlIGN1cnJlbnQgdG9rZW4gc3RyZWFtLlxuXHRMZXhlci5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbiAoaW5kZXgsdmFsKXtcblx0XHR2YXIgdG9rO1xuXHRcdGlmICh0b2sgPSBsYXN0KHRoaXMuX3Rva2VucyxpbmRleCkpIHtcblx0XHRcdGlmICh2YWwpIHsgdFZzKHRvayx2YWwpIH07XG5cdFx0XHRyZXR1cm4gdFYodG9rKTtcblx0XHRcdC8vIHRvay5AdmFsdWUgPSB2YWwgaWYgdmFsICMgd2h5P1xuXHRcdFx0Ly8gdG9rLkB2YWx1ZVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXHR9O1xuXHRcblx0XG5cdC8vIEFyZSB3ZSBpbiB0aGUgbWlkc3Qgb2YgYW4gdW5maW5pc2hlZCBleHByZXNzaW9uP1xuXHRMZXhlci5wcm90b3R5cGUudW5maW5pc2hlZCA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmIChMSU5FX0NPTlRJTlVFUi50ZXN0KHRoaXMuX2NodW5rKSkgeyByZXR1cm4gdHJ1ZSB9O1xuXHRcdHJldHVybiBVTkZJTklTSEVELmluZGV4T2YodGhpcy5fbGFzdFR5cCkgPj0gMDtcblx0fTtcblx0XG5cdC8vIHZhciB0b2tlbnMgPSBbJ1xcXFwnLCcuJywgJz8uJywgJ1VOQVJZJywgJ01BVEgnLCAnKycsICctJywgJ1NISUZUJywgJ1JFTEFUSU9OJywgJ0NPTVBBUkUnLCAnTE9HSUMnLCAnQ09NUE9VTkRfQVNTSUdOJywgJ1RIUk9XJywgJ0VYVEVORFMnXVxuXHRcblx0Ly8gQ29udmVydHMgbmV3bGluZXMgZm9yIHN0cmluZyBsaXRlcmFscy5cblx0TGV4ZXIucHJvdG90eXBlLmVzY2FwZUxpbmVzID0gZnVuY3Rpb24gKHN0cixoZXJlZG9jKXtcblx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoTVVMVElMSU5FUiwoaGVyZWRvYyA/ICgnXFxcXG4nKSA6ICgnJykpKTtcblx0fTtcblx0XG5cdC8vIENvbnN0cnVjdHMgYSBzdHJpbmcgdG9rZW4gYnkgZXNjYXBpbmcgcXVvdGVzIGFuZCBuZXdsaW5lcy5cblx0TGV4ZXIucHJvdG90eXBlLm1ha2VTdHJpbmcgPSBmdW5jdGlvbiAoYm9keSxxdW90ZSxoZXJlZG9jKXtcblx0XHRpZiAoIWJvZHkpIHsgcmV0dXJuIHF1b3RlICsgcXVvdGUgfTtcblx0XHRib2R5ID0gYm9keS5yZXBsYWNlKC9cXFxcKFtcXHNcXFNdKS9nLGZ1bmN0aW9uKG1hdGNoLGNvbnRlbnRzKSB7XG5cdFx0XHRyZXR1cm4gKGNvbnRlbnRzID09ICdcXG4nIHx8IGNvbnRlbnRzID09IHF1b3RlKSA/IChjb250ZW50cykgOiAobWF0Y2gpO1xuXHRcdH0pO1xuXHRcdC8vIERvZXMgbm90IHdvcmsgbm93XG5cdFx0Ym9keSA9IGJvZHkucmVwbGFjZShSZWdFeHAoKFwiXCIgKyBxdW90ZSksXCJnXCIpLCdcXFxcJCYnKTtcblx0XHRyZXR1cm4gcXVvdGUgKyB0aGlzLmVzY2FwZUxpbmVzKGJvZHksaGVyZWRvYykgKyBxdW90ZTtcblx0fTtcblx0XG5cdC8vIFRocm93cyBhIHN5bnRheCBlcnJvciBvbiB0aGUgY3VycmVudCBgQGxpbmVgLlxuXHRMZXhlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSxsZW4pe1xuXHRcdGlmICgodHlwZW9mIHRoaXMuX2xpbmU9PSdudW1iZXInfHx0aGlzLl9saW5lIGluc3RhbmNlb2YgTnVtYmVyKSkgeyBtZXNzYWdlID0gKFwiXCIgKyBtZXNzYWdlICsgXCIgb24gbGluZSBcIiArICh0aGlzLl9saW5lKSkgfTtcblx0XHRcblx0XHRpZiAobGVuKSB7XG5cdFx0XHRtZXNzYWdlICs9IChcIiBbXCIgKyAodGhpcy5fbG9jKSArIFwiOlwiICsgKHRoaXMuX2xvYyArIGxlbikgKyBcIl1cIik7XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgZXJyID0gbmV3IFN5bnRheEVycm9yKG1lc3NhZ2UpO1xuXHRcdGVyci5saW5lID0gdGhpcy5fbGluZTtcblx0XHQvLyBlcnI6Y29sdW1uTnVtYmVyXG5cdFx0ZXJyID0gbmV3IEVSUi5JbWJhUGFyc2VFcnJvcihlcnIse3Rva2VuczogdGhpcy5fdG9rZW5zLHBvczogdGhpcy5fdG9rZW5zLmxlbmd0aH0pO1xuXHRcdGVyci5yZWdpb24gPSBbdGhpcy5fbG9jLHRoaXMuX2xvYyArIChsZW4gfHwgMCldO1xuXHRcdHRocm93IGVycjtcblx0fTtcblx0cmV0dXJuIExleGVyO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21waWxlci9sZXhlci5pbWJhXG4gKiogbW9kdWxlIGlkID0gMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdHZhciBUT0ssIExCUkFDS0VULCBSQlJBQ0tFVCwgTFBBUkVOLCBSUEFSRU4sIElOREVOVCwgT1VUREVOVDtcblx0XG5cdFxuXHRtb2R1bGUuZXhwb3J0cy5UT0sgPSBUT0sgPSB7fTtcblx0dmFyIFRURVJNSU5BVE9SID0gVE9LLlRFUk1JTkFUT1IgPSAxO1xuXHR2YXIgVElERU5USUZJRVIgPSBUT0suSURFTlRJRklFUiA9IFRPSy5JVkFSID0gMjtcblx0dmFyIENPTlNUID0gVE9LLkNPTlNUID0gMztcblx0dmFyIFZBUiA9IFRPSy5WQVIgPSA0O1xuXHR2YXIgSUYgPSBUT0suSUYgPSA1O1xuXHR2YXIgRUxTRSA9IFRPSy5FTFNFID0gNjtcblx0dmFyIERFRiA9IFRPSy5ERUYgPSA3O1xuXHRcblx0ZnVuY3Rpb24gVG9rZW4odHlwZSx2YWx1ZSxsb2MsbGVuKXtcblx0XHR0aGlzLl90eXBlID0gdHlwZTtcblx0XHR0aGlzLl92YWx1ZSA9IHZhbHVlO1xuXHRcdHRoaXMuX2xvYyA9IGxvYyAhPSBudWxsID8gKGxvYykgOiAoLTEpO1xuXHRcdHRoaXMuX2xlbiA9IGxlbiB8fCAwO1xuXHRcdHRoaXMuX21ldGEgPSBudWxsO1xuXHRcdHRoaXMuZ2VuZXJhdGVkID0gZmFsc2U7XG5cdFx0dGhpcy5uZXdMaW5lID0gZmFsc2U7XG5cdFx0dGhpcy5zcGFjZWQgPSBmYWxzZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdGV4cG9ydHMuVG9rZW4gPSBUb2tlbjsgLy8gZXhwb3J0IGNsYXNzIFxuXHRUb2tlbi5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl90eXBlO1xuXHR9O1xuXHRcblx0VG9rZW4ucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3ZhbHVlO1xuXHR9O1xuXHRcblx0VG9rZW4ucHJvdG90eXBlLnRyYXZlcnNlID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuO1xuXHR9O1xuXHRcblx0VG9rZW4ucHJvdG90eXBlLmMgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gXCJcIiArIHRoaXMuX3ZhbHVlO1xuXHR9O1xuXHRcblx0VG9rZW4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3ZhbHVlO1xuXHR9O1xuXHRcblx0VG9rZW4ucHJvdG90eXBlLmNoYXJBdCA9IGZ1bmN0aW9uIChpKXtcblx0XHRyZXR1cm4gdGhpcy5fdmFsdWUuY2hhckF0KGkpO1xuXHR9O1xuXHRcblx0VG9rZW4ucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKGkpe1xuXHRcdHJldHVybiB0aGlzLl92YWx1ZS5zbGljZShpKTtcblx0fTtcblx0XG5cdFRva2VuLnByb3RvdHlwZS5yZWdpb24gPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gW3RoaXMuX2xvYyx0aGlzLl9sb2MgKyAodGhpcy5fbGVuIHx8IHRoaXMuX3ZhbHVlLmxlbmd0aCldO1xuXHR9O1xuXHRcblx0VG9rZW4ucHJvdG90eXBlLnNvdXJjZU1hcE1hcmtlciA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9sb2MgPT0gLTEgPyAoJzonKSA6ICgoXCIlJFwiICsgKHRoaXMuX2xvYykgKyBcIiQlXCIpKTtcblx0XHQvLyBAY29sID09IC0xID8gJycgOiBcIiUle0BsaW5lfSR7QGNvbH0lJVwiXG5cdH07XG5cdFxuXHRcblx0ZnVuY3Rpb24gbGV4KCl7XG5cdFx0dmFyIHRva2VuID0gdGhpcy50b2tlbnNbdGhpcy5wb3MrK107XG5cdFx0dmFyIHR0YWc7XG5cdFx0XG5cdFx0aWYgKHRva2VuKSB7XG5cdFx0XHR0dGFnID0gdG9rZW4uX3R5cGU7XG5cdFx0XHR0aGlzLnl5dGV4dCA9IHRva2VuO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0dGFnID0gJyc7XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gdHRhZztcblx0fTsgZXhwb3J0cy5sZXggPSBsZXg7XG5cdFxuXHRcblx0Ly8gZXhwb3J0IGRlZiB0b2tlbiB0eXAsIHZhbCwgbGluZSwgY29sLCBsZW4gZG8gVG9rZW4ubmV3KHR5cCx2YWwsbGluZSwgY29sIG9yIDAsIGxlbiBvciAwKSAjIFtudWxsLHR5cCx2YWwsbG9jXVxuXHRmdW5jdGlvbiB0b2tlbih0eXAsdmFsKXtcblx0XHRyZXR1cm4gbmV3IFRva2VuKHR5cCx2YWwsLTEsMCk7XG5cdH07IGV4cG9ydHMudG9rZW4gPSB0b2tlbjtcblx0XG5cdGZ1bmN0aW9uIHR5cCh0b2spe1xuXHRcdHJldHVybiB0b2suX3R5cGU7XG5cdH07IGV4cG9ydHMudHlwID0gdHlwO1xuXHRmdW5jdGlvbiB2YWwodG9rKXtcblx0XHRyZXR1cm4gdG9rLl92YWx1ZTtcblx0fTsgZXhwb3J0cy52YWwgPSB2YWw7IC8vIHRva1tvZmZzZXQgKyAxXVxuXHRmdW5jdGlvbiBsaW5lKHRvayl7XG5cdFx0cmV0dXJuIHRvay5fbGluZTtcblx0fTsgZXhwb3J0cy5saW5lID0gbGluZTsgLy8gdG9rW29mZnNldCArIDJdXG5cdGZ1bmN0aW9uIGxvYyh0b2spe1xuXHRcdHJldHVybiB0b2suX2xvYztcblx0fTsgZXhwb3J0cy5sb2MgPSBsb2M7IC8vIHRva1tvZmZzZXQgKyAyXVxuXHRcblx0ZnVuY3Rpb24gc2V0VHlwKHRvayx2KXtcblx0XHRyZXR1cm4gdG9rLl90eXBlID0gdjtcblx0fTsgZXhwb3J0cy5zZXRUeXAgPSBzZXRUeXA7XG5cdGZ1bmN0aW9uIHNldFZhbCh0b2ssdil7XG5cdFx0cmV0dXJuIHRvay5fdmFsdWUgPSB2O1xuXHR9OyBleHBvcnRzLnNldFZhbCA9IHNldFZhbDtcblx0ZnVuY3Rpb24gc2V0TGluZSh0b2ssdil7XG5cdFx0cmV0dXJuIHRvay5fbGluZSA9IHY7XG5cdH07IGV4cG9ydHMuc2V0TGluZSA9IHNldExpbmU7XG5cdGZ1bmN0aW9uIHNldExvYyh0b2ssdil7XG5cdFx0cmV0dXJuIHRvay5fbG9jID0gdjtcblx0fTsgZXhwb3J0cy5zZXRMb2MgPSBzZXRMb2M7XG5cdFxuXHRcblx0bW9kdWxlLmV4cG9ydHMuTEJSQUNLRVQgPSBMQlJBQ0tFVCA9IG5ldyBUb2tlbigneycsJ3snLDAsMCwwKTtcblx0bW9kdWxlLmV4cG9ydHMuUkJSQUNLRVQgPSBSQlJBQ0tFVCA9IG5ldyBUb2tlbignfScsJ30nLDAsMCwwKTtcblx0XG5cdG1vZHVsZS5leHBvcnRzLkxQQVJFTiA9IExQQVJFTiA9IG5ldyBUb2tlbignKCcsJygnLDAsMCwwKTtcblx0bW9kdWxlLmV4cG9ydHMuUlBBUkVOID0gUlBBUkVOID0gbmV3IFRva2VuKCcpJywnKScsMCwwLDApO1xuXHRcblx0TEJSQUNLRVQuZ2VuZXJhdGVkID0gdHJ1ZTtcblx0UkJSQUNLRVQuZ2VuZXJhdGVkID0gdHJ1ZTtcblx0TFBBUkVOLmdlbmVyYXRlZCA9IHRydWU7XG5cdFJQQVJFTi5nZW5lcmF0ZWQgPSB0cnVlO1xuXHRcblx0bW9kdWxlLmV4cG9ydHMuSU5ERU5UID0gSU5ERU5UID0gbmV3IFRva2VuKCdJTkRFTlQnLCcyJywwLDAsMCk7XG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cy5PVVRERU5UID0gT1VUREVOVCA9IG5ldyBUb2tlbignT1VUREVOVCcsJzInLDAsMCwwKTtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvY29tcGlsZXIvdG9rZW4uaW1iYVxuICoqIG1vZHVsZSBpZCA9IDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRmdW5jdGlvbiBpZHgkKGEsYil7XG5cdFx0cmV0dXJuIChiICYmIGIuaW5kZXhPZikgPyBiLmluZGV4T2YoYSkgOiBbXS5pbmRleE9mLmNhbGwoYSxiKTtcblx0fTtcblx0XG5cdGZ1bmN0aW9uIGl0ZXIkKGEpeyByZXR1cm4gYSA/IChhLnRvQXJyYXkgPyBhLnRvQXJyYXkoKSA6IGEpIDogW107IH07XG5cdHZhciBJTlZFUlNFUywgTElORUJSRUFLUztcblx0XG5cdC8vIFRoZSBJbWJhIGxhbmd1YWdlIGhhcyBhIGdvb2QgZGVhbCBvZiBvcHRpb25hbCBzeW50YXgsIGltcGxpY2l0IHN5bnRheCxcblx0Ly8gYW5kIHNob3J0aGFuZCBzeW50YXguIFRoaXMgY2FuIGdyZWF0bHkgY29tcGxpY2F0ZSBhIGdyYW1tYXIgYW5kIGJsb2F0XG5cdC8vIHRoZSByZXN1bHRpbmcgcGFyc2UgdGFibGUuIEluc3RlYWQgb2YgbWFraW5nIHRoZSBwYXJzZXIgaGFuZGxlIGl0IGFsbCwgd2UgdGFrZVxuXHQvLyBhIHNlcmllcyBvZiBwYXNzZXMgb3ZlciB0aGUgdG9rZW4gc3RyZWFtLCB1c2luZyB0aGlzICoqUmV3cml0ZXIqKiB0byBjb252ZXJ0XG5cdC8vIHNob3J0aGFuZCBpbnRvIHRoZSB1bmFtYmlndW91cyBsb25nIGZvcm0sIGFkZCBpbXBsaWNpdCBpbmRlbnRhdGlvbiBhbmRcblx0Ly8gcGFyZW50aGVzZXMsIGFuZCBnZW5lcmFsbHkgY2xlYW4gdGhpbmdzIHVwLlxuXHRcblx0dmFyIFQgPSByZXF1aXJlKCcuL3Rva2VuJyk7XG5cdHZhciBUb2tlbiA9IFQuVG9rZW47XG5cdFxuXHQvLyBCYXNlZCBvbiB0aGUgb3JpZ2luYWwgcmV3cml0ZXIuY29mZmVlIGZyb20gQ29mZmVlU2NyaXB0XG5cdGZ1bmN0aW9uIFJld3JpdGVyKCl7IH07XG5cdFxuXHRleHBvcnRzLlJld3JpdGVyID0gUmV3cml0ZXI7IC8vIGV4cG9ydCBjbGFzcyBcblx0UmV3cml0ZXIucHJvdG90eXBlLnRva2VucyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl90b2tlbnM7XG5cdH07XG5cdFxuXHQvLyBIZWxwZnVsIHNuaXBwZXQgZm9yIGRlYnVnZ2luZzpcblx0Ly8gICAgIGNvbnNvbGUubG9nICh0WzBdICsgJy8nICsgdFsxXSBmb3IgdCBpbiBAdG9rZW5zKS5qb2luICcgJ1xuXHQvLyBSZXdyaXRlIHRoZSB0b2tlbiBzdHJlYW0gaW4gbXVsdGlwbGUgcGFzc2VzLCBvbmUgbG9naWNhbCBmaWx0ZXIgYXRcblx0Ly8gYSB0aW1lLiBUaGlzIGNvdWxkIGNlcnRhaW5seSBiZSBjaGFuZ2VkIGludG8gYSBzaW5nbGUgcGFzcyB0aHJvdWdoIHRoZVxuXHQvLyBzdHJlYW0sIHdpdGggYSBiaWcgb2wnIGVmZmljaWVudCBzd2l0Y2gsIGJ1dCBpdCdzIG11Y2ggbmljZXIgdG8gd29yayB3aXRoXG5cdC8vIGxpa2UgdGhpcy4gVGhlIG9yZGVyIG9mIHRoZXNlIHBhc3NlcyBtYXR0ZXJzIC0tIGluZGVudGF0aW9uIG11c3QgYmVcblx0Ly8gY29ycmVjdGVkIGJlZm9yZSBpbXBsaWNpdCBwYXJlbnRoZXNlcyBjYW4gYmUgd3JhcHBlZCBhcm91bmQgYmxvY2tzIG9mIGNvZGUuXG5cdFJld3JpdGVyLnByb3RvdHlwZS5yZXdyaXRlID0gZnVuY3Rpb24gKHRva2VucyxvcHRzKXtcblx0XHR2YXIgdG9rZW47XG5cdFx0aWYob3B0cyA9PT0gdW5kZWZpbmVkKSBvcHRzID0ge307XG5cdFx0dGhpcy5fdG9rZW5zID0gdG9rZW5zO1xuXHRcdHRoaXMuX29wdGlvbnMgPSBvcHRzO1xuXHRcdFxuXHRcdC8vIGNvbnNvbGUubG9nIFwidG9rZW5zIGluOiBcIiArIHRva2VuczpsZW5ndGhcblx0XHRpZiAob3B0cy5wcm9maWxlKSB7IGNvbnNvbGUudGltZShcInRva2VuaXplOnJld3JpdGVcIikgfTtcblx0XHRcblx0XHR2YXIgaSA9IDA7XG5cdFx0Ly8gZmxhZyBlbXB0eSBtZXRob2RzXG5cdFx0d2hpbGUgKHRva2VuID0gdG9rZW5zW2ldKXtcblx0XHRcdHZhciBuZXh0ID0gdG9rZW5zW2kgKyAxXTtcblx0XHRcdGlmICh0b2tlbi5fdHlwZSA9PSAnREVGX0JPRFknICYmIG5leHQgJiYgbmV4dC5fdHlwZSA9PSAnVEVSTUlOQVRPUicpIHtcblx0XHRcdFx0dG9rZW4uX3R5cGUgPSAnREVGX0VNUFRZJztcblx0XHRcdH07XG5cdFx0XHRpKys7XG5cdFx0fTtcblx0XHRcblx0XHR0aGlzLnN0ZXAoXCJlbnN1cmVGaXJzdExpbmVcIik7XG5cdFx0dGhpcy5zdGVwKFwicmVtb3ZlTGVhZGluZ05ld2xpbmVzXCIpO1xuXHRcdHRoaXMuc3RlcChcInJlbW92ZU1pZEV4cHJlc3Npb25OZXdsaW5lc1wiKTtcblx0XHR0aGlzLnN0ZXAoXCJ0YWdEZWZBcmd1bWVudHNcIik7XG5cdFx0dGhpcy5zdGVwKFwiY2xvc2VPcGVuQ2FsbHNcIik7XG5cdFx0dGhpcy5zdGVwKFwiY2xvc2VPcGVuSW5kZXhlc1wiKTtcblx0XHR0aGlzLnN0ZXAoXCJjbG9zZU9wZW5UYWdzXCIpO1xuXHRcdHRoaXMuc3RlcChcImNsb3NlT3BlblRhZ0F0dHJMaXN0c1wiKTtcblx0XHR0aGlzLnN0ZXAoXCJhZGRJbXBsaWNpdEluZGVudGF0aW9uXCIpO1xuXHRcdHRoaXMuc3RlcChcInRhZ1Bvc3RmaXhDb25kaXRpb25hbHNcIik7XG5cdFx0dGhpcy5zdGVwKFwiYWRkSW1wbGljaXRCcmFjZXNcIik7XG5cdFx0dGhpcy5zdGVwKFwiYWRkSW1wbGljaXRQYXJlbnRoZXNlc1wiKTtcblx0XHRcblx0XHRpZiAob3B0cy5wcm9maWxlKSB7IGNvbnNvbGUudGltZUVuZChcInRva2VuaXplOnJld3JpdGVcIikgfTtcblx0XHQvLyBjb25zb2xlLmxvZyBcInRva2VucyBvdXQ6IFwiICsgQHRva2VuczpsZW5ndGhcblx0XHRyZXR1cm4gdGhpcy5fdG9rZW5zO1xuXHR9O1xuXHRcblx0UmV3cml0ZXIucHJvdG90eXBlLnN0ZXAgPSBmdW5jdGlvbiAoZm4pe1xuXHRcdGlmICh0aGlzLl9vcHRpb25zLnByb2ZpbGUpIHtcblx0XHRcdGNvbnNvbGUubG9nKChcIi0tLS0gc3RhcnRpbmcgXCIgKyBmbiArIFwiIC0tLS0gXCIpKTtcblx0XHRcdGNvbnNvbGUudGltZShmbik7XG5cdFx0fTtcblx0XHRcblx0XHR0aGlzW2ZuXSgpO1xuXHRcdFxuXHRcdGlmICh0aGlzLl9vcHRpb25zLnByb2ZpbGUpIHtcblx0XHRcdGNvbnNvbGUudGltZUVuZChmbik7XG5cdFx0XHRjb25zb2xlLmxvZyhcIlxcblxcblwiKTtcblx0XHR9O1xuXHRcdHJldHVybjtcblx0fTtcblx0XG5cdC8vIFJld3JpdGUgdGhlIHRva2VuIHN0cmVhbSwgbG9va2luZyBvbmUgdG9rZW4gYWhlYWQgYW5kIGJlaGluZC5cblx0Ly8gQWxsb3cgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgYmxvY2sgdG8gdGVsbCB1cyBob3cgbWFueSB0b2tlbnMgdG8gbW92ZVxuXHQvLyBmb3J3YXJkcyAob3IgYmFja3dhcmRzKSBpbiB0aGUgc3RyZWFtLCB0byBtYWtlIHN1cmUgd2UgZG9uJ3QgbWlzcyBhbnl0aGluZ1xuXHQvLyBhcyB0b2tlbnMgYXJlIGluc2VydGVkIGFuZCByZW1vdmVkLCBhbmQgdGhlIHN0cmVhbSBjaGFuZ2VzIGxlbmd0aCB1bmRlclxuXHQvLyBvdXIgZmVldC5cblx0UmV3cml0ZXIucHJvdG90eXBlLnNjYW5Ub2tlbnMgPSBmdW5jdGlvbiAoYmxvY2spe1xuXHRcdHZhciB0b2tlbjtcblx0XHR2YXIgdG9rZW5zID0gdGhpcy5fdG9rZW5zO1xuXHRcdFxuXHRcdHZhciBpID0gMDtcblx0XHR3aGlsZSAodG9rZW4gPSB0b2tlbnNbaV0pe1xuXHRcdFx0aSArPSBibG9jay5jYWxsKHRoaXMsdG9rZW4saSx0b2tlbnMpO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cdFxuXHRSZXdyaXRlci5wcm90b3R5cGUuZGV0ZWN0RW5kID0gZnVuY3Rpb24gKGksY29uZGl0aW9uLGFjdGlvbil7XG5cdFx0dmFyIHRva2VucyA9IHRoaXMuX3Rva2Vucztcblx0XHR2YXIgbGV2ZWxzID0gMDtcblx0XHR2YXIgc3RhcnRzID0gW107XG5cdFx0dmFyIHRva2VuO1xuXHRcdHZhciB0LHY7XG5cdFx0XG5cdFx0d2hpbGUgKHRva2VuID0gdG9rZW5zW2ldKXtcblx0XHRcdGlmIChsZXZlbHMgPT0gMCAmJiBjb25kaXRpb24uY2FsbCh0aGlzLHRva2VuLGksc3RhcnRzKSkge1xuXHRcdFx0XHRyZXR1cm4gYWN0aW9uLmNhbGwodGhpcyx0b2tlbixpKTtcblx0XHRcdH07XG5cdFx0XHRpZiAoIXRva2VuIHx8IGxldmVscyA8IDApIHtcblx0XHRcdFx0cmV0dXJuIGFjdGlvbi5jYWxsKHRoaXMsdG9rZW4saSAtIDEpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dCA9IFQudHlwKHRva2VuKTtcblx0XHRcdFxuXHRcdFx0aWYgKEVYUFJFU1NJT05fU1RBUlQuaW5kZXhPZih0KSA+PSAwKSB7XG5cdFx0XHRcdGlmIChsZXZlbHMgPT0gMCkgeyBzdGFydHMucHVzaChpKSB9O1xuXHRcdFx0XHRsZXZlbHMgKz0gMTtcblx0XHRcdH0gZWxzZSBpZiAoRVhQUkVTU0lPTl9FTkQuaW5kZXhPZih0KSA+PSAwKSB7XG5cdFx0XHRcdGxldmVscyAtPSAxO1xuXHRcdFx0fTtcblx0XHRcdGkgKz0gMTtcblx0XHR9O1xuXHRcdHJldHVybiBpIC0gMTtcblx0fTtcblx0XG5cdFJld3JpdGVyLnByb3RvdHlwZS5lbnN1cmVGaXJzdExpbmUgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgdG9rID0gdGhpcy5fdG9rZW5zWzBdO1xuXHRcdFxuXHRcdGlmIChULnR5cCh0b2spID09ICdURVJNSU5BVE9SJykge1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgXCJhZGRpbmcgYm9keXN0YXJ0XCJcblx0XHRcdHRoaXMuX3Rva2VucyA9IFtULnRva2VuKCdCT0RZU1RBUlQnLCdCT0RZU1RBUlQnKV0uY29uY2F0KHRoaXMuX3Rva2Vucyk7XG5cdFx0XHQvLyBULnNldFR5cCh0b2ssJ0hFQURFUicpXG5cdFx0fTtcblx0XHRyZXR1cm47XG5cdH07XG5cdFxuXHQvLyBMZWFkaW5nIG5ld2xpbmVzIHdvdWxkIGludHJvZHVjZSBhbiBhbWJpZ3VpdHkgaW4gdGhlIGdyYW1tYXIsIHNvIHdlXG5cdC8vIGRpc3BhdGNoIHRoZW0gaGVyZS5cblx0UmV3cml0ZXIucHJvdG90eXBlLnJlbW92ZUxlYWRpbmdOZXdsaW5lcyA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBhdCA9IDA7XG5cdFx0XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHRoaXMuX3Rva2VucyksIGxlbiA9IGFyeS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKFQudHlwKGFyeVtpXSkgIT0gJ1RFUk1JTkFUT1InKSB7XG5cdFx0XHRcdGF0ID0gaTticmVhaztcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoYXQpIHsgdGhpcy5fdG9rZW5zLnNwbGljZSgwLGF0KSB9O1xuXHRcdFxuXHRcdHJldHVybjtcblx0fTtcblx0XG5cdC8vIFNvbWUgYmxvY2tzIG9jY3VyIGluIHRoZSBtaWRkbGUgb2YgZXhwcmVzc2lvbnMgLS0gd2hlbiB3ZSdyZSBleHBlY3Rpbmdcblx0Ly8gdGhpcywgcmVtb3ZlIHRoZWlyIHRyYWlsaW5nIG5ld2xpbmVzLlxuXHRSZXdyaXRlci5wcm90b3R5cGUucmVtb3ZlTWlkRXhwcmVzc2lvbk5ld2xpbmVzID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHJldHVybiBzZWxmLnNjYW5Ub2tlbnMoZnVuY3Rpb24odG9rZW4saSx0b2tlbnMpIHsgLy8gZG8gfHRva2VuLGksdG9rZW5zfFxuXHRcdFx0dmFyIG5leHQgPSBzZWxmLnRva2VuVHlwZShpICsgMSk7XG5cdFx0XHRcblx0XHRcdGlmICghKFQudHlwKHRva2VuKSA9PSAnVEVSTUlOQVRPUicgJiYgRVhQUkVTU0lPTl9DTE9TRS5pbmRleE9mKG5leHQpID49IDApKSB7IHJldHVybiAxIH07XG5cdFx0XHRpZiAobmV4dCA9PSAnT1VUREVOVCcpIHsgcmV0dXJuIDEgfTtcblx0XHRcdHRva2Vucy5zcGxpY2UoaSwxKTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH0pO1xuXHR9O1xuXHRcblx0XG5cdFJld3JpdGVyLnByb3RvdHlwZS50YWdEZWZBcmd1bWVudHMgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblx0XG5cdC8vIFRoZSBsZXhlciBoYXMgdGFnZ2VkIHRoZSBvcGVuaW5nIHBhcmVudGhlc2lzIG9mIGEgbWV0aG9kIGNhbGwuIE1hdGNoIGl0IHdpdGhcblx0Ly8gaXRzIHBhaXJlZCBjbG9zZS4gV2UgaGF2ZSB0aGUgbWlzLW5lc3RlZCBvdXRkZW50IGNhc2UgaW5jbHVkZWQgaGVyZSBmb3Jcblx0Ly8gY2FsbHMgdGhhdCBjbG9zZSBvbiB0aGUgc2FtZSBsaW5lLCBqdXN0IGJlZm9yZSB0aGVpciBvdXRkZW50LlxuXHRSZXdyaXRlci5wcm90b3R5cGUuY2xvc2VPcGVuQ2FsbHMgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0dmFyIGNvbmRpdGlvbiA9IGZ1bmN0aW9uKHRva2VuLGkpIHtcblx0XHRcdHZhciB0ID0gVC50eXAodG9rZW4pO1xuXHRcdFx0cmV0dXJuICh0ID09ICcpJyB8fCB0ID09ICdDQUxMX0VORCcpIHx8IHQgPT0gJ09VVERFTlQnICYmIHNlbGYudG9rZW5UeXBlKGkgLSAxKSA9PSAnKSc7XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgYWN0aW9uID0gZnVuY3Rpb24odG9rZW4saSkge1xuXHRcdFx0dmFyIHQgPSBULnR5cCh0b2tlbik7XG5cdFx0XHR2YXIgdG9rID0gc2VsZi5fdG9rZW5zW3QgPT0gJ09VVERFTlQnID8gKGkgLSAxKSA6IChpKV07XG5cdFx0XHRyZXR1cm4gVC5zZXRUeXAodG9rLCdDQUxMX0VORCcpO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHNlbGYuc2NhblRva2VucyhmdW5jdGlvbih0b2tlbixpKSB7XG5cdFx0XHRpZiAoVC50eXAodG9rZW4pID09ICdDQUxMX1NUQVJUJykgeyBzZWxmLmRldGVjdEVuZChpICsgMSxjb25kaXRpb24sYWN0aW9uKSB9O1xuXHRcdFx0cmV0dXJuIDE7XG5cdFx0fSk7XG5cdH07XG5cdFxuXHQvLyBUaGUgbGV4ZXIgaGFzIHRhZ2dlZCB0aGUgb3BlbmluZyBwYXJlbnRoZXNpcyBvZiBhbiBpbmRleGluZyBvcGVyYXRpb24gY2FsbC5cblx0Ly8gTWF0Y2ggaXQgd2l0aCBpdHMgcGFpcmVkIGNsb3NlLlxuXHRSZXdyaXRlci5wcm90b3R5cGUuY2xvc2VPcGVuSW5kZXhlcyA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR2YXIgY29uZGl0aW9uID0gZnVuY3Rpb24odG9rZW4saSkgeyByZXR1cm4gaWR4JChULnR5cCh0b2tlbiksWyddJywnSU5ERVhfRU5EJ10pID49IDA7IH07XG5cdFx0dmFyIGFjdGlvbiA9IGZ1bmN0aW9uKHRva2VuLGkpIHsgcmV0dXJuIFQuc2V0VHlwKHRva2VuLCdJTkRFWF9FTkQnKTsgfTtcblx0XHRcblx0XHRyZXR1cm4gc2VsZi5zY2FuVG9rZW5zKGZ1bmN0aW9uKHRva2VuLGkpIHtcblx0XHRcdGlmIChULnR5cCh0b2tlbikgPT0gJ0lOREVYX1NUQVJUJykgeyBzZWxmLmRldGVjdEVuZChpICsgMSxjb25kaXRpb24sYWN0aW9uKSB9O1xuXHRcdFx0cmV0dXJuIDE7XG5cdFx0fSk7XG5cdH07XG5cdFxuXHRcblx0UmV3cml0ZXIucHJvdG90eXBlLmNsb3NlT3BlblRhZ0F0dHJMaXN0cyA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR2YXIgY29uZGl0aW9uID0gZnVuY3Rpb24odG9rZW4saSkgeyByZXR1cm4gaWR4JChULnR5cCh0b2tlbiksWycpJywnVEFHX0FUVFJTX0VORCddKSA+PSAwOyB9O1xuXHRcdHZhciBhY3Rpb24gPSBmdW5jdGlvbih0b2tlbixpKSB7IHJldHVybiBULnNldFR5cCh0b2tlbiwnVEFHX0FUVFJTX0VORCcpOyB9OyAvLyAnVEFHX0FUVFJTX0VORCdcblx0XHRcblx0XHRyZXR1cm4gc2VsZi5zY2FuVG9rZW5zKGZ1bmN0aW9uKHRva2VuLGkpIHtcblx0XHRcdGlmIChULnR5cCh0b2tlbikgPT0gJ1RBR19BVFRSU19TVEFSVCcpIHsgc2VsZi5kZXRlY3RFbmQoaSArIDEsY29uZGl0aW9uLGFjdGlvbikgfTtcblx0XHRcdHJldHVybiAxO1xuXHRcdH0pO1xuXHR9O1xuXHRcblx0Ly8gVGhlIGxleGVyIGhhcyB0YWdnZWQgdGhlIG9wZW5pbmcgcGFyZW50aGVzaXMgb2YgYW4gaW5kZXhpbmcgb3BlcmF0aW9uIGNhbGwuXG5cdC8vIE1hdGNoIGl0IHdpdGggaXRzIHBhaXJlZCBjbG9zZS4gU2hvdWxkIGJlIGRvbmUgaW4gbGV4ZXIgZGlyZWN0bHlcblx0UmV3cml0ZXIucHJvdG90eXBlLmNsb3NlT3BlblRhZ3MgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0dmFyIGNvbmRpdGlvbiA9IGZ1bmN0aW9uKHRva2VuLGkpIHsgcmV0dXJuIGlkeCQoVC50eXAodG9rZW4pLFsnPicsJ1RBR19FTkQnXSkgPj0gMDsgfTtcblx0XHR2YXIgYWN0aW9uID0gZnVuY3Rpb24odG9rZW4saSkgeyByZXR1cm4gVC5zZXRUeXAodG9rZW4sJ1RBR19FTkQnKTsgfTsgLy8gdG9rZW5bMF0gPSAnVEFHX0VORCdcblx0XHRcblx0XHRyZXR1cm4gc2VsZi5zY2FuVG9rZW5zKGZ1bmN0aW9uKHRva2VuLGkpIHtcblx0XHRcdGlmIChULnR5cCh0b2tlbikgPT0gJ1RBR19TVEFSVCcpIHsgc2VsZi5kZXRlY3RFbmQoaSArIDEsY29uZGl0aW9uLGFjdGlvbikgfTtcblx0XHRcdHJldHVybiAxO1xuXHRcdH0pO1xuXHR9O1xuXHRcblx0UmV3cml0ZXIucHJvdG90eXBlLmFkZEltcGxpY2l0Q29tbWFzID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuO1xuXHR9O1xuXHRcblx0UmV3cml0ZXIucHJvdG90eXBlLmFkZEltcGxpY2l0QmxvY2tDYWxscyA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciB0b2tlbjtcblx0XHR2YXIgaSA9IDE7XG5cdFx0dmFyIHRva2VucyA9IHRoaXMuX3Rva2Vucztcblx0XHRcblx0XHR3aGlsZSAodG9rZW4gPSB0b2tlbnNbaV0pe1xuXHRcdFx0dmFyIHQgPSB0b2tlbi5fdHlwZTtcblx0XHRcdHZhciB2ID0gdG9rZW4uX3ZhbHVlO1xuXHRcdFx0Ly8gaG1tXG5cdFx0XHRpZiAodCA9PSAnRE8nICYmICh2ID09ICdJTkRFWF9FTkQnIHx8IHYgPT0gJ0lERU5USUZJRVInIHx8IHYgPT0gJ05FVycpKSB7XG5cdFx0XHRcdHRva2Vucy5zcGxpY2UoaSArIDEsMCxULnRva2VuKCdDQUxMX0VORCcsJyknKSk7XG5cdFx0XHRcdHRva2Vucy5zcGxpY2UoaSArIDEsMCxULnRva2VuKCdDQUxMX1NUQVJUJywnKCcpKTtcblx0XHRcdFx0aSsrO1xuXHRcdFx0fTtcblx0XHRcdGkrKztcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybjtcblx0fTtcblx0XG5cdC8vIE9iamVjdCBsaXRlcmFscyBtYXkgYmUgd3JpdHRlbiB3aXRoIGltcGxpY2l0IGJyYWNlcywgZm9yIHNpbXBsZSBjYXNlcy5cblx0Ly8gSW5zZXJ0IHRoZSBtaXNzaW5nIGJyYWNlcyBoZXJlLCBzbyB0aGF0IHRoZSBwYXJzZXIgZG9lc24ndCBoYXZlIHRvLlxuXHRSZXdyaXRlci5wcm90b3R5cGUuYWRkSW1wbGljaXRCcmFjZXMgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0dmFyIHN0YWNrID0gW107XG5cdFx0dmFyIHN0YXJ0ID0gbnVsbDtcblx0XHR2YXIgc3RhcnRJbmRlbnQgPSAwO1xuXHRcdHZhciBzdGFydElkeCA9IG51bGw7XG5cdFx0XG5cdFx0dmFyIG5vQnJhY2VUYWcgPSBbJ0NMQVNTJywnSUYnLCdVTkxFU1MnLCdUQUcnLCdXSElMRScsJ0ZPUicsJ1VOVElMJywnQ0FUQ0gnLCdGSU5BTExZJywnTU9EVUxFJywnTEVBRElOR19XSEVOJ107XG5cdFx0dmFyIG5vQnJhY2VDb250ZXh0ID0gWydJRicsJ1RFUk5BUlknLCdGT1InXTtcblx0XHRcblx0XHR2YXIgbm9CcmFjZSA9IGZhbHNlO1xuXHRcdFxuXHRcdHZhciBzY29wZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdIHx8IFtdO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIGFjdGlvbiA9IGZ1bmN0aW9uKHRva2VuLGkpIHtcblx0XHRcdHJldHVybiBzZWxmLl90b2tlbnMuc3BsaWNlKGksMCxULlJCUkFDS0VUKTtcblx0XHR9O1xuXHRcdFxuXHRcdHZhciBvcGVuID0gZnVuY3Rpb24odG9rZW4saSkge1xuXHRcdFx0cmV0dXJuIHNlbGYuX3Rva2Vucy5zcGxpY2UoaSwwLFQuTEJSQUNLRVQpO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIGNsb3NlID0gZnVuY3Rpb24odG9rZW4saSkge1xuXHRcdFx0cmV0dXJuIHNlbGYuX3Rva2Vucy5zcGxpY2UoaSwwLFQuUkJSQUNLRVQpO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIHN0YWNrVG9rZW4gPSBmdW5jdGlvbihhLGIpIHtcblx0XHRcdHJldHVybiBbYSxiXTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiBzZWxmLnNjYW5Ub2tlbnMoZnVuY3Rpb24odG9rZW4saSx0b2tlbnMpIHtcblx0XHRcdHZhciB0eXBlID0gVC50eXAodG9rZW4pO1xuXHRcdFx0dmFyIHYgPSBULnZhbCh0b2tlbik7XG5cdFx0XHR2YXIgY3R4ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gfHwgW107XG5cdFx0XHR2YXIgaWR4O1xuXHRcdFx0XG5cdFx0XHRpZiAobm9CcmFjZUNvbnRleHQuaW5kZXhPZih0eXBlKSA+PSAwKSB7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nIFwiZm91bmQgbm9CcmFjZVRhZyB7dHlwZX1cIlxuXHRcdFx0XHRzdGFjay5wdXNoKHN0YWNrVG9rZW4odHlwZSxpKSk7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKHYgPT0gJz8nKSB7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKCdURVJOQVJZIE9QRVJBVE9SIScpXG5cdFx0XHRcdHN0YWNrLnB1c2goc3RhY2tUb2tlbignVEVSTkFSWScsaSkpO1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8vIG5vIG5lZWQgdG8gdGVzdCBmb3IgdGhpcyBoZXJlIGFzIHdlbGwgYXMgaW5cblx0XHRcdGlmIChFWFBSRVNTSU9OX1NUQVJULmluZGV4T2YodHlwZSkgPj0gMCkge1xuXHRcdFx0XHRpZiAodHlwZSA9PSAnSU5ERU5UJyAmJiBub0JyYWNlQ29udGV4dC5pbmRleE9mKGN0eFswXSkgPj0gMCkge1xuXHRcdFx0XHRcdHN0YWNrLnBvcCgpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coJ2V4cHJlc3Npb24gc3RhcnQnLHR5cGUsY3R4WzBdKVxuXHRcdFx0XHRpZiAodHlwZSA9PSAnSU5ERU5UJyAmJiBzZWxmLnRva2VuVHlwZShpIC0gMSkgPT0gJ3snKSB7XG5cdFx0XHRcdFx0Ly8gc3RhY2sgPyE/IG5vIHRva2VuXG5cdFx0XHRcdFx0c3RhY2sucHVzaChzdGFja1Rva2VuKCd7JyxpKSk7IC8vIHNob3VsZCBub3QgYXV0b2dlbmVyYXRlIGFub3RoZXI/XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3RhY2sucHVzaChzdGFja1Rva2VuKHR5cGUsaSkpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChFWFBSRVNTSU9OX0VORC5pbmRleE9mKHR5cGUpID49IDApIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgXCJFWFBSRVNTSU9OX0VORCBhdCB7dHlwZX0gLSBzdGFjayBpcyB7Y3R4WzBdfVwiXG5cdFx0XHRcdGlmIChjdHhbMF0gPT0gJ1RFUk5BUlknKSB7IC8vIEZJWD9cblx0XHRcdFx0XHRzdGFjay5wb3AoKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdHN0YXJ0ID0gc3RhY2sucG9wKCk7XG5cdFx0XHRcdGlmICghc3RhcnQpIHtcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhcIk5PIFNUQUNLISFcIik7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHN0YXJ0WzJdID0gaTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIHNlZW1zIGxpa2UgdGhlIHN0YWNrIHNob3VsZCB1c2UgdG9rZW5zLCBubz8pXG5cdFx0XHRcdGlmIChzdGFydFswXSA9PSAneycgJiYgc3RhcnQuZ2VuZXJhdGVkKSB7IC8vICAjIHR5cGUgIT0gJ30nICMgYW5kIHN0YXJ0OmdlbmVyYXRlZFxuXHRcdFx0XHRcdGNsb3NlKHRva2VuLGkpO1xuXHRcdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHQvLyBpcyB0aGlzIGNvcnJlY3Q/IHNhbWUgZm9yIGlmL2NsYXNzIGV0Yz9cblx0XHRcdGlmIChjdHhbMF0gPT0gJ1RFUk5BUlknICYmICh0eXBlID09ICdURVJNSU5BVE9SJyB8fCB0eXBlID09ICdPVVRERU5UJykpIHtcblx0XHRcdFx0c3RhY2sucG9wKCk7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKG5vQnJhY2VDb250ZXh0LmluZGV4T2YoY3R4WzBdKSA+PSAwICYmIHR5cGUgPT0gJ0lOREVOVCcpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coXCJwb3BwaW5nIG5vQnJhY2VDb250ZXh0XCIpO1xuXHRcdFx0XHRzdGFjay5wb3AoKTtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRcblx0XHRcdGlmICh0eXBlID09ICcsJykge1xuXHRcdFx0XHQvLyBhdXRvbWF0aWNhbGx5IGFkZCBhbiBlbmRpbmcgaGVyZSBpZiBpbnNpZGU6Z2VuZXJhdGVkIHNjb3BlP1xuXHRcdFx0XHQvLyBpdCBpcyBpbXBvcnRhbnQgdGhhdCB0aGlzIGlzOmdlbmVyYXRlZCghKVxuXHRcdFx0XHRpZiAoY3R4WzBdID09ICd7JyAmJiBjdHguZ2VuZXJhdGVkKSB7XG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZShpLDAsVC5SQlJBQ0tFVCk7XG5cdFx0XHRcdFx0c3RhY2sucG9wKCk7XG5cdFx0XHRcdFx0cmV0dXJuIDI7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHRydWU7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHQvLyBmb3VuZCBhIHR5cGVcblx0XHRcdGlmICh0eXBlID09ICc6JyAmJiBjdHhbMF0gIT0gJ3snICYmIGN0eFswXSAhPSAnVEVSTkFSWScgJiYgKG5vQnJhY2VDb250ZXh0LmluZGV4T2YoY3R4WzBdKSA9PSAtMSkpIHtcblx0XHRcdFx0Ly8gY291bGQganVzdCBjaGVjayBpZiB0aGUgZW5kIHdhcyByaWdodCBiZWZvcmUgdGhpcz9cblx0XHRcdFx0XG5cdFx0XHRcdGlmIChzdGFydCAmJiBzdGFydFsyXSA9PSBpIC0gMSkge1xuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKCd0aGlzIGV4cHJlc3Npb24gd2FzIGp1c3QgZW5kaW5nIGJlZm9yZSBjb2xvbiEnKVxuXHRcdFx0XHRcdGlkeCA9IHN0YXJ0WzFdIC0gMTsgLy8gdGhlc2UgYXJlIHRoZSBzdGFja1Rva2Vuc1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nIFwicmV3cml0ZSBoZXJlPyAje2l9XCJcblx0XHRcdFx0XHRpZHggPSBpIC0gMjsgLy8gaWYgc3RhcnQgdGhlbiBzdGFydFsxXSAtIDEgZWxzZSBpIC0gMlxuXHRcdFx0XHRcdC8vIGlkeCA9IGlkeCAtIDEgaWYgdG9rZW5UeXBlKGlkeCkgaXMgJ1RFUk1JTkFUT1InXG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHR3aGlsZSAoc2VsZi50b2tlblR5cGUoaWR4IC0gMSkgPT0gJ0hFUkVDT01NRU5UJyl7XG5cdFx0XHRcdFx0aWR4IC09IDI7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHR2YXIgdDAgPSB0b2tlbnNbaWR4IC0gMV07XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAodDAgJiYgVC50eXAodDApID09ICd9JyAmJiB0MC5nZW5lcmF0ZWQpIHtcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKGlkeCAtIDEsMSk7XG5cdFx0XHRcdFx0dmFyIHMgPSBzdGFja1Rva2VuKCd7Jyk7XG5cdFx0XHRcdFx0cy5nZW5lcmF0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdHN0YWNrLnB1c2gocyk7XG5cdFx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHRcdH0gZWxzZSBpZiAodDAgJiYgVC50eXAodDApID09ICcsJyAmJiBzZWxmLnRva2VuVHlwZShpZHggLSAyKSA9PSAnfScpIHtcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKGlkeCAtIDIsMSk7XG5cdFx0XHRcdFx0cyA9IHN0YWNrVG9rZW4oJ3snKTtcblx0XHRcdFx0XHRzLmdlbmVyYXRlZCA9IHRydWU7XG5cdFx0XHRcdFx0c3RhY2sucHVzaChzKTtcblx0XHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzID0gc3RhY2tUb2tlbigneycpO1xuXHRcdFx0XHRcdHMuZ2VuZXJhdGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRzdGFjay5wdXNoKHMpO1xuXHRcdFx0XHRcdG9wZW4odG9rZW4saWR4ICsgMSk7XG5cdFx0XHRcdFx0cmV0dXJuIDI7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHQvLyB3ZSBwcm9iYWJseSBuZWVkIHRvIHJ1biB0aHJvdWdoIGF1dG9jYWxsIGZpcnN0PyFcblx0XHRcdFxuXHRcdFx0aWYgKHR5cGUgPT0gJ0RPJykgeyAvLyBhbmQgY3R4OmdlbmVyYXRlZFxuXHRcdFx0XHR2YXIgcHJldiA9IFQudHlwKHRva2Vuc1tpIC0gMV0pOyAvLyBbMF1cblx0XHRcdFx0aWYgKFsnTlVNQkVSJywnU1RSSU5HJywnUkVHRVgnLCdTWU1CT0wnLCddJywnfScsJyknLCdTVFJJTkdfRU5EJ10uaW5kZXhPZihwcmV2KSA+PSAwKSB7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0dmFyIHRvayA9IFQudG9rZW4oJywnLCcsJyk7XG5cdFx0XHRcdFx0dG9rLmdlbmVyYXRlZCA9IHRydWU7XG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZShpLDAsdG9rKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoY3R4LmdlbmVyYXRlZCkge1xuXHRcdFx0XHRcdFx0Y2xvc2UodG9rZW4saSk7XG5cdFx0XHRcdFx0XHRzdGFjay5wb3AoKTtcblx0XHRcdFx0XHRcdHJldHVybiAyO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAoKHR5cGUgPT0gJ1RFUk1JTkFUT1InIHx8IHR5cGUgPT0gJ09VVERFTlQnIHx8IHR5cGUgPT0gJ0RFRl9CT0RZJykgJiYgY3R4LmdlbmVyYXRlZCkge1xuXHRcdFx0XHRjbG9zZSh0b2tlbixpKTtcblx0XHRcdFx0c3RhY2sucG9wKCk7XG5cdFx0XHRcdHJldHVybiAyO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIDE7XG5cdFx0fSk7XG5cdH07XG5cdFxuXHQvLyBNZXRob2RzIG1heSBiZSBvcHRpb25hbGx5IGNhbGxlZCB3aXRob3V0IHBhcmVudGhlc2VzLCBmb3Igc2ltcGxlIGNhc2VzLlxuXHQvLyBJbnNlcnQgdGhlIGltcGxpY2l0IHBhcmVudGhlc2VzIGhlcmUsIHNvIHRoYXQgdGhlIHBhcnNlciBkb2Vzbid0IGhhdmUgdG9cblx0Ly8gZGVhbCB3aXRoIHRoZW0uXG5cdC8vIFByYWN0aWNhbGx5IGV2ZXJ5dGhpbmcgd2lsbCBub3cgYmUgY2FsbGFibGUgdGhpcyB3YXkgKGV2ZXJ5IGlkZW50aWZpZXIpXG5cdFJld3JpdGVyLnByb3RvdHlwZS5hZGRJbXBsaWNpdFBhcmVudGhlc2VzID0gZnVuY3Rpb24gKCl7XG5cdFx0XG5cdFx0dmFyIHNlbGYgPSB0aGlzLCB0b2tlbjtcblx0XHR2YXIgbm9DYWxsVGFnID0gWydDTEFTUycsJ0lGJywnVU5MRVNTJywnVEFHJywnV0hJTEUnLCdGT1InLCdVTlRJTCcsJ0NBVENIJywnRklOQUxMWScsJ01PRFVMRScsJ0xFQURJTkdfV0hFTiddO1xuXHRcdFxuXHRcdHZhciBhY3Rpb24gPSBmdW5jdGlvbih0b2tlbixpKSB7XG5cdFx0XHRyZXR1cm4gc2VsZi5fdG9rZW5zLnNwbGljZShpLDAsVC50b2tlbignQ0FMTF9FTkQnLCcpJykpO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gY29uc29sZS5sb2cgXCJhZGRpbmcgaW1wbGljaXQgcGFyZW50aGVzaXNcIiAjICxzZWxmOnNjYW5Ub2tlbnNcblx0XHR2YXIgdG9rZW5zID0gc2VsZi5fdG9rZW5zO1xuXHRcdFxuXHRcdHZhciBub0NhbGwgPSBmYWxzZTtcblx0XHR2YXIgc2VlbkZvciA9IGZhbHNlO1xuXHRcdHZhciBlbmRDYWxsQXRUZXJtaW5hdG9yID0gZmFsc2U7XG5cdFx0XG5cdFx0dmFyIGkgPSAwO1xuXHRcdHdoaWxlICh0b2tlbiA9IHRva2Vuc1tpXSl7XG5cdFx0XHRcblx0XHRcdC8vIHRvIGhhbmRsZSBjYXNlcyBsaWtlOlxuXHRcdFx0Ly8gaWYgYShkbyB5ZXMpLnRlc3Rcblx0XHRcdC8vIFx0eWVzXG5cdFx0XHQvLyB3ZSBuZWVkIHRvIGtlZXAgYSBzdGFjayBmb3IgYmFsYW5jZWQgcGFpcnNcblx0XHRcdC8vIHVudGlsIHRoZW4geW91IG11c3QgZXhwbGljaXRseSBlbmQgdGhlIGNhbGwgbGlrZVxuXHRcdFx0Ly8gaWYgYShkbyB5ZXMpLnRlc3QoKVxuXHRcdFx0Ly8gXHR5ZXNcblx0XHRcdFxuXHRcdFx0dmFyIHR5cGUgPSB0b2tlbi5fdHlwZTtcblx0XHRcdFxuXHRcdFx0dmFyIHByZXYgPSB0b2tlbnNbaSAtIDFdO1xuXHRcdFx0dmFyIGN1cnJlbnQgPSB0b2tlbnNbaV07XG5cdFx0XHR2YXIgbmV4dCA9IHRva2Vuc1tpICsgMV07XG5cdFx0XHRcblx0XHRcdHZhciBwdCA9IHByZXYgJiYgcHJldi5fdHlwZTtcblx0XHRcdHZhciBudCA9IG5leHQgJiYgbmV4dC5fdHlwZTtcblx0XHRcdFxuXHRcdFx0Ly8gaWYgcHQgPT0gJ1dIRU4nXG5cdFx0XHQvLyBOZXZlciBtYWtlIHRoZXNlIHRhZ3MgaW1wbGljaXRseSBjYWxsXG5cdFx0XHQvLyBzaG91bGQgd2Ugbm90IGp1c3QgcmVtb3ZlIHRoZXNlIGZyb20gSU1QTElDSVRfRlVOQz9cblx0XHRcdGlmICgocHQgPT0gJyknIHx8IHB0ID09ICddJykgJiYgdHlwZSA9PSAnSU5ERU5UJykge1xuXHRcdFx0XHRub0NhbGwgPSB0cnVlO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKG5vQ2FsbFRhZy5pbmRleE9mKHB0KSA+PSAwKSB7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwic2VlbiBub2NhbGwgdGFnIHtwdH0gKHtwdH0ge3R5cGV9IHtudH0pXCIpXG5cdFx0XHRcdGVuZENhbGxBdFRlcm1pbmF0b3IgPSB0cnVlO1xuXHRcdFx0XHRub0NhbGwgPSB0cnVlO1xuXHRcdFx0XHRpZiAocHQgPT0gJ0ZPUicpIHsgc2VlbkZvciA9IHRydWUgfTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0dmFyIGNhbGxPYmplY3QgPSBmYWxzZTtcblx0XHRcdHZhciBjYWxsSW5kZW50ID0gZmFsc2U7XG5cdFx0XHRcblx0XHRcdC8vIFtwcmV2LCBjdXJyZW50LCBuZXh0XSA9IHRva2Vuc1tpIC0gMSAuLiBpICsgMV1cblx0XHRcdFxuXHRcdFx0Ly8gY2hlY2sgZm9yIGNvbW1lbnRzXG5cdFx0XHQvLyBjb25zb2xlLmxvZyBcImRldGVjdCBlbmQ/P1wiXG5cdFx0XHRpZiAoIW5vQ2FsbCAmJiB0eXBlID09ICdJTkRFTlQnICYmIG5leHQpIHtcblx0XHRcdFx0dmFyIHByZXZJbXBGdW5jID0gcHQgJiYgSU1QTElDSVRfRlVOQy5pbmRleE9mKHB0KSA+PSAwO1xuXHRcdFx0XHR2YXIgbmV4dEltcENhbGwgPSBudCAmJiBJTVBMSUNJVF9DQUxMLmluZGV4T2YobnQpID49IDA7XG5cdFx0XHRcdGNhbGxPYmplY3QgPSAoKG5leHQuZ2VuZXJhdGVkICYmIG50ID09ICd7JykgfHwgbmV4dEltcENhbGwpICYmIHByZXZJbXBGdW5jO1xuXHRcdFx0XHRjYWxsSW5kZW50ID0gbmV4dEltcENhbGwgJiYgcHJldkltcEZ1bmM7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR2YXIgc2VlblNpbmdsZSA9IGZhbHNlO1xuXHRcdFx0dmFyIHNlZW5Db250cm9sID0gZmFsc2U7XG5cdFx0XHQvLyBIbW0gP1xuXHRcdFx0XG5cdFx0XHQvLyB0aGlzIGlzIG5vdCBjb3JyZWN0IGlmIHRoaXMgaXMgaW5zaWRlIGEgYmxvY2ssbm8/XG5cdFx0XHRpZiAoKHR5cGUgPT0gJ1RFUk1JTkFUT1InIHx8IHR5cGUgPT0gJ09VVERFTlQnIHx8IHR5cGUgPT0gJ0lOREVOVCcpKSB7XG5cdFx0XHRcdGVuZENhbGxBdFRlcm1pbmF0b3IgPSBmYWxzZTtcblx0XHRcdFx0bm9DYWxsID0gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAodHlwZSA9PSAnPycgJiYgcHJldiAmJiAhcHJldi5zcGFjZWQpIHsgdG9rZW4uY2FsbCA9IHRydWUgfTtcblx0XHRcdFxuXHRcdFx0Ly8gd2hlcmUgZG9lcyBmcm9tVGhlbSBjb21lIGZyb20/XG5cdFx0XHRpZiAodG9rZW4uZnJvbVRoZW4pIHtcblx0XHRcdFx0aSArPSAxO2NvbnRpbnVlO1xuXHRcdFx0fTtcblx0XHRcdC8vIGhlcmUgd2UgZGVhbCB3aXRoIDpzcGFjZWQgYW5kIDpuZXdMaW5lXG5cdFx0XHRpZiAoIShjYWxsT2JqZWN0IHx8IGNhbGxJbmRlbnQgfHwgKHByZXYgJiYgcHJldi5zcGFjZWQpICYmIChwcmV2LmNhbGwgfHwgSU1QTElDSVRfRlVOQy5pbmRleE9mKHB0KSA+PSAwKSAmJiAoSU1QTElDSVRfQ0FMTC5pbmRleE9mKHR5cGUpID49IDAgfHwgISh0b2tlbi5zcGFjZWQgfHwgdG9rZW4ubmV3TGluZSkgJiYgSU1QTElDSVRfVU5TUEFDRURfQ0FMTC5pbmRleE9mKHR5cGUpID49IDApKSkge1xuXHRcdFx0XHRpICs9IDE7Y29udGludWU7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRcblx0XHRcdHRva2Vucy5zcGxpY2UoaSwwLFQudG9rZW4oJ0NBTExfU1RBUlQnLCcoJykpO1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgXCJhZGRlZCAoIHtwcmV2fVwiXG5cdFx0XHR2YXIgY29uZCA9IGZ1bmN0aW9uKHRva2VuLGkpIHtcblx0XHRcdFx0dmFyIHR5cGUgPSBULnR5cCh0b2tlbik7XG5cdFx0XHRcdGlmICghc2VlblNpbmdsZSAmJiB0b2tlbi5mcm9tVGhlbikgeyByZXR1cm4gdHJ1ZSB9O1xuXHRcdFx0XHR2YXIgaWZlbHNlID0gdHlwZSA9PSAnSUYnIHx8IHR5cGUgPT0gJ1VOTEVTUycgfHwgdHlwZSA9PSAnRUxTRSc7XG5cdFx0XHRcdGlmIChpZmVsc2UgfHwgdHlwZSA9PSAnQ0FUQ0gnKSB7IHNlZW5TaW5nbGUgPSB0cnVlIH07XG5cdFx0XHRcdGlmIChpZmVsc2UgfHwgdHlwZSA9PSAnU1dJVENIJyB8fCB0eXBlID09ICdUUlknKSB7IHNlZW5Db250cm9sID0gdHJ1ZSB9O1xuXHRcdFx0XHR2YXIgcHJldiA9IHNlbGYudG9rZW5UeXBlKGkgLSAxKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICgodHlwZSA9PSAnLicgfHwgdHlwZSA9PSAnPy4nIHx8IHR5cGUgPT0gJzo6JykgJiYgcHJldiA9PSAnT1VUREVOVCcpIHsgcmV0dXJuIHRydWUgfTtcblx0XHRcdFx0aWYgKGVuZENhbGxBdFRlcm1pbmF0b3IgJiYgKHR5cGUgPT0gJ0lOREVOVCcgfHwgdHlwZSA9PSAnVEVSTUlOQVRPUicpKSB7IHJldHVybiB0cnVlIH07XG5cdFx0XHRcdGlmICgodHlwZSA9PSAnV0hFTicgfHwgdHlwZSA9PSAnQlknKSAmJiAhc2VlbkZvcikge1xuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nIFwiZG9udCBjbG9zZSBpbXBsaWNpdCBjYWxsIG91dHNpZGUgZm9yXCJcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHR2YXIgcG9zdCA9IHRva2Vuc1tpICsgMV07XG5cdFx0XHRcdHZhciBwb3N0VHlwID0gcG9zdCAmJiBULnR5cChwb3N0KTtcblx0XHRcdFx0Ly8gV1RGXG5cdFx0XHRcdHJldHVybiAhdG9rZW4uZ2VuZXJhdGVkICYmIHByZXYgIT0gJywnICYmIChJTVBMSUNJVF9FTkQuaW5kZXhPZih0eXBlKSA+PSAwIHx8ICh0eXBlID09ICdJTkRFTlQnICYmICFzZWVuQ29udHJvbCkgfHwgKHR5cGUgPT0gJ0RPUycgJiYgcHJldiAhPSAnPScpKSAmJiAodHlwZSAhPSAnSU5ERU5UJyB8fCAoc2VsZi50b2tlblR5cGUoaSAtIDIpICE9ICdDTEFTUycgJiYgSU1QTElDSVRfQkxPQ0suaW5kZXhPZihwcmV2KSA9PSAtMSAmJiAhKHBvc3QgJiYgKChwb3N0LmdlbmVyYXRlZCAmJiBwb3N0VHlwID09ICd7JykgfHwgSU1QTElDSVRfQ0FMTC5pbmRleE9mKHBvc3RUeXApID49IDApKSkpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Ly8gVGhlIGFjdGlvbiBmb3IgZGV0ZWN0aW5nIHdoZW4gdGhlIGNhbGwgc2hvdWxkIGVuZFxuXHRcdFx0Ly8gY29uc29sZS5sb2cgXCJkZXRlY3QgZW5kPz9cIlxuXHRcdFx0c2VsZi5kZXRlY3RFbmQoaSArIDEsY29uZCxhY3Rpb24pO1xuXHRcdFx0aWYgKFQudHlwKHByZXYpID09ICc/JykgeyBULnNldFR5cChwcmV2LCdGVU5DX0VYSVNUJykgfTtcblx0XHRcdGkgKz0gMjtcblx0XHRcdC8vIG5lZWQgdG8gcmVzZXQgYWZ0ZXIgYSBtYXRjaFxuXHRcdFx0ZW5kQ2FsbEF0VGVybWluYXRvciA9IGZhbHNlO1xuXHRcdFx0bm9DYWxsID0gZmFsc2U7XG5cdFx0XHRzZWVuRm9yID0gZmFsc2U7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHRyZXR1cm47XG5cdH07XG5cdFxuXHQvLyBCZWNhdXNlIG91ciBncmFtbWFyIGlzIExBTFIoMSksIGl0IGNhbid0IGhhbmRsZSBzb21lIHNpbmdsZS1saW5lXG5cdC8vIGV4cHJlc3Npb25zIHRoYXQgbGFjayBlbmRpbmcgZGVsaW1pdGVycy4gVGhlICoqUmV3cml0ZXIqKiBhZGRzIHRoZSBpbXBsaWNpdFxuXHQvLyBibG9ja3MsIHNvIGl0IGRvZXNuJ3QgbmVlZCB0by4gJyknIGNhbiBjbG9zZSBhIHNpbmdsZS1saW5lIGJsb2NrLFxuXHQvLyBidXQgd2UgbmVlZCB0byBtYWtlIHN1cmUgaXQncyBiYWxhbmNlZC5cblx0UmV3cml0ZXIucHJvdG90eXBlLmFkZEltcGxpY2l0SW5kZW50YXRpb24gPSBmdW5jdGlvbiAoKXtcblx0XHRcblx0XHRcblx0XHR2YXIgc2VsZiA9IHRoaXMsIHRva2VuO1xuXHRcdHZhciBpID0gMDtcblx0XHR2YXIgdG9rZW5zID0gc2VsZi5fdG9rZW5zO1xuXHRcdHdoaWxlICh0b2tlbiA9IHRva2Vuc1tpXSl7XG5cdFx0XHR2YXIgdHlwZSA9IFQudHlwKHRva2VuKTtcblx0XHRcdHZhciBuZXh0ID0gc2VsZi50b2tlblR5cGUoaSArIDEpO1xuXHRcdFx0XG5cdFx0XHQvLyB3aHkgYXJlIHdlIHJlbW92aW5nIHRlcm1pbmF0b3JzIGFmdGVyIHRoZW4/IHNob3VsZCBiZSBhYmxlIHRvIGhhbmRsZVxuXHRcdFx0aWYgKHR5cGUgPT0gJ1RFUk1JTkFUT1InICYmIG5leHQgPT0gJ1RIRU4nKSB7XG5cdFx0XHRcdHRva2Vucy5zcGxpY2UoaSwxKTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAodHlwZSA9PSAnQ0FUQ0gnICYmIGlkeCQoc2VsZi50b2tlblR5cGUoaSArIDIpLFsnT1VUREVOVCcsJ1RFUk1JTkFUT1InLCdGSU5BTExZJ10pID49IDApIHtcblx0XHRcdFx0dG9rZW5zLnNwbGljZS5hcHBseSh0b2tlbnMsW10uY29uY2F0KFtpICsgMiwwXSwgW10uc2xpY2UuY2FsbChzZWxmLmluZGVudGF0aW9uKHRva2VuKSkpKTtcblx0XHRcdFx0aSArPSA0O2NvbnRpbnVlO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKFNJTkdMRV9MSU5FUlMuaW5kZXhPZih0eXBlKSA+PSAwICYmIChuZXh0ICE9ICdJTkRFTlQnICYmIG5leHQgIT0gJ0JMT0NLX1BBUkFNX1NUQVJUJykgJiYgISh0eXBlID09ICdFTFNFJyAmJiBuZXh0ID09ICdJRicpICYmIHR5cGUgIT0gJ0VMSUYnKSB7XG5cdFx0XHRcdFxuXHRcdFx0XHR2YXIgc3RhcnRlciA9IHR5cGU7XG5cdFx0XHRcdFxuXHRcdFx0XHR2YXIgaW5kZW50ID0gVC50b2tlbignSU5ERU5UJywnMicpO1xuXHRcdFx0XHR2YXIgb3V0ZGVudCA9IFQuT1VUREVOVDtcblx0XHRcdFx0Ly8gdmFyIGluZGVudCwgb3V0ZGVudCA9IGluZGVudGF0aW9uKHRva2VuKVxuXHRcdFx0XHRpZiAoc3RhcnRlciA9PSAnVEhFTicpIHsgaW5kZW50LmZyb21UaGVuID0gdHJ1ZSB9OyAvLyBzZXR0aW5nIHNwZWNpYWwgdmFsdWVzIGZvciB0aGVzZSAtLSBjYW5ub3QgcmVhbGx5IHJldXNlP1xuXHRcdFx0XHRpbmRlbnQuZ2VuZXJhdGVkID0gdHJ1ZTtcblx0XHRcdFx0Ly8gb3V0ZGVudDpnZW5lcmF0ZWQgPSB0cnVlXG5cdFx0XHRcdHRva2Vucy5zcGxpY2UoaSArIDEsMCxpbmRlbnQpO1xuXHRcdFx0XHRcblx0XHRcdFx0dmFyIGNvbmRpdGlvbiA9IGZ1bmN0aW9uKHRva2VuLGkpIHtcblx0XHRcdFx0XHR2YXIgdCA9IFQudHlwKHRva2VuKTtcblx0XHRcdFx0XHRyZXR1cm4gVC52YWwodG9rZW4pICE9ICc7JyAmJiBTSU5HTEVfQ0xPU0VSUy5pbmRleE9mKHQpID49IDAgJiYgISh0ID09ICdFTFNFJyAmJiBzdGFydGVyICE9ICdJRicgJiYgc3RhcnRlciAhPSAnVEhFTicpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0dmFyIGFjdGlvbiA9IGZ1bmN0aW9uKHRva2VuLGkpIHtcblx0XHRcdFx0XHR2YXIgaWR4ID0gc2VsZi50b2tlblR5cGUoaSAtIDEpID09ICcsJyA/IChpIC0gMSkgOiAoaSk7XG5cdFx0XHRcdFx0cmV0dXJuIHRva2Vucy5zcGxpY2UoaWR4LDAsb3V0ZGVudCk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRzZWxmLmRldGVjdEVuZChpICsgMixjb25kaXRpb24sYWN0aW9uKTtcblx0XHRcdFx0aWYgKHR5cGUgPT0gJ1RIRU4nKSB7IHRva2Vucy5zcGxpY2UoaSwxKSB9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aSsrO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuO1xuXHR9O1xuXHRcblx0Ly8gVGFnIHBvc3RmaXggY29uZGl0aW9uYWxzIGFzIHN1Y2gsIHNvIHRoYXQgd2UgY2FuIHBhcnNlIHRoZW0gd2l0aCBhXG5cdC8vIGRpZmZlcmVudCBwcmVjZWRlbmNlLlxuXHRSZXdyaXRlci5wcm90b3R5cGUudGFnUG9zdGZpeENvbmRpdGlvbmFscyA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR2YXIgY29uZGl0aW9uID0gZnVuY3Rpb24odG9rZW4saSkgeyByZXR1cm4gaWR4JChULnR5cCh0b2tlbiksWydURVJNSU5BVE9SJywnSU5ERU5UJ10pID49IDA7IH07XG5cdFx0XG5cdFx0cmV0dXJuIHNlbGYuc2NhblRva2VucyhmdW5jdGlvbih0b2tlbixpKSB7XG5cdFx0XHR2YXIgdHlwID0gVC50eXAodG9rZW4pO1xuXHRcdFx0aWYgKCEodHlwID09ICdJRicgfHwgdHlwID09ICdGT1InKSkgeyByZXR1cm4gMSB9O1xuXHRcdFx0dmFyIG9yaWdpbmFsID0gdG9rZW47XG5cdFx0XHRzZWxmLmRldGVjdEVuZChpICsgMSxjb25kaXRpb24sZnVuY3Rpb24odG9rZW4saSkge1xuXHRcdFx0XHRpZiAoVC50eXAodG9rZW4pICE9ICdJTkRFTlQnKSB7IHJldHVybiBULnNldFR5cChvcmlnaW5hbCwnUE9TVF8nICsgVC50eXAob3JpZ2luYWwpKSB9O1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9KTtcblx0fTtcblx0XG5cdC8vIEdlbmVyYXRlIHRoZSBpbmRlbnRhdGlvbiB0b2tlbnMsIGJhc2VkIG9uIGFub3RoZXIgdG9rZW4gb24gdGhlIHNhbWUgbGluZS5cblx0UmV3cml0ZXIucHJvdG90eXBlLmluZGVudGF0aW9uID0gZnVuY3Rpb24gKHRva2VuKXtcblx0XHRyZXR1cm4gW1QudG9rZW4oJ0lOREVOVCcsJzInKSxULnRva2VuKCdPVVRERU5UJywnMicpXTtcblx0fTtcblx0XG5cdC8vIExvb2sgdXAgYSB0eXBlIGJ5IHRva2VuIGluZGV4LlxuXHRSZXdyaXRlci5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uIChpKXtcblx0XHQvLyBpZiBpIDwgMCB0aGVuIHJldHVybiBudWxsXG5cdFx0dmFyIHRvayA9IHRoaXMuX3Rva2Vuc1tpXTtcblx0XHRyZXR1cm4gdG9rICYmIFQudHlwKHRvayk7XG5cdFx0Ly8gaWYgdG9rIHRoZW4gdG9rWzBdIGVsc2UgbnVsbFxuXHR9O1xuXHRcblx0UmV3cml0ZXIucHJvdG90eXBlLnRva2VuVHlwZSA9IGZ1bmN0aW9uIChpKXtcblx0XHR2YXIgdG9rID0gdGhpcy5fdG9rZW5zW2ldO1xuXHRcdHJldHVybiB0b2sgJiYgVC50eXAodG9rKTtcblx0XHQvLyByZXR1cm4gdG9rIGFuZCB0b2tbMF1cblx0fTtcblx0XG5cdC8vIENvbnN0YW50c1xuXHQvLyAtLS0tLS0tLS1cblx0XG5cdC8vIExpc3Qgb2YgdGhlIHRva2VuIHBhaXJzIHRoYXQgbXVzdCBiZSBiYWxhbmNlZC5cblx0dmFyIEJBTEFOQ0VEX1BBSVJTID0gW1xuXHRcdFsnKCcsJyknXSxcblx0XHRbJ1snLCddJ10sXG5cdFx0Wyd7JywnfSddLFxuXHRcdFsne3snLCd9fSddLFxuXHRcdFsnSU5ERU5UJywnT1VUREVOVCddLFxuXHRcdFsnQ0FMTF9TVEFSVCcsJ0NBTExfRU5EJ10sXG5cdFx0WydQQVJBTV9TVEFSVCcsJ1BBUkFNX0VORCddLFxuXHRcdFsnSU5ERVhfU1RBUlQnLCdJTkRFWF9FTkQnXSxcblx0XHRbJ1RBR19TVEFSVCcsJ1RBR19FTkQnXSxcblx0XHRbJ1RBR19QQVJBTV9TVEFSVCcsJ1RBR19QQVJBTV9FTkQnXSxcblx0XHRbJ1RBR19BVFRSU19TVEFSVCcsJ1RBR19BVFRSU19FTkQnXSxcblx0XHRbJ0JMT0NLX1BBUkFNX1NUQVJUJywnQkxPQ0tfUEFSQU1fRU5EJ11cblx0XTtcblx0XG5cdC8vIFRoZSBpbnZlcnNlIG1hcHBpbmdzIG9mIGBCQUxBTkNFRF9QQUlSU2Agd2UncmUgdHJ5aW5nIHRvIGZpeCB1cCwgc28gd2UgY2FuXG5cdC8vIGxvb2sgdGhpbmdzIHVwIGZyb20gZWl0aGVyIGVuZC5cblx0bW9kdWxlLmV4cG9ydHMuSU5WRVJTRVMgPSBJTlZFUlNFUyA9IHt9O1xuXHRcblx0Ly8gVGhlIHRva2VucyB0aGF0IHNpZ25hbCB0aGUgc3RhcnQvZW5kIG9mIGEgYmFsYW5jZWQgcGFpci5cblx0Ly8gdmFyIEVYUFJFU1NJT05fU1RBUlQgPSBbXVxuXHQvLyB2YXIgRVhQUkVTU0lPTl9FTkQgICA9IFtdXG5cdFxuXHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQoQkFMQU5DRURfUEFJUlMpLCBsZW4gPSBhcnkubGVuZ3RoLCBwYWlyOyBpIDwgbGVuOyBpKyspIHtcblx0XHRwYWlyID0gYXJ5W2ldO1xuXHRcdHZhciBsZWZ0ID0gcGFpclswXTtcblx0XHR2YXIgcml0ZSA9IHBhaXJbMV07XG5cdFx0SU5WRVJTRVNbcml0ZV0gPSBsZWZ0O1xuXHRcdElOVkVSU0VTW2xlZnRdID0gcml0ZTtcblx0fTtcblx0XG5cdHZhciBFWFBSRVNTSU9OX1NUQVJUID0gWycoJywnWycsJ3snLCdJTkRFTlQnLCdDQUxMX1NUQVJUJywnUEFSQU1fU1RBUlQnLCdJTkRFWF9TVEFSVCcsJ1RBR19QQVJBTV9TVEFSVCcsJ0JMT0NLX1BBUkFNX1NUQVJUJywnU1RSSU5HX1NUQVJUJywne3snLCdUQUdfU1RBUlQnXTtcblx0dmFyIEVYUFJFU1NJT05fRU5EID0gWycpJywnXScsJ30nLCdPVVRERU5UJywnQ0FMTF9FTkQnLCdQQVJBTV9FTkQnLCdJTkRFWF9FTkQnLCdUQUdfUEFSQU1fRU5EJywnQkxPQ0tfUEFSQU1fRU5EJywnU1RSSU5HX0VORCcsJ319JywnVEFHX0VORCddO1xuXHRcblx0dmFyIElERU5USUZJRVJTID0gWydJREVOVElGSUVSJywnR1ZBUicsJ0lWQVInLCdDVkFSJywnQ09OU1QnLCdBUkdWQVInXTtcblx0XG5cdC8vIFRva2VucyB0aGF0IGluZGljYXRlIHRoZSBjbG9zZSBvZiBhIGNsYXVzZSBvZiBhbiBleHByZXNzaW9uLlxuXHR2YXIgRVhQUkVTU0lPTl9DTE9TRSA9IFsnQ0FUQ0gnLCdXSEVOJywnRUxTRScsJ0ZJTkFMTFknXS5jb25jYXQoRVhQUkVTU0lPTl9FTkQpO1xuXHRcblx0Ly8gVG9rZW5zIHRoYXQsIGlmIGZvbGxvd2VkIGJ5IGFuIGBJTVBMSUNJVF9DQUxMYCwgaW5kaWNhdGUgYSBmdW5jdGlvbiBpbnZvY2F0aW9uLlxuXHR2YXIgSU1QTElDSVRfRlVOQyA9IFsnSURFTlRJRklFUicsJ1NVUEVSJywnQCcsJ1RISVMnLCdTRUxGJywnRVZFTlQnLCdUUklHR0VSJywnVEFHX0VORCcsJ0lWQVInLFxuXHQnR1ZBUicsJ0NPTlNUJywnQVJHVkFSJywnTkVXJywnQlJFQUsnLCdDT05USU5VRScsJ1JFVFVSTiddO1xuXHRcblx0Ly8gSWYgcHJlY2VkZWQgYnkgYW4gYElNUExJQ0lUX0ZVTkNgLCBpbmRpY2F0ZXMgYSBmdW5jdGlvbiBpbnZvY2F0aW9uLlxuXHR2YXIgSU1QTElDSVRfQ0FMTCA9IFtcblx0XHQnU0VMRUNUT1InLCdJREVOVElGSUVSJywnTlVNQkVSJywnU1RSSU5HJywnU1lNQk9MJywnSlMnLCdSRUdFWCcsJ05FVycsJ1BBUkFNX1NUQVJUJywnQ0xBU1MnLFxuXHRcdCdJRicsJ1VOTEVTUycsJ1RSWScsJ1NXSVRDSCcsJ1RISVMnLCdCT09MJywnVFJVRScsJ0ZBTFNFJywnTlVMTCcsJ1VOREVGSU5FRCcsJ1VOQVJZJywnU1VQRVInLCdJVkFSJywnR1ZBUicsJ0NPTlNUJywnQVJHVkFSJywnU0VMRicsXG5cdFx0J0AnLCdbJywnKCcsJ3snLCctLScsJysrJywnU0VMRUNUT1InLCdUQUdfU1RBUlQnLCdUQUdJRCcsJyMnLCdTRUxFQ1RPUl9TVEFSVCcsJ0lEUkVGJywnU1BMQVQnLCdETycsJ0JMT0NLX0FSRycsXG5cdFx0J0ZPUicsJ1NUUklOR19TVEFSVCcsJ0NPTlRJTlVFJywnQlJFQUsnXG5cdF07IC8vICctPicsICc9PicsIHdoeSBkb2VzIGl0IG5vdCB3b3JrIHdpdGggc3ltYm9sP1xuXHRcblx0dmFyIElNUExJQ0lUX0lOREVOVF9DQUxMID0gW1xuXHRcdCdGT1InXG5cdF07XG5cdC8vIGlzIG5vdCBkbyBhbiBpbXBsaWNpdCBjYWxsPz9cblx0XG5cdHZhciBJTVBMSUNJVF9VTlNQQUNFRF9DQUxMID0gWycrJywnLSddO1xuXHRcblx0Ly8gVG9rZW5zIGluZGljYXRpbmcgdGhhdCB0aGUgaW1wbGljaXQgY2FsbCBtdXN0IGVuY2xvc2UgYSBibG9jayBvZiBleHByZXNzaW9ucy5cblx0dmFyIElNUExJQ0lUX0JMT0NLID0gWyd7JywnWycsJywnLCdCTE9DS19QQVJBTV9FTkQnLCdETyddOyAvLyAnLT4nLCAnPT4nLCBcblx0XG5cdHZhciBDT05ESVRJT05BTF9BU1NJR04gPSBbJ3x8PScsJyYmPScsJz89JywnJj0nLCd8PSddO1xuXHR2YXIgQ09NUE9VTkRfQVNTSUdOID0gWyctPScsJys9JywnLz0nLCcqPScsJyU9JywnfHw9JywnJiY9JywnPz0nLCc8PD0nLCc+Pj0nLCc+Pj49JywnJj0nLCdePScsJ3w9J107XG5cdHZhciBVTkFSWSA9IFsnIScsJ34nLCdORVcnLCdUWVBFT0YnLCdERUxFVEUnXTtcblx0dmFyIExPR0lDID0gWycmJicsJ3x8JywnJicsJ3wnLCdeJ107XG5cdFxuXHQvLyBvcHRpbWl6ZSBmb3IgZml4ZWQgYXJyYXlzXG5cdHZhciBOT19JTVBMSUNJVF9CTE9DS19DQUxMID0gW1xuXHRcdCdDQUxMX0VORCcsJz0nLCdERUZfQk9EWScsJygnLCdDQUxMX1NUQVJUJywnLCcsJzonLCdSRVRVUk4nLFxuXHRcdCctPScsJys9JywnLz0nLCcqPScsJyU9JywnfHw9JywnJiY9JywnPz0nLCc8PD0nLCc+Pj0nLCc+Pj49JywnJj0nLCdePScsJ3w9J1xuXHRdOyAvLyAuY29uY2F0KENPTVBPVU5EX0FTU0lHTilcblx0XG5cdFxuXHQvLyBjb25zb2xlLmxvZyBOT19JTVBMSUNJVF9CTE9DS19DQUxMOmxlbmd0aFxuXHQvLyBOT19JTVBMSUNJVF9CTE9DS19DQUxMXG5cdC8vIElNUExJQ0lUX0NPTU1BID0gWyctPicsICc9PicsICd7JywgJ1snLCAnTlVNQkVSJywgJ1NUUklORycsICdTWU1CT0wnLCAnSURFTlRJRklFUicsJ0RPJ11cblx0XG5cdHZhciBJTVBMSUNJVF9DT01NQSA9IFsnRE8nXTtcblx0XG5cdC8vIFRva2VucyB0aGF0IGFsd2F5cyBtYXJrIHRoZSBlbmQgb2YgYW4gaW1wbGljaXQgY2FsbCBmb3Igc2luZ2xlLWxpbmVycy5cblx0dmFyIElNUExJQ0lUX0VORCA9IFsnUE9TVF9JRicsJ1BPU1RfVU5MRVNTJywnUE9TVF9GT1InLCdXSElMRScsJ1VOVElMJywnV0hFTicsJ0JZJywnTE9PUCcsJ1RFUk1JTkFUT1InLCdERUZfQk9EWScsJ0RFRl9GUkFHTUVOVCddO1xuXHRcblx0Ly8gU2luZ2xlLWxpbmUgZmxhdm9ycyBvZiBibG9jayBleHByZXNzaW9ucyB0aGF0IGhhdmUgdW5jbG9zZWQgZW5kaW5ncy5cblx0Ly8gVGhlIGdyYW1tYXIgY2FuJ3QgZGlzYW1iaWd1YXRlIHRoZW0sIHNvIHdlIGluc2VydCB0aGUgaW1wbGljaXQgaW5kZW50YXRpb24uXG5cdHZhciBTSU5HTEVfTElORVJTID0gWydFTFNFJywnVFJZJywnRklOQUxMWScsJ1RIRU4nLCdCTE9DS19QQVJBTV9FTkQnLCdETycsJ0JFR0lOJywnQ0FUQ0hfVkFSJ107IC8vICctPicsICc9PicsIHJlYWxseT9cblx0dmFyIFNJTkdMRV9DTE9TRVJTID0gWydURVJNSU5BVE9SJywnQ0FUQ0gnLCdGSU5BTExZJywnRUxTRScsJ09VVERFTlQnLCdMRUFESU5HX1dIRU4nXTtcblx0XG5cdC8vIFRva2VucyB0aGF0IGVuZCBhIGxpbmUuXG5cdHJldHVybiBMSU5FQlJFQUtTID0gWydURVJNSU5BVE9SJywnSU5ERU5UJywnT1VUREVOVCddO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21waWxlci9yZXdyaXRlci5pbWJhXG4gKiogbW9kdWxlIGlkID0gNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyogcGFyc2VyIGdlbmVyYXRlZCBieSBqaXNvbi1mb3JrICovXG52YXIgcGFyc2VyID0gKGZ1bmN0aW9uKCl7XG52YXIgbz1mdW5jdGlvbihrLHYsbyxsKXtmb3Iobz1vfHx7fSxsPWsubGVuZ3RoO2wtLTtvW2tbbF1dPXYpO3JldHVybiBvfSwkVjA9WzEsNF0sJFYxPVsxLDZdLCRWMj1bMSwzMl0sJFYzPVsxLDMzXSwkVjQ9WzEsMzRdLCRWNT1bMSwzNV0sJFY2PVsxLDc1XSwkVjc9WzEsMTE1XSwkVjg9WzEsMTI4XSwkVjk9WzEsMTIxXSwkVmE9WzEsMTIyXSwkVmI9WzEsMTIzXSwkVmM9WzEsMTIwXSwkVmQ9WzEsMTI0XSwkVmU9WzEsMTMxXSwkVmY9WzEsMTE0XSwkVmc9WzEsMTMyXSwkVmg9WzEsODBdLCRWaT1bMSw4MV0sJFZqPVsxLDgyXSwkVms9WzEsODNdLCRWbD1bMSw4NF0sJFZtPVsxLDg1XSwkVm49WzEsODZdLCRWbz1bMSw3M10sJFZwPVsxLDExOF0sJFZxPVsxLDk1XSwkVnI9WzEsOTFdLCRWcz1bMSw4OF0sJFZ0PVsxLDcxXSwkVnU9WzEsNjVdLCRWdj1bMSw2Nl0sJFZ3PVsxLDExMV0sJFZ4PVsxLDkwXSwkVnk9WzEsODddLCRWej1bMSwyOF0sJFZBPVsxLDI5XSwkVkI9WzEsOTZdLCRWQz1bMSw5NF0sJFZEPVsxLDExMl0sJFZFPVsxLDExM10sJFZGPVsxLDEyNl0sJFZHPVsxLDY3XSwkVkg9WzEsNjhdLCRWST1bMSwxMTldLCRWSj1bMSwxMV0sJFZLPVsxLDEyN10sJFZMPVsxLDc4XSwkVk09WzEsMzddLCRWTj1bMSw0M10sJFZPPVsxLDExMF0sJFZQPVsxLDY5XSwkVlE9WzEsODldLCRWUj1bMSwxMjVdLCRWUz1bMSw1OV0sJFZUPVsxLDc0XSwkVlU9WzEsMTA1XSwkVlY9WzEsMTA2XSwkVlc9WzEsMTA3XSwkVlg9WzEsMTI5XSwkVlk9WzEsMTMwXSwkVlo9WzEsNjNdLCRWXz1bMSwxMDRdLCRWJD1bMSw1MV0sJFYwMT1bMSw1Ml0sJFYxMT1bMSw1M10sJFYyMT1bMSw1NF0sJFYzMT1bMSw1NV0sJFY0MT1bMSw1Nl0sJFY1MT1bMSwxMzRdLCRWNjE9WzEsNiwxMSwxMzddLCRWNzE9WzEsMTM2XSwkVjgxPVsxLDYsMTEsMTQsMTM3XSwkVjkxPVsxLDE0NF0sJFZhMT1bMSwxNDVdLCRWYjE9WzEsMTQ3XSwkVmMxPVsxLDE0OF0sJFZkMT1bMSwxNDFdLCRWZTE9WzEsMTQwXSwkVmYxPVsxLDE0Ml0sJFZnMT1bMSwxNDNdLCRWaDE9WzEsMTQ2XSwkVmkxPVsxLDE1MV0sJFZqMT1bMSw2LDEwLDExLDE0LDIyLDcxLDkwLDk3LDEwNiwxMTIsMTI2LDEzNSwxMzcsMTQ3LDE3MSwyMDAsMjAxLDIxMiwyMTMsMjE0LDIxOSwyMjAsMjI5LDIzOCwyMzksMjQyLDI0MywyNDYsMjQ3LDI0OF0sJFZrMT1bMiwyNjNdLCRWbDE9WzEsMTU4XSwkVm0xPVsxLDE2NF0sJFZuMT1bMSwxNjJdLCRWbzE9WzEsMTYwXSwkVnAxPVsxLDE2MV0sJFZxMT1bMSwxNjVdLCRWcjE9WzEsMTYzXSwkVnMxPVsxLDYsMTAsMTEsMTQsMjIsOTAsOTcsMTM3XSwkVnQxPVsxLDYsMTEsMTQsMTM3LDIxMiwyMTQsMjE5LDIyMCwyMzhdLCRWdTE9WzEsNiwxMCwxMSwxNCwyMSwyMiw3MSw4OCw4OSw5MCw5NywxMDYsMTExLDExMiwxMjYsMTM1LDEzNywxNDQsMTQ3LDE3MSwxODAsMTgxLDE4MywxOTYsMjAwLDIwMSwyMTIsMjEzLDIxNCwyMTksMjIwLDIyOSwyMzgsMjM5LDI0MiwyNDMsMjQ2LDI0NywyNDhdLCRWdjE9WzIsMjMxXSwkVncxPVsxLDE3OF0sJFZ4MT1bMSwxNzZdLCRWeTE9WzEsNiwxMCwxMSwxNCwyMSwyMiw3MSw4OCw4OSw5MCw5NywxMDYsMTExLDExMiwxMTcsMTI2LDEzNSwxMzcsMTQ0LDE0NywxNzEsMTgwLDE4MSwxODMsMTk2LDIwMCwyMDEsMjEyLDIxMywyMTQsMjE5LDIyMCwyMjksMjM4LDIzOSwyNDIsMjQzLDI0NiwyNDcsMjQ4XSwkVnoxPVsyLDIyN10sJFZBMT1bNiwxNCw1Myw1NCw4OCw5MSwxMDYsMTExLDExMywxMTZdLCRWQjE9WzEsMjEyXSwkVkMxPVsxLDIxN10sJFZEMT1bMSw2LDEwLDExLDE0LDIxLDIyLDcxLDg4LDg5LDkwLDk3LDEwNiwxMTEsMTEyLDExNywxMjYsMTM1LDEzNywxNDQsMTQ3LDE3MSwxODAsMTgxLDE4MywxOTYsMjAwLDIwMSwyMTIsMjEzLDIxNCwyMTksMjIwLDIyOSwyMzgsMjM5LDI0MiwyNDMsMjQ0LDI0NSwyNDYsMjQ3LDI0OCwyNDldLCRWRTE9WzEsMjI3XSwkVkYxPVsxLDIyNF0sJFZHMT1bMSwyMjldLCRWSDE9WzYsMTAsMTQsOTBdLCRWSTE9WzIsMjQ0XSwkVkoxPVsxLDI1N10sJFZLMT1bMSwyNDddLCRWTDE9WzEsMjc2XSwkVk0xPVsxLDI3N10sJFZOMT1bNTEsODldLCRWTzE9Wzg1LDg2LDg3LDg4LDkxLDkyLDkzLDk0LDk1LDk2LDEwMCwxMDJdLCRWUDE9WzEsMjg5XSwkVlExPVsxLDYsMTAsMTEsMTQsMjEsMjIsNTMsNTQsNzEsODgsODksOTAsOTEsOTcsMTA2LDExMSwxMTIsMTEzLDExNiwxMTcsMTI2LDEzNSwxMzcsMTQ0LDE0NywxNzEsMTgwLDE4MSwxODMsMTk2LDIwMCwyMDEsMjEyLDIxMywyMTQsMjE5LDIyMCwyMjksMjM4LDIzOSwyNDIsMjQzLDI0NCwyNDUsMjQ2LDI0NywyNDgsMjQ5XSwkVlIxPVsxLDI5NV0sJFZTMT1bNTEsODksOTYsMjI1XSwkVlQxPVsxLDYsMTAsMTEsMTQsMjEsMjIsNjcsNjksNzAsNzEsODgsODksOTAsOTcsMTA2LDExMSwxMTIsMTI2LDEzNSwxMzcsMTQ0LDE0NywxNzEsMTgwLDE4MSwxODMsMTk2LDIwMCwyMDEsMjEyLDIxMywyMTQsMjE5LDIyMCwyMjksMjM4LDIzOSwyNDIsMjQzLDI0NiwyNDcsMjQ4XSwkVlUxPVsxLDYsMTAsMTEsMTQsMjEsMjIsNzEsODgsODksOTAsOTcsMTA2LDExMSwxMTIsMTI2LDEzNSwxMzcsMTQ0LDE0NywxNzEsMTgwLDE4MSwxODMsMTk2LDIwMCwyMDEsMjA3LDIwOCwyMTIsMjEzLDIxNCwyMTksMjIwLDIyOSwyMzIsMjM0LDIzNywyMzgsMjM5LDI0MiwyNDMsMjQ2LDI0NywyNDhdLCRWVjE9WzUxLDUzLDU0LDU4XSwkVlcxPVsxLDMyNl0sJFZYMT1bMSwzMjddLCRWWTE9WzEsNiwxMCwxMSwxNCwyMiw3MSw5MCw5NywxMDYsMTEyLDEzNSwxMzcsMTQ3LDIwMCwyMDEsMjEyLDIxMywyMTQsMjE5LDIyMCwyMjksMjM4XSwkVloxPVsxLDM0MF0sJFZfMT1bMSwzNDRdLCRWJDE9WzEsNiwxMSwxNCwyMiw3MSw5MCw5NywxMDYsMTEyLDEyNiwxMzUsMTM3LDE0NywxNzEsMjAwLDIwMSwyMTIsMjEzLDIxNCwyMTksMjIwLDIyOSwyMzgsMjM5LDI0MiwyNDMsMjQ2LDI0NywyNDhdLCRWMDI9WzYsMTQsMTA2XSwkVjEyPVsxLDM1NF0sJFYyMj1bMSw2LDEwLDExLDE0LDIxLDIyLDcxLDg5LDkwLDk3LDEwNiwxMTIsMTI2LDEzNSwxMzcsMTQ3LDE3MSwyMDAsMjAxLDIxMiwyMTMsMjE0LDIxOSwyMjAsMjI5LDIzOCwyMzksMjQyLDI0MywyNDYsMjQ3LDI0OF0sJFYzMj1bMTQsMjhdLCRWNDI9WzEsNiwxMSwxNCwyOCwxMzcsMjEyLDIxNCwyMTksMjIwLDIzOF0sJFY1Mj1bMiwyODRdLCRWNjI9WzEsNiwxMCwxMSwxNCwyMSwyMiw3MSw4OCw4OSw5MCw5NywxMDYsMTExLDExMiwxMTcsMTI2LDEzNSwxMzcsMTQ0LDE0NywxNzEsMTgwLDE4MSwxODMsMTk2LDIwMCwyMDEsMjEyLDIxMywyMTQsMjE5LDIyMCwyMjcsMjI4LDIyOSwyMzgsMjM5LDI0MiwyNDMsMjQ0LDI0NSwyNDYsMjQ3LDI0OCwyNDldLCRWNzI9WzIsMTg0XSwkVjgyPVsxLDM2OV0sJFY5Mj1bNiwxMCwxMSwxNCwyMiw5N10sJFZhMj1bMTQsMTQ3XSwkVmIyPVsyLDE4Nl0sJFZjMj1bMSwzNzldLCRWZDI9WzEsMzgwXSwkVmUyPVsxLDM4MV0sJFZmMj1bMSwzODVdLCRWZzI9WzYsMTAsMTEsMTQsOTBdLCRWaDI9WzYsMTAsMTEsMTQsOTAsMTM1XSwkVmkyPVsxLDYsMTAsMTEsMTQsMjIsNzEsOTAsOTcsMTA2LDExMiwxMzUsMTM3LDE0NywyMDAsMjAxLDIyMCwyMjksMjM4XSwkVmoyPVsxLDYsMTAsMTEsMTQsMjIsNzEsOTAsOTcsMTA2LDExMiwxMzUsMTM3LDE0NywyMDAsMjAxLDIxMywyMjAsMjI5LDIzOF0sJFZrMj1bMjI3LDIyOF0sJFZsMj1bMTQsMjI3LDIyOF0sJFZtMj1bMSw2LDExLDE0LDIyLDcxLDkwLDk3LDEwNiwxMTIsMTM1LDEzNywxNDcsMTcxLDIwMCwyMDEsMjEyLDIxMywyMTQsMjE5LDIyMCwyMjksMjM4LDIzOSwyNDIsMjQzLDI0NiwyNDcsMjQ4XSwkVm4yPVs4OCw5MV0sJFZvMj1bMSw0MDZdLCRWcDI9WzEsNDA3XSwkVnEyPVsyMSw4OCw5MSwxNjQsMTY1XSwkVnIyPVsxLDYsMTAsMTEsMTQsMjIsNzEsOTAsOTcsMTA2LDExMiwxMjYsMTM1LDEzNywxNDcsMTcxLDIwMCwyMDEsMjEyLDIxMywyMTQsMjE5LDIyMCwyMjksMjM4LDIzOSwyNDIsMjQzLDI0NywyNDhdLCRWczI9WzEsNiwxMCwxMSwxNCwyMiw3MSw5MCw5NywxMDYsMTEyLDEzNSwxMzcsMTQ3LDIwMCwyMDEsMjEzLDIyOV0sJFZ0Mj1bMTksMjAsMjMsMjQsMjYsMzIsNTEsNTMsNTQsNTYsNTgsNjAsNjIsNjQsNjYsNzMsNzQsNzUsNzYsNzcsNzgsNzksODAsODMsODksOTEsOTYsMTAzLDExMiwxMjIsMTIzLDEyNCwxMzAsMTM2LDE0MywxNDQsMTUxLDE1MiwxNTQsMTU2LDE1NywxNTgsMTc1LDE4NCwxODUsMTg4LDE5MywxOTQsMTk3LDE5OCwyMDQsMjEwLDIxMiwyMTQsMjE2LDIxOSwyMjAsMjMwLDIzNiwyNDAsMjQxLDI0MiwyNDMsMjQ0LDI0NV0sJFZ1Mj1bMSw2LDEwLDExLDE0LDIyLDcxLDkwLDk3LDEwNiwxMTIsMTI2LDEzNSwxMzcsMTQ3LDE3MSwyMDAsMjAxLDIxMiwyMTMsMjE0LDIxOSwyMjAsMjI5LDIzMiwyMzcsMjM4LDIzOSwyNDIsMjQzLDI0NiwyNDcsMjQ4XSwkVnYyPVsxMSwyMzIsMjM0XSwkVncyPVsxLDQ1M10sJFZ4Mj1bMiwxODVdLCRWeTI9WzYsMTAsMTFdLCRWejI9WzEsNDYxXSwkVkEyPVsxNCwyMiwxNDddLCRWQjI9WzEsNDY5XSwkVkMyPVsxLDYsMTAsMTEsMTQsMjIsNzEsOTAsOTcsMTA2LDExMiwxMzUsMTM3LDE0NywyMDAsMjAxLDIxMiwyMTQsMjE5LDIyMCwyMjksMjM4XSwkVkQyPVs1MSw1OCw4OV0sJFZFMj1bMTQsMjJdLCRWRjI9WzEsNDkyXSwkVkcyPVsxMCwxNF0sJFZIMj1bMSw1NDJdLCRWSTI9WzYsMTBdO1xudmFyIHBhcnNlciA9IHt0cmFjZTogZnVuY3Rpb24gdHJhY2UoKSB7IH0sXG55eToge30sXG5zeW1ib2xzXzoge1wiZXJyb3JcIjoyLFwiUm9vdFwiOjMsXCJCb2R5XCI6NCxcIkJsb2NrXCI6NSxcIlRFUk1JTkFUT1JcIjo2LFwiQk9EWVNUQVJUXCI6NyxcIkxpbmVcIjo4LFwiVGVybWluYXRvclwiOjksXCJJTkRFTlRcIjoxMCxcIk9VVERFTlRcIjoxMSxcIlNwbGF0XCI6MTIsXCJFeHByZXNzaW9uXCI6MTMsXCIsXCI6MTQsXCJDb21tZW50XCI6MTUsXCJTdGF0ZW1lbnRcIjoxNixcIlJldHVyblwiOjE3LFwiVGhyb3dcIjoxOCxcIlNUQVRFTUVOVFwiOjE5LFwiQlJFQUtcIjoyMCxcIkNBTExfU1RBUlRcIjoyMSxcIkNBTExfRU5EXCI6MjIsXCJDT05USU5VRVwiOjIzLFwiREVCVUdHRVJcIjoyNCxcIkltcG9ydFN0YXRlbWVudFwiOjI1LFwiSU1QT1JUXCI6MjYsXCJJbXBvcnRBcmdMaXN0XCI6MjcsXCJGUk9NXCI6MjgsXCJJbXBvcnRGcm9tXCI6MjksXCJBU1wiOjMwLFwiSW1wb3J0QXJnXCI6MzEsXCJTVFJJTkdcIjozMixcIlZhcklkZW50aWZpZXJcIjozMyxcIkF3YWl0XCI6MzQsXCJWYWx1ZVwiOjM1LFwiQ29kZVwiOjM2LFwiT3BlcmF0aW9uXCI6MzcsXCJBc3NpZ25cIjozOCxcIklmXCI6MzksXCJUZXJuYXJ5XCI6NDAsXCJUcnlcIjo0MSxcIldoaWxlXCI6NDIsXCJGb3JcIjo0MyxcIlN3aXRjaFwiOjQ0LFwiQ2xhc3NcIjo0NSxcIk1vZHVsZVwiOjQ2LFwiVGFnRGVjbGFyYXRpb25cIjo0NyxcIlRhZ1wiOjQ4LFwiUHJvcGVydHlcIjo0OSxcIklkZW50aWZpZXJcIjo1MCxcIklERU5USUZJRVJcIjo1MSxcIkl2YXJcIjo1MixcIklWQVJcIjo1MyxcIkNWQVJcIjo1NCxcIkd2YXJcIjo1NSxcIkdWQVJcIjo1NixcIkNvbnN0XCI6NTcsXCJDT05TVFwiOjU4LFwiQXJndmFyXCI6NTksXCJBUkdWQVJcIjo2MCxcIlN5bWJvbFwiOjYxLFwiU1lNQk9MXCI6NjIsXCJBbHBoYU51bWVyaWNcIjo2MyxcIk5VTUJFUlwiOjY0LFwiSW50ZXJwb2xhdGVkU3RyaW5nXCI6NjUsXCJTVFJJTkdfU1RBUlRcIjo2NixcIk5FT1NUUklOR1wiOjY3LFwiSW50ZXJwb2xhdGlvblwiOjY4LFwiU1RSSU5HX0VORFwiOjY5LFwie3tcIjo3MCxcIn19XCI6NzEsXCJMaXRlcmFsXCI6NzIsXCJKU1wiOjczLFwiUkVHRVhcIjo3NCxcIkJPT0xcIjo3NSxcIlRSVUVcIjo3NixcIkZBTFNFXCI6NzcsXCJOVUxMXCI6NzgsXCJVTkRFRklORURcIjo3OSxcIlJFVFVSTlwiOjgwLFwiQXJndW1lbnRzXCI6ODEsXCJUYWdTZWxlY3RvclwiOjgyLFwiU0VMRUNUT1JfU1RBUlRcIjo4MyxcIlRhZ1NlbGVjdG9yVHlwZVwiOjg0LFwiU0VMRUNUT1JfTlNcIjo4NSxcIlNFTEVDVE9SX0lEXCI6ODYsXCJTRUxFQ1RPUl9DTEFTU1wiOjg3LFwiLlwiOjg4LFwie1wiOjg5LFwifVwiOjkwLFwiI1wiOjkxLFwiU0VMRUNUT1JfQ09NQklOQVRPUlwiOjkyLFwiU0VMRUNUT1JfUFNFVURPX0NMQVNTXCI6OTMsXCJTRUxFQ1RPUl9HUk9VUFwiOjk0LFwiVU5JVkVSU0FMX1NFTEVDVE9SXCI6OTUsXCJbXCI6OTYsXCJdXCI6OTcsXCJTRUxFQ1RPUl9BVFRSX09QXCI6OTgsXCJUYWdTZWxlY3RvckF0dHJWYWx1ZVwiOjk5LFwiU0VMRUNUT1JfVEFHXCI6MTAwLFwiU2VsZWN0b3JcIjoxMDEsXCJTRUxFQ1RPUl9FTkRcIjoxMDIsXCJUQUdfU1RBUlRcIjoxMDMsXCJUYWdPcHRpb25zXCI6MTA0LFwiVGFnQXR0cmlidXRlc1wiOjEwNSxcIlRBR19FTkRcIjoxMDYsXCJUYWdCb2R5XCI6MTA3LFwiVGFnVHlwZU5hbWVcIjoxMDgsXCJTZWxmXCI6MTA5LFwiVEFHX1RZUEVcIjoxMTAsXCJJTkRFWF9TVEFSVFwiOjExMSxcIklOREVYX0VORFwiOjExMixcIkBcIjoxMTMsXCJUYWdBdHRyXCI6MTE0LFwiT3B0Q29tbWFcIjoxMTUsXCJUQUdfQVRUUlwiOjExNixcIj1cIjoxMTcsXCJUYWdBdHRyVmFsdWVcIjoxMTgsXCJBcmdMaXN0XCI6MTE5LFwiVGFnVHlwZURlZlwiOjEyMCxcIlRhZ0RlY2xhcmF0aW9uQmxvY2tcIjoxMjEsXCJFWFRFTkRcIjoxMjIsXCJMT0NBTFwiOjEyMyxcIlRBR1wiOjEyNCxcIlRhZ1R5cGVcIjoxMjUsXCJDT01QQVJFXCI6MTI2LFwiVGFnRGVjbEtleXdvcmRzXCI6MTI3LFwiVEFHX0lEXCI6MTI4LFwiVGFnSWRcIjoxMjksXCJJRFJFRlwiOjEzMCxcIkFzc2lnbmFibGVcIjoxMzEsXCJPdXRkZW50XCI6MTMyLFwiQXNzaWduT2JqXCI6MTMzLFwiT2JqQXNzaWduYWJsZVwiOjEzNCxcIjpcIjoxMzUsXCIoXCI6MTM2LFwiKVwiOjEzNyxcIkhFUkVDT01NRU5UXCI6MTM4LFwiQ09NTUVOVFwiOjEzOSxcIk1ldGhvZFwiOjE0MCxcIkRvXCI6MTQxLFwiQmVnaW5cIjoxNDIsXCJCRUdJTlwiOjE0MyxcIkRPXCI6MTQ0LFwiQkxPQ0tfUEFSQU1fU1RBUlRcIjoxNDUsXCJQYXJhbUxpc3RcIjoxNDYsXCJCTE9DS19QQVJBTV9FTkRcIjoxNDcsXCJQcm9wVHlwZVwiOjE0OCxcIlByb3BlcnR5SWRlbnRpZmllclwiOjE0OSxcIk9iamVjdFwiOjE1MCxcIlBST1BcIjoxNTEsXCJBVFRSXCI6MTUyLFwiVHVwbGVBc3NpZ25cIjoxNTMsXCJWQVJcIjoxNTQsXCJNZXRob2REZWNsYXJhdGlvblwiOjE1NSxcIkdMT0JBTFwiOjE1NixcIkVYUE9SVFwiOjE1NyxcIkRFRlwiOjE1OCxcIk1ldGhvZFNjb3BlXCI6MTU5LFwiTWV0aG9kU2NvcGVUeXBlXCI6MTYwLFwiTWV0aG9kSWRlbnRpZmllclwiOjE2MSxcIk1ldGhvZEJvZHlcIjoxNjIsXCJNZXRob2RSZWNlaXZlclwiOjE2MyxcIkRFRl9CT0RZXCI6MTY0LFwiREVGX0VNUFRZXCI6MTY1LFwiVGhpc1wiOjE2NixcIlBhcmFtXCI6MTY3LFwiQXJyYXlcIjoxNjgsXCJQYXJhbVZhclwiOjE2OSxcIlNQTEFUXCI6MTcwLFwiTE9HSUNcIjoxNzEsXCJCTE9DS19BUkdcIjoxNzIsXCJWYXJSZWZlcmVuY2VcIjoxNzMsXCJWYXJBc3NpZ25hYmxlXCI6MTc0LFwiTEVUXCI6MTc1LFwiU2ltcGxlQXNzaWduYWJsZVwiOjE3NixcIk5FV1wiOjE3NyxcIlN1cGVyXCI6MTc4LFwiU29ha2FibGVPcFwiOjE3OSxcIj86XCI6MTgwLFwiLjpcIjoxODEsXCJJbmRleFZhbHVlXCI6MTgyLFwiPy5cIjoxODMsXCJTVVBFUlwiOjE4NCxcIkFXQUlUXCI6MTg1LFwiUGFyZW50aGV0aWNhbFwiOjE4NixcIlJhbmdlXCI6MTg3LFwiQVJHVU1FTlRTXCI6MTg4LFwiSW52b2NhdGlvblwiOjE4OSxcIlNsaWNlXCI6MTkwLFwiQXNzaWduTGlzdFwiOjE5MSxcIkNsYXNzU3RhcnRcIjoxOTIsXCJDTEFTU1wiOjE5MyxcIk1PRFVMRVwiOjE5NCxcIk9wdEZ1bmNFeGlzdFwiOjE5NSxcIkZVTkNfRVhJU1RcIjoxOTYsXCJUSElTXCI6MTk3LFwiU0VMRlwiOjE5OCxcIlJhbmdlRG90c1wiOjE5OSxcIi4uXCI6MjAwLFwiLi4uXCI6MjAxLFwiQXJnXCI6MjAyLFwiU2ltcGxlQXJnc1wiOjIwMyxcIlRSWVwiOjIwNCxcIkNhdGNoXCI6MjA1LFwiRmluYWxseVwiOjIwNixcIkZJTkFMTFlcIjoyMDcsXCJDQVRDSFwiOjIwOCxcIkNBVENIX1ZBUlwiOjIwOSxcIlRIUk9XXCI6MjEwLFwiV2hpbGVTb3VyY2VcIjoyMTEsXCJXSElMRVwiOjIxMixcIldIRU5cIjoyMTMsXCJVTlRJTFwiOjIxNCxcIkxvb3BcIjoyMTUsXCJMT09QXCI6MjE2LFwiRm9yQm9keVwiOjIxNyxcIkZvcktleXdvcmRcIjoyMTgsXCJGT1JcIjoyMTksXCJQT1NUX0ZPUlwiOjIyMCxcIkZvckJsb2NrXCI6MjIxLFwiRm9yU3RhcnRcIjoyMjIsXCJGb3JTb3VyY2VcIjoyMjMsXCJGb3JWYXJpYWJsZXNcIjoyMjQsXCJPV05cIjoyMjUsXCJGb3JWYWx1ZVwiOjIyNixcIkZPUklOXCI6MjI3LFwiRk9ST0ZcIjoyMjgsXCJCWVwiOjIyOSxcIlNXSVRDSFwiOjIzMCxcIldoZW5zXCI6MjMxLFwiRUxTRVwiOjIzMixcIldoZW5cIjoyMzMsXCJMRUFESU5HX1dIRU5cIjoyMzQsXCJJZkJsb2NrXCI6MjM1LFwiSUZcIjoyMzYsXCJFTElGXCI6MjM3LFwiUE9TVF9JRlwiOjIzOCxcIj9cIjoyMzksXCJVTkFSWVwiOjI0MCxcIlNRUlRcIjoyNDEsXCItXCI6MjQyLFwiK1wiOjI0MyxcIi0tXCI6MjQ0LFwiKytcIjoyNDUsXCJNQVRIXCI6MjQ2LFwiU0hJRlRcIjoyNDcsXCJSRUxBVElPTlwiOjI0OCxcIkNPTVBPVU5EX0FTU0lHTlwiOjI0OSxcIiRhY2NlcHRcIjowLFwiJGVuZFwiOjF9LFxudGVybWluYWxzXzogezI6XCJlcnJvclwiLDY6XCJURVJNSU5BVE9SXCIsNzpcIkJPRFlTVEFSVFwiLDEwOlwiSU5ERU5UXCIsMTE6XCJPVVRERU5UXCIsMTQ6XCIsXCIsMTk6XCJTVEFURU1FTlRcIiwyMDpcIkJSRUFLXCIsMjE6XCJDQUxMX1NUQVJUXCIsMjI6XCJDQUxMX0VORFwiLDIzOlwiQ09OVElOVUVcIiwyNDpcIkRFQlVHR0VSXCIsMjY6XCJJTVBPUlRcIiwyODpcIkZST01cIiwzMDpcIkFTXCIsMzI6XCJTVFJJTkdcIiw1MTpcIklERU5USUZJRVJcIiw1MzpcIklWQVJcIiw1NDpcIkNWQVJcIiw1NjpcIkdWQVJcIiw1ODpcIkNPTlNUXCIsNjA6XCJBUkdWQVJcIiw2MjpcIlNZTUJPTFwiLDY0OlwiTlVNQkVSXCIsNjY6XCJTVFJJTkdfU1RBUlRcIiw2NzpcIk5FT1NUUklOR1wiLDY5OlwiU1RSSU5HX0VORFwiLDcwOlwie3tcIiw3MTpcIn19XCIsNzM6XCJKU1wiLDc0OlwiUkVHRVhcIiw3NTpcIkJPT0xcIiw3NjpcIlRSVUVcIiw3NzpcIkZBTFNFXCIsNzg6XCJOVUxMXCIsNzk6XCJVTkRFRklORURcIiw4MDpcIlJFVFVSTlwiLDgzOlwiU0VMRUNUT1JfU1RBUlRcIiw4NTpcIlNFTEVDVE9SX05TXCIsODY6XCJTRUxFQ1RPUl9JRFwiLDg3OlwiU0VMRUNUT1JfQ0xBU1NcIiw4ODpcIi5cIiw4OTpcIntcIiw5MDpcIn1cIiw5MTpcIiNcIiw5MjpcIlNFTEVDVE9SX0NPTUJJTkFUT1JcIiw5MzpcIlNFTEVDVE9SX1BTRVVET19DTEFTU1wiLDk0OlwiU0VMRUNUT1JfR1JPVVBcIiw5NTpcIlVOSVZFUlNBTF9TRUxFQ1RPUlwiLDk2OlwiW1wiLDk3OlwiXVwiLDk4OlwiU0VMRUNUT1JfQVRUUl9PUFwiLDEwMDpcIlNFTEVDVE9SX1RBR1wiLDEwMjpcIlNFTEVDVE9SX0VORFwiLDEwMzpcIlRBR19TVEFSVFwiLDEwNjpcIlRBR19FTkRcIiwxMTA6XCJUQUdfVFlQRVwiLDExMTpcIklOREVYX1NUQVJUXCIsMTEyOlwiSU5ERVhfRU5EXCIsMTEzOlwiQFwiLDExNjpcIlRBR19BVFRSXCIsMTE3OlwiPVwiLDEyMjpcIkVYVEVORFwiLDEyMzpcIkxPQ0FMXCIsMTI0OlwiVEFHXCIsMTI2OlwiQ09NUEFSRVwiLDEyODpcIlRBR19JRFwiLDEzMDpcIklEUkVGXCIsMTM1OlwiOlwiLDEzNjpcIihcIiwxMzc6XCIpXCIsMTM4OlwiSEVSRUNPTU1FTlRcIiwxMzk6XCJDT01NRU5UXCIsMTQzOlwiQkVHSU5cIiwxNDQ6XCJET1wiLDE0NTpcIkJMT0NLX1BBUkFNX1NUQVJUXCIsMTQ3OlwiQkxPQ0tfUEFSQU1fRU5EXCIsMTUxOlwiUFJPUFwiLDE1MjpcIkFUVFJcIiwxNTQ6XCJWQVJcIiwxNTY6XCJHTE9CQUxcIiwxNTc6XCJFWFBPUlRcIiwxNTg6XCJERUZcIiwxNjQ6XCJERUZfQk9EWVwiLDE2NTpcIkRFRl9FTVBUWVwiLDE3MDpcIlNQTEFUXCIsMTcxOlwiTE9HSUNcIiwxNzI6XCJCTE9DS19BUkdcIiwxNzU6XCJMRVRcIiwxNzc6XCJORVdcIiwxODA6XCI/OlwiLDE4MTpcIi46XCIsMTgzOlwiPy5cIiwxODQ6XCJTVVBFUlwiLDE4NTpcIkFXQUlUXCIsMTg4OlwiQVJHVU1FTlRTXCIsMTkzOlwiQ0xBU1NcIiwxOTQ6XCJNT0RVTEVcIiwxOTY6XCJGVU5DX0VYSVNUXCIsMTk3OlwiVEhJU1wiLDE5ODpcIlNFTEZcIiwyMDA6XCIuLlwiLDIwMTpcIi4uLlwiLDIwNDpcIlRSWVwiLDIwNzpcIkZJTkFMTFlcIiwyMDg6XCJDQVRDSFwiLDIwOTpcIkNBVENIX1ZBUlwiLDIxMDpcIlRIUk9XXCIsMjEyOlwiV0hJTEVcIiwyMTM6XCJXSEVOXCIsMjE0OlwiVU5USUxcIiwyMTY6XCJMT09QXCIsMjE5OlwiRk9SXCIsMjIwOlwiUE9TVF9GT1JcIiwyMjU6XCJPV05cIiwyMjc6XCJGT1JJTlwiLDIyODpcIkZPUk9GXCIsMjI5OlwiQllcIiwyMzA6XCJTV0lUQ0hcIiwyMzI6XCJFTFNFXCIsMjM0OlwiTEVBRElOR19XSEVOXCIsMjM2OlwiSUZcIiwyMzc6XCJFTElGXCIsMjM4OlwiUE9TVF9JRlwiLDIzOTpcIj9cIiwyNDA6XCJVTkFSWVwiLDI0MTpcIlNRUlRcIiwyNDI6XCItXCIsMjQzOlwiK1wiLDI0NDpcIi0tXCIsMjQ1OlwiKytcIiwyNDY6XCJNQVRIXCIsMjQ3OlwiU0hJRlRcIiwyNDg6XCJSRUxBVElPTlwiLDI0OTpcIkNPTVBPVU5EX0FTU0lHTlwifSxcbnByb2R1Y3Rpb25zXzogWzAsWzMsMF0sWzMsMV0sWzMsMl0sWzQsMV0sWzQsMV0sWzQsM10sWzQsMl0sWzksMV0sWzUsMl0sWzUsM10sWzUsNF0sWzgsMV0sWzgsMV0sWzgsM10sWzgsM10sWzgsMV0sWzgsMV0sWzE2LDFdLFsxNiwxXSxbMTYsMV0sWzE2LDFdLFsxNiw0XSxbMTYsMV0sWzE2LDRdLFsxNiwxXSxbMTYsMV0sWzI1LDRdLFsyNSw0XSxbMjUsMl0sWzI5LDFdLFsyNywxXSxbMjcsM10sWzMxLDFdLFsxMywxXSxbMTMsMV0sWzEzLDFdLFsxMywxXSxbMTMsMV0sWzEzLDFdLFsxMywxXSxbMTMsMV0sWzEzLDFdLFsxMywxXSxbMTMsMV0sWzEzLDFdLFsxMywxXSxbMTMsMV0sWzEzLDFdLFsxMywxXSxbNTAsMV0sWzUyLDFdLFs1MiwxXSxbNTUsMV0sWzU3LDFdLFs1OSwxXSxbNjEsMV0sWzYzLDFdLFs2MywxXSxbNjMsMV0sWzYzLDFdLFs2NSwxXSxbNjUsMl0sWzY1LDJdLFs2NSwyXSxbNjgsMl0sWzY4LDNdLFs3MiwxXSxbNzIsMV0sWzcyLDFdLFs3MiwxXSxbNzIsMV0sWzcyLDFdLFs3MiwxXSxbNzIsMV0sWzE3LDJdLFsxNywyXSxbMTcsMV0sWzgyLDFdLFs4MiwyXSxbODIsMl0sWzgyLDJdLFs4MiwyXSxbODIsNV0sWzgyLDVdLFs4MiwyXSxbODIsMl0sWzgyLDJdLFs4MiwyXSxbODIsNF0sWzgyLDZdLFs4NCwxXSxbMTAxLDJdLFs5OSwxXSxbOTksMV0sWzk5LDNdLFs0OCw0XSxbNDgsNV0sWzQ4LDVdLFsxMDgsMV0sWzEwOCwxXSxbMTA4LDFdLFsxMDgsMF0sWzEwNCwxXSxbMTA0LDNdLFsxMDQsNF0sWzEwNCwzXSxbMTA0LDVdLFsxMDQsNV0sWzEwNCwzXSxbMTA0LDJdLFsxMDQsNV0sWzEwNSwwXSxbMTA1LDFdLFsxMDUsM10sWzEwNSw0XSxbMTE0LDFdLFsxMTQsM10sWzExOCwxXSxbMTA3LDNdLFsxMDcsM10sWzEyMCwxXSxbMTIwLDNdLFs0NywxXSxbNDcsMl0sWzQ3LDJdLFsxMjEsMl0sWzEyMSwzXSxbMTIxLDRdLFsxMjEsNV0sWzEyNywwXSxbMTI3LDFdLFsxMjUsMV0sWzEyNSwxXSxbMTI5LDFdLFsxMjksMl0sWzM4LDNdLFszOCw1XSxbMTMzLDFdLFsxMzMsM10sWzEzMyw1XSxbMTMzLDFdLFsxMzQsMV0sWzEzNCwxXSxbMTM0LDFdLFsxMzQsMV0sWzEzNCwxXSxbMTM0LDNdLFsxNSwxXSxbMTUsMV0sWzM2LDFdLFszNiwxXSxbMzYsMV0sWzE0MiwyXSxbMTQxLDJdLFsxNDEsNV0sWzE0MSw2XSxbNDksM10sWzQ5LDVdLFs0OSwyXSxbMTQ4LDFdLFsxNDgsMV0sWzE0OSwxXSxbMTQ5LDNdLFsxNTMsNF0sWzE0MCwxXSxbMTQwLDJdLFsxNDAsMl0sWzE1NSw4XSxbMTU1LDVdLFsxNTUsNl0sWzE1NSwzXSxbMTYwLDFdLFsxNjAsMV0sWzE2MSwxXSxbMTYxLDFdLFsxNjEsM10sWzE2MiwyXSxbMTYyLDJdLFsxNjIsMV0sWzE1OSwxXSxbMTU5LDFdLFsxNTksMV0sWzE1OSwxXSxbMTE1LDBdLFsxMTUsMV0sWzE0NiwwXSxbMTQ2LDFdLFsxNDYsM10sWzE2NywxXSxbMTY3LDFdLFsxNjcsMV0sWzE2NywyXSxbMTY3LDJdLFsxNjcsMl0sWzE2NywzXSxbMTY5LDFdLFsxMiwyXSxbMTczLDNdLFsxNzMsMl0sWzE3MywyXSxbMTczLDNdLFsxNzMsMl0sWzMzLDFdLFszMywxXSxbMTc0LDFdLFsxNzQsMV0sWzE3NCwxXSxbMTc2LDFdLFsxNzYsMV0sWzE3NiwxXSxbMTc2LDFdLFsxNzYsMV0sWzE3NiwxXSxbMTc2LDFdLFsxNzYsM10sWzE3NiwzXSxbMTc2LDNdLFsxNzYsM10sWzE3NiwzXSxbMTc2LDNdLFsxNzYsM10sWzE3NiwzXSxbMTc2LDRdLFsxNzksMV0sWzE3OSwxXSxbMTc4LDFdLFsxMzEsMV0sWzEzMSwxXSxbMTMxLDFdLFszNCwyXSxbMzUsMV0sWzM1LDFdLFszNSwxXSxbMzUsMV0sWzM1LDFdLFszNSwxXSxbMzUsMV0sWzM1LDFdLFszNSwxXSxbMzUsMV0sWzE4MiwxXSxbMTgyLDFdLFsxNTAsNF0sWzE5MSwwXSxbMTkxLDFdLFsxOTEsM10sWzE5MSw0XSxbMTkxLDZdLFs0NSwxXSxbNDUsMl0sWzQ1LDJdLFs0NSwyXSxbNDUsMl0sWzQ1LDNdLFsxOTIsMl0sWzE5MiwzXSxbMTkyLDRdLFsxOTIsNV0sWzQ2LDJdLFs0NiwzXSxbMTg5LDNdLFsxODksMl0sWzE5NSwwXSxbMTk1LDFdLFs4MSwyXSxbODEsNF0sWzE2NiwxXSxbMTA5LDFdLFsxNjgsMl0sWzE2OCw0XSxbMTk5LDFdLFsxOTksMV0sWzE4Nyw1XSxbMTkwLDNdLFsxOTAsMl0sWzE5MCwyXSxbMTE5LDFdLFsxMTksM10sWzExOSw0XSxbMTE5LDRdLFsxMTksNl0sWzEzMiwyXSxbMTMyLDFdLFsyMDIsMV0sWzIwMiwxXSxbMjAyLDFdLFsyMDIsMV0sWzIwMywxXSxbMjAzLDNdLFs0MSwyXSxbNDEsM10sWzQxLDNdLFs0MSw0XSxbMjA2LDJdLFsyMDUsM10sWzE4LDJdLFsxODYsM10sWzE4Niw1XSxbMjExLDJdLFsyMTEsNF0sWzIxMSwyXSxbMjExLDRdLFs0MiwyXSxbNDIsMl0sWzQyLDJdLFs0MiwxXSxbMjE1LDJdLFsyMTUsMl0sWzQzLDJdLFs0MywyXSxbNDMsMl0sWzIxOCwxXSxbMjE4LDFdLFsyMjEsMl0sWzIxNywyXSxbMjE3LDJdLFsyMjIsMl0sWzIyMiwzXSxbMjI2LDFdLFsyMjYsMV0sWzIyNiwxXSxbMjI0LDFdLFsyMjQsM10sWzIyMywyXSxbMjIzLDJdLFsyMjMsNF0sWzIyMyw0XSxbMjIzLDRdLFsyMjMsNl0sWzIyMyw2XSxbNDQsNV0sWzQ0LDddLFs0NCw0XSxbNDQsNl0sWzIzMSwxXSxbMjMxLDJdLFsyMzMsM10sWzIzMyw0XSxbMjM1LDNdLFsyMzUsNV0sWzIzNSw0XSxbMjM1LDNdLFszOSwxXSxbMzksM10sWzM5LDNdLFs0MCw1XSxbMzcsMl0sWzM3LDJdLFszNywyXSxbMzcsMl0sWzM3LDJdLFszNywyXSxbMzcsMl0sWzM3LDJdLFszNywzXSxbMzcsM10sWzM3LDNdLFszNywzXSxbMzcsM10sWzM3LDNdLFszNywzXSxbMzcsM10sWzM3LDVdXSxcbnBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uIHBlcmZvcm1BY3Rpb24oc2VsZiwgeXl0ZXh0LCB5eSwgeXlzdGF0ZSAvKiBhY3Rpb25bMV0gKi8sICQkIC8qIHZzdGFjayAqLykge1xuLyogc2VsZiA9PSB5eXZhbCAqL1xuXG52YXIgJDAgPSAkJC5sZW5ndGggLSAxO1xuc3dpdGNoICh5eXN0YXRlKSB7XG5jYXNlIDE6XG5yZXR1cm4gc2VsZi4kID0gbmV3IHl5LlJvb3QoW10pO1xuYnJlYWs7XG5jYXNlIDI6XG5yZXR1cm4gc2VsZi4kID0gbmV3IHl5LlJvb3QoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAzOlxucmV0dXJuIHNlbGYuJCA9ICQkWyQwLTFdO1xuYnJlYWs7XG5jYXNlIDQ6XG5zZWxmLiQgPSBuZXcgeXkuQmxvY2soW10pO1xuYnJlYWs7XG5jYXNlIDU6XG5zZWxmLiQgPSBuZXcgeXkuQmxvY2soWyQkWyQwXV0pO1xuYnJlYWs7XG5jYXNlIDY6XG5zZWxmLiQgPSAkJFskMC0yXS5icmVhaygkJFskMC0xXSkuYWRkKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgNzpcbnNlbGYuJCA9ICQkWyQwLTFdLmJyZWFrKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgODpcbnNlbGYuJCA9IG5ldyB5eS5UZXJtaW5hdG9yKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgOTpcbnNlbGYuJCA9IG5ldyB5eS5CbG9jayhbXSkuaW5kZW50ZWQoJCRbJDAtMV0sJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAxMDogY2FzZSAxMTk6XG5zZWxmLiQgPSAkJFskMC0xXS5pbmRlbnRlZCgkJFskMC0yXSwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDExOlxuc2VsZi4kID0gJCRbJDAtMV0ucHJlYnJlYWsoJCRbJDAtMl0pLmluZGVudGVkKCQkWyQwLTNdLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMTI6IGNhc2UgMTM6IGNhc2UgMTY6IGNhc2UgMTc6IGNhc2UgMTg6IGNhc2UgMTk6IGNhc2UgMjY6IGNhc2UgMzA6IGNhc2UgMzM6IGNhc2UgMzQ6IGNhc2UgMzU6IGNhc2UgMzY6IGNhc2UgMzc6IGNhc2UgMzg6IGNhc2UgMzk6IGNhc2UgNDA6IGNhc2UgNDE6IGNhc2UgNDI6IGNhc2UgNDM6IGNhc2UgNDQ6IGNhc2UgNDU6IGNhc2UgNDY6IGNhc2UgNDc6IGNhc2UgNDg6IGNhc2UgNDk6IGNhc2UgNTk6IGNhc2UgNjA6IGNhc2UgNjc6IGNhc2UgOTM6IGNhc2UgOTQ6IGNhc2UgOTk6IGNhc2UgMTE4OiBjYXNlIDEyMzogY2FzZSAxMzA6IGNhc2UgMTQxOiBjYXNlIDE0MjogY2FzZSAxNDM6IGNhc2UgMTQ0OiBjYXNlIDE0NTogY2FzZSAxNDY6IGNhc2UgMTUwOiBjYXNlIDE1MTogY2FzZSAxNTI6IGNhc2UgMTYwOiBjYXNlIDE2MTogY2FzZSAxNjI6IGNhc2UgMTY1OiBjYXNlIDE3NDogY2FzZSAxNzU6IGNhc2UgMTc3OiBjYXNlIDE4MDogY2FzZSAxODE6IGNhc2UgMTgyOiBjYXNlIDE4MzogY2FzZSAxODQ6IGNhc2UgMTg1OiBjYXNlIDE5NjogY2FzZSAyMDM6IGNhc2UgMjA0OiBjYXNlIDIwNTogY2FzZSAyMDY6IGNhc2UgMjA3OiBjYXNlIDIwODogY2FzZSAyMTA6IGNhc2UgMjExOiBjYXNlIDIxMjogY2FzZSAyMTM6IGNhc2UgMjI3OiBjYXNlIDIyODogY2FzZSAyMjk6IGNhc2UgMjMxOiBjYXNlIDIzMjogY2FzZSAyMzM6IGNhc2UgMjM0OiBjYXNlIDIzNTogY2FzZSAyMzc6IGNhc2UgMjM4OiBjYXNlIDIzOTogY2FzZSAyNDA6IGNhc2UgMjQ5OiBjYXNlIDI4MzogY2FzZSAyODQ6IGNhc2UgMjg1OiBjYXNlIDI4NjogY2FzZSAyODc6IGNhc2UgMjg4OiBjYXNlIDMwNjogY2FzZSAzMTI6IGNhc2UgMzEzOiBjYXNlIDMxOTogY2FzZSAzMzU6IGNhc2UgMzQzOlxuc2VsZi4kID0gJCRbJDBdO1xuYnJlYWs7XG5jYXNlIDE0OiBjYXNlIDE1Olxuc2VsZi4kID0gJCRbJDAtMl0uYWRkRXhwcmVzc2lvbigkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDIwOiBjYXNlIDY4Olxuc2VsZi4kID0gbmV3IHl5LkxpdGVyYWwoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyMTpcbnNlbGYuJCA9IG5ldyB5eS5CcmVha1N0YXRlbWVudCgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDIyOlxuc2VsZi4kID0gbmV3IHl5LkJyZWFrU3RhdGVtZW50KCQkWyQwLTNdLCQkWyQwLTFdKTtcbmJyZWFrO1xuY2FzZSAyMzpcbnNlbGYuJCA9IG5ldyB5eS5Db250aW51ZVN0YXRlbWVudCgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDI0Olxuc2VsZi4kID0gbmV3IHl5LkNvbnRpbnVlU3RhdGVtZW50KCQkWyQwLTNdLCQkWyQwLTFdKTtcbmJyZWFrO1xuY2FzZSAyNTpcbnNlbGYuJCA9IG5ldyB5eS5EZWJ1Z2dlclN0YXRlbWVudCgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDI3Olxuc2VsZi4kID0gbmV3IHl5LkltcG9ydFN0YXRlbWVudCgkJFskMC0yXSwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDI4Olxuc2VsZi4kID0gbmV3IHl5LkltcG9ydFN0YXRlbWVudChudWxsLCQkWyQwLTJdLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjk6XG5zZWxmLiQgPSBuZXcgeXkuSW1wb3J0U3RhdGVtZW50KG51bGwsJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAzMTogY2FzZSAxMTM6IGNhc2UgMTg3OiBjYXNlIDMyMjpcbnNlbGYuJCA9IFskJFskMF1dO1xuYnJlYWs7XG5jYXNlIDMyOiBjYXNlIDExNDogY2FzZSAxODg6XG5zZWxmLiQgPSAkJFskMC0yXS5jb25jYXQoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSA1MDpcbnNlbGYuJCA9IG5ldyB5eS5JZGVudGlmaWVyKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgNTE6IGNhc2UgNTI6XG5zZWxmLiQgPSBuZXcgeXkuSXZhcigkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDUzOlxuc2VsZi4kID0gbmV3IHl5Lkd2YXIoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSA1NDpcbnNlbGYuJCA9IG5ldyB5eS5Db25zdCgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDU1Olxuc2VsZi4kID0gbmV3IHl5LkFyZ3ZhcigkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDU2Olxuc2VsZi4kID0gbmV3IHl5LlN5bWJvbCgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDU3Olxuc2VsZi4kID0gbmV3IHl5Lk51bSgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDU4Olxuc2VsZi4kID0gbmV3IHl5LlN0cigkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDYxOlxuc2VsZi4kID0gbmV3IHl5LkludGVycG9sYXRlZFN0cmluZyhbXSx7b3BlbjogJCRbJDBdfSk7XG5icmVhaztcbmNhc2UgNjI6XG5zZWxmLiQgPSAkJFskMC0xXS5hZGQoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSA2MzpcbnNlbGYuJCA9ICQkWyQwXSA/ICgkJFskMC0xXS5hZGQoJCRbJDBdKSkgOiAoJCRbJDAtMV0pO1xuYnJlYWs7XG5jYXNlIDY0Olxuc2VsZi4kID0gJCRbJDAtMV0ub3B0aW9uKCdjbG9zZScsJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSA2NTpcbnNlbGYuJCA9IG51bGw7XG5icmVhaztcbmNhc2UgNjY6IGNhc2UgOTI6IGNhc2UgOTU6IGNhc2UgMTIwOiBjYXNlIDE0NzogY2FzZSAxNjM6IGNhc2UgMTc2OiBjYXNlIDI4MjpcbnNlbGYuJCA9ICQkWyQwLTFdO1xuYnJlYWs7XG5jYXNlIDY5Olxuc2VsZi4kID0gbmV3IHl5LlJlZ0V4cCgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDcwOlxuc2VsZi4kID0gbmV3IHl5LkJvb2woJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSA3MTpcbnNlbGYuJCA9IHl5LlRSVUU7XG5icmVhaztcbmNhc2UgNzI6XG5zZWxmLiQgPSB5eS5GQUxTRTtcbmJyZWFrO1xuY2FzZSA3MzpcbnNlbGYuJCA9IHl5Lk5JTDtcbmJyZWFrO1xuY2FzZSA3NDpcbnNlbGYuJCA9IHl5LlVOREVGSU5FRDtcbmJyZWFrO1xuY2FzZSA3NTogY2FzZSA3NjpcbnNlbGYuJCA9IG5ldyB5eS5SZXR1cm4oJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSA3NzpcbnNlbGYuJCA9IG5ldyB5eS5SZXR1cm4oKTtcbmJyZWFrO1xuY2FzZSA3ODpcbnNlbGYuJCA9IG5ldyB5eS5TZWxlY3RvcihbXSx7dHlwZTogJCRbJDBdfSk7XG5icmVhaztcbmNhc2UgNzk6XG5zZWxmLiQgPSAkJFskMC0xXS5hZGQobmV3IHl5LlNlbGVjdG9yVHlwZSgkJFskMF0pLCd0YWcnKTtcbmJyZWFrO1xuY2FzZSA4MDpcbnNlbGYuJCA9ICQkWyQwLTFdLmFkZChuZXcgeXkuU2VsZWN0b3JOYW1lc3BhY2UoJCRbJDBdKSwnbnMnKTtcbmJyZWFrO1xuY2FzZSA4MTpcbnNlbGYuJCA9ICQkWyQwLTFdLmFkZChuZXcgeXkuU2VsZWN0b3JJZCgkJFskMF0pLCdpZCcpO1xuYnJlYWs7XG5jYXNlIDgyOlxuc2VsZi4kID0gJCRbJDAtMV0uYWRkKG5ldyB5eS5TZWxlY3RvckNsYXNzKCQkWyQwXSksJ2NsYXNzJyk7XG5icmVhaztcbmNhc2UgODM6XG5zZWxmLiQgPSAkJFskMC00XS5hZGQobmV3IHl5LlNlbGVjdG9yQ2xhc3MoJCRbJDAtMV0pLCdjbGFzcycpO1xuYnJlYWs7XG5jYXNlIDg0Olxuc2VsZi4kID0gJCRbJDAtNF0uYWRkKG5ldyB5eS5TZWxlY3RvcklkKCQkWyQwLTFdKSwnaWQnKTtcbmJyZWFrO1xuY2FzZSA4NTpcbnNlbGYuJCA9ICQkWyQwLTFdLmFkZChuZXcgeXkuU2VsZWN0b3JDb21iaW5hdG9yKCQkWyQwXSksJ3NlcCcpO1xuYnJlYWs7XG5jYXNlIDg2Olxuc2VsZi4kID0gJCRbJDAtMV0uYWRkKG5ldyB5eS5TZWxlY3RvclBzZXVkb0NsYXNzKCQkWyQwXSksJ3BzZXVkb2NsYXNzJyk7XG5icmVhaztcbmNhc2UgODc6XG5zZWxmLiQgPSAkJFskMC0xXS5ncm91cCgpO1xuYnJlYWs7XG5jYXNlIDg4Olxuc2VsZi4kID0gJCRbJDAtMV0uYWRkKG5ldyB5eS5TZWxlY3RvclVuaXZlcnNhbCgkJFskMF0pLCd1bml2ZXJzYWwnKTtcbmJyZWFrO1xuY2FzZSA4OTpcbnNlbGYuJCA9ICQkWyQwLTNdLmFkZChuZXcgeXkuU2VsZWN0b3JBdHRyaWJ1dGUoJCRbJDAtMV0pLCdhdHRyJyk7XG5icmVhaztcbmNhc2UgOTA6XG5zZWxmLiQgPSAkJFskMC01XS5hZGQobmV3IHl5LlNlbGVjdG9yQXR0cmlidXRlKCQkWyQwLTNdLCQkWyQwLTJdLCQkWyQwLTFdKSwnYXR0cicpO1xuYnJlYWs7XG5jYXNlIDkxOiBjYXNlIDEwMDogY2FzZSAxMDE6IGNhc2UgMTMyOiBjYXNlIDEzMzpcbnNlbGYuJCA9IG5ldyB5eS5UYWdUeXBlSWRlbnRpZmllcigkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDk2Olxuc2VsZi4kID0gJCRbJDAtMl0uc2V0KHthdHRyaWJ1dGVzOiAkJFskMC0xXSxvcGVuOiAkJFskMC0zXSxjbG9zZTogJCRbJDBdfSk7XG5icmVhaztcbmNhc2UgOTc6XG5zZWxmLiQgPSAkJFskMC0zXS5zZXQoe2F0dHJpYnV0ZXM6ICQkWyQwLTJdLGJvZHk6ICQkWyQwXSxvcGVuOiAkJFskMC00XSxjbG9zZTogJCRbJDAtMV19KTtcbmJyZWFrO1xuY2FzZSA5ODpcbnNlbGYuJCA9IG5ldyB5eS5UYWdXcmFwcGVyKCQkWyQwLTJdLCQkWyQwLTRdLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMTAyOlxuc2VsZi4kID0gbmV3IHl5LlRhZ1R5cGVJZGVudGlmaWVyKCdkaXYnKTtcbmJyZWFrO1xuY2FzZSAxMDM6XG5zZWxmLiQgPSBuZXcgeXkuVGFnKHt0eXBlOiAkJFskMF19KTtcbmJyZWFrO1xuY2FzZSAxMDQ6XG5zZWxmLiQgPSAkJFskMC0yXS5hZGRTeW1ib2woJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAxMDU6XG5zZWxmLiQgPSAkJFskMC0zXS5hZGRJbmRleCgkJFskMC0xXSk7XG5icmVhaztcbmNhc2UgMTA2Olxuc2VsZi4kID0gJCRbJDAtMl0uYWRkQ2xhc3MoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAxMDc6XG5zZWxmLiQgPSAkJFskMC00XS5hZGRDbGFzcygkJFskMC0xXSk7XG5icmVhaztcbmNhc2UgMTA4Olxuc2VsZi4kID0gJCRbJDAtNF0uc2V0KHtrZXk6ICQkWyQwLTFdfSk7XG5icmVhaztcbmNhc2UgMTA5Olxuc2VsZi4kID0gJCRbJDAtMl0uc2V0KHtpZDogJCRbJDBdfSk7XG5icmVhaztcbmNhc2UgMTEwOlxuc2VsZi4kID0gJCRbJDAtMV0uc2V0KHtpdmFyOiAkJFskMF19KTtcbmJyZWFrO1xuY2FzZSAxMTE6XG5zZWxmLiQgPSAkJFskMC00XS5zZXQoe2lkOiAkJFskMC0xXX0pO1xuYnJlYWs7XG5jYXNlIDExMjogY2FzZSAxNzk6IGNhc2UgMTg2Olxuc2VsZi4kID0gW107XG5icmVhaztcbmNhc2UgMTE1Olxuc2VsZi4kID0gJCRbJDAtM10uY29uY2F0KCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMTE2Olxuc2VsZi4kID0gbmV3IHl5LlRhZ0F0dHIoJCRbJDBdLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMTE3Olxuc2VsZi4kID0gbmV3IHl5LlRhZ0F0dHIoJCRbJDAtMl0sJCRbJDBdLCQkWyQwLTFdKTtcbmJyZWFrO1xuY2FzZSAxMjE6XG5zZWxmLiQgPSBuZXcgeXkuVGFnRGVzYygkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDEyMjpcbnNlbGYuJCA9ICQkWyQwLTJdLmNsYXNzZXMoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAxMjQ6XG5zZWxmLiQgPSAkJFskMF0uc2V0KHtleHRlbnNpb246IHRydWV9KTtcbmJyZWFrO1xuY2FzZSAxMjU6XG5zZWxmLiQgPSAkJFskMF0uc2V0KHtsb2NhbDogdHJ1ZX0pO1xuYnJlYWs7XG5jYXNlIDEyNjpcbnNlbGYuJCA9IG5ldyB5eS5UYWdEZWNsYXJhdGlvbigkJFskMF0pLnNldCh7a2V5d29yZDogJCRbJDAtMV19KTtcbmJyZWFrO1xuY2FzZSAxMjc6XG5zZWxmLiQgPSBuZXcgeXkuVGFnRGVjbGFyYXRpb24oJCRbJDAtMV0sbnVsbCwkJFskMF0pLnNldCh7a2V5d29yZDogJCRbJDAtMl19KTtcbmJyZWFrO1xuY2FzZSAxMjg6XG5zZWxmLiQgPSBuZXcgeXkuVGFnRGVjbGFyYXRpb24oJCRbJDAtMl0sJCRbJDBdKS5zZXQoe2tleXdvcmQ6ICQkWyQwLTNdfSk7XG5icmVhaztcbmNhc2UgMTI5Olxuc2VsZi4kID0gbmV3IHl5LlRhZ0RlY2xhcmF0aW9uKCQkWyQwLTNdLCQkWyQwLTFdLCQkWyQwXSkuc2V0KHtrZXl3b3JkOiAkJFskMC00XX0pO1xuYnJlYWs7XG5jYXNlIDEzMTpcbnNlbGYuJCA9IFsneXkuZXh0ZW5kJ107XG5icmVhaztcbmNhc2UgMTM0OiBjYXNlIDEzNTpcbnNlbGYuJCA9IG5ldyB5eS5UYWdJZCgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDEzNjpcbnNlbGYuJCA9IG5ldyB5eS5Bc3NpZ24oJCRbJDAtMV0sJCRbJDAtMl0sJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAxMzc6XG5zZWxmLiQgPSBuZXcgeXkuQXNzaWduKCQkWyQwLTNdLCQkWyQwLTRdLCQkWyQwLTFdLmluZGVudGVkKCQkWyQwLTJdLCQkWyQwXSkpO1xuYnJlYWs7XG5jYXNlIDEzODpcbnNlbGYuJCA9IG5ldyB5eS5PYmpBdHRyKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMTM5Olxuc2VsZi4kID0gbmV3IHl5Lk9iakF0dHIoJCRbJDAtMl0sJCRbJDBdLCdvYmplY3QnKTtcbmJyZWFrO1xuY2FzZSAxNDA6XG5zZWxmLiQgPSBuZXcgeXkuT2JqQXR0cigkJFskMC00XSwkJFskMC0xXS5pbmRlbnRlZCgkJFskMC0yXSwkJFskMF0pLCdvYmplY3QnKTtcbmJyZWFrO1xuY2FzZSAxNDg6XG5zZWxmLiQgPSBuZXcgeXkuQ29tbWVudCgkJFskMF0sdHJ1ZSk7XG5icmVhaztcbmNhc2UgMTQ5Olxuc2VsZi4kID0gbmV3IHl5LkNvbW1lbnQoJCRbJDBdLGZhbHNlKTtcbmJyZWFrO1xuY2FzZSAxNTM6XG5zZWxmLiQgPSBuZXcgeXkuQmVnaW4oJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAxNTQ6XG5zZWxmLiQgPSBuZXcgeXkuTGFtYmRhKFtdLCQkWyQwXSxudWxsLG51bGwse2JvdW5kOiB0cnVlfSk7XG5icmVhaztcbmNhc2UgMTU1Olxuc2VsZi4kID0gbmV3IHl5LkxhbWJkYSgkJFskMC0yXSwkJFskMF0sbnVsbCxudWxsLHtib3VuZDogdHJ1ZX0pO1xuYnJlYWs7XG5jYXNlIDE1NjpcbnNlbGYuJCA9IG5ldyB5eS5MYW1iZGEoJCRbJDAtM10sJCRbJDAtMV0sbnVsbCxudWxsLHtib3VuZDogdHJ1ZX0pO1xuYnJlYWs7XG5jYXNlIDE1NzpcbnNlbGYuJCA9IG5ldyB5eS5Qcm9wZXJ0eURlY2xhcmF0aW9uKCQkWyQwLTFdLCQkWyQwXSwkJFskMC0yXSk7XG5icmVhaztcbmNhc2UgMTU4Olxuc2VsZi4kID0gbmV3IHl5LlByb3BlcnR5RGVjbGFyYXRpb24oJCRbJDAtM10sJCRbJDAtMV0sJCRbJDAtNF0pO1xuYnJlYWs7XG5jYXNlIDE1OTpcbnNlbGYuJCA9IG5ldyB5eS5Qcm9wZXJ0eURlY2xhcmF0aW9uKCQkWyQwXSxudWxsLCQkWyQwLTFdKTtcbmJyZWFrO1xuY2FzZSAxNjQ6XG5zZWxmLiQgPSAkJFskMC0zXTtcbmJyZWFrO1xuY2FzZSAxNjY6IGNhc2UgMjUyOlxuc2VsZi4kID0gJCRbJDBdLnNldCh7Z2xvYmFsOiAkJFskMC0xXX0pO1xuYnJlYWs7XG5jYXNlIDE2NzogY2FzZSAyMDI6IGNhc2UgMjUzOlxuc2VsZi4kID0gJCRbJDBdLnNldCh7ZXhwb3J0OiAkJFskMC0xXX0pO1xuYnJlYWs7XG5jYXNlIDE2ODpcbnNlbGYuJCA9IG5ldyB5eS5NZXRob2REZWNsYXJhdGlvbigkJFskMC0yXSwkJFskMF0sJCRbJDAtNF0sJCRbJDAtNl0sJCRbJDAtNV0pLnNldCh7ZGVmOiAkJFskMC03XX0pO1xuYnJlYWs7XG5jYXNlIDE2OTpcbnNlbGYuJCA9IG5ldyB5eS5NZXRob2REZWNsYXJhdGlvbihbXSwkJFskMF0sJCRbJDAtMV0sJCRbJDAtM10sJCRbJDAtMl0pLnNldCh7ZGVmOiAkJFskMC00XX0pO1xuYnJlYWs7XG5jYXNlIDE3MDpcbnNlbGYuJCA9IG5ldyB5eS5NZXRob2REZWNsYXJhdGlvbigkJFskMC0yXSwkJFskMF0sJCRbJDAtNF0sbnVsbCkuc2V0KHtkZWY6ICQkWyQwLTVdfSk7XG5icmVhaztcbmNhc2UgMTcxOlxuc2VsZi4kID0gbmV3IHl5Lk1ldGhvZERlY2xhcmF0aW9uKFtdLCQkWyQwXSwkJFskMC0xXSxudWxsKS5zZXQoe2RlZjogJCRbJDAtMl19KTtcbmJyZWFrO1xuY2FzZSAxNzI6XG5zZWxmLiQgPSB7c3RhdGljOiB0cnVlfTtcbmJyZWFrO1xuY2FzZSAxNzM6XG5zZWxmLiQgPSB7fTtcbmJyZWFrO1xuY2FzZSAxNzg6XG5zZWxmLiQgPSAkJFskMF0uYm9keSgpO1xuYnJlYWs7XG5jYXNlIDE4OTpcbnNlbGYuJCA9IG5ldyB5eS5OYW1lZFBhcmFtcygkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDE5MDpcbnNlbGYuJCA9IG5ldyB5eS5BcnJheVBhcmFtcygkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDE5MTpcbnNlbGYuJCA9IG5ldyB5eS5SZXF1aXJlZFBhcmFtKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMTkyOlxuc2VsZi4kID0gbmV3IHl5LlNwbGF0UGFyYW0oJCRbJDBdLG51bGwsJCRbJDAtMV0pO1xuYnJlYWs7XG5jYXNlIDE5MzogY2FzZSAxOTQ6XG5zZWxmLiQgPSBuZXcgeXkuQmxvY2tQYXJhbSgkJFskMF0sbnVsbCwkJFskMC0xXSk7XG5icmVhaztcbmNhc2UgMTk1Olxuc2VsZi4kID0gbmV3IHl5Lk9wdGlvbmFsUGFyYW0oJCRbJDAtMl0sJCRbJDBdLCQkWyQwLTFdKTtcbmJyZWFrO1xuY2FzZSAxOTc6XG5zZWxmLiQgPSB5eS5TUExBVCgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDE5ODogY2FzZSAyMDE6XG5zZWxmLiQgPSB5eS5TUExBVChuZXcgeXkuVmFyUmVmZXJlbmNlKCQkWyQwXSwkJFskMC0yXSksJCRbJDAtMV0pO1xuYnJlYWs7XG5jYXNlIDE5OTogY2FzZSAyMDA6XG5zZWxmLiQgPSBuZXcgeXkuVmFyUmVmZXJlbmNlKCQkWyQwXSwkJFskMC0xXSk7XG5icmVhaztcbmNhc2UgMjA5Olxuc2VsZi4kID0gbmV3IHl5Lkl2YXJBY2Nlc3MoJy4nLG51bGwsJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyMTQ6XG5zZWxmLiQgPSBuZXcgeXkuVmFyT3JBY2Nlc3MoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyMTU6XG5zZWxmLiQgPSBuZXcgeXkuTmV3KCQkWyQwLTJdKTtcbmJyZWFrO1xuY2FzZSAyMTY6XG5zZWxmLiQgPSBuZXcgeXkuU3VwZXJBY2Nlc3MoJy4nLCQkWyQwLTJdLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjE3Olxuc2VsZi4kID0gbmV3IHl5LlByb3BlcnR5QWNjZXNzKCQkWyQwLTFdLCQkWyQwLTJdLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjE4OiBjYXNlIDIxOTogY2FzZSAyMjA6IGNhc2UgMjIyOlxuc2VsZi4kID0gbmV3IHl5LkFjY2VzcygkJFskMC0xXSwkJFskMC0yXSwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDIyMTpcbnNlbGYuJCA9IG5ldyB5eS5BY2Nlc3MoJy4nLCQkWyQwLTJdLG5ldyB5eS5JZGVudGlmaWVyKCQkWyQwXS52YWx1ZSgpKSk7XG5icmVhaztcbmNhc2UgMjIzOlxuc2VsZi4kID0gbmV3IHl5LkluZGV4QWNjZXNzKCcuJywkJFskMC0zXSwkJFskMC0xXSk7XG5icmVhaztcbmNhc2UgMjI2Olxuc2VsZi4kID0geXkuU1VQRVI7XG5icmVhaztcbmNhc2UgMjMwOlxuc2VsZi4kID0gbmV3IHl5LkF3YWl0KCQkWyQwXSkuc2V0KHtrZXl3b3JkOiAkJFskMC0xXX0pO1xuYnJlYWs7XG5jYXNlIDIzNjpcbnNlbGYuJCA9IHl5LkFSR1VNRU5UUztcbmJyZWFrO1xuY2FzZSAyNDE6XG5zZWxmLiQgPSBuZXcgeXkuSW5kZXgoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyNDI6XG5zZWxmLiQgPSBuZXcgeXkuU2xpY2UoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyNDM6XG5zZWxmLiQgPSBuZXcgeXkuT2JqKCQkWyQwLTJdLCQkWyQwLTNdLmdlbmVyYXRlZCk7XG5icmVhaztcbmNhc2UgMjQ0Olxuc2VsZi4kID0gbmV3IHl5LkFzc2lnbkxpc3QoW10pO1xuYnJlYWs7XG5jYXNlIDI0NTpcbnNlbGYuJCA9IG5ldyB5eS5Bc3NpZ25MaXN0KFskJFskMF1dKTtcbmJyZWFrO1xuY2FzZSAyNDY6IGNhc2UgMjc4Olxuc2VsZi4kID0gJCRbJDAtMl0uYWRkKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjQ3OiBjYXNlIDI3OTpcbnNlbGYuJCA9ICQkWyQwLTNdLmFkZCgkJFskMC0xXSkuYWRkKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjQ4Olxuc2VsZi4kID0gJCRbJDAtNV0uY29uY2F0KCQkWyQwLTJdLmluZGVudGVkKCQkWyQwLTNdLCQkWyQwXSkpO1xuYnJlYWs7XG5jYXNlIDI1MDpcbnNlbGYuJCA9ICQkWyQwXS5zZXQoe2V4dGVuc2lvbjogJCRbJDAtMV19KTtcbmJyZWFrO1xuY2FzZSAyNTE6XG5zZWxmLiQgPSAkJFskMF0uc2V0KHtsb2NhbDogJCRbJDAtMV19KTtcbmJyZWFrO1xuY2FzZSAyNTQ6XG5zZWxmLiQgPSAkJFskMF0uc2V0KHtleHBvcnQ6ICQkWyQwLTJdLGxvY2FsOiAkJFskMC0xXX0pO1xuYnJlYWs7XG5jYXNlIDI1NTpcbnNlbGYuJCA9IG5ldyB5eS5DbGFzc0RlY2xhcmF0aW9uKCQkWyQwXSxudWxsLFtdKS5zZXQoe2tleXdvcmQ6ICQkWyQwLTFdfSk7XG5icmVhaztcbmNhc2UgMjU2Olxuc2VsZi4kID0gbmV3IHl5LkNsYXNzRGVjbGFyYXRpb24oJCRbJDAtMV0sbnVsbCwkJFskMF0pLnNldCh7a2V5d29yZDogJCRbJDAtMl19KTtcbmJyZWFrO1xuY2FzZSAyNTc6XG5zZWxmLiQgPSBuZXcgeXkuQ2xhc3NEZWNsYXJhdGlvbigkJFskMC0yXSwkJFskMF0sW10pLnNldCh7a2V5d29yZDogJCRbJDAtM119KTtcbmJyZWFrO1xuY2FzZSAyNTg6XG5zZWxmLiQgPSBuZXcgeXkuQ2xhc3NEZWNsYXJhdGlvbigkJFskMC0zXSwkJFskMC0xXSwkJFskMF0pLnNldCh7a2V5d29yZDogJCRbJDAtNF19KTtcbmJyZWFrO1xuY2FzZSAyNTk6XG5zZWxmLiQgPSBuZXcgeXkuTW9kdWxlKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjYwOlxuc2VsZi4kID0gbmV3IHl5Lk1vZHVsZSgkJFskMC0xXSxudWxsLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjYxOlxuc2VsZi4kID0gbmV3IHl5LkNhbGwoJCRbJDAtMl0sJCRbJDBdLCQkWyQwLTFdKTtcbmJyZWFrO1xuY2FzZSAyNjI6XG5zZWxmLiQgPSAkJFskMC0xXS5hZGRCbG9jaygkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDI2MzpcbnNlbGYuJCA9IGZhbHNlO1xuYnJlYWs7XG5jYXNlIDI2NDpcbnNlbGYuJCA9IHRydWU7XG5icmVhaztcbmNhc2UgMjY1Olxuc2VsZi4kID0gbmV3IHl5LkFyZ0xpc3QoW10pO1xuYnJlYWs7XG5jYXNlIDI2NjpcbnNlbGYuJCA9ICQkWyQwLTJdO1xuYnJlYWs7XG5jYXNlIDI2NzpcbnNlbGYuJCA9IG5ldyB5eS5UaGlzKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjY4Olxuc2VsZi4kID0gbmV3IHl5LlNlbGYoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyNjk6XG5zZWxmLiQgPSBuZXcgeXkuQXJyKG5ldyB5eS5BcmdMaXN0KFtdKSk7XG5icmVhaztcbmNhc2UgMjcwOlxuc2VsZi4kID0gbmV3IHl5LkFycigkJFskMC0yXSk7XG5icmVhaztcbmNhc2UgMjcxOlxuc2VsZi4kID0gJy4uJztcbmJyZWFrO1xuY2FzZSAyNzI6XG5zZWxmLiQgPSAnLi4uJztcbmJyZWFrO1xuY2FzZSAyNzM6XG5zZWxmLiQgPSB5eS5PUCgkJFskMC0yXSwkJFskMC0zXSwkJFskMC0xXSk7XG5icmVhaztcbmNhc2UgMjc0Olxuc2VsZi4kID0gbmV3IHl5LlJhbmdlKCQkWyQwLTJdLCQkWyQwXSwkJFskMC0xXSk7XG5icmVhaztcbmNhc2UgMjc1Olxuc2VsZi4kID0gbmV3IHl5LlJhbmdlKCQkWyQwLTFdLG51bGwsJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyNzY6XG5zZWxmLiQgPSBuZXcgeXkuUmFuZ2UobnVsbCwkJFskMF0sJCRbJDAtMV0pO1xuYnJlYWs7XG5jYXNlIDI3NzpcbnNlbGYuJCA9IG5ldyB5eS5BcmdMaXN0KFskJFskMF1dKTtcbmJyZWFrO1xuY2FzZSAyODA6XG5zZWxmLiQgPSAkJFskMC0yXS5pbmRlbnRlZCgkJFskMC0zXSwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDI4MTpcbnNlbGYuJCA9ICQkWyQwLTVdLmNvbmNhdCgkJFskMC0yXSk7XG5icmVhaztcbmNhc2UgMjg5Olxuc2VsZi4kID0gW10uY29uY2F0KCQkWyQwLTJdLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjkwOlxuc2VsZi4kID0gbmV3IHl5LlRyeSgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDI5MTpcbnNlbGYuJCA9IG5ldyB5eS5UcnkoJCRbJDAtMV0sJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyOTI6XG5zZWxmLiQgPSBuZXcgeXkuVHJ5KCQkWyQwLTFdLG51bGwsJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyOTM6XG5zZWxmLiQgPSBuZXcgeXkuVHJ5KCQkWyQwLTJdLCQkWyQwLTFdLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjk0Olxuc2VsZi4kID0gbmV3IHl5LkZpbmFsbHkoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyOTU6XG5zZWxmLiQgPSBuZXcgeXkuQ2F0Y2goJCRbJDBdLCQkWyQwLTFdKTtcbmJyZWFrO1xuY2FzZSAyOTY6XG5zZWxmLiQgPSBuZXcgeXkuVGhyb3coJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyOTc6XG5zZWxmLiQgPSBuZXcgeXkuUGFyZW5zKCQkWyQwLTFdLCQkWyQwLTJdLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjk4Olxuc2VsZi4kID0gbmV3IHl5LlBhcmVucygkJFskMC0yXSwkJFskMC00XSwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDI5OTpcbnNlbGYuJCA9IG5ldyB5eS5XaGlsZSgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDMwMDpcbnNlbGYuJCA9IG5ldyB5eS5XaGlsZSgkJFskMC0yXSx7Z3VhcmQ6ICQkWyQwXX0pO1xuYnJlYWs7XG5jYXNlIDMwMTpcbnNlbGYuJCA9IG5ldyB5eS5XaGlsZSgkJFskMF0se2ludmVydDogdHJ1ZX0pO1xuYnJlYWs7XG5jYXNlIDMwMjpcbnNlbGYuJCA9IG5ldyB5eS5XaGlsZSgkJFskMC0yXSx7aW52ZXJ0OiB0cnVlLGd1YXJkOiAkJFskMF19KTtcbmJyZWFrO1xuY2FzZSAzMDM6IGNhc2UgMzExOiBjYXNlIDMxNDpcbnNlbGYuJCA9ICQkWyQwLTFdLmFkZEJvZHkoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAzMDQ6IGNhc2UgMzA1Olxuc2VsZi4kID0gJCRbJDBdLmFkZEJvZHkoeXkuQmxvY2sud3JhcChbJCRbJDAtMV1dKSk7XG5icmVhaztcbmNhc2UgMzA3Olxuc2VsZi4kID0gbmV3IHl5LldoaWxlKG5ldyB5eS5MaXRlcmFsKCd0cnVlJykpLmFkZEJvZHkoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAzMDg6XG5zZWxmLiQgPSBuZXcgeXkuV2hpbGUobmV3IHl5LkxpdGVyYWwoJ3RydWUnKSkuYWRkQm9keSh5eS5CbG9jay53cmFwKFskJFskMF1dKSk7XG5icmVhaztcbmNhc2UgMzA5OiBjYXNlIDMxMDpcbnNlbGYuJCA9ICQkWyQwXS5hZGRCb2R5KFskJFskMC0xXV0pO1xuYnJlYWs7XG5jYXNlIDMxNTpcbnNlbGYuJCA9IHtzb3VyY2U6IG5ldyB5eS5WYWx1ZU5vZGUoJCRbJDBdKX07XG5icmVhaztcbmNhc2UgMzE2Olxuc2VsZi4kID0gJCRbJDBdLmNvbmZpZ3VyZSh7b3duOiAkJFskMC0xXS5vd24sbmFtZTogJCRbJDAtMV1bMF0saW5kZXg6ICQkWyQwLTFdWzFdLGtleXdvcmQ6ICQkWyQwLTFdLmtleXdvcmR9KTtcbmJyZWFrO1xuY2FzZSAzMTc6XG5zZWxmLiQgPSAoJCRbJDBdLmtleXdvcmQgPSAkJFskMC0xXSkgJiYgJCRbJDBdO1xuYnJlYWs7XG5jYXNlIDMxODpcbnNlbGYuJCA9ICgkJFskMF0ub3duID0gdHJ1ZSkgJiYgKCQkWyQwXS5rZXl3b3JkID0gJCRbJDAtMl0pICYmICQkWyQwXTtcbmJyZWFrO1xuY2FzZSAzMjA6IGNhc2UgMzIxOlxuc2VsZi4kID0gbmV3IHl5LlZhbHVlTm9kZSgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDMyMzpcbnNlbGYuJCA9IFskJFskMC0yXSwkJFskMF1dO1xuYnJlYWs7XG5jYXNlIDMyNDpcbnNlbGYuJCA9IG5ldyB5eS5Gb3JJbih7c291cmNlOiAkJFskMF19KTtcbmJyZWFrO1xuY2FzZSAzMjU6XG5zZWxmLiQgPSBuZXcgeXkuRm9yT2Yoe3NvdXJjZTogJCRbJDBdLG9iamVjdDogdHJ1ZX0pO1xuYnJlYWs7XG5jYXNlIDMyNjpcbnNlbGYuJCA9IG5ldyB5eS5Gb3JJbih7c291cmNlOiAkJFskMC0yXSxndWFyZDogJCRbJDBdfSk7XG5icmVhaztcbmNhc2UgMzI3Olxuc2VsZi4kID0gbmV3IHl5LkZvck9mKHtzb3VyY2U6ICQkWyQwLTJdLGd1YXJkOiAkJFskMF0sb2JqZWN0OiB0cnVlfSk7XG5icmVhaztcbmNhc2UgMzI4Olxuc2VsZi4kID0gbmV3IHl5LkZvckluKHtzb3VyY2U6ICQkWyQwLTJdLHN0ZXA6ICQkWyQwXX0pO1xuYnJlYWs7XG5jYXNlIDMyOTpcbnNlbGYuJCA9IG5ldyB5eS5Gb3JJbih7c291cmNlOiAkJFskMC00XSxndWFyZDogJCRbJDAtMl0sc3RlcDogJCRbJDBdfSk7XG5icmVhaztcbmNhc2UgMzMwOlxuc2VsZi4kID0gbmV3IHl5LkZvckluKHtzb3VyY2U6ICQkWyQwLTRdLHN0ZXA6ICQkWyQwLTJdLGd1YXJkOiAkJFskMF19KTtcbmJyZWFrO1xuY2FzZSAzMzE6XG5zZWxmLiQgPSBuZXcgeXkuU3dpdGNoKCQkWyQwLTNdLCQkWyQwLTFdKTtcbmJyZWFrO1xuY2FzZSAzMzI6XG5zZWxmLiQgPSBuZXcgeXkuU3dpdGNoKCQkWyQwLTVdLCQkWyQwLTNdLCQkWyQwLTFdKTtcbmJyZWFrO1xuY2FzZSAzMzM6XG5zZWxmLiQgPSBuZXcgeXkuU3dpdGNoKG51bGwsJCRbJDAtMV0pO1xuYnJlYWs7XG5jYXNlIDMzNDpcbnNlbGYuJCA9IG5ldyB5eS5Td2l0Y2gobnVsbCwkJFskMC0zXSwkJFskMC0xXSk7XG5icmVhaztcbmNhc2UgMzM2Olxuc2VsZi4kID0gJCRbJDAtMV0uY29uY2F0KCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMzM3Olxuc2VsZi4kID0gW25ldyB5eS5Td2l0Y2hDYXNlKCQkWyQwLTFdLCQkWyQwXSldO1xuYnJlYWs7XG5jYXNlIDMzODpcbnNlbGYuJCA9IFtuZXcgeXkuU3dpdGNoQ2FzZSgkJFskMC0yXSwkJFskMC0xXSldO1xuYnJlYWs7XG5jYXNlIDMzOTpcbnNlbGYuJCA9IG5ldyB5eS5JZigkJFskMC0xXSwkJFskMF0se3R5cGU6ICQkWyQwLTJdfSk7XG5icmVhaztcbmNhc2UgMzQwOlxuc2VsZi4kID0gJCRbJDAtNF0uYWRkRWxzZShuZXcgeXkuSWYoJCRbJDAtMV0sJCRbJDBdLHt0eXBlOiAkJFskMC0yXX0pKTtcbmJyZWFrO1xuY2FzZSAzNDE6XG5zZWxmLiQgPSAkJFskMC0zXS5hZGRFbHNlKG5ldyB5eS5JZigkJFskMC0xXSwkJFskMF0se3R5cGU6ICQkWyQwLTJdfSkpO1xuYnJlYWs7XG5jYXNlIDM0MjpcbnNlbGYuJCA9ICQkWyQwLTJdLmFkZEVsc2UoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAzNDQ6XG5zZWxmLiQgPSBuZXcgeXkuSWYoJCRbJDBdLG5ldyB5eS5CbG9jayhbJCRbJDAtMl1dKSx7dHlwZTogJCRbJDAtMV0sc3RhdGVtZW50OiB0cnVlfSk7XG5icmVhaztcbmNhc2UgMzQ1Olxuc2VsZi4kID0gbmV3IHl5LklmKCQkWyQwXSxuZXcgeXkuQmxvY2soWyQkWyQwLTJdXSkse3R5cGU6ICQkWyQwLTFdfSk7XG5icmVhaztcbmNhc2UgMzQ2Olxuc2VsZi4kID0geXkuSWYudGVybmFyeSgkJFskMC00XSwkJFskMC0yXSwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDM0NzogY2FzZSAzNDg6XG5zZWxmLiQgPSB5eS5PUCgkJFskMC0xXSwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDM0OTpcbnNlbGYuJCA9IG5ldyB5eS5PcCgnLScsJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAzNTA6XG5zZWxmLiQgPSBuZXcgeXkuT3AoJysnLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMzUxOlxuc2VsZi4kID0gbmV3IHl5LlVuYXJ5T3AoJy0tJyxudWxsLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMzUyOlxuc2VsZi4kID0gbmV3IHl5LlVuYXJ5T3AoJysrJyxudWxsLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMzUzOlxuc2VsZi4kID0gbmV3IHl5LlVuYXJ5T3AoJy0tJywkJFskMC0xXSxudWxsLHRydWUpO1xuYnJlYWs7XG5jYXNlIDM1NDpcbnNlbGYuJCA9IG5ldyB5eS5VbmFyeU9wKCcrKycsJCRbJDAtMV0sbnVsbCx0cnVlKTtcbmJyZWFrO1xuY2FzZSAzNTU6IGNhc2UgMzU2Olxuc2VsZi4kID0gbmV3IHl5Lk9wKCQkWyQwLTFdLCQkWyQwLTJdLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMzU3OiBjYXNlIDM1ODogY2FzZSAzNTk6IGNhc2UgMzYwOlxuc2VsZi4kID0geXkuT1AoJCRbJDAtMV0sJCRbJDAtMl0sJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAzNjE6XG5zZWxmLiQgPSAoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZiAoJCRbJDAtMV0uY2hhckF0KDApID09ICchJykge1xuXHRcdFx0XHRcdHJldHVybiB5eS5PUCgkJFskMC0xXS5zbGljZSgxKSwkJFskMC0yXSwkJFskMF0pLmludmVydCgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiB5eS5PUCgkJFskMC0xXSwkJFskMC0yXSwkJFskMF0pO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSgpKTtcbmJyZWFrO1xuY2FzZSAzNjI6XG5zZWxmLiQgPSB5eS5PUF9DT01QT1VORCgkJFskMC0xXS5fdmFsdWUsJCRbJDAtMV0sJCRbJDAtMl0sJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAzNjM6XG5zZWxmLiQgPSB5eS5PUF9DT01QT1VORCgkJFskMC0zXS5fdmFsdWUsJCRbJDAtNF0sJCRbJDAtMV0uaW5kZW50ZWQoJCRbJDAtMl0sJCRbJDBdKSk7XG5icmVhaztcbn1cbn0sXG50YWJsZTogW3sxOlsyLDFdLDM6MSw0OjIsNTozLDc6JFYwLDg6NSwxMDokVjEsMTI6NywxMzo4LDE1OjksMTY6MTAsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDEzODokVnosMTM5OiRWQSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzA6JFZKLDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezE6WzNdfSx7MTpbMiwyXSw2OiRWNTEsOToxMzN9LHs2OlsxLDEzNV19LG8oJFY2MSxbMiw0XSksbygkVjYxLFsyLDVdLHsxNDokVjcxfSksezQ6MTM4LDY6WzEsMTM5XSw3OiRWMCw4OjUsMTE6WzEsMTM3XSwxMjo3LDEzOjgsMTU6OSwxNjoxMCwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTM4OiRWeiwxMzk6JFZBLDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MDokVkosMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWODEsWzIsMTJdKSxvKCRWODEsWzIsMTNdLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDEyNjokVjkxLDE3MTokVmExLDIxMjokVlUsMjE0OiRWViwyMTk6JFZYLDIyMDokVlksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSxvKCRWODEsWzIsMTZdKSxvKCRWODEsWzIsMTddLHsyMTg6MTA4LDIyMjoxMDksMjExOjE1MiwyMTc6MTUzLDIxMjokVlUsMjE0OiRWViwyMTk6JFZYLDIyMDokVlksMjM4OiRWaTF9KSx7MTM6MTU0LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWajEsWzIsMzRdKSxvKCRWajEsWzIsMzVdLHsxOTU6MTU2LDE0MToxNTcsMTc5OjE1OSwyMTokVmsxLDg4OiRWbDEsODk6JFZtMSwxMTE6JFZuMSwxNDQ6JFZDLDE4MDokVm8xLDE4MTokVnAxLDE4MzokVnExLDE5NjokVnIxfSksbygkVmoxLFsyLDM2XSksbygkVmoxLFsyLDM3XSksbygkVmoxLFsyLDM4XSksbygkVmoxLFsyLDM5XSksbygkVmoxLFsyLDQwXSksbygkVmoxLFsyLDQxXSksbygkVmoxLFsyLDQyXSksbygkVmoxLFsyLDQzXSksbygkVmoxLFsyLDQ0XSksbygkVmoxLFsyLDQ1XSksbygkVmoxLFsyLDQ2XSksbygkVmoxLFsyLDQ3XSksbygkVmoxLFsyLDQ4XSksbygkVmoxLFsyLDQ5XSksbygkVnMxLFsyLDE0OF0pLG8oJFZzMSxbMiwxNDldKSxvKCRWdDEsWzIsMThdKSxvKCRWdDEsWzIsMTldKSxvKCRWdDEsWzIsMjBdKSxvKCRWdDEsWzIsMjFdLHsyMTpbMSwxNjZdfSksbygkVnQxLFsyLDIzXSx7MjE6WzEsMTY3XX0pLG8oJFZ0MSxbMiwyNV0pLG8oJFZ0MSxbMiwyNl0pLHsxMzoxNjgsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oJFZ1MSwkVnYxLHsxMTc6WzEsMTY5XX0pLG8oJFZ1MSxbMiwyMzJdKSxvKCRWdTEsWzIsMjMzXSksbygkVnUxLFsyLDIzNF0pLG8oJFZ1MSxbMiwyMzVdKSxvKCRWdTEsWzIsMjM2XSksbygkVnUxLFsyLDIzN10pLG8oJFZ1MSxbMiwyMzhdKSxvKCRWdTEsWzIsMjM5XSksbygkVnUxLFsyLDI0MF0pLG8oJFZqMSxbMiwxNTBdKSxvKCRWajEsWzIsMTUxXSksbygkVmoxLFsyLDE1Ml0pLHsxMzoxNzAsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHsxMzoxNzEsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHsxMzoxNzIsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHsxMzoxNzMsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHszMjokVjcsMzU6MTc1LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODI6OTIsODM6JFZwLDg5OiRWdzEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTA5OjEwMSwxMjk6NDUsMTMwOiRWeCwxMzE6MTc3LDEzNjokVnksMTUwOjc3LDE1NDokVkYsMTU3OiRWeDEsMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjE3NCwxNzg6MzksMTg0OiRWTCwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5NzokVlEsMTk4OiRWUn0sezMyOiRWNywzNToxNzUsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4Mjo5Miw4MzokVnAsODk6JFZ3MSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDk6MTAxLDEyOTo0NSwxMzA6JFZ4LDEzMToxNzcsMTM2OiRWeSwxNTA6NzcsMTU0OiRWRiwxNTc6JFZ4MSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6MTc5LDE3ODozOSwxODQ6JFZMLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTk3OiRWUSwxOTg6JFZSfSxvKCRWeTEsJFZ6MSx7MjQ0OlsxLDE4MF0sMjQ1OlsxLDE4MV0sMjQ5OlsxLDE4Ml19KSxvKCRWajEsWzIsMzQzXSx7MjMyOlsxLDE4M10sMjM3OlsxLDE4NF19KSx7NToxODUsMTA6JFYxfSx7NToxODYsMTA6JFYxfSxvKCRWajEsWzIsMzA2XSksezU6MTg3LDEwOiRWMX0sezEwOlsxLDE4OV0sMTM6MTg4LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWajEsWzIsMjQ5XSksezEyMToxOTEsMTI0OiRWdywxOTI6MTkwLDE5MzokVk99LHsxMjE6MTkzLDEyNDokVncsMTkyOjE5MiwxOTM6JFZPfSx7MTU1OjE5NSwxNTg6JFZJLDE5MjoxOTQsMTkzOiRWT30sezEyMzpbMSwxOTddLDE1NDokVkYsMTU1OjE5OCwxNTc6JFZ4MSwxNTg6JFZJLDE3MzoxOTksMTc1OiRWSywxOTI6MTk2LDE5MzokVk99LHszMjokVjcsMzU6MTc1LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODI6OTIsODM6JFZwLDg5OiRWdzEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTA5OjEwMSwxMjk6NDUsMTMwOiRWeCwxMzE6MTc3LDEzNjokVnksMTUwOjc3LDE1NDokVkYsMTU3OiRWeDEsMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjIwMCwxNzg6MzksMTg0OiRWTCwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5NzokVlEsMTk4OiRWUn0sbygkVmoxLFsyLDEyM10pLG8oJFZBMSxbMiwxMDJdLHsxMDQ6MjAxLDEwODoyMDMsMTA5OjIwNCw1MTpbMSwyMDVdLDg5OlsxLDIwMl0sMTEwOlsxLDIwNl0sMTk4OiRWUn0pLHs1MDoyMDgsNTE6JFY4LDg5OlsxLDIwOV0sMTQ5OjIwN30sbygkVnQxLFsyLDc3XSx7MzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsMTc6MzAsMTg6MzEsMjU6MzYsMTMxOjM4LDE3ODozOSw3Mjo0MCwxODY6NDEsMTg3OjQyLDE2Njo0NCwxMjk6NDUsMTAxOjQ2LDE4OTo0NywxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNzY6NTcsMjM1OjU4LDIxMTo2MCwyMTU6NjEsMjE3OjYyLDE5Mjo2NCwxMjE6NzAsMTQ4OjcyLDE2ODo3NiwxNTA6NzcsNjM6NzksODI6OTIsMTU1OjkzLDU3Ojk3LDUyOjk4LDU1Ojk5LDU5OjEwMCwxMDk6MTAxLDE3MzoxMDIsNTA6MTAzLDIxODoxMDgsMjIyOjEwOSw2MToxMTYsNjU6MTE3LDE2OjE1NSwxMzoyMTAsODE6MjExLDE5OiRWMiwyMDokVjMsMjE6JFZCMSwyMzokVjQsMjQ6JFY1LDI2OiRWNiwzMjokVjcsNTE6JFY4LDUzOiRWOSw1NDokVmEsNTY6JFZiLDU4OiRWYyw2MDokVmQsNjI6JFZlLDY0OiRWZiw2NjokVmcsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAzOiRWdCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMzA6JFZ4LDEzNjokVnksMTQzOiRWQiwxNDQ6JFZDLDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE3NTokVkssMTg0OiRWTCwxODU6JFZNLDE4ODokVk4sMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjE2OiRWVywyMzA6JFZaLDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0pLHsxMzoyMTMsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHsyNzoyMTQsMjk6MjE1LDMxOjIxNiwzMjokVkMxLDMzOjIxOCw1MDoyMjAsNTE6JFY4LDU3OjIxOSw1ODokVmN9LG8oJFZ5MSxbMiwyMjhdKSxvKCRWeTEsWzIsMjI5XSksbygkVkQxLFsyLDIyNl0pLG8oJFZ1MSxbMiw2N10pLG8oJFZ1MSxbMiw2OF0pLG8oJFZ1MSxbMiw2OV0pLG8oJFZ1MSxbMiw3MF0pLG8oJFZ1MSxbMiw3MV0pLG8oJFZ1MSxbMiw3Ml0pLG8oJFZ1MSxbMiw3M10pLG8oJFZ1MSxbMiw3NF0pLHs0OjIyMSw3OiRWMCw4OjUsMTA6WzEsMjIyXSwxMjo3LDEzOjgsMTU6OSwxNjoxMCwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTM4OiRWeiwxMzk6JFZBLDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MDokVkosMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTA6JFZFMSwxMjoyMjgsMTM6MjIzLDE1OjIzMCwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDk3OiRWRjEsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMTk6MjI1LDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxMzg6JFZ6LDEzOTokVkEsMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTcwOiRWSiwxNzE6JFZHMSwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDI6MjI2LDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sbyhbMSw2LDEwLDExLDE0LDIxLDIyLDcxLDg4LDg5LDkwLDkxLDk3LDEwNiwxMTEsMTEyLDEyNiwxMzUsMTM3LDE0NCwxNDcsMTcxLDE4MCwxODEsMTgzLDE5NiwyMDAsMjAxLDIxMiwyMTMsMjE0LDIxOSwyMjAsMjI5LDIzOCwyMzksMjQyLDI0MywyNDYsMjQ3LDI0OF0sWzIsMjY3XSksbygkVnUxLFsyLDEzNF0pLHs1MDoyMzEsNTE6JFY4fSx7ODQ6MjMzLDg1OlsxLDIzNF0sODY6WzEsMjM1XSw4NzpbMSwyMzZdLDg4OlsxLDIzN10sOTE6WzEsMjM4XSw5MjpbMSwyMzldLDkzOlsxLDI0MF0sOTQ6WzEsMjQxXSw5NTpbMSwyNDJdLDk2OlsxLDI0M10sMTAwOlsxLDI0NF0sMTAyOlsxLDIzMl19LG8oJFZqMSxbMiwxNjVdKSx7NToyNDUsMTA6JFYxLDE0NTpbMSwyNDZdfSxvKCRWSDEsJFZJMSx7NjE6MTE2LDY1OjExNywxOTE6MjQ4LDEzMzoyNDksMTM0OjI1MCwxNToyNTEsNTA6MjUyLDU3OjI1Myw2MzoyNTQsNTI6MjU1LDU1OjI1NiwzMjokVjcsNTE6JFY4LDUzOiRWOSw1NDokVmEsNTY6JFZiLDU4OiRWYyw2MjokVmUsNjQ6JFZmLDY2OiRWZywxMzY6JFZKMSwxMzg6JFZ6LDEzOTokVkEsMTQ1OiRWSzF9KSx7NToyNTgsMTA6JFYxfSxvKCRWRDEsWzIsMjA4XSksbygkVkQxLFsyLDIwOV0pLG8oJFZEMSxbMiwyMTBdKSxvKCRWRDEsWzIsMjExXSksbygkVkQxLFsyLDIxMl0pLG8oJFZEMSxbMiwyMTNdKSxvKCRWRDEsWzIsMjE0XSksezEzOjI1OSwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezEzOjI2MCwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezEzOjI2MSwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezU6MjYyLDEwOiRWMSwxMzoyNjMsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHs1MDoyNjgsNTE6JFY4LDg5OiRWdzEsOTY6JFZzLDE1MDoyNzAsMTY4OjI2OSwxODc6MjY0LDIyNDoyNjUsMjI1OlsxLDI2Nl0sMjI2OjI2N30sezIyMzoyNzEsMjI3OlsxLDI3Ml0sMjI4OlsxLDI3M119LHszMjokVjcsMzU6MTc1LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODI6OTIsODM6JFZwLDg5OiRWdzEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTA5OjEwMSwxMjk6NDUsMTMwOiRWeCwxMzE6MTc3LDEzNjokVnksMTUwOjc3LDE1NDokVkYsMTU3OiRWeDEsMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjI3NCwxNzg6MzksMTg0OiRWTCwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5NzokVlEsMTk4OiRWUn0sezExMDokVkwxLDEyNToyNzUsMTI4OiRWTTF9LG8oJFZOMSxbMiwxNjBdKSxvKCRWTjEsWzIsMTYxXSksbygkVnUxLFsyLDU3XSksbygkVnUxLFsyLDU4XSksbygkVnUxLFsyLDU5XSksbygkVnUxLFsyLDYwXSx7Njg6Mjc5LDY3OlsxLDI3OF0sNjk6WzEsMjgwXSw3MDpbMSwyODFdfSksbygkVk8xLFsyLDc4XSksezUwOjI4Nyw1MTokVjgsNTU6Mjg2LDU2OiRWYiw1NzoyODgsNTg6JFZjLDg5OiRWUDEsMTA5OjI4NSwxNTk6MjgyLDE2MToyODMsMTY2OjI4NCwxOTc6JFZRLDE5ODokVlJ9LG8oWzEsNiwxMCwxMSwxNCwyMSwyMiwyOCw3MSw4OCw4OSw5MCw5MSw5NywxMDYsMTExLDExMiwxMTcsMTI2LDEzNSwxMzcsMTQ0LDE0NywxNjQsMTY1LDE3MSwxODAsMTgxLDE4MywxOTYsMjAwLDIwMSwyMTIsMjEzLDIxNCwyMTksMjIwLDIyOSwyMzgsMjM5LDI0MiwyNDMsMjQ0LDI0NSwyNDYsMjQ3LDI0OCwyNDldLFsyLDU0XSksbygkVlExLFsyLDUxXSksbygkVlExLFsyLDUyXSksbyhbMSw2LDEwLDExLDE0LDIxLDIyLDcxLDg4LDg5LDkwLDkxLDk3LDEwNiwxMTEsMTEyLDExNywxMjYsMTM1LDEzNywxNDQsMTQ3LDE3MSwxODAsMTgxLDE4MywxOTYsMjAwLDIwMSwyMTIsMjEzLDIxNCwyMTksMjIwLDIyOSwyMzgsMjM5LDI0MiwyNDMsMjQ0LDI0NSwyNDYsMjQ3LDI0OCwyNDldLFsyLDUzXSksbygkVkQxLFsyLDU1XSksbygkVlExLFsyLDI2OF0pLHs1MDoyOTMsNTE6JFY4LDU3OjI5Miw1ODokVmMsOTY6JFZSMSwxNjg6Mjk0LDE3MDpbMSwyOTBdLDE3NDoyOTF9LHs1MDoyOTMsNTE6JFY4LDU3OjI5Miw1ODokVmMsOTY6JFZSMSwxNjg6Mjk0LDE3MDpbMSwyOTddLDE3NDoyOTZ9LG8oWzEsNiwxMCwxMSwxNCwyMSwyMiwyOCw3MSw4OCw4OSw5MCw5MSw5Nyw5OCwxMDYsMTExLDExMiwxMTcsMTI2LDEzNSwxMzcsMTQ0LDE0NywxNjQsMTY1LDE3MSwxODAsMTgxLDE4MywxOTYsMjAwLDIwMSwyMTIsMjEzLDIxNCwyMTksMjIwLDIyNywyMjgsMjI5LDIzOCwyMzksMjQyLDI0MywyNDQsMjQ1LDI0NiwyNDcsMjQ4LDI0OV0sWzIsNTBdKSxvKCRWUzEsWzIsMzEyXSksbygkVlMxLFsyLDMxM10pLG8oJFZEMSxbMiw1Nl0pLG8oJFZUMSxbMiw2MV0pLG8oJFY2MSxbMiw3XSx7MTI6NywxMzo4LDE1OjksMTY6MTAsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsMTc6MzAsMTg6MzEsMjU6MzYsMTMxOjM4LDE3ODozOSw3Mjo0MCwxODY6NDEsMTg3OjQyLDE2Njo0NCwxMjk6NDUsMTAxOjQ2LDE4OTo0NywxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNzY6NTcsMjM1OjU4LDIxMTo2MCwyMTU6NjEsMjE3OjYyLDE5Mjo2NCwxMjE6NzAsMTQ4OjcyLDE2ODo3NiwxNTA6NzcsNjM6NzksODI6OTIsMTU1OjkzLDU3Ojk3LDUyOjk4LDU1Ojk5LDU5OjEwMCwxMDk6MTAxLDE3MzoxMDIsNTA6MTAzLDIxODoxMDgsMjIyOjEwOSw2MToxMTYsNjU6MTE3LDg6Mjk4LDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNjokVjYsMzI6JFY3LDUxOiRWOCw1MzokVjksNTQ6JFZhLDU2OiRWYiw1ODokVmMsNjA6JFZkLDYyOiRWZSw2NDokVmYsNjY6JFZnLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMzokVnQsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTMwOiRWeCwxMzY6JFZ5LDEzODokVnosMTM5OiRWQSwxNDM6JFZCLDE0NDokVkMsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTcwOiRWSiwxNzU6JFZLLDE4NDokVkwsMTg1OiRWTSwxODg6JFZOLDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMjokVlUsMjE0OiRWViwyMTY6JFZXLDIxOTokVlgsMjIwOiRWWSwyMzA6JFZaLDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0pLG8oWzEsNiwxMSwxOSwyMCwyMywyNCwyNiwzMiw1MSw1Myw1NCw1Niw1OCw2MCw2Miw2NCw2Niw3Myw3NCw3NSw3Niw3Nyw3OCw3OSw4MCw4Myw4OSw5MSw5NiwxMDMsMTIyLDEyMywxMjQsMTMwLDEzNiwxMzcsMTM4LDEzOSwxNDMsMTQ0LDE1MSwxNTIsMTU0LDE1NiwxNTcsMTU4LDE3MCwxNzEsMTc1LDE4NCwxODUsMTg4LDE5MywxOTQsMTk3LDE5OCwyMDQsMjEwLDIxMiwyMTQsMjE2LDIxOSwyMjAsMjMwLDIzNiwyNDAsMjQxLDI0MiwyNDMsMjQ0LDI0NV0sWzIsOF0pLHsxOlsyLDNdfSx7MTI6MzAwLDEzOjI5OSwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MDokVkosMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWVTEsWzIsOV0pLHs2OiRWNTEsOToxMzMsMTE6WzEsMzAxXX0sezQ6MzAyLDc6JFYwLDg6NSwxMjo3LDEzOjgsMTU6OSwxNjoxMCwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTM4OiRWeiwxMzk6JFZBLDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MDokVkosMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTM6MzAzLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTM6MzA0LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTM6MzA1LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTM6MzA2LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTM6MzA3LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTM6MzA4LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTM6MzA5LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTM6MzEwLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTM6MzExLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWajEsWzIsMzA1XSksbygkVmoxLFsyLDMxMF0pLHsxMzozMTIsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oJFZqMSxbMiwzMDRdKSxvKCRWajEsWzIsMzA5XSksbyhbMSw2LDEwLDExLDE0LDIyLDk3LDEzN10sWzIsMTk3XSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwxMjY6JFY5MSwxNzE6JFZhMSwyMTI6JFZVLDIxNDokVlYsMjE5OiRWWCwyMjA6JFZZLDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSksezIxMToxNTIsMjEyOiRWVSwyMTQ6JFZWLDIxNzoxNTMsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzg6JFZpMX0sezIxOiRWQjEsODE6MzEzfSxvKCRWdTEsWzIsMjYyXSksbygkVlYxLFsyLDIyNF0sezE3ODozMTUsNjE6MzE2LDYyOiRWZSwxNzc6WzEsMzE0XSwxODQ6JFZMfSksezUwOjMxNyw1MTokVjgsNTI6MzE4LDUzOiRWOSw1NDokVmEsNTc6MzE5LDU4OiRWY30sezUwOjMyMCw1MTokVjh9LHs1MDozMjEsNTE6JFY4fSx7MTM6MzIzLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTgyOjMyMiwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTA6MzI0LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDE5OTozMjUsMjAwOiRWVzEsMjAxOiRWWDEsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MjE6WzIsMjY0XX0sezE0NTokVksxfSxvKCRWVjEsWzIsMjI1XSksezEzOjMyOCwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezEzOjMyOSwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sbygkVlkxLFsyLDIzMF0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMTI2OiRWOTEsMTcxOiRWYTEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSx7MTA6WzEsMzMxXSwxMzozMzAsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oJFZqMSxbMiwzNDddLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwfSksbygkVmoxLFsyLDM0OF0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTB9KSxvKCRWajEsWzIsMzQ5XSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MH0pLG8oJFZqMSxbMiwzNTBdLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwfSksbygkVmoxLFsyLDM1MV0sezIxOiRWejEsODg6JFZ6MSw4OTokVnoxLDExMTokVnoxLDE0NDokVnoxLDE4MDokVnoxLDE4MTokVnoxLDE4MzokVnoxLDE5NjokVnoxfSksezIxOiRWazEsODg6JFZsMSw4OTokVm0xLDExMTokVm4xLDE0MToxNTcsMTQ0OiRWQywxNzk6MTU5LDE4MDokVm8xLDE4MTokVnAxLDE4MzokVnExLDE5NToxNTYsMTk2OiRWcjF9LHsxNTQ6JFZGLDE1NzokVngxLDE3MzoxOTksMTc1OiRWS30sbyhbMjEsODgsODksMTExLDE0NCwxODAsMTgxLDE4MywxOTZdLCRWdjEpLG8oJFZIMSwkVkkxLHs2MToxMTYsNjU6MTE3LDE5MToyNDgsMTMzOjI0OSwxMzQ6MjUwLDE1OjI1MSw1MDoyNTIsNTc6MjUzLDYzOjI1NCw1MjoyNTUsNTU6MjU2LDMyOiRWNyw1MTokVjgsNTM6JFY5LDU0OiRWYSw1NjokVmIsNTg6JFZjLDYyOiRWZSw2NDokVmYsNjY6JFZnLDEzNjokVkoxLDEzODokVnosMTM5OiRWQX0pLG8oJFZqMSxbMiwzNTJdLHsyMTokVnoxLDg4OiRWejEsODk6JFZ6MSwxMTE6JFZ6MSwxNDQ6JFZ6MSwxODA6JFZ6MSwxODE6JFZ6MSwxODM6JFZ6MSwxOTY6JFZ6MX0pLG8oJFZqMSxbMiwzNTNdKSxvKCRWajEsWzIsMzU0XSksezEwOlsxLDMzM10sMTM6MzMyLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7NTozMzUsMTA6JFYxLDIzNjpbMSwzMzRdfSx7MTM6MzM2LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWajEsWzIsMjkwXSx7MjA1OjMzNywyMDY6MzM4LDIwNzokVloxLDIwODpbMSwzMzldfSksbygkVmoxLFsyLDMwM10pLG8oJFZqMSxbMiwzMTFdKSx7MTA6WzEsMzQxXSwxMjY6JFY5MSwxNzE6JFZhMSwyMTE6MTQ5LDIxMjokVlUsMjE0OiRWViwyMTc6MTUwLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9LHsyMzE6MzQyLDIzMzozNDMsMjM0OiRWXzF9LG8oJFZqMSxbMiwyNTBdKSxvKCRWajEsWzIsMTI0XSksbygkVmoxLFsyLDI1MV0pLG8oJFZqMSxbMiwxMjVdKSxvKCRWajEsWzIsMjUyXSksbygkVmoxLFsyLDE2Nl0pLG8oJFZqMSxbMiwyNTNdKSx7MTkyOjM0NSwxOTM6JFZPfSxvKCRWajEsWzIsMTY3XSksbygkVkQxLFsyLDIwMl0pLG8oJFYkMSxbMiwyNTldLHs1OjM0NiwxMDokVjEsMjE6JFZ6MSw4ODokVnoxLDg5OiRWejEsMTExOiRWejEsMTQ0OiRWejEsMTgwOiRWejEsMTgxOiRWejEsMTgzOiRWejEsMTk2OiRWejF9KSxvKCRWMDIsWzIsMTEyXSx7MTA1OjM0Nyw1MjozNTIsMTE0OjM1Myw1MzokVjksNTQ6JFZhLDg4OlsxLDM0OF0sOTE6WzEsMzUxXSwxMTE6WzEsMzQ5XSwxMTM6WzEsMzUwXSwxMTY6JFYxMn0pLHsxMzozNTUsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oJFZBMSxbMiwxMDNdKSxvKCRWQTEsWzIsOTldKSxvKCRWQTEsWzIsMTAwXSksbygkVkExLFsyLDEwMV0pLG8oJFZqMSxbMiwxNTldLHsxNTA6MzU2LDIxOlsxLDM1N10sODk6JFZ3MX0pLG8oJFYyMixbMiwxNjJdKSx7MTM6MzU4LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWdDEsWzIsNzVdLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDEyNjokVjkxLDE3MTokVmExLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSksbygkVnQxLFsyLDc2XSksezEwOiRWRTEsMTI6MjI4LDEzOjM2MSwxNToyMzAsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjI6WzEsMzU5XSwyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTE5OjM2MCwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTM4OiRWeiwxMzk6JFZBLDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MDokVkosMTcxOiRWRzEsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjAyOjIyNiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oJFZ0MSxbMiwyOTZdLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDEyNjokVjkxLDE3MTokVmExLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSksezE0OlsxLDM2M10sMjg6WzEsMzYyXX0sbygkVnQxLFsyLDI5XSx7MzA6WzEsMzY0XX0pLG8oJFYzMixbMiwzMV0pLG8oWzEsNiwxMSwxNCwzMCwxMzcsMjEyLDIxNCwyMTksMjIwLDIzOF0sWzIsMzBdKSxvKCRWNDIsWzIsMzNdKSxvKCRWNDIsWzIsMjAzXSksbygkVjQyLFsyLDIwNF0pLHs2OiRWNTEsOToxMzMsMTM3OlsxLDM2NV19LHs0OjM2Niw3OiRWMCw4OjUsMTI6NywxMzo4LDE1OjksMTY6MTAsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDEzODokVnosMTM5OiRWQSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzA6JFZKLDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sbyhbNiwxMCwxNCw5N10sJFY1Mix7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwxOTk6MzY3LDEyNjokVjkxLDE3MTokVmExLDIwMDokVlcxLDIwMTokVlgxLDIxMjokVlUsMjE0OiRWViwyMTk6JFZYLDIyMDokVlksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSxvKCRWNjIsWzIsMjY5XSksbyhbNiwxMCw5N10sJFY3Mix7MTE1OjM2OCwxNDokVjgyfSksbygkVjkyLFsyLDI3N10pLHsxMDokVkUxLDEyOjIyOCwxMzozNjEsMTU6MjMwLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMTk6MzcwLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxMzg6JFZ6LDEzOTokVkEsMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTcwOiRWSiwxNzE6JFZHMSwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDI6MjI2LDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sbygkVjkyLFsyLDI4NV0pLG8oJFY5MixbMiwyODZdKSxvKCRWOTIsWzIsMjg3XSksbygkVnUxLFsyLDEzNV0pLG8oJFZ1MSxbMiw5Ml0pLG8oJFZPMSxbMiw3OV0pLG8oJFZPMSxbMiw4MF0pLG8oJFZPMSxbMiw4MV0pLG8oJFZPMSxbMiw4Ml0pLHs4OTpbMSwzNzFdfSx7ODk6WzEsMzcyXX0sbygkVk8xLFsyLDg1XSksbygkVk8xLFsyLDg2XSksbygkVk8xLFsyLDg3XSksbygkVk8xLFsyLDg4XSksezUwOjM3Myw1MTokVjh9LG8oJFZPMSxbMiw5MV0pLG8oJFZ1MSxbMiwxNTRdKSxvKCRWYTIsJFZiMix7MTQ2OjM3NCwxNjc6Mzc1LDE1MDozNzYsMTY4OjM3NywxNjk6Mzc4LDUwOjM4Miw1MTokVjgsODk6JFZ3MSw5NjokVlIxLDE3MDokVmMyLDE3MTokVmQyLDE3MjokVmUyfSksbygkVmEyLCRWYjIsezE2NzozNzUsMTUwOjM3NiwxNjg6Mzc3LDE2OTozNzgsNTA6MzgyLDE0NjozODMsNTE6JFY4LDg5OiRWdzEsOTY6JFZSMSwxNzA6JFZjMiwxNzE6JFZkMiwxNzI6JFZlMn0pLG8oWzYsMTAsOTBdLCRWNzIsezExNTozODQsMTQ6JFZmMn0pLG8oJFZnMixbMiwyNDVdKSxvKCRWZzIsWzIsMTM4XSx7MTM1OlsxLDM4Nl19KSxvKCRWZzIsWzIsMTQxXSksbygkVmgyLFsyLDE0Ml0pLG8oJFZoMixbMiwxNDNdKSxvKCRWaDIsWzIsMTQ0XSksbygkVmgyLFsyLDE0NV0pLG8oJFZoMixbMiwxNDZdKSx7MTM6Mzg3LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWajEsWzIsMTUzXSksezU6Mzg4LDEwOiRWMSwxMjY6JFY5MSwxNzE6JFZhMSwyMTE6MTQ5LDIxMjokVlUsMjE0OiRWViwyMTc6MTUwLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9LG8oJFZpMixbMiwyOTldLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDEyNjokVjkxLDE3MTokVmExLDIxMjokVlUsMjEzOlsxLDM4OV0sMjE0OiRWViwyMTk6JFZYLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSksbygkVmkyLFsyLDMwMV0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMTI2OiRWOTEsMTcxOiRWYTEsMjEyOiRWVSwyMTM6WzEsMzkwXSwyMTQ6JFZWLDIxOTokVlgsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSxvKCRWajEsWzIsMzA3XSksbygkVmoyLFsyLDMwOF0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMTI2OiRWOTEsMTcxOiRWYTEsMjEyOiRWVSwyMTQ6JFZWLDIxOTokVlgsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSxvKCRWajEsWzIsMzE1XSksbygkVmsyLFsyLDMxN10pLHs1MDoyNjgsNTE6JFY4LDg5OiRWdzEsOTY6JFZSMSwxNTA6MjcwLDE2ODoyNjksMjI0OjM5MSwyMjY6MjY3fSxvKCRWazIsWzIsMzIyXSx7MTQ6WzEsMzkyXX0pLG8oJFZsMixbMiwzMTldKSxvKCRWbDIsWzIsMzIwXSksbygkVmwyLFsyLDMyMV0pLG8oJFZqMSxbMiwzMTZdKSx7MTM6MzkzLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTM6Mzk0LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWbTIsWzIsMjU1XSx7NTozOTUsMTA6JFYxLDIxOiRWejEsODg6JFZ6MSw4OTokVnoxLDExMTokVnoxLDE0NDokVnoxLDE4MDokVnoxLDE4MTokVnoxLDE4MzokVnoxLDE5NjokVnoxLDEyNjpbMSwzOTZdfSksbygkVm0yLFsyLDEyNl0sezU6Mzk3LDEwOiRWMSwxMjY6WzEsMzk4XX0pLG8oJFZqMSxbMiwxMzJdKSxvKCRWajEsWzIsMTMzXSksbygkVlQxLFsyLDYyXSksbygkVlQxLFsyLDYzXSksbygkVlQxLFsyLDY0XSksezEzOjQwMCwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcxOlsxLDM5OV0sNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7ODg6WzEsNDAyXSw5MTpbMSw0MDNdLDE2MDo0MDF9LG8oJFZuMixbMiwxODBdLHsxNjI6NDA1LDIxOlsxLDQwNF0sMTY0OiRWbzIsMTY1OiRWcDJ9KSxvKCRWbjIsWzIsMTgxXSksbygkVm4yLFsyLDE4Ml0pLG8oJFZuMixbMiwxODNdKSxvKCRWcTIsWzIsMTc0XSksbygkVnEyLFsyLDE3NV0pLHsxMzo0MDgsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHs1MDoyOTMsNTE6JFY4LDU3OjI5Miw1ODokVmMsOTY6JFZSMSwxNjg6Mjk0LDE3NDo0MDl9LG8oJFZEMSxbMiwxOTldKSxvKCRWRDEsWzIsMjA1XSksbygkVkQxLFsyLDIwNl0pLG8oJFZEMSxbMiwyMDddKSx7MTA6JFZFMSwxMjoyMjgsMTM6MzYxLDE1OjIzMCwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDk3OiRWRjEsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMTk6MjI1LDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxMzg6JFZ6LDEzOTokVkEsMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTcwOiRWSiwxNzE6JFZHMSwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDI6MjI2LDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sbygkVkQxLFsyLDIwMF0pLHs1MDoyOTMsNTE6JFY4LDU3OjI5Miw1ODokVmMsOTY6JFZSMSwxNjg6Mjk0LDE3NDo0MTB9LG8oJFY2MSxbMiw2XSx7MTQ6JFY3MX0pLG8oJFY4MSxbMiwxNF0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMTI2OiRWOTEsMTcxOiRWYTEsMjEyOiRWVSwyMTQ6JFZWLDIxOTokVlgsMjIwOiRWWSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0pLG8oJFY4MSxbMiwxNV0pLG8oJFZVMSxbMiwxMF0pLHs2OiRWNTEsOToxMzMsMTE6WzEsNDExXX0sbygkVnIyLFsyLDM1NV0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMjQ2OiRWZjF9KSxvKCRWcjIsWzIsMzU2XSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwyNDY6JFZmMX0pLG8oJFZqMSxbMiwzNTddLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwfSksbyhbMSw2LDEwLDExLDE0LDIyLDcxLDkwLDk3LDEwNiwxMTIsMTI2LDEzNSwxMzcsMTQ3LDE3MSwyMDAsMjAxLDIxMiwyMTMsMjE0LDIxOSwyMjAsMjI5LDIzOCwyMzksMjQ3LDI0OF0sWzIsMzU4XSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMX0pLG8oWzEsNiwxMCwxMSwxNCwyMiw3MSw5MCw5NywxMDYsMTEyLDEyNiwxMzUsMTM3LDE0NywxNzEsMjAwLDIwMSwyMTIsMjEzLDIxNCwyMTksMjIwLDIyOSwyMzgsMjM5XSxbMiwzNTldLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSksbyhbMSw2LDEwLDExLDE0LDIyLDcxLDkwLDk3LDEwNiwxMTIsMTM1LDEzNywxNDcsMTcxLDIwMCwyMDEsMjEyLDIxMywyMTQsMjE5LDIyMCwyMjksMjM4LDIzOV0sWzIsMzYwXSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwxMjY6JFY5MSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0pLG8oWzEsNiwxMCwxMSwxNCwyMiw3MSw5MCw5NywxMDYsMTEyLDEyNiwxMzUsMTM3LDE0NywxNzEsMjAwLDIwMSwyMTIsMjEzLDIxNCwyMTksMjIwLDIyOSwyMzgsMjM5LDI0OF0sWzIsMzYxXSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMX0pLG8oJFZzMixbMiwzNDVdLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDEyNjokVjkxLDE3MTokVmExLDIxMjokVlUsMjE0OiRWViwyMTk6JFZYLDIyMDokVlksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSx7MTI2OiRWOTEsMTM1OlsxLDQxMl0sMTcxOiRWYTEsMjExOjE0OSwyMTI6JFZVLDIxNDokVlYsMjE3OjE1MCwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSxvKCRWczIsWzIsMzQ0XSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwxMjY6JFY5MSwxNzE6JFZhMSwyMTI6JFZVLDIxNDokVlYsMjE5OiRWWCwyMjA6JFZZLDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSksbygkVnUxLFsyLDI2MV0pLG8oJFZEMSxbMiwyMTVdKSxvKCRWRDEsWzIsMjE2XSksbygkVkQxLFsyLDIyMV0pLG8oJFZEMSxbMiwyMTddKSxvKCRWRDEsWzIsMjIwXSksbygkVkQxLFsyLDIyMl0pLG8oJFZEMSxbMiwyMThdKSxvKCRWRDEsWzIsMjE5XSksezExMjpbMSw0MTNdfSx7MTEyOlsyLDI0MV0sMTI2OiRWOTEsMTcxOiRWYTEsMTk5OjQxNCwyMDA6JFZXMSwyMDE6JFZYMSwyMTE6MTQ5LDIxMjokVlUsMjE0OiRWViwyMTc6MTUwLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9LHsxMTI6WzIsMjQyXX0sezEzOjQxNSwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sbygkVnQyLFsyLDI3MV0pLG8oJFZ0MixbMiwyNzJdKSx7MjI6WzEsNDE2XSwxMjY6JFY5MSwxNzE6JFZhMSwyMTE6MTQ5LDIxMjokVlUsMjE0OiRWViwyMTc6MTUwLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9LHsyMjpbMSw0MTddLDEyNjokVjkxLDE3MTokVmExLDIxMToxNDksMjEyOiRWVSwyMTQ6JFZWLDIxNzoxNTAsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0sbygkVlkxLFsyLDEzNl0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMTI2OiRWOTEsMTcxOiRWYTEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSx7MTM6NDE4LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWWTEsWzIsMzYyXSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwxMjY6JFY5MSwxNzE6JFZhMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0pLHsxMzo0MTksMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHsxMzo0MjAsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oJFZ1MixbMiwzNDJdKSx7NTo0MjEsMTA6JFYxLDEyNjokVjkxLDE3MTokVmExLDIxMToxNDksMjEyOiRWVSwyMTQ6JFZWLDIxNzoxNTAsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0sbygkVmoxLFsyLDI5MV0sezIwNjo0MjIsMjA3OiRWWjF9KSxvKCRWajEsWzIsMjkyXSksezIwOTpbMSw0MjNdfSx7NTo0MjQsMTA6JFYxfSx7MjMxOjQyNSwyMzM6MzQzLDIzNDokVl8xfSx7MTE6WzEsNDI2XSwyMzI6WzEsNDI3XSwyMzM6NDI4LDIzNDokVl8xfSxvKCRWdjIsWzIsMzM1XSksezEzOjQzMCwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwMzo0MjksMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWajEsWzIsMjU0XSksbygkVmoxLFsyLDI2MF0pLHs2OiRWNzIsMTQ6WzEsNDMyXSwxMDY6WzEsNDMxXSwxMTU6NDMzfSx7NTE6WzEsNDM1XSw2MjpbMSw0MzRdLDg5OlsxLDQzNl19LHsxMzo0MzcsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHs4OTpbMSw0MzhdfSx7NTE6WzEsNDM5XSw4OTpbMSw0NDBdfSxvKCRWQTEsWzIsMTEwXSksbygkVjAyLFsyLDExM10pLG8oJFYwMixbMiwxMTZdLHsxMTc6WzEsNDQxXX0pLHs5MDpbMSw0NDJdLDEyNjokVjkxLDE3MTokVmExLDIxMToxNDksMjEyOiRWVSwyMTQ6JFZWLDIxNzoxNTAsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0sbygkVmoxLFsyLDE1N10pLHs4OTokVncxLDE1MDo0NDN9LHs5MDpbMSw0NDRdLDEyNjokVjkxLDE3MTokVmExLDIxMToxNDksMjEyOiRWVSwyMTQ6JFZWLDIxNzoxNTAsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0sbygkVnUxLFsyLDI2NV0pLG8oWzYsMTAsMjJdLCRWNzIsezExNTo0NDUsMTQ6JFY4Mn0pLG8oJFY5MiwkVjUyLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDEyNjokVjkxLDE3MTokVmExLDIxMjokVlUsMjE0OiRWViwyMTk6JFZYLDIyMDokVlksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSx7Mjk6NDQ2LDMyOiRWQzF9LHszMTo0NDcsMzM6MjE4LDUwOjIyMCw1MTokVjgsNTc6MjE5LDU4OiRWY30sezMxOjQ0OCwzMzoyMTgsNTA6MjIwLDUxOiRWOCw1NzoyMTksNTg6JFZjfSxvKCRWdTEsWzIsMjk3XSksezY6JFY1MSw5OjEzMywxMTpbMSw0NDldfSx7MTM6NDUwLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7NjokVjUxLDk6NDUyLDEwOiRWdzIsOTc6WzEsNDUxXX0sbyhbNiwxMCwxMSwyMiw5N10sJFZ4Mix7MzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsMTc6MzAsMTg6MzEsMjU6MzYsMTMxOjM4LDE3ODozOSw3Mjo0MCwxODY6NDEsMTg3OjQyLDE2Njo0NCwxMjk6NDUsMTAxOjQ2LDE4OTo0NywxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNzY6NTcsMjM1OjU4LDIxMTo2MCwyMTU6NjEsMjE3OjYyLDE5Mjo2NCwxMjE6NzAsMTQ4OjcyLDE2ODo3NiwxNTA6NzcsNjM6NzksODI6OTIsMTU1OjkzLDU3Ojk3LDUyOjk4LDU1Ojk5LDU5OjEwMCwxMDk6MTAxLDE3MzoxMDIsNTA6MTAzLDIxODoxMDgsMjIyOjEwOSw2MToxMTYsNjU6MTE3LDE2OjE1NSwxMjoyMjgsMTU6MjMwLDEzOjM2MSwyMDI6NDU0LDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNjokVjYsMzI6JFY3LDUxOiRWOCw1MzokVjksNTQ6JFZhLDU2OiRWYiw1ODokVmMsNjA6JFZkLDYyOiRWZSw2NDokVmYsNjY6JFZnLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMzokVnQsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTMwOiRWeCwxMzY6JFZ5LDEzODokVnosMTM5OiRWQSwxNDM6JFZCLDE0NDokVkMsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTcwOiRWSiwxNzE6JFZHMSwxNzU6JFZLLDE4NDokVkwsMTg1OiRWTSwxODg6JFZOLDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMjokVlUsMjE0OiRWViwyMTY6JFZXLDIxOTokVlgsMjIwOiRWWSwyMzA6JFZaLDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0pLG8oJFZ5MiwkVjcyLHsxMTU6NDU1LDE0OiRWODJ9KSx7MTM6NDU2LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTM6NDU3LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7OTc6WzEsNDU4XSw5ODpbMSw0NTldfSx7MTQ6JFZ6MiwxNDc6WzEsNDYwXX0sbygkVkEyLFsyLDE4N10pLG8oJFZBMixbMiwxODldKSxvKCRWQTIsWzIsMTkwXSksbygkVkEyLFsyLDE5MV0sezExNzpbMSw0NjJdfSksezUwOjM4Miw1MTokVjgsMTY5OjQ2M30sezUwOjM4Miw1MTokVjgsMTY5OjQ2NH0sezUwOjM4Miw1MTokVjgsMTY5OjQ2NX0sbyhbMTQsMjIsMTE3LDE0N10sWzIsMTk2XSksezE0OiRWejIsMTQ3OlsxLDQ2Nl19LHs2OiRWNTEsOTo0NjgsMTA6JFZCMiw5MDpbMSw0NjddfSxvKFs2LDEwLDExLDkwXSwkVngyLHs2MToxMTYsNjU6MTE3LDEzNDoyNTAsMTU6MjUxLDUwOjI1Miw1NzoyNTMsNjM6MjU0LDUyOjI1NSw1NToyNTYsMTMzOjQ3MCwzMjokVjcsNTE6JFY4LDUzOiRWOSw1NDokVmEsNTY6JFZiLDU4OiRWYyw2MjokVmUsNjQ6JFZmLDY2OiRWZywxMzY6JFZKMSwxMzg6JFZ6LDEzOTokVkF9KSx7MTA6WzEsNDcyXSwxMzo0NzEsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHsxMjY6JFY5MSwxMzc6WzEsNDczXSwxNzE6JFZhMSwyMTE6MTQ5LDIxMjokVlUsMjE0OiRWViwyMTc6MTUwLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9LG8oJFZ1MixbMiwzMzldKSx7MTM6NDc0LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTM6NDc1LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWazIsWzIsMzE4XSksezUwOjI2OCw1MTokVjgsODk6JFZ3MSw5NjokVlIxLDE1MDoyNzAsMTY4OjI2OSwyMjY6NDc2fSxvKFsxLDYsMTAsMTEsMTQsMjIsNzEsOTAsOTcsMTA2LDExMiwxMzUsMTM3LDE0NywyMDAsMjAxLDIxMiwyMTQsMjE5LDIyMCwyMzhdLFsyLDMyNF0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMTI2OiRWOTEsMTcxOiRWYTEsMjEzOlsxLDQ3N10sMjI5OlsxLDQ3OF0sMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSxvKCRWQzIsWzIsMzI1XSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwxMjY6JFY5MSwxNzE6JFZhMSwyMTM6WzEsNDc5XSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0pLG8oJFZqMSxbMiwyNTZdKSx7MTM6NDgwLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWajEsWzIsMTI3XSksezExMDokVkwxLDEyNTo0ODEsMTI4OiRWTTF9LG8oJFZUMSxbMiw2NV0pLHs3MTpbMSw0ODJdLDEyNjokVjkxLDE3MTokVmExLDIxMToxNDksMjEyOiRWVSwyMTQ6JFZWLDIxNzoxNTAsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0sezUwOjI4Nyw1MTokVjgsNTc6Mjg4LDU4OiRWYyw4OTokVlAxLDE2MTo0ODN9LG8oJFZEMixbMiwxNzJdKSxvKCRWRDIsWzIsMTczXSksbygkVkUyLCRWYjIsezE2NzozNzUsMTUwOjM3NiwxNjg6Mzc3LDE2OTozNzgsNTA6MzgyLDE0Njo0ODQsNTE6JFY4LDg5OiRWdzEsOTY6JFZSMSwxNzA6JFZjMiwxNzE6JFZkMiwxNzI6JFZlMn0pLG8oJFZqMSxbMiwxNzFdKSx7NTo0ODUsMTA6JFYxLDg5OiRWbTEsMTQxOjQ4NiwxNDQ6JFZDfSxvKCRWajEsWzIsMTc5XSksezkwOlsxLDQ4N10sMTI2OiRWOTEsMTcxOiRWYTEsMjExOjE0OSwyMTI6JFZVLDIxNDokVlYsMjE3OjE1MCwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSxvKCRWRDEsWzIsMTk4XSksbygkVkQxLFsyLDIwMV0pLG8oJFZVMSxbMiwxMV0pLHsxMzo0ODgsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oJFZEMSxbMiwyMjNdKSx7MTM6NDg5LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMTI6WzIsMjc1XSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTEyOlsyLDI3Nl0sMTI2OiRWOTEsMTcxOiRWYTEsMjExOjE0OSwyMTI6JFZVLDIxNDokVlYsMjE3OjE1MCwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSxvKCRWdDEsWzIsMjJdKSxvKCRWdDEsWzIsMjRdKSx7NjokVjUxLDk6NDkxLDExOiRWRjIsMTI2OiRWOTEsMTMyOjQ5MCwxNzE6JFZhMSwyMTE6MTQ5LDIxMjokVlUsMjE0OiRWViwyMTc6MTUwLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9LHs2OiRWNTEsOTo0OTEsMTE6JFZGMiwxMjY6JFY5MSwxMzI6NDkzLDE3MTokVmExLDIxMToxNDksMjEyOiRWVSwyMTQ6JFZWLDIxNzoxNTAsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0sezU6NDk0LDEwOiRWMSwxMjY6JFY5MSwxNzE6JFZhMSwyMTE6MTQ5LDIxMjokVlUsMjE0OiRWViwyMTc6MTUwLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9LG8oJFZ1MixbMiwzNDFdKSxvKCRWajEsWzIsMjkzXSksezU6NDk1LDEwOiRWMX0sbygkVmoxLFsyLDI5NF0pLHsxMTpbMSw0OTZdLDIzMjpbMSw0OTddLDIzMzo0MjgsMjM0OiRWXzF9LG8oJFZqMSxbMiwzMzNdKSx7NTo0OTgsMTA6JFYxfSxvKCRWdjIsWzIsMzM2XSksezU6NDk5LDEwOiRWMSwxNDpbMSw1MDBdfSxvKCRWRzIsWzIsMjg4XSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwxMjY6JFY5MSwxNzE6JFZhMSwyMTI6JFZVLDIxNDokVlYsMjE5OiRWWCwyMjA6JFZZLDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSksbygkViQxLFsyLDk2XSx7MTA3OjUwMSwxMDpbMSw1MDJdLDIxOlsxLDUwM119KSx7NjokVngyLDExNDo1MDQsMTE2OiRWMTJ9LHs2OlsxLDUwNV19LG8oJFZBMSxbMiwxMDRdKSxvKCRWQTEsWzIsMTA2XSksezEzOjUwNiwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezExMjpbMSw1MDddLDEyNjokVjkxLDE3MTokVmExLDIxMToxNDksMjEyOiRWVSwyMTQ6JFZWLDIxNzoxNTAsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0sezEzOjUwOCwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sbygkVkExLFsyLDEwOV0pLHsxMzo1MDksMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHsxMzo1MTEsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDExODo1MTAsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sezEwNjpbMSw1MTJdfSx7MjI6WzEsNTEzXX0sbygkVjIyLFsyLDE2M10pLHs2OiRWNTEsOTo0NTIsMTA6JFZ3MiwyMjpbMSw1MTRdfSxvKCRWdDEsWzIsMjddKSxvKCRWMzIsWzIsMzJdKSxvKCRWdDEsWzIsMjhdKSx7MTM3OlsxLDUxNV19LHs5NzpbMSw1MTZdLDEyNjokVjkxLDE3MTokVmExLDIxMToxNDksMjEyOiRWVSwyMTQ6JFZWLDIxNzoxNTAsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0sbygkVjYyLFsyLDI3MF0pLHsxMjoyMjgsMTM6MzYxLDE1OjIzMCwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDEzODokVnosMTM5OiRWQSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzA6JFZKLDE3MTokVkcxLDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwMjo1MTcsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTA6JFZFMSwxMjoyMjgsMTM6MzYxLDE1OjIzMCwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTE5OjUxOCwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTM4OiRWeiwxMzk6JFZBLDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MDokVkosMTcxOiRWRzEsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjAyOjIyNiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oJFY5MixbMiwyNzhdKSx7NjokVjUxLDk6NTIwLDEwOiRWdzIsMTE6JFZGMiwxMzI6NTE5fSx7OTA6WzEsNTIxXSwxMjY6JFY5MSwxNzE6JFZhMSwyMTE6MTQ5LDIxMjokVlUsMjE0OiRWViwyMTc6MTUwLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9LHs5MDpbMSw1MjJdLDEyNjokVjkxLDE3MTokVmExLDIxMToxNDksMjEyOiRWVSwyMTQ6JFZWLDIxNzoxNTAsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0sbygkVk8xLFsyLDg5XSksezMyOiRWNyw1MTpbMSw1MjRdLDYxOjExNiw2MjokVmUsNjM6NTI1LDY0OiRWZiw2NToxMTcsNjY6JFZnLDg5OlsxLDUyNl0sOTk6NTIzfSx7NTo1MjcsMTA6JFYxfSx7NTA6MzgyLDUxOiRWOCw4OTokVncxLDk2OiRWUjEsMTUwOjM3NiwxNjc6NTI4LDE2ODozNzcsMTY5OjM3OCwxNzA6JFZjMiwxNzE6JFZkMiwxNzI6JFZlMn0sezEzOjUyOSwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTIxOjcwLDEyMjokVnUsMTIzOiRWdiwxMjQ6JFZ3LDEyOTo0NSwxMzA6JFZ4LDEzMTozOCwxMzY6JFZ5LDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MzoxMDIsMTc1OiRWSywxNzY6NTcsMTc4OjM5LDE4NDokVkwsMTg1OiRWTSwxODY6NDEsMTg3OjQyLDE4ODokVk4sMTg5OjQ3LDE5Mjo2NCwxOTM6JFZPLDE5NDokVlAsMTk3OiRWUSwxOTg6JFZSLDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sbygkVkEyLFsyLDE5Ml0pLG8oJFZBMixbMiwxOTNdKSxvKCRWQTIsWzIsMTk0XSksezU6NTMwLDEwOiRWMX0sbyhbMSw2LDEwLDExLDE0LDIxLDIyLDcxLDg4LDg5LDkwLDk3LDEwNiwxMTEsMTEyLDExNywxMjYsMTM1LDEzNywxNDQsMTQ3LDE3MSwxODAsMTgxLDE4MywxOTYsMjAwLDIwMSwyMTIsMjEzLDIxNCwyMTksMjIwLDIyNywyMjgsMjI5LDIzOCwyMzksMjQyLDI0MywyNDYsMjQ3LDI0OF0sWzIsMjQzXSksezE1OjI1MSwzMjokVjcsNTA6MjUyLDUxOiRWOCw1MjoyNTUsNTM6JFY5LDU0OiRWYSw1NToyNTYsNTY6JFZiLDU3OjI1Myw1ODokVmMsNjE6MTE2LDYyOiRWZSw2MzoyNTQsNjQ6JFZmLDY1OjExNyw2NjokVmcsMTMzOjUzMSwxMzQ6MjUwLDEzNjokVkoxLDEzODokVnosMTM5OiRWQX0sbyhbNiwxMCwxMSwxNF0sJFZJMSx7NjE6MTE2LDY1OjExNywxMzM6MjQ5LDEzNDoyNTAsMTU6MjUxLDUwOjI1Miw1NzoyNTMsNjM6MjU0LDUyOjI1NSw1NToyNTYsMTkxOjUzMiwzMjokVjcsNTE6JFY4LDUzOiRWOSw1NDokVmEsNTY6JFZiLDU4OiRWYyw2MjokVmUsNjQ6JFZmLDY2OiRWZywxMzY6JFZKMSwxMzg6JFZ6LDEzOTokVkF9KSxvKCRWZzIsWzIsMjQ2XSksbygkVmcyLFsyLDEzOV0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMTI2OiRWOTEsMTcxOiRWYTEsMjEyOiRWVSwyMTQ6JFZWLDIxOTokVlgsMjIwOiRWWSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0pLHsxMzo1MzMsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oJFZoMixbMiwxNDddKSxvKCRWajIsWzIsMzAwXSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwxMjY6JFY5MSwxNzE6JFZhMSwyMTI6JFZVLDIxNDokVlYsMjE5OiRWWCwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0pLG8oJFZqMixbMiwzMDJdLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDEyNjokVjkxLDE3MTokVmExLDIxMjokVlUsMjE0OiRWViwyMTk6JFZYLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSksbygkVmsyLFsyLDMyM10pLHsxMzo1MzQsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHsxMzo1MzUsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHsxMzo1MzYsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oWzEsNiwxMSwxNCwyMiw3MSw5MCw5NywxMDYsMTEyLDEzNSwxMzcsMTQ3LDIwMCwyMDEsMjEzLDIyMCwyMjksMjM4XSxbMiwyNTddLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDU6NTM3LDEwOiRWMSwxMjY6JFY5MSwxNzE6JFZhMSwyMTI6JFZVLDIxNDokVlYsMjE5OiRWWCwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0pLG8oJFYkMSxbMiwxMjhdLHs1OjUzOCwxMDokVjF9KSxvKCRWVDEsWzIsNjZdKSx7MjE6WzEsNTM5XSwxNjI6NTQwLDE2NDokVm8yLDE2NTokVnAyfSx7MTQ6JFZ6MiwyMjpbMSw1NDFdfSxvKCRWajEsWzIsMTc3XSksbygkVmoxLFsyLDE3OF0pLG8oJFZxMixbMiwxNzZdKSxvKFsxLDYsMTAsMTEsMTQsMjIsNzEsOTAsOTcsMTA2LDExMiwxMzUsMTM3LDE0NywyMDAsMjAxLDIxMiwyMTMsMjE0LDIxOSwyMjAsMjI5LDIzOCwyMzldLFsyLDM0Nl0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMTI2OiRWOTEsMTcxOiRWYTEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSx7MTEyOlsyLDI3NF0sMTI2OiRWOTEsMTcxOiRWYTEsMjExOjE0OSwyMTI6JFZVLDIxNDokVlYsMjE3OjE1MCwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSxvKCRWajEsWzIsMTM3XSksezExOiRWSDJ9LG8oJFZqMSxbMiwyODNdKSxvKCRWajEsWzIsMzYzXSksbygkVnUyLFsyLDM0MF0pLG8oWzEsNiwxMCwxMSwxNCwyMiw3MSw5MCw5NywxMDYsMTEyLDEyNiwxMzUsMTM3LDE0NywxNzEsMjAwLDIwMSwyMDcsMjEyLDIxMywyMTQsMjE5LDIyMCwyMjksMjM4LDIzOSwyNDIsMjQzLDI0NiwyNDcsMjQ4XSxbMiwyOTVdKSxvKCRWajEsWzIsMzMxXSksezU6NTQzLDEwOiRWMX0sezExOlsxLDU0NF19LG8oJFZ2MixbMiwzMzddLHs2OlsxLDU0NV19KSx7MTM6NTQ2LDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSxvKCRWajEsWzIsOTddKSx7MTA6JFZFMSwxMjoyMjgsMTM6MzYxLDE1OjIzMCwxNjoxNTUsMTc6MzAsMTg6MzEsMTk6JFYyLDIwOiRWMywyMzokVjQsMjQ6JFY1LDI1OjM2LDI2OiRWNiwzMjokVjcsMzQ6MTIsMzU6MTMsMzY6MTQsMzc6MTUsMzg6MTYsMzk6MTcsNDA6MTgsNDE6MTksNDI6MjAsNDM6MjEsNDQ6MjIsNDU6MjMsNDY6MjQsNDc6MjUsNDg6MjYsNDk6MjcsNTA6MTAzLDUxOiRWOCw1Mjo5OCw1MzokVjksNTQ6JFZhLDU1Ojk5LDU2OiRWYiw1Nzo5Nyw1ODokVmMsNTk6MTAwLDYwOiRWZCw2MToxMTYsNjI6JFZlLDYzOjc5LDY0OiRWZiw2NToxMTcsNjY6JFZnLDcyOjQwLDczOiRWaCw3NDokVmksNzU6JFZqLDc2OiRWayw3NzokVmwsNzg6JFZtLDc5OiRWbiw4MDokVm8sODI6OTIsODM6JFZwLDg5OiRWcSw5MTokVnIsOTY6JFZzLDEwMTo0NiwxMDM6JFZ0LDEwOToxMDEsMTE5OjU0NywxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTM4OiRWeiwxMzk6JFZBLDE0MDo0OCwxNDE6NDksMTQyOjUwLDE0MzokVkIsMTQ0OiRWQywxNDg6NzIsMTUwOjc3LDE1MTokVkQsMTUyOiRWRSwxNTQ6JFZGLDE1NTo5MywxNTY6JFZHLDE1NzokVkgsMTU4OiRWSSwxNjY6NDQsMTY4Ojc2LDE3MDokVkosMTcxOiRWRzEsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjAyOjIyNiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LHsxMDokVkUxLDEyOjIyOCwxMzozNjEsMTU6MjMwLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMTk6NTQ4LDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxMzg6JFZ6LDEzOTokVkEsMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTcwOiRWSiwxNzE6JFZHMSwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDI6MjI2LDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sbygkVjAyLFsyLDExNF0pLHsxMTQ6NTQ5LDExNjokVjEyfSx7OTA6WzEsNTUwXSwxMjY6JFY5MSwxNzE6JFZhMSwyMTE6MTQ5LDIxMjokVlUsMjE0OiRWViwyMTc6MTUwLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9LG8oJFZBMSxbMiwxMDVdKSx7OTA6WzEsNTUxXSwxMjY6JFY5MSwxNzE6JFZhMSwyMTE6MTQ5LDIxMjokVlUsMjE0OiRWViwyMTc6MTUwLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9LHs5MDpbMSw1NTJdLDEyNjokVjkxLDE3MTokVmExLDIxMToxNDksMjEyOiRWVSwyMTQ6JFZWLDIxNzoxNTAsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0sbygkVjAyLFsyLDExN10pLG8oJFYwMixbMiwxMThdLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDEyNjokVjkxLDE3MTokVmExLDIxMjokVlUsMjE0OiRWViwyMTk6JFZYLDIyMDokVlksMjM4OiRWYjEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSxvKCRWajEsWzIsOThdKSxvKCRWajEsWzIsMTU4XSksbygkVnUxLFsyLDI2Nl0pLG8oJFZ1MSxbMiwyOThdKSxvKCRWdTEsWzIsMjczXSksbygkVjkyLFsyLDI3OV0pLG8oJFZ5MiwkVjcyLHsxMTU6NTUzLDE0OiRWODJ9KSxvKCRWOTIsWzIsMjgwXSksezExOiRWSDIsMTI6MjI4LDEzOjM2MSwxNToyMzAsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxMzg6JFZ6LDEzOTokVkEsMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTcwOiRWSiwxNzE6JFZHMSwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDI6NTE3LDIwNDokVlMsMjEwOiRWVCwyMTE6NjAsMjEyOiRWVSwyMTQ6JFZWLDIxNTo2MSwyMTY6JFZXLDIxNzo2MiwyMTg6MTA4LDIxOTokVlgsMjIwOiRWWSwyMjI6MTA5LDIzMDokVlosMjM1OjU4LDIzNjokVl8sMjQwOiRWJCwyNDE6JFYwMSwyNDI6JFYxMSwyNDM6JFYyMSwyNDQ6JFYzMSwyNDU6JFY0MX0sbygkVk8xLFsyLDgzXSksbygkVk8xLFsyLDg0XSksezk3OlsxLDU1NF19LHs5NzpbMiw5M119LHs5NzpbMiw5NF19LHsxMzo1NTUsMTY6MTU1LDE3OjMwLDE4OjMxLDE5OiRWMiwyMDokVjMsMjM6JFY0LDI0OiRWNSwyNTozNiwyNjokVjYsMzI6JFY3LDM0OjEyLDM1OjEzLDM2OjE0LDM3OjE1LDM4OjE2LDM5OjE3LDQwOjE4LDQxOjE5LDQyOjIwLDQzOjIxLDQ0OjIyLDQ1OjIzLDQ2OjI0LDQ3OjI1LDQ4OjI2LDQ5OjI3LDUwOjEwMyw1MTokVjgsNTI6OTgsNTM6JFY5LDU0OiRWYSw1NTo5OSw1NjokVmIsNTc6OTcsNTg6JFZjLDU5OjEwMCw2MDokVmQsNjE6MTE2LDYyOiRWZSw2Mzo3OSw2NDokVmYsNjU6MTE3LDY2OiRWZyw3Mjo0MCw3MzokVmgsNzQ6JFZpLDc1OiRWaiw3NjokVmssNzc6JFZsLDc4OiRWbSw3OTokVm4sODA6JFZvLDgyOjkyLDgzOiRWcCw4OTokVnEsOTE6JFZyLDk2OiRWcywxMDE6NDYsMTAzOiRWdCwxMDk6MTAxLDEyMTo3MCwxMjI6JFZ1LDEyMzokVnYsMTI0OiRWdywxMjk6NDUsMTMwOiRWeCwxMzE6MzgsMTM2OiRWeSwxNDA6NDgsMTQxOjQ5LDE0Mjo1MCwxNDM6JFZCLDE0NDokVkMsMTQ4OjcyLDE1MDo3NywxNTE6JFZELDE1MjokVkUsMTU0OiRWRiwxNTU6OTMsMTU2OiRWRywxNTc6JFZILDE1ODokVkksMTY2OjQ0LDE2ODo3NiwxNzM6MTAyLDE3NTokVkssMTc2OjU3LDE3ODozOSwxODQ6JFZMLDE4NTokVk0sMTg2OjQxLDE4Nzo0MiwxODg6JFZOLDE4OTo0NywxOTI6NjQsMTkzOiRWTywxOTQ6JFZQLDE5NzokVlEsMTk4OiRWUiwyMDQ6JFZTLDIxMDokVlQsMjExOjYwLDIxMjokVlUsMjE0OiRWViwyMTU6NjEsMjE2OiRWVywyMTc6NjIsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzA6JFZaLDIzNTo1OCwyMzY6JFZfLDI0MDokViQsMjQxOiRWMDEsMjQyOiRWMTEsMjQzOiRWMjEsMjQ0OiRWMzEsMjQ1OiRWNDF9LG8oJFZ1MSxbMiwxNTVdKSxvKCRWQTIsWzIsMTg4XSksbygkVkEyLFsyLDE5NV0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMTI2OiRWOTEsMTcxOiRWYTEsMjEyOiRWVSwyMTQ6JFZWLDIxOTokVlgsMjIwOiRWWSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0pLHs5MDpbMSw1NTZdfSxvKCRWZzIsWzIsMjQ3XSksbygkVnkyLCRWNzIsezExNTo1NTcsMTQ6JFZmMn0pLHs2OiRWNTEsOTo0OTEsMTE6JFZGMiwxMjY6JFY5MSwxMzI6NTU4LDE3MTokVmExLDIxMToxNDksMjEyOiRWVSwyMTQ6JFZWLDIxNzoxNTAsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0sbyhbMSw2LDEwLDExLDE0LDIyLDcxLDkwLDk3LDEwNiwxMTIsMTM1LDEzNywxNDcsMjAwLDIwMSwyMTIsMjEzLDIxNCwyMTksMjIwLDIzOF0sWzIsMzI2XSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwxMjY6JFY5MSwxNzE6JFZhMSwyMjk6WzEsNTU5XSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0pLG8oJFZDMixbMiwzMjhdLHsyMTg6MTA4LDIyMjoxMDksMjExOjE0OSwyMTc6MTUwLDEyNjokVjkxLDE3MTokVmExLDIxMzpbMSw1NjBdLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSksbygkVlkxLFsyLDMyN10sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMTI2OiRWOTEsMTcxOiRWYTEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSxvKCRWajEsWzIsMjU4XSksbygkVmoxLFsyLDEyOV0pLG8oJFZFMiwkVmIyLHsxNjc6Mzc1LDE1MDozNzYsMTY4OjM3NywxNjk6Mzc4LDUwOjM4MiwxNDY6NTYxLDUxOiRWOCw4OTokVncxLDk2OiRWUjEsMTcwOiRWYzIsMTcxOiRWZDIsMTcyOiRWZTJ9KSxvKCRWajEsWzIsMTY5XSksezE2Mjo1NjIsMTY0OiRWbzIsMTY1OiRWcDJ9LG8oJFZqMSxbMiwyODJdKSx7NjokVjUxLDk6NDkxLDExOiRWRjIsMTMyOjU2M30sbygkVmoxLFsyLDMzNF0pLG8oJFZ2MixbMiwzMzhdKSxvKCRWRzIsWzIsMjg5XSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwxMjY6JFY5MSwxNzE6JFZhMSwyMTI6JFZVLDIxNDokVlYsMjE5OiRWWCwyMjA6JFZZLDIzODokVmIxLDIzOTokVmMxLDI0MjokVmQxLDI0MzokVmUxLDI0NjokVmYxLDI0NzokVmcxLDI0ODokVmgxfSksbygkVkkyLCRWNzIsezExNTo1NjUsMTE6WzEsNTY0XSwxNDokVjgyfSksbygkVkkyLCRWNzIsezExNTo1NjUsMTQ6JFY4MiwyMjpbMSw1NjZdfSksbygkVjAyLFsyLDExNV0pLG8oJFZBMSxbMiwxMDddKSxvKCRWQTEsWzIsMTA4XSksbygkVkExLFsyLDExMV0pLHs2OiRWNTEsOTo1MjAsMTA6JFZ3MiwxMTokVkYyLDEzMjo1Njd9LG8oJFZPMSxbMiw5MF0pLHs5MDpbMSw1NjhdLDEyNjokVjkxLDE3MTokVmExLDIxMToxNDksMjEyOiRWVSwyMTQ6JFZWLDIxNzoxNTAsMjE4OjEwOCwyMTk6JFZYLDIyMDokVlksMjIyOjEwOSwyMzg6JFZiMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0sbygkVnUxLFsyLDE1Nl0pLHs2OiRWNTEsOTo1NzAsMTA6JFZCMiwxMTokVkYyLDEzMjo1Njl9LG8oJFZnMixbMiwxNDBdKSx7MTM6NTcxLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTM6NTcyLDE2OjE1NSwxNzozMCwxODozMSwxOTokVjIsMjA6JFYzLDIzOiRWNCwyNDokVjUsMjU6MzYsMjY6JFY2LDMyOiRWNywzNDoxMiwzNToxMywzNjoxNCwzNzoxNSwzODoxNiwzOToxNyw0MDoxOCw0MToxOSw0MjoyMCw0MzoyMSw0NDoyMiw0NToyMyw0NjoyNCw0NzoyNSw0ODoyNiw0OToyNyw1MDoxMDMsNTE6JFY4LDUyOjk4LDUzOiRWOSw1NDokVmEsNTU6OTksNTY6JFZiLDU3Ojk3LDU4OiRWYyw1OToxMDAsNjA6JFZkLDYxOjExNiw2MjokVmUsNjM6NzksNjQ6JFZmLDY1OjExNyw2NjokVmcsNzI6NDAsNzM6JFZoLDc0OiRWaSw3NTokVmosNzY6JFZrLDc3OiRWbCw3ODokVm0sNzk6JFZuLDgwOiRWbyw4Mjo5Miw4MzokVnAsODk6JFZxLDkxOiRWciw5NjokVnMsMTAxOjQ2LDEwMzokVnQsMTA5OjEwMSwxMjE6NzAsMTIyOiRWdSwxMjM6JFZ2LDEyNDokVncsMTI5OjQ1LDEzMDokVngsMTMxOjM4LDEzNjokVnksMTQwOjQ4LDE0MTo0OSwxNDI6NTAsMTQzOiRWQiwxNDQ6JFZDLDE0ODo3MiwxNTA6NzcsMTUxOiRWRCwxNTI6JFZFLDE1NDokVkYsMTU1OjkzLDE1NjokVkcsMTU3OiRWSCwxNTg6JFZJLDE2Njo0NCwxNjg6NzYsMTczOjEwMiwxNzU6JFZLLDE3Njo1NywxNzg6MzksMTg0OiRWTCwxODU6JFZNLDE4Njo0MSwxODc6NDIsMTg4OiRWTiwxODk6NDcsMTkyOjY0LDE5MzokVk8sMTk0OiRWUCwxOTc6JFZRLDE5ODokVlIsMjA0OiRWUywyMTA6JFZULDIxMTo2MCwyMTI6JFZVLDIxNDokVlYsMjE1OjYxLDIxNjokVlcsMjE3OjYyLDIxODoxMDgsMjE5OiRWWCwyMjA6JFZZLDIyMjoxMDksMjMwOiRWWiwyMzU6NTgsMjM2OiRWXywyNDA6JFYkLDI0MTokVjAxLDI0MjokVjExLDI0MzokVjIxLDI0NDokVjMxLDI0NTokVjQxfSx7MTQ6JFZ6MiwyMjpbMSw1NzNdfSxvKCRWajEsWzIsMTcwXSksbygkVmoxLFsyLDMzMl0pLG8oJFZqMSxbMiwxMTldKSx7NjokVjUxLDk6NDUyLDEwOiRWdzJ9LG8oJFZqMSxbMiwxMjBdKSxvKCRWOTIsWzIsMjgxXSksezk3OlsyLDk1XX0sbygkVmcyLFsyLDI0OF0pLHsxMTokVkgyLDE1OjI1MSwzMjokVjcsNTA6MjUyLDUxOiRWOCw1MjoyNTUsNTM6JFY5LDU0OiRWYSw1NToyNTYsNTY6JFZiLDU3OjI1Myw1ODokVmMsNjE6MTE2LDYyOiRWZSw2MzoyNTQsNjQ6JFZmLDY1OjExNyw2NjokVmcsMTMzOjUzMSwxMzQ6MjUwLDEzNjokVkoxLDEzODokVnosMTM5OiRWQX0sbygkVlkxLFsyLDMyOV0sezIxODoxMDgsMjIyOjEwOSwyMTE6MTQ5LDIxNzoxNTAsMTI2OiRWOTEsMTcxOiRWYTEsMjM5OiRWYzEsMjQyOiRWZDEsMjQzOiRWZTEsMjQ2OiRWZjEsMjQ3OiRWZzEsMjQ4OiRWaDF9KSxvKCRWWTEsWzIsMzMwXSx7MjE4OjEwOCwyMjI6MTA5LDIxMToxNDksMjE3OjE1MCwxMjY6JFY5MSwxNzE6JFZhMSwyMzk6JFZjMSwyNDI6JFZkMSwyNDM6JFZlMSwyNDY6JFZmMSwyNDc6JFZnMSwyNDg6JFZoMX0pLHsxNjI6NTc0LDE2NDokVm8yLDE2NTokVnAyfSxvKCRWajEsWzIsMTY4XSldLFxuZGVmYXVsdEFjdGlvbnM6IHsxMzU6WzIsM10sMTYzOlsyLDI2NF0sMzI0OlsyLDI0Ml0sNTI0OlsyLDkzXSw1MjU6WzIsOTRdLDU2ODpbMiw5NV19LFxucGFyc2VFcnJvcjogZnVuY3Rpb24gcGFyc2VFcnJvcihzdHIsIGhhc2gpIHtcbiAgICBpZiAoaGFzaC5yZWNvdmVyYWJsZSkge1xuICAgICAgICB0aGlzLnRyYWNlKHN0cik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHN0cik7XG4gICAgfVxufSxcbnBhcnNlOiBmdW5jdGlvbiBwYXJzZShpbnB1dCkge1xuXG4gICAgLy8gRm9yIEltYmEgd2UgYXJlIGdvaW5nIHRvIGRyb3AgbW9zdCBvZiB0aGUgZmVhdHVyZXMgdGhhdCBhcmUgbm90IHVzZWRcbiAgICAvLyBMb2NhdGlvbnMgYXJlIHByb3ZpZGVkIGJ5IHRoZSB0b2tlbnMgZnJvbSB0aGUgbGV4ZXIgZGlyZWN0bHkgLSBzbyBkcm9wIHl5bGxvY1xuICAgIC8vIFdlIGRvbnQgcmVhbGx5IG5lZWQgdGhlIHNoYXJlZCBzdGF0ZSAoaXQgc2VlbXMpXG5cbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIHN0YWNrID0gWzBdLFxuICAgICAgICB0c3RhY2sgPSBbXSwgLy8gdG9rZW4gc3RhY2tcbiAgICAgICAgdnN0YWNrID0gW251bGxdLCAvLyBzZW1hbnRpYyB2YWx1ZSBzdGFja1xuICAgICAgICB0YWJsZSA9IHRoaXMudGFibGUsXG4gICAgICAgIHl5dGV4dCA9ICcnLFxuICAgICAgICB5eWxpbmVubyA9IDAsXG4gICAgICAgIHl5bGVuZyA9IDAsXG4gICAgICAgIHJlY292ZXJpbmcgPSAwLFxuICAgICAgICBURVJST1IgPSAyLFxuICAgICAgICBFT0YgPSAxO1xuXG4gICAgLy8gdmFyIGFyZ3MgPSBsc3RhY2suc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIC8vdGhpcy5yZWR1Y3Rpb25Db3VudCA9IHRoaXMuc2hpZnRDb3VudCA9IDA7XG5cbiAgICB2YXIgbGV4ZXIgPSBPYmplY3QuY3JlYXRlKHRoaXMubGV4ZXIpO1xuICAgIHZhciB5eSA9IHRoaXMueXk7XG5cbiAgICBsZXhlci5zZXRJbnB1dChpbnB1dCx5eSk7XG5cbiAgICBpZiAodHlwZW9mIHl5LnBhcnNlRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5wYXJzZUVycm9yID0geXkucGFyc2VFcnJvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhcnNlRXJyb3IgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykucGFyc2VFcnJvcjsgLy8gd2hhdD9cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb3BTdGFjayAobikge1xuICAgICAgICBzdGFjay5sZW5ndGggPSBzdGFjay5sZW5ndGggLSAyICogbjtcbiAgICAgICAgdnN0YWNrLmxlbmd0aCA9IHZzdGFjay5sZW5ndGggLSBuO1xuICAgIH1cblxuICAgIHZhciBzeW1ib2wsIHByZUVycm9yU3ltYm9sLCBzdGF0ZSwgYWN0aW9uLCBhLCByLCB5eXZhbCA9IHt9LCBwLCBsZW4sIG5ld1N0YXRlLCBleHBlY3RlZDtcblxuICAgIGZ1bmN0aW9uIGhhbmRsZUVycm9yKCl7XG4gICAgICAgIHZhciBlcnJvcl9ydWxlX2RlcHRoO1xuICAgICAgICB2YXIgZXJyU3RyID0gJyc7XG5cbiAgICAgICAgLy8gUmV0dXJuIHRoZSBydWxlIHN0YWNrIGRlcHRoIHdoZXJlIHRoZSBuZWFyZXN0IGVycm9yIHJ1bGUgY2FuIGJlIGZvdW5kLlxuICAgICAgICAvLyBSZXR1cm4gRkFMU0Ugd2hlbiBubyBlcnJvciByZWNvdmVyeSBydWxlIHdhcyBmb3VuZC5cbiAgICAgICAgLy8gd2UgaGF2ZSBubyBydWxlcyBub3dcbiAgICAgICAgZnVuY3Rpb24gbG9jYXRlTmVhcmVzdEVycm9yUmVjb3ZlcnlSdWxlKHN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgc3RhY2tfcHJvYmUgPSBzdGFjay5sZW5ndGggLSAxO1xuICAgICAgICAgICAgdmFyIGRlcHRoID0gMDtcblxuICAgICAgICAgICAgLy8gdHJ5IHRvIHJlY292ZXIgZnJvbSBlcnJvclxuICAgICAgICAgICAgZm9yKDs7KSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGVycm9yIHJlY292ZXJ5IHJ1bGUgaW4gdGhpcyBzdGF0ZVxuICAgICAgICAgICAgICAgIGlmICgoVEVSUk9SLnRvU3RyaW5nKCkpIGluIHRhYmxlW3N0YXRlXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVwdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gMCB8fCBzdGFja19wcm9iZSA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBObyBzdWl0YWJsZSBlcnJvciByZWNvdmVyeSBydWxlIGF2YWlsYWJsZS5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhY2tfcHJvYmUgLT0gMjsgLy8gcG9wU3RhY2soMSk6IFtzeW1ib2wsIGFjdGlvbl1cbiAgICAgICAgICAgICAgICBzdGF0ZSA9IHN0YWNrW3N0YWNrX3Byb2JlXTtcbiAgICAgICAgICAgICAgICArK2RlcHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyZWNvdmVyaW5nKSB7XG4gICAgICAgICAgICAvLyBmaXJzdCBzZWUgaWYgdGhlcmUncyBhbnkgY2hhbmNlIGF0IGhpdHRpbmcgYW4gZXJyb3IgcmVjb3ZlcnkgcnVsZTpcbiAgICAgICAgICAgIGVycm9yX3J1bGVfZGVwdGggPSBsb2NhdGVOZWFyZXN0RXJyb3JSZWNvdmVyeVJ1bGUoc3RhdGUpO1xuXG4gICAgICAgICAgICAvLyBSZXBvcnQgZXJyb3JcbiAgICAgICAgICAgIGV4cGVjdGVkID0gW107XG5cbiAgICAgICAgICAgIHZhciB0c3ltID0gbGV4ZXIueXl0ZXh0O1xuICAgICAgICAgICAgdmFyIHRvayA9IHNlbGYudGVybWluYWxzX1tzeW1ib2xdIHx8IHN5bWJvbDtcbiAgICAgICAgICAgIHZhciB0bG9jID0gdHN5bSA/IHRzeW0uX2xvYyA6IC0xO1xuICAgICAgICAgICAgdmFyIHRwb3MgPSB0bG9jICE9IC0xID8gXCJbXCIgKyB0c3ltLl9sb2MgKyBcIjpcIiArIHRzeW0uX2xlbiArIFwiXVwiIDogJ1swOjBdJztcblxuICAgICAgICAgICAgaWYgKGxleGVyLnNob3dQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIGVyclN0ciA9ICdQYXJzZSBlcnJvciBhdCAnKyh0cG9zKStcIjpcXG5cIitsZXhlci5zaG93UG9zaXRpb24oKStcIlxcbkV4cGVjdGluZyBcIitleHBlY3RlZC5qb2luKCcsICcpICsgXCIsIGdvdCAnXCIgKyAoc2VsZi50ZXJtaW5hbHNfW3N5bWJvbF0gfHwgc3ltYm9sKSsgXCInXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVyclN0ciA9ICdQYXJzZSBlcnJvciBhdCAnKyh0cG9zKStcIjogVW5leHBlY3RlZCBcIiArIChzeW1ib2wgPT0gRU9GID8gXCJlbmQgb2YgaW5wdXRcIiA6IChcIidcIisodG9rKStcIidcIikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLnBhcnNlRXJyb3IoZXJyU3RyLCB7XG4gICAgICAgICAgICAgICAgbGV4ZXI6IGxleGVyLFxuICAgICAgICAgICAgICAgIHRleHQ6IGxleGVyLm1hdGNoLFxuICAgICAgICAgICAgICAgIHRva2VuOiB0b2ssXG4gICAgICAgICAgICAgICAgbGluZTogbGV4ZXIueXlsaW5lbm8sXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgICAgICAgICAgIHJlY292ZXJhYmxlOiAoZXJyb3JfcnVsZV9kZXB0aCAhPT0gZmFsc2UpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChwcmVFcnJvclN5bWJvbCAhPT0gRU9GKSB7XG4gICAgICAgICAgICBlcnJvcl9ydWxlX2RlcHRoID0gbG9jYXRlTmVhcmVzdEVycm9yUmVjb3ZlcnlSdWxlKHN0YXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGp1c3QgcmVjb3ZlcmVkIGZyb20gYW5vdGhlciBlcnJvclxuICAgICAgICBpZiAocmVjb3ZlcmluZyA9PSAzKSB7XG4gICAgICAgICAgICBpZiAoc3ltYm9sID09PSBFT0YgfHwgcHJlRXJyb3JTeW1ib2wgPT09IEVPRikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJTdHIgfHwgJ1BhcnNpbmcgaGFsdGVkIHdoaWxlIHN0YXJ0aW5nIHRvIHJlY292ZXIgZnJvbSBhbm90aGVyIGVycm9yLicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBkaXNjYXJkIGN1cnJlbnQgbG9va2FoZWFkIGFuZCBncmFiIGFub3RoZXJcbiAgICAgICAgICAgIHl5dGV4dCA9IGxleGVyLnl5dGV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyeSB0byByZWNvdmVyIGZyb20gZXJyb3JcbiAgICAgICAgaWYgKGVycm9yX3J1bGVfZGVwdGggPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyU3RyIHx8ICdQYXJzaW5nIGhhbHRlZC4gTm8gc3VpdGFibGUgZXJyb3IgcmVjb3ZlcnkgcnVsZSBhdmFpbGFibGUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcG9wU3RhY2soZXJyb3JfcnVsZV9kZXB0aCk7XG4gICAgICAgIHByZUVycm9yU3ltYm9sID0gKHN5bWJvbCA9PSBURVJST1IgPyBudWxsIDogc3ltYm9sKTsgLy8gc2F2ZSB0aGUgbG9va2FoZWFkIHRva2VuXG4gICAgICAgIHN5bWJvbCA9IFRFUlJPUjsgICAgICAgICAvLyBpbnNlcnQgZ2VuZXJpYyBlcnJvciBzeW1ib2wgYXMgbmV3IGxvb2thaGVhZFxuICAgICAgICBzdGF0ZSA9IHN0YWNrW3N0YWNrLmxlbmd0aC0xXTtcbiAgICAgICAgYWN0aW9uID0gdGFibGVbc3RhdGVdICYmIHRhYmxlW3N0YXRlXVtURVJST1JdO1xuICAgICAgICByZWNvdmVyaW5nID0gMzsgLy8gYWxsb3cgMyByZWFsIHN5bWJvbHMgdG8gYmUgc2hpZnRlZCBiZWZvcmUgcmVwb3J0aW5nIGEgbmV3IGVycm9yXG4gICAgfVxuXG5cbiAgICB2YXIgX19zeW0gPSB0aGlzLnN5bWJvbHNfO1xuICAgIHZhciBfX3Byb2QgPSB0aGlzLnByb2R1Y3Rpb25zXztcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIC8vIHJldHJlaXZlIHN0YXRlIG51bWJlciBmcm9tIHRvcCBvZiBzdGFja1xuICAgICAgICBzdGF0ZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmIChzeW1ib2wgPT09IG51bGwgfHwgdHlwZW9mIHN5bWJvbCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgc3ltYm9sID0gX19zeW1bbGV4ZXIubGV4KCldIHx8IEVPRjtcbiAgICAgICAgfVxuICAgICAgICBhY3Rpb24gPSB0YWJsZVtzdGF0ZV0gJiYgdGFibGVbc3RhdGVdW3N5bWJvbF07XG5cbl9oYW5kbGVfZXJyb3I6XG4gICAgICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSAndW5kZWZpbmVkJyB8fCAhYWN0aW9uLmxlbmd0aCB8fCAhYWN0aW9uWzBdKSB7XG4gICAgICAgICAgICBoYW5kbGVFcnJvcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChhY3Rpb25bMF0pIHtcbiAgICAgICAgICAgIGNhc2UgMTogLy8gc2hpZnRcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHN5bWJvbCk7XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChhY3Rpb25bMV0pOyAvLyBwdXNoIHN0YXRlXG4gICAgICAgICAgICAgICAgdnN0YWNrLnB1c2gobGV4ZXIueXl0ZXh0KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghcHJlRXJyb3JTeW1ib2wpIHsgLy8gbm9ybWFsIGV4ZWN1dGlvbi9ubyBlcnJvclxuICAgICAgICAgICAgICAgICAgICB5eXRleHQgPSBsZXhlci55eXRleHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNvdmVyaW5nID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3ZlcmluZy0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXJyb3IganVzdCBvY2N1cnJlZCwgcmVzdW1lIG9sZCBsb29rYWhlYWQgZi8gYmVmb3JlIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IHByZUVycm9yU3ltYm9sO1xuICAgICAgICAgICAgICAgICAgICBwcmVFcnJvclN5bWJvbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgbGVuID0gX19wcm9kW2FjdGlvblsxXV1bMV07XG4gICAgICAgICAgICAgICAgLy8gcGVyZm9ybSBzZW1hbnRpYyBhY3Rpb25cbiAgICAgICAgICAgICAgICB5eXZhbC4kID0gdnN0YWNrW3ZzdGFjay5sZW5ndGgtbGVuXTtcbiAgICAgICAgICAgICAgICByID0gdGhpcy5wZXJmb3JtQWN0aW9uKHl5dmFsLCB5eXRleHQsIHl5LCBhY3Rpb25bMV0sIHZzdGFjayk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB3aGlsZShsZW4gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgdnN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBsZW4tLTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKF9fcHJvZFthY3Rpb25bMV1dWzBdKTtcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IHRhYmxlW3N0YWNrW3N0YWNrLmxlbmd0aC0yXV1bc3RhY2tbc3RhY2subGVuZ3RoLTFdXTtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKG5ld1N0YXRlKTtcbiAgICAgICAgICAgICAgICB2c3RhY2sucHVzaCh5eXZhbC4kKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59fTtcblxuZnVuY3Rpb24gUGFyc2VyICgpIHtcbiAgdGhpcy55eSA9IHt9O1xufVxuUGFyc2VyLnByb3RvdHlwZSA9IHBhcnNlcjtwYXJzZXIuUGFyc2VyID0gUGFyc2VyO1xucmV0dXJuIG5ldyBQYXJzZXI7XG59KSgpO1xuXG5cbmlmICh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG5leHBvcnRzLnBhcnNlciA9IHBhcnNlcjtcbmV4cG9ydHMuUGFyc2VyID0gcGFyc2VyLlBhcnNlcjtcbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBwYXJzZXIucGFyc2UuYXBwbHkocGFyc2VyLCBhcmd1bWVudHMpOyB9O1xuLy8gZXhwb3J0cy5tYWluID0gZnVuY3Rpb24gY29tbW9uanNNYWluKGFyZ3MpIHtcbi8vICAgICBpZiAoIWFyZ3NbMV0pIHtcbi8vICAgICAgICAgY29uc29sZS5sb2coJ1VzYWdlOiAnK2FyZ3NbMF0rJyBGSUxFJyk7XG4vLyAgICAgICAgIHByb2Nlc3MuZXhpdCgxKTtcbi8vICAgICB9XG4vLyAgICAgdmFyIHNvdXJjZSA9IHJlcXVpcmUoJ2ZzJykucmVhZEZpbGVTeW5jKHJlcXVpcmUoJ3BhdGgnKS5ub3JtYWxpemUoYXJnc1sxXSksIFwidXRmOFwiKTtcbi8vICAgICByZXR1cm4gZXhwb3J0cy5wYXJzZXIucGFyc2Uoc291cmNlKTtcbi8vIH07XG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgcmVxdWlyZS5tYWluID09PSBtb2R1bGUpIHtcbiAgZXhwb3J0cy5tYWluKHByb2Nlc3MuYXJndi5zbGljZSgxKSk7XG59XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9jb21waWxlci9wYXJzZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdGlmKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XHJcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xyXG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59XHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzXG4gKiogbW9kdWxlIGlkID0gNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS9+L25vZGUtbGlicy1icm93c2VyL34vcHJvY2Vzcy9icm93c2VyLmpzXG4gKiogbW9kdWxlIGlkID0gN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdGZ1bmN0aW9uIGlkeCQoYSxiKXtcblx0XHRyZXR1cm4gKGIgJiYgYi5pbmRleE9mKSA/IGIuaW5kZXhPZihhKSA6IFtdLmluZGV4T2YuY2FsbChhLGIpO1xuXHR9O1xuXHRcblx0Ly8gaGVscGVyIGZvciBzdWJjbGFzc2luZ1xuXHRmdW5jdGlvbiBzdWJjbGFzcyQob2JqLHN1cCkge1xuXHRcdGZvciAodmFyIGsgaW4gc3VwKSB7XG5cdFx0XHRpZiAoc3VwLmhhc093blByb3BlcnR5KGspKSBvYmpba10gPSBzdXBba107XG5cdFx0fTtcblx0XHQvLyBvYmouX19zdXBlcl9fID0gc3VwO1xuXHRcdG9iai5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cC5wcm90b3R5cGUpO1xuXHRcdG9iai5fX3N1cGVyX18gPSBvYmoucHJvdG90eXBlLl9fc3VwZXJfXyA9IHN1cC5wcm90b3R5cGU7XG5cdFx0b2JqLnByb3RvdHlwZS5pbml0aWFsaXplID0gb2JqLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG9iajtcblx0fTtcblx0XG5cdGZ1bmN0aW9uIGl0ZXIkKGEpeyByZXR1cm4gYSA/IChhLnRvQXJyYXkgPyBhLnRvQXJyYXkoKSA6IGEpIDogW107IH07XG5cdHZhciBBU1QsIE9QLCBPUF9DT01QT1VORCwgTk9ERVMsIFNQTEFULCBTVEFDSywgS19JVkFSLCBLX1NZTSwgS19TVFIsIEtfUFJPUCwgQlIsIEJSMiwgU0VMRiwgU1VQRVIsIFRSVUUsIEZBTFNFLCBVTkRFRklORUQsIE5JTCwgQVJHVU1FTlRTLCBFTVBUWSwgTlVMTCwgUkVTRVJWRUQsIFJFU0VSVkVEX1JFR0VYLCBVTklPTiwgSU5URVJTRUNULCBDTEFTU0RFRiwgVEFHREVGLCBORVdUQUc7XG5cdC8vIFRPRE8gQ3JlYXRlIEV4cHJlc3Npb24gLSBtYWtlIGFsbCBleHByZXNzaW9ucyBpbmhlcml0IGZyb20gdGhlc2U/XG5cdFxuXHQvLyBleHRlcm5zO1xuXHRcblx0dmFyIGhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcblx0dmFyIEVSUiA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5cdHZhciB2OCA9IG51bGw7IC8vIHJlcXVpcmUgJ3Y4LW5hdGl2ZXMnXG5cdFxuXHR2YXIgVCA9IHJlcXVpcmUoJy4vdG9rZW4nKTtcblx0dmFyIFRva2VuID0gVC5Ub2tlbjtcblx0XG5cdHZhciBTb3VyY2VNYXAgPSByZXF1aXJlKCcuL3NvdXJjZW1hcCcpLlNvdXJjZU1hcDtcblx0XG5cdG1vZHVsZS5leHBvcnRzLkFTVCA9IEFTVCA9IHt9O1xuXHRcblx0Ly8gSGVscGVycyBmb3Igb3BlcmF0b3JzXG5cdG1vZHVsZS5leHBvcnRzLk9QID0gT1AgPSBmdW5jdGlvbihvcCxsLHIpIHtcblx0XHR2YXIgbyA9IFN0cmluZyhvcCk7XG5cdFx0Ly8gY29uc29sZS5sb2cgXCJvcGVyYXRvclwiLG9cblx0XHRzd2l0Y2ggKG8pIHtcblx0XHRcdGNhc2UgJy4nOlxuXHRcdFx0XHRpZiAoKHR5cGVvZiByPT0nc3RyaW5nJ3x8ciBpbnN0YW5jZW9mIFN0cmluZykpIHsgciA9IG5ldyBJZGVudGlmaWVyKHIpIH07XG5cdFx0XHRcdC8vIHIgPSByLnZhbHVlIGlmIHIgaXNhIFZhck9yQWNjZXNzXG5cdFx0XHRcdHJldHVybiBuZXcgQWNjZXNzKG9wLGwscik7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0XG5cdFx0XHRjYXNlICc9Jzpcblx0XHRcdFx0aWYgKGwgaW5zdGFuY2VvZiBUdXBsZSkgeyByZXR1cm4gbmV3IFR1cGxlQXNzaWduKG9wLGwscikgfTtcblx0XHRcdFx0cmV0dXJuIG5ldyBBc3NpZ24ob3AsbCxyKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcblx0XHRcdGNhc2UgJz89Jzpcblx0XHRcdGNhc2UgJ3x8PSc6XG5cdFx0XHRjYXNlICcmJj0nOlxuXHRcdFx0XHRyZXR1cm4gbmV3IENvbmRpdGlvbmFsQXNzaWduKG9wLGwscik7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0XG5cdFx0XHRjYXNlICcrPSc6XG5cdFx0XHRjYXNlICctPSc6XG5cdFx0XHRjYXNlICcqPSc6XG5cdFx0XHRjYXNlICcvPSc6XG5cdFx0XHRjYXNlICdePSc6XG5cdFx0XHRjYXNlICclPSc6XG5cdFx0XHRcdHJldHVybiBuZXcgQ29tcG91bmRBc3NpZ24ob3AsbCxyKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcblx0XHRcdGNhc2UgJz8uJzpcblx0XHRcdFx0aWYgKHIgaW5zdGFuY2VvZiBWYXJPckFjY2Vzcykge1xuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nIFwiaXMgdmFyIG9yIGFjY2Vzc1wiXG5cdFx0XHRcdFx0ciA9IHIudmFsdWUoKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0Ly8gZGVwZW5kcyBvbiB0aGUgcmlnaHQgc2lkZSAtIHRoaXMgaXMgd3Jvbmdcblx0XHRcdFx0cmV0dXJuIG5ldyBQcm9wZXJ0eUFjY2VzcyhvcCxsLHIpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdFxuXHRcdFx0Y2FzZSAnaW5zdGFuY2VvZic6XG5cdFx0XHRcdHJldHVybiBuZXcgSW5zdGFuY2VPZihvcCxsLHIpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdFxuXHRcdFx0Y2FzZSAnaW4nOlxuXHRcdFx0XHRyZXR1cm4gbmV3IEluKG9wLGwscik7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0XG5cdFx0XHRjYXNlICd0eXBlb2YnOlxuXHRcdFx0XHRyZXR1cm4gbmV3IFR5cGVPZihvcCxsLHIpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdFxuXHRcdFx0Y2FzZSAnZGVsZXRlJzpcblx0XHRcdFx0cmV0dXJuIG5ldyBEZWxldGUob3AsbCxyKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcblx0XHRcdGNhc2UgJy0tJzpcblx0XHRcdGNhc2UgJysrJzpcblx0XHRcdGNhc2UgJyEnOlxuXHRcdFx0Y2FzZSAn4oiaJzpcblx0XHRcdFx0cmV0dXJuIG5ldyBVbmFyeU9wKG9wLGwscik7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0XG5cdFx0XHRjYXNlICc+Jzpcblx0XHRcdGNhc2UgJzwnOlxuXHRcdFx0Y2FzZSAnPj0nOlxuXHRcdFx0Y2FzZSAnPD0nOlxuXHRcdFx0Y2FzZSAnPT0nOlxuXHRcdFx0Y2FzZSAnPT09Jzpcblx0XHRcdGNhc2UgJyE9Jzpcblx0XHRcdGNhc2UgJyE9PSc6XG5cdFx0XHRcdHJldHVybiBuZXcgQ29tcGFyaXNvbk9wKG9wLGwscik7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0XG5cdFx0XHRjYXNlICfiiKknOlxuXHRcdFx0Y2FzZSAn4oiqJzpcblx0XHRcdFx0cmV0dXJuIG5ldyBNYXRoT3Aob3AsbCxyKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcblx0XHRcdGNhc2UgJy4uJzpcblx0XHRcdGNhc2UgJy4uLic6XG5cdFx0XHRcdHJldHVybiBuZXcgUmFuZ2Uob3AsbCxyKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcblx0XHRcdFx0cmV0dXJuIG5ldyBPcChvcCxsLHIpO1xuXHRcdFxuXHRcdH07XG5cdH07XG5cdFxuXHRtb2R1bGUuZXhwb3J0cy5PUF9DT01QT1VORCA9IE9QX0NPTVBPVU5EID0gZnVuY3Rpb24oc3ltLG9wLGwscikge1xuXHRcdC8vIGNvbnNvbGUubG9nIFwiPy4gc29hayBvcGVyYXRvclwiLHN5bVxuXHRcdGlmIChzeW0gPT0gJz8uJykge1xuXHRcdFx0Y29uc29sZS5sb2coXCI/LiBzb2FrIG9wZXJhdG9yXCIpO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblx0XHRpZiAoc3ltID09ICc/PScgfHwgc3ltID09ICd8fD0nIHx8IHN5bSA9PSAnJiY9Jykge1xuXHRcdFx0cmV0dXJuIG5ldyBDb25kaXRpb25hbEFzc2lnbihvcCxsLHIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gbmV3IENvbXBvdW5kQXNzaWduKG9wLGwscik7XG5cdFx0fTtcblx0fTtcblx0XG5cdHZhciBPUFRTID0ge307XG5cdHZhciBST09UID0gbnVsbDtcblx0XG5cdG1vZHVsZS5leHBvcnRzLk5PREVTID0gTk9ERVMgPSBbXTtcblx0XG5cdHZhciBMSVQgPSBmdW5jdGlvbih2YWwpIHtcblx0XHRyZXR1cm4gbmV3IExpdGVyYWwodmFsKTtcblx0fTtcblx0XG5cdHZhciBTWU0gPSBmdW5jdGlvbih2YWwpIHtcblx0XHRyZXR1cm4gbmV3IFN5bWJvbCh2YWwpO1xuXHR9O1xuXHRcblx0dmFyIElGID0gZnVuY3Rpb24oY29uZCxib2R5LGFsdCkge1xuXHRcdHZhciBub2RlID0gbmV3IElmKGNvbmQsYm9keSk7XG5cdFx0aWYgKGFsdCkgeyBub2RlLmFkZEVsc2UoYWx0KSB9O1xuXHRcdHJldHVybiBub2RlO1xuXHR9O1xuXHRcblx0dmFyIEZOID0gZnVuY3Rpb24ocGFycyxib2R5KSB7XG5cdFx0cmV0dXJuIG5ldyBGdW5jKHBhcnMsYm9keSk7XG5cdH07XG5cdFxuXHR2YXIgQ0FMTCA9IGZ1bmN0aW9uKGNhbGxlZSxwYXJzKSB7XG5cdFx0Ly8gcG9zc2libHkgcmV0dXJuIGluc3RlYWQoISlcblx0XHRpZihwYXJzID09PSB1bmRlZmluZWQpIHBhcnMgPSBbXTtcblx0XHRyZXR1cm4gbmV3IENhbGwoY2FsbGVlLHBhcnMpO1xuXHR9O1xuXHRcblx0dmFyIENBTExTRUxGID0gZnVuY3Rpb24obmFtZSxwYXJzKSB7XG5cdFx0aWYocGFycyA9PT0gdW5kZWZpbmVkKSBwYXJzID0gW107XG5cdFx0dmFyIHJlZiA9IG5ldyBJZGVudGlmaWVyKG5hbWUpO1xuXHRcdHJldHVybiBuZXcgQ2FsbChPUCgnLicsU0VMRixyZWYpLHBhcnMpO1xuXHR9O1xuXHRcblx0dmFyIEJMT0NLID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIEJsb2NrLndyYXAoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcblx0fTtcblx0XG5cdHZhciBXSElMRSA9IGZ1bmN0aW9uKHRlc3QsY29kZSkge1xuXHRcdHJldHVybiBuZXcgV2hpbGUodGVzdCkuYWRkQm9keShjb2RlKTtcblx0fTtcblx0XG5cdG1vZHVsZS5leHBvcnRzLlNQTEFUID0gU1BMQVQgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFzc2lnbikge1xuXHRcdFx0Ly8gcCBcIldBUk5cIlxuXHRcdFx0dmFsdWUuc2V0TGVmdChuZXcgU3BsYXQodmFsdWUubGVmdCgpKSk7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBuZXcgU3BsYXQodmFsdWUpO1xuXHRcdFx0Ly8gbm90IHN1cmUgYWJvdXQgdGhpc1xuXHRcdH07XG5cdH07XG5cdFxuXHQvLyBPUC5BU1NJR05NRU5UID0gWyBcIj1cIiAsIFwiKz1cIiAsIFwiLT1cIiAsIFwiKj1cIiAsIFwiLz1cIiAsIFwiJT1cIiwgXCI8PD1cIiAsIFwiPj49XCIgLCBcIj4+Pj1cIiwgXCJ8PVwiICwgXCJePVwiICwgXCImPVwiIF1cblx0Ly8gT1AuTE9HSUNBTCA9IFsgXCJ8fFwiICwgXCImJlwiIF1cblx0Ly8gT1AuVU5BUlkgPSBbIFwiKytcIiAsIFwiLS1cIiBdXG5cdFxuXHR2YXIgU0VNSUNPTE9OX1RFU1QgPSAvOyhcXHMqXFwvXFwvLiopP1tcXG5cXHNcXHRdKiQvO1xuXHR2YXIgUkVTRVJWRURfVEVTVCA9IC9eKGRlZmF1bHR8Y2hhcikkLztcblx0XG5cdC8vIGNhcHR1cmVzIGVycm9yIGZyb20gcGFyc2VyXG5cdGZ1bmN0aW9uIHBhcnNlRXJyb3Ioc3RyLG8pe1xuXHRcdC8vIGNvbnNvbGUubG9nICdwYXJzZUVycm9yJyxvOnRva2VuXG5cdFx0XG5cdFx0Ly8gZmluZCBuZWFyZXN0IHRva2VuXG5cdFx0dmFyIGVycjtcblx0XHRcblx0XHRpZiAoby5sZXhlcikge1xuXHRcdFx0dmFyIHRva2VuID0gby5sZXhlci55eXRleHQ7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyBvOmxleGVyOnBvcyx0b2tlbi5AbG9jXG5cdFx0XHRlcnIgPSBuZXcgRVJSLkltYmFQYXJzZUVycm9yKHttZXNzYWdlOiBzdHJ9LHtcblx0XHRcdFx0cG9zOiBvLmxleGVyLnBvcyxcblx0XHRcdFx0dG9rZW5zOiBvLmxleGVyLnRva2Vucyxcblx0XHRcdFx0dG9rZW46IG8ubGV4ZXIueXl0ZXh0LFxuXHRcdFx0XHRtZXRhOiBvXG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0dGhyb3cgZXJyO1xuXHRcdFx0XG5cdFx0XHQvLyBzaG91bGQgZmluZCB0aGUgY2xvc2VzdCB0b2tlbiB3aXRoIGFjdHVhbCBwb3NpdGlvblxuXHRcdFx0Ly8gc3RyID0gXCJbe3Rva2VuLkBsb2N9Ont0b2tlbi5AbGVuIHx8IFN0cmluZyh0b2tlbik6bGVuZ3RofV0ge3N0cn1cIlxuXHRcdH07XG5cdFx0dmFyIGUgPSBuZXcgRXJyb3Ioc3RyKTtcblx0XHRlLmxleGVyID0gby5sZXhlcjtcblx0XHRlLm9wdGlvbnMgPSBvO1xuXHRcdHRocm93IGU7XG5cdH07IGV4cG9ydHMucGFyc2VFcnJvciA9IHBhcnNlRXJyb3I7XG5cdFxuXHRmdW5jdGlvbiBjX18ob2JqKXtcblx0XHRyZXR1cm4gdHlwZW9mIG9iaiA9PSAnc3RyaW5nJyA/IChvYmopIDogKG9iai5jKCkpO1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gbWFya19fKHRvayl7XG5cdFx0aWYgKHRvayAmJiAoT1BUUy5zb3VyY2VNYXBJbmxpbmUgfHwgT1BUUy5zb3VyY2VNYXApICYmIHRvay5zb3VyY2VNYXBNYXJrZXIpIHtcblx0XHRcdHJldHVybiB0b2suc291cmNlTWFwTWFya2VyKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiAnJztcblx0XHR9O1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gbnVtX18obnVtKXtcblx0XHRyZXR1cm4gbmV3IE51bShudW0pO1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gc3RyX18oc3RyKXtcblx0XHQvLyBzaG91bGQgcGFjayBpbiB0b2tlbj8hP1xuXHRcdHJldHVybiBuZXcgU3RyKHN0cik7XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBibGtfXyhvYmope1xuXHRcdHJldHVybiBvYmogaW5zdGFuY2VvZiBBcnJheSA/IChCbG9jay53cmFwKG9iaikpIDogKG9iaik7XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBzeW1fXyhvYmope1xuXHRcdC8vIGNvbnNvbGUubG9nIFwic3ltIHtvYmp9XCJcblx0XHRyZXR1cm4gaGVscGVycy5zeW1ib2xpemUoU3RyaW5nKG9iaikpO1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gY2FyeV9fKGFyeSl7XG5cdFx0cmV0dXJuIGFyeS5tYXAoZnVuY3Rpb24odikgeyByZXR1cm4gdHlwZW9mIHYgPT0gJ3N0cmluZycgPyAodikgOiAodi5jKCkpOyB9KTtcblx0fTtcblx0XG5cdGZ1bmN0aW9uIGR1bXBfXyhvYmosa2V5KXtcblx0XHRpZiAob2JqIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdHJldHVybiBvYmoubWFwKGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHYgJiYgdi5kdW1wID8gKHYuZHVtcChrZXkpKSA6ICh2KTsgfSk7XG5cdFx0fSBlbHNlIGlmIChvYmogJiYgb2JqLmR1bXApIHtcblx0XHRcdHJldHVybiBvYmouZHVtcCgpO1xuXHRcdH07XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBjb21wYWN0X18oYXJ5KXtcblx0XHRpZiAoYXJ5IGluc3RhbmNlb2YgTGlzdE5vZGUpIHtcblx0XHRcdHJldHVybiBhcnkuY29tcGFjdCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIGFyeS5maWx0ZXIoZnVuY3Rpb24odikgeyByZXR1cm4gdiAhPSB1bmRlZmluZWQgJiYgdiAhPSBudWxsOyB9KTtcblx0fTtcblx0XG5cdGZ1bmN0aW9uIHJlZHVjZV9fKHJlcyxhcnkpe1xuXHRcdGZvciAodmFyIGkgPSAwLCBpdGVtcyA9IGl0ZXIkKGFyeSksIGxlbiA9IGl0ZW1zLmxlbmd0aCwgdjsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHR2ID0gaXRlbXNbaV07XG5cdFx0XHR2IGluc3RhbmNlb2YgQXJyYXkgPyAocmVkdWNlX18ocmVzLHYpKSA6IChyZXMucHVzaCh2KSk7XG5cdFx0fTtcblx0XHRyZXR1cm47XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBmbGF0dGVuX18oYXJ5LGNvbXBhY3Qpe1xuXHRcdGlmKGNvbXBhY3QgPT09IHVuZGVmaW5lZCkgY29tcGFjdCA9IGZhbHNlO1xuXHRcdHZhciBvdXQgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMCwgaXRlbXMgPSBpdGVyJChhcnkpLCBsZW4gPSBpdGVtcy5sZW5ndGgsIHY7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0diA9IGl0ZW1zW2ldO1xuXHRcdFx0diBpbnN0YW5jZW9mIEFycmF5ID8gKHJlZHVjZV9fKG91dCx2KSkgOiAob3V0LnB1c2godikpO1xuXHRcdH07XG5cdFx0cmV0dXJuIG91dDtcblx0fTtcblx0XG5cdEFTVC5wYXJzZSA9IGZ1bmN0aW9uIChzdHIsb3B0cyl7XG5cdFx0aWYob3B0cyA9PT0gdW5kZWZpbmVkKSBvcHRzID0ge307XG5cdFx0dmFyIGluZGVudCA9IHN0ci5tYXRjaCgvXFx0Ky8pWzBdO1xuXHRcdC8vIHJlYWxseT8gUmVxdWlyZSB0aGUgY29tcGlsZXIsIG5vdCB0aGlzXG5cdFx0cmV0dXJuIEltYmFjLnBhcnNlKHN0cixvcHRzKTtcblx0fTtcblx0XG5cdEFTVC5pbmxpbmUgPSBmdW5jdGlvbiAoc3RyLG9wdHMpe1xuXHRcdGlmKG9wdHMgPT09IHVuZGVmaW5lZCkgb3B0cyA9IHt9O1xuXHRcdHJldHVybiB0aGlzLnBhcnNlKHN0cixvcHRzKS5ib2R5KCk7XG5cdH07XG5cdFxuXHRBU1Qubm9kZSA9IGZ1bmN0aW9uICh0eXAscGFycyl7XG5cdFx0aWYgKHR5cCA9PSAnY2FsbCcpIHtcblx0XHRcdGlmIChwYXJzWzBdLmMoKSA9PSAncmV0dXJuJykge1xuXHRcdFx0XHRwYXJzWzBdID0gJ3RhdGEnO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiBuZXcgQ2FsbChwYXJzWzBdLHBhcnNbMV0scGFyc1syXSk7XG5cdFx0fTtcblx0fTtcblx0XG5cdFxuXHRBU1QuZXNjYXBlQ29tbWVudHMgPSBmdW5jdGlvbiAoc3RyKXtcblx0XHRpZiAoIXN0cikgeyByZXR1cm4gJycgfTtcblx0XHRyZXR1cm4gc3RyO1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gSW5kZW50YXRpb24oYSxiKXtcblx0XHR0aGlzLl9vcGVuID0gYTtcblx0XHR0aGlzLl9jbG9zZSA9IGI7XG5cdFx0dGhpcztcblx0fTtcblx0XG5cdGV4cG9ydHMuSW5kZW50YXRpb24gPSBJbmRlbnRhdGlvbjsgLy8gZXhwb3J0IGNsYXNzIFxuXHRJbmRlbnRhdGlvbi5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fb3BlbjsgfVxuXHRJbmRlbnRhdGlvbi5wcm90b3R5cGUuc2V0T3BlbiA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9vcGVuID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdEluZGVudGF0aW9uLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fY2xvc2U7IH1cblx0SW5kZW50YXRpb24ucHJvdG90eXBlLnNldENsb3NlID0gZnVuY3Rpb24odil7IHRoaXMuX2Nsb3NlID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRJbmRlbnRhdGlvbi5wcm90b3R5cGUuaXNHZW5lcmF0ZWQgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fb3BlbiAmJiB0aGlzLl9vcGVuLmdlbmVyYXRlZDtcblx0fTtcblx0XG5cdEluZGVudGF0aW9uLnByb3RvdHlwZS5hbG9jID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX29wZW4gJiYgdGhpcy5fb3Blbi5fbG9jIHx8IDA7XG5cdH07XG5cdFxuXHRJbmRlbnRhdGlvbi5wcm90b3R5cGUuYmxvYyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9jbG9zZSAmJiB0aGlzLl9jbG9zZS5fbG9jIHx8IDA7XG5cdH07XG5cdFxuXHQvLyBzaG91bGQgcmF0aGVyIHBhcnNlIGFuZCBleHRyYWN0IHRoZSBjb21tZW50cywgbm8/XG5cdEluZGVudGF0aW9uLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cil7XG5cdFx0Ly8gdmFyIHByZSwgcG9zdFxuXHRcdFxuXHRcdC8vIGNvbnNvbGUubG9nIFwiSU5ERU5UIHtAb3BlbiBhbmQgSlNPTi5zdHJpbmdpZnkoQG9wZW4uQG1ldGEpfVwiXG5cdFx0Ly8gY29uc29sZS5sb2cgXCJPVVRERU5UIHtAY2xvc2V9XCJcblx0XHQvLyB2YXIgb3YgPSBAb3BlbiBhbmQgQG9wZW4uQHZhbHVlXG5cdFx0Ly8gaWYgb3YgYW5kIG92Omxlbmd0aCA+IDFcblx0XHQvLyBcdGNvbnNvbGUubG9nIFwidmFsdWUgZm9yIGluZGVudFwiLG92XG5cdFx0Ly8gXHRpZiBvdi5pbmRleE9mKCclfCUnKVxuXHRcdC8vIFx0XHRwcmUgPSBvdi5zdWJzdHJcblx0XHR2YXIgb20gPSB0aGlzLl9vcGVuICYmIHRoaXMuX29wZW4uX21ldGE7XG5cdFx0dmFyIHByZSA9IG9tICYmIG9tLnByZSB8fCAnJztcblx0XHR2YXIgcG9zdCA9IG9tICYmIG9tLnBvc3QgfHwgJyc7XG5cdFx0dmFyIGVzYyA9IEFTVC5lc2NhcGVDb21tZW50cztcblx0XHR2YXIgb3V0ID0gdGhpcy5fY2xvc2U7XG5cdFx0XG5cdFx0Ly8gdGhlIGZpcnN0IG5ld2xpbmUgc2hvdWxkIG5vdCBiZSBpbmRlbnRlZD9cblx0XHRzdHIgPSBwb3N0LnJlcGxhY2UoL15cXG4vLCcnKSArIHN0cjtcblx0XHRzdHIgPSBzdHIucmVwbGFjZSgvXi9nLFwiXFx0XCIpLnJlcGxhY2UoL1xcbi9nLFwiXFxuXFx0XCIpLnJlcGxhY2UoL1xcblxcdCQvZyxcIlxcblwiKTtcblx0XHRcblx0XHRzdHIgPSBwcmUgKyAnXFxuJyArIHN0cjtcblx0XHRpZiAob3V0IGluc3RhbmNlb2YgVGVybWluYXRvcikgeyBzdHIgKz0gb3V0LmMoKSB9O1xuXHRcdGlmIChzdHJbc3RyLmxlbmd0aCAtIDFdICE9ICdcXG4nKSB7IHN0ciA9IHN0ciArICdcXG4nIH07XG5cdFx0cmV0dXJuIHN0cjtcblx0fTtcblx0XG5cdHZhciBJTkRFTlQgPSBuZXcgSW5kZW50YXRpb24oe30se30pO1xuXHRcblx0ZnVuY3Rpb24gU3Rhc2goKXtcblx0XHR0aGlzLl9lbnRpdGllcyA9IFtdO1xuXHR9O1xuXHRcblx0U3Rhc2gucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChpdGVtKXtcblx0XHR0aGlzLl9lbnRpdGllcy51bnNoaWZ0KGl0ZW0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0U3Rhc2gucHJvdG90eXBlLnBsdWNrID0gZnVuY3Rpb24gKGl0ZW0pe1xuXHRcdHZhciBtYXRjaCA9IG51bGw7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHRoaXMuX2VudGl0aWVzKSwgbGVuID0gYXJ5Lmxlbmd0aCwgZW50aXR5OyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGVudGl0eSA9IGFyeVtpXTtcblx0XHRcdGlmIChlbnRpdHkgPT0gaXRlbSB8fCAoZW50aXR5IGluc3RhbmNlb2YgaXRlbSkpIHtcblx0XHRcdFx0bWF0Y2ggPSBlbnRpdHk7XG5cdFx0XHRcdHRoaXMuX2VudGl0aWVzLnNwbGljZShpLDEpO1xuXHRcdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cdFxuXHRcblx0ZnVuY3Rpb24gU3RhY2soKXtcblx0XHR0aGlzLnJlc2V0KCk7XG5cdH07XG5cdFxuXHRleHBvcnRzLlN0YWNrID0gU3RhY2s7IC8vIGV4cG9ydCBjbGFzcyBcblx0U3RhY2sucHJvdG90eXBlLmxvZ2xldmVsID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9sb2dsZXZlbDsgfVxuXHRTdGFjay5wcm90b3R5cGUuc2V0TG9nbGV2ZWwgPSBmdW5jdGlvbih2KXsgdGhpcy5fbG9nbGV2ZWwgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0U3RhY2sucHJvdG90eXBlLm5vZGVzID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9ub2RlczsgfVxuXHRTdGFjay5wcm90b3R5cGUuc2V0Tm9kZXMgPSBmdW5jdGlvbih2KXsgdGhpcy5fbm9kZXMgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0U3RhY2sucHJvdG90eXBlLnNjb3BlcyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fc2NvcGVzOyB9XG5cdFN0YWNrLnByb3RvdHlwZS5zZXRTY29wZXMgPSBmdW5jdGlvbih2KXsgdGhpcy5fc2NvcGVzID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRTdGFjay5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKXtcblx0XHR0aGlzLl9ub2RlcyA9IFtdO1xuXHRcdHRoaXMuX3Njb3BpbmcgPSBbXTtcblx0XHR0aGlzLl9zY29wZXMgPSBbXTsgLy8gZm9yIGFuYWx5c2lzIC0gc2hvdWxkIHJlbmFtZVxuXHRcdHRoaXMuX3N0YXNoID0gbmV3IFN0YXNoKHRoaXMpO1xuXHRcdHRoaXMuX2xvZ2xldmVsID0gMztcblx0XHR0aGlzLl9jb3VudGVyID0gMDtcblx0XHR0aGlzLl9jb3VudGVycyA9IHt9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0U3RhY2sucHJvdG90eXBlLmluY3IgPSBmdW5jdGlvbiAobmFtZSl7XG5cdFx0dmFyICQxO1xuXHRcdHRoaXMuX2NvdW50ZXJzWygkMSA9IG5hbWUpXSB8fCAodGhpcy5fY291bnRlcnNbJDFdID0gMCk7XG5cdFx0cmV0dXJuIHRoaXMuX2NvdW50ZXJzW25hbWVdICs9IDE7XG5cdH07XG5cdFxuXHRTdGFjay5wcm90b3R5cGUuc3Rhc2ggPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fc3Rhc2g7XG5cdH07XG5cdFxuXHRTdGFjay5wcm90b3R5cGUub3B0aW9uID0gZnVuY3Rpb24gKGtleSl7XG5cdFx0cmV0dXJuIHRoaXMuX29wdGlvbnMgJiYgdGhpcy5fb3B0aW9uc1trZXldO1xuXHR9O1xuXHRcblx0U3RhY2sucHJvdG90eXBlLmFkZFNjb3BlID0gZnVuY3Rpb24gKHNjb3BlKXtcblx0XHR0aGlzLl9zY29wZXMucHVzaChzY29wZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRTdGFjay5wcm90b3R5cGUudHJhdmVyc2UgPSBmdW5jdGlvbiAobm9kZSl7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRTdGFjay5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChub2RlKXtcblx0XHR0aGlzLl9ub2Rlcy5wdXNoKG5vZGUpO1xuXHRcdC8vIG5vdCBzdXJlIGlmIHdlIGhhdmUgYWxyZWFkeSBkZWZpbmVkIGEgc2NvcGU/XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRTdGFjay5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gKG5vZGUpe1xuXHRcdHRoaXMuX25vZGVzLnBvcCgpOyAvLyAobm9kZSlcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFN0YWNrLnByb3RvdHlwZS5wYXJlbnQgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fbm9kZXNbdGhpcy5fbm9kZXMubGVuZ3RoIC0gMl07XG5cdH07XG5cdFxuXHRTdGFjay5wcm90b3R5cGUuY3VycmVudCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9ub2Rlc1t0aGlzLl9ub2Rlcy5sZW5ndGggLSAxXTtcblx0fTtcblx0XG5cdFN0YWNrLnByb3RvdHlwZS51cCA9IGZ1bmN0aW9uICh0ZXN0KXtcblx0XHR0ZXN0IHx8ICh0ZXN0ID0gZnVuY3Rpb24odikgeyByZXR1cm4gISh2IGluc3RhbmNlb2YgVmFyT3JBY2Nlc3MpOyB9KTtcblx0XHRcblx0XHRpZiAodGVzdC5wcm90b3R5cGUgaW5zdGFuY2VvZiBOb2RlKSB7XG5cdFx0XHR2YXIgdHlwID0gdGVzdDtcblx0XHRcdHRlc3QgPSBmdW5jdGlvbih2KSB7IHJldHVybiB2IGluc3RhbmNlb2YgdHlwOyB9O1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIGkgPSB0aGlzLl9ub2Rlcy5sZW5ndGggLSAyOyAvLyBrZXlcblx0XHR3aGlsZSAoaSA+PSAwKXtcblx0XHRcdHZhciBub2RlID0gdGhpcy5fbm9kZXNbaV07XG5cdFx0XHRpZiAodGVzdChub2RlKSkgeyByZXR1cm4gbm9kZSB9O1xuXHRcdFx0aSAtPSAxO1xuXHRcdH07XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cdFxuXHRTdGFjay5wcm90b3R5cGUucmVsYXRpdmUgPSBmdW5jdGlvbiAobm9kZSxvZmZzZXQpe1xuXHRcdGlmKG9mZnNldCA9PT0gdW5kZWZpbmVkKSBvZmZzZXQgPSAwO1xuXHRcdHZhciBpZHggPSB0aGlzLl9ub2Rlcy5pbmRleE9mKG5vZGUpO1xuXHRcdHJldHVybiBpZHggPj0gMCA/ICh0aGlzLl9ub2Rlc1tpZHggKyBvZmZzZXRdKSA6IChudWxsKTtcblx0fTtcblx0XG5cdFN0YWNrLnByb3RvdHlwZS5zY29wZSA9IGZ1bmN0aW9uIChsdmwpe1xuXHRcdGlmKGx2bCA9PT0gdW5kZWZpbmVkKSBsdmwgPSAwO1xuXHRcdHZhciBpID0gdGhpcy5fbm9kZXMubGVuZ3RoIC0gMSAtIGx2bDtcblx0XHR3aGlsZSAoaSA+PSAwKXtcblx0XHRcdHZhciBub2RlID0gdGhpcy5fbm9kZXNbaV07XG5cdFx0XHRpZiAobm9kZS5fc2NvcGUpIHsgcmV0dXJuIG5vZGUuX3Njb3BlIH07XG5cdFx0XHRpIC09IDE7XG5cdFx0fTtcblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblx0XG5cdFN0YWNrLnByb3RvdHlwZS5zY29wZXMgPSBmdW5jdGlvbiAoKXtcblx0XHQvLyBpbmNsdWRlIGRlZXBlciBzY29wZXMgYXMgd2VsbD9cblx0XHR2YXIgc2NvcGVzID0gW107XG5cdFx0dmFyIGkgPSB0aGlzLl9ub2Rlcy5sZW5ndGggLSAxO1xuXHRcdHdoaWxlIChpID49IDApe1xuXHRcdFx0dmFyIG5vZGUgPSB0aGlzLl9ub2Rlc1tpXTtcblx0XHRcdGlmIChub2RlLl9zY29wZSkgeyBzY29wZXMucHVzaChub2RlLl9zY29wZSkgfTtcblx0XHRcdGkgLT0gMTtcblx0XHR9O1xuXHRcdHJldHVybiBzY29wZXM7XG5cdH07XG5cdFxuXHRTdGFjay5wcm90b3R5cGUubWV0aG9kID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMudXAoTWV0aG9kRGVjbGFyYXRpb24pO1xuXHR9O1xuXHRcblx0U3RhY2sucHJvdG90eXBlLmJsb2NrID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMudXAoQmxvY2spO1xuXHR9O1xuXHRcblx0U3RhY2sucHJvdG90eXBlLmlzRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBpID0gdGhpcy5fbm9kZXMubGVuZ3RoIC0gMTtcblx0XHR3aGlsZSAoaSA+PSAwKXtcblx0XHRcdHZhciBub2RlID0gdGhpcy5fbm9kZXNbaV07XG5cdFx0XHQvLyB3aHkgYXJlIHdlIG5vdCB1c2luZyBpc0V4cHJlc3Npb24gaGVyZSBhcyB3ZWxsP1xuXHRcdFx0aWYgKChub2RlIGluc3RhbmNlb2YgQ29kZSkgfHwgKG5vZGUgaW5zdGFuY2VvZiBMb29wKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdFx0aWYgKG5vZGUuaXNFeHByZXNzaW9uKCkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9O1xuXHRcdFx0Ly8gcHJvYmFibHkgbm90IHRoZSByaWdodCB0ZXN0IC0gbmVlZCB0byBiZSBtb3JlIGV4cGxpY2l0XG5cdFx0XHRpIC09IDE7XG5cdFx0fTtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cdFxuXHRTdGFjay5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gKFwiU3RhY2soXCIgKyB0aGlzLl9ub2Rlcy5qb2luKFwiIC0+IFwiKSArIFwiKVwiKTtcblx0fTtcblx0XG5cdFN0YWNrLnByb3RvdHlwZS5zY29waW5nID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX25vZGVzLmZpbHRlcihmdW5jdGlvbihuKSB7IHJldHVybiBuLl9zY29wZTsgfSkubWFwKGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4uX3Njb3BlOyB9KTtcblx0fTtcblx0XG5cdC8vIExvdHMgb2YgZ2xvYmFscyAtLSByZWFsbHkgbmVlZCB0byBkZWFsIHdpdGggb25lIHN0YWNrIHBlciBmaWxlIC8gY29udGV4dFxuXHRtb2R1bGUuZXhwb3J0cy5TVEFDSyA9IFNUQUNLID0gbmV3IFN0YWNrKCk7XG5cdFxuXHRHTE9CU1RBQ0sgPSBTVEFDSztcblx0XG5cdC8vIHVzZSBhIGJpdG1hc2sgZm9yIHRoZXNlXG5cdFxuXHRmdW5jdGlvbiBOb2RlKCl7XG5cdFx0dGhpcy5zZXR1cCgpO1xuXHRcdHRoaXM7XG5cdH07XG5cdFxuXHRleHBvcnRzLk5vZGUgPSBOb2RlOyAvLyBleHBvcnQgY2xhc3MgXG5cdE5vZGUucHJvdG90eXBlLm8gPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX287IH1cblx0Tm9kZS5wcm90b3R5cGUuc2V0TyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9vID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdE5vZGUucHJvdG90eXBlLm9wdGlvbnMgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX29wdGlvbnM7IH1cblx0Tm9kZS5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9vcHRpb25zID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdE5vZGUucHJvdG90eXBlLnRyYXZlcnNlZCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fdHJhdmVyc2VkOyB9XG5cdE5vZGUucHJvdG90eXBlLnNldFRyYXZlcnNlZCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl90cmF2ZXJzZWQgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdE5vZGUucHJvdG90eXBlLnNhZmVjaGFpbiA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblx0XG5cdC8vIGRlZiBkb21cblx0Ly8gXHR2YXIgbmFtZSA9IFwiYXN0X1wiICsgc2VsZjpjb25zdHJ1Y3RvcjpuYW1lLnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csXCIkMV8kMlwiKS50b0xvd2VyQ2FzZVxuXHQvLyBcdCMgcCBcInRyeSB0byBnZXQgdGhlIGRvbS1ub2RlIGZvciB0aGlzIGFzdC1ub2RlXCIsbmFtZVxuXHQvLyBcdGlmIEltYmEuVEFHU1tuYW1lXVxuXHQvLyBcdFx0dmFyIG5vZGUgPSBJbWJhLnRhZyhuYW1lKVxuXHQvLyBcdFx0bm9kZS5iaW5kKHNlbGYpLmJ1aWxkXG5cdC8vIFx0XHRyZXR1cm4gbm9kZVxuXHQvLyBcdGVsc2Vcblx0Ly8gXHRcdHJldHVybiBcIlt7bmFtZX1dXCJcblx0XG5cdE5vZGUucHJvdG90eXBlLnAgPSBmdW5jdGlvbiAoKXtcblx0XHRcblx0XHQvLyBhbGxvdyBjb250cm9sbGluZyB0aGlzIGZyb20gY29tbWFuZGxpbmVcblx0XHRpZiAoU1RBQ0subG9nbGV2ZWwoKSA+IDApIHtcblx0XHRcdGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsYXJndW1lbnRzKTtcblx0XHR9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Tm9kZS5wcm90b3R5cGUudHlwZU5hbWUgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuXHR9O1xuXHRcblx0Tm9kZS5wcm90b3R5cGUubmFtZXBhdGggPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy50eXBlTmFtZSgpO1xuXHR9O1xuXHRcblx0Tm9kZS5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbiAoKXtcblx0XHR0aGlzLl9leHByZXNzaW9uID0gZmFsc2U7XG5cdFx0dGhpcy5fdHJhdmVyc2VkID0gZmFsc2U7XG5cdFx0dGhpcy5fcGFyZW5zID0gZmFsc2U7XG5cdFx0dGhpcy5fY2FjaGUgPSBudWxsO1xuXHRcdHRoaXMuX3ZhbHVlID0gbnVsbDtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdE5vZGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChvYmope1xuXHRcdC8vIGNvbnNvbGUubG9nIFwic2V0dGluZyBvcHRpb25zIHtKU09OLnN0cmluZ2lmeShvYmopfVwiXG5cdFx0dGhpcy5fb3B0aW9ucyB8fCAodGhpcy5fb3B0aW9ucyA9IHt9KTtcblx0XHRmb3IgKHZhciBpID0gMCwga2V5cyA9IE9iamVjdC5rZXlzKG9iaiksIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKyl7XG5cdFx0XHR0aGlzLl9vcHRpb25zW2tleXNbaV1dID0gb2JqW2tleXNbaV1dO1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvLyBnZXQgYW5kIHNldFxuXHROb2RlLnByb3RvdHlwZS5vcHRpb24gPSBmdW5jdGlvbiAoa2V5LHZhbCl7XG5cdFx0aWYgKHZhbCAhPSB1bmRlZmluZWQpIHtcblx0XHRcdC8vIGNvbnNvbGUubG9nIFwic2V0dGluZyBvcHRpb24ge2tleX0ge3ZhbH1cIlxuXHRcdFx0dGhpcy5fb3B0aW9ucyB8fCAodGhpcy5fb3B0aW9ucyA9IHt9KTtcblx0XHRcdHRoaXMuX29wdGlvbnNba2V5XSA9IHZhbDtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXMuX29wdGlvbnMgJiYgdGhpcy5fb3B0aW9uc1trZXldO1xuXHR9O1xuXHRcblx0Tm9kZS5wcm90b3R5cGUuY29uZmlndXJlID0gZnVuY3Rpb24gKG9iail7XG5cdFx0cmV0dXJuIHRoaXMuc2V0KG9iaik7XG5cdH07XG5cdFxuXHROb2RlLnByb3RvdHlwZS5yZWdpb24gPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gWzAsMF07XG5cdH07XG5cdFxuXHROb2RlLnByb3RvdHlwZS5sb2MgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gWzAsMF07XG5cdH07XG5cdFxuXHROb2RlLnByb3RvdHlwZS50b2tlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXHRcblx0Tm9kZS5wcm90b3R5cGUuY29tcGlsZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Tm9kZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdE5vZGUucHJvdG90eXBlLnN0YWNrID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIFNUQUNLO1xuXHR9O1xuXHRcblx0Tm9kZS5wcm90b3R5cGUuaXNTdHJpbmcgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cdFxuXHROb2RlLnByb3RvdHlwZS5pc1ByaW1pdGl2ZSA9IGZ1bmN0aW9uIChkZWVwKXtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cdFxuXHROb2RlLnByb3RvdHlwZS5pc1Jlc2VydmVkID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXHRcblx0Ly8gc2hvdWxkIHJhdGhlciBkbyB0cmF2ZXJzYWxzXG5cdC8vIG8gPSB7fSwgdXAsIGtleSwgaW5kZXhcblx0Tm9kZS5wcm90b3R5cGUudHJhdmVyc2UgPSBmdW5jdGlvbiAoKXtcblx0XHRpZiAodGhpcy5fdHJhdmVyc2VkKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdC8vIE5PREVTLnB1c2goc2VsZilcblx0XHR0aGlzLl90cmF2ZXJzZWQgPSB0cnVlO1xuXHRcdFNUQUNLLnB1c2godGhpcyk7XG5cdFx0dGhpcy52aXNpdChTVEFDSyk7XG5cdFx0U1RBQ0sucG9wKHRoaXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Tm9kZS5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB7dHlwZTogdGhpcy5jb25zdHJ1Y3Rvci50b1N0cmluZygpfTtcblx0fTtcblx0XG5cdE5vZGUucHJvdG90eXBlLmpzID0gZnVuY3Rpb24gKG8pe1xuXHRcdHJldHVybiBcIk5PREVcIjtcblx0fTtcblx0XG5cdE5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIChcIlwiICsgKHRoaXMuY29uc3RydWN0b3IubmFtZSkpO1xuXHR9O1xuXHRcblx0Ly8gc3dhbGxvdyBtaWdodCBiZSBiZXR0ZXIgbmFtZVxuXHROb2RlLnByb3RvdHlwZS5jb25zdW1lID0gZnVuY3Rpb24gKG5vZGUpe1xuXHRcdGlmIChub2RlIGluc3RhbmNlb2YgUHVzaEFzc2lnbikge1xuXHRcdFx0cmV0dXJuIG5ldyBQdXNoQXNzaWduKG5vZGUub3AoKSxub2RlLmxlZnQoKSx0aGlzKTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmIChub2RlIGluc3RhbmNlb2YgQXNzaWduKSB7XG5cdFx0XHQvLyBwIFwiY29uc3VtZSBhc3NpZ25tZW50XCIuY3lhblxuXHRcdFx0Ly8gbm9kZS5yaWdodCA9IHNlbGZcblx0XHRcdHJldHVybiBPUChub2RlLm9wKCksbm9kZS5sZWZ0KCksdGhpcyk7XG5cdFx0fSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgT3ApIHtcblx0XHRcdHJldHVybiBPUChub2RlLm9wKCksbm9kZS5sZWZ0KCksdGhpcyk7XG5cdFx0fSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgUmV0dXJuKSB7XG5cdFx0XHQvLyBwIFwiY29uc3VtZSByZXR1cm5cIi5jeWFuXG5cdFx0XHRyZXR1cm4gbmV3IFJldHVybih0aGlzKTtcblx0XHR9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Tm9kZS5wcm90b3R5cGUudG9FeHByZXNzaW9uID0gZnVuY3Rpb24gKCl7XG5cdFx0dGhpcy5fZXhwcmVzc2lvbiA9IHRydWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHROb2RlLnByb3RvdHlwZS5mb3JjZUV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKXtcblx0XHR0aGlzLl9leHByZXNzaW9uID0gdHJ1ZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdE5vZGUucHJvdG90eXBlLmlzRXhwcmVzc2FibGUgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblx0XG5cdE5vZGUucHJvdG90eXBlLmlzRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9leHByZXNzaW9uIHx8IGZhbHNlO1xuXHR9O1xuXHRcblx0Tm9kZS5wcm90b3R5cGUuaGFzU2lkZUVmZmVjdHMgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblx0XG5cdE5vZGUucHJvdG90eXBlLmlzVXNlZCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXHRcblx0Tm9kZS5wcm90b3R5cGUuc2hvdWxkUGFyZW50aGVzaXplID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXHRcblx0Tm9kZS5wcm90b3R5cGUuYmxvY2sgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gQmxvY2sud3JhcChbdGhpc10pO1xuXHR9O1xuXHRcblx0Tm9kZS5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Tm9kZS5wcm90b3R5cGUuc2NvcGVfXyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiBTVEFDSy5zY29wZSgpO1xuXHR9O1xuXHRcblx0Tm9kZS5wcm90b3R5cGUudXAgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gU1RBQ0sucGFyZW50KCk7XG5cdH07XG5cdFxuXHROb2RlLnByb3RvdHlwZS51dGlsID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIFV0aWw7XG5cdH07XG5cdFxuXHROb2RlLnByb3RvdHlwZS5yZWNlaXZlciA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Tm9kZS5wcm90b3R5cGUuYWRkRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChleHByKXtcblx0XHQvLyBtaWdodCBiZSBiZXR0ZXIgdG8gbmVzdCB0aGlzIHVwIGFmdGVyIHBhcnNpbmcgaXMgZG9uZT9cblx0XHQvLyBwIFwiYWRkRXhwcmVzc2lvbiB7c2VsZn0gPC0ge2V4cHJ9XCJcblx0XHR2YXIgbm9kZSA9IG5ldyBFeHByZXNzaW9uQmxvY2soW3RoaXNdKTtcblx0XHRyZXR1cm4gbm9kZS5hZGRFeHByZXNzaW9uKGV4cHIpO1xuXHR9O1xuXHRcblx0XG5cdE5vZGUucHJvdG90eXBlLmluZGVudGVkID0gZnVuY3Rpb24gKGEsYil7XG5cdFx0XG5cdFx0aWYgKGEgaW5zdGFuY2VvZiBJbmRlbnRhdGlvbikge1xuXHRcdFx0dGhpcy5faW5kZW50YXRpb24gPSBhO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHQvLyB0aGlzIGlzIGEgX0JJR18gaGFja1xuXHRcdGlmIChiIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdHRoaXMuYWRkKGJbMF0pO1xuXHRcdFx0YiA9IGJbMV07XG5cdFx0fTtcblx0XHRcblx0XHQvLyBpZiBpbmRlbnQgYW5kIGluZGVudC5tYXRjaCgvXFw6Lylcblx0XHR0aGlzLl9pbmRlbnRhdGlvbiB8fCAodGhpcy5faW5kZW50YXRpb24gPSBhICYmIGIgPyAobmV3IEluZGVudGF0aW9uKGEsYikpIDogKElOREVOVCkpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Tm9kZS5wcm90b3R5cGUucHJlYnJlYWsgPSBmdW5jdGlvbiAodGVybSl7XG5cdFx0Ly8gaW4gb3B0aW9ucyBpbnN0ZWFkP1xuXHRcdC8vIGNvbnNvbGUubG9nIFwicHJlYnJlYWshISEhXCJcblx0XHQvLyBAcHJlYnJlYWsgPSBAcHJlYnJlYWsgb3IgdGVybVxuXHRcdGlmKHRlcm0gPT09IHVuZGVmaW5lZCkgdGVybSA9ICdcXG4nO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Tm9kZS5wcm90b3R5cGUuaW52ZXJ0ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIE9QKCchJyx0aGlzKTtcblx0fTtcblx0XG5cdE5vZGUucHJvdG90eXBlLmNhY2hlID0gZnVuY3Rpb24gKG8pe1xuXHRcdGlmKG8gPT09IHVuZGVmaW5lZCkgbyA9IHt9O1xuXHRcdHRoaXMuX2NhY2hlID0gbztcblx0XHRvLnZhciA9IHRoaXMuc2NvcGVfXygpLnRlbXBvcmFyeSh0aGlzLG8pO1xuXHRcdG8ubG9va3VwcyA9IDA7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHROb2RlLnByb3RvdHlwZS5jYWNoZXZhciA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9jYWNoZSAmJiB0aGlzLl9jYWNoZS52YXI7XG5cdH07XG5cdFxuXHROb2RlLnByb3RvdHlwZS5kZWNhY2hlID0gZnVuY3Rpb24gKCl7XG5cdFx0aWYgKHRoaXMuX2NhY2hlKSB7XG5cdFx0XHR0aGlzLmNhY2hldmFyKCkuZnJlZSgpO1xuXHRcdFx0dGhpcy5fY2FjaGUgPSBudWxsO1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvLyBpcyB0aGlzIHdpdGhvdXQgc2lkZS1lZmZlY3RzPyBobW0gLSB3aGF0IGRvZXMgaXQgZXZlbiBkbz9cblx0Tm9kZS5wcm90b3R5cGUucHJlZGVjbGFyZSA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmICh0aGlzLl9jYWNoZSkge1xuXHRcdFx0dGhpcy5zY29wZV9fKCkudmFycygpLnN3YXAodGhpcy5fY2FjaGUudmFyLHRoaXMpO1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvLyB0aGUgXCJuYW1lLXN1Z2dlc3Rpb25cIiBmb3Igbm9kZXMgaWYgdGhleSBuZWVkIHRvIGJlIGNhY2hlZFxuXHROb2RlLnByb3RvdHlwZS5hbGlhcyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXHRcblx0Tm9kZS5wcm90b3R5cGUud2FybiA9IGZ1bmN0aW9uICh0ZXh0LG9wdHMpe1xuXHRcdGlmKG9wdHMgPT09IHVuZGVmaW5lZCkgb3B0cyA9IHt9O1xuXHRcdG9wdHMubWVzc2FnZSA9IHRleHQ7XG5cdFx0b3B0cy5sb2MgfHwgKG9wdHMubG9jID0gdGhpcy5sb2MoKSk7XG5cdFx0dGhpcy5zY29wZV9fKCkucm9vdCgpLndhcm4ob3B0cyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHROb2RlLnByb3RvdHlwZS5jID0gZnVuY3Rpb24gKG8pe1xuXHRcdHZhciBpbmRlbnQ7XG5cdFx0dmFyIHMgPSBTVEFDSztcblx0XHR2YXIgY2ggPSB0aGlzLl9jYWNoZTtcblx0XHRpZiAoY2ggJiYgY2guY2FjaGVkKSB7IHJldHVybiB0aGlzLmNfY2FjaGVkKGNoKSB9O1xuXHRcdFxuXHRcdHMucHVzaCh0aGlzKTtcblx0XHRpZiAobyAmJiBvLmV4cHJlc3Npb24pIHRoaXMuZm9yY2VFeHByZXNzaW9uKCk7XG5cdFx0XG5cdFx0djggJiYgY29uc29sZS5sb2codjguaGFzRmFzdE9iamVjdEVsZW1lbnRzKHRoaXMpKTtcblx0XHRcblx0XHRpZiAobyAmJiBvLmluZGVudCkge1xuXHRcdFx0dGhpcy5faW5kZW50YXRpb24gfHwgKHRoaXMuX2luZGVudGF0aW9uID0gSU5ERU5UKTtcblx0XHR9O1xuXHRcdFxuXHRcdHZhciBvdXQgPSB0aGlzLmpzKHMsbyk7XG5cdFx0XG5cdFx0Ly8gcmVhbGx5PyB3aHkgbm90IGNhbGwgdGhpcyBzb21ld2hlcmUgZWxzZT9cblx0XHR2YXIgcGFyZW4gPSB0aGlzLnNob3VsZFBhcmVudGhlc2l6ZSgpO1xuXHRcdFxuXHRcdGlmIChpbmRlbnQgPSB0aGlzLl9pbmRlbnRhdGlvbikge1xuXHRcdFx0b3V0ID0gaW5kZW50LndyYXAob3V0LG8pO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gc2hvdWxkIG1vdmUgdGhpcyBzb21ld2hlcmUgZWxzZSByZWFsbHlcblx0XHRpZiAocGFyZW4pIHsgb3V0ID0gKFwiKFwiICsgb3V0ICsgXCIpXCIpIH07XG5cdFx0aWYgKG8gJiYgby5icmFjZXMpIHtcblx0XHRcdGlmIChpbmRlbnQpIHtcblx0XHRcdFx0b3V0ID0gJ3snICsgb3V0ICsgJ30nO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0ID0gJ3sgJyArIG91dCArICcgfSc7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0cy5wb3AodGhpcyk7XG5cdFx0XG5cdFx0aWYgKGNoID0gdGhpcy5fY2FjaGUpIHtcblx0XHRcdGlmICghY2gubWFudWFsKSB7IG91dCA9IChcIlwiICsgKGNoLnZhci5jKCkpICsgXCIgPSBcIiArIG91dCkgfTtcblx0XHRcdHZhciBwYXIgPSBzLmN1cnJlbnQoKTtcblx0XHRcdGlmICgocGFyIGluc3RhbmNlb2YgQWNjZXNzKSB8fCAocGFyIGluc3RhbmNlb2YgT3ApKSB7IG91dCA9ICcoJyArIG91dCArICcpJyB9OyAvLyBvdGhlcnM/ICMgXG5cdFx0XHRjaC5jYWNoZWQgPSB0cnVlO1xuXHRcdH07XG5cdFx0cmV0dXJuIG91dDtcblx0fTtcblx0XG5cdE5vZGUucHJvdG90eXBlLmNfY2FjaGVkID0gZnVuY3Rpb24gKGNhY2hlKXtcblx0XHRjYWNoZS5sb29rdXBzKys7XG5cdFx0aWYgKGNhY2hlLnVzZXMgPT0gY2FjaGUubG9va3VwcykgeyBjYWNoZS52YXIuZnJlZSgpIH07XG5cdFx0cmV0dXJuIGNhY2hlLnZhci5jKCk7IC8vIHJlY29tcGlsZSBldmVyeSB0aW1lPz9cblx0fTtcblx0XG5cdGZ1bmN0aW9uIFZhbHVlTm9kZSh2YWx1ZSl7XG5cdFx0dGhpcy5zZXR1cCgpO1xuXHRcdHRoaXMuX3ZhbHVlID0gdGhpcy5sb2FkKHZhbHVlKTtcblx0fTtcblx0XG5cdHN1YmNsYXNzJChWYWx1ZU5vZGUsTm9kZSk7XG5cdGV4cG9ydHMuVmFsdWVOb2RlID0gVmFsdWVOb2RlOyAvLyBleHBvcnQgY2xhc3MgXG5cdFZhbHVlTm9kZS5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3ZhbHVlOyB9XG5cdFZhbHVlTm9kZS5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbih2KXsgdGhpcy5fdmFsdWUgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFZhbHVlTm9kZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICh2YWx1ZSl7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9O1xuXHRcblx0VmFsdWVOb2RlLnByb3RvdHlwZS5qcyA9IGZ1bmN0aW9uIChvKXtcblx0XHRyZXR1cm4gdHlwZW9mIHRoaXMuX3ZhbHVlID09ICdzdHJpbmcnID8gKHRoaXMuX3ZhbHVlKSA6ICh0aGlzLl92YWx1ZS5jKCkpO1xuXHR9O1xuXHRcblx0VmFsdWVOb2RlLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICgpe1xuXHRcdFxuXHRcdGlmICh0aGlzLl92YWx1ZSBpbnN0YW5jZW9mIE5vZGUpIHsgdGhpcy5fdmFsdWUudHJhdmVyc2UoKSB9OyAvLyAgJiYgQHZhbHVlOnRyYXZlcnNlXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRWYWx1ZU5vZGUucHJvdG90eXBlLnJlZ2lvbiA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiBbdGhpcy5fdmFsdWUuX2xvYyx0aGlzLl92YWx1ZS5fbG9jICsgdGhpcy5fdmFsdWUuX2xlbl07XG5cdH07XG5cdFxuXHRcblx0ZnVuY3Rpb24gU3RhdGVtZW50KCl7IHJldHVybiBWYWx1ZU5vZGUuYXBwbHkodGhpcyxhcmd1bWVudHMpIH07XG5cdFxuXHRzdWJjbGFzcyQoU3RhdGVtZW50LFZhbHVlTm9kZSk7XG5cdGV4cG9ydHMuU3RhdGVtZW50ID0gU3RhdGVtZW50OyAvLyBleHBvcnQgY2xhc3MgXG5cdFN0YXRlbWVudC5wcm90b3R5cGUuaXNFeHByZXNzYWJsZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblx0XG5cdFxuXHRmdW5jdGlvbiBNZXRhKCl7IHJldHVybiBWYWx1ZU5vZGUuYXBwbHkodGhpcyxhcmd1bWVudHMpIH07XG5cdFxuXHRzdWJjbGFzcyQoTWV0YSxWYWx1ZU5vZGUpO1xuXHRleHBvcnRzLk1ldGEgPSBNZXRhOyAvLyBleHBvcnQgY2xhc3MgXG5cdE1ldGEucHJvdG90eXBlLmlzUHJpbWl0aXZlID0gZnVuY3Rpb24gKGRlZXApe1xuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gQ29tbWVudCgpeyByZXR1cm4gTWV0YS5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XG5cdHN1YmNsYXNzJChDb21tZW50LE1ldGEpO1xuXHRleHBvcnRzLkNvbW1lbnQgPSBDb21tZW50OyAvLyBleHBvcnQgY2xhc3MgXG5cdENvbW1lbnQucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKCl7XG5cdFx0Ly8gc3RhY2suc3Rhc2guYWRkKHNlbGYpXG5cdFx0XG5cdFx0dmFyIGJsb2NrLCBuZXh0O1xuXHRcdGlmIChibG9jayA9IHRoaXMudXAoKSkge1xuXHRcdFx0dmFyIGlkeCA9IGJsb2NrLmluZGV4T2YodGhpcykgKyAxO1xuXHRcdFx0aWYgKGJsb2NrLmluZGV4KGlkeCkgaW5zdGFuY2VvZiBUZXJtaW5hdG9yKSB7IGlkeCArPSAxIH07XG5cdFx0XHRpZiAobmV4dCA9IGJsb2NrLmluZGV4KGlkeCkpIHtcblx0XHRcdFx0bmV4dC5fZGVzYyA9IHRoaXM7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHQvLyBjb25zb2xlLmxvZyBcIk5leHQgaXRlbSBhZnRlciBjb21tZW50IGlzIHtibG9jay5pbmRleChpZHgpfVwiXG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdENvbW1lbnQucHJvdG90eXBlLnRvRG9jID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIGhlbHBlcnMubm9ybWFsaXplSW5kZW50YXRpb24oXCJcIiArIHRoaXMuX3ZhbHVlLl92YWx1ZSk7XG5cdH07XG5cdFxuXHRDb21tZW50LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gaGVscGVycy5ub3JtYWxpemVJbmRlbnRhdGlvbihcIlwiICsgdGhpcy5fdmFsdWUuX3ZhbHVlKTtcblx0fTtcblx0XG5cdENvbW1lbnQucHJvdG90eXBlLmMgPSBmdW5jdGlvbiAobyl7XG5cdFx0dmFyIHYgPSB0aGlzLl92YWx1ZS5fdmFsdWU7XG5cdFx0Ly8gcCBAdmFsdWUudHlwZVxuXHRcdGlmIChvICYmIG8uZXhwcmVzc2lvbiB8fCB2Lm1hdGNoKC9cXG4vKSB8fCB0aGlzLl92YWx1ZS50eXBlKCkgPT0gJ0hFUkVDT01NRU5UJykgeyAvLyBtdWx0aWxpbmU/XG5cdFx0XHRyZXR1cm4gKFwiLypcIiArIHYgKyBcIiovXCIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gKFwiLy8gXCIgKyB2KTtcblx0XHR9O1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gVGVybWluYXRvcih2KXtcblx0XHR0aGlzLl92YWx1ZSA9IHY7XG5cdFx0dGhpcztcblx0fTtcblx0XG5cdHN1YmNsYXNzJChUZXJtaW5hdG9yLE1ldGEpO1xuXHRleHBvcnRzLlRlcm1pbmF0b3IgPSBUZXJtaW5hdG9yOyAvLyBleHBvcnQgY2xhc3MgXG5cdFRlcm1pbmF0b3IucHJvdG90eXBlLnRyYXZlcnNlID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRUZXJtaW5hdG9yLnByb3RvdHlwZS5jID0gZnVuY3Rpb24gKCl7XG5cdFx0Ly8gVE9ETyB0aGlzIGNhbiBjb250YWluIHNldmVyYWwgbmV3bGluZXNcblx0XHQvLyBmb3Igc291cmNlbWFwcyBpdCB3b3VsZCBiZSBuaWNlIHRvIHBhcnNlIHRoaXNcblx0XHQvLyBhbmQgZml4IGl0IHVwIG1hcmtfXyhAdmFsdWUpICsgXG5cdFx0cmV0dXJuIHRoaXMuX3ZhbHVlLmMoKTtcblx0XHQvLyB2YXIgdiA9IHZhbHVlLnJlcGxhY2UoL1xcXFxuL2csJ1xcbicpXG5cdFx0Ly8gdiAjIC5zcGxpdCgpXG5cdFx0Ly8gdi5zcGxpdChcIlxcblwiKS5tYXAofHZ8IHYgPyBcIiAvLyB7dn1cIiA6IHYpLmpvaW4oXCJcXG5cIilcblx0fTtcblx0XG5cdGZ1bmN0aW9uIE5ld2xpbmUodil7XG5cdFx0dGhpcy5fdHJhdmVyc2VkID0gZmFsc2U7XG5cdFx0dGhpcy5fdmFsdWUgPSB2IHx8ICdcXG4nO1xuXHR9O1xuXHRcblx0c3ViY2xhc3MkKE5ld2xpbmUsVGVybWluYXRvcik7XG5cdGV4cG9ydHMuTmV3bGluZSA9IE5ld2xpbmU7IC8vIGV4cG9ydCBjbGFzcyBcblx0TmV3bGluZS5wcm90b3R5cGUuYyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiBjX18odGhpcy5fdmFsdWUpO1xuXHR9O1xuXHRcblx0XG5cdC8vIHdlaXJkIHBsYWNlP1xuXHRmdW5jdGlvbiBJbmRleCgpeyByZXR1cm4gVmFsdWVOb2RlLmFwcGx5KHRoaXMsYXJndW1lbnRzKSB9O1xuXHRcblx0c3ViY2xhc3MkKEluZGV4LFZhbHVlTm9kZSk7XG5cdGV4cG9ydHMuSW5kZXggPSBJbmRleDsgLy8gZXhwb3J0IGNsYXNzIFxuXHRJbmRleC5wcm90b3R5cGUuanMgPSBmdW5jdGlvbiAobyl7XG5cdFx0cmV0dXJuIHRoaXMuX3ZhbHVlLmMoKTtcblx0fTtcblx0XG5cdGZ1bmN0aW9uIExpc3ROb2RlKGxpc3Qpe1xuXHRcdHRoaXMuc2V0dXAoKTtcblx0XHR0aGlzLl9ub2RlcyA9IHRoaXMubG9hZChsaXN0IHx8IFtdKTtcblx0XHR0aGlzLl9pbmRlbnRhdGlvbiA9IG51bGw7XG5cdH07XG5cdFxuXHQvLyBQRVJGIGFjY2VzIEBub2RlcyBkaXJlY3RseT9cblx0c3ViY2xhc3MkKExpc3ROb2RlLE5vZGUpO1xuXHRleHBvcnRzLkxpc3ROb2RlID0gTGlzdE5vZGU7IC8vIGV4cG9ydCBjbGFzcyBcblx0TGlzdE5vZGUucHJvdG90eXBlLm5vZGVzID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9ub2RlczsgfVxuXHRMaXN0Tm9kZS5wcm90b3R5cGUuc2V0Tm9kZXMgPSBmdW5jdGlvbih2KXsgdGhpcy5fbm9kZXMgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdExpc3ROb2RlLnByb3RvdHlwZS5saXN0ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX25vZGVzO1xuXHR9O1xuXHRcblx0TGlzdE5vZGUucHJvdG90eXBlLmNvbXBhY3QgPSBmdW5jdGlvbiAoKXtcblx0XHR0aGlzLl9ub2RlcyA9IGNvbXBhY3RfXyh0aGlzLl9ub2Rlcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRMaXN0Tm9kZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChsaXN0KXtcblx0XHRyZXR1cm4gbGlzdDtcblx0fTtcblx0XG5cdExpc3ROb2RlLnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiAob3RoZXIpe1xuXHRcdC8vIG5lZWQgdG8gc3RvcmUgaW5kZW50ZWQgY29udGVudCBhcyB3ZWxsP1xuXHRcdHRoaXMuX25vZGVzID0gdGhpcy5ub2RlcygpLmNvbmNhdChvdGhlciBpbnN0YW5jZW9mIEFycmF5ID8gKG90aGVyKSA6IChvdGhlci5ub2RlcygpKSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRMaXN0Tm9kZS5wcm90b3R5cGUuc3dhcCA9IGZ1bmN0aW9uIChpdGVtLG90aGVyKXtcblx0XHR2YXIgaWR4ID0gdGhpcy5pbmRleE9mKGl0ZW0pO1xuXHRcdGlmIChpZHggPj0gMCkgeyB0aGlzLm5vZGVzKClbaWR4XSA9IG90aGVyIH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRMaXN0Tm9kZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChpdGVtKXtcblx0XHR0aGlzLl9ub2Rlcy5wdXNoKGl0ZW0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0TGlzdE5vZGUucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBlbmQgPSB0aGlzLl9ub2Rlcy5wb3AoKTtcblx0XHRyZXR1cm4gZW5kO1xuXHR9O1xuXHRcblx0TGlzdE5vZGUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChpdGVtKXtcblx0XHR0aGlzLl9ub2Rlcy5wdXNoKGl0ZW0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0TGlzdE5vZGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoaXRlbSxicil7XG5cdFx0aWYgKGJyKSB7IHRoaXMuX25vZGVzLnVuc2hpZnQoQlIpIH07XG5cdFx0dGhpcy5fbm9kZXMudW5zaGlmdChpdGVtKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8vIHRlc3Rcblx0TGlzdE5vZGUucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKGEsYil7XG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuX25vZGVzLnNsaWNlKGEsYikpO1xuXHR9O1xuXHRcblx0XG5cdFxuXHRMaXN0Tm9kZS5wcm90b3R5cGUuYnJlYWsgPSBmdW5jdGlvbiAoYnIscHJlKXtcblx0XHRpZihwcmUgPT09IHVuZGVmaW5lZCkgcHJlID0gZmFsc2U7XG5cdFx0aWYgKHR5cGVvZiBiciA9PSAnc3RyaW5nJykgeyBiciA9IG5ldyBUZXJtaW5hdG9yKGJyKSB9O1xuXHRcdHByZSA/ICh0aGlzLnVuc2hpZnQoYnIpKSA6ICh0aGlzLnB1c2goYnIpKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdExpc3ROb2RlLnByb3RvdHlwZS5zb21lID0gZnVuY3Rpb24gKGNiKXtcblx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQodGhpcy5fbm9kZXMpLCBsZW4gPSBhcnkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChjYihhcnlbaV0pKSB7IHJldHVybiB0cnVlIH07XG5cdFx0fTtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cdFxuXHRMaXN0Tm9kZS5wcm90b3R5cGUuZXZlcnkgPSBmdW5jdGlvbiAoY2Ipe1xuXHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJCh0aGlzLl9ub2RlcyksIGxlbiA9IGFyeS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKCFjYihhcnlbaV0pKSB7IHJldHVybiBmYWxzZSB9O1xuXHRcdH07XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cdFxuXHRMaXN0Tm9kZS5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gKGNiKXtcblx0XHRyZXR1cm4gdGhpcy5fbm9kZXMuZmlsdGVyKGNiKTtcblx0fTtcblx0XG5cdExpc3ROb2RlLnByb3RvdHlwZS5wbHVjayA9IGZ1bmN0aW9uIChjYil7XG5cdFx0dmFyIGl0ZW0gPSB0aGlzLmZpbHRlcihjYilbMF07XG5cdFx0aWYgKGl0ZW0pIHsgdGhpcy5yZW1vdmUoaXRlbSkgfTtcblx0XHRyZXR1cm4gaXRlbTtcblx0fTtcblx0XG5cdExpc3ROb2RlLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gKGl0ZW0pe1xuXHRcdHJldHVybiB0aGlzLl9ub2Rlcy5pbmRleE9mKGl0ZW0pO1xuXHR9O1xuXHRcblx0TGlzdE5vZGUucHJvdG90eXBlLmluZGV4ID0gZnVuY3Rpb24gKGkpe1xuXHRcdHJldHVybiB0aGlzLl9ub2Rlc1tpXTtcblx0fTtcblx0XG5cdExpc3ROb2RlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoaXRlbSl7XG5cdFx0dmFyIGlkeCA9IHRoaXMuX25vZGVzLmluZGV4T2YoaXRlbSk7XG5cdFx0aWYgKGlkeCA+PSAwKSB7IHRoaXMuX25vZGVzLnNwbGljZShpZHgsMSkgfTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdExpc3ROb2RlLnByb3RvdHlwZS5yZW1vdmVBdCA9IGZ1bmN0aW9uIChpZHgpe1xuXHRcdHZhciBpdGVtID0gdGhpcy5fbm9kZXNbaWR4XTtcblx0XHRpZiAoaWR4ID49IDApIHsgdGhpcy5fbm9kZXMuc3BsaWNlKGlkeCwxKSB9O1xuXHRcdHJldHVybiBpdGVtO1xuXHR9O1xuXHRcblx0XG5cdExpc3ROb2RlLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gKG9yaWdpbmFsLHJlcGxhY2VtZW50KXtcblx0XHR2YXIgaWR4ID0gdGhpcy5fbm9kZXMuaW5kZXhPZihvcmlnaW5hbCk7XG5cdFx0aWYgKGlkeCA+PSAwKSB7XG5cdFx0XHRpZiAocmVwbGFjZW1lbnQgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0XHQvLyBwIFwicmVwbGFjZWluZyB3aXRoIGFycmF5IG9mIGl0ZW1zXCJcblx0XHRcdFx0dGhpcy5fbm9kZXMuc3BsaWNlLmFwcGx5KHRoaXMuX25vZGVzLFtdLmNvbmNhdChbaWR4LDFdLCBbXS5zbGljZS5jYWxsKHJlcGxhY2VtZW50KSkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fbm9kZXNbaWR4XSA9IHJlcGxhY2VtZW50O1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0TGlzdE5vZGUucHJvdG90eXBlLmZpcnN0ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX25vZGVzWzBdO1xuXHR9O1xuXHRcblx0TGlzdE5vZGUucHJvdG90eXBlLmxhc3QgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgaSA9IHRoaXMuX25vZGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoaSl7XG5cdFx0XHRpID0gaSAtIDE7XG5cdFx0XHR2YXIgdiA9IHRoaXMuX25vZGVzW2ldO1xuXHRcdFx0aWYgKCEoKHYgaW5zdGFuY2VvZiBNZXRhKSkpIHsgcmV0dXJuIHYgfTtcblx0XHR9O1xuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXHRcblx0TGlzdE5vZGUucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChmbil7XG5cdFx0cmV0dXJuIHRoaXMuX25vZGVzLm1hcChmbik7XG5cdH07XG5cdFxuXHRMaXN0Tm9kZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmbil7XG5cdFx0cmV0dXJuIHRoaXMuX25vZGVzLmZvckVhY2goZm4pO1xuXHR9O1xuXHRcblx0TGlzdE5vZGUucHJvdG90eXBlLnJlbWFwID0gZnVuY3Rpb24gKGZuKXtcblx0XHR0aGlzLl9ub2RlcyA9IHRoaXMubWFwKGZuKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdExpc3ROb2RlLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9ub2Rlcy5sZW5ndGg7XG5cdH07XG5cdFxuXHRMaXN0Tm9kZS5wcm90b3R5cGUucmVhbENvdW50ID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIGsgPSAwO1xuXHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJCh0aGlzLl9ub2RlcyksIGxlbiA9IGFyeS5sZW5ndGgsIG5vZGU7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0bm9kZSA9IGFyeVtpXTtcblx0XHRcdGlmIChub2RlICYmICEobm9kZSBpbnN0YW5jZW9mIE1ldGEpKSB7IGsrKyB9O1xuXHRcdH07XG5cdFx0cmV0dXJuIGs7XG5cdH07XG5cdFxuXHRMaXN0Tm9kZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAoKXtcblx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQodGhpcy5fbm9kZXMpLCBsZW4gPSBhcnkubGVuZ3RoLCBub2RlOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdG5vZGUgPSBhcnlbaV07XG5cdFx0XHRub2RlICYmIG5vZGUudHJhdmVyc2UoKTtcblx0XHR9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0TGlzdE5vZGUucHJvdG90eXBlLmlzRXhwcmVzc2FibGUgPSBmdW5jdGlvbiAoKXtcblx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQodGhpcy5ub2RlcygpKSwgbGVuID0gYXJ5Lmxlbmd0aCwgbm9kZTsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRub2RlID0gYXJ5W2ldO1xuXHRcdFx0aWYgKG5vZGUgJiYgIW5vZGUuaXNFeHByZXNzYWJsZSgpKSB7IHJldHVybiBmYWxzZSB9O1xuXHRcdH07XG5cdFx0Ly8gcmV0dXJuIG5vIHVubGVzcyBub2Rlcy5ldmVyeSh8dnwgdi5pc0V4cHJlc3NhYmxlIClcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblx0XG5cdExpc3ROb2RlLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX25vZGVzO1xuXHR9O1xuXHRcblx0TGlzdE5vZGUucHJvdG90eXBlLmRlbGltaXRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9kZWxpbWl0ZXIgfHwgXCIsXCI7XG5cdH07XG5cdFxuXHRMaXN0Tm9kZS5wcm90b3R5cGUuanMgPSBmdW5jdGlvbiAobyxwYXJzKXtcblx0XHRpZighcGFyc3x8cGFycy5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0KSBwYXJzID0ge307XG5cdFx0dmFyIG5vZGVzID0gcGFycy5ub2RlcyAhPT0gdW5kZWZpbmVkID8gcGFycy5ub2RlcyA6IHRoaXMuX25vZGVzO1xuXHRcdHZhciBkZWxpbSA9ICcsJztcblx0XHR2YXIgZXhwcmVzcyA9IGRlbGltICE9ICc7Jztcblx0XHR2YXIgbGFzdCA9IHRoaXMubGFzdCgpO1xuXHRcdFxuXHRcdHZhciBpID0gMDtcblx0XHR2YXIgbCA9IG5vZGVzLmxlbmd0aDtcblx0XHR2YXIgc3RyID0gXCJcIjtcblx0XHRcblx0XHRmb3IgKHZhciBqID0gMCwgYXJ5ID0gaXRlciQobm9kZXMpLCBsZW4gPSBhcnkubGVuZ3RoLCBhcmc7IGogPCBsZW47IGorKykge1xuXHRcdFx0YXJnID0gYXJ5W2pdO1xuXHRcdFx0dmFyIHBhcnQgPSB0eXBlb2YgYXJnID09ICdzdHJpbmcnID8gKGFyZykgOiAoKGFyZyA/IChhcmcuYyh7ZXhwcmVzc2lvbjogZXhwcmVzc30pKSA6ICgnJykpKTtcblx0XHRcdHN0ciArPSBwYXJ0O1xuXHRcdFx0aWYgKHBhcnQgJiYgKCFleHByZXNzIHx8IGFyZyAhPSBsYXN0KSAmJiAhKGFyZyBpbnN0YW5jZW9mIE1ldGEpKSB7IHN0ciArPSBkZWxpbSB9O1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHN0cjtcblx0fTtcblx0XG5cdExpc3ROb2RlLnByb3RvdHlwZS5pbmRlbnRlZCA9IGZ1bmN0aW9uIChhLGIpe1xuXHRcdGlmIChhIGluc3RhbmNlb2YgSW5kZW50YXRpb24pIHtcblx0XHRcdHRoaXMuX2luZGVudGF0aW9uID0gYTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGhpcy5faW5kZW50YXRpb24gfHwgKHRoaXMuX2luZGVudGF0aW9uID0gYSAmJiBiID8gKG5ldyBJbmRlbnRhdGlvbihhLGIpKSA6IChJTkRFTlQpKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFxuXHRmdW5jdGlvbiBBcmdMaXN0KCl7IHJldHVybiBMaXN0Tm9kZS5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XG5cdHN1YmNsYXNzJChBcmdMaXN0LExpc3ROb2RlKTtcblx0ZXhwb3J0cy5BcmdMaXN0ID0gQXJnTGlzdDsgLy8gZXhwb3J0IGNsYXNzIFxuXHRcblx0XG5cdC8vXHRkZWYgaW5kZW50ZWQgYSxiXG5cdC8vXHRcdGlmIGEgaXNhIEluZGVudGF0aW9uXG5cdC8vXHRcdFx0QGluZGVudGF0aW9uID0gYVxuXHQvL1x0XHRcdHJldHVybiBzZWxmXG5cdC8vXG5cdC8vXHRcdEBpbmRlbnRhdGlvbiB8fD0gYSBhbmQgYiA/IEluZGVudGF0aW9uLm5ldyhhLGIpIDogSU5ERU5UXG5cdC8vXHRcdHNlbGZcblx0XG5cdC8vIGRlZiBoYXNTcGxhdFxuXHQvLyBcdEBub2Rlcy5zb21lIGRvIHx2fCB2IGlzYSBTcGxhdFxuXHQvLyBkZWYgZGVsaW1pdGVyXG5cdC8vIFx0XCIsXCJcblx0XG5cdFxuXHRmdW5jdGlvbiBBc3NpZ25MaXN0KCl7IHJldHVybiBBcmdMaXN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKSB9O1xuXHRcblx0c3ViY2xhc3MkKEFzc2lnbkxpc3QsQXJnTGlzdCk7XG5cdGV4cG9ydHMuQXNzaWduTGlzdCA9IEFzc2lnbkxpc3Q7IC8vIGV4cG9ydCBjbGFzcyBcblx0QXNzaWduTGlzdC5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gKG90aGVyKXtcblx0XHRpZiAodGhpcy5fbm9kZXMubGVuZ3RoID09IDAgJiYgKG90aGVyIGluc3RhbmNlb2YgQXNzaWduTGlzdCkpIHtcblx0XHRcdHJldHVybiBvdGhlcjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0QXNzaWduTGlzdC5fX3N1cGVyX18uY29uY2F0LmNhbGwodGhpcyxvdGhlcik7XG5cdFx0fTtcblx0XHQvLyBuZWVkIHRvIHN0b3JlIGluZGVudGVkIGNvbnRlbnQgYXMgd2VsbD9cblx0XHQvLyBAbm9kZXMgPSBub2Rlcy5jb25jYXQob3RoZXIgaXNhIEFycmF5ID8gb3RoZXIgOiBvdGhlci5ub2Rlcylcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFxuXHRmdW5jdGlvbiBCbG9jayhsaXN0KXtcblx0XHR0aGlzLnNldHVwKCk7XG5cdFx0Ly8gQG5vZGVzID0gY29tcGFjdF9fKGZsYXR0ZW5fXyhsaXN0KSkgb3IgW11cblx0XHR0aGlzLl9ub2RlcyA9IGxpc3QgfHwgW107XG5cdFx0dGhpcy5faGVhZCA9IG51bGw7XG5cdFx0dGhpcy5faW5kZW50YXRpb24gPSBudWxsO1xuXHR9O1xuXHRcblx0c3ViY2xhc3MkKEJsb2NrLExpc3ROb2RlKTtcblx0ZXhwb3J0cy5CbG9jayA9IEJsb2NrOyAvLyBleHBvcnQgY2xhc3MgXG5cdEJsb2NrLnByb3RvdHlwZS5oZWFkID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9oZWFkOyB9XG5cdEJsb2NrLnByb3RvdHlwZS5zZXRIZWFkID0gZnVuY3Rpb24odil7IHRoaXMuX2hlYWQgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdEJsb2NrLndyYXAgPSBmdW5jdGlvbiAoYXJ5KXtcblx0XHRpZiAoISgoYXJ5IGluc3RhbmNlb2YgQXJyYXkpKSkge1xuXHRcdFx0dGhyb3cgbmV3IFN5bnRheEVycm9yKFwid2hhdFwiKTtcblx0XHR9O1xuXHRcdHJldHVybiBhcnkubGVuZ3RoID09IDEgJiYgKGFyeVswXSBpbnN0YW5jZW9mIEJsb2NrKSA/IChhcnlbMF0pIDogKG5ldyBCbG9jayhhcnkpKTtcblx0fTtcblx0XG5cdEJsb2NrLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmICh0aGlzLl9zY29wZSkgeyB0aGlzLl9zY29wZS52aXNpdCgpIH07XG5cdFx0XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHRoaXMuX25vZGVzKSwgbGVuID0gYXJ5Lmxlbmd0aCwgbm9kZTsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRub2RlID0gYXJ5W2ldO1xuXHRcdFx0bm9kZSAmJiBub2RlLnRyYXZlcnNlKCk7XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEJsb2NrLnByb3RvdHlwZS5ibG9jayA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Ly8gZGVmIGluZGVudGVkIGEsYlxuXHQvLyBcdEBpbmRlbnRhdGlvbiB8fD0gYSBhbmQgYiA/IEluZGVudGF0aW9uLm5ldyhhLGIpIDogSU5ERU5UXG5cdC8vIFx0c2VsZlxuXHRcblx0QmxvY2sucHJvdG90eXBlLmxvYyA9IGZ1bmN0aW9uICgpe1xuXHRcdC8vIHJhdGhlciBpbmRlbnRzLCBubz9cblx0XHR2YXIgb3B0LCBpbmQ7XG5cdFx0aWYgKG9wdCA9IHRoaXMub3B0aW9uKCdlbmRzJykpIHtcblx0XHRcdC8vIHAgXCJsb2NhdGlvbiBpc1wiLG9wdFxuXHRcdFx0dmFyIGEgPSBvcHRbMF0ubG9jKCk7XG5cdFx0XHR2YXIgYiA9IG9wdFsxXS5sb2MoKTtcblx0XHRcdFxuXHRcdFx0aWYgKCFhKSB7IHRoaXMucCgoXCJubyBsb2MgZm9yIFwiICsgKG9wdFswXSkpKSB9O1xuXHRcdFx0aWYgKCFiKSB7IHRoaXMucCgoXCJubyBsb2MgZm9yIFwiICsgKG9wdFsxXSkpKSB9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gW2FbMF0sYlsxXV07XG5cdFx0fSBlbHNlIGlmIChpbmQgPSB0aGlzLl9pbmRlbnRhdGlvbikge1xuXHRcdFx0cmV0dXJuIFtpbmQuYWxvYygpLGluZC5ibG9jKCldO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gWzAsMF07XG5cdFx0fTtcblx0fTtcblx0XG5cdC8vIGdvIHRocm91Z2ggY2hpbGRyZW4gYW5kIHVud3JhcCBpbm5lciBub2Rlc1xuXHRCbG9jay5wcm90b3R5cGUudW53cmFwID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIGFyeSA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwLCBpdGVtcyA9IGl0ZXIkKHRoaXMubm9kZXMoKSksIGxlbiA9IGl0ZW1zLmxlbmd0aCwgbm9kZTsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRub2RlID0gaXRlbXNbaV07XG5cdFx0XHRpZiAobm9kZSBpbnN0YW5jZW9mIEJsb2NrKSB7XG5cdFx0XHRcdC8vIHAgXCJ1bndyYXBwaW5nIGlubmVyIGJsb2NrXCJcblx0XHRcdFx0YXJ5LnB1c2guYXBwbHkoYXJ5LG5vZGUudW53cmFwKCkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YXJ5LnB1c2gobm9kZSk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0cmV0dXJuIGFyeTtcblx0fTtcblx0XG5cdEJsb2NrLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGl0ZW0pe1xuXHRcdHRoaXMuX25vZGVzLnB1c2goaXRlbSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRCbG9jay5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGl0ZW0pe1xuXHRcdHRoaXMuX25vZGVzLnB1c2goaXRlbSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvLyBUaGlzIGlzIGp1c3QgdG8gd29yayBhcyBhbiBpbnBsYWNlIHJlcGxhY2VtZW50IG9mIG5vZGVzLmNvZmZlZVxuXHQvLyBBZnRlciB0aGluZ3MgYXJlIHdvcmtpbmcgb2theSB3ZSdsbCBkbyBiaWdnZXIgcmVmYWN0b3JpbmdzXG5cdEJsb2NrLnByb3RvdHlwZS5jb21waWxlID0gZnVuY3Rpb24gKG8pe1xuXHRcdGlmKG8gPT09IHVuZGVmaW5lZCkgbyA9IHt9O1xuXHRcdHZhciByb290ID0gbmV3IFJvb3QodGhpcyxvKTtcblx0XHRyZXR1cm4gcm9vdC5jb21waWxlKG8pO1xuXHR9O1xuXHRcblx0XG5cdC8vIE5vdCBzdXJlIGlmIHdlIHNob3VsZCBjcmVhdGUgYSBzZXBhcmF0ZSBibG9jaz9cblx0QmxvY2sucHJvdG90eXBlLmFuYWx5emUgPSBmdW5jdGlvbiAobyl7XG5cdFx0Ly8gcCBcImFuYWx5emluZyBibG9jayEhIVwiLG9cblx0XHRpZihvID09PSB1bmRlZmluZWQpIG8gPSB7fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEJsb2NrLnByb3RvdHlwZS5jcGFydCA9IGZ1bmN0aW9uIChub2RlKXtcblx0XHR2YXIgb3V0ID0gdHlwZW9mIG5vZGUgPT0gJ3N0cmluZycgPyAobm9kZSkgOiAoKG5vZGUgPyAobm9kZS5jKCkpIDogKFwiXCIpKSk7XG5cdFx0aWYgKG91dCA9PSBudWxsIHx8IG91dCA9PSB1bmRlZmluZWQgfHwgb3V0ID09IFwiXCIpIHsgcmV0dXJuIFwiXCIgfTtcblx0XHRcblx0XHRpZiAob3V0IGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdHZhciBzdHIgPSBcIlwiO1xuXHRcdFx0dmFyIGwgPSBvdXQubGVuZ3RoO1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0d2hpbGUgKGkgPCBsKXtcblx0XHRcdFx0c3RyICs9IHRoaXMuY3BhcnQob3V0W2krK10pO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiBzdHI7XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgaGFzU2VtaUNvbG9uID0gU0VNSUNPTE9OX1RFU1QudGVzdChvdXQpO1xuXHRcdGlmICghKGhhc1NlbWlDb2xvbiB8fCAobm9kZSBpbnN0YW5jZW9mIE1ldGEpKSkgeyBvdXQgKz0gXCI7XCIgfTtcblx0XHRyZXR1cm4gb3V0O1xuXHR9O1xuXHRcblx0QmxvY2sucHJvdG90eXBlLmpzID0gZnVuY3Rpb24gKG8sb3B0cyl7XG5cdFx0dmFyIGFzdCA9IHRoaXMuX25vZGVzO1xuXHRcdHZhciBsID0gYXN0Lmxlbmd0aDtcblx0XHQvLyByZWFsbHk/XG5cdFx0dmFyIGV4cHJlc3MgPSB0aGlzLmlzRXhwcmVzc2lvbigpIHx8IG8uaXNFeHByZXNzaW9uKCkgfHwgKHRoaXMub3B0aW9uKCdleHByZXNzJykgJiYgdGhpcy5pc0V4cHJlc3NhYmxlKCkpO1xuXHRcdGlmIChhc3QubGVuZ3RoID09IDApIHsgcmV0dXJuICcnIH07XG5cdFx0XG5cdFx0aWYgKGV4cHJlc3MpIHtcblx0XHRcdHJldHVybiBCbG9jay5fX3N1cGVyX18uanMuY2FsbCh0aGlzLG8se25vZGVzOiBhc3R9KTtcblx0XHR9O1xuXHRcdFxuXHRcdHZhciBzdHIgPSBcIlwiO1xuXHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChhc3QpLCBsZW4gPSBhcnkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHN0ciArPSB0aGlzLmNwYXJ0KGFyeVtpXSk7XG5cdFx0fTtcblx0XHRcblx0XHQvLyBub3cgYWRkIHRoZSBoZWFkIGl0ZW1zIGFzIHdlbGxcblx0XHRpZiAodGhpcy5faGVhZCAmJiB0aGlzLl9oZWFkLmxlbmd0aCA+IDApIHtcblx0XHRcdHZhciBwcmVmaXggPSBcIlwiO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHRoaXMuX2hlYWQpLCBsZW4gPSBhcnkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0dmFyIGh2ID0gdGhpcy5jcGFydChhcnlbaV0pO1xuXHRcdFx0XHRpZiAoaHYpIHsgcHJlZml4ICs9IGh2ICsgJ1xcbicgfTtcblx0XHRcdH07XG5cdFx0XHRzdHIgPSBwcmVmaXggKyBzdHI7XG5cdFx0fTtcblx0XHRyZXR1cm4gc3RyO1xuXHR9O1xuXHRcblx0XG5cdC8vIFNob3VsZCB0aGlzIGNyZWF0ZSB0aGUgZnVuY3Rpb24gYXMgd2VsbD9cblx0QmxvY2sucHJvdG90eXBlLmRlZmVycyA9IGZ1bmN0aW9uIChvcmlnaW5hbCxyZXBsYWNlbWVudCl7XG5cdFx0dmFyIGlkeCA9IHRoaXMuX25vZGVzLmluZGV4T2Yob3JpZ2luYWwpO1xuXHRcdGlmIChpZHggPj0gMCkgeyB0aGlzLl9ub2Rlc1tpZHhdID0gcmVwbGFjZW1lbnQgfTtcblx0XHR2YXIgcmVzdCA9IHRoaXMuX25vZGVzLnNwbGljZShpZHggKyAxKTtcblx0XHRyZXR1cm4gcmVzdDtcblx0fTtcblx0XG5cdEJsb2NrLnByb3RvdHlwZS5leHByZXNzaW9ucyA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBleHByZXNzaW9ucyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJCh0aGlzLm5vZGVzKCkpLCBsZW4gPSBhcnkubGVuZ3RoLCBub2RlOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdG5vZGUgPSBhcnlbaV07XG5cdFx0XHRpZiAoISgobm9kZSBpbnN0YW5jZW9mIFRlcm1pbmF0b3IpKSkgeyBleHByZXNzaW9ucy5wdXNoKG5vZGUpIH07XG5cdFx0fTtcblx0XHRyZXR1cm4gZXhwcmVzc2lvbnM7XG5cdH07XG5cdFxuXHRcblx0QmxvY2sucHJvdG90eXBlLmNvbnN1bWUgPSBmdW5jdGlvbiAobm9kZSl7XG5cdFx0dmFyIGJlZm9yZTtcblx0XHRpZiAobm9kZSBpbnN0YW5jZW9mIFRhZ1RyZWUpIHsgLy8gc3BlY2lhbCBjYXNlPyE/XG5cdFx0XHR0aGlzLl9ub2RlcyA9IHRoaXMuX25vZGVzLm1hcChmdW5jdGlvbihjaGlsZCkge1xuXHRcdFx0XHRyZXR1cm4gY2hpbGQuY29uc3VtZShub2RlKTtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHR2YXIgcmVhbCA9IHRoaXMuZXhwcmVzc2lvbnMoKTtcblx0XHRcdC8vIEZJWE1FIHNob3VsZCBub3QgaW5jbHVkZSB0ZXJtaW5hdG9ycyBhbmQgY29tbWVudHMgd2hlbiBjb3VudGluZ1xuXHRcdFx0Ly8gc2hvdWxkIG9ubHkgd3JhcCB0aGUgY29udGVudCBpbiBhcnJheSAocmV0dXJuaW5nIGFsbCBwYXJ0cylcblx0XHRcdC8vIGZvciBpZi9lbHNlIGJsb2NrcyAtLSBub3QgbG9vcHNcblx0XHRcdFxuXHRcdFx0Ly8gd2UgbmVlZCB0byBjb21wYXJlIHRoZSByZWFsIGxlbmd0aFxuXHRcdFx0aWYgKCFub2RlLl9sb29wICYmIHJlYWwubGVuZ3RoID4gMSkge1xuXHRcdFx0XHQvLyBwIFwibGVuZ3Roc1wiLEBub2RlczpsZW5ndGgsZXhwcmVzc2lvbnM6bGVuZ3RoXG5cdFx0XHRcdHZhciBuciA9IG5vZGUuYmxvY2tzKCkucHVzaCh0aGlzKTtcblx0XHRcdFx0dmFyIGFyciA9IG5ldyBBcnIobmV3IEFyZ0xpc3QodGhpcy5fbm9kZXMpKTtcblx0XHRcdFx0YXJyLmluZGVudGVkKHRoaXMuX2luZGVudGF0aW9uKTtcblx0XHRcdFx0dGhpcy5faW5kZW50YXRpb24gPSBudWxsO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKG5vZGUucmVhY3RpdmUoKSkge1xuXHRcdFx0XHRcdHRoaXMuX25vZGVzID0gW1V0aWwuY2FsbEltYmEoXCJzdGF0aWNcIixbYXJyLG5ldyBOdW0obnIpXSldO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX25vZGVzID0gW2Fycl07XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHQvLyBjYW4gYWxzbyByZXR1cm4gc3VwZXIgaWYgaXQgaXMgZXhwcmVzc2FibGUsIGJ1dCBzaG91bGQgd2UgcmVhbGx5P1xuXHRcdGlmIChiZWZvcmUgPSB0aGlzLmxhc3QoKSkge1xuXHRcdFx0dmFyIGFmdGVyID0gYmVmb3JlLmNvbnN1bWUobm9kZSk7XG5cdFx0XHRpZiAoYWZ0ZXIgIT0gYmVmb3JlKSB7XG5cdFx0XHRcdC8vIHAgXCJyZXBsYWNlIG5vZGUgaW4gYmxvY2sge2JlZm9yZX0gLT4ge2FmdGVyfVwiXG5cdFx0XHRcdGlmIChhZnRlciBpbnN0YW5jZW9mIEJsb2NrKSB7XG5cdFx0XHRcdFx0Ly8gcCBcInJlcGxhY2VkIHdpdGggYmxvY2sgLS0gc2hvdWxkIGJhc2ljYWxseSBhZGQgaXQgaW5zdGVhZD9cIlxuXHRcdFx0XHRcdGFmdGVyID0gYWZ0ZXIubm9kZXMoKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdHRoaXMucmVwbGFjZShiZWZvcmUsYWZ0ZXIpO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdC8vIHJlYWxseT9cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFxuXHRCbG9jay5wcm90b3R5cGUuaXNFeHByZXNzYWJsZSA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmICghdGhpcy5fbm9kZXMuZXZlcnkoZnVuY3Rpb24odikgeyByZXR1cm4gdi5pc0V4cHJlc3NhYmxlKCk7IH0pKSB7IHJldHVybiBmYWxzZSB9O1xuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXHRcblx0QmxvY2sucHJvdG90eXBlLmlzRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpe1xuXHRcdFxuXHRcdHJldHVybiB0aGlzLm9wdGlvbignZXhwcmVzcycpIHx8IHRoaXMuX2V4cHJlc3Npb247XG5cdH07XG5cdFxuXHRcblx0Ly8gdGhpcyBpcyBhbG1vc3QgbGlrZSB0aGUgb2xkIFZhckRlY2xhcmF0aW9ucyBidXQgd2l0aG91dCB0aGUgdmFsdWVzXG5cdGZ1bmN0aW9uIFZhckJsb2NrKCl7IHJldHVybiBMaXN0Tm9kZS5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XG5cdHN1YmNsYXNzJChWYXJCbG9jayxMaXN0Tm9kZSk7XG5cdGV4cG9ydHMuVmFyQmxvY2sgPSBWYXJCbG9jazsgLy8gZXhwb3J0IGNsYXNzIFxuXHRWYXJCbG9jay5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChsaXN0KXtcblx0XHR2YXIgZmlyc3QgPSBsaXN0WzBdO1xuXHRcdFxuXHRcdGlmIChmaXJzdCBpbnN0YW5jZW9mIEFzc2lnbikge1xuXHRcdFx0dGhpcy5fdHlwZSA9IGZpcnN0LmxlZnQoKS5fdHlwZTtcblx0XHR9IGVsc2UgaWYgKGZpcnN0IGluc3RhbmNlb2YgVmFyUmVmZXJlbmNlKSB7XG5cdFx0XHR0aGlzLl90eXBlID0gZmlyc3QuX3R5cGU7XG5cdFx0fTtcblx0XHQvLyBwIFwiaGVyZSB7bGlzdFswXX0gLSB7QHR5cGV9XCJcblx0XHQvLyBAdHlwZSA9IGxpc3RbMF0gYW5kIGxpc3RbMF0udHlwZVxuXHRcdHJldHVybiBsaXN0O1xuXHR9O1xuXHRcblx0Ly8gVE9ETyBBbGwgdGhlc2UgaW5uZXIgaXRlbXMgc2hvdWxkIHJhdGhlciBiZSBzdHJhaWdodCB1cCBsaXRlcmFsc1xuXHQvLyBvciBiYXNpYyBsb2NhbHZhcnMgLSB3aXRob3V0IGFueSBjYXJlIHdoYXRzb2V2ZXIgYWJvdXQgYWRkaW5nIHZhciB0byB0aGVcblx0Ly8gYmVnaW5uaW5nIGV0Yy4gXG5cdFZhckJsb2NrLnByb3RvdHlwZS5hZGRFeHByZXNzaW9uID0gZnVuY3Rpb24gKGV4cHIpe1xuXHRcdC8vIHAgXCJWYXJCbG9jay5hZGRFeHByZXNzaW9uIHtzZWxmfSA8LSB7ZXhwcn1cIlxuXHRcdFxuXHRcdGlmIChleHByIGluc3RhbmNlb2YgQXNzaWduKSB7XG5cdFx0XHQvLyBtYWtlIHN1cmUgdGhlIGxlZnQtc2lkZSBpcyBhIHZhci1yZWZlcmVuY2Vcblx0XHRcdC8vIHRoaXMgc2hvdWxkIGJlIGEgZGlmZmVyZW50IHR5cGUgb2YgYXNzaWduLCBubz9cblx0XHRcdGlmIChleHByLmxlZnQoKSBpbnN0YW5jZW9mIFZhck9yQWNjZXNzKSB7XG5cdFx0XHRcdGV4cHIuc2V0TGVmdChuZXcgVmFyUmVmZXJlbmNlKGV4cHIubGVmdCgpLnZhbHVlKCksdGhpcy5fdHlwZSkpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dGhpcy5wdXNoKGV4cHIpO1xuXHRcdH0gZWxzZSBpZiAoZXhwciBpbnN0YW5jZW9mIEFzc2lnbikge1xuXHRcdFx0dGhpcy5hZGRFeHByZXNzaW9uKGV4cHIubGVmdCgpKTsgLy8gbWFrZSBzdXJlIHRoaXMgaXMgYSB2YWxpZCB0aGluZz9cblx0XHRcdC8vIG1ha2UgdGhpcyBpbnRvIGEgdHVwbGUgaW5zdGVhZFxuXHRcdFx0Ly8gZG9lcyBub3QgbmVlZCB0byBiZSBhIHR1cGxlP1xuXHRcdFx0cmV0dXJuIG5ldyBUdXBsZUFzc2lnbignPScsbmV3IFR1cGxlKHRoaXMubm9kZXMoKSksZXhwci5yaWdodCgpKTtcblx0XHR9IGVsc2UgaWYgKGV4cHIgaW5zdGFuY2VvZiBWYXJPckFjY2Vzcykge1xuXHRcdFx0Ly8gdGhpcyBpcyByZWFsbHkgYSBWYXJSZWZlcmVuY2Vcblx0XHRcdHRoaXMucHVzaChuZXcgVmFyUmVmZXJlbmNlKGV4cHIudmFsdWUoKSx0aGlzLl90eXBlKSk7XG5cdFx0fSBlbHNlIGlmICgoZXhwciBpbnN0YW5jZW9mIFNwbGF0KSAmJiAoZXhwci5ub2RlKCkgaW5zdGFuY2VvZiBWYXJPckFjY2VzcykpIHtcblx0XHRcdC8vIHAgXCJpcyBhIHNwbGF0IC0gb25seSBhbGxvd2VkIGluIHR1cGxlLWFzc2lnbm1lbnRcIlxuXHRcdFx0Ly8gd2hhdD9cblx0XHRcdGV4cHIuc2V0VmFsdWUobmV3IFZhclJlZmVyZW5jZShleHByLm5vZGUoKS52YWx1ZSgpLHRoaXMuX3R5cGUpKTtcblx0XHRcdHRoaXMucHVzaChleHByKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5wKChcIlZhckJsb2NrLmFkZEV4cHJlc3Npb24gXCIgKyB0aGlzICsgXCIgPC0gXCIgKyBleHByKSk7XG5cdFx0XHR0aHJvdyBcIlZhckJsb2NrIGRvZXMgbm90IGFsbG93IG5vbi12YXJpYWJsZSBleHByZXNzaW9uc1wiO1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRcblx0VmFyQmxvY2sucHJvdG90eXBlLmlzRXhwcmVzc2FibGUgPSBmdW5jdGlvbiAoKXtcblx0XHQvLyB3ZSB3b3VsZCBuZWVkIHRvIGZvcmNlLWRyb3AgdGhlIHZhcmlhYmxlcywgbWFrZXMgbGl0dGxlIHNlbnNlXG5cdFx0Ly8gYnV0LCBpdCBjb3VsZCBiZSwgY291bGQganVzdCBwdXNoIHRoZSB2YXJpYWJsZXMgb3V0P1xuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblx0XG5cdFZhckJsb2NrLnByb3RvdHlwZS5qcyA9IGZ1bmN0aW9uIChvKXtcblx0XHQvLyBwIFwiVmFyQmxvY2tcIlxuXHRcdC8vIGZvciBuIGluIEBub2Rlc1xuXHRcdC8vIFx0cCBcIlZhckJsb2NrIGNoaWxkIHtufVwiXG5cdFx0dmFyIGNvZGUgPSBjb21wYWN0X18oZmxhdHRlbl9fKGNhcnlfXyh0aGlzLm5vZGVzKCkpKSk7XG5cdFx0Y29kZSA9IGNvZGUuZmlsdGVyKGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gIT0gbnVsbCAmJiBuICE9IHVuZGVmaW5lZCAmJiBuICE9IEVNUFRZOyB9KTtcblx0XHR2YXIgb3V0ID0gY29kZS5qb2luKFwiLFwiKTtcblx0XHQvLyB3ZSBqdXN0IG5lZWQgdG8gdHJ1c3QgdGhhdCB0aGUgdmFyaWFibGVzIGhhdmUgYmVlbiBhdXRvZGVjbGFyZWQgYmVmb3JlaGFuZFxuXHRcdC8vIGlmIHdlIGFyZSBpbnNpZGUgYW4gZXhwcmVzc2lvblxuXHRcdGlmICghby5pc0V4cHJlc3Npb24oKSkgeyBvdXQgPSBcInZhciBcIiArIG91dCB9O1xuXHRcdHJldHVybiBvdXQ7XG5cdH07XG5cdFxuXHRcblx0VmFyQmxvY2sucHJvdG90eXBlLmNvbnN1bWUgPSBmdW5jdGlvbiAobm9kZSl7XG5cdFx0Ly8gSXQgZG9lc250IG1ha2UgbXVjaCBzZW5zZSBmb3IgYSBWYXJCbG9jayB0byBjb25zdW1lIGFueXRoaW5nXG5cdFx0Ly8gaXQgc2hvdWxkIHByb2JhYmx5IHJldHVybiB2b2lkIGZvciBtZXRob2RzXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRcblx0Ly8gQ291bGQgaW5oZXJpdCBmcm9tIHZhbHVlTm9kZVxuXHRmdW5jdGlvbiBQYXJlbnModmFsdWUsb3BlbixjbG9zZSl7XG5cdFx0dGhpcy5zZXR1cCgpO1xuXHRcdHRoaXMuX29wZW4gPSBvcGVuO1xuXHRcdHRoaXMuX2Nsb3NlID0gY2xvc2U7XG5cdFx0dGhpcy5fdmFsdWUgPSB0aGlzLmxvYWQodmFsdWUpO1xuXHR9O1xuXHRcblx0c3ViY2xhc3MkKFBhcmVucyxWYWx1ZU5vZGUpO1xuXHRleHBvcnRzLlBhcmVucyA9IFBhcmVuczsgLy8gZXhwb3J0IGNsYXNzIFxuXHRQYXJlbnMucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAodmFsdWUpe1xuXHRcdHRoaXMuX25vcGFyZW4gPSBmYWxzZTtcblx0XHRyZXR1cm4gKHZhbHVlIGluc3RhbmNlb2YgQmxvY2spICYmIHZhbHVlLmNvdW50KCkgPT0gMSA/ICh2YWx1ZS5maXJzdCgpKSA6ICh2YWx1ZSk7XG5cdH07XG5cdFxuXHRQYXJlbnMucHJvdG90eXBlLmlzU3RyaW5nID0gZnVuY3Rpb24gKCl7XG5cdFx0Ly8gY2hlY2tpbmcgaWYgdGhpcyBpcyBhbiBpbnRlcnBvbGF0ZWQgc3RyaW5nXG5cdFx0cmV0dXJuIHRoaXMuX29wZW4gJiYgU3RyaW5nKHRoaXMuX29wZW4pID09ICcoXCInIHx8IHRoaXMudmFsdWUoKS5pc1N0cmluZygpO1xuXHR9O1xuXHRcblx0UGFyZW5zLnByb3RvdHlwZS5qcyA9IGZ1bmN0aW9uIChvKXtcblx0XHRcblx0XHR2YXIgcGFyID0gdGhpcy51cCgpO1xuXHRcdHZhciB2ID0gdGhpcy5fdmFsdWU7XG5cdFx0dmFyIHN0ciA9IG51bGw7XG5cdFx0XG5cdFx0aWYgKHYgaW5zdGFuY2VvZiBGdW5jKSB7IHRoaXMuX25vcGFyZW4gPSB0cnVlIH07XG5cdFx0Ly8gcCBcImNvbXBpbGUgcGFyZW5zIHt2fSB7diBpc2EgQmxvY2sgYW5kIHYuY291bnR9XCJcblx0XHQvLyBwIFwiUGFyZW5zIHVwIHtwYXJ9IHtvLmlzRXhwcmVzc2lvbn1cIlxuXHRcdGlmIChwYXIgaW5zdGFuY2VvZiBCbG9jaykge1xuXHRcdFx0Ly8gaXMgaXQgd29ydGggaXQ/XG5cdFx0XHRpZiAoIW8uaXNFeHByZXNzaW9uKCkpIHsgdGhpcy5fbm9wYXJlbiA9IHRydWUgfTtcblx0XHRcdHN0ciA9IHYgaW5zdGFuY2VvZiBBcnJheSA/IChjYXJ5X18odikpIDogKHYuYyh7ZXhwcmVzc2lvbjogby5pc0V4cHJlc3Npb24oKX0pKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3RyID0gdiBpbnN0YW5jZW9mIEFycmF5ID8gKGNhcnlfXyh2KSkgOiAodi5jKHtleHByZXNzaW9uOiB0cnVlfSkpO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gY2hlY2sgaWYgd2UgcmVhbGx5IG5lZWQgcGFyZW5zIGhlcmU/XG5cdFx0cmV0dXJuIHN0cjtcblx0fTtcblx0XG5cdFBhcmVucy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG9iail7XG5cdFx0Y29uc29sZS5sb2coKFwiUGFyZW5zIHNldCBcIiArIEpTT04uc3RyaW5naWZ5KG9iaikpKTtcblx0XHRyZXR1cm4gUGFyZW5zLl9fc3VwZXJfXy5zZXQuY2FsbCh0aGlzLG9iaik7XG5cdH07XG5cdFxuXHRcblx0UGFyZW5zLnByb3RvdHlwZS5zaG91bGRQYXJlbnRoZXNpemUgPSBmdW5jdGlvbiAoKXtcblx0XHQvLyBubyBuZWVkIHRvIHBhcmVudGhlc2l6ZSBpZiB0aGlzIGlzIGEgbGluZSBpbiBhIGJsb2NrXG5cdFx0aWYgKHRoaXMuX25vcGFyZW4pIHsgcmV0dXJuIGZhbHNlIH07IC8vICBvciBwYXIgaXNhIEFyZ0xpc3Rcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblx0XG5cdFxuXHRQYXJlbnMucHJvdG90eXBlLnByZWJyZWFrID0gZnVuY3Rpb24gKGJyKXtcblx0XHRQYXJlbnMuX19zdXBlcl9fLnByZWJyZWFrLmNhbGwodGhpcyxicik7XG5cdFx0Y29uc29sZS5sb2coXCJQUkVCUkVBS1wiKTtcblx0XHRpZiAodGhpcy5fdmFsdWUpIHsgdGhpcy5fdmFsdWUucHJlYnJlYWsoYnIpIH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRcblx0UGFyZW5zLnByb3RvdHlwZS5pc0V4cHJlc3NhYmxlID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3ZhbHVlLmlzRXhwcmVzc2FibGUoKTtcblx0fTtcblx0XG5cdFBhcmVucy5wcm90b3R5cGUuY29uc3VtZSA9IGZ1bmN0aW9uIChub2RlKXtcblx0XHRyZXR1cm4gdGhpcy5fdmFsdWUuY29uc3VtZShub2RlKTtcblx0fTtcblx0XG5cdFxuXHQvLyBDb3VsZCBpbmhlcml0IGZyb20gdmFsdWVOb2RlXG5cdC8vIGFuIGV4cGxpY2l0IGV4cHJlc3Npb24tYmxvY2sgKHdpdGggcGFyZW5zKSBpcyBzb21ld2hhdCBkaWZmZXJlbnRcblx0Ly8gY2FuIGJlIHVzZWQgdG8gcmV0dXJuIGFmdGVyIGFuIGV4cHJlc3Npb25cblx0ZnVuY3Rpb24gRXhwcmVzc2lvbkJsb2NrKCl7IHJldHVybiBMaXN0Tm9kZS5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XG5cdHN1YmNsYXNzJChFeHByZXNzaW9uQmxvY2ssTGlzdE5vZGUpO1xuXHRleHBvcnRzLkV4cHJlc3Npb25CbG9jayA9IEV4cHJlc3Npb25CbG9jazsgLy8gZXhwb3J0IGNsYXNzIFxuXHRFeHByZXNzaW9uQmxvY2sucHJvdG90eXBlLmMgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oaXRlbSkgeyByZXR1cm4gaXRlbS5jKCk7IH0pLmpvaW4oXCIsXCIpO1xuXHR9O1xuXHRcblx0RXhwcmVzc2lvbkJsb2NrLnByb3RvdHlwZS5jb25zdW1lID0gZnVuY3Rpb24gKG5vZGUpe1xuXHRcdHJldHVybiB0aGlzLnZhbHVlKCkuY29uc3VtZShub2RlKTtcblx0fTtcblx0XG5cdEV4cHJlc3Npb25CbG9jay5wcm90b3R5cGUuYWRkRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChleHByKXtcblx0XHQvLyBOZWVkIHRvIHRha2UgY2FyZSBvZiB0aGUgc3BsYXQgaGVyZSB0by4uIGhhenpsZVxuXHRcdGlmIChleHByLm5vZGUoKSBpbnN0YW5jZW9mIEFzc2lnbikge1xuXHRcdFx0Ly8gcCBcImlzIGFzc2lnbm1lbnQhXCJcblx0XHRcdHRoaXMucHVzaChleHByLmxlZnQoKSk7XG5cdFx0XHQvLyBtYWtlIHRoaXMgaW50byBhIHR1cGxlIGluc3RlYWRcblx0XHRcdC8vIHBvc3NpYmx5IGZpeCB0aGlzIGFzIHdlbGw/IT9cblx0XHRcdHJldHVybiBuZXcgVHVwbGVBc3NpZ24oJz0nLG5ldyBUdXBsZSh0aGlzLm5vZGVzKCkpLGV4cHIucmlnaHQoKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucHVzaChleHByKTtcblx0XHR9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0XG5cdFxuXHQvLyBTVEFURU1FTlRTXG5cdFxuXHRmdW5jdGlvbiBSZXR1cm4odil7XG5cdFx0dGhpcy5fdHJhdmVyc2VkID0gZmFsc2U7XG5cdFx0dGhpcy5fdmFsdWUgPSAodiBpbnN0YW5jZW9mIEFyZ0xpc3QpICYmIHYuY291bnQoKSA9PSAxID8gKHYubGFzdCgpKSA6ICh2KTtcblx0XHQvLyBAcHJlYnJlYWsgPSB2IGFuZCB2LkBwcmVicmVha1xuXHRcdC8vIGNvbnNvbGUubG9nIFwicmV0dXJuPyE/IHt2fVwiLEBwcmVicmVha1xuXHRcdC8vIGlmIHYgaXNhIEFyZ0xpc3QgYW5kIHYuY291bnQgPT0gMVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0c3ViY2xhc3MkKFJldHVybixTdGF0ZW1lbnQpO1xuXHRleHBvcnRzLlJldHVybiA9IFJldHVybjsgLy8gZXhwb3J0IGNsYXNzIFxuXHRSZXR1cm4ucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl92YWx1ZTsgfVxuXHRSZXR1cm4ucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24odil7IHRoaXMuX3ZhbHVlID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRSZXR1cm4ucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKCl7XG5cdFx0aWYgKHRoaXMuX3ZhbHVlICYmIHRoaXMuX3ZhbHVlLnRyYXZlcnNlKSB7IHJldHVybiB0aGlzLl92YWx1ZS50cmF2ZXJzZSgpIH07XG5cdH07XG5cdFxuXHRSZXR1cm4ucHJvdG90eXBlLmpzID0gZnVuY3Rpb24gKG8pe1xuXHRcdHZhciB2ID0gdGhpcy5fdmFsdWU7XG5cdFx0XG5cdFx0aWYgKHYgaW5zdGFuY2VvZiBBcmdMaXN0KSB7XG5cdFx0XHRyZXR1cm4gKFwicmV0dXJuIFtcIiArIHYuYyh7ZXhwcmVzc2lvbjogdHJ1ZX0pICsgXCJdXCIpO1xuXHRcdH0gZWxzZSBpZiAodikge1xuXHRcdFx0cmV0dXJuIChcInJldHVybiBcIiArIHYuYyh7ZXhwcmVzc2lvbjogdHJ1ZX0pKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIFwicmV0dXJuXCI7XG5cdFx0fTtcblx0fTtcblx0XG5cdFJldHVybi5wcm90b3R5cGUuYyA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmICghKHRoaXMudmFsdWUoKSkgfHwgdGhpcy52YWx1ZSgpLmlzRXhwcmVzc2FibGUoKSkgeyByZXR1cm4gUmV0dXJuLl9fc3VwZXJfXy5jLmFwcGx5KHRoaXMsYXJndW1lbnRzKSB9O1xuXHRcdC8vIHAgXCJyZXR1cm4gbXVzdCBjYXNjYWRlIGludG8gdmFsdWVcIi5yZWRcblx0XHRyZXR1cm4gdGhpcy52YWx1ZSgpLmNvbnN1bWUodGhpcykuYygpO1xuXHR9O1xuXHRcblx0UmV0dXJuLnByb3RvdHlwZS5jb25zdW1lID0gZnVuY3Rpb24gKG5vZGUpe1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gSW1wbGljaXRSZXR1cm4oKXsgcmV0dXJuIFJldHVybi5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XG5cdHN1YmNsYXNzJChJbXBsaWNpdFJldHVybixSZXR1cm4pO1xuXHRleHBvcnRzLkltcGxpY2l0UmV0dXJuID0gSW1wbGljaXRSZXR1cm47IC8vIGV4cG9ydCBjbGFzcyBcblx0XG5cdFxuXHRmdW5jdGlvbiBHcmVlZHlSZXR1cm4oKXsgcmV0dXJuIEltcGxpY2l0UmV0dXJuLmFwcGx5KHRoaXMsYXJndW1lbnRzKSB9O1xuXHRcblx0c3ViY2xhc3MkKEdyZWVkeVJldHVybixJbXBsaWNpdFJldHVybik7XG5cdGV4cG9ydHMuR3JlZWR5UmV0dXJuID0gR3JlZWR5UmV0dXJuOyAvLyBleHBvcnQgY2xhc3MgXG5cdFxuXHRcblx0Ly8gY2Fubm90IGxpdmUgaW5zaWRlIGFuIGV4cHJlc3Npb24oISlcblx0ZnVuY3Rpb24gVGhyb3coKXsgcmV0dXJuIFN0YXRlbWVudC5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XG5cdHN1YmNsYXNzJChUaHJvdyxTdGF0ZW1lbnQpO1xuXHRleHBvcnRzLlRocm93ID0gVGhyb3c7IC8vIGV4cG9ydCBjbGFzcyBcblx0VGhyb3cucHJvdG90eXBlLmpzID0gZnVuY3Rpb24gKG8pe1xuXHRcdHJldHVybiAoXCJ0aHJvdyBcIiArICh0aGlzLnZhbHVlKCkuYygpKSk7XG5cdH07XG5cdFxuXHRUaHJvdy5wcm90b3R5cGUuY29uc3VtZSA9IGZ1bmN0aW9uIChub2RlKXtcblx0XHQvLyBST0FETUFQIHNob3VsZCBwb3NzaWJseSBjb25zdW1lIHRvIHRoZSB2YWx1ZSBvZiB0aHJvdyBhbmQgdGhlbiB0aHJvdz9cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFxuXHRmdW5jdGlvbiBMb29wRmxvd1N0YXRlbWVudChsaXQsZXhwcil7XG5cdFx0dGhpcy5zZXRMaXRlcmFsKGxpdCk7XG5cdFx0dGhpcy5zZXRFeHByZXNzaW9uKGV4cHIpOyAvLyAmJiBBcmdMaXN0Lm5ldyhleHByKSAjIHJlYWxseT9cblx0fTtcblx0XG5cdHN1YmNsYXNzJChMb29wRmxvd1N0YXRlbWVudCxTdGF0ZW1lbnQpO1xuXHRleHBvcnRzLkxvb3BGbG93U3RhdGVtZW50ID0gTG9vcEZsb3dTdGF0ZW1lbnQ7IC8vIGV4cG9ydCBjbGFzcyBcblx0TG9vcEZsb3dTdGF0ZW1lbnQucHJvdG90eXBlLmxpdGVyYWwgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2xpdGVyYWw7IH1cblx0TG9vcEZsb3dTdGF0ZW1lbnQucHJvdG90eXBlLnNldExpdGVyYWwgPSBmdW5jdGlvbih2KXsgdGhpcy5fbGl0ZXJhbCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRMb29wRmxvd1N0YXRlbWVudC5wcm90b3R5cGUuZXhwcmVzc2lvbiA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fZXhwcmVzc2lvbjsgfVxuXHRMb29wRmxvd1N0YXRlbWVudC5wcm90b3R5cGUuc2V0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9leHByZXNzaW9uID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRMb29wRmxvd1N0YXRlbWVudC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAoKXtcblx0XHRpZiAodGhpcy5leHByZXNzaW9uKCkpIHsgcmV0dXJuIHRoaXMuZXhwcmVzc2lvbigpLnRyYXZlcnNlKCkgfTtcblx0fTtcblx0XG5cdExvb3BGbG93U3RhdGVtZW50LnByb3RvdHlwZS5jb25zdW1lID0gZnVuY3Rpb24gKG5vZGUpe1xuXHRcdC8vIHAgXCJicmVhay9jb250aW51ZSBzaG91bGQgY29uc3VtZT8hXCJcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdExvb3BGbG93U3RhdGVtZW50LnByb3RvdHlwZS5jID0gZnVuY3Rpb24gKCl7XG5cdFx0aWYgKCEodGhpcy5leHByZXNzaW9uKCkpKSB7IHJldHVybiBMb29wRmxvd1N0YXRlbWVudC5fX3N1cGVyX18uYy5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XHQvLyBnZXQgdXAgdG8gdGhlIG91dGVyIGxvb3Bcblx0XHR2YXIgX2xvb3AgPSBTVEFDSy51cChMb29wKTtcblx0XHQvLyBwIFwiZm91bmQgbG9vcD9cIixfbG9vcFxuXHRcdFxuXHRcdC8vIG5lZWQgdG8gZml4IHRoZSBncmFtbWFyIGZvciB0aGlzLiBSaWdodCBub3cgaXQgXG5cdFx0Ly8gaXMgbGlrZSBhIGZha2UgY2FsbCwgYnV0IHNob3VsZCBvbmx5IGNhcmUgYWJvdXQgdGhlIGZpcnN0IGFyZ3VtZW50XG5cdFx0dmFyIGV4cHIgPSB0aGlzLmV4cHJlc3Npb24oKTtcblx0XHRcblx0XHRpZiAoX2xvb3AuY2F0Y2hlcigpKSB7XG5cdFx0XHRleHByID0gZXhwci5jb25zdW1lKF9sb29wLmNhdGNoZXIoKSk7XG5cdFx0XHR2YXIgY29weSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMubGl0ZXJhbCgpKTtcblx0XHRcdHJldHVybiBuZXcgQmxvY2soW2V4cHIsY29weV0pLmMoKTtcblx0XHR9IGVsc2UgaWYgKGV4cHIpIHtcblx0XHRcdGNvcHkgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLmxpdGVyYWwoKSk7XG5cdFx0XHRyZXR1cm4gbmV3IEJsb2NrKFtleHByLGNvcHldKS5jKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBMb29wRmxvd1N0YXRlbWVudC5fX3N1cGVyX18uYy5hcHBseSh0aGlzLGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0XHQvLyByZXR1cm4gXCJsb29wZmxvd1wiXG5cdH07XG5cdFxuXHRcblx0ZnVuY3Rpb24gQnJlYWtTdGF0ZW1lbnQoKXsgcmV0dXJuIExvb3BGbG93U3RhdGVtZW50LmFwcGx5KHRoaXMsYXJndW1lbnRzKSB9O1xuXHRcblx0c3ViY2xhc3MkKEJyZWFrU3RhdGVtZW50LExvb3BGbG93U3RhdGVtZW50KTtcblx0ZXhwb3J0cy5CcmVha1N0YXRlbWVudCA9IEJyZWFrU3RhdGVtZW50OyAvLyBleHBvcnQgY2xhc3MgXG5cdEJyZWFrU3RhdGVtZW50LnByb3RvdHlwZS5qcyA9IGZ1bmN0aW9uIChvKXtcblx0XHRyZXR1cm4gXCJicmVha1wiO1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gQ29udGludWVTdGF0ZW1lbnQoKXsgcmV0dXJuIExvb3BGbG93U3RhdGVtZW50LmFwcGx5KHRoaXMsYXJndW1lbnRzKSB9O1xuXHRcblx0c3ViY2xhc3MkKENvbnRpbnVlU3RhdGVtZW50LExvb3BGbG93U3RhdGVtZW50KTtcblx0ZXhwb3J0cy5Db250aW51ZVN0YXRlbWVudCA9IENvbnRpbnVlU3RhdGVtZW50OyAvLyBleHBvcnQgY2xhc3MgXG5cdENvbnRpbnVlU3RhdGVtZW50LnByb3RvdHlwZS5qcyA9IGZ1bmN0aW9uIChvKXtcblx0XHRyZXR1cm4gXCJjb250aW51ZVwiO1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gRGVidWdnZXJTdGF0ZW1lbnQoKXsgcmV0dXJuIFN0YXRlbWVudC5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XG5cdHN1YmNsYXNzJChEZWJ1Z2dlclN0YXRlbWVudCxTdGF0ZW1lbnQpO1xuXHRleHBvcnRzLkRlYnVnZ2VyU3RhdGVtZW50ID0gRGVidWdnZXJTdGF0ZW1lbnQ7IC8vIGV4cG9ydCBjbGFzcyBcblx0XG5cdFxuXHRcblx0Ly8gUEFSQU1TXG5cdFxuXHRmdW5jdGlvbiBQYXJhbShuYW1lLGRlZmF1bHRzLHR5cCl7XG5cdFx0Ly8gY291bGQgaGF2ZSBpbnRyb2R1Y2VkIGJ1Z3MgYnkgbW92aW5nIGJhY2sgdG8gaWRlbnRpZmllciBoZXJlXG5cdFx0dGhpcy5fdHJhdmVyc2VkID0gZmFsc2U7XG5cdFx0dGhpcy5fbmFtZSA9IG5hbWU7IC8vIC52YWx1ZSAjIHRoaXMgaXMgYW4gaWRlbnRpZmllcighKVxuXHRcdHRoaXMuX2RlZmF1bHRzID0gZGVmYXVsdHM7XG5cdFx0dGhpcy5fdHlwID0gdHlwO1xuXHRcdHRoaXMuX3ZhcmlhYmxlID0gbnVsbDtcblx0fTtcblx0XG5cdHN1YmNsYXNzJChQYXJhbSxOb2RlKTtcblx0ZXhwb3J0cy5QYXJhbSA9IFBhcmFtOyAvLyBleHBvcnQgY2xhc3MgXG5cdFBhcmFtLnByb3RvdHlwZS5uYW1lID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9uYW1lOyB9XG5cdFBhcmFtLnByb3RvdHlwZS5zZXROYW1lID0gZnVuY3Rpb24odil7IHRoaXMuX25hbWUgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0UGFyYW0ucHJvdG90eXBlLmluZGV4ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9pbmRleDsgfVxuXHRQYXJhbS5wcm90b3R5cGUuc2V0SW5kZXggPSBmdW5jdGlvbih2KXsgdGhpcy5faW5kZXggPSB2OyByZXR1cm4gdGhpczsgfTtcblx0UGFyYW0ucHJvdG90eXBlLmRlZmF1bHRzID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9kZWZhdWx0czsgfVxuXHRQYXJhbS5wcm90b3R5cGUuc2V0RGVmYXVsdHMgPSBmdW5jdGlvbih2KXsgdGhpcy5fZGVmYXVsdHMgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0UGFyYW0ucHJvdG90eXBlLnNwbGF0ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9zcGxhdDsgfVxuXHRQYXJhbS5wcm90b3R5cGUuc2V0U3BsYXQgPSBmdW5jdGlvbih2KXsgdGhpcy5fc3BsYXQgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0UGFyYW0ucHJvdG90eXBlLnZhcmlhYmxlID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl92YXJpYWJsZTsgfVxuXHRQYXJhbS5wcm90b3R5cGUuc2V0VmFyaWFibGUgPSBmdW5jdGlvbih2KXsgdGhpcy5fdmFyaWFibGUgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdC8vIHdoYXQgYWJvdXQgb2JqZWN0LXBhcmFtcz9cblx0XG5cdFBhcmFtLnByb3RvdHlwZS52YXJuYW1lID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3ZhcmlhYmxlID8gKHRoaXMuX3ZhcmlhYmxlLmMoKSkgOiAodGhpcy5uYW1lKCkpO1xuXHR9O1xuXHRcblx0UGFyYW0ucHJvdG90eXBlLmpzID0gZnVuY3Rpb24gKG8pe1xuXHRcdGlmICh0aGlzLl92YXJpYWJsZSkgeyByZXR1cm4gdGhpcy5fdmFyaWFibGUuYygpIH07XG5cdFx0XG5cdFx0aWYgKHRoaXMuZGVmYXVsdHMoKSkge1xuXHRcdFx0Ly8gc2hvdWxkIG5vdCBpbmNsdWRlIGFueSBzb3VyY2UtbWFwcGluZyBoZXJlP1xuXHRcdFx0cmV0dXJuIChcImlmKFwiICsgKHRoaXMubmFtZSgpLmMoKSkgKyBcIiA9PSBudWxsKSBcIiArICh0aGlzLm5hbWUoKS5jKCkpICsgXCIgPSBcIiArICh0aGlzLmRlZmF1bHRzKCkuYygpKSk7XG5cdFx0fTtcblx0XHQvLyBzZWUgaWYgdGhpcyBpcyB0aGUgaW5pdGlhbCBkZWNsYXJhdG9yP1xuXHR9O1xuXHRcblx0UGFyYW0ucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHZhcmlhYmxlXywgdl87XG5cdFx0aWYgKHRoaXMuX2RlZmF1bHRzKSB7IHRoaXMuX2RlZmF1bHRzLnRyYXZlcnNlKCkgfTtcblx0XHQodmFyaWFibGVfID0gdGhpcy52YXJpYWJsZSgpKSB8fCAoKHRoaXMuc2V0VmFyaWFibGUodl8gPSB0aGlzLnNjb3BlX18oKS5yZWdpc3Rlcih0aGlzLm5hbWUoKSx0aGlzKSksdl8pKTtcblx0XHRcblx0XHRpZiAodGhpcy5fbmFtZSBpbnN0YW5jZW9mIElkZW50aWZpZXIpIHtcblx0XHRcdC8vIGNoYW5nZSB0eXBlIGhlcmU/XG5cdFx0XHRpZiAodGhpcy5fbmFtZS5fdmFsdWUpIHsgdGhpcy5fbmFtZS5fdmFsdWUuX3R5cGUgPSBcIlBBUkFNVkFSXCIgfTtcblx0XHRcdHRoaXMuX25hbWUucmVmZXJlbmNlcyh0aGlzLl92YXJpYWJsZSk7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyBcImdvdCBoZXJlISEge0BuYW1lOmNvbnN0cnVjdG9yfVwiXG5cdFx0XHQvLyBAbmFtZS5AdG9rZW4uQHZhcmlhYmxlID0gQHZhcmlhYmxlIGlmIEBuYW1lLkB0b2tlblxuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRQYXJhbS5wcm90b3R5cGUuYXNzaWdubWVudCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiBPUCgnPScsdGhpcy52YXJpYWJsZSgpLmFjY2Vzc29yKCksdGhpcy5kZWZhdWx0cygpKTtcblx0fTtcblx0XG5cdFBhcmFtLnByb3RvdHlwZS5pc0V4cHJlc3NhYmxlID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuICEodGhpcy5kZWZhdWx0cygpKSB8fCB0aGlzLmRlZmF1bHRzKCkuaXNFeHByZXNzYWJsZSgpO1xuXHRcdC8vIHAgXCJ2aXNpdGluZyBwYXJhbSEhIVwiXG5cdH07XG5cdFxuXHRQYXJhbS5wcm90b3R5cGUuZHVtcCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB7bG9jOiB0aGlzLmxvYygpfTtcblx0fTtcblx0XG5cdFBhcmFtLnByb3RvdHlwZS5sb2MgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fbmFtZSAmJiB0aGlzLl9uYW1lLnJlZ2lvbigpO1xuXHR9O1xuXHRcblx0UGFyYW0ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB7XG5cdFx0XHR0eXBlOiB0aGlzLnR5cGVOYW1lKCksXG5cdFx0XHRuYW1lOiB0aGlzLm5hbWUoKSxcblx0XHRcdGRlZmF1bHRzOiB0aGlzLmRlZmF1bHRzKClcblx0XHR9O1xuXHR9O1xuXHRcblx0XG5cdGZ1bmN0aW9uIFNwbGF0UGFyYW0oKXsgcmV0dXJuIFBhcmFtLmFwcGx5KHRoaXMsYXJndW1lbnRzKSB9O1xuXHRcblx0c3ViY2xhc3MkKFNwbGF0UGFyYW0sUGFyYW0pO1xuXHRleHBvcnRzLlNwbGF0UGFyYW0gPSBTcGxhdFBhcmFtOyAvLyBleHBvcnQgY2xhc3MgXG5cdFNwbGF0UGFyYW0ucHJvdG90eXBlLmxvYyA9IGZ1bmN0aW9uICgpe1xuXHRcdC8vIGhhY2t5Li4gY2Fubm90IGtub3cgZm9yIHN1cmUgdGhhdCB0aGlzIGlzIHJpZ2h0P1xuXHRcdHZhciByID0gdGhpcy5uYW1lKCkucmVnaW9uKCk7XG5cdFx0cmV0dXJuIFtyWzBdIC0gMSxyWzFdXTtcblx0fTtcblx0XG5cdGZ1bmN0aW9uIEJsb2NrUGFyYW0oKXsgcmV0dXJuIFBhcmFtLmFwcGx5KHRoaXMsYXJndW1lbnRzKSB9O1xuXHRcblx0c3ViY2xhc3MkKEJsb2NrUGFyYW0sUGFyYW0pO1xuXHRleHBvcnRzLkJsb2NrUGFyYW0gPSBCbG9ja1BhcmFtOyAvLyBleHBvcnQgY2xhc3MgXG5cdEJsb2NrUGFyYW0ucHJvdG90eXBlLmMgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gXCJibG9ja3BhcmFtXCI7XG5cdH07XG5cdFxuXHRCbG9ja1BhcmFtLnByb3RvdHlwZS5sb2MgPSBmdW5jdGlvbiAoKXtcblx0XHQvLyBoYWNreS4uIGNhbm5vdCBrbm93IGZvciBzdXJlIHRoYXQgdGhpcyBpcyByaWdodD9cblx0XHR2YXIgciA9IHRoaXMubmFtZSgpLnJlZ2lvbigpO1xuXHRcdHJldHVybiBbclswXSAtIDEsclsxXV07XG5cdH07XG5cdFxuXHRcblx0ZnVuY3Rpb24gT3B0aW9uYWxQYXJhbSgpeyByZXR1cm4gUGFyYW0uYXBwbHkodGhpcyxhcmd1bWVudHMpIH07XG5cdFxuXHRzdWJjbGFzcyQoT3B0aW9uYWxQYXJhbSxQYXJhbSk7XG5cdGV4cG9ydHMuT3B0aW9uYWxQYXJhbSA9IE9wdGlvbmFsUGFyYW07IC8vIGV4cG9ydCBjbGFzcyBcblx0XG5cdFxuXHRmdW5jdGlvbiBOYW1lZFBhcmFtKCl7IHJldHVybiBQYXJhbS5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XG5cdHN1YmNsYXNzJChOYW1lZFBhcmFtLFBhcmFtKTtcblx0ZXhwb3J0cy5OYW1lZFBhcmFtID0gTmFtZWRQYXJhbTsgLy8gZXhwb3J0IGNsYXNzIFxuXHRcblx0XG5cdGZ1bmN0aW9uIFJlcXVpcmVkUGFyYW0oKXsgcmV0dXJuIFBhcmFtLmFwcGx5KHRoaXMsYXJndW1lbnRzKSB9O1xuXHRcblx0c3ViY2xhc3MkKFJlcXVpcmVkUGFyYW0sUGFyYW0pO1xuXHRleHBvcnRzLlJlcXVpcmVkUGFyYW0gPSBSZXF1aXJlZFBhcmFtOyAvLyBleHBvcnQgY2xhc3MgXG5cdFxuXHRcblx0ZnVuY3Rpb24gTmFtZWRQYXJhbXMoKXsgcmV0dXJuIExpc3ROb2RlLmFwcGx5KHRoaXMsYXJndW1lbnRzKSB9O1xuXHRcblx0c3ViY2xhc3MkKE5hbWVkUGFyYW1zLExpc3ROb2RlKTtcblx0ZXhwb3J0cy5OYW1lZFBhcmFtcyA9IE5hbWVkUGFyYW1zOyAvLyBleHBvcnQgY2xhc3MgXG5cdE5hbWVkUGFyYW1zLnByb3RvdHlwZS5pbmRleCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5faW5kZXg7IH1cblx0TmFtZWRQYXJhbXMucHJvdG90eXBlLnNldEluZGV4ID0gZnVuY3Rpb24odil7IHRoaXMuX2luZGV4ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdE5hbWVkUGFyYW1zLnByb3RvdHlwZS52YXJpYWJsZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fdmFyaWFibGU7IH1cblx0TmFtZWRQYXJhbXMucHJvdG90eXBlLnNldFZhcmlhYmxlID0gZnVuY3Rpb24odil7IHRoaXMuX3ZhcmlhYmxlID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHROYW1lZFBhcmFtcy5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChsaXN0KXtcblx0XHR2YXIgbG9hZCA9IGZ1bmN0aW9uKGspIHsgcmV0dXJuIG5ldyBOYW1lZFBhcmFtKGsua2V5KCksay52YWx1ZSgpKTsgfTtcblx0XHRyZXR1cm4gbGlzdCBpbnN0YW5jZW9mIE9iaiA/IChsaXN0LnZhbHVlKCkubWFwKGxvYWQpKSA6IChsaXN0KTtcblx0fTtcblx0XG5cdE5hbWVkUGFyYW1zLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBzID0gdGhpcy5zY29wZV9fKCk7XG5cdFx0dGhpcy5fdmFyaWFibGUgfHwgKHRoaXMuX3ZhcmlhYmxlID0gcy50ZW1wb3JhcnkodGhpcyx7cG9vbDogJ2tleXBhcnMnfSkpO1xuXHRcdHRoaXMuX3ZhcmlhYmxlLnByZWRlY2xhcmVkKCk7XG5cdFx0XG5cdFx0Ly8gdGhpcyBpcyBhIGxpc3Rub2RlLCB3aGljaCB3aWxsIGF1dG9tYXRpY2FsbHkgdHJhdmVyc2Vcblx0XHQvLyBhbmQgdmlzaXQgYWxsIGNoaWxkcmVuXG5cdFx0TmFtZWRQYXJhbXMuX19zdXBlcl9fLnZpc2l0LmFwcGx5KHRoaXMsYXJndW1lbnRzKTtcblx0XHQvLyByZWdpc3RlciB0aGUgaW5uZXIgdmFyaWFibGVzIGFzIHdlbGwoISlcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFxuXHROYW1lZFBhcmFtcy5wcm90b3R5cGUudmFybmFtZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLnZhcmlhYmxlKCkuYygpO1xuXHR9O1xuXHRcblx0TmFtZWRQYXJhbXMucHJvdG90eXBlLm5hbWUgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy52YXJuYW1lKCk7XG5cdH07XG5cdFxuXHROYW1lZFBhcmFtcy5wcm90b3R5cGUuanMgPSBmdW5jdGlvbiAobyl7XG5cdFx0cmV0dXJuIFwibmFtZWRwYXJcIjtcblx0fTtcblx0XG5cdE5hbWVkUGFyYW1zLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dHlwZTogdGhpcy50eXBlTmFtZSgpLFxuXHRcdFx0bm9kZXM6IHRoaXMuZmlsdGVyKGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHYgaW5zdGFuY2VvZiBOYW1lZFBhcmFtOyB9KVxuXHRcdH07XG5cdH07XG5cdFxuXHRcblx0ZnVuY3Rpb24gSW5kZXhlZFBhcmFtKCl7IHJldHVybiBQYXJhbS5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XG5cdHN1YmNsYXNzJChJbmRleGVkUGFyYW0sUGFyYW0pO1xuXHRleHBvcnRzLkluZGV4ZWRQYXJhbSA9IEluZGV4ZWRQYXJhbTsgLy8gZXhwb3J0IGNsYXNzIFxuXHRJbmRleGVkUGFyYW0ucHJvdG90eXBlLnBhcmVudCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fcGFyZW50OyB9XG5cdEluZGV4ZWRQYXJhbS5wcm90b3R5cGUuc2V0UGFyZW50ID0gZnVuY3Rpb24odil7IHRoaXMuX3BhcmVudCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRJbmRleGVkUGFyYW0ucHJvdG90eXBlLnN1YmluZGV4ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9zdWJpbmRleDsgfVxuXHRJbmRleGVkUGFyYW0ucHJvdG90eXBlLnNldFN1YmluZGV4ID0gZnVuY3Rpb24odil7IHRoaXMuX3N1YmluZGV4ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRJbmRleGVkUGFyYW0ucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKCl7XG5cdFx0Ly8gcCBcIlZJU0lUIFBBUkFNIHtuYW1lfSFcIlxuXHRcdC8vIGFyeS5bLTFdICMgcG9zc2libGVcblx0XHQvLyBhcnkuKC0xKSAjIHBvc3NpYmxlXG5cdFx0Ly8gc3RyKC9vay8sLTEpXG5cdFx0Ly8gc2NvcGUucmVnaXN0ZXIoQG5hbWUsc2VsZilcblx0XHQvLyBCVUcgVGhlIGRlZmF1bHRzIHNob3VsZCBwcm9iYWJseSBiZSBsb29rZWQgdXAgbGlrZSB2YXJzXG5cdFx0dmFyIHZhcmlhYmxlXywgdl87XG5cdFx0KHZhcmlhYmxlXyA9IHRoaXMudmFyaWFibGUoKSkgfHwgKCh0aGlzLnNldFZhcmlhYmxlKHZfID0gdGhpcy5zY29wZV9fKCkucmVnaXN0ZXIodGhpcy5uYW1lKCksdGhpcykpLHZfKSk7XG5cdFx0dGhpcy52YXJpYWJsZSgpLnByb3h5KHRoaXMucGFyZW50KCkudmFyaWFibGUoKSx0aGlzLnN1YmluZGV4KCkpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0XG5cdGZ1bmN0aW9uIEFycmF5UGFyYW1zKCl7IHJldHVybiBMaXN0Tm9kZS5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XG5cdHN1YmNsYXNzJChBcnJheVBhcmFtcyxMaXN0Tm9kZSk7XG5cdGV4cG9ydHMuQXJyYXlQYXJhbXMgPSBBcnJheVBhcmFtczsgLy8gZXhwb3J0IGNsYXNzIFxuXHRBcnJheVBhcmFtcy5wcm90b3R5cGUuaW5kZXggPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2luZGV4OyB9XG5cdEFycmF5UGFyYW1zLnByb3RvdHlwZS5zZXRJbmRleCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9pbmRleCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRBcnJheVBhcmFtcy5wcm90b3R5cGUudmFyaWFibGUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3ZhcmlhYmxlOyB9XG5cdEFycmF5UGFyYW1zLnByb3RvdHlwZS5zZXRWYXJpYWJsZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl92YXJpYWJsZSA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0QXJyYXlQYXJhbXMucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHMgPSB0aGlzLnNjb3BlX18oKTtcblx0XHR0aGlzLl92YXJpYWJsZSB8fCAodGhpcy5fdmFyaWFibGUgPSBzLnRlbXBvcmFyeSh0aGlzLHtwb29sOiAna2V5cGFycyd9KSk7XG5cdFx0dGhpcy5fdmFyaWFibGUucHJlZGVjbGFyZWQoKTtcblx0XHRcblx0XHQvLyBub3cgd2hlbiB3ZSBsb29wIHRocm91Z2ggdGhlc2UgaW5uZXIgcGFyYW1zIC0gd2UgY3JlYXRlIHRoZSBwYXJzXG5cdFx0Ly8gd2l0aCB0aGUgY29ycmVjdCBuYW1lLCBidXQgYmluZCB0aGVtIHRvIHRoZSBwYXJlbnRcblx0XHRyZXR1cm4gQXJyYXlQYXJhbXMuX19zdXBlcl9fLnZpc2l0LmFwcGx5KHRoaXMsYXJndW1lbnRzKTtcblx0fTtcblx0XG5cdEFycmF5UGFyYW1zLnByb3RvdHlwZS5uYW1lID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMudmFyaWFibGUoKS5jKCk7XG5cdH07XG5cdFxuXHRBcnJheVBhcmFtcy5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChsaXN0KXtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0aWYgKCEoKGxpc3QgaW5zdGFuY2VvZiBBcnIpKSkgeyByZXR1cm4gbnVsbCB9O1xuXHRcdC8vIHAgXCJsb2FkaW5nIGFycmF5cGFyYW1zXCJcblx0XHQvLyB0cnkgdGhlIGJhc2ljIGZpcnN0XG5cdFx0aWYgKCFsaXN0LnNwbGF0KCkpIHtcblx0XHRcdHJldHVybiBsaXN0LnZhbHVlKCkubWFwKGZ1bmN0aW9uKHYsaSkge1xuXHRcdFx0XHQvLyBtdXN0IG1ha2Ugc3VyZSB0aGUgcGFyYW1zIGFyZSBzdXBwb3J0ZWQgaGVyZVxuXHRcdFx0XHQvLyBzaG91bGQgcmVhbGx5IG5vdCBwYXJzZSBhbnkgYXJyYXkgYXQgYWxsKCEpXG5cdFx0XHRcdHZhciBuYW1lID0gdjtcblx0XHRcdFx0aWYgKHYgaW5zdGFuY2VvZiBWYXJPckFjY2Vzcykge1xuXHRcdFx0XHRcdC8vIHAgXCJ2YXJvcmFjY2VzcyB7di52YWx1ZX1cIlxuXHRcdFx0XHRcdC8vIEZJWD9cblx0XHRcdFx0XHRuYW1lID0gdi52YWx1ZSgpLnZhbHVlKCk7XG5cdFx0XHRcdFx0Ly8gdGhpcyBpcyBhY2NlcHRlZFxuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4gc2VsZi5wYXJzZShuYW1lLHYsaSk7XG5cdFx0XHR9KTtcblx0XHR9O1xuXHR9O1xuXHRcblx0QXJyYXlQYXJhbXMucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKG5hbWUsY2hpbGQsaSl7XG5cdFx0dmFyIHBhcmFtID0gbmV3IEluZGV4ZWRQYXJhbShuYW1lLG51bGwpO1xuXHRcdFxuXHRcdHBhcmFtLnNldFBhcmVudCh0aGlzKTtcblx0XHRwYXJhbS5zZXRTdWJpbmRleChpKTtcblx0XHRyZXR1cm4gcGFyYW07XG5cdH07XG5cdFxuXHRBcnJheVBhcmFtcy5wcm90b3R5cGUuaGVhZCA9IGZ1bmN0aW9uIChhc3Qpe1xuXHRcdC8vIFwiYXJyYXlwYXJhbXNcIlxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gUGFyYW1MaXN0KCl7IHJldHVybiBMaXN0Tm9kZS5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XG5cdHN1YmNsYXNzJChQYXJhbUxpc3QsTGlzdE5vZGUpO1xuXHRleHBvcnRzLlBhcmFtTGlzdCA9IFBhcmFtTGlzdDsgLy8gZXhwb3J0IGNsYXNzIFxuXHRQYXJhbUxpc3QucHJvdG90eXBlLnNwbGF0ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9zcGxhdDsgfVxuXHRQYXJhbUxpc3QucHJvdG90eXBlLnNldFNwbGF0ID0gZnVuY3Rpb24odil7IHRoaXMuX3NwbGF0ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFBhcmFtTGlzdC5wcm90b3R5cGUuYmxvY2sgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2Jsb2NrOyB9XG5cdFBhcmFtTGlzdC5wcm90b3R5cGUuc2V0QmxvY2sgPSBmdW5jdGlvbih2KXsgdGhpcy5fYmxvY2sgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFBhcmFtTGlzdC5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiAoaW5kZXgsZm9yY2UsbmFtZSl7XG5cdFx0aWYoZm9yY2UgPT09IHVuZGVmaW5lZCkgZm9yY2UgPSBmYWxzZTtcblx0XHRpZihuYW1lID09PSB1bmRlZmluZWQpIG5hbWUgPSBudWxsO1xuXHRcdGlmIChmb3JjZSkge1xuXHRcdFx0d2hpbGUgKHRoaXMuY291bnQoKSA8PSBpbmRleCl7XG5cdFx0XHRcdHRoaXMuYWRkKG5ldyBQYXJhbSh0aGlzLmNvdW50KCkgPT0gaW5kZXggJiYgbmFtZSB8fCAoXCJfXCIgKyB0aGlzLmNvdW50KCkpKSk7XG5cdFx0XHR9O1xuXHRcdFx0Ly8gbmVlZCB0byB2aXNpdCBhdCB0aGUgc2FtZSB0aW1lLCBubz9cblx0XHR9O1xuXHRcdHJldHVybiB0aGlzLmxpc3QoKVtpbmRleF07XG5cdH07XG5cdFxuXHRQYXJhbUxpc3QucHJvdG90eXBlLm1ldGFkYXRhID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uKHBhcikgeyByZXR1cm4gIShwYXIgaW5zdGFuY2VvZiBNZXRhKTsgfSk7XG5cdH07XG5cdFxuXHRQYXJhbUxpc3QucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLm1ldGFkYXRhKCk7XG5cdH07XG5cdFxuXHRQYXJhbUxpc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKCl7XG5cdFx0dGhpcy5fc3BsYXQgPSB0aGlzLmZpbHRlcihmdW5jdGlvbihwYXIpIHsgcmV0dXJuIHBhciBpbnN0YW5jZW9mIFNwbGF0UGFyYW07IH0pWzBdO1xuXHRcdHZhciBibGsgPSB0aGlzLmZpbHRlcihmdW5jdGlvbihwYXIpIHsgcmV0dXJuIHBhciBpbnN0YW5jZW9mIEJsb2NrUGFyYW07IH0pO1xuXHRcdFxuXHRcdGlmIChibGsubGVuZ3RoID4gMSkge1xuXHRcdFx0YmxrWzFdLndhcm4oXCJhIG1ldGhvZCBjYW4gb25seSBoYXZlIG9uZSAmYmxvY2sgcGFyYW1ldGVyXCIpO1xuXHRcdH0gZWxzZSBpZiAoYmxrWzBdICYmIGJsa1swXSAhPSB0aGlzLmxhc3QoKSkge1xuXHRcdFx0YmxrWzBdLndhcm4oXCImYmxvY2sgbXVzdCBiZSB0aGUgbGFzdCBwYXJhbWV0ZXIgb2YgYSBtZXRob2RcIik7XG5cdFx0XHQvLyB3YXJuIFwiJmJsb2NrIG11c3QgYmUgdGhlIGxhc3QgcGFyYW1ldGVyIG9mIGEgbWV0aG9kXCIsIGJsa1swXVxuXHRcdH07XG5cdFx0XG5cdFx0Ly8gYWRkIG1vcmUgd2FybmluZ3MgbGF0ZXIoISlcblx0XHQvLyBzaG91bGQgcHJvYmFibHkgdGhyb3cgZXJyb3IgYXMgd2VsbCB0byBzdG9wIGNvbXBpbGF0aW9uXG5cdFx0XG5cdFx0Ly8gbmVlZCB0byByZWdpc3RlciB0aGUgcmVxdWlyZWQtcGFycyBhcyB2YXJpYWJsZXNcblx0XHRyZXR1cm4gUGFyYW1MaXN0Ll9fc3VwZXJfXy52aXNpdC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7XG5cdH07XG5cdFxuXHRQYXJhbUxpc3QucHJvdG90eXBlLmpzID0gZnVuY3Rpb24gKG8pe1xuXHRcdGlmICh0aGlzLmNvdW50KCkgPT0gMCkgeyByZXR1cm4gRU1QVFkgfTtcblx0XHRpZiAoby5wYXJlbnQoKSBpbnN0YW5jZW9mIEJsb2NrKSB7IHJldHVybiB0aGlzLmhlYWQobykgfTtcblx0XHRcblx0XHQvLyBpdGVtcyA9IG1hcCh8YXJnfCBhcmcubmFtZS5jICkuY29tcGFjdFxuXHRcdC8vIHJldHVybiBudWxsIHVubGVzcyBpdGVtc1swXVxuXHRcdFxuXHRcdGlmIChvLnBhcmVudCgpIGluc3RhbmNlb2YgQ29kZSkge1xuXHRcdFx0Ly8gcmVtb3ZlIHRoZSBzcGxhdCwgZm9yIHN1cmUuLiBuZWVkIHRvIGhhbmRsZSB0aGUgb3RoZXIgaXRlbXMgYXMgd2VsbFxuXHRcdFx0Ly8gdGhpcyBpcyBtZXNzeSB3aXRoIHJlZmVyZW5jZXMgdG8gYXJndmFycyBldGMgZXRjLiBGaXhcblx0XHRcdHZhciBwYXJzID0gdGhpcy5ub2RlcygpO1xuXHRcdFx0Ly8gcGFycyA9IGZpbHRlcih8YXJnfCBhcmcgIT0gQHNwbGF0ICYmICEoYXJnIGlzYSBCbG9ja1BhcmFtKSkgaWYgQHNwbGF0XG5cdFx0XHRpZiAodGhpcy5fc3BsYXQpIHsgcGFycyA9IHRoaXMuZmlsdGVyKGZ1bmN0aW9uKGFyZykgeyByZXR1cm4gKGFyZyBpbnN0YW5jZW9mIFJlcXVpcmVkUGFyYW0pIHx8IChhcmcgaW5zdGFuY2VvZiBPcHRpb25hbFBhcmFtKTsgfSkgfTtcblx0XHRcdHJldHVybiBjb21wYWN0X18ocGFycy5tYXAoZnVuY3Rpb24oYXJnKSB7IHJldHVybiBjX18oYXJnLnZhcm5hbWUoKSk7IH0pKS5qb2luKFwiLFwiKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgXCJub3QgaW1wbGVtZW50ZWQgcGFyYW1saXN0IGpzXCI7XG5cdFx0XHRyZXR1cm4gXCJ0YVwiICsgY29tcGFjdF9fKHRoaXMubWFwKGZ1bmN0aW9uKGFyZykgeyByZXR1cm4gYXJnLmMoKTsgfSkpLmpvaW4oXCIsXCIpO1xuXHRcdH07XG5cdH07XG5cdFxuXHRQYXJhbUxpc3QucHJvdG90eXBlLmhlYWQgPSBmdW5jdGlvbiAobyl7XG5cdFx0dmFyIHJlZyA9IFtdO1xuXHRcdHZhciBvcHQgPSBbXTtcblx0XHR2YXIgYmxrID0gbnVsbDtcblx0XHR2YXIgc3BsYXQgPSBudWxsO1xuXHRcdHZhciBuYW1lZCA9IG51bGw7XG5cdFx0dmFyIGFyeXMgPSBbXTtcblx0XHR2YXIgc2lnbmF0dXJlID0gW107XG5cdFx0dmFyIGlkeCA9IDA7XG5cdFx0XG5cdFx0dGhpcy5ub2RlcygpLmZvckVhY2goZnVuY3Rpb24ocGFyLGkpIHtcblx0XHRcdHBhci5zZXRJbmRleChpZHgpO1xuXHRcdFx0aWYgKHBhciBpbnN0YW5jZW9mIE5hbWVkUGFyYW1zKSB7XG5cdFx0XHRcdHNpZ25hdHVyZS5wdXNoKCduYW1lZCcpO1xuXHRcdFx0XHRuYW1lZCA9IHBhcjtcblx0XHRcdH0gZWxzZSBpZiAocGFyIGluc3RhbmNlb2YgT3B0aW9uYWxQYXJhbSkge1xuXHRcdFx0XHRzaWduYXR1cmUucHVzaCgnb3B0Jyk7XG5cdFx0XHRcdG9wdC5wdXNoKHBhcik7XG5cdFx0XHR9IGVsc2UgaWYgKHBhciBpbnN0YW5jZW9mIEJsb2NrUGFyYW0pIHtcblx0XHRcdFx0c2lnbmF0dXJlLnB1c2goJ2JsaycpO1xuXHRcdFx0XHRibGsgPSBwYXI7XG5cdFx0XHR9IGVsc2UgaWYgKHBhciBpbnN0YW5jZW9mIFNwbGF0UGFyYW0pIHtcblx0XHRcdFx0c2lnbmF0dXJlLnB1c2goJ3NwbGF0Jyk7XG5cdFx0XHRcdHNwbGF0ID0gcGFyO1xuXHRcdFx0XHRpZHggLT0gMTsgLy8gdGhpcyBzaG91bGQgcmVhbGx5IGJlIHJlbW92ZWQgZnJvbSB0aGUgbGlzdCwgbm8/XG5cdFx0XHR9IGVsc2UgaWYgKHBhciBpbnN0YW5jZW9mIEFycmF5UGFyYW1zKSB7XG5cdFx0XHRcdGFyeXMucHVzaChwYXIpO1xuXHRcdFx0XHRzaWduYXR1cmUucHVzaCgnYXJ5Jyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzaWduYXR1cmUucHVzaCgncmVnJyk7XG5cdFx0XHRcdHJlZy5wdXNoKHBhcik7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIGlkeCsrO1xuXHRcdH0pO1xuXHRcdFxuXHRcdGlmIChuYW1lZCkge1xuXHRcdFx0dmFyIG5hbWVkdmFyID0gbmFtZWQudmFyaWFibGUoKTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIHZhciBvcHQgPSBub2Rlcy5maWx0ZXIofG58IG4gaXNhIE9wdGlvbmFsUGFyYW0pXG5cdFx0Ly8gdmFyIGJsayA9IG5vZGVzLmZpbHRlcih8bnwgbiBpc2EgQmxvY2tQYXJhbSlbMF1cblx0XHQvLyB2YXIgc3BsYXQgPSBub2Rlcy5maWx0ZXIofG58IG4gaXNhIFNwbGF0UGFyYW0pWzBdXG5cdFx0XG5cdFx0Ly8gc2ltcGxlIHNpdHVhdGlvbiB3aGVyZSB3ZSBzaW1wbHkgc3dpdGNoXG5cdFx0Ly8gY2FuIHByb2JhYmx5IG9wdGltaXplIGJ5IG5vdCBsb29raW5nIGF0IGFyZ3VtZW50cyBhdCBhbGxcblx0XHR2YXIgYXN0ID0gW107XG5cdFx0dmFyIGlzRnVuYyA9IGZ1bmN0aW9uKGpzKSB7IHJldHVybiAoXCJ0eXBlb2YgXCIgKyBqcyArIFwiID09ICdmdW5jdGlvbidcIik7IH07XG5cdFx0XG5cdFx0Ly8gVGhpcyBpcyBicm9rZW4gd2hlbiBkZWFsaW5nIHdpdGggaWZyYW1lcyBhbmMgWFNTIHNjcmlwdGluZ1xuXHRcdC8vIGJ1dCBmb3Igbm93IGl0IGlzIHRoZSBiZXN0IHRlc3QgZm9yIGFjdHVhbCBhcmd1bWVudHNcblx0XHQvLyBjYW4gYWxzbyBkbyBjb25zdHJ1Y3Rvci5uYW1lID09ICdPYmplY3QnXG5cdFx0dmFyIGlzT2JqID0gZnVuY3Rpb24oanMpIHsgcmV0dXJuIChcIlwiICsganMgKyBcIi5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0XCIpOyB9O1xuXHRcdHZhciBpc250T2JqID0gZnVuY3Rpb24oanMpIHsgcmV0dXJuIChcIlwiICsganMgKyBcIi5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0XCIpOyB9O1xuXHRcdC8vIHNob3VsZCBoYW5kbGUgc29tZSBjb21tb24gY2FzZXMgaW4gYSBjbGVhbmVyIChsZXNzIHZlcmJvc2UpIG1hbm5lclxuXHRcdC8vIGRvZXMgdGhpcyB3b3JrIHdpdGggZGVmYXVsdCBwYXJhbXMgYWZ0ZXIgb3B0aW9uYWwgb25lcz8gSXMgdGhhdCBldmVuIHdvcnRoIGFueXRoaW5nP1xuXHRcdC8vIHRoaXMgb25seSB3b3JrcyBpbiBvbmUgZGlyZWN0aW9uIG5vdywgdW5saWtlIFR1cGxlQXNzaWduXG5cdFx0XG5cdFx0Ly8gd2UgZG9udCByZWFsbHkgY2hlY2sgdGhlIGxlbmd0aCBldGMgbm93IC0tIHNvIGl0IGlzIGJ1Z2d5IGZvciBsb3RzIG9mIGFyZ3VtZW50c1xuXHRcdFxuXHRcdC8vIGlmIHdlIGhhdmUgb3B0aW9uYWwgcGFyYW1zIGluIHRoZSByZWd1bGFyIG9yZGVyIGV0YyB3ZSBjYW4gZ28gdGhlIGVhc3kgcm91dGVcblx0XHQvLyBzbGlnaHRseSBoYWNreSBub3cuIFNob3VsZCByZWZhY3RvciBhbGwgb2YgdGhlc2UgdG8gdXNlIHRoZSBzaWduYXR1cmU/XG5cdFx0aWYgKCFuYW1lZCAmJiAhc3BsYXQgJiYgIWJsayAmJiBvcHQubGVuZ3RoID4gMCAmJiBzaWduYXR1cmUuam9pbihcIiBcIikubWF0Y2goL29wdCQvKSkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbl8gPSBvcHQubGVuZ3RoLCBwYXI7IGkgPCBsZW5fOyBpKyspIHtcblx0XHRcdFx0cGFyID0gb3B0W2ldO1xuXHRcdFx0XHRhc3QucHVzaCgoXCJpZihcIiArIChwYXIubmFtZSgpLmMoKSkgKyBcIiA9PT0gdW5kZWZpbmVkKSBcIiArIChwYXIubmFtZSgpLmMoKSkgKyBcIiA9IFwiICsgKHBhci5kZWZhdWx0cygpLmMoKSkpKTtcblx0XHRcdH07XG5cdFx0fSBlbHNlIGlmIChuYW1lZCAmJiAhc3BsYXQgJiYgIWJsayAmJiBvcHQubGVuZ3RoID09IDApIHsgLy8gYW5kIG5vIGJsb2NrPyFcblx0XHRcdC8vIGRpZmZlcmVudCBzaG9ydGhhbmRzXG5cdFx0XHQvLyBpZiBuYW1lZFxuXHRcdFx0YXN0LnB1c2goKFwiaWYoIVwiICsgKG5hbWVkdmFyLmMoKSkgKyBcInx8XCIgKyBpc250T2JqKG5hbWVkdmFyLmMoKSkgKyBcIikgXCIgKyAobmFtZWR2YXIuYygpKSArIFwiID0gXFx7XFx9XCIpKTtcblx0XHR9IGVsc2UgaWYgKGJsayAmJiBvcHQubGVuZ3RoID09IDEgJiYgIXNwbGF0ICYmICFuYW1lZCkge1xuXHRcdFx0dmFyIG9wID0gb3B0WzBdO1xuXHRcdFx0dmFyIG9wbiA9IG9wLm5hbWUoKS5jKCk7XG5cdFx0XHR2YXIgYm4gPSBibGsubmFtZSgpLmMoKTtcblx0XHRcdGFzdC5wdXNoKChcImlmKFwiICsgYm4gKyBcIj09dW5kZWZpbmVkICYmIFwiICsgaXNGdW5jKG9wbikgKyBcIikgXCIgKyBibiArIFwiID0gXCIgKyBvcG4gKyBcIixcIiArIG9wbiArIFwiID0gXCIgKyAob3AuZGVmYXVsdHMoKS5jKCkpKSk7XG5cdFx0XHRhc3QucHVzaCgoXCJpZihcIiArIG9wbiArIFwiPT11bmRlZmluZWQpIFwiICsgb3BuICsgXCIgPSBcIiArIChvcC5kZWZhdWx0cygpLmMoKSkpKTtcblx0XHR9IGVsc2UgaWYgKGJsayAmJiBuYW1lZCAmJiBvcHQubGVuZ3RoID09IDAgJiYgIXNwbGF0KSB7XG5cdFx0XHRibiA9IGJsay5uYW1lKCkuYygpO1xuXHRcdFx0YXN0LnB1c2goKFwiaWYoXCIgKyBibiArIFwiPT11bmRlZmluZWQgJiYgXCIgKyBpc0Z1bmMobmFtZWR2YXIuYygpKSArIFwiKSBcIiArIGJuICsgXCIgPSBcIiArIChuYW1lZHZhci5jKCkpICsgXCIsXCIgKyAobmFtZWR2YXIuYygpKSArIFwiID0gXFx7XFx9XCIpKTtcblx0XHRcdGFzdC5wdXNoKChcImVsc2UgaWYoIVwiICsgKG5hbWVkdmFyLmMoKSkgKyBcInx8XCIgKyBpc250T2JqKG5hbWVkdmFyLmMoKSkgKyBcIikgXCIgKyAobmFtZWR2YXIuYygpKSArIFwiID0gXFx7XFx9XCIpKTtcblx0XHR9IGVsc2UgaWYgKG9wdC5sZW5ndGggPiAwIHx8IHNwbGF0KSB7IC8vICYmIGJsayAgIyAmJiAhc3BsYXRcblx0XHRcdFxuXHRcdFx0dmFyIGFyZ3ZhciA9IHRoaXMuc2NvcGVfXygpLnRlbXBvcmFyeSh0aGlzLHtwb29sOiAnYXJndW1lbnRzJ30pLnByZWRlY2xhcmVkKCkuYygpO1xuXHRcdFx0dmFyIGxlbiA9IHRoaXMuc2NvcGVfXygpLnRlbXBvcmFyeSh0aGlzLHtwb29sOiAnY291bnRlcid9KS5wcmVkZWNsYXJlZCgpLmMoKTtcblx0XHRcdFxuXHRcdFx0dmFyIGxhc3QgPSAoXCJcIiArIGFyZ3ZhciArIFwiW1wiICsgbGVuICsgXCItMV1cIik7XG5cdFx0XHR2YXIgcG9wID0gKFwiXCIgKyBhcmd2YXIgKyBcIlstLVwiICsgbGVuICsgXCJdXCIpO1xuXHRcdFx0YXN0LnB1c2goKFwidmFyIFwiICsgYXJndmFyICsgXCIgPSBhcmd1bWVudHMsIFwiICsgbGVuICsgXCIgPSBcIiArIGFyZ3ZhciArIFwiLmxlbmd0aFwiKSk7XG5cdFx0XHRcblx0XHRcdGlmIChibGspIHtcblx0XHRcdFx0Ym4gPSBibGsubmFtZSgpLmMoKTtcblx0XHRcdFx0aWYgKHNwbGF0KSB7XG5cdFx0XHRcdFx0YXN0LnB1c2goKFwidmFyIFwiICsgYm4gKyBcIiA9IFwiICsgaXNGdW5jKGxhc3QpICsgXCIgPyBcIiArIHBvcCArIFwiIDogbnVsbFwiKSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAocmVnLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHQvLyBhc3QucHVzaCBcIi8vIHNldmVyYWwgcmVncyByZWFsbHk/XCJcblx0XHRcdFx0XHRhc3QucHVzaCgoXCJ2YXIgXCIgKyBibiArIFwiID0gXCIgKyBsZW4gKyBcIiA+IFwiICsgKHJlZy5sZW5ndGgpICsgXCIgJiYgXCIgKyBpc0Z1bmMobGFzdCkgKyBcIiA/IFwiICsgcG9wICsgXCIgOiBudWxsXCIpKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhc3QucHVzaCgoXCJ2YXIgXCIgKyBibiArIFwiID0gXCIgKyBpc0Z1bmMobGFzdCkgKyBcIiA/IFwiICsgcG9wICsgXCIgOiBudWxsXCIpKTtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8vIGlmIHdlIGhhdmUgbmFtZWQgcGFyYW1zIC0gbG9vayBmb3IgdGhlbSBiZWZvcmUgc3BsYXRcblx0XHRcdC8vIHNob3VsZCBwcm9iYWJseSBsb29wIHRocm91Z2ggcGFycyBpbiB0aGUgc2FtZSBvcmRlciB0aGV5IHdlcmUgYWRkZWRcblx0XHRcdC8vIHNob3VsZCBpdCBiZSBwcmlvcml0aXplZCBhYm92ZSBvcHRpb25hbCBvYmplY3RzPz9cblx0XHRcdGlmIChuYW1lZCkge1xuXHRcdFx0XHQvLyBzaG91bGQgbm90IGluY2x1ZGUgaXQgd2hlbiB0aGVyZSBpcyBhIHNwbGF0P1xuXHRcdFx0XHRhc3QucHVzaCgoXCJ2YXIgXCIgKyAobmFtZWR2YXIuYygpKSArIFwiID0gXCIgKyBsYXN0ICsgXCImJlwiICsgaXNPYmoobGFzdCkgKyBcIiA/IFwiICsgcG9wICsgXCIgOiBcXHtcXH1cIikpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Zm9yICh2YXIgaTEgPSAwLCBsZW5fID0gb3B0Lmxlbmd0aCwgcGFyMTsgaTEgPCBsZW5fOyBpMSsrKSB7XG5cdFx0XHRcdHBhcjEgPSBvcHRbaTFdO1xuXHRcdFx0XHRhc3QucHVzaCgoXCJpZihcIiArIGxlbiArIFwiIDwgXCIgKyAocGFyMS5pbmRleCgpICsgMSkgKyBcIikgXCIgKyAocGFyMS5uYW1lKCkuYygpKSArIFwiID0gXCIgKyAocGFyMS5kZWZhdWx0cygpLmMoKSkpKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8vIGFkZCB0aGUgc3BsYXRcblx0XHRcdGlmIChzcGxhdCkge1xuXHRcdFx0XHR2YXIgc24gPSBzcGxhdC5uYW1lKCkuYygpO1xuXHRcdFx0XHR2YXIgc2kgPSBzcGxhdC5pbmRleCgpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHNpID09IDApIHtcblx0XHRcdFx0XHRhc3QucHVzaCgoXCJ2YXIgXCIgKyBzbiArIFwiID0gbmV3IEFycmF5KFwiICsgbGVuICsgXCI+XCIgKyBzaSArIFwiID8gXCIgKyBsZW4gKyBcIiA6IDApXCIpKTtcblx0XHRcdFx0XHRhc3QucHVzaCgoXCJ3aGlsZShcIiArIGxlbiArIFwiPlwiICsgc2kgKyBcIikgXCIgKyBzbiArIFwiW1wiICsgbGVuICsgXCItMV0gPSBcIiArIHBvcCkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGFzdC5wdXNoKChcInZhciBcIiArIHNuICsgXCIgPSBuZXcgQXJyYXkoXCIgKyBsZW4gKyBcIj5cIiArIHNpICsgXCIgPyBcIiArIGxlbiArIFwiLVwiICsgc2kgKyBcIiA6IDApXCIpKTtcblx0XHRcdFx0XHRhc3QucHVzaCgoXCJ3aGlsZShcIiArIGxlbiArIFwiPlwiICsgc2kgKyBcIikgXCIgKyBzbiArIFwiWy0tXCIgKyBsZW4gKyBcIiAtIFwiICsgc2kgKyBcIl0gPSBcIiArIGFyZ3ZhciArIFwiW1wiICsgbGVuICsgXCJdXCIpKTtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8vIGlmIG5hbWVkXG5cdFx0XHQvLyBcdGZvciBrLGkgaW4gbmFtZWQubm9kZXNcblx0XHRcdC8vIFx0XHQjIE9QKCcuJyxuYW1lZHZhcikgPC0gdGhpcyBpcyB0aGUgcmlnaHQgd2F5LCB3aXRoIGludmFsaWQgbmFtZXMgZXRjXG5cdFx0XHQvLyBcdFx0dmFyIG9wID0gT1AoJy4nLG5hbWVkdmFyLGsua2V5KS5jXG5cdFx0XHQvLyBcdFx0YXN0LnB1c2ggXCJ2YXIge2sua2V5LmN9ID0ge29wfSAhPT0gdW5kZWZpbmVkID8ge29wfSA6IHtrLnZhbHVlLmN9XCJcblx0XHRcdFxuXHRcdFx0Ly8gaWYgbmFtZWRcblx0XHRcdFxuXHRcdFx0Ly8gcmV0dXJuIGFzdC5qb2luKFwiO1xcblwiKSArIFwiO1wiXG5cdFx0XHQvLyByZXR1cm4gXCJpZih7b3B0WzBdLm5hbWUuY30gaW5zdGFuY2VvZiBGdW5jdGlvbikge2Jsay5jfSA9IHtvcHRbMF0uY307XCJcblx0XHR9IGVsc2UgaWYgKG9wdC5sZW5ndGggPiAwKSB7XG5cdFx0XHRmb3IgKHZhciBpMiA9IDAsIGxlbl8gPSBvcHQubGVuZ3RoLCBwYXIyOyBpMiA8IGxlbl87IGkyKyspIHtcblx0XHRcdFx0cGFyMiA9IG9wdFtpMl07XG5cdFx0XHRcdGFzdC5wdXNoKChcImlmKFwiICsgKHBhcjIubmFtZSgpLmMoKSkgKyBcIiA9PT0gdW5kZWZpbmVkKSBcIiArIChwYXIyLm5hbWUoKS5jKCkpICsgXCIgPSBcIiArIChwYXIyLmRlZmF1bHRzKCkuYygpKSkpO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIG5vdyBzZXQgc3R1ZmYgaWYgbmFtZWQgcGFyYW1zKCEpXG5cdFx0XG5cdFx0aWYgKG5hbWVkKSB7XG5cdFx0XHRmb3IgKHZhciBpMyA9IDAsIGFyeSA9IGl0ZXIkKG5hbWVkLm5vZGVzKCkpLCBsZW5fID0gYXJ5Lmxlbmd0aCwgazsgaTMgPCBsZW5fOyBpMysrKSB7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nIFwibmFtZWQgdmFyIHtrLmN9XCJcblx0XHRcdFx0ayA9IGFyeVtpM107XG5cdFx0XHRcdG9wID0gT1AoJy4nLG5hbWVkdmFyLGsuYygpKS5jKCk7XG5cdFx0XHRcdGFzdC5wdXNoKChcInZhciBcIiArIChrLmMoKSkgKyBcIiA9IFwiICsgb3AgKyBcIiAhPT0gdW5kZWZpbmVkID8gXCIgKyBvcCArIFwiIDogXCIgKyAoay5kZWZhdWx0cygpLmMoKSkpKTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoYXJ5cy5sZW5ndGgpIHtcblx0XHRcdGZvciAodmFyIGk0ID0gMCwgbGVuXyA9IGFyeXMubGVuZ3RoOyBpNCA8IGxlbl87IGk0KyspIHtcblx0XHRcdFx0Ly8gY3JlYXRlIHR1cGxlc1xuXHRcdFx0XHQvLyBwIFwiYWRkaW5nIGFycmF5cGFyYW1zXCJcblx0XHRcdFx0YXJ5c1tpNF0uaGVhZChvLGFzdCx0aGlzKTtcblx0XHRcdFx0Ly8gYXN0LnB1c2ggdi5jXG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0XG5cdFx0Ly8gaWYgb3B0Omxlbmd0aCA9PSAwXG5cdFx0cmV0dXJuIGFzdC5sZW5ndGggPiAwID8gKChhc3Quam9pbihcIjtcXG5cIikgKyBcIjtcIikpIDogKEVNUFRZKTtcblx0fTtcblx0XG5cdFxuXHQvLyBMZWdhY3kuIFNob3VsZCBtb3ZlIGF3YXkgZnJvbSB0aGlzP1xuXHRmdW5jdGlvbiBWYXJpYWJsZURlY2xhcmF0aW9uKCl7IHJldHVybiBMaXN0Tm9kZS5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XG5cdHN1YmNsYXNzJChWYXJpYWJsZURlY2xhcmF0aW9uLExpc3ROb2RlKTtcblx0ZXhwb3J0cy5WYXJpYWJsZURlY2xhcmF0aW9uID0gVmFyaWFibGVEZWNsYXJhdGlvbjsgLy8gZXhwb3J0IGNsYXNzIFxuXHRWYXJpYWJsZURlY2xhcmF0aW9uLnByb3RvdHlwZS5raW5kID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9raW5kOyB9XG5cdFZhcmlhYmxlRGVjbGFyYXRpb24ucHJvdG90eXBlLnNldEtpbmQgPSBmdW5jdGlvbih2KXsgdGhpcy5fa2luZCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0Ly8gd2Ugd2FudCB0byByZWdpc3RlciB0aGVzZSB2YXJpYWJsZXMgaW5cblx0VmFyaWFibGVEZWNsYXJhdGlvbi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG5hbWUsaW5pdCxwb3Mpe1xuXHRcdGlmKHBvcyA9PT0gdW5kZWZpbmVkKSBwb3MgPSAtMTtcblx0XHR2YXIgdmFyZGVjID0gbmV3IFZhcmlhYmxlRGVjbGFyYXRvcihuYW1lLGluaXQpO1xuXHRcdGlmIChuYW1lIGluc3RhbmNlb2YgVmFyaWFibGUpIHsgKHZhcmRlYy5zZXRWYXJpYWJsZShuYW1lKSxuYW1lKSB9O1xuXHRcdHBvcyA9PSAwID8gKHRoaXMudW5zaGlmdCh2YXJkZWMpKSA6ICh0aGlzLnB1c2godmFyZGVjKSk7XG5cdFx0cmV0dXJuIHZhcmRlYztcblx0XHRcblx0XHQvLyBUT0RPICh0YXJnZXQpIDw8IChub2RlKSByZXdyaXRlcyB0byBhIGNhY2hpbmcgcHVzaCB3aGljaCByZXR1cm5zIG5vZGVcblx0fTtcblx0XG5cdC8vIGRlZiByZW1vdmUgaXRlbVxuXHQvLyBcdGlmIGl0ZW0gaXNhIFZhcmlhYmxlXG5cdC8vIFx0XHRtYXAgZG8gfHYsaXxcblx0Ly8gXHRcdFx0aWYgdi52YXJpYWJsZSA9PSBpdGVtXG5cdC8vIFx0XHRcdFx0cCBcImZvdW5kIHZhcmlhYmxlIHRvIHJlbW92ZVwiXG5cdC8vIFx0XHRcdFx0c3VwZXIucmVtb3ZlKHYpXG5cdC8vIFx0ZWxzZVxuXHQvLyBcdFx0c3VwZXIucmVtb3ZlKGl0ZW0pXG5cdC8vIFx0c2VsZlxuXHRcblx0VmFyaWFibGVEZWNsYXJhdGlvbi5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChsaXN0KXtcblx0XHQvLyB0ZW1wb3Jhcnkgc29sdXRpb24hISFcblx0XHRyZXR1cm4gbGlzdC5tYXAoZnVuY3Rpb24ocGFyKSB7IHJldHVybiBuZXcgVmFyaWFibGVEZWNsYXJhdG9yKHBhci5uYW1lKCkscGFyLmRlZmF1bHRzKCkscGFyLnNwbGF0KCkpOyB9KTtcblx0fTtcblx0XG5cdFZhcmlhYmxlRGVjbGFyYXRpb24ucHJvdG90eXBlLmlzRXhwcmVzc2FibGUgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5ub2RlcygpLmV2ZXJ5KGZ1bmN0aW9uKGl0ZW0pIHsgcmV0dXJuIGl0ZW0uaXNFeHByZXNzYWJsZSgpOyB9KTtcblx0fTtcblx0XG5cdFZhcmlhYmxlRGVjbGFyYXRpb24ucHJvdG90eXBlLmpzID0gZnVuY3Rpb24gKG8pe1xuXHRcdGlmICh0aGlzLmNvdW50KCkgPT0gMCkgeyByZXR1cm4gRU1QVFkgfTtcblx0XHRcblx0XHRpZiAodGhpcy5jb3VudCgpID09IDEgJiYgISh0aGlzLmlzRXhwcmVzc2FibGUoKSkpIHtcblx0XHRcdC8vIHAgXCJTSE9VTEQgQUxURVIgVkFSREVDISEhXCIuY3lhblxuXHRcdFx0dGhpcy5maXJzdCgpLnZhcmlhYmxlKCkuYXV0b2RlY2xhcmUoKTtcblx0XHRcdHZhciBub2RlID0gdGhpcy5maXJzdCgpLmFzc2lnbm1lbnQoKTtcblx0XHRcdHJldHVybiBub2RlLmMoKTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIEZJWCBQRVJGT1JNQU5DRVxuXHRcdHZhciBvdXQgPSBjb21wYWN0X18oY2FyeV9fKHRoaXMubm9kZXMoKSkpLmpvaW4oXCIsIFwiKTtcblx0XHRyZXR1cm4gb3V0ID8gKChcInZhciBcIiArIG91dCkpIDogKFwiXCIpO1xuXHRcdC8vIFwidmFyIFwiICsgY29tcGFjdF9fKGNhcnlfXyhub2RlcykpLmpvaW4oXCIsIFwiKSArIFwiXCJcblx0fTtcblx0XG5cdGZ1bmN0aW9uIFZhcmlhYmxlRGVjbGFyYXRvcigpeyByZXR1cm4gUGFyYW0uYXBwbHkodGhpcyxhcmd1bWVudHMpIH07XG5cdFxuXHRzdWJjbGFzcyQoVmFyaWFibGVEZWNsYXJhdG9yLFBhcmFtKTtcblx0ZXhwb3J0cy5WYXJpYWJsZURlY2xhcmF0b3IgPSBWYXJpYWJsZURlY2xhcmF0b3I7IC8vIGV4cG9ydCBjbGFzcyBcblx0VmFyaWFibGVEZWNsYXJhdG9yLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICgpe1xuXHRcdC8vIGV2ZW4gaWYgd2Ugc2hvdWxkIHRyYXZlcnNlIHRoZSBkZWZhdWx0cyBhcyBpZiB0aGlzIHZhcmlhYmxlIGRvZXMgbm90IGV4aXN0XG5cdFx0Ly8gd2UgbmVlZCB0byBwcmVyZWdpc3RlciBpdCBhbmQgdGhlbiBhY3RpdmF0ZSBpdCBsYXRlclxuXHRcdHZhciB2YXJpYWJsZV8sIHZfO1xuXHRcdCh2YXJpYWJsZV8gPSB0aGlzLnZhcmlhYmxlKCkpIHx8ICgodGhpcy5zZXRWYXJpYWJsZSh2XyA9IHRoaXMuc2NvcGVfXygpLnJlZ2lzdGVyKHRoaXMubmFtZSgpLG51bGwpKSx2XykpO1xuXHRcdGlmICh0aGlzLmRlZmF1bHRzKCkpIHsgdGhpcy5kZWZhdWx0cygpLnRyYXZlcnNlKCkgfTtcblx0XHQvLyBXQVJOIHdoYXQgaWYgaXQgaXMgYWxyZWFkeSBkZWNsYXJlZD9cblx0XHR0aGlzLnZhcmlhYmxlKCkuc2V0RGVjbGFyYXRvcih0aGlzKTtcblx0XHR0aGlzLnZhcmlhYmxlKCkuYWRkUmVmZXJlbmNlKHRoaXMubmFtZSgpKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8vIG5lZWRzIHRvIGJlIGxpbmtlZCB1cCB0byB0aGUgYWN0dWFsIHNjb3BlZCB2YXJpYWJsZXMsIG5vP1xuXHRWYXJpYWJsZURlY2xhcmF0b3IucHJvdG90eXBlLmpzID0gZnVuY3Rpb24gKG8pe1xuXHRcdGlmICh0aGlzLnZhcmlhYmxlKCkuX3Byb3h5KSB7IHJldHVybiBudWxsIH07XG5cdFx0XG5cdFx0dmFyIGRlZnMgPSB0aGlzLmRlZmF1bHRzKCk7XG5cdFx0Ly8gRklYTUUgbmVlZCB0byBkZWFsIHdpdGggdmFyLWRlZmluZXMgd2l0aGluIG90aGVyIHN0YXRlbWVudHMgZXRjXG5cdFx0Ly8gRklYTUUgbmVlZCBiZXR0ZXIgc3ludGF4IGZvciB0aGlzXG5cdFx0aWYgKGRlZnMgIT0gbnVsbCAmJiBkZWZzICE9IHVuZGVmaW5lZCkge1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgXCJkZWZhdWx0cyBpcyB7ZGVmYXVsdHN9XCJcblx0XHRcdGlmIChkZWZzIGluc3RhbmNlb2YgTm9kZSkgeyBkZWZzID0gZGVmcy5jKHtleHByZXNzaW9uOiB0cnVlfSkgfTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIChcIlwiICsgKHRoaXMudmFyaWFibGUoKS5jKCkpICsgXCIgPSBcIiArIGRlZnMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gKFwiXCIgKyAodGhpcy52YXJpYWJsZSgpLmMoKSkpO1xuXHRcdH07XG5cdH07XG5cdFxuXHRWYXJpYWJsZURlY2xhcmF0b3IucHJvdG90eXBlLmFjY2Vzc29yID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRcblx0Ly8gVE9ETyBjbGVhbiB1cCBhbmQgcmVmYWN0b3IgYWxsIHRoZSBkaWZmZXJlbnQgcmVwcmVzZW50YXRpb25zIG9mIHZhcnNcblx0Ly8gVmFyTmFtZSwgVmFyUmVmZXJlbmNlLCBMb2NhbFZhckFjY2Vzcz9cblx0ZnVuY3Rpb24gVmFyTmFtZShhLGIpe1xuXHRcdFZhck5hbWUuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtcblx0XHR0aGlzLl9zcGxhdCA9IGI7XG5cdH07XG5cdFxuXHRzdWJjbGFzcyQoVmFyTmFtZSxWYWx1ZU5vZGUpO1xuXHRleHBvcnRzLlZhck5hbWUgPSBWYXJOYW1lOyAvLyBleHBvcnQgY2xhc3MgXG5cdFZhck5hbWUucHJvdG90eXBlLnZhcmlhYmxlID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl92YXJpYWJsZTsgfVxuXHRWYXJOYW1lLnByb3RvdHlwZS5zZXRWYXJpYWJsZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl92YXJpYWJsZSA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRWYXJOYW1lLnByb3RvdHlwZS5zcGxhdCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fc3BsYXQ7IH1cblx0VmFyTmFtZS5wcm90b3R5cGUuc2V0U3BsYXQgPSBmdW5jdGlvbih2KXsgdGhpcy5fc3BsYXQgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFZhck5hbWUucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKCl7XG5cdFx0Ly8gcCBcInZpc2l0aW5nIHZhcm5hbWUoISlcIiwgdmFsdWUuY1xuXHRcdC8vIHNob3VsZCB3ZSBub3QgbG9va3VwIGluc3RlYWQ/XG5cdFx0Ly8gRklYTUUgcCBcInJlZ2lzdGVyIHZhbHVlIHt2YWx1ZS5jfVwiXG5cdFx0dmFyIHZhcmlhYmxlXywgdl87XG5cdFx0KHZhcmlhYmxlXyA9IHRoaXMudmFyaWFibGUoKSkgfHwgKCh0aGlzLnNldFZhcmlhYmxlKHZfID0gdGhpcy5zY29wZV9fKCkucmVnaXN0ZXIodGhpcy52YWx1ZSgpLmMoKSxudWxsKSksdl8pKTtcblx0XHR0aGlzLnZhcmlhYmxlKCkuc2V0RGVjbGFyYXRvcih0aGlzKTtcblx0XHR0aGlzLnZhcmlhYmxlKCkuYWRkUmVmZXJlbmNlKHRoaXMudmFsdWUoKSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRWYXJOYW1lLnByb3RvdHlwZS5qcyA9IGZ1bmN0aW9uIChvKXtcblx0XHRyZXR1cm4gdGhpcy52YXJpYWJsZSgpLmMoKTtcblx0fTtcblx0XG5cdFZhck5hbWUucHJvdG90eXBlLmMgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy52YXJpYWJsZSgpLmMoKTtcblx0fTtcblx0XG5cdFxuXHRmdW5jdGlvbiBWYXJMaXN0KHQsbCxyKXtcblx0XHR0aGlzLl90cmF2ZXJzZWQgPSBmYWxzZTtcblx0XHR0aGlzLl90eXBlID0gdGhpcy50eXBlKCk7XG5cdFx0dGhpcy5fbGVmdCA9IGw7XG5cdFx0dGhpcy5fcmlnaHQgPSByO1xuXHR9O1xuXHRcblx0c3ViY2xhc3MkKFZhckxpc3QsTm9kZSk7XG5cdGV4cG9ydHMuVmFyTGlzdCA9IFZhckxpc3Q7IC8vIGV4cG9ydCBjbGFzcyBcblx0VmFyTGlzdC5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fdHlwZTsgfVxuXHRWYXJMaXN0LnByb3RvdHlwZS5zZXRUeXBlID0gZnVuY3Rpb24odil7IHRoaXMuX3R5cGUgPSB2OyByZXR1cm4gdGhpczsgfTsgLy8gbGV0IC8gdmFyIC8gY29uc3Rcblx0VmFyTGlzdC5wcm90b3R5cGUubGVmdCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fbGVmdDsgfVxuXHRWYXJMaXN0LnByb3RvdHlwZS5zZXRMZWZ0ID0gZnVuY3Rpb24odil7IHRoaXMuX2xlZnQgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0VmFyTGlzdC5wcm90b3R5cGUucmlnaHQgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3JpZ2h0OyB9XG5cdFZhckxpc3QucHJvdG90eXBlLnNldFJpZ2h0ID0gZnVuY3Rpb24odil7IHRoaXMuX3JpZ2h0ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHQvLyBmb3JtYXQgOnR5cGUsIDpsZWZ0LCA6cmlnaHRcblx0XG5cdC8vIHNob3VsZCB0aHJvdyBlcnJvciBpZiB0aGVyZSBhcmUgbW9yZSB2YWx1ZXMgb24gcmlnaHQgdGhhbiBsZWZ0XG5cdFxuXHRWYXJMaXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICgpe1xuXHRcdFxuXHRcdC8vIHdlIG5lZWQgdG8gY2FyZWZ1bGx5IHRyYXZlcnNlIGNoaWxkcmVuIGluIHRoZSByaWdodCBvcmRlclxuXHRcdC8vIHNpbmNlIHdlIHNob3VsZCBiZSBhYmxlIHRvIHJlZmVyZW5jZVxuXHRcdHZhciByO1xuXHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJCh0aGlzLmxlZnQoKSksIGxlbiA9IGFyeS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0YXJ5W2ldLnRyYXZlcnNlKCk7IC8vIHRoaXMgc2hvdWxkIHJlYWxseSBiZSBhIHZhci1kZWNsYXJhdGlvblxuXHRcdFx0aWYgKHIgPSB0aGlzLnJpZ2h0KClbaV0pIHsgci50cmF2ZXJzZSgpIH07XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFZhckxpc3QucHJvdG90eXBlLmpzID0gZnVuY3Rpb24gKG8pe1xuXHRcdC8vIGZvciB0aGUgcmVndWxhciBpdGVtcyBcblx0XHR2YXIgcGFpcnMgPSBbXTtcblx0XHR2YXIgbGwgPSB0aGlzLmxlZnQoKS5sZW5ndGg7XG5cdFx0dmFyIHJsID0gdGhpcy5yaWdodCgpLmxlbmd0aDtcblx0XHR2YXIgdiA9IG51bGw7XG5cdFx0XG5cdFx0Ly8gc3BsYXR0aW5nIGhlcmUgd2UgY29tZVxuXHRcdGlmIChsbCA+IDEgJiYgcmwgPT0gMSkge1xuXHRcdFx0dGhpcy5wKFwibXVsdGlhc3NpZ24hXCIpO1xuXHRcdFx0dmFyIHIgPSB0aGlzLnJpZ2h0KClbMF07XG5cdFx0XHRyLmNhY2hlKCk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQodGhpcy5sZWZ0KCkpLCBsZW4gPSBhcnkubGVuZ3RoLCBsOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0bCA9IGFyeVtpXTtcblx0XHRcdFx0aWYgKGwuc3BsYXQoKSkge1xuXHRcdFx0XHRcdHRocm93IFwibm90IHN1cHBvcnRlZD9cIjtcblx0XHRcdFx0XHR0aGlzLnAoXCJzcGxhdFwiKTsgLy8gRklYIHJlaW1wbGVtZW50IHNsaWNlP1xuXHRcdFx0XHRcdGlmIChpID09IGxsIC0gMSkge1xuXHRcdFx0XHRcdFx0diA9IHRoaXMudXRpbCgpLnNsaWNlKHIsaSk7XG5cdFx0XHRcdFx0XHR0aGlzLnAoXCJsYXN0XCIpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR2ID0gdGhpcy51dGlsKCkuc2xpY2UocixpLC0obGwgLSBpKSArIDEpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0diA9IE9QKCcuJyxyLG51bV9fKGkpKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdHBhaXJzLnB1c2goT1AoJz0nLGwsdikpO1xuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICh2YXIgaTEgPSAwLCBhcnkgPSBpdGVyJCh0aGlzLmxlZnQoKSksIGxlbiA9IGFyeS5sZW5ndGgsIGwxOyBpMSA8IGxlbjsgaTErKykge1xuXHRcdFx0XHRsMSA9IGFyeVtpMV07XG5cdFx0XHRcdHIgPSB0aGlzLnJpZ2h0KClbaTFdO1xuXHRcdFx0XHRwYWlycy5wdXNoKHIgPyAoT1AoJz0nLGwxLnZhcmlhYmxlKCkuYWNjZXNzb3IoKSxyKSkgOiAobDEpKTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gKFwidmFyIFwiICsgKHBhaXJzLmMoKSkpO1xuXHR9O1xuXHRcblx0XG5cdC8vIENPREVcblx0XG5cdGZ1bmN0aW9uIENvZGUoKXsgcmV0dXJuIE5vZGUuYXBwbHkodGhpcyxhcmd1bWVudHMpIH07XG5cdFxuXHRzdWJjbGFzcyQoQ29kZSxOb2RlKTtcblx0ZXhwb3J0cy5Db2RlID0gQ29kZTsgLy8gZXhwb3J0IGNsYXNzIFxuXHRDb2RlLnByb3RvdHlwZS5oZWFkID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9oZWFkOyB9XG5cdENvZGUucHJvdG90eXBlLnNldEhlYWQgPSBmdW5jdGlvbih2KXsgdGhpcy5faGVhZCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRDb2RlLnByb3RvdHlwZS5ib2R5ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9ib2R5OyB9XG5cdENvZGUucHJvdG90eXBlLnNldEJvZHkgPSBmdW5jdGlvbih2KXsgdGhpcy5fYm9keSA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRDb2RlLnByb3RvdHlwZS5zY29wZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fc2NvcGU7IH1cblx0Q29kZS5wcm90b3R5cGUuc2V0U2NvcGUgPSBmdW5jdGlvbih2KXsgdGhpcy5fc2NvcGUgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0Q29kZS5wcm90b3R5cGUucGFyYW1zID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9wYXJhbXM7IH1cblx0Q29kZS5wcm90b3R5cGUuc2V0UGFyYW1zID0gZnVuY3Rpb24odil7IHRoaXMuX3BhcmFtcyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0Q29kZS5wcm90b3R5cGUuc2NvcGV0eXBlID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIFNjb3BlO1xuXHR9O1xuXHRcblx0Q29kZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAoKXtcblx0XHRpZiAodGhpcy5fc2NvcGUpIHsgdGhpcy5fc2NvcGUudmlzaXQoKSB9O1xuXHRcdC8vIEBzY29wZS5wYXJlbnQgPSBTVEFDSy5zY29wZSgxKSBpZiBAc2NvcGVcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFxuXHQvLyBSZW5hbWUgdG8gUHJvZ3JhbT9cblx0ZnVuY3Rpb24gUm9vdChib2R5LG9wdHMpe1xuXHRcdC8vIHAgXCJjcmVhdGUgcm9vdCFcIlxuXHRcdHRoaXMuX3RyYXZlcnNlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX2JvZHkgPSBibGtfXyhib2R5KTtcblx0XHR0aGlzLl9zY29wZSA9IG5ldyBSb290U2NvcGUodGhpcyxudWxsKTtcblx0XHR0aGlzLl9vcHRpb25zID0ge307XG5cdH07XG5cdFxuXHRzdWJjbGFzcyQoUm9vdCxDb2RlKTtcblx0ZXhwb3J0cy5Sb290ID0gUm9vdDsgLy8gZXhwb3J0IGNsYXNzIFxuXHRSb290LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICgpe1xuXHRcdFJPT1QgPSBTVEFDSy5ST09UID0gdGhpcy5fc2NvcGU7XG5cdFx0dGhpcy5zY29wZSgpLnZpc2l0KCk7XG5cdFx0cmV0dXJuIHRoaXMuYm9keSgpLnRyYXZlcnNlKCk7XG5cdH07XG5cdFxuXHRSb290LnByb3RvdHlwZS5jb21waWxlID0gZnVuY3Rpb24gKG8pe1xuXHRcdFNUQUNLLnJlc2V0KCk7IC8vIC0tIG5lc3RlZCBjb21waWxhdGlvbiBkb2VzIG5vdCB3b3JrIG5vd1xuXHRcdE9QVFMgPSBTVEFDSy5fb3B0aW9ucyA9IHRoaXMuX29wdGlvbnMgPSBvIHx8IHt9O1xuXHRcdFxuXHRcdHRoaXMudHJhdmVyc2UoKTtcblx0XHRcblx0XHR2YXIgb3V0ID0gdGhpcy5jKCk7XG5cdFx0dmFyIHJlc3VsdCA9IHtcblx0XHRcdGpzOiBvdXQsXG5cdFx0XHRhc3Q6IHRoaXMsXG5cdFx0XHR3YXJuaW5nczogdGhpcy5zY29wZSgpLndhcm5pbmdzKCksXG5cdFx0XHRvcHRpb25zOiBvLFxuXHRcdFx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5qczsgfVxuXHRcdH07XG5cdFx0aWYgKG8uc291cmNlTWFwSW5saW5lIHx8IG8uc291cmNlTWFwKSB7XG5cdFx0XHRyZXN1bHQuc291cmNlbWFwID0gbmV3IFNvdXJjZU1hcChyZXN1bHQpLmdlbmVyYXRlKCk7XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXHRcblx0Um9vdC5wcm90b3R5cGUuanMgPSBmdW5jdGlvbiAobyl7XG5cdFx0dmFyIG91dDtcblx0XHRpZiAodGhpcy5fb3B0aW9ucy5iYXJlKSB7XG5cdFx0XHRvdXQgPSB0aGlzLnNjb3BlKCkuYygpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmJvZHkoKS5jb25zdW1lKG5ldyBJbXBsaWNpdFJldHVybigpKTtcblx0XHRcdG91dCA9IHRoaXMuc2NvcGUoKS5jKHtpbmRlbnQ6IHRydWV9KTtcblx0XHRcdG91dCA9IG91dC5yZXBsYWNlKC9eXFxuPy8sJ1xcbicpO1xuXHRcdFx0b3V0ID0gb3V0LnJlcGxhY2UoL1xcbj8kLywnXFxuXFxuJyk7XG5cdFx0XHRvdXQgPSAnKGZ1bmN0aW9uKCl7JyArIG91dCArICd9KSgpJztcblx0XHR9O1xuXHRcdFxuXHRcdC8vIGZpbmQgYW5kIHJlcGxhY2Ugc2hlYmFuZ3Ncblx0XHR2YXIgc2hlYmFuZ3MgPSBbXTtcblx0XHRvdXQgPSBvdXQucmVwbGFjZSgvXlsgXFx0XSpcXC9cXC8oXFwhLispJC9tZyxmdW5jdGlvbihtLHNoZWJhbmcpIHtcblx0XHRcdC8vIHAgXCJmb3VuZCBzaGViYW5nIHtzaGViYW5nfVwiXG5cdFx0XHRzaGViYW5nID0gc2hlYmFuZy5yZXBsYWNlKC9cXGJpbWJhXFxiL2csJ25vZGUnKTtcblx0XHRcdHNoZWJhbmdzLnB1c2goKFwiI1wiICsgc2hlYmFuZyArIFwiXFxuXCIpKTtcblx0XHRcdHJldHVybiBcIlwiO1xuXHRcdH0pO1xuXHRcdFxuXHRcdG91dCA9IHNoZWJhbmdzLmpvaW4oJycpICsgb3V0O1xuXHRcdFxuXHRcdHJldHVybiBvdXQ7XG5cdH07XG5cdFxuXHRcblx0Um9vdC5wcm90b3R5cGUuYW5hbHl6ZSA9IGZ1bmN0aW9uIChwYXJzKXtcblx0XHRpZighcGFyc3x8cGFycy5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0KSBwYXJzID0ge307XG5cdFx0dmFyIGxvZ2xldmVsID0gcGFycy5sb2dsZXZlbCAhPT0gdW5kZWZpbmVkID8gcGFycy5sb2dsZXZlbCA6IDA7XG5cdFx0dmFyIGVudGl0aWVzID0gcGFycy5lbnRpdGllcyAhPT0gdW5kZWZpbmVkID8gcGFycy5lbnRpdGllcyA6IGZhbHNlO1xuXHRcdHZhciBzY29wZXMgPSBwYXJzLnNjb3BlcyAhPT0gdW5kZWZpbmVkID8gcGFycy5zY29wZXMgOiB0cnVlO1xuXHRcdFNUQUNLLnNldExvZ2xldmVsKGxvZ2xldmVsKTtcblx0XHRTVEFDSy5fYW5hbHl6aW5nID0gdHJ1ZTtcblx0XHRST09UID0gU1RBQ0suUk9PVCA9IHRoaXMuX3Njb3BlO1xuXHRcdFxuXHRcdE9QVFMgPSB7XG5cdFx0XHRhbmFseXNpczoge1xuXHRcdFx0XHRlbnRpdGllczogZW50aXRpZXMsXG5cdFx0XHRcdHNjb3Blczogc2NvcGVzXG5cdFx0XHR9XG5cdFx0fTtcblx0XHRcblx0XHR0aGlzLnRyYXZlcnNlKCk7XG5cdFx0U1RBQ0suX2FuYWx5emluZyA9IGZhbHNlO1xuXHRcdFxuXHRcdHJldHVybiB0aGlzLnNjb3BlKCkuZHVtcCgpO1xuXHR9O1xuXHRcblx0Um9vdC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gQ2xhc3NEZWNsYXJhdGlvbihuYW1lLHN1cGVyY2xhc3MsYm9keSl7XG5cdFx0Ly8gd2hhdCBhYm91dCB0aGUgbmFtZXNwYWNlP1xuXHRcdHRoaXMuX3RyYXZlcnNlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX25hbWUgPSBuYW1lO1xuXHRcdHRoaXMuX3N1cGVyY2xhc3MgPSBzdXBlcmNsYXNzO1xuXHRcdHRoaXMuX3Njb3BlID0gbmV3IENsYXNzU2NvcGUodGhpcyk7XG5cdFx0dGhpcy5fYm9keSA9IGJsa19fKGJvZHkpO1xuXHRcdHRoaXM7XG5cdH07XG5cdFxuXHRzdWJjbGFzcyQoQ2xhc3NEZWNsYXJhdGlvbixDb2RlKTtcblx0ZXhwb3J0cy5DbGFzc0RlY2xhcmF0aW9uID0gQ2xhc3NEZWNsYXJhdGlvbjsgLy8gZXhwb3J0IGNsYXNzIFxuXHRDbGFzc0RlY2xhcmF0aW9uLnByb3RvdHlwZS5uYW1lID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9uYW1lOyB9XG5cdENsYXNzRGVjbGFyYXRpb24ucHJvdG90eXBlLnNldE5hbWUgPSBmdW5jdGlvbih2KXsgdGhpcy5fbmFtZSA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRDbGFzc0RlY2xhcmF0aW9uLnByb3RvdHlwZS5zdXBlcmNsYXNzID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9zdXBlcmNsYXNzOyB9XG5cdENsYXNzRGVjbGFyYXRpb24ucHJvdG90eXBlLnNldFN1cGVyY2xhc3MgPSBmdW5jdGlvbih2KXsgdGhpcy5fc3VwZXJjbGFzcyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRDbGFzc0RlY2xhcmF0aW9uLnByb3RvdHlwZS5pbml0b3IgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2luaXRvcjsgfVxuXHRDbGFzc0RlY2xhcmF0aW9uLnByb3RvdHlwZS5zZXRJbml0b3IgPSBmdW5jdGlvbih2KXsgdGhpcy5faW5pdG9yID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRDbGFzc0RlY2xhcmF0aW9uLnByb3RvdHlwZS5jb25zdW1lID0gZnVuY3Rpb24gKG5vZGUpe1xuXHRcdGlmIChub2RlIGluc3RhbmNlb2YgUmV0dXJuKSB7XG5cdFx0XHR0aGlzLm9wdGlvbigncmV0dXJuJyx0cnVlKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0cmV0dXJuIENsYXNzRGVjbGFyYXRpb24uX19zdXBlcl9fLmNvbnN1bWUuYXBwbHkodGhpcyxhcmd1bWVudHMpO1xuXHR9O1xuXHRcblx0Q2xhc3NEZWNsYXJhdGlvbi5wcm90b3R5cGUubmFtZXBhdGggPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fbmFtZXBhdGggfHwgKHRoaXMuX25hbWVwYXRoID0gKFwiXCIgKyAodGhpcy5uYW1lKCkuYygpKSkpO1xuXHR9O1xuXHRcblx0Q2xhc3NEZWNsYXJhdGlvbi5wcm90b3R5cGUubWV0YWRhdGEgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgc3VwZXJjbGFzc187XG5cdFx0cmV0dXJuIHtcblx0XHRcdHR5cGU6ICdjbGFzcycsXG5cdFx0XHRuYW1lcGF0aDogdGhpcy5uYW1lcGF0aCgpLFxuXHRcdFx0aW5oZXJpdHM6IChzdXBlcmNsYXNzXyA9IHRoaXMuc3VwZXJjbGFzcygpKSAmJiBzdXBlcmNsYXNzXy5uYW1lcGF0aCAgJiYgIHN1cGVyY2xhc3NfLm5hbWVwYXRoKCksXG5cdFx0XHRwYXRoOiB0aGlzLm5hbWUoKS5jKCkudG9TdHJpbmcoKSxcblx0XHRcdGRlc2M6IHRoaXMuX2Rlc2MsXG5cdFx0XHRsb2M6IHRoaXMubG9jKClcblx0XHR9O1xuXHR9O1xuXHRcblx0Q2xhc3NEZWNsYXJhdGlvbi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMubWV0YWRhdGEoKTtcblx0fTtcblx0XG5cdENsYXNzRGVjbGFyYXRpb24ucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKCl7XG5cdFx0Ly8gcmVwbGFjZSB3aXRoIHNvbWUgYWR2YW5jZWQgbG9va3VwP1xuXHRcdFJPT1QuZW50aXRpZXMoKS5hZGQodGhpcy5uYW1lcGF0aCgpLHRoaXMpO1xuXHRcdHRoaXMuc2NvcGUoKS52aXNpdCgpO1xuXHRcdHRoaXMuYm9keSgpLnRyYXZlcnNlKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRDbGFzc0RlY2xhcmF0aW9uLnByb3RvdHlwZS5qcyA9IGZ1bmN0aW9uIChvKXtcblx0XHR0aGlzLnNjb3BlKCkudmlydHVhbGl6ZSgpOyAvLyBpcyB0aGlzIGFsd2F5cyBuZWVkZWQ/XG5cdFx0dGhpcy5zY29wZSgpLmNvbnRleHQoKS5zZXRWYWx1ZSh0aGlzLm5hbWUoKSk7XG5cdFx0XG5cdFx0Ly8gc2hvdWxkIHByb2JhYmx5IGFsc28gd2FybiBhYm91dCBzdHVmZiBldGNcblx0XHRpZiAodGhpcy5vcHRpb24oJ2V4dGVuc2lvbicpKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5ib2R5KCkuYygpO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIGhlYWQgPSBbXTtcblx0XHR2YXIgbyA9IHRoaXMuX29wdGlvbnMgfHwge307XG5cdFx0dmFyIGNuYW1lID0gdGhpcy5uYW1lKCkgaW5zdGFuY2VvZiBBY2Nlc3MgPyAodGhpcy5uYW1lKCkucmlnaHQoKSkgOiAodGhpcy5uYW1lKCkpO1xuXHRcdHZhciBuYW1lc3BhY2VkID0gdGhpcy5uYW1lKCkgIT0gY25hbWU7XG5cdFx0dmFyIGluaXRvciA9IG51bGw7XG5cdFx0dmFyIHN1cCA9IHRoaXMuc3VwZXJjbGFzcygpO1xuXHRcdFxuXHRcdHZhciBib2R5aW5kZXggPSAtMTtcblx0XHR2YXIgc3BhY2VzID0gdGhpcy5ib2R5KCkuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHsgcmV0dXJuIGl0ZW0gaW5zdGFuY2VvZiBUZXJtaW5hdG9yOyB9KTtcblx0XHR2YXIgbWFyayA9IG1hcmtfXyh0aGlzLm9wdGlvbigna2V5d29yZCcpKTtcblx0XHRcblx0XHR0aGlzLmJvZHkoKS5tYXAoZnVuY3Rpb24oYyxpKSB7XG5cdFx0XHRpZiAoKGMgaW5zdGFuY2VvZiBNZXRob2REZWNsYXJhdGlvbikgJiYgYy50eXBlKCkgPT0gJ2NvbnN0cnVjdG9yJykge1xuXHRcdFx0XHRyZXR1cm4gYm9keWluZGV4ID0gaTtcblx0XHRcdH07XG5cdFx0fSk7XG5cdFx0XG5cdFx0aWYgKGJvZHlpbmRleCA+PSAwKSB7XG5cdFx0XHRpbml0b3IgPSB0aGlzLmJvZHkoKS5yZW1vdmVBdChib2R5aW5kZXgpO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gdmFyIGluaXRvciA9IGJvZHkucGx1Y2sgZG8gfGN8IGMgaXNhIE1ldGhvZERlY2xhcmF0aW9uICYmIGMudHlwZSA9PSA6Y29uc3RydWN0b3Jcblx0XHQvLyBjb21waWxlIHRoZSBjbmFtZVxuXHRcdGlmICh0eXBlb2YgY25hbWUgIT0gJ3N0cmluZycpIHsgY25hbWUgPSBjbmFtZS5jKCkgfTtcblx0XHRcblx0XHR2YXIgY3BhdGggPSB0eXBlb2YgdGhpcy5uYW1lKCkgPT0gJ3N0cmluZycgPyAodGhpcy5uYW1lKCkpIDogKHRoaXMubmFtZSgpLmMoKSk7XG5cdFx0XG5cdFx0aWYgKCFpbml0b3IpIHtcblx0XHRcdGlmIChzdXApIHtcblx0XHRcdFx0aW5pdG9yID0gKFwiXCIgKyBtYXJrICsgXCJmdW5jdGlvbiBcIiArIGNuYW1lICsgXCIoKVxceyByZXR1cm4gXCIgKyAoc3VwLmMoKSkgKyBcIi5hcHBseSh0aGlzLGFyZ3VtZW50cykgXFx9O1xcblxcblwiKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGluaXRvciA9IChcIlwiICsgbWFyayArIFwiZnVuY3Rpb24gXCIgKyBjbmFtZSArIFwiKClcIikgKyAneyB9O1xcblxcbic7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpbml0b3Iuc2V0TmFtZShjbmFtZSk7XG5cdFx0XHRpbml0b3IgPSBpbml0b3IuYygpICsgJzsnO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gaWYgd2UgYXJlIGRlZmluaW5nIGEgY2xhc3MgaW5zaWRlIGEgbmFtZXNwYWNlIGV0YyAtLSBob3cgc2hvdWxkIHdlIHNldCB1cCB0aGUgY2xhc3M/XG5cdFx0XG5cdFx0aWYgKG5hbWVzcGFjZWQpIHtcblx0XHRcdC8vIHNob3VsZCB1c2UgTm9kZXMgdG8gYnVpbGQgdGhpcyBpbnN0ZWFkXG5cdFx0XHRpbml0b3IgPSAoXCJcIiArIGNwYXRoICsgXCIgPSBcIiArIGluaXRvcik7IC8vIE9QKCc9JyxuYW1lLGluaXRvcilcblx0XHR9O1xuXHRcdFxuXHRcdGhlYWQucHVzaChpbml0b3IpOyAvLyAvLyBAY2xhc3Mge2NuYW1lfVxcblxuXHRcdFxuXHRcdGlmIChib2R5aW5kZXggPj0gMCkge1xuXHRcdFx0Ly8gYWRkIHRoZSBzcGFjZSBhZnRlciBpbml0b3I/XG5cdFx0XHRpZiAodGhpcy5ib2R5KCkuaW5kZXgoYm9keWluZGV4KSBpbnN0YW5jZW9mIFRlcm1pbmF0b3IpIHtcblx0XHRcdFx0aGVhZC5wdXNoKHRoaXMuYm9keSgpLnJlbW92ZUF0KGJvZHlpbmRleCkpO1xuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaGVhZC5wdXNoKFRlcm1pbmF0b3IubmV3KCdcXG5cXG4nKSlcblx0XHRcdHRydWU7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHRcblx0XHRpZiAoc3VwKSB7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyBcImRlYWwgd2l0aCBzdXBlcmNsYXNzIVwiXG5cdFx0XHQvLyBoZWFkLnB1c2goXCIvLyBleHRlbmRpbmcgdGhlIHN1cGVyY2xhc3NcXG5pbWJhJGNsYXNzKHtuYW1lLmN9LHtzdXAuY30pO1xcblxcblwiKVxuXHRcdFx0aGVhZC5wdXNoKG5ldyBVdGlsLlN1YmNsYXNzKFt0aGlzLm5hbWUoKSxzdXBdKSk7XG5cdFx0fTtcblx0XHRcblx0XHQvLyBvbmx5IGlmIGl0IGlzIG5vdCBuYW1lc3BhY2VkXG5cdFx0aWYgKG8uZ2xvYmFsICYmICFuYW1lc3BhY2VkKSB7IC8vIG9wdGlvbig6Z2xvYmFsKVxuXHRcdFx0aGVhZC5wdXNoKChcImdsb2JhbC5cIiArIGNuYW1lICsgXCIgPSBcIiArIGNwYXRoICsgXCI7IC8vIGdsb2JhbCBjbGFzcyBcXG5cIikpXG5cdFx0fTtcblx0XHRcblx0XHRpZiAoby5leHBvcnQgJiYgIW5hbWVzcGFjZWQpIHtcblx0XHRcdGhlYWQucHVzaCgoXCJleHBvcnRzLlwiICsgY25hbWUgKyBcIiA9IFwiICsgY3BhdGggKyBcIjsgLy8gZXhwb3J0IGNsYXNzIFxcblwiKSlcblx0XHR9O1xuXHRcdFxuXHRcdC8vIEZJWE1FXG5cdFx0Ly8gaWYgbmFtZXNwYWNlZCBhbmQgKG86bG9jYWwgb3IgbzpleHBvcnQpXG5cdFx0Ly8gXHRjb25zb2xlLmxvZyBcIm5hbWVzcGFjZWQgY2xhc3NlcyBhcmUgaW1wbGljaXRseSBsb2NhbC9nbG9iYWwgZGVwZW5kaW5nIG9uIHRoZSBuYW1lc3BhY2VcIlxuXHRcdFxuXHRcdGlmICh0aGlzLm9wdGlvbigncmV0dXJuJykpIHtcblx0XHRcdHRoaXMuYm9keSgpLnB1c2goKFwicmV0dXJuIFwiICsgY3BhdGggKyBcIjtcIikpO1xuXHRcdH07XG5cdFx0XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKGhlYWQucmV2ZXJzZSgpKSwgbGVuID0gYXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHR0aGlzLmJvZHkoKS51bnNoaWZ0KGFyeVtpXSk7XG5cdFx0fTtcblx0XHR0aGlzLmJvZHkoKS5faW5kZW50YXRpb24gPSBudWxsO1xuXHRcdHZhciBlbmQgPSB0aGlzLmJvZHkoKS5pbmRleCh0aGlzLmJvZHkoKS5jb3VudCgpIC0gMSk7XG5cdFx0aWYgKChlbmQgaW5zdGFuY2VvZiBUZXJtaW5hdG9yKSAmJiBlbmQuYygpLmxlbmd0aCA9PSAxKSB7IHRoaXMuYm9keSgpLnBvcCgpIH07XG5cdFx0XG5cdFx0dmFyIG91dCA9IHRoaXMuYm9keSgpLmMoKTtcblx0XHRcblx0XHRyZXR1cm4gb3V0O1xuXHR9O1xuXHRcblx0XG5cdGZ1bmN0aW9uIFRhZ0RlY2xhcmF0aW9uKG5hbWUsc3VwZXJjbGFzcyxib2R5KXtcblx0XHQvLyB3aGF0IGFib3V0IHRoZSBuYW1lc3BhY2U/XG5cdFx0Ly8gQG5hbWUgPSBUYWdUeXBlUmVmLm5ldyhuYW1lKVxuXHRcdHRoaXMuX3RyYXZlcnNlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX25hbWUgPSBuYW1lO1xuXHRcdHRoaXMuX3N1cGVyY2xhc3MgPSBzdXBlcmNsYXNzO1xuXHRcdHRoaXMuX3Njb3BlID0gbmV3IFRhZ1Njb3BlKHRoaXMpO1xuXHRcdHRoaXMuX2JvZHkgPSBibGtfXyhib2R5IHx8IFtdKTtcblx0fTtcblx0XG5cdHN1YmNsYXNzJChUYWdEZWNsYXJhdGlvbixDb2RlKTtcblx0ZXhwb3J0cy5UYWdEZWNsYXJhdGlvbiA9IFRhZ0RlY2xhcmF0aW9uOyAvLyBleHBvcnQgY2xhc3MgXG5cdFRhZ0RlY2xhcmF0aW9uLnByb3RvdHlwZS5uYW1lID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9uYW1lOyB9XG5cdFRhZ0RlY2xhcmF0aW9uLnByb3RvdHlwZS5zZXROYW1lID0gZnVuY3Rpb24odil7IHRoaXMuX25hbWUgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0VGFnRGVjbGFyYXRpb24ucHJvdG90eXBlLnN1cGVyY2xhc3MgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3N1cGVyY2xhc3M7IH1cblx0VGFnRGVjbGFyYXRpb24ucHJvdG90eXBlLnNldFN1cGVyY2xhc3MgPSBmdW5jdGlvbih2KXsgdGhpcy5fc3VwZXJjbGFzcyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRUYWdEZWNsYXJhdGlvbi5wcm90b3R5cGUuaW5pdG9yID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9pbml0b3I7IH1cblx0VGFnRGVjbGFyYXRpb24ucHJvdG90eXBlLnNldEluaXRvciA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9pbml0b3IgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFRhZ0RlY2xhcmF0aW9uLnByb3RvdHlwZS5uYW1lcGF0aCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiAoXCI8XCIgKyB0aGlzLm5hbWUoKSArIFwiPlwiKTtcblx0fTtcblx0XG5cdFRhZ0RlY2xhcmF0aW9uLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dHlwZTogJ3RhZycsXG5cdFx0XHRuYW1lcGF0aDogdGhpcy5uYW1lcGF0aCgpLFxuXHRcdFx0aW5oZXJpdHM6IHRoaXMuc3VwZXJjbGFzcygpID8gKChcIjxcIiArICh0aGlzLnN1cGVyY2xhc3MoKS5uYW1lKCkpICsgXCI+XCIpKSA6IChudWxsKSxcblx0XHRcdGxvYzogdGhpcy5sb2MoKSxcblx0XHRcdGRlc2M6IHRoaXMuX2Rlc2Ncblx0XHR9O1xuXHR9O1xuXHRcblx0VGFnRGVjbGFyYXRpb24ucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKCl7XG5cdFx0Uk9PVC5lbnRpdGllcygpLnJlZ2lzdGVyKHRoaXMpOyAvLyB3aGF0IGlmIHRoaXMgaXMgbm90IGxvY2FsP1xuXHRcdFxuXHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChTVEFDSy5zY29wZXMoKSksIGxlbiA9IGFyeS5sZW5ndGgsIHNjb3BlOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHNjb3BlID0gYXJ5W2ldO1xuXHRcdFx0aWYgKGkgPiAwICYmIChzY29wZSBpbnN0YW5jZW9mIFRhZ1Njb3BlKSkge1xuXHRcdFx0XHQvLyByZWdpc3RlciBpbnNpZGUgaGVyZT9cblx0XHRcdFx0c2NvcGUubm9kZSgpLm9wdGlvbignaGFzTG9jYWxUYWdzJyx0cnVlKTtcblx0XHRcdFx0dGhpcy5vcHRpb24oJ3BhcmVudCcsc2NvcGUubm9kZSgpKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nIFwidGFnIGlzIGxvY2FsISEhXCJcblx0XHRcdH07XG5cdFx0fTtcblx0XHQvLyByZXBsYWNlIHdpdGggc29tZSBhZHZhbmNlZCBsb29rdXA/XG5cdFx0dGhpcy5zY29wZSgpLnZpc2l0KCk7XG5cdFx0cmV0dXJuIHRoaXMuYm9keSgpLnRyYXZlcnNlKCk7XG5cdH07XG5cdFxuXHRUYWdEZWNsYXJhdGlvbi5wcm90b3R5cGUuaWQgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5uYW1lKCkuaWQoKTtcblx0fTtcblx0XG5cdFRhZ0RlY2xhcmF0aW9uLnByb3RvdHlwZS50YWdzcGFjZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBjdHggPSB0aGlzLnNjb3BlKCkuY2xvc3VyZSgpLnRhZ0NvbnRleHRQYXRoKCk7XG5cdFx0cmV0dXJuIHRoaXMubmFtZSgpLm5zKCkgPyAoKFwiXCIgKyBjdHggKyBcIi5cIiArICh0aGlzLm5hbWUoKS5ucygpLnRvVXBwZXJDYXNlKCkpKSkgOiAoY3R4KTtcblx0fTtcblx0XG5cdFRhZ0RlY2xhcmF0aW9uLnByb3RvdHlwZS5qcyA9IGZ1bmN0aW9uIChvKXtcblx0XHR0aGlzLnNjb3BlKCkuY29udGV4dCgpLnNldFZhbHVlKHRoaXMuX2N0eCA9IHRoaXMuc2NvcGUoKS5kZWNsYXJlKCd0YWcnLG51bGwse3N5c3RlbTogdHJ1ZX0pKTtcblx0XHRcblx0XHR2YXIgbnMgPSB0aGlzLm5hbWUoKS5ucygpO1xuXHRcdHZhciBtYXJrID0gbWFya19fKHRoaXMub3B0aW9uKCdrZXl3b3JkJykpO1xuXHRcdFxuXHRcdHZhciBwYXJhbXMgPSBbaGVscGVycy5zaW5nbGVxdW90ZSh0aGlzLm5hbWUoKS5uYW1lKCkpXTtcblx0XHR2YXIgY2JvZHkgPSB0aGlzLmJvZHkoKS5jKCk7XG5cdFx0Ly8gdmFyIG91dGJvZHkgPSBib2R5LmNvdW50ID8gXCIsIGZ1bmN0aW9uKHtAY3R4LmN9KVxce3tjYm9keX1cXH1cIiA6ICcnXG5cdFx0XG5cdFx0aWYgKHRoaXMuc3VwZXJjbGFzcygpKSB7XG5cdFx0XHQvLyBXQVJOIHdoYXQgaWYgdGhlIHN1cGVyY2xhc3MgaGFzIGEgbmFtZXNwYWNlP1xuXHRcdFx0cGFyYW1zLnB1c2goaGVscGVycy5zaW5nbGVxdW90ZSh0aGlzLnN1cGVyY2xhc3MoKS5uYW1lKCkpKTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmICh0aGlzLmJvZHkoKS5jb3VudCgpKSB7XG5cdFx0XHRpZiAodGhpcy5vcHRpb24oJ2hhc0xvY2FsVGFncycpKSB7XG5cdFx0XHRcdHBhcmFtcy5wdXNoKChcImZ1bmN0aW9uKFwiICsgKHRoaXMuX2N0eC5jKCkpICsgXCIsXCIgKyAodGhpcy5zY29wZSgpLmNsb3N1cmUoKS50YWdDb250ZXh0UGF0aCgpKSArIFwiKVxce1wiICsgY2JvZHkgKyBcIlxcfVwiKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwYXJhbXMucHVzaCgoXCJmdW5jdGlvbihcIiArICh0aGlzLl9jdHguYygpKSArIFwiKVxce1wiICsgY2JvZHkgKyBcIlxcfVwiKSk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIG1ldGggPSB0aGlzLm9wdGlvbignZXh0ZW5zaW9uJykgPyAoJ2V4dGVuZFRhZycpIDogKCdkZWZpbmVUYWcnKTtcblx0XHQvLyByZXR1cm4gXCJ7bWFya317dGFnc3BhY2V9LmV4dGVuZFRhZygne25hbWUubmFtZX0ne291dGJvZHl9KVwiXG5cdFx0XG5cdFx0Ly8gdmFyIHN1cCA9IHN1cGVyY2xhc3MgYW5kIFwiLFwiICsgaGVscGVycy5zaW5nbGVxdW90ZShzdXBlcmNsYXNzLmZ1bmMpIG9yIFwiXCJcblx0XHRcblx0XHQvLyB2YXIgb3V0ID0gaWYgbmFtZS5pZFxuXHRcdC8vXHRcInttYXJrfXt0YWdzcGFjZX0uZGVmaW5lU2luZ2xldG9uKCd7bmFtZS5uYW1lfSd7c3VwfXtvdXRib2R5fSlcIlxuXHRcdC8vIGVsc2Vcblx0XHRcblx0XHRyZXR1cm4gKFwiXCIgKyBtYXJrICsgdGhpcy50YWdzcGFjZSgpICsgXCIuXCIgKyBtZXRoICsgXCIoXCIgKyBwYXJhbXMuam9pbignLCAnKSArIFwiKVwiKTtcblx0XHRcblx0XHQvLyByZXR1cm4gb3V0XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBGdW5jKHBhcmFtcyxib2R5LG5hbWUsdGFyZ2V0LG8pe1xuXHRcdC8vIHAgXCJJTklUIEZ1bmN0aW9uISFcIixwYXJhbXMsYm9keSxuYW1lXG5cdFx0dmFyIHR5cCA9IHRoaXMuc2NvcGV0eXBlKCk7XG5cdFx0dGhpcy5fdHJhdmVyc2VkID0gZmFsc2U7XG5cdFx0dGhpcy5fYm9keSA9IGJsa19fKGJvZHkpO1xuXHRcdHRoaXMuX3Njb3BlIHx8ICh0aGlzLl9zY29wZSA9IChvICYmIG8uc2NvcGUpIHx8IG5ldyB0eXAodGhpcykpO1xuXHRcdHRoaXMuX3Njb3BlLnNldFBhcmFtcyh0aGlzLl9wYXJhbXMgPSBuZXcgUGFyYW1MaXN0KHBhcmFtcykpO1xuXHRcdHRoaXMuX25hbWUgPSBuYW1lIHx8ICcnO1xuXHRcdHRoaXMuX3RhcmdldCA9IHRhcmdldDtcblx0XHR0aGlzLl9vcHRpb25zID0gbztcblx0XHR0aGlzLl90eXBlID0gJ2Z1bmN0aW9uJztcblx0XHR0aGlzLl92YXJpYWJsZSA9IG51bGw7XG5cdFx0dGhpcztcblx0fTtcblx0XG5cdHN1YmNsYXNzJChGdW5jLENvZGUpO1xuXHRleHBvcnRzLkZ1bmMgPSBGdW5jOyAvLyBleHBvcnQgY2xhc3MgXG5cdEZ1bmMucHJvdG90eXBlLm5hbWUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX25hbWU7IH1cblx0RnVuYy5wcm90b3R5cGUuc2V0TmFtZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9uYW1lID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdEZ1bmMucHJvdG90eXBlLnBhcmFtcyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fcGFyYW1zOyB9XG5cdEZ1bmMucHJvdG90eXBlLnNldFBhcmFtcyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9wYXJhbXMgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0RnVuYy5wcm90b3R5cGUudGFyZ2V0ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl90YXJnZXQ7IH1cblx0RnVuYy5wcm90b3R5cGUuc2V0VGFyZ2V0ID0gZnVuY3Rpb24odil7IHRoaXMuX3RhcmdldCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRGdW5jLnByb3RvdHlwZS5vcHRpb25zID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9vcHRpb25zOyB9XG5cdEZ1bmMucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbih2KXsgdGhpcy5fb3B0aW9ucyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRGdW5jLnByb3RvdHlwZS50eXBlID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl90eXBlOyB9XG5cdEZ1bmMucHJvdG90eXBlLnNldFR5cGUgPSBmdW5jdGlvbih2KXsgdGhpcy5fdHlwZSA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRGdW5jLnByb3RvdHlwZS5jb250ZXh0ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9jb250ZXh0OyB9XG5cdEZ1bmMucHJvdG90eXBlLnNldENvbnRleHQgPSBmdW5jdGlvbih2KXsgdGhpcy5fY29udGV4dCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0RnVuYy5wcm90b3R5cGUuc2NvcGV0eXBlID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIEZ1bmN0aW9uU2NvcGU7XG5cdH07XG5cdFxuXHRGdW5jLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICgpe1xuXHRcdHRoaXMuc2NvcGUoKS52aXNpdCgpO1xuXHRcdHRoaXMuX2NvbnRleHQgPSB0aGlzLnNjb3BlKCkucGFyZW50KCk7XG5cdFx0dGhpcy5fcGFyYW1zLnRyYXZlcnNlKCk7XG5cdFx0cmV0dXJuIHRoaXMuX2JvZHkudHJhdmVyc2UoKTsgLy8gc28gc29vbj9cblx0fTtcblx0XG5cdFxuXHRGdW5jLnByb3RvdHlwZS5qcyA9IGZ1bmN0aW9uIChvKXtcblx0XHRpZiAoIXRoaXMub3B0aW9uKCdub3JldHVybicpKSB7IHRoaXMuYm9keSgpLmNvbnN1bWUobmV3IEltcGxpY2l0UmV0dXJuKCkpIH07XG5cdFx0dmFyIGluZCA9IHRoaXMuYm9keSgpLl9pbmRlbnRhdGlvbjtcblx0XHQvLyB2YXIgcyA9IGluZCBhbmQgaW5kLkBvcGVuXG5cdFx0Ly8gcCBcImluZGVudCBmdW5jdGlvbj8ge2JvZHkuQGluZGVudGF0aW9ufSB7c30ge3M6Z2VuZXJhdGVkfSB7Ym9keS5jb3VudH1cIlxuXHRcdGlmIChpbmQgJiYgaW5kLmlzR2VuZXJhdGVkKCkpIHsgdGhpcy5ib2R5KCkuX2luZGVudGF0aW9uID0gbnVsbCB9O1xuXHRcdHZhciBjb2RlID0gdGhpcy5zY29wZSgpLmMoe2luZGVudDogKCFpbmQgfHwgIWluZC5pc0dlbmVyYXRlZCgpKSxicmFjZXM6IHRydWV9KTtcblx0XHRcblx0XHQvLyBhcmdzID0gcGFyYW1zLm1hcCBkbyB8cGFyfCBwYXIubmFtZVxuXHRcdC8vIGhlYWQgPSBwYXJhbXMubWFwIGRvIHxwYXJ8IHBhci5jXG5cdFx0Ly8gY29kZSA9IFtoZWFkLGJvZHkuYyhleHByZXNzaW9uOiBubyldLmZsYXR0ZW5fXy5jb21wYWN0LmpvaW4oXCJcXG5cIikud3JhcFxuXHRcdC8vIEZJWE1FIGNyZWF0aW5nIHRoZSBmdW5jdGlvbi1uYW1lIHRoaXMgd2F5IGlzIHByb25lIHRvIGNyZWF0ZSBuYW1pbmctY29sbGlzaW9uc1xuXHRcdC8vIHdpbGwgbmVlZCB0byB3cmFwIHRoZSB2YWx1ZSBpbiBhIEZ1bmN0aW9uTmFtZSB3aGljaCB0YWtlcyBjYXJlIG9mIGxvb2tpbmcgdXAgc2NvcGVcblx0XHQvLyBhbmQgcG9zc2libHkgZGVhbGluZyB3aXRoIGl0XG5cdFx0dmFyIG5hbWUgPSB0eXBlb2YgdGhpcy5fbmFtZSA9PSAnc3RyaW5nJyA/ICh0aGlzLl9uYW1lKSA6ICh0aGlzLl9uYW1lLmMoKSk7XG5cdFx0bmFtZSA9IG5hbWUgPyAoJyAnICsgbmFtZS5yZXBsYWNlKC9cXC4vZywnXycpKSA6ICgnJyk7XG5cdFx0dmFyIG91dCA9IChcImZ1bmN0aW9uXCIgKyBuYW1lICsgXCIoXCIgKyAodGhpcy5wYXJhbXMoKS5jKCkpICsgXCIpIFwiKSArIGNvZGU7XG5cdFx0aWYgKHRoaXMub3B0aW9uKCdldmFsJykpIHsgb3V0ID0gKFwiKFwiICsgb3V0ICsgXCIpKClcIikgfTtcblx0XHRyZXR1cm4gb3V0O1xuXHR9O1xuXHRcblx0RnVuYy5wcm90b3R5cGUuc2hvdWxkUGFyZW50aGVzaXplID0gZnVuY3Rpb24gKHBhcil7XG5cdFx0aWYocGFyID09PSB1bmRlZmluZWQpIHBhciA9IHRoaXMudXAoKTtcblx0XHRyZXR1cm4gKHBhciBpbnN0YW5jZW9mIENhbGwpICYmIHBhci5jYWxsZWUoKSA9PSB0aGlzO1xuXHRcdC8vIGlmIHVwIGFzIGEgY2FsbD8gT25seSBpZiB3ZSBhcmUgXG5cdH07XG5cdFxuXHRmdW5jdGlvbiBMYW1iZGEoKXsgcmV0dXJuIEZ1bmMuYXBwbHkodGhpcyxhcmd1bWVudHMpIH07XG5cdFxuXHRzdWJjbGFzcyQoTGFtYmRhLEZ1bmMpO1xuXHRleHBvcnRzLkxhbWJkYSA9IExhbWJkYTsgLy8gZXhwb3J0IGNsYXNzIFxuXHRMYW1iZGEucHJvdG90eXBlLnNjb3BldHlwZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiBMYW1iZGFTY29wZTtcblx0fTtcblx0XG5cdGZ1bmN0aW9uIFRhZ0ZyYWdtZW50RnVuYygpeyByZXR1cm4gRnVuYy5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XG5cdHN1YmNsYXNzJChUYWdGcmFnbWVudEZ1bmMsRnVuYyk7XG5cdGV4cG9ydHMuVGFnRnJhZ21lbnRGdW5jID0gVGFnRnJhZ21lbnRGdW5jOyAvLyBleHBvcnQgY2xhc3MgXG5cdFxuXHRcblx0Ly8gTWV0aG9kRGVjbGFyYXRpb25cblx0Ly8gQ3JlYXRlIGEgc2hhcmVkIGJvZHk/XG5cdFxuXHRmdW5jdGlvbiBNZXRob2REZWNsYXJhdGlvbigpeyByZXR1cm4gRnVuYy5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XG5cdHN1YmNsYXNzJChNZXRob2REZWNsYXJhdGlvbixGdW5jKTtcblx0ZXhwb3J0cy5NZXRob2REZWNsYXJhdGlvbiA9IE1ldGhvZERlY2xhcmF0aW9uOyAvLyBleHBvcnQgY2xhc3MgXG5cdE1ldGhvZERlY2xhcmF0aW9uLnByb3RvdHlwZS52YXJpYWJsZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fdmFyaWFibGU7IH1cblx0TWV0aG9kRGVjbGFyYXRpb24ucHJvdG90eXBlLnNldFZhcmlhYmxlID0gZnVuY3Rpb24odil7IHRoaXMuX3ZhcmlhYmxlID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRNZXRob2REZWNsYXJhdGlvbi5wcm90b3R5cGUuc2NvcGV0eXBlID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIE1ldGhvZFNjb3BlO1xuXHR9O1xuXHRcblx0TWV0aG9kRGVjbGFyYXRpb24ucHJvdG90eXBlLmNvbnN1bWUgPSBmdW5jdGlvbiAobm9kZSl7XG5cdFx0aWYgKG5vZGUgaW5zdGFuY2VvZiBSZXR1cm4pIHtcblx0XHRcdHRoaXMub3B0aW9uKCdyZXR1cm4nLHRydWUpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRyZXR1cm4gTWV0aG9kRGVjbGFyYXRpb24uX19zdXBlcl9fLmNvbnN1bWUuYXBwbHkodGhpcyxhcmd1bWVudHMpO1xuXHR9O1xuXHRcblx0TWV0aG9kRGVjbGFyYXRpb24ucHJvdG90eXBlLm1ldGFkYXRhID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHR5cGU6IFwibWV0aG9kXCIsXG5cdFx0XHRuYW1lOiBcIlwiICsgdGhpcy5uYW1lKCksXG5cdFx0XHRuYW1lcGF0aDogdGhpcy5uYW1lcGF0aCgpLFxuXHRcdFx0cGFyYW1zOiB0aGlzLl9wYXJhbXMubWV0YWRhdGEoKSxcblx0XHRcdGRlc2M6IHRoaXMuX2Rlc2MsXG5cdFx0XHRzY29wZW5yOiB0aGlzLnNjb3BlKCkuX25yLFxuXHRcdFx0bG9jOiB0aGlzLmxvYygpXG5cdFx0fTtcblx0fTtcblx0XG5cdE1ldGhvZERlY2xhcmF0aW9uLnByb3RvdHlwZS5sb2MgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgZDtcblx0XHRpZiAoZCA9IHRoaXMub3B0aW9uKCdkZWYnKSkge1xuXHRcdFx0cmV0dXJuIFtkLl9sb2MsdGhpcy5ib2R5KCkubG9jKClbMV1dO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gWzAsMF07XG5cdFx0fTtcblx0fTtcblx0XG5cdFxuXHRNZXRob2REZWNsYXJhdGlvbi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMubWV0YWRhdGEoKTtcblx0fTtcblx0XG5cdE1ldGhvZERlY2xhcmF0aW9uLnByb3RvdHlwZS5uYW1lcGF0aCA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmICh0aGlzLl9uYW1lcGF0aCkgeyByZXR1cm4gdGhpcy5fbmFtZXBhdGggfTtcblx0XHRcblx0XHR2YXIgbmFtZSA9IFN0cmluZyh0aGlzLm5hbWUoKSk7XG5cdFx0dmFyIHNlcCA9ICh0aGlzLm9wdGlvbignc3RhdGljJykgPyAoJy4nKSA6ICgnIycpKTtcblx0XHRpZiAodGhpcy50YXJnZXQoKSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX25hbWVwYXRoID0gdGhpcy5fdGFyZ2V0Lm5hbWVwYXRoKCkgKyBzZXAgKyBuYW1lO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fbmFtZXBhdGggPSAnJicgKyBuYW1lO1xuXHRcdH07XG5cdH07XG5cdFxuXHRNZXRob2REZWNsYXJhdGlvbi5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAoKXtcblx0XHQvLyBAZGVzYyA9IHN0YWNrLnN0YXNoLnBsdWNrKENvbW1lbnQpXG5cdFx0Ly8gQGRlc2MgPSBzdGFjay5zdGFzaC5wbHVjayhDb21tZW50KVxuXHRcdC8vIHByZWJyZWFrICMgbWFrZSBzdXJlIHRoaXMgaGFzIGEgYnJlYWs/XG5cdFx0dGhpcy5zY29wZSgpLnZpc2l0KCk7XG5cdFx0XG5cdFx0aWYgKFN0cmluZyh0aGlzLm5hbWUoKSkgPT0gJ2luaXRpYWxpemUnKSB7XG5cdFx0XHR0aGlzLnNldFR5cGUoJ2NvbnN0cnVjdG9yJyk7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAodGhpcy5vcHRpb24oJ2dyZWVkeScpKSB7XG5cdFx0XHR0aGlzLndhcm4oXCJkZXByZWNhdGVkXCIpO1xuXHRcdFx0Ly8gc2V0KGdyZWVkeTogdHJ1ZSlcblx0XHRcdC8vIHAgXCJCT0RZIEVYUFJFU1NJT05TISEgVGhpcyBpcyBhIGZyYWdtZW50XCJcblx0XHRcdHZhciB0cmVlID0gbmV3IFRhZ1RyZWUoKTtcblx0XHRcdHRoaXMuX2JvZHkgPSB0aGlzLmJvZHkoKS5jb25zdW1lKHRyZWUpO1xuXHRcdFx0Ly8gYm9keS5ub2RlcyA9IFtBcnIubmV3KGJvZHkubm9kZXMpXVxuXHRcdH07XG5cdFx0XG5cdFx0dGhpcy5fY29udGV4dCA9IHRoaXMuc2NvcGUoKS5wYXJlbnQoKS5jbG9zdXJlKCk7XG5cdFx0dGhpcy5fcGFyYW1zLnRyYXZlcnNlKCk7XG5cdFx0XG5cdFx0aWYgKHRoaXMudGFyZ2V0KCkgaW5zdGFuY2VvZiBTZWxmKSB7XG5cdFx0XHR0aGlzLl90YXJnZXQgPSB0aGlzLl9jb250ZXh0LmNvbnRleHQoKTtcblx0XHRcdHRoaXMuc2V0KHtzdGF0aWM6IHRydWV9KTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmICh0aGlzLmNvbnRleHQoKSBpbnN0YW5jZW9mIENsYXNzU2NvcGUpIHtcblx0XHRcdHRoaXMuY29udGV4dCgpLmFubm90YXRlKHRoaXMpO1xuXHRcdFx0dGhpcy5fdGFyZ2V0IHx8ICh0aGlzLl90YXJnZXQgPSB0aGlzLmNvbnRleHQoKS5jb250ZXh0KCkpO1xuXHRcdFx0Ly8gcmVnaXN0ZXIgYXMgY2xhc3MtbWV0aG9kP1xuXHRcdFx0Ly8gc2hvdWxkIHJlZ2lzdGVyIGZvciB0aGlzXG5cdFx0XHQvLyBjb25zb2xlLmxvZyBcImNvbnRleHQgaXMgY2xhc3NzY29wZSB7QG5hbWV9XCJcblx0XHR9O1xuXHRcdFxuXHRcdGlmICghdGhpcy5fdGFyZ2V0KSB7XG5cdFx0XHQvLyBzaG91bGQgbm90IGJlIHJlZ2lzdGVyZWQgb24gdGhlIG91dGVybW9zdCBjbG9zdXJlP1xuXHRcdFx0dGhpcy5fdmFyaWFibGUgPSB0aGlzLmNvbnRleHQoKS5yZWdpc3Rlcih0aGlzLm5hbWUoKSx0aGlzLHt0eXBlOiAnbWV0aCd9KTtcblx0XHR9O1xuXHRcdFxuXHRcdFJPT1QuZW50aXRpZXMoKS5hZGQodGhpcy5uYW1lcGF0aCgpLHRoaXMpO1xuXHRcdHRoaXMuX2JvZHkudHJhdmVyc2UoKTsgLy8gc28gc29vbj9cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdE1ldGhvZERlY2xhcmF0aW9uLnByb3RvdHlwZS5zdXBlcm5hbWUgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy50eXBlKCkgPT0gJ2NvbnN0cnVjdG9yJyA/ICh0aGlzLnR5cGUoKSkgOiAodGhpcy5uYW1lKCkpO1xuXHR9O1xuXHRcblx0XG5cdC8vIEZJWE1FIGV4cG9ydCBnbG9iYWwgZXRjIGFyZSBOT1QgdmFsaWQgZm9yIG1ldGhvZHMgaW5zaWRlIGFueSBvdGhlciBzY29wZSB0aGFuXG5cdC8vIHRoZSBvdXRlcm1vc3Qgc2NvcGUgKHJvb3QpXG5cdFxuXHRNZXRob2REZWNsYXJhdGlvbi5wcm90b3R5cGUuanMgPSBmdW5jdGlvbiAobyl7XG5cdFx0Ly8gRklYTUUgRG8gdGhpcyBpbiB0aGUgZ3JhbW1hciAtIHJlbW5hbnRzIG9mIG9sZCBpbXBsZW1lbnRhdGlvblxuXHRcdGlmICghKHRoaXMudHlwZSgpID09ICdjb25zdHJ1Y3RvcicgfHwgdGhpcy5vcHRpb24oJ25vcmV0dXJuJykpKSB7XG5cdFx0XHRpZiAodGhpcy5vcHRpb24oJ2dyZWVkeScpKSB7XG5cdFx0XHRcdC8vIGhhYWFja1xuXHRcdFx0XHR0aGlzLmJvZHkoKS5jb25zdW1lKG5ldyBHcmVlZHlSZXR1cm4oKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmJvZHkoKS5jb25zdW1lKG5ldyBJbXBsaWNpdFJldHVybigpKTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgY29kZSA9IHRoaXMuc2NvcGUoKS5jKHtpbmRlbnQ6IHRydWUsYnJhY2VzOiB0cnVlfSk7XG5cdFx0XG5cdFx0Ly8gc2FtZSBmb3IgRnVuYyAtLSBzaG91bGQgZ2VuZXJhbGl6ZVxuXHRcdHZhciBuYW1lID0gdHlwZW9mIHRoaXMuX25hbWUgPT0gJ3N0cmluZycgPyAodGhpcy5fbmFtZSkgOiAodGhpcy5fbmFtZS5jKCkpO1xuXHRcdG5hbWUgPSBuYW1lLnJlcGxhY2UoL1xcLi9nLCdfJyk7XG5cdFx0XG5cdFx0Ly8gdmFyIG5hbWUgPSBzZWxmLm5hbWUuYy5yZXBsYWNlKC9cXC4vZywnXycpICMgV0hBVD9cblx0XHR2YXIgZm9vdCA9IFtdO1xuXHRcdFxuXHRcdHZhciBsZWZ0ID0gXCJcIjtcblx0XHR2YXIgZnVuYyA9IChcIihcIiArICh0aGlzLnBhcmFtcygpLmMoKSkgKyBcIilcIikgKyBjb2RlOyAvLyAud3JhcFxuXHRcdHZhciB0YXJnZXQgPSB0aGlzLnRhcmdldCgpO1xuXHRcdHZhciBkZWNsID0gIXRoaXMub3B0aW9uKCdnbG9iYWwnKSAmJiAhdGhpcy5vcHRpb24oJ2V4cG9ydCcpO1xuXHRcdFxuXHRcdGlmICh0YXJnZXQgaW5zdGFuY2VvZiBTY29wZUNvbnRleHQpIHtcblx0XHRcdC8vIHRoZSB0YXJnZXQgaXMgYSBzY29wZSBjb250ZXh0XG5cdFx0XHR0YXJnZXQgPSBudWxsO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIGN0eCA9IHRoaXMuY29udGV4dCgpO1xuXHRcdHZhciBvdXQgPSBcIlwiO1xuXHRcdHZhciBtYXJrID0gbWFya19fKHRoaXMub3B0aW9uKCdkZWYnKSk7XG5cdFx0Ly8gaWYgY3R4IFxuXHRcdFxuXHRcdHZhciBmbmFtZSA9IHN5bV9fKHRoaXMubmFtZSgpKTtcblx0XHQvLyBjb25zb2xlLmxvZyBcInN5bWJvbGl6ZSB7c2VsZi5uYW1lfSAtLSB7Zm5hbWV9XCJcblx0XHR2YXIgZmRlY2wgPSBmbmFtZTsgLy8gZGVjbCA/IGZuYW1lIDogJydcblx0XHRcblx0XHRpZiAoKGN0eCBpbnN0YW5jZW9mIENsYXNzU2NvcGUpICYmICF0YXJnZXQpIHtcblx0XHRcdGlmICh0aGlzLnR5cGUoKSA9PSAnY29uc3RydWN0b3InKSB7XG5cdFx0XHRcdG91dCA9IChcIlwiICsgbWFyayArIFwiZnVuY3Rpb24gXCIgKyBmbmFtZSArIGZ1bmMpO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLm9wdGlvbignc3RhdGljJykpIHtcblx0XHRcdFx0b3V0ID0gKFwiXCIgKyBtYXJrICsgKGN0eC5jb250ZXh0KCkuYygpKSArIFwiLlwiICsgZm5hbWUgKyBcIiA9IGZ1bmN0aW9uIFwiICsgZnVuYyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXQgPSAoXCJcIiArIG1hcmsgKyAoY3R4LmNvbnRleHQoKS5jKCkpICsgXCIucHJvdG90eXBlLlwiICsgZm5hbWUgKyBcIiA9IGZ1bmN0aW9uIFwiICsgZnVuYyk7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSBpZiAoKGN0eCBpbnN0YW5jZW9mIFJvb3RTY29wZSkgJiYgIXRhcmdldCkge1xuXHRcdFx0Ly8gcmVnaXN0ZXIgbWV0aG9kIGFzIGEgcm9vdC1mdW5jdGlvbiwgYnV0IHdpdGggYXV0by1jYWxsPyBobW1cblx0XHRcdC8vIHNob3VsZCBwcm9iYWJseSBzZXQgdXNpbmcgdmFyaWFibGUgZGlyZWN0bHkgaW5zdGVhZCwgbm8/XG5cdFx0XHRvdXQgPSAoXCJcIiArIG1hcmsgKyBcImZ1bmN0aW9uIFwiICsgZmRlY2wgKyBmdW5jKTtcblx0XHR9IGVsc2UgaWYgKHRhcmdldCAmJiB0aGlzLm9wdGlvbignc3RhdGljJykpIHtcblx0XHRcdG91dCA9IChcIlwiICsgbWFyayArICh0YXJnZXQuYygpKSArIFwiLlwiICsgZm5hbWUgKyBcIiA9IGZ1bmN0aW9uIFwiICsgZnVuYyk7XG5cdFx0fSBlbHNlIGlmICh0YXJnZXQpIHtcblx0XHRcdG91dCA9IChcIlwiICsgbWFyayArICh0YXJnZXQuYygpKSArIFwiLnByb3RvdHlwZS5cIiArIGZuYW1lICsgXCIgPSBmdW5jdGlvbiBcIiArIGZ1bmMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRvdXQgPSAoXCJcIiArIG1hcmsgKyBcImZ1bmN0aW9uIFwiICsgZmRlY2wgKyBmdW5jKTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmICh0aGlzLm9wdGlvbignZ2xvYmFsJykpIHtcblx0XHRcdG91dCA9IChcIlwiICsgZm5hbWUgKyBcIiA9IFwiICsgb3V0KTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmICh0aGlzLm9wdGlvbignZXhwb3J0JykpIHtcblx0XHRcdG91dCA9IChcIlwiICsgb3V0ICsgXCI7IGV4cG9ydHMuXCIgKyBmbmFtZSArIFwiID0gXCIgKyBmbmFtZSArIFwiO1wiKTtcblx0XHRcdGlmICh0aGlzLm9wdGlvbigncmV0dXJuJykpIHsgb3V0ID0gKFwiXCIgKyBvdXQgKyBcIjsgcmV0dXJuIFwiICsgZm5hbWUgKyBcIjtcIikgfTtcblx0XHR9IGVsc2UgaWYgKHRoaXMub3B0aW9uKCdyZXR1cm4nKSkge1xuXHRcdFx0b3V0ID0gKFwicmV0dXJuIFwiICsgb3V0KTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiBvdXQ7XG5cdH07XG5cdFxuXHRcblx0ZnVuY3Rpb24gVGFnRnJhZ21lbnREZWNsYXJhdGlvbigpeyByZXR1cm4gTWV0aG9kRGVjbGFyYXRpb24uYXBwbHkodGhpcyxhcmd1bWVudHMpIH07XG5cdFxuXHRzdWJjbGFzcyQoVGFnRnJhZ21lbnREZWNsYXJhdGlvbixNZXRob2REZWNsYXJhdGlvbik7XG5cdGV4cG9ydHMuVGFnRnJhZ21lbnREZWNsYXJhdGlvbiA9IFRhZ0ZyYWdtZW50RGVjbGFyYXRpb247IC8vIGV4cG9ydCBjbGFzcyBcblx0XG5cdFxuXHRcblx0ZnVuY3Rpb24gUHJvcGVydHlEZWNsYXJhdGlvbihuYW1lLG9wdGlvbnMsdG9rZW4pe1xuXHRcdHRoaXMuX3Rva2VuID0gdG9rZW47XG5cdFx0dGhpcy5fdHJhdmVyc2VkID0gZmFsc2U7XG5cdFx0dGhpcy5fbmFtZSA9IG5hbWU7XG5cdFx0dGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgfHwgbmV3IE9iaihuZXcgQXNzaWduTGlzdCgpKTtcblx0fTtcblx0XG5cdHN1YmNsYXNzJChQcm9wZXJ0eURlY2xhcmF0aW9uLE5vZGUpO1xuXHRleHBvcnRzLlByb3BlcnR5RGVjbGFyYXRpb24gPSBQcm9wZXJ0eURlY2xhcmF0aW9uOyAvLyBleHBvcnQgY2xhc3MgXG5cdHZhciBwcm9wVGVtcGxhdGUgPSAnJHtoZWFkZXJzfVxcbiR7cGF0aH0uJHtnZXR0ZXJ9ID0gZnVuY3Rpb24odil7IHJldHVybiAke2dldH07IH1cXG4ke3BhdGh9LiR7c2V0dGVyfSA9IGZ1bmN0aW9uKHYpeyAke3NldH07IHJldHVybiB0aGlzOyB9XFxuJHtpbml0fSc7XG5cdFxuXHR2YXIgcHJvcFdhdGNoVGVtcGxhdGUgPSAnJHtoZWFkZXJzfVxcbiR7cGF0aH0uJHtnZXR0ZXJ9ID0gZnVuY3Rpb24odil7IHJldHVybiAke2dldH07IH1cXG4ke3BhdGh9LiR7c2V0dGVyfSA9IGZ1bmN0aW9uKHYpe1xcblx0dmFyIGEgPSB0aGlzLiR7Z2V0dGVyfSgpO1xcblx0aWYodiAhPSBhKSB7ICR7c2V0fTsgfVxcblx0aWYodiAhPSBhKSB7ICR7b25kaXJ0eX0gfVxcblx0cmV0dXJuIHRoaXM7XFxufVxcbiR7aW5pdH0nO1xuXHRcblx0UHJvcGVydHlEZWNsYXJhdGlvbi5wcm90b3R5cGUubmFtZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fbmFtZTsgfVxuXHRQcm9wZXJ0eURlY2xhcmF0aW9uLnByb3RvdHlwZS5zZXROYW1lID0gZnVuY3Rpb24odil7IHRoaXMuX25hbWUgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0UHJvcGVydHlEZWNsYXJhdGlvbi5wcm90b3R5cGUub3B0aW9ucyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fb3B0aW9uczsgfVxuXHRQcm9wZXJ0eURlY2xhcmF0aW9uLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24odil7IHRoaXMuX29wdGlvbnMgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFByb3BlcnR5RGVjbGFyYXRpb24ucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKCl7XG5cdFx0dGhpcy5fb3B0aW9ucy50cmF2ZXJzZSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Ly8gVGhpcyB3aWxsIHNvb24gc3VwcG9ydCBiaW5kaW5ncyAvIGxpc3RlbmVycyBldGMsIG11Y2ggbW9yZVxuXHQvLyBhZHZhbmNlZCBnZW5lcmF0ZWQgY29kZSBiYXNlZCBvbiBvcHRpb25zIHBhc3NlZCBpbi5cblx0UHJvcGVydHlEZWNsYXJhdGlvbi5wcm90b3R5cGUuYyA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBvID0gdGhpcy5vcHRpb25zKCk7XG5cdFx0dmFyIGFzdCA9IFwiXCI7XG5cdFx0dmFyIGtleSA9IHRoaXMubmFtZSgpLmpzKCk7XG5cdFx0dmFyIHNjb3BlID0gU1RBQ0suc2NvcGUoKTtcblx0XHRcblx0XHR2YXIgYWRkRGVzYyA9IG8ua2V5cygpLmxlbmd0aDtcblx0XHRcblx0XHR2YXIgcGFycyA9IG8uaGFzaCgpO1xuXHRcdFxuXHRcdHZhciBpc0F0dHIgPSAodGhpcy5fdG9rZW4gJiYgU3RyaW5nKHRoaXMuX3Rva2VuKSA9PSAnYXR0cicpIHx8IG8ua2V5KCdhdHRyJyk7XG5cdFx0XG5cdFx0dmFyIGpzID0ge1xuXHRcdFx0a2V5OiBrZXksXG5cdFx0XHRnZXR0ZXI6IGtleSxcblx0XHRcdHNldHRlcjogc3ltX18oKFwic2V0LVwiICsga2V5KSksXG5cdFx0XHRzY29wZTogKFwiXCIgKyAoc2NvcGUuY29udGV4dCgpLmMoKSkpLFxuXHRcdFx0cGF0aDogJyR7c2NvcGV9LnByb3RvdHlwZScsXG5cdFx0XHRzZXQ6IChcInRoaXMuX1wiICsga2V5ICsgXCIgPSB2XCIpLFxuXHRcdFx0Z2V0OiAoXCJ0aGlzLl9cIiArIGtleSksXG5cdFx0XHRpbml0OiBcIlwiLFxuXHRcdFx0aGVhZGVyczogXCJcIixcblx0XHRcdG9uZGlydHk6IFwiXCJcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdGlmIChwYXJzLmlubGluZSkge1xuXHRcdFx0aWYgKChwYXJzLmlubGluZSBpbnN0YW5jZW9mIEJvb2wpICYmICFwYXJzLmlubGluZS50cnV0aHkoKSkge1xuXHRcdFx0XHRvLnJlbW92ZSgnaW5saW5lJyk7XG5cdFx0XHRcdC8vIHAgXCJkb250IG1ha2UgYXR0ciBpbmxpbmUoISlcIlxuXHRcdFx0XHRyZXR1cm4gKFwiSW1iYS5cIiArICh0aGlzLl90b2tlbikgKyBcIihcIiArIChqcy5zY29wZSkgKyBcIiwnXCIgKyAodGhpcy5uYW1lKCkudmFsdWUoKSkgKyBcIicsXCIgKyAoby5jKCkpICsgXCIpXCIpLnJlcGxhY2UoJyx7fSknLCcpJyk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHQvLyBwIFwicGFycyBpbmxpbmU/IT8ge3BhcnM6aW5saW5lfVwiLCB0eXBlb2YgcGFyczppbmxpbmVcblx0XHR9O1xuXHRcdFxuXHRcdHZhciB0cGwgPSBwcm9wVGVtcGxhdGU7XG5cdFx0XG5cdFx0by5hZGQoJ25hbWUnLG5ldyBTeW1ib2woa2V5KSk7XG5cdFx0XG5cdFx0aWYgKHBhcnMud2F0Y2gpIHtcblx0XHRcdC8vIHAgXCJ3YXRjaCBpcyBhIHByb3BlcnR5IHtwYXJzOndhdGNofVwiXG5cdFx0XHRpZiAoISgocGFycy53YXRjaCBpbnN0YW5jZW9mIEJvb2wpICYmICFwYXJzLndhdGNoLnRydXRoeSgpKSkgeyB0cGwgPSBwcm9wV2F0Y2hUZW1wbGF0ZSB9O1xuXHRcdFx0dmFyIHdmbiA9IChcIlwiICsga2V5ICsgXCJEaWRTZXRcIik7XG5cdFx0XHRcblx0XHRcdGlmIChwYXJzLndhdGNoIGluc3RhbmNlb2YgU3ltYm9sKSB7XG5cdFx0XHRcdHdmbiA9IHBhcnMud2F0Y2g7XG5cdFx0XHR9IGVsc2UgaWYgKHBhcnMud2F0Y2ggaW5zdGFuY2VvZiBCb29sKSB7XG5cdFx0XHRcdG8ua2V5KCd3YXRjaCcpLnNldFZhbHVlKG5ldyBTeW1ib2woKFwiXCIgKyBrZXkgKyBcIkRpZFNldFwiKSkpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dmFyIGZuID0gT1AoJy4nLG5ldyBUaGlzKCksd2ZuKTtcblx0XHRcdGpzLm9uZGlydHkgPSBPUCgnJiYnLGZuLENBTEwoZm4sWyd2JywnYScsKFwidGhpcy5fX1wiICsga2V5KV0pKS5jKCk7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAocGFycy5vYnNlcnZlKSB7XG5cdFx0XHRpZiAocGFycy5vYnNlcnZlIGluc3RhbmNlb2YgQm9vbCkge1xuXHRcdFx0XHRvLmtleSgnb2JzZXJ2ZScpLnNldFZhbHVlKG5ldyBTeW1ib2woKFwiXCIgKyBrZXkgKyBcIkRpZEVtaXRcIikpKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHRwbCA9IHByb3BXYXRjaFRlbXBsYXRlO1xuXHRcdFx0anMub25kaXJ0eSA9IChcIkltYmEub2JzZXJ2ZVByb3BlcnR5KHRoaXMsJ1wiICsga2V5ICsgXCInLFwiICsgKG8ua2V5KCdvYnNlcnZlJykudmFsdWUoKS5jKCkpICsgXCIsdixhKTtcIikgKyAoanMub25kaXJ0eSB8fCAnJyk7XG5cdFx0XHQvLyBPUCgnJiYnLGZuLENBTEwoZm4sWyd2JywnYScsXCJ0aGlzLl9fe2tleX1cIl0pKS5jXG5cdFx0fTtcblx0XHRcblx0XHRpZiAoKHRoaXMuX3Rva2VuICYmIFN0cmluZyh0aGlzLl90b2tlbikgPT0gJ2F0dHInKSB8fCBvLmtleSgnZG9tJykgfHwgby5rZXkoJ2F0dHInKSkge1xuXHRcdFx0dmFyIGF0dHJLZXkgPSBvLmtleSgnZG9tJykgaW5zdGFuY2VvZiBTdHIgPyAoby5rZXkoJ2RvbScpKSA6ICh0aGlzLm5hbWUoKS52YWx1ZSgpKTtcblx0XHRcdC8vIG5lZWQgdG8gbWFrZSBzdXJlIG8gaGFzIGEga2V5IGZvciBhdHRyIHRoZW4gLSBzbyB0aGF0IHRoZSBkZWxlZ2F0ZSBjYW4ga25vdz9cblx0XHRcdGpzLnNldCA9IChcInRoaXMuc2V0QXR0cmlidXRlKCdcIiArIGF0dHJLZXkgKyBcIicsdilcIik7XG5cdFx0XHRqcy5nZXQgPSAoXCJ0aGlzLmdldEF0dHJpYnV0ZSgnXCIgKyBhdHRyS2V5ICsgXCInKVwiKTtcblx0XHR9IGVsc2UgaWYgKG8ua2V5KCdkZWxlZ2F0ZScpKSB7XG5cdFx0XHQvLyBpZiB3ZSBoYXZlIGEgZGVsZWdhdGVcblx0XHRcdGpzLnNldCA9IChcInYgPSB0aGlzLl9fXCIgKyBrZXkgKyBcIi5kZWxlZ2F0ZS5zZXQodGhpcywnXCIgKyBrZXkgKyBcIicsdix0aGlzLl9fXCIgKyBrZXkgKyBcIilcIik7XG5cdFx0XHRqcy5nZXQgPSAoXCJ0aGlzLl9fXCIgKyBrZXkgKyBcIi5kZWxlZ2F0ZS5nZXQodGhpcywnXCIgKyBrZXkgKyBcIicsdGhpcy5fX1wiICsga2V5ICsgXCIpXCIpO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0XG5cdFx0aWYgKHBhcnMuZGVmYXVsdCkge1xuXHRcdFx0aWYgKG8ua2V5KCdkb20nKSkge1xuXHRcdFx0XHQvLyBGSVhNRSBnbyB0aHJvdWdoIGNsYXNzLW1ldGhvZCBzZXRBdHRyaWJ1dGUgaW5zdGVhZFxuXHRcdFx0XHRqcy5pbml0ID0gKFwiXCIgKyAoanMuc2NvcGUpICsgXCIuZG9tKCkuc2V0QXR0cmlidXRlKCdcIiArIGtleSArIFwiJyxcIiArIChwYXJzLmRlZmF1bHQuYygpKSArIFwiKTtcIik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBpZiB0aGlzIGlzIG5vdCBhIHByaW1pdGl2ZSAtIGl0IE1VU1QgYmUgaW5jbHVkZWQgaW4gdGhlXG5cdFx0XHRcdC8vIGdldHRlciAvIHNldHRlciBpbnN0ZWFkXG5cdFx0XHRcdGpzLmluaXQgPSAoXCJcIiArIChqcy5zY29wZSkgKyBcIi5wcm90b3R5cGUuX1wiICsga2V5ICsgXCIgPSBcIiArIChwYXJzLmRlZmF1bHQuYygpKSArIFwiO1wiKTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoby5rZXkoJ2NoYWluYWJsZScpKSB7XG5cdFx0XHRqcy5nZXQgPSAoXCJ2ICE9PSB1bmRlZmluZWQgPyAodGhpcy5cIiArIChqcy5zZXR0ZXIpICsgXCIodiksdGhpcykgOiBcIiArIChqcy5nZXQpKTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdGpzLm9wdGlvbnMgPSBvLmMoKTtcblx0XHRcblx0XHRpZiAoYWRkRGVzYykge1xuXHRcdFx0anMuaGVhZGVycyA9IChcIlwiICsgKGpzLnBhdGgpICsgXCIuX19cIiArIChqcy5nZXR0ZXIpICsgXCIgPSBcIiArIChqcy5vcHRpb25zKSArIFwiO1wiKTtcblx0XHR9O1xuXHRcdFxuXHRcdHZhciByZWcgPSAvXFwkXFx7KFxcdyspXFx9L2dtO1xuXHRcdC8vIHZhciB0cGwgPSBvLmtleSg6d2F0Y2gpID8gcHJvcFdhdGNoVGVtcGxhdGUgOiBwcm9wVGVtcGxhdGVcblx0XHR2YXIgb3V0ID0gdHBsLnJlcGxhY2UocmVnLGZ1bmN0aW9uKG0sYSkgeyByZXR1cm4ganNbYV07IH0pO1xuXHRcdC8vIHJ1biBhbm90aGVyIHRpbWUgZm9yIG5lc3RpbmcuIGhhY2t5XG5cdFx0b3V0ID0gb3V0LnJlcGxhY2UocmVnLGZ1bmN0aW9uKG0sYSkgeyByZXR1cm4ganNbYV07IH0pO1xuXHRcdC8vIG91dCA9IG91dC5yZXBsYWNlKC9cXG5cXHMqJC8sJycpXG5cdFx0b3V0ID0gb3V0LnJlcGxhY2UoL15cXHMrfFxccyskL2csJycpO1xuXHRcdFxuXHRcdC8vIGlmIG8ua2V5KDp2KVxuXHRcdHJldHVybiBvdXQ7XG5cdH07XG5cdFxuXHRcblx0XG5cdC8vIExpdGVyYWxzIHNob3VsZCBwcm9iYWJseSBub3QgaW5oZXJpdCBmcm9tIHRoZSBzYW1lIHBhcmVudFxuXHQvLyBhcyBhcnJheXMsIHR1cGxlcywgb2JqZWN0cyB3b3VsZCBiZSBiZXR0ZXIgb2ZmIGluaGVyaXRpbmdcblx0Ly8gZnJvbSBsaXN0bm9kZS5cblx0XG5cdGZ1bmN0aW9uIExpdGVyYWwodil7XG5cdFx0dGhpcy5fdHJhdmVyc2VkID0gZmFsc2U7XG5cdFx0dGhpcy5fZXhwcmVzc2lvbiA9IHRydWU7XG5cdFx0dGhpcy5fY2FjaGUgPSBudWxsO1xuXHRcdHRoaXMuX3JhdyA9IG51bGw7XG5cdFx0dGhpcy5fdmFsdWUgPSB2O1xuXHR9O1xuXHRcblx0c3ViY2xhc3MkKExpdGVyYWwsVmFsdWVOb2RlKTtcblx0ZXhwb3J0cy5MaXRlcmFsID0gTGl0ZXJhbDsgLy8gZXhwb3J0IGNsYXNzIFxuXHRMaXRlcmFsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiBcIlwiICsgdGhpcy52YWx1ZSgpO1xuXHR9O1xuXHRcblx0TGl0ZXJhbC5wcm90b3R5cGUuaGFzU2lkZUVmZmVjdHMgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cdFxuXHRcblx0ZnVuY3Rpb24gQm9vbCh2KXtcblx0XHR0aGlzLl92YWx1ZSA9IHY7XG5cdFx0dGhpcy5fcmF3ID0gU3RyaW5nKHYpID09IFwidHJ1ZVwiID8gKHRydWUpIDogKGZhbHNlKTtcblx0fTtcblx0XG5cdHN1YmNsYXNzJChCb29sLExpdGVyYWwpO1xuXHRleHBvcnRzLkJvb2wgPSBCb29sOyAvLyBleHBvcnQgY2xhc3MgXG5cdEJvb2wucHJvdG90eXBlLmNhY2hlID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRCb29sLnByb3RvdHlwZS5pc1ByaW1pdGl2ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXHRcblx0Qm9vbC5wcm90b3R5cGUudHJ1dGh5ID0gZnVuY3Rpb24gKCl7XG5cdFx0Ly8gcCBcImJvb2wgaXMgdHJ1dGh5PyB7dmFsdWV9XCJcblx0XHRyZXR1cm4gU3RyaW5nKHRoaXMudmFsdWUoKSkgPT0gXCJ0cnVlXCI7XG5cdFx0Ly8geWVzXG5cdH07XG5cdFxuXHRCb29sLnByb3RvdHlwZS5qcyA9IGZ1bmN0aW9uIChvKXtcblx0XHRyZXR1cm4gU3RyaW5nKHRoaXMuX3ZhbHVlKTtcblx0fTtcblx0XG5cdEJvb2wucHJvdG90eXBlLmMgPSBmdW5jdGlvbiAoKXtcblx0XHRTVEFDSy5fY291bnRlciArPSAxO1xuXHRcdC8vIHVuZGVmaW5lZCBzaG91bGQgbm90IGJlIGEgYm9vbFxuXHRcdHJldHVybiBTdHJpbmcodGhpcy5fdmFsdWUpO1xuXHRcdC8vIEByYXcgPyBcInRydWVcIiA6IFwiZmFsc2VcIlxuXHR9O1xuXHRcblx0Qm9vbC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHt0eXBlOiAnQm9vbCcsdmFsdWU6IHRoaXMuX3ZhbHVlfTtcblx0fTtcblx0XG5cdGZ1bmN0aW9uIFVuZGVmaW5lZCgpeyByZXR1cm4gTGl0ZXJhbC5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XG5cdHN1YmNsYXNzJChVbmRlZmluZWQsTGl0ZXJhbCk7XG5cdGV4cG9ydHMuVW5kZWZpbmVkID0gVW5kZWZpbmVkOyAvLyBleHBvcnQgY2xhc3MgXG5cdFVuZGVmaW5lZC5wcm90b3R5cGUuaXNQcmltaXRpdmUgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblx0XG5cdFVuZGVmaW5lZC5wcm90b3R5cGUuYyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiBtYXJrX18odGhpcy5fdmFsdWUpICsgXCJ1bmRlZmluZWRcIjtcblx0fTtcblx0XG5cdGZ1bmN0aW9uIE5pbCgpeyByZXR1cm4gTGl0ZXJhbC5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XG5cdHN1YmNsYXNzJChOaWwsTGl0ZXJhbCk7XG5cdGV4cG9ydHMuTmlsID0gTmlsOyAvLyBleHBvcnQgY2xhc3MgXG5cdE5pbC5wcm90b3R5cGUuaXNQcmltaXRpdmUgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblx0XG5cdE5pbC5wcm90b3R5cGUuYyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiBtYXJrX18odGhpcy5fdmFsdWUpICsgXCJudWxsXCI7XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBUcnVlKCl7IHJldHVybiBCb29sLmFwcGx5KHRoaXMsYXJndW1lbnRzKSB9O1xuXHRcblx0c3ViY2xhc3MkKFRydWUsQm9vbCk7XG5cdGV4cG9ydHMuVHJ1ZSA9IFRydWU7IC8vIGV4cG9ydCBjbGFzcyBcblx0VHJ1ZS5wcm90b3R5cGUucmF3ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cdFxuXHRUcnVlLnByb3RvdHlwZS5jID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIG1hcmtfXyh0aGlzLl92YWx1ZSkgKyBcInRydWVcIjtcblx0fTtcblx0XG5cdGZ1bmN0aW9uIEZhbHNlKCl7IHJldHVybiBCb29sLmFwcGx5KHRoaXMsYXJndW1lbnRzKSB9O1xuXHRcblx0c3ViY2xhc3MkKEZhbHNlLEJvb2wpO1xuXHRleHBvcnRzLkZhbHNlID0gRmFsc2U7IC8vIGV4cG9ydCBjbGFzcyBcblx0RmFsc2UucHJvdG90eXBlLnJhdyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblx0XG5cdEZhbHNlLnByb3RvdHlwZS5jID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIG1hcmtfXyh0aGlzLl92YWx1ZSkgKyBcImZhbHNlXCI7XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBOdW0odil7XG5cdFx0dGhpcy5fdHJhdmVyc2VkID0gZmFsc2U7XG5cdFx0dGhpcy5fdmFsdWUgPSB2O1xuXHR9O1xuXHRcblx0c3ViY2xhc3MkKE51bSxMaXRlcmFsKTtcblx0ZXhwb3J0cy5OdW0gPSBOdW07IC8vIGV4cG9ydCBjbGFzcyBcblx0TnVtLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiBTdHJpbmcodGhpcy5fdmFsdWUpO1xuXHR9O1xuXHRcblx0TnVtLnByb3RvdHlwZS5pc1ByaW1pdGl2ZSA9IGZ1bmN0aW9uIChkZWVwKXtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblx0XG5cdE51bS5wcm90b3R5cGUuc2hvdWxkUGFyZW50aGVzaXplID0gZnVuY3Rpb24gKHBhcil7XG5cdFx0aWYocGFyID09PSB1bmRlZmluZWQpIHBhciA9IHRoaXMudXAoKTtcblx0XHRyZXR1cm4gKHBhciBpbnN0YW5jZW9mIEFjY2VzcykgJiYgcGFyLmxlZnQoKSA9PSB0aGlzO1xuXHR9O1xuXHRcblx0TnVtLnByb3RvdHlwZS5qcyA9IGZ1bmN0aW9uIChvKXtcblx0XHR2YXIgbnVtID0gU3RyaW5nKHRoaXMuX3ZhbHVlKTtcblx0XHQvLyBjb25zb2xlLmxvZyBcImNvbXBpbGVkIG51bSB0byB7bnVtfVwiXG5cdFx0cmV0dXJuIG51bTtcblx0fTtcblx0XG5cdE51bS5wcm90b3R5cGUuYyA9IGZ1bmN0aW9uIChvKXtcblx0XHRpZiAodGhpcy5fY2FjaGUpIHsgcmV0dXJuIE51bS5fX3N1cGVyX18uYy5jYWxsKHRoaXMsbykgfTtcblx0XHR2YXIganMgPSBTdHJpbmcodGhpcy5fdmFsdWUpO1xuXHRcdHZhciBwYXIgPSBTVEFDSy5jdXJyZW50KCk7XG5cdFx0dmFyIHBhcmVuID0gKHBhciBpbnN0YW5jZW9mIEFjY2VzcykgJiYgcGFyLmxlZnQoKSA9PSB0aGlzO1xuXHRcdC8vIG9ubHkgaWYgdGhpcyBpcyB0aGUgcmlnaHQgcGFydCBvZiB0ZWggYWNjZXNcblx0XHQvLyBjb25zb2xlLmxvZyBcInNob3VsZCBwYXJlbj8/IHtzaG91bGRQYXJlbnRoZXNpemV9XCJcblx0XHRyZXR1cm4gcGFyZW4gPyAoKFwiKFwiICsgbWFya19fKHRoaXMuX3ZhbHVlKSkgKyBqcyArIFwiKVwiKSA6ICgobWFya19fKHRoaXMuX3ZhbHVlKSArIGpzKSk7XG5cdFx0Ly8gQGNhY2hlID8gc3VwZXIobykgOiBTdHJpbmcoQHZhbHVlKVxuXHR9O1xuXHRcblx0TnVtLnByb3RvdHlwZS5jYWNoZSA9IGZ1bmN0aW9uIChvKXtcblx0XHQvLyBwIFwiY2FjaGUgbnVtXCIsb1xuXHRcdGlmICghKG8gJiYgKG8uY2FjaGUgfHwgby5wb29sKSkpIHsgcmV0dXJuIHRoaXMgfTtcblx0XHRyZXR1cm4gTnVtLl9fc3VwZXJfXy5jYWNoZS5jYWxsKHRoaXMsbyk7XG5cdH07XG5cdFxuXHROdW0ucHJvdG90eXBlLnJhdyA9IGZ1bmN0aW9uICgpe1xuXHRcdC8vIHJlYWxseT9cblx0XHRyZXR1cm4gSlNPTi5wYXJzZShTdHJpbmcodGhpcy52YWx1ZSgpKSk7XG5cdH07XG5cdFxuXHROdW0ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB7dHlwZTogdGhpcy50eXBlTmFtZSgpLHZhbHVlOiB0aGlzLnJhdygpfTtcblx0fTtcblx0XG5cdC8vIHNob3VsZCBiZSBxdW90ZWQgbm8/XG5cdC8vIHdoYXQgYWJvdXQgc3RyaW5ncyBpbiBvYmplY3QtbGl0ZXJhbHM/XG5cdC8vIHdlIHdhbnQgdG8gYmUgYWJsZSB0byBzZWUgaWYgdGhlIHZhbHVlcyBhcmUgYWxsb3dlZFxuXHRmdW5jdGlvbiBTdHIodil7XG5cdFx0dGhpcy5fdHJhdmVyc2VkID0gZmFsc2U7XG5cdFx0dGhpcy5fZXhwcmVzc2lvbiA9IHRydWU7XG5cdFx0dGhpcy5fY2FjaGUgPSBudWxsO1xuXHRcdHRoaXMuX3ZhbHVlID0gdjtcblx0XHQvLyBzaG91bGQgZ3JhYiB0aGUgYWN0dWFsIHZhbHVlIGltbWVkaWF0ZWx5P1xuXHR9O1xuXHRcblx0c3ViY2xhc3MkKFN0cixMaXRlcmFsKTtcblx0ZXhwb3J0cy5TdHIgPSBTdHI7IC8vIGV4cG9ydCBjbGFzcyBcblx0U3RyLnByb3RvdHlwZS5pc1N0cmluZyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXHRcblx0U3RyLnByb3RvdHlwZS5pc1ByaW1pdGl2ZSA9IGZ1bmN0aW9uIChkZWVwKXtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblx0XG5cdFN0ci5wcm90b3R5cGUucmF3ID0gZnVuY3Rpb24gKCl7XG5cdFx0Ly8gSlNPTi5wYXJzZSByZXF1aXJlcyBkb3VibGUtcXVvdGVkIHN0cmluZ3MsXG5cdFx0Ly8gd2hpbGUgZXZhbCBhbHNvIGFsbG93cyBzaW5nbGUgcXVvdGVzLiBcblx0XHQvLyBORVhUIGV2YWwgaXMgbm90IGFjY2Vzc2libGUgbGlrZSB0aGlzXG5cdFx0Ly8gV0FSTklORyBUT0RPIGJlIGNhcmVmdWwhIC0gc2hvdWxkIGNsZWFuIHVwXG5cdFx0XG5cdFx0cmV0dXJuIHRoaXMuX3JhdyB8fCAodGhpcy5fcmF3ID0gU3RyaW5nKHRoaXMudmFsdWUoKSkuc2xpY2UoMSwtMSkpOyAvLyBpbmNyZWRpYmx5IHN0dXBpZCBzb2x1dGlvblxuXHR9O1xuXHRcblx0U3RyLnByb3RvdHlwZS5pc1ZhbGlkSWRlbnRpZmllciA9IGZ1bmN0aW9uICgpe1xuXHRcdC8vIHRoZXJlIGFyZSBhbHNvIHNvbWUgdmFsdWVzIHdlIGNhbm5vdCB1c2Vcblx0XHRyZXR1cm4gdGhpcy5yYXcoKS5tYXRjaCgvXlthLXpBLVpcXCRcXF9dK1tcXGRcXHdcXCRcXF9dKiQvKSA/ICh0cnVlKSA6IChmYWxzZSk7XG5cdH07XG5cdFxuXHRTdHIucHJvdG90eXBlLmpzID0gZnVuY3Rpb24gKG8pe1xuXHRcdHJldHVybiBTdHJpbmcodGhpcy5fdmFsdWUpO1xuXHR9O1xuXHRcblx0U3RyLnByb3RvdHlwZS5jID0gZnVuY3Rpb24gKG8pe1xuXHRcdHJldHVybiB0aGlzLl9jYWNoZSA/IChTdHIuX19zdXBlcl9fLmMuY2FsbCh0aGlzLG8pKSA6IChTdHJpbmcodGhpcy5fdmFsdWUpKTtcblx0fTtcblx0XG5cdFxuXHRmdW5jdGlvbiBJbnRlcnBvbGF0aW9uKCl7IHJldHVybiBWYWx1ZU5vZGUuYXBwbHkodGhpcyxhcmd1bWVudHMpIH07XG5cdFxuXHRzdWJjbGFzcyQoSW50ZXJwb2xhdGlvbixWYWx1ZU5vZGUpO1xuXHRleHBvcnRzLkludGVycG9sYXRpb24gPSBJbnRlcnBvbGF0aW9uOyAvLyBleHBvcnQgY2xhc3MgXG5cdFxuXHRcblx0Ly8gQ3VycmVudGx5IG5vdCB1c2VkIC0gaXQgd291bGQgYmUgYmV0dGVyIHRvIHVzZSB0aGlzXG5cdC8vIGZvciByZWFsIGludGVycG9sYXRlZCBzdHJpbmdzIHRob3VnaCwgdGhhbiB0byBicmVha1xuXHQvLyB0aGVtIHVwIGludG8gdGhlaXIgcGFydHMgYmVmb3JlIHBhcnNpbmdcblx0ZnVuY3Rpb24gSW50ZXJwb2xhdGVkU3RyaW5nKG5vZGVzLG8pe1xuXHRcdGlmKG8gPT09IHVuZGVmaW5lZCkgbyA9IHt9O1xuXHRcdHRoaXMuX25vZGVzID0gbm9kZXM7XG5cdFx0dGhpcy5fb3B0aW9ucyA9IG87XG5cdFx0dGhpcztcblx0fTtcblx0XG5cdHN1YmNsYXNzJChJbnRlcnBvbGF0ZWRTdHJpbmcsTm9kZSk7XG5cdGV4cG9ydHMuSW50ZXJwb2xhdGVkU3RyaW5nID0gSW50ZXJwb2xhdGVkU3RyaW5nOyAvLyBleHBvcnQgY2xhc3MgXG5cdEludGVycG9sYXRlZFN0cmluZy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHBhcnQpe1xuXHRcdGlmIChwYXJ0KSB7IHRoaXMuX25vZGVzLnB1c2gocGFydCkgfTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEludGVycG9sYXRlZFN0cmluZy5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAoKXtcblx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQodGhpcy5fbm9kZXMpLCBsZW4gPSBhcnkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGFyeVtpXS50cmF2ZXJzZSgpO1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbnRlcnBvbGF0ZWRTdHJpbmcucHJvdG90eXBlLmVzY2FwZVN0cmluZyA9IGZ1bmN0aW9uIChzdHIpe1xuXHRcdC8vIHZhciBpZHggPSAwXG5cdFx0Ly8gdmFyIGxlbiA9IHN0cjpsZW5ndGhcblx0XHQvLyB2YXIgY2hyXG5cdFx0Ly8gd2hpbGUgY2hyID0gc3RyW2lkeCsrXVxuXHRcdHJldHVybiBzdHIgPSBzdHIucmVwbGFjZSgvXFxuL2csJ1xcXFxcXG4nKTtcblx0fTtcblx0XG5cdEludGVycG9sYXRlZFN0cmluZy5wcm90b3R5cGUuanMgPSBmdW5jdGlvbiAobyl7XG5cdFx0Ly8gY3JlYXRpbmcgdGhlIHN0cmluZ1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR2YXIgcGFydHMgPSBbXTtcblx0XHR2YXIgc3RyID0gJygnO1xuXHRcdFxuXHRcdHNlbGYuX25vZGVzLm1hcChmdW5jdGlvbihwYXJ0LGkpIHtcblx0XHRcdGlmICgocGFydCBpbnN0YW5jZW9mIFRva2VuKSAmJiBwYXJ0Ll90eXBlID09ICdORU9TVFJJTkcnKSB7XG5cdFx0XHRcdC8vIGVzY2Fcblx0XHRcdFx0cmV0dXJuIHBhcnRzLnB1c2goJ1wiJyArIHNlbGYuZXNjYXBlU3RyaW5nKHBhcnQuX3ZhbHVlKSArICdcIicpO1xuXHRcdFx0fSBlbHNlIGlmIChwYXJ0KSB7XG5cdFx0XHRcdGlmIChpID09IDApIHtcblx0XHRcdFx0XHQvLyBmb3JjZSBmaXJzdCBwYXJ0IHRvIGJlIHN0cmluZ1xuXHRcdFx0XHRcdHBhcnRzLnB1c2goJ1wiXCInKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0cGFydC5fcGFyZW5zID0gdHJ1ZTtcblx0XHRcdFx0cmV0dXJuIHBhcnRzLnB1c2gocGFydC5jKHtleHByZXNzaW9uOiB0cnVlfSkpO1xuXHRcdFx0fTtcblx0XHR9KTtcblx0XHRcblx0XHRzdHIgKz0gcGFydHMuam9pbihcIiArIFwiKTtcblx0XHRzdHIgKz0gJyknO1xuXHRcdHJldHVybiBzdHI7XG5cdH07XG5cdFxuXHRcblx0ZnVuY3Rpb24gVHVwbGUoKXsgcmV0dXJuIExpc3ROb2RlLmFwcGx5KHRoaXMsYXJndW1lbnRzKSB9O1xuXHRcblx0c3ViY2xhc3MkKFR1cGxlLExpc3ROb2RlKTtcblx0ZXhwb3J0cy5UdXBsZSA9IFR1cGxlOyAvLyBleHBvcnQgY2xhc3MgXG5cdFR1cGxlLnByb3RvdHlwZS5jID0gZnVuY3Rpb24gKCl7XG5cdFx0Ly8gY29tcGlsZXMgYXMgYW4gYXJyYXlcblx0XHRyZXR1cm4gbmV3IEFycih0aGlzLm5vZGVzKCkpLmMoKTtcblx0fTtcblx0XG5cdFR1cGxlLnByb3RvdHlwZS5oYXNTcGxhdCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbih2KSB7IHJldHVybiB2IGluc3RhbmNlb2YgU3BsYXQ7IH0pWzBdO1xuXHR9O1xuXHRcblx0VHVwbGUucHJvdG90eXBlLmNvbnN1bWUgPSBmdW5jdGlvbiAobm9kZSl7XG5cdFx0aWYgKHRoaXMuY291bnQoKSA9PSAxKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5maXJzdCgpLmNvbnN1bWUobm9kZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IFwibXVsdGl0dXBsZSBjYW5ub3QgY29uc3VtZVwiO1xuXHRcdH07XG5cdH07XG5cdFxuXHRcblx0Ly8gQmVjYXVzZSB3ZSd2ZSBkcm9wcGVkIHRoZSBTdHItd3JhcHBlciBpdCBpcyBraW5kYSBkaWZmaWN1bHRcblx0ZnVuY3Rpb24gU3ltYm9sKCl7IHJldHVybiBMaXRlcmFsLmFwcGx5KHRoaXMsYXJndW1lbnRzKSB9O1xuXHRcblx0c3ViY2xhc3MkKFN5bWJvbCxMaXRlcmFsKTtcblx0ZXhwb3J0cy5TeW1ib2wgPSBTeW1ib2w7IC8vIGV4cG9ydCBjbGFzcyBcblx0U3ltYm9sLnByb3RvdHlwZS5pc1ZhbGlkSWRlbnRpZmllciA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLnJhdygpLm1hdGNoKC9eW2EtekEtWlxcJFxcX10rW1xcZFxcd1xcJFxcX10qJC8pID8gKHRydWUpIDogKGZhbHNlKTtcblx0fTtcblx0XG5cdFN5bWJvbC5wcm90b3R5cGUuaXNQcmltaXRpdmUgPSBmdW5jdGlvbiAoZGVlcCl7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cdFxuXHRTeW1ib2wucHJvdG90eXBlLnJhdyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9yYXcgfHwgKHRoaXMuX3JhdyA9IHN5bV9fKHRoaXMudmFsdWUoKSkpO1xuXHR9O1xuXHRcblx0U3ltYm9sLnByb3RvdHlwZS5qcyA9IGZ1bmN0aW9uIChvKXtcblx0XHRyZXR1cm4gKFwiJ1wiICsgc3ltX18odGhpcy52YWx1ZSgpKSArIFwiJ1wiKTtcblx0fTtcblx0XG5cdGZ1bmN0aW9uIFJlZ0V4cCgpeyByZXR1cm4gTGl0ZXJhbC5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XG5cdHN1YmNsYXNzJChSZWdFeHAsTGl0ZXJhbCk7XG5cdGV4cG9ydHMuUmVnRXhwID0gUmVnRXhwOyAvLyBleHBvcnQgY2xhc3MgXG5cdFJlZ0V4cC5wcm90b3R5cGUuaXNQcmltaXRpdmUgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblx0XG5cdC8vIGRlZiB0b1N0cmluZ1xuXHQvLyBcdFwiXCIgKyB2YWx1ZVxuXHQ7XG5cdFxuXHQvLyBTaG91bGQgaW5oZXJpdCBmcm9tIExpc3ROb2RlIC0gd291bGQgc2ltcGxpZnlcblx0ZnVuY3Rpb24gQXJyKCl7IHJldHVybiBMaXRlcmFsLmFwcGx5KHRoaXMsYXJndW1lbnRzKSB9O1xuXHRcblx0c3ViY2xhc3MkKEFycixMaXRlcmFsKTtcblx0ZXhwb3J0cy5BcnIgPSBBcnI7IC8vIGV4cG9ydCBjbGFzcyBcblx0QXJyLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKHZhbHVlKXtcblx0XHRyZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBBcnJheSA/IChuZXcgQXJnTGlzdCh2YWx1ZSkpIDogKHZhbHVlKTtcblx0fTtcblx0XG5cdEFyci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChpdGVtKXtcblx0XHR0aGlzLnZhbHVlKCkucHVzaChpdGVtKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEFyci5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy52YWx1ZSgpLmxlbmd0aDtcblx0fTtcblx0XG5cdEFyci5wcm90b3R5cGUubm9kZXMgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgdmFsID0gdGhpcy52YWx1ZSgpO1xuXHRcdHJldHVybiB2YWwgaW5zdGFuY2VvZiBBcnJheSA/ICh2YWwpIDogKHZhbC5ub2RlcygpKTtcblx0fTtcblx0XG5cdEFyci5wcm90b3R5cGUuc3BsYXQgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy52YWx1ZSgpLnNvbWUoZnVuY3Rpb24odikgeyByZXR1cm4gdiBpbnN0YW5jZW9mIFNwbGF0OyB9KTtcblx0fTtcblx0XG5cdEFyci5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAoKXtcblx0XHRpZiAodGhpcy5fdmFsdWUgJiYgdGhpcy5fdmFsdWUudHJhdmVyc2UpIHsgdGhpcy5fdmFsdWUudHJhdmVyc2UoKSB9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0QXJyLnByb3RvdHlwZS5pc1ByaW1pdGl2ZSA9IGZ1bmN0aW9uIChkZWVwKXtcblx0XHRyZXR1cm4gIXRoaXMudmFsdWUoKS5zb21lKGZ1bmN0aW9uKHYpIHsgcmV0dXJuICF2LmlzUHJpbWl0aXZlKHRydWUpOyB9KTtcblx0fTtcblx0XG5cdEFyci5wcm90b3R5cGUuanMgPSBmdW5jdGlvbiAobyl7XG5cdFx0XG5cdFx0dmFyIHZhbCA9IHRoaXMuX3ZhbHVlO1xuXHRcdGlmICghdmFsKSB7IHJldHVybiBcIltdXCIgfTtcblx0XHRcblx0XHR2YXIgc3BsYXQgPSB0aGlzLnNwbGF0KCk7XG5cdFx0dmFyIG5vZGVzID0gdmFsIGluc3RhbmNlb2YgQXJyYXkgPyAodmFsKSA6ICh2YWwubm9kZXMoKSk7XG5cdFx0Ly8gcCBcInZhbHVlIG9mIGFycmF5IGlzYSB7QHZhbHVlfVwiXG5cdFx0XG5cdFx0Ly8gZm9yIHYgaW4gQHZhbHVlXG5cdFx0Ly8gXHRicmVhayBzcGxhdCA9IHllcyBpZiB2IGlzYSBTcGxhdFxuXHRcdC8vIHZhciBzcGxhdCA9IHZhbHVlLnNvbWUofHZ8IHYgaXNhIFNwbGF0KVxuXHRcdFxuXHRcdGlmIChzcGxhdCkge1xuXHRcdFx0Ly8gXCJTUExBVFRFRCBBUlJBWSFcIlxuXHRcdFx0Ly8gaWYgd2Uga25vdyBmb3IgY2VydGFpbiB0aGF0IHRoZSBzcGxhdHMgYXJlIGFycmF5cyB3ZSBjYW4gZHJvcCB0aGUgc2xpY2U/XG5cdFx0XHQvLyBwIFwiYXJyYXkgaXMgc3BsYXQ/IT9cIlxuXHRcdFx0dmFyIHNsaWNlcyA9IFtdO1xuXHRcdFx0dmFyIGdyb3VwID0gbnVsbDtcblx0XHRcdFxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKG5vZGVzKSwgbGVuID0gYXJ5Lmxlbmd0aCwgdjsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHYgPSBhcnlbaV07XG5cdFx0XHRcdGlmICh2IGluc3RhbmNlb2YgU3BsYXQpIHtcblx0XHRcdFx0XHRzbGljZXMucHVzaCh2KTtcblx0XHRcdFx0XHRncm91cCA9IG51bGw7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKCFncm91cCkgeyBzbGljZXMucHVzaChncm91cCA9IG5ldyBBcnIoW10pKSB9O1xuXHRcdFx0XHRcdGdyb3VwLnB1c2godik7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gKFwiW10uY29uY2F0KFwiICsgY2FyeV9fKHNsaWNlcykuam9pbihcIiwgXCIpICsgXCIpXCIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyB2ZXJ5IHRlbXBvcmFyeS4gbmVlZCBhIG1vcmUgZ2VuZXJpYyB3YXkgdG8gcHJldHRpZnkgY29kZVxuXHRcdFx0Ly8gc2hvdWxkIGRlcGVuZCBvbiB0aGUgbGVuZ3RoIG9mIHRoZSBpbm5lciBpdGVtcyBldGNcblx0XHRcdC8vIGlmIEBpbmRlbnRlZCBvciBvcHRpb24oOmluZGVudCkgb3IgdmFsdWUuQGluZGVudGVkXG5cdFx0XHQvL1x0XCJbXFxue3ZhbHVlLmMuam9pbihcIixcXG5cIikuaW5kZW50fVxcbl1cIlxuXHRcdFx0dmFyIG91dCA9IHZhbCBpbnN0YW5jZW9mIEFycmF5ID8gKGNhcnlfXyh2YWwpKSA6ICh2YWwuYygpKTtcblx0XHRcdHJldHVybiAoXCJbXCIgKyBvdXQgKyBcIl1cIik7XG5cdFx0fTtcblx0fTtcblx0XG5cdEFyci5wcm90b3R5cGUuaGFzU2lkZUVmZmVjdHMgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy52YWx1ZSgpLnNvbWUoZnVuY3Rpb24odikgeyByZXR1cm4gdi5oYXNTaWRlRWZmZWN0cygpOyB9KTtcblx0fTtcblx0XG5cdEFyci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gXCJBcnJcIjtcblx0fTtcblx0XG5cdEFyci5wcm90b3R5cGUuaW5kZW50ZWQgPSBmdW5jdGlvbiAoYSxiKXtcblx0XHR0aGlzLl92YWx1ZS5pbmRlbnRlZChhLGIpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0QXJyLndyYXAgPSBmdW5jdGlvbiAodmFsKXtcblx0XHRyZXR1cm4gbmV3IEFycih2YWwpO1xuXHR9O1xuXHRcblx0Ly8gc2hvdWxkIG5vdCBiZSBja2xhc3NpZmllZCBhcyBhIGxpdGVyYWw/XG5cdGZ1bmN0aW9uIE9iaigpeyByZXR1cm4gTGl0ZXJhbC5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XG5cdHN1YmNsYXNzJChPYmosTGl0ZXJhbCk7XG5cdGV4cG9ydHMuT2JqID0gT2JqOyAvLyBleHBvcnQgY2xhc3MgXG5cdE9iai5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICh2YWx1ZSl7XG5cdFx0cmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgQXJyYXkgPyAobmV3IEFzc2lnbkxpc3QodmFsdWUpKSA6ICh2YWx1ZSk7XG5cdH07XG5cdFxuXHRPYmoucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKCl7XG5cdFx0aWYgKHRoaXMuX3ZhbHVlKSB7IHRoaXMuX3ZhbHVlLnRyYXZlcnNlKCkgfTtcblx0XHQvLyBmb3IgdiBpbiB2YWx1ZVxuXHRcdC8vIFx0di50cmF2ZXJzZVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0T2JqLnByb3RvdHlwZS5qcyA9IGZ1bmN0aW9uIChvKXtcblx0XHR2YXIgZHluID0gdGhpcy52YWx1ZSgpLmZpbHRlcihmdW5jdGlvbih2KSB7IHJldHVybiAodiBpbnN0YW5jZW9mIE9iakF0dHIpICYmICgodi5rZXkoKSBpbnN0YW5jZW9mIE9wKSB8fCAodi5rZXkoKSBpbnN0YW5jZW9mIEludGVycG9sYXRlZFN0cmluZykpOyB9KTtcblx0XHRcblx0XHRpZiAoZHluLmxlbmd0aCA+IDApIHtcblx0XHRcdHZhciBpZHggPSB0aGlzLnZhbHVlKCkuaW5kZXhPZihkeW5bMF0pO1xuXHRcdFx0Ly8gcCBcImR5bmFtaWMga2V5cyEge2R5bn1cIlxuXHRcdFx0Ly8gY3JlYXRlIGEgdGVtcCB2YXJpYWJsZVxuXHRcdFx0XG5cdFx0XHR2YXIgdG1wID0gdGhpcy5zY29wZV9fKCkudGVtcG9yYXJ5KHRoaXMpO1xuXHRcdFx0Ly8gc2V0IHRoZSB0ZW1wb3Jhcnkgb2JqZWN0IHRvIHRoZSBzYW1lXG5cdFx0XHR2YXIgZmlyc3QgPSB0aGlzLnZhbHVlKCkuc2xpY2UoMCxpZHgpO1xuXHRcdFx0dmFyIG9iaiA9IG5ldyBPYmooZmlyc3QpO1xuXHRcdFx0dmFyIGFzdCA9IFtPUCgnPScsdG1wLG9iaildO1xuXHRcdFx0XG5cdFx0XHR0aGlzLnZhbHVlKCkuc2xpY2UoaWR4KS5mb3JFYWNoKGZ1bmN0aW9uKGF0cikge1xuXHRcdFx0XHRyZXR1cm4gYXN0LnB1c2goT1AoJz0nLE9QKCcuJyx0bXAsYXRyLmtleSgpKSxhdHIudmFsdWUoKSkpO1xuXHRcdFx0fSk7XG5cdFx0XHRhc3QucHVzaCh0bXApOyAvLyBhY2Nlc3MgdGhlIHRtcCBhdCBpbiB0aGUgbGFzdCBwYXJ0XG5cdFx0XHRyZXR1cm4gbmV3IFBhcmVucyhhc3QpLmMoKTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIGZvciBvYmplY3RzIHdpdGggZXhwcmVzc2lvbi1rZXlzIHdlIG5lZWQgdG8gdGhpbmsgZGlmZmVyZW50bHlcblx0XHRyZXR1cm4gJ3snICsgdGhpcy52YWx1ZSgpLmMoKSArICd9Jztcblx0fTtcblx0XG5cdE9iai5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGssdil7XG5cdFx0aWYgKCh0eXBlb2Ygaz09J3N0cmluZyd8fGsgaW5zdGFuY2VvZiBTdHJpbmcpKSB7IGsgPSBuZXcgSWRlbnRpZmllcihrKSB9O1xuXHRcdHZhciBrdiA9IG5ldyBPYmpBdHRyKGssdik7XG5cdFx0dGhpcy52YWx1ZSgpLnB1c2goa3YpO1xuXHRcdHJldHVybiBrdjtcblx0fTtcblx0XG5cdE9iai5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGtleSl7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHRoaXMudmFsdWUoKSksIGxlbiA9IGFyeS5sZW5ndGgsIGs7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0ayA9IGFyeVtpXTtcblx0XHRcdGlmIChrLmtleSgpLnN5bWJvbCgpID09IGtleSkgeyB0aGlzLnZhbHVlKCkucmVtb3ZlKGspIH07XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdE9iai5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmhhc2goKSk7XG5cdH07XG5cdFxuXHRPYmoucHJvdG90eXBlLmhhc2ggPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgaGFzaCA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJCh0aGlzLnZhbHVlKCkpLCBsZW4gPSBhcnkubGVuZ3RoLCBrOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGsgPSBhcnlbaV07XG5cdFx0XHRpZiAoayBpbnN0YW5jZW9mIE9iakF0dHIpIHsgaGFzaFtrLmtleSgpLnN5bWJvbCgpXSA9IGsudmFsdWUoKSB9O1xuXHRcdH07XG5cdFx0cmV0dXJuIGhhc2g7XG5cdFx0Ly8gcmV0dXJuIGsgaWYgay5rZXkuc3ltYm9sID09IGtleVxuXHR9O1xuXHRcblx0Ly8gYWRkIG1ldGhvZCBmb3IgZmluZGluZyBwcm9wZXJ0aWVzIGV0Yz9cblx0T2JqLnByb3RvdHlwZS5rZXkgPSBmdW5jdGlvbiAoa2V5KXtcblx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQodGhpcy52YWx1ZSgpKSwgbGVuID0gYXJ5Lmxlbmd0aCwgazsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrID0gYXJ5W2ldO1xuXHRcdFx0aWYgKChrIGluc3RhbmNlb2YgT2JqQXR0cikgJiYgay5rZXkoKS5zeW1ib2woKSA9PSBrZXkpIHsgcmV0dXJuIGsgfTtcblx0XHR9O1xuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXHRcblx0T2JqLnByb3RvdHlwZS5pbmRlbnRlZCA9IGZ1bmN0aW9uIChhLGIpe1xuXHRcdHRoaXMuX3ZhbHVlLmluZGVudGVkKGEsYik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRPYmoucHJvdG90eXBlLmhhc1NpZGVFZmZlY3RzID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMudmFsdWUoKS5zb21lKGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHYuaGFzU2lkZUVmZmVjdHMoKTsgfSk7XG5cdH07XG5cdFxuXHQvLyBmb3IgY29udmVydGluZyBhIHJlYWwgb2JqZWN0IGludG8gYW4gYXN0LXJlcHJlc2VudGF0aW9uXG5cdE9iai53cmFwID0gZnVuY3Rpb24gKG9iail7XG5cdFx0dmFyIGF0dHJzID0gW107XG5cdFx0Zm9yICh2YXIgdiwgaSA9IDAsIGtleXMgPSBPYmplY3Qua2V5cyhvYmopLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspe1xuXHRcdFx0diA9IG9ialtrZXlzW2ldXTtpZiAodiBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHRcdHYgPSBBcnIud3JhcCh2KTtcblx0XHRcdH0gZWxzZSBpZiAodi5jb25zdHJ1Y3RvciA9PSBPYmplY3QpIHtcblx0XHRcdFx0diA9IE9iai53cmFwKHYpO1xuXHRcdFx0fTtcblx0XHRcdGF0dHJzLnB1c2gobmV3IE9iakF0dHIoa2V5c1tpXSx2KSk7XG5cdFx0fTtcblx0XHRyZXR1cm4gbmV3IE9iaihhdHRycyk7XG5cdH07XG5cdFxuXHRPYmoucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIFwiT2JqXCI7XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBPYmpBdHRyKGtleSx2YWx1ZSl7XG5cdFx0dGhpcy5fdHJhdmVyc2VkID0gZmFsc2U7XG5cdFx0dGhpcy5fa2V5ID0ga2V5O1xuXHRcdHRoaXMuX3ZhbHVlID0gdmFsdWU7XG5cdFx0dGhpcy5fZHluYW1pYyA9IChrZXkgaW5zdGFuY2VvZiBPcCk7XG5cdFx0dGhpcztcblx0fTtcblx0XG5cdHN1YmNsYXNzJChPYmpBdHRyLE5vZGUpO1xuXHRleHBvcnRzLk9iakF0dHIgPSBPYmpBdHRyOyAvLyBleHBvcnQgY2xhc3MgXG5cdE9iakF0dHIucHJvdG90eXBlLmtleSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fa2V5OyB9XG5cdE9iakF0dHIucHJvdG90eXBlLnNldEtleSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9rZXkgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0T2JqQXR0ci5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3ZhbHVlOyB9XG5cdE9iakF0dHIucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24odil7IHRoaXMuX3ZhbHVlID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdE9iakF0dHIucHJvdG90eXBlLm9wdGlvbnMgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX29wdGlvbnM7IH1cblx0T2JqQXR0ci5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9vcHRpb25zID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRPYmpBdHRyLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICgpe1xuXHRcdC8vIHNob3VsZCBwcm9iYWJseSB0cmF2ZXJzZSBrZXkgYXMgd2VsbCwgdW5sZXNzIGl0IGlzIGEgZGVhZCBzaW1wbGUgaWRlbnRpZmllclxuXHRcdHRoaXMua2V5KCkudHJhdmVyc2UoKTtcblx0XHRyZXR1cm4gdGhpcy52YWx1ZSgpLnRyYXZlcnNlKCk7XG5cdH07XG5cdFxuXHRPYmpBdHRyLnByb3RvdHlwZS5qcyA9IGZ1bmN0aW9uIChvKXtcblx0XHR2YXIgayA9IHRoaXMua2V5KCkuaXNSZXNlcnZlZCgpID8gKChcIidcIiArICh0aGlzLmtleSgpLmMoKSkgKyBcIidcIikpIDogKHRoaXMua2V5KCkuYygpKTtcblx0XHRyZXR1cm4gKFwiXCIgKyBrICsgXCI6IFwiICsgKHRoaXMudmFsdWUoKS5jKCkpKTtcblx0fTtcblx0XG5cdE9iakF0dHIucHJvdG90eXBlLmhhc1NpZGVFZmZlY3RzID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cdFxuXHRcblx0XG5cdGZ1bmN0aW9uIEFyZ3NSZWZlcmVuY2UoKXsgcmV0dXJuIE5vZGUuYXBwbHkodGhpcyxhcmd1bWVudHMpIH07XG5cdFxuXHRzdWJjbGFzcyQoQXJnc1JlZmVyZW5jZSxOb2RlKTtcblx0ZXhwb3J0cy5BcmdzUmVmZXJlbmNlID0gQXJnc1JlZmVyZW5jZTsgLy8gZXhwb3J0IGNsYXNzIFxuXHRBcmdzUmVmZXJlbmNlLnByb3RvdHlwZS5jID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIFwiYXJndW1lbnRzXCI7XG5cdH07XG5cdFxuXHQvLyBzaG91bGQgYmUgYSBzZXBhcmF0ZSBDb250ZXh0IG9yIHNvbWV0aGluZ1xuXHRmdW5jdGlvbiBTZWxmKHNjb3BlKXtcblx0XHR0aGlzLl9zY29wZSA9IHNjb3BlO1xuXHR9O1xuXHRcblx0c3ViY2xhc3MkKFNlbGYsTGl0ZXJhbCk7XG5cdGV4cG9ydHMuU2VsZiA9IFNlbGY7IC8vIGV4cG9ydCBjbGFzcyBcblx0U2VsZi5wcm90b3R5cGUuc2NvcGUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3Njb3BlOyB9XG5cdFNlbGYucHJvdG90eXBlLnNldFNjb3BlID0gZnVuY3Rpb24odil7IHRoaXMuX3Njb3BlID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRTZWxmLnByb3RvdHlwZS5jYWNoZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0U2VsZi5wcm90b3R5cGUucmVmZXJlbmNlID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRTZWxmLnByb3RvdHlwZS5jID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHMgPSB0aGlzLnNjb3BlX18oKTtcblx0XHRyZXR1cm4gcyA/IChzLmNvbnRleHQoKS5jKCkpIDogKFwidGhpc1wiKTtcblx0fTtcblx0XG5cdGZ1bmN0aW9uIEltcGxpY2l0U2VsZigpeyByZXR1cm4gU2VsZi5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XG5cdHN1YmNsYXNzJChJbXBsaWNpdFNlbGYsU2VsZik7XG5cdGV4cG9ydHMuSW1wbGljaXRTZWxmID0gSW1wbGljaXRTZWxmOyAvLyBleHBvcnQgY2xhc3MgXG5cdFxuXHRcblx0ZnVuY3Rpb24gVGhpcygpeyByZXR1cm4gU2VsZi5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XG5cdHN1YmNsYXNzJChUaGlzLFNlbGYpO1xuXHRleHBvcnRzLlRoaXMgPSBUaGlzOyAvLyBleHBvcnQgY2xhc3MgXG5cdFRoaXMucHJvdG90eXBlLmNhY2hlID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRUaGlzLnByb3RvdHlwZS5yZWZlcmVuY2UgPSBmdW5jdGlvbiAoKXtcblx0XHQvLyBwIFwicmVmZXJlbmNpbmcgdGhpc1wiXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRUaGlzLnByb3RvdHlwZS5jID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIFwidGhpc1wiO1xuXHR9O1xuXHRcblx0XG5cdFxuXHRcblx0Ly8gT1BFUkFUT1JTXG5cdFxuXHRmdW5jdGlvbiBPcChvLGwscil7XG5cdFx0Ly8gc2V0IGV4cHJlc3Npb24geWVzLCBubz9cblx0XHR0aGlzLl9leHByZXNzaW9uID0gZmFsc2U7XG5cdFx0dGhpcy5fdHJhdmVyc2VkID0gZmFsc2U7XG5cdFx0dGhpcy5fcGFyZW5zID0gZmFsc2U7XG5cdFx0dGhpcy5fY2FjaGUgPSBudWxsO1xuXHRcdHRoaXMuX2ludmVydCA9IGZhbHNlO1xuXHRcdHRoaXMuX29wVG9rZW4gPSBvO1xuXHRcdHRoaXMuX29wID0gbyAmJiBvLl92YWx1ZSB8fCBvO1xuXHRcdHRoaXMuX2xlZnQgPSBsO1xuXHRcdHRoaXMuX3JpZ2h0ID0gcjtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdHN1YmNsYXNzJChPcCxOb2RlKTtcblx0ZXhwb3J0cy5PcCA9IE9wOyAvLyBleHBvcnQgY2xhc3MgXG5cdE9wLnByb3RvdHlwZS5vcCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fb3A7IH1cblx0T3AucHJvdG90eXBlLnNldE9wID0gZnVuY3Rpb24odil7IHRoaXMuX29wID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdE9wLnByb3RvdHlwZS5sZWZ0ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9sZWZ0OyB9XG5cdE9wLnByb3RvdHlwZS5zZXRMZWZ0ID0gZnVuY3Rpb24odil7IHRoaXMuX2xlZnQgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0T3AucHJvdG90eXBlLnJpZ2h0ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9yaWdodDsgfVxuXHRPcC5wcm90b3R5cGUuc2V0UmlnaHQgPSBmdW5jdGlvbih2KXsgdGhpcy5fcmlnaHQgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdE9wLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmICh0aGlzLl9yaWdodCkgeyB0aGlzLl9yaWdodC50cmF2ZXJzZSgpIH07XG5cdFx0aWYgKHRoaXMuX2xlZnQpIHsgdGhpcy5fbGVmdC50cmF2ZXJzZSgpIH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRPcC5wcm90b3R5cGUuaXNFeHByZXNzYWJsZSA9IGZ1bmN0aW9uICgpe1xuXHRcdC8vIHdoYXQgaWYgcmlnaHQgaXMgYSBzdHJpbmc/IT9cblx0XHRyZXR1cm4gISh0aGlzLnJpZ2h0KCkpIHx8IHRoaXMucmlnaHQoKS5pc0V4cHJlc3NhYmxlKCk7XG5cdH07XG5cdFxuXHRPcC5wcm90b3R5cGUuanMgPSBmdW5jdGlvbiAobyl7XG5cdFx0dmFyIG91dCA9IG51bGw7XG5cdFx0dmFyIG9wID0gdGhpcy5fb3A7XG5cdFx0XG5cdFx0dmFyIGwgPSB0aGlzLl9sZWZ0O1xuXHRcdHZhciByID0gdGhpcy5fcmlnaHQ7XG5cdFx0XG5cdFx0aWYgKGwgaW5zdGFuY2VvZiBOb2RlKSB7IGwgPSBsLmMoKSB9O1xuXHRcdGlmIChyIGluc3RhbmNlb2YgTm9kZSkgeyByID0gci5jKCkgfTtcblx0XHRcblx0XHRpZiAobCAmJiByKSB7XG5cdFx0XHRvdXQgPSAoXCJcIiArIGwgKyBcIiBcIiArIG1hcmtfXyh0aGlzLl9vcFRva2VuKSArIG9wICsgXCIgXCIgKyByKTtcblx0XHR9IGVsc2UgaWYgKGwpIHtcblx0XHRcdG91dCA9IChcIlwiICsgbWFya19fKHRoaXMuX29wVG9rZW4pICsgb3AgKyBsKTtcblx0XHR9O1xuXHRcdC8vIG91dCA9IG91dC5wYXJlbnRoZXNpemUgaWYgdXAgaXNhIE9wICMgcmVhbGx5P1xuXHRcdHJldHVybiBvdXQ7XG5cdH07XG5cdFxuXHRPcC5wcm90b3R5cGUuc2hvdWxkUGFyZW50aGVzaXplID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmVucztcblx0XHQvLyBvcHRpb24oOnBhcmVucylcblx0fTtcblx0XG5cdE9wLnByb3RvdHlwZS5wcmVjZWRlbmNlID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIDEwO1xuXHR9O1xuXHRcblx0T3AucHJvdG90eXBlLmNvbnN1bWUgPSBmdW5jdGlvbiAobm9kZSl7XG5cdFx0Ly8gcCAnYXNzaWduaWZ5IGlmPyEnXG5cdFx0Ly8gaWYgaXQgaXMgcG9zc2libGUsIGNvbnZlcnQgaW50byBleHByZXNzaW9uXG5cdFx0aWYgKG5vZGUgaW5zdGFuY2VvZiBUYWdUcmVlKSB7XG5cdFx0XHRpZiAodGhpcy5fbGVmdCkgeyB0aGlzLl9sZWZ0LmNvbnN1bWUobm9kZSkgfTtcblx0XHRcdGlmICh0aGlzLl9yaWdodCkgeyB0aGlzLl9yaWdodC5jb25zdW1lKG5vZGUpIH07XG5cdFx0XHQvLyBAYm9keSA9IEBib2R5LmNvbnN1bWUobm9kZSlcblx0XHRcdC8vIEBhbHQgPSBAYWx0LmNvbnN1bWUobm9kZSkgaWYgQGFsdFxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHQvLyBwIFwiT3AuY29uc3VtZSB7bm9kZX1cIi5jeWFuXG5cdFx0aWYgKHRoaXMuaXNFeHByZXNzYWJsZSgpKSB7IHJldHVybiBPcC5fX3N1cGVyX18uY29uc3VtZS5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XHRcblx0XHQvLyBUT0RPIGNhbiByYXRoZXIgdXNlIGdsb2JhbCBjYWNoaW5nP1xuXHRcdHZhciB0bXB2YXIgPSB0aGlzLnNjb3BlX18oKS5kZWNsYXJlKCd0bXAnLG51bGwse3N5c3RlbTogdHJ1ZX0pO1xuXHRcdHZhciBjbG9uZSA9IE9QKHRoaXMub3AoKSx0aGlzLmxlZnQoKSxudWxsKTtcblx0XHR2YXIgYXN0ID0gdGhpcy5yaWdodCgpLmNvbnN1bWUoY2xvbmUpO1xuXHRcdGlmIChub2RlKSB7IGFzdC5jb25zdW1lKG5vZGUpIH07XG5cdFx0cmV0dXJuIGFzdDtcblx0fTtcblx0XG5cdGZ1bmN0aW9uIENvbXBhcmlzb25PcCgpeyByZXR1cm4gT3AuYXBwbHkodGhpcyxhcmd1bWVudHMpIH07XG5cdFxuXHRzdWJjbGFzcyQoQ29tcGFyaXNvbk9wLE9wKTtcblx0ZXhwb3J0cy5Db21wYXJpc29uT3AgPSBDb21wYXJpc29uT3A7IC8vIGV4cG9ydCBjbGFzcyBcblx0Q29tcGFyaXNvbk9wLnByb3RvdHlwZS5pbnZlcnQgPSBmdW5jdGlvbiAoKXtcblx0XHQvLyBhcmUgdGhlcmUgb3RoZXIgY29tcGFyaXNvbiBvcHM/XG5cdFx0Ly8gd2hhdCBhYm91dCBhIGNoYWluP1xuXHRcdHZhciBvcCA9IHRoaXMuX29wO1xuXHRcdHZhciBwYWlycyA9IFtcIj09XCIsXCIhPVwiLFwiPT09XCIsXCIhPT1cIixcIj5cIixcIjw9XCIsXCI8XCIsXCI+PVwiXTtcblx0XHR2YXIgaWR4ID0gcGFpcnMuaW5kZXhPZihvcCk7XG5cdFx0aWR4ICs9IChpZHggJSAyID8gKC0xKSA6ICgxKSk7XG5cdFx0XG5cdFx0Ly8gcCBcImludmVydCB7QG9wfVwiXG5cdFx0Ly8gcCBcImludmVydGVkIGNvbXBhcmlzb24oISkge2lkeH0ge29wfSAtPiB7cGFpcnNbaWR4XX1cIlxuXHRcdHRoaXMuc2V0T3AocGFpcnNbaWR4XSk7XG5cdFx0dGhpcy5faW52ZXJ0ID0gIXRoaXMuX2ludmVydDtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdENvbXBhcmlzb25PcC5wcm90b3R5cGUuYyA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmICh0aGlzLmxlZnQoKSBpbnN0YW5jZW9mIENvbXBhcmlzb25PcCkge1xuXHRcdFx0dGhpcy5sZWZ0KCkucmlnaHQoKS5jYWNoZSgpO1xuXHRcdFx0cmV0dXJuIE9QKCcmJicsdGhpcy5sZWZ0KCksT1AodGhpcy5vcCgpLHRoaXMubGVmdCgpLnJpZ2h0KCksdGhpcy5yaWdodCgpKSkuYygpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gQ29tcGFyaXNvbk9wLl9fc3VwZXJfXy5jLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtcblx0XHR9O1xuXHR9O1xuXHRcblx0Q29tcGFyaXNvbk9wLnByb3RvdHlwZS5qcyA9IGZ1bmN0aW9uIChvKXtcblx0XHR2YXIgb3AgPSB0aGlzLl9vcDtcblx0XHR2YXIgbCA9IHRoaXMuX2xlZnQ7XG5cdFx0dmFyIHIgPSB0aGlzLl9yaWdodDtcblx0XHRcblx0XHRpZiAobCBpbnN0YW5jZW9mIE5vZGUpIHsgbCA9IGwuYygpIH07XG5cdFx0aWYgKHIgaW5zdGFuY2VvZiBOb2RlKSB7IHIgPSByLmMoKSB9O1xuXHRcdHJldHVybiAoXCJcIiArIGwgKyBcIiBcIiArIG1hcmtfXyh0aGlzLl9vcFRva2VuKSArIG9wICsgXCIgXCIgKyByKTtcblx0fTtcblx0XG5cdFxuXHRmdW5jdGlvbiBNYXRoT3AoKXsgcmV0dXJuIE9wLmFwcGx5KHRoaXMsYXJndW1lbnRzKSB9O1xuXHRcblx0c3ViY2xhc3MkKE1hdGhPcCxPcCk7XG5cdGV4cG9ydHMuTWF0aE9wID0gTWF0aE9wOyAvLyBleHBvcnQgY2xhc3MgXG5cdE1hdGhPcC5wcm90b3R5cGUuYyA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmICh0aGlzLm9wKCkgPT0gJ+KIqicpIHtcblx0XHRcdHJldHVybiB0aGlzLnV0aWwoKS51bmlvbih0aGlzLmxlZnQoKSx0aGlzLnJpZ2h0KCkpLmMoKTtcblx0XHR9IGVsc2UgaWYgKHRoaXMub3AoKSA9PSAn4oipJykge1xuXHRcdFx0cmV0dXJuIHRoaXMudXRpbCgpLmludGVyc2VjdCh0aGlzLmxlZnQoKSx0aGlzLnJpZ2h0KCkpLmMoKTtcblx0XHR9O1xuXHR9O1xuXHRcblx0XG5cdGZ1bmN0aW9uIFVuYXJ5T3AoKXsgcmV0dXJuIE9wLmFwcGx5KHRoaXMsYXJndW1lbnRzKSB9O1xuXHRcblx0c3ViY2xhc3MkKFVuYXJ5T3AsT3ApO1xuXHRleHBvcnRzLlVuYXJ5T3AgPSBVbmFyeU9wOyAvLyBleHBvcnQgY2xhc3MgXG5cdFVuYXJ5T3AucHJvdG90eXBlLmludmVydCA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmICh0aGlzLm9wKCkgPT0gJyEnKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5sZWZ0KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBVbmFyeU9wLl9fc3VwZXJfXy5pbnZlcnQuYXBwbHkodGhpcyxhcmd1bWVudHMpOyAvLyByZWd1bGFyIGludmVydFxuXHRcdH07XG5cdH07XG5cdFxuXHRVbmFyeU9wLnByb3RvdHlwZS5qcyA9IGZ1bmN0aW9uIChvKXtcblx0XHR2YXIgbCA9IHRoaXMuX2xlZnQ7XG5cdFx0dmFyIHIgPSB0aGlzLl9yaWdodDtcblx0XHQvLyBhbGwgb2YgdGhpcyBjb3VsZCByZWFsbHkgYmUgZG9uZSBpIGEgbXVjaFxuXHRcdC8vIGNsZWFuZXIgd2F5LlxuXHRcdC8vIGwuc2V0KHBhcmVuczogeWVzKSBpZiBsICMgYXJlIHdlIHJlYWxseSBzdXJlIGFib3V0IHRoaXM/XG5cdFx0Ly8gci5zZXQocGFyZW5zOiB5ZXMpIGlmIHJcblx0XHRcblx0XHRpZiAodGhpcy5vcCgpID09ICchJykge1xuXHRcdFx0Ly8gbC5AcGFyZW5zID0geWVzXG5cdFx0XHR2YXIgc3RyID0gbC5jKCk7XG5cdFx0XHR2YXIgcGFyZW4gPSBsLnNob3VsZFBhcmVudGhlc2l6ZSh0aGlzKTtcblx0XHRcdC8vIHAgXCJjaGVjayBmb3IgcGFyZW5zIGluICE6IHtzdHJ9IHtsfSB7bC5AcGFyZW5zfSB7bC5zaG91bGRQYXJlbnRoZXNpemUoc2VsZil9XCJcblx0XHRcdC8vIEZJWE1FIHRoaXMgaXMgYSB2ZXJ5IGhhY2t5IHdvcmthcm91bmQuIE5lZWQgdG8gaGFuZGxlIGFsbCB0aGlzXG5cdFx0XHQvLyBpbiB0aGUgY2hpbGQgaW5zdGVhZCwgcHJvYmxlbXMgYXJpc2UgZHVlIHRvIGF1dG9tYXRpYyBjYWNoaW5nXG5cdFx0XHRpZiAoIShzdHIubWF0Y2goL15cXCE/KFtcXHdcXC5dKykkLykgfHwgKGwgaW5zdGFuY2VvZiBQYXJlbnMpIHx8IHBhcmVuIHx8IChsIGluc3RhbmNlb2YgQWNjZXNzKSB8fCAobCBpbnN0YW5jZW9mIENhbGwpKSkgeyBzdHIgPSAnKCcgKyBzdHIgKyAnKScgfTtcblx0XHRcdC8vIGwuc2V0KHBhcmVuczogeWVzKSAjIHN1cmU/XG5cdFx0XHRyZXR1cm4gKFwiXCIgKyB0aGlzLm9wKCkgKyBzdHIpO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5vcCgpID09ICfiiJonKSB7XG5cdFx0XHRyZXR1cm4gKFwiTWF0aC5zcXJ0KFwiICsgKGwuYygpKSArIFwiKVwiKTtcblx0XHR9IGVsc2UgaWYgKHRoaXMubGVmdCgpKSB7XG5cdFx0XHRyZXR1cm4gKFwiXCIgKyAobC5jKCkpICsgdGhpcy5vcCgpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIChcIlwiICsgdGhpcy5vcCgpICsgKHIuYygpKSk7XG5cdFx0fTtcblx0fTtcblx0XG5cdFVuYXJ5T3AucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmICh0aGlzLm9wKCkgPT0gJyEnIHx8IHRoaXMub3AoKSA9PSAn4oiaJykgeyByZXR1cm4gdGhpcyB9O1xuXHRcdHZhciBub2RlID0gKHRoaXMubGVmdCgpIHx8IHRoaXMucmlnaHQoKSkubm9kZSgpO1xuXHRcdC8vIGZvciBwcm9wZXJ0eS1hY2Nlc3NvcnMgd2UgbmVlZCB0byByZXdyaXRlIHRoZSBhc3Rcblx0XHRpZiAoISgobm9kZSBpbnN0YW5jZW9mIFByb3BlcnR5QWNjZXNzKSkpIHsgcmV0dXJuIHRoaXMgfTtcblx0XHRcblx0XHQvLyBhc2sgdG8gY2FjaGUgdGhlIHBhdGhcblx0XHRpZiAoKG5vZGUgaW5zdGFuY2VvZiBBY2Nlc3MpICYmIG5vZGUubGVmdCgpKSB7IG5vZGUubGVmdCgpLmNhY2hlKCkgfTtcblx0XHRcblx0XHR2YXIgbnVtID0gbmV3IE51bSgxKTtcblx0XHR2YXIgYXN0ID0gT1AoJz0nLG5vZGUsT1AodGhpcy5vcCgpWzBdLG5vZGUsbnVtKSk7XG5cdFx0aWYgKHRoaXMubGVmdCgpKSB7IGFzdCA9IE9QKHRoaXMub3AoKVswXSA9PSAnLScgPyAoJysnKSA6ICgnLScpLGFzdCxudW0pIH07XG5cdFx0XG5cdFx0cmV0dXJuIGFzdDtcblx0fTtcblx0XG5cdFVuYXJ5T3AucHJvdG90eXBlLmNvbnN1bWUgPSBmdW5jdGlvbiAobm9kZSl7XG5cdFx0dmFyIG5vcm0gPSB0aGlzLm5vcm1hbGl6ZSgpO1xuXHRcdHJldHVybiBub3JtID09IHRoaXMgPyAoVW5hcnlPcC5fX3N1cGVyX18uY29uc3VtZS5hcHBseSh0aGlzLGFyZ3VtZW50cykpIDogKG5vcm0uY29uc3VtZShub2RlKSk7XG5cdH07XG5cdFxuXHRVbmFyeU9wLnByb3RvdHlwZS5jID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIG5vcm0gPSB0aGlzLm5vcm1hbGl6ZSgpO1xuXHRcdHJldHVybiBub3JtID09IHRoaXMgPyAoVW5hcnlPcC5fX3N1cGVyX18uYy5hcHBseSh0aGlzLGFyZ3VtZW50cykpIDogKG5vcm0uYygpKTtcblx0fTtcblx0XG5cdGZ1bmN0aW9uIEluc3RhbmNlT2YoKXsgcmV0dXJuIE9wLmFwcGx5KHRoaXMsYXJndW1lbnRzKSB9O1xuXHRcblx0c3ViY2xhc3MkKEluc3RhbmNlT2YsT3ApO1xuXHRleHBvcnRzLkluc3RhbmNlT2YgPSBJbnN0YW5jZU9mOyAvLyBleHBvcnQgY2xhc3MgXG5cdEluc3RhbmNlT2YucHJvdG90eXBlLmpzID0gZnVuY3Rpb24gKG8pe1xuXHRcdC8vIGZpeCBjaGVja3MgZm9yIFN0cmluZyBhbmQgTnVtYmVyXG5cdFx0Ly8gcCByaWdodC5pbnNwZWN0XG5cdFx0XG5cdFx0aWYgKHRoaXMucmlnaHQoKSBpbnN0YW5jZW9mIENvbnN0KSB7XG5cdFx0XHQvLyBXQVJOIG90aGVyd2lzZSAtIHdoYXQgZG8gd2UgZG8/IGRvZXMgbm90IHdvcmsgd2l0aCBkeW5hbWljXG5cdFx0XHQvLyBjbGFzc2VzIGV0Yz8gU2hvdWxkIHByb2JhYmx5IHNlbmQgdG8gdXRpbGl0eSBmdW5jdGlvbiBpc2EkXG5cdFx0XHR2YXIgbmFtZSA9IGNfXyh0aGlzLnJpZ2h0KCkudmFsdWUoKSk7XG5cdFx0XHR2YXIgb2JqID0gdGhpcy5sZWZ0KCkubm9kZSgpO1xuXHRcdFx0Ly8gVE9ETyBhbHNvIGNoZWNrIGZvciBwcmltaXRpdmUtY29uc3RydWN0b3Jcblx0XHRcdGlmIChpZHgkKG5hbWUsWydTdHJpbmcnLCdOdW1iZXInLCdCb29sZWFuJ10pID49IDApIHtcblx0XHRcdFx0aWYgKCEoKG9iaiBpbnN0YW5jZW9mIExvY2FsVmFyQWNjZXNzKSkpIHtcblx0XHRcdFx0XHRvYmouY2FjaGUoKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0Ly8gbmVlZCBhIGRvdWJsZSBjaGVjayBmb3IgdGhlc2UgKGNhY2hlIGxlZnQpIC0gcG9zc2libHlcblx0XHRcdFx0cmV0dXJuIChcIih0eXBlb2YgXCIgKyAob2JqLmMoKSkgKyBcIj09J1wiICsgKG5hbWUudG9Mb3dlckNhc2UoKSkgKyBcIid8fFwiICsgKG9iai5jKCkpICsgXCIgaW5zdGFuY2VvZiBcIiArIG5hbWUgKyBcIilcIik7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBjb252ZXJ0XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0dmFyIG91dCA9IChcIlwiICsgKHRoaXMubGVmdCgpLmMoKSkgKyBcIiBcIiArIHRoaXMub3AoKSArIFwiIFwiICsgKHRoaXMucmlnaHQoKS5jKCkpKTtcblx0XHRcblx0XHQvLyBzaG91bGQgdGhpcyBub3QgaGFwcGVuIGluICNjP1xuXHRcdGlmIChvLnBhcmVudCgpIGluc3RhbmNlb2YgT3ApIHsgb3V0ID0gaGVscGVycy5wYXJlbnRoZXNpemUob3V0KSB9O1xuXHRcdHJldHVybiBvdXQ7XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBUeXBlT2YoKXsgcmV0dXJuIE9wLmFwcGx5KHRoaXMsYXJndW1lbnRzKSB9O1xuXHRcblx0c3ViY2xhc3MkKFR5cGVPZixPcCk7XG5cdGV4cG9ydHMuVHlwZU9mID0gVHlwZU9mOyAvLyBleHBvcnQgY2xhc3MgXG5cdFR5cGVPZi5wcm90b3R5cGUuanMgPSBmdW5jdGlvbiAobyl7XG5cdFx0cmV0dXJuIChcInR5cGVvZiBcIiArICh0aGlzLmxlZnQoKS5jKCkpKTtcblx0fTtcblx0XG5cdGZ1bmN0aW9uIERlbGV0ZSgpeyByZXR1cm4gT3AuYXBwbHkodGhpcyxhcmd1bWVudHMpIH07XG5cdFxuXHRzdWJjbGFzcyQoRGVsZXRlLE9wKTtcblx0ZXhwb3J0cy5EZWxldGUgPSBEZWxldGU7IC8vIGV4cG9ydCBjbGFzcyBcblx0RGVsZXRlLnByb3RvdHlwZS5qcyA9IGZ1bmN0aW9uIChvKXtcblx0XHQvLyBUT0RPIHRoaXMgd2lsbCBleGVjdXRlIGNhbGxzIHNldmVyYWwgdGltZXMgaWYgdGhlIHBhdGggaXMgbm90IGRpcmVjdGx5IHRvIGFuIG9iamVjdFxuXHRcdC8vIG5lZWQgdG8gY2FjaGUgdGhlIHJlY2VpdmVyXG5cdFx0dmFyIGwgPSB0aGlzLmxlZnQoKTtcblx0XHR2YXIgdG1wID0gdGhpcy5zY29wZV9fKCkudGVtcG9yYXJ5KHRoaXMse3Bvb2w6ICd2YWwnfSk7XG5cdFx0dmFyIG8gPSBPUCgnPScsdG1wLGwpO1xuXHRcdC8vIEZJWE1FXG5cdFx0cmV0dXJuIChcIihcIiArIChvLmMoKSkgKyBcIixkZWxldGUgXCIgKyAobC5jKCkpICsgXCIsIFwiICsgKHRtcC5jKCkpICsgXCIpXCIpOyAvLyBvaCB3ZWxsXG5cdFx0Ly8gdmFyIGFzdCA9IFtPUCgnPScsdG1wLGxlZnQpLFwiZGVsZXRlIHtsZWZ0LmN9XCIsdG1wXVxuXHRcdC8vIHNob3VsZCBwYXJlbnRoZXNpemUgZGlyZWN0bHkgbm8/XG5cdFx0Ly8gYXN0LmNcblx0fTtcblx0XG5cdERlbGV0ZS5wcm90b3R5cGUuc2hvdWxkUGFyZW50aGVzaXplID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBJbigpeyByZXR1cm4gT3AuYXBwbHkodGhpcyxhcmd1bWVudHMpIH07XG5cdFxuXHRzdWJjbGFzcyQoSW4sT3ApO1xuXHRleHBvcnRzLkluID0gSW47IC8vIGV4cG9ydCBjbGFzcyBcblx0SW4ucHJvdG90eXBlLmludmVydCA9IGZ1bmN0aW9uICgpe1xuXHRcdHRoaXMuX2ludmVydCA9ICF0aGlzLl9pbnZlcnQ7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbi5wcm90b3R5cGUuanMgPSBmdW5jdGlvbiAobyl7XG5cdFx0dmFyIGNvbmQgPSB0aGlzLl9pbnZlcnQgPyAoXCI9PSAtMVwiKSA6IChcIj49IDBcIik7XG5cdFx0dmFyIGlkeCA9IFV0aWwuaW5kZXhPZih0aGlzLmxlZnQoKSx0aGlzLnJpZ2h0KCkpO1xuXHRcdHJldHVybiAoXCJcIiArIChpZHguYygpKSArIFwiIFwiICsgY29uZCk7XG5cdH07XG5cdFxuXHRcblx0XG5cdFxuXHRcblx0XG5cdFxuXHQvLyBBQ0NFU1Ncblx0XG5cdG1vZHVsZS5leHBvcnRzLktfSVZBUiA9IEtfSVZBUiA9IDE7XG5cdG1vZHVsZS5leHBvcnRzLktfU1lNID0gS19TWU0gPSAyO1xuXHRtb2R1bGUuZXhwb3J0cy5LX1NUUiA9IEtfU1RSID0gMztcblx0bW9kdWxlLmV4cG9ydHMuS19QUk9QID0gS19QUk9QID0gNDtcblx0XG5cdGZ1bmN0aW9uIEFjY2VzcyhvLGwscil7XG5cdFx0Ly8gc2V0IGV4cHJlc3Npb24geWVzLCBubz9cblx0XHR0aGlzLl9leHByZXNzaW9uID0gZmFsc2U7XG5cdFx0dGhpcy5fdHJhdmVyc2VkID0gZmFsc2U7XG5cdFx0dGhpcy5fcGFyZW5zID0gZmFsc2U7XG5cdFx0dGhpcy5fY2FjaGUgPSBudWxsO1xuXHRcdHRoaXMuX2ludmVydCA9IGZhbHNlO1xuXHRcdHRoaXMuX29wID0gbyAmJiBvLl92YWx1ZSB8fCBvO1xuXHRcdHRoaXMuX2xlZnQgPSBsO1xuXHRcdHRoaXMuX3JpZ2h0ID0gcjtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdHN1YmNsYXNzJChBY2Nlc3MsT3ApO1xuXHRleHBvcnRzLkFjY2VzcyA9IEFjY2VzczsgLy8gZXhwb3J0IGNsYXNzIFxuXHRBY2Nlc3MucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKGxlZnQscmlnaHQpe1xuXHRcdHZhciBjdG9yID0gdGhpcy5jb25zdHJ1Y3Rvcjtcblx0XHRyZXR1cm4gbmV3IGN0b3IodGhpcy5vcCgpLGxlZnQscmlnaHQpO1xuXHR9O1xuXHRcblx0QWNjZXNzLnByb3RvdHlwZS5qcyA9IGZ1bmN0aW9uIChvKXtcblx0XHR2YXIgcjtcblx0XHR2YXIgcmF3ID0gbnVsbDtcblx0XHR2YXIgcmd0ID0gdGhpcy5yaWdodCgpO1xuXHRcdHZhciBjdHggPSAodGhpcy5sZWZ0KCkgfHwgdGhpcy5zY29wZV9fKCkuY29udGV4dCgpKTtcblx0XHR2YXIgcHJlID0gXCJcIjtcblx0XHR2YXIgbWFyayA9ICcnO1xuXHRcdFxuXHRcdC8vIGlmIHNhZmVjaGFpblxuXHRcdC8vXHRwIFwiQWNjZXNzIGlzIHNhZmVjaGFpbmVkIHtyZ3QuY31cIlxuXHRcdFxuXHRcdFxuXHRcdGlmIChyZ3QgaW5zdGFuY2VvZiBOdW0pIHtcblx0XHRcdHJldHVybiBjdHguYygpICsgXCJbXCIgKyByZ3QuYygpICsgXCJdXCI7XG5cdFx0fTtcblx0XHRcblx0XHQvLyBpcyB0aGlzIHJpZ2h0PyBTaG91bGQgbm90IHRoZSBpbmRleCBjb21waWxlIHRoZSBicmFja2V0c1xuXHRcdC8vIG9yIHZhbHVlIGlzIGEgc3ltYm9sIC0tIHNob3VsZCBiZSB0aGUgc2FtZSwgbm8/XG5cdFx0aWYgKChyZ3QgaW5zdGFuY2VvZiBJbmRleCkgJiYgKChyZ3QudmFsdWUoKSBpbnN0YW5jZW9mIFN0cikgfHwgKHJndC52YWx1ZSgpIGluc3RhbmNlb2YgU3ltYm9sKSkpIHtcblx0XHRcdHJndCA9IHJndC52YWx1ZSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gVE9ETyBkbyB0aGUgaWRlbnRpZmllci12YWxpZGF0aW9uIGluIGEgY2VudHJhbCBwbGFjZSBpbnN0ZWFkXG5cdFx0aWYgKChyZ3QgaW5zdGFuY2VvZiBTdHIpICYmIHJndC5pc1ZhbGlkSWRlbnRpZmllcigpKSB7XG5cdFx0XHRyYXcgPSByZ3QucmF3KCk7XG5cdFx0fSBlbHNlIGlmICgocmd0IGluc3RhbmNlb2YgU3ltYm9sKSAmJiByZ3QuaXNWYWxpZElkZW50aWZpZXIoKSkge1xuXHRcdFx0cmF3ID0gcmd0LnJhdygpO1xuXHRcdH0gZWxzZSBpZiAoKHJndCBpbnN0YW5jZW9mIElkZW50aWZpZXIpICYmIHJndC5pc1ZhbGlkSWRlbnRpZmllcigpKSB7XG5cdFx0XHRtYXJrID0gbWFya19fKHJndC5fdmFsdWUpO1xuXHRcdFx0cmF3ID0gcmd0LmMoKTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmICh0aGlzLnNhZmVjaGFpbigpICYmIGN0eCkge1xuXHRcdFx0Y3R4LmNhY2hlKHtmb3JjZTogdHJ1ZX0pO1xuXHRcdFx0cHJlID0gY3R4LmMoKSArIFwiICYmIFwiO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gcmVhbGx5P1xuXHRcdC8vIHZhciBjdHggPSAobGVmdCB8fCBzY29wZV9fLmNvbnRleHQpXG5cdFx0dmFyIG91dCA9IHJhdyA/IChcblx0XHRcdC8vIHNlZSBpZiBpdCBuZWVkcyBxdW90aW5nXG5cdFx0XHQvLyBuZWVkIHRvIGNoZWNrIHRvIHNlZSBpZiBpdCBpcyBsZWdhbFxuXHRcdFx0Y3R4ID8gKChcIlwiICsgKGN0eC5jKCkpICsgXCIuXCIgKyBtYXJrICsgcmF3KSkgOiAocmF3KVxuXHRcdCkgOiAoXG5cdFx0XHRyID0gcmd0IGluc3RhbmNlb2YgTm9kZSA/IChyZ3QuYyh7ZXhwcmVzc2lvbjogdHJ1ZX0pKSA6IChyZ3QpLFxuXHRcdFx0KFwiXCIgKyAoY3R4LmMoKSkgKyBcIltcIiArIHIgKyBcIl1cIilcblx0XHQpO1xuXHRcdFxuXHRcdC8vIGlmIHNhZmVjaGFpbiBhbmQgY3R4XG5cdFx0Ly8gXHRvdXQgPSBcIntjdHguY30gJiYge291dH1cIlxuXHRcdFxuXHRcdHJldHVybiBwcmUgKyBvdXQ7XG5cdH07XG5cdFxuXHRBY2Nlc3MucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKCl7XG5cdFx0aWYgKHRoaXMubGVmdCgpKSB7IHRoaXMubGVmdCgpLnRyYXZlcnNlKCkgfTtcblx0XHRpZiAodGhpcy5yaWdodCgpKSB7IHRoaXMucmlnaHQoKS50cmF2ZXJzZSgpIH07XG5cdFx0cmV0dXJuO1xuXHR9O1xuXHRcblx0QWNjZXNzLnByb3RvdHlwZS5pc0V4cHJlc3NhYmxlID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cdFxuXHRBY2Nlc3MucHJvdG90eXBlLmFsaWFzID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMucmlnaHQoKSBpbnN0YW5jZW9mIElkZW50aWZpZXIgPyAodGhpcy5yaWdodCgpLmFsaWFzKCkpIDogKEFjY2Vzcy5fX3N1cGVyX18uYWxpYXMuY2FsbCh0aGlzKSk7XG5cdH07XG5cdFxuXHRBY2Nlc3MucHJvdG90eXBlLnNhZmVjaGFpbiA9IGZ1bmN0aW9uICgpe1xuXHRcdC8vIHJpZ2h0LnNhZmVjaGFpblxuXHRcdHJldHVybiBTdHJpbmcodGhpcy5fb3ApID09ICc/LicgfHwgU3RyaW5nKHRoaXMuX29wKSA9PSAnPzonO1xuXHR9O1xuXHRcblx0QWNjZXNzLnByb3RvdHlwZS5jYWNoZSA9IGZ1bmN0aW9uIChvKXtcblx0XHRyZXR1cm4gKCh0aGlzLnJpZ2h0KCkgaW5zdGFuY2VvZiBJdmFyKSAmJiAhKHRoaXMubGVmdCgpKSkgPyAodGhpcykgOiAoQWNjZXNzLl9fc3VwZXJfXy5jYWNoZS5jYWxsKHRoaXMsbykpO1xuXHR9O1xuXHRcblx0XG5cdFxuXHQvLyBTaG91bGQgY2hhbmdlIHRoaXMgdG8ganVzdCByZWZlciBkaXJlY3RseSB0byB0aGUgdmFyaWFibGU/IE9yIFZhclJlZmVyZW5jZVxuXHRmdW5jdGlvbiBMb2NhbFZhckFjY2VzcygpeyByZXR1cm4gQWNjZXNzLmFwcGx5KHRoaXMsYXJndW1lbnRzKSB9O1xuXHRcblx0c3ViY2xhc3MkKExvY2FsVmFyQWNjZXNzLEFjY2Vzcyk7XG5cdGV4cG9ydHMuTG9jYWxWYXJBY2Nlc3MgPSBMb2NhbFZhckFjY2VzczsgLy8gZXhwb3J0IGNsYXNzIFxuXHRMb2NhbFZhckFjY2Vzcy5wcm90b3R5cGUuc2FmZWNoYWluID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9zYWZlY2hhaW47IH1cblx0TG9jYWxWYXJBY2Nlc3MucHJvdG90eXBlLnNldFNhZmVjaGFpbiA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9zYWZlY2hhaW4gPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdExvY2FsVmFyQWNjZXNzLnByb3RvdHlwZS5qcyA9IGZ1bmN0aW9uIChvKXtcblx0XHRpZiAoKHRoaXMucmlnaHQoKSBpbnN0YW5jZW9mIFZhcmlhYmxlKSAmJiB0aGlzLnJpZ2h0KCkudHlwZSgpID09ICdtZXRoJykge1xuXHRcdFx0aWYgKCEoKHRoaXMudXAoKSBpbnN0YW5jZW9mIENhbGwpKSkgeyByZXR1cm4gKFwiXCIgKyAodGhpcy5yaWdodCgpLmMoKSkgKyBcIigpXCIpIH07XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gdGhpcy5yaWdodCgpLmMoKTtcblx0fTtcblx0XG5cdExvY2FsVmFyQWNjZXNzLnByb3RvdHlwZS52YXJpYWJsZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLnJpZ2h0KCk7XG5cdH07XG5cdFxuXHRMb2NhbFZhckFjY2Vzcy5wcm90b3R5cGUuY2FjaGUgPSBmdW5jdGlvbiAobyl7XG5cdFx0aWYobyA9PT0gdW5kZWZpbmVkKSBvID0ge307XG5cdFx0aWYgKG8uZm9yY2UpIHsgTG9jYWxWYXJBY2Nlc3MuX19zdXBlcl9fLmNhY2hlLmNhbGwodGhpcyxvKSB9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0TG9jYWxWYXJBY2Nlc3MucHJvdG90eXBlLmFsaWFzID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMudmFyaWFibGUoKS5fYWxpYXMgfHwgTG9jYWxWYXJBY2Nlc3MuX19zdXBlcl9fLmFsaWFzLmNhbGwodGhpcyk7XG5cdH07XG5cdFxuXHRcblx0ZnVuY3Rpb24gR2xvYmFsVmFyQWNjZXNzKCl7IHJldHVybiBWYWx1ZU5vZGUuYXBwbHkodGhpcyxhcmd1bWVudHMpIH07XG5cdFxuXHRzdWJjbGFzcyQoR2xvYmFsVmFyQWNjZXNzLFZhbHVlTm9kZSk7XG5cdGV4cG9ydHMuR2xvYmFsVmFyQWNjZXNzID0gR2xvYmFsVmFyQWNjZXNzOyAvLyBleHBvcnQgY2xhc3MgXG5cdEdsb2JhbFZhckFjY2Vzcy5wcm90b3R5cGUuanMgPSBmdW5jdGlvbiAobyl7XG5cdFx0cmV0dXJuIHRoaXMudmFsdWUoKS5jKCk7XG5cdH07XG5cdFxuXHRcblx0ZnVuY3Rpb24gT2JqZWN0QWNjZXNzKCl7IHJldHVybiBBY2Nlc3MuYXBwbHkodGhpcyxhcmd1bWVudHMpIH07XG5cdFxuXHRzdWJjbGFzcyQoT2JqZWN0QWNjZXNzLEFjY2Vzcyk7XG5cdGV4cG9ydHMuT2JqZWN0QWNjZXNzID0gT2JqZWN0QWNjZXNzOyAvLyBleHBvcnQgY2xhc3MgXG5cdFxuXHRcblx0XG5cdGZ1bmN0aW9uIFByb3BlcnR5QWNjZXNzKG8sbCxyKXtcblx0XHR0aGlzLl90cmF2ZXJzZWQgPSBmYWxzZTtcblx0XHR0aGlzLl9pbnZlcnQgPSBmYWxzZTtcblx0XHR0aGlzLl9wYXJlbnMgPSBmYWxzZTtcblx0XHR0aGlzLl9leHByZXNzaW9uID0gZmFsc2U7IC8vIHllcz9cblx0XHR0aGlzLl9jYWNoZSA9IG51bGw7XG5cdFx0dGhpcy5fb3AgPSBvO1xuXHRcdHRoaXMuX2xlZnQgPSBsO1xuXHRcdHRoaXMuX3JpZ2h0ID0gcjtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdHN1YmNsYXNzJChQcm9wZXJ0eUFjY2VzcyxBY2Nlc3MpO1xuXHRleHBvcnRzLlByb3BlcnR5QWNjZXNzID0gUHJvcGVydHlBY2Nlc3M7IC8vIGV4cG9ydCBjbGFzcyBcblx0UHJvcGVydHlBY2Nlc3MucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKCl7XG5cdFx0aWYgKHRoaXMuX3JpZ2h0KSB7IHRoaXMuX3JpZ2h0LnRyYXZlcnNlKCkgfTtcblx0XHRpZiAodGhpcy5fbGVmdCkgeyB0aGlzLl9sZWZ0LnRyYXZlcnNlKCkgfTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8vIHJpZ2h0IGluIGMgd2Ugc2hvdWxkIHBvc3NpYmx5IG92ZXJyaWRlXG5cdC8vIHRvIGNyZWF0ZSBhIGNhbGwgYW5kIHJlZ3VsYXIgYWNjZXNzIGluc3RlYWRcblx0XG5cdFByb3BlcnR5QWNjZXNzLnByb3RvdHlwZS5qcyA9IGZ1bmN0aW9uIChvKXtcblx0XHRcblx0XHR2YXIgcmVjO1xuXHRcdGlmIChyZWMgPSB0aGlzLnJlY2VpdmVyKCkpIHtcblx0XHRcdC8vIHAgXCJjb252ZXJ0aW5nIHRvIGNhbGxcIlxuXHRcdFx0dmFyIGFzdCA9IENBTEwoT1AoJy4nLHRoaXMubGVmdCgpLHRoaXMucmlnaHQoKSksW10pOyAvLyBjb252ZXJ0IHRvIEFyZ0xpc3Qgb3IgbnVsbFxuXHRcdFx0YXN0LnNldFJlY2VpdmVyKHJlYyk7XG5cdFx0XHRyZXR1cm4gYXN0LmMoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHZhciB1cCA9IHRoaXMudXAoKTtcblx0XHRcblx0XHRpZiAoISgodXAgaW5zdGFuY2VvZiBDYWxsKSkpIHtcblx0XHRcdC8vIHAgXCJjb252ZXJ0IHRvIGNhbGwgaW5zdGVhZFwiXG5cdFx0XHRhc3QgPSBDQUxMKG5ldyBBY2Nlc3ModGhpcy5vcCgpLHRoaXMubGVmdCgpLHRoaXMucmlnaHQoKSksW10pO1xuXHRcdFx0cmV0dXJuIGFzdC5jKCk7XG5cdFx0fTtcblx0XHRcblx0XHQvLyByZWFsbHkgbmVlZCB0byBmaXggdGhpcyAtIGZvciBzdXJlXG5cdFx0Ly8gc2hvdWxkIGJlIHBvc3NpYmxlIGZvciB0aGUgZnVuY3Rpb24gdG8gcmVtb3ZlIHRoaXMgdGhpcyBpbnN0ZWFkP1xuXHRcdHZhciBqcyA9IChcIlwiICsgUHJvcGVydHlBY2Nlc3MuX19zdXBlcl9fLmpzLmNhbGwodGhpcyxvKSk7XG5cdFx0XG5cdFx0aWYgKCEoKHVwIGluc3RhbmNlb2YgQ2FsbCkgfHwgKHVwIGluc3RhbmNlb2YgVXRpbC5Jc0Z1bmN0aW9uKSkpIHtcblx0XHRcdC8vIHAgXCJDYWxsZWRcIlxuXHRcdFx0anMgKz0gXCIoKVwiO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIGpzO1xuXHR9O1xuXHRcblx0XG5cdFByb3BlcnR5QWNjZXNzLnByb3RvdHlwZS5yZWNlaXZlciA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmICgodGhpcy5sZWZ0KCkgaW5zdGFuY2VvZiBTdXBlckFjY2VzcykgfHwgKHRoaXMubGVmdCgpIGluc3RhbmNlb2YgU3VwZXIpKSB7XG5cdFx0XHRyZXR1cm4gU0VMRjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblx0fTtcblx0XG5cdFxuXHRmdW5jdGlvbiBJdmFyQWNjZXNzKCl7IHJldHVybiBBY2Nlc3MuYXBwbHkodGhpcyxhcmd1bWVudHMpIH07XG5cdFxuXHRzdWJjbGFzcyQoSXZhckFjY2VzcyxBY2Nlc3MpO1xuXHRleHBvcnRzLkl2YXJBY2Nlc3MgPSBJdmFyQWNjZXNzOyAvLyBleHBvcnQgY2xhc3MgXG5cdEl2YXJBY2Nlc3MucHJvdG90eXBlLmNhY2hlID0gZnVuY3Rpb24gKCl7XG5cdFx0Ly8gV0FSTiBobW0sIHRoaXMgaXMgbm90IHJpZ2h0Li4uIHdoZW4gYWNjZXNzaW5nIG9uIGFub3RoZXIgb2JqZWN0IGl0IHdpbGwgbmVlZCB0byBiZSBjYWNoZWRcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFxuXHRmdW5jdGlvbiBDb25zdEFjY2VzcygpeyByZXR1cm4gQWNjZXNzLmFwcGx5KHRoaXMsYXJndW1lbnRzKSB9O1xuXHRcblx0c3ViY2xhc3MkKENvbnN0QWNjZXNzLEFjY2Vzcyk7XG5cdGV4cG9ydHMuQ29uc3RBY2Nlc3MgPSBDb25zdEFjY2VzczsgLy8gZXhwb3J0IGNsYXNzIFxuXHRcblx0XG5cdFxuXHRmdW5jdGlvbiBJbmRleEFjY2VzcygpeyByZXR1cm4gQWNjZXNzLmFwcGx5KHRoaXMsYXJndW1lbnRzKSB9O1xuXHRcblx0c3ViY2xhc3MkKEluZGV4QWNjZXNzLEFjY2Vzcyk7XG5cdGV4cG9ydHMuSW5kZXhBY2Nlc3MgPSBJbmRleEFjY2VzczsgLy8gZXhwb3J0IGNsYXNzIFxuXHRJbmRleEFjY2Vzcy5wcm90b3R5cGUuY2FjaGUgPSBmdW5jdGlvbiAobyl7XG5cdFx0aWYobyA9PT0gdW5kZWZpbmVkKSBvID0ge307XG5cdFx0aWYgKG8uZm9yY2UpIHsgcmV0dXJuIEluZGV4QWNjZXNzLl9fc3VwZXJfXy5jYWNoZS5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XHR0aGlzLnJpZ2h0KCkuY2FjaGUoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFxuXHRmdW5jdGlvbiBTdXBlckFjY2VzcygpeyByZXR1cm4gQWNjZXNzLmFwcGx5KHRoaXMsYXJndW1lbnRzKSB9O1xuXHRcblx0c3ViY2xhc3MkKFN1cGVyQWNjZXNzLEFjY2Vzcyk7XG5cdGV4cG9ydHMuU3VwZXJBY2Nlc3MgPSBTdXBlckFjY2VzczsgLy8gZXhwb3J0IGNsYXNzIFxuXHRTdXBlckFjY2Vzcy5wcm90b3R5cGUuanMgPSBmdW5jdGlvbiAobyl7XG5cdFx0dmFyIG0gPSBvLm1ldGhvZCgpO1xuXHRcdHZhciB1cCA9IG8ucGFyZW50KCk7XG5cdFx0dmFyIGRlZXAgPSAoby5wYXJlbnQoKSBpbnN0YW5jZW9mIEFjY2Vzcyk7XG5cdFx0XG5cdFx0dmFyIG91dCA9IChcIlwiICsgKHRoaXMubGVmdCgpLmMoKSkgKyBcIi5fX3N1cGVyX19cIik7XG5cdFx0XG5cdFx0aWYgKCEoKHVwIGluc3RhbmNlb2YgQWNjZXNzKSkpIHtcblx0XHRcdG91dCArPSAoXCIuXCIgKyAobS5zdXBlcm5hbWUoKS5jKCkpKTtcblx0XHRcdGlmICghKCh1cCBpbnN0YW5jZW9mIENhbGwpKSkgeyAvLyBhdXRvY2FsbD9cblx0XHRcdFx0b3V0ICs9IChcIi5hcHBseShcIiArIChtLnNjb3BlKCkuY29udGV4dCgpLmMoKSkgKyBcIixhcmd1bWVudHMpXCIpO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiBvdXQ7XG5cdH07XG5cdFxuXHRTdXBlckFjY2Vzcy5wcm90b3R5cGUucmVjZWl2ZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gU0VMRjtcblx0fTtcblx0XG5cdFxuXHRmdW5jdGlvbiBWYXJPckFjY2Vzcyh2YWx1ZSl7XG5cdFx0Ly8gc2hvdWxkIHJhdGhlciBjYWxsIHVwIHRvIHZhbHVlbm9kZT9cblx0XHR0aGlzLl90cmF2ZXJzZWQgPSBmYWxzZTtcblx0XHR0aGlzLl9wYXJlbnMgPSBmYWxzZTtcblx0XHR0aGlzLl92YWx1ZSA9IHZhbHVlO1xuXHRcdHRoaXMuX2lkZW50aWZpZXIgPSB2YWx1ZTtcblx0XHR0aGlzLl90b2tlbiA9IHZhbHVlLl92YWx1ZTtcblx0XHR0aGlzLl92YXJpYWJsZSA9IG51bGw7XG5cdFx0dGhpcztcblx0fTtcblx0XG5cdC8vIFNob3J0Y2lyY3VpdCB0cmF2ZXJzZSBzbyB0aGF0IGl0IGlzIG5vdCBhZGRlZCB0byB0aGUgc3RhY2s/IVxuXHRzdWJjbGFzcyQoVmFyT3JBY2Nlc3MsVmFsdWVOb2RlKTtcblx0ZXhwb3J0cy5WYXJPckFjY2VzcyA9IFZhck9yQWNjZXNzOyAvLyBleHBvcnQgY2xhc3MgXG5cdFZhck9yQWNjZXNzLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICgpe1xuXHRcdC8vIEBpZGVudGlmaWVyID0gdmFsdWUgIyB0aGlzIGlzIG5vdCBhIHJlYWwgaWRlbnRpZmllcj9cblx0XHQvLyBjb25zb2xlLmxvZyBcIlZhck9yQWNjZXNzIHtAaWRlbnRpZmllcn1cIlxuXHRcdC8vIHAgXCJ2aXNpdCB7c2VsZn1cIlxuXHRcdFxuXHRcdFxuXHRcdHZhciBzY29wZSA9IHRoaXMuc2NvcGVfXygpO1xuXHRcdFxuXHRcdHZhciB2YXJpYWJsZSA9IHNjb3BlLmxvb2t1cCh0aGlzLnZhbHVlKCkpO1xuXHRcdFxuXHRcdC8vIGRvZXMgbm90IHJlYWxseSBuZWVkIHRvIGhhdmUgYSBkZWNsYXJhdG9yIGFscmVhZHk/IC0tIHRyaWNreVxuXHRcdGlmICh2YXJpYWJsZSAmJiB2YXJpYWJsZS5kZWNsYXJhdG9yKCkpIHtcblx0XHRcdC8vIHZhciBkZWNsID0gdmFyaWFibGUuZGVjbGFyYXRvclxuXHRcdFx0XG5cdFx0XHQvLyBpZiB0aGUgdmFyaWFibGUgaXMgbm90IGluaXRpYWxpemVkIGp1c3QgeWV0IGFuZCB3ZSBhcmVcblx0XHRcdC8vIGluIHRoZSBzYW1lIHNjb3BlIC0gd2Ugc2hvdWxkIG5vdCB0cmVhdCB0aGlzIGFzIGEgdmFyLWxvb2t1cFxuXHRcdFx0Ly8gaWUuICB2YXIgeCA9IHggd291bGQgcmVzb2x2ZSB0byB2YXIgeCA9IHRoaXMueCgpIGlmIHhcblx0XHRcdC8vIHdhcyBub3QgcHJldmlvdXNseSBkZWZpbmVkXG5cdFx0XHRcblx0XHRcdC8vIHNob3VsZCBkbyB0aGlzIGV2ZW4gaWYgd2UgYXJlIG5vdCBpbiB0aGUgc2FtZSBzY29wZT9cblx0XHRcdC8vIHdlIG9ubHkgbmVlZCB0byBiZSBpbiB0aGUgc2FtZSBjbG9zdXJlKCEpXG5cdFx0XHRcblx0XHRcdGlmICh2YXJpYWJsZS5faW5pdGlhbGl6ZWQgfHwgKHNjb3BlLmNsb3N1cmUoKSAhPSB2YXJpYWJsZS5zY29wZSgpLmNsb3N1cmUoKSkpIHtcblx0XHRcdFx0dGhpcy5fdmFyaWFibGUgPSB2YXJpYWJsZTtcblx0XHRcdFx0dmFyaWFibGUuYWRkUmVmZXJlbmNlKHRoaXMpO1xuXHRcdFx0XHR0aGlzLl92YWx1ZSA9IHZhcmlhYmxlOyAvLyB2YXJpYWJsZS5hY2Nlc3NvcihzZWxmKVxuXHRcdFx0XHR0aGlzLl90b2tlbi5fdmFyaWFibGUgPSB2YXJpYWJsZTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHQvLyBwIFwidmFyIGlzIG5vdCB5ZXQgaW5pdGlhbGl6ZWQhXCJcblx0XHRcdC8vIHAgXCJkZWNsYXJhdG9yIGZvciB2YXIge2RlY2wuQGRlY2xhcmVkfVwiXG5cdFx0XHQvLyBGSVhcblx0XHRcdC8vIEB2YWx1ZS5zYWZlY2hhaW4gPSBzYWZlY2hhaW5cblx0XHR9O1xuXHRcdFxuXHRcdC8vIFRPRE8gZGVwcmVjYXRlIGFuZCByZW1vdmVcblx0XHRpZiAodGhpcy52YWx1ZSgpLnN5bWJvbCgpLmluZGV4T2YoJyQnKSA+PSAwKSB7XG5cdFx0XHQvLyBiaWcgaGFjayAtIHNob3VsZCBkaXNhYmxlXG5cdFx0XHQvLyBtYWpvciBoYWNrIGhlcmUsIG5vP1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgXCJHbG9iYWxWYXJBY2Nlc3NcIlxuXHRcdFx0dGhpcy5fdmFsdWUgPSBuZXcgR2xvYmFsVmFyQWNjZXNzKHRoaXMudmFsdWUoKSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdC8vIHJlYWxseT8gd2hhdCBhYm91dCBqdXN0IG1pbWlja2luZyB0aGUgdHdvIGRpZmZyZW50IGluc3RlYWQ/XG5cdFx0Ly8gU2hvdWxkIHdlIG5vdCByZXR1cm4gYSBjYWxsIGRpcmVjdGx5IGluc3RlYWQ/XG5cdFx0dGhpcy5fdmFsdWUgPSBuZXcgUHJvcGVydHlBY2Nlc3MoXCIuXCIsc2NvcGUuY29udGV4dCgpLHRoaXMudmFsdWUoKSk7XG5cdFx0Ly8gbWFyayB0aGUgc2NvcGUgLyBjb250ZXh0IC0tIHNvIHdlIGNhbiBzaG93IGNvcnJlY3QgaW1wbGljaXRcblx0XHR0aGlzLl90b2tlbi5fbWV0YSA9IHt0eXBlOiAnQUNDRVNTJ307XG5cdFx0Ly8gQHZhbHVlLnRyYXZlcnNlICMgbmFoXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRWYXJPckFjY2Vzcy5wcm90b3R5cGUuYyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiBtYXJrX18odGhpcy5fdG9rZW4pICsgKHRoaXMuX3ZhcmlhYmxlID8gKFZhck9yQWNjZXNzLl9fc3VwZXJfXy5jLmNhbGwodGhpcykpIDogKHRoaXMudmFsdWUoKS5jKCkpKTtcblx0fTtcblx0XG5cdFZhck9yQWNjZXNzLnByb3RvdHlwZS5qcyA9IGZ1bmN0aW9uIChvKXtcblx0XHRcblx0XHR2YXIgdjtcblx0XHRpZiAodiA9IHRoaXMuX3ZhcmlhYmxlKSB7XG5cdFx0XHR2YXIgb3V0ID0gdi5jKCk7XG5cdFx0XHRpZiAodi5fdHlwZSA9PSAnbWV0aCcgJiYgIShvLnVwKCkgaW5zdGFuY2VvZiBDYWxsKSkgeyBvdXQgKz0gXCIoKVwiIH07XG5cdFx0XHRyZXR1cm4gb3V0O1xuXHRcdH07XG5cdFx0cmV0dXJuIFwiTk9OT1wiO1xuXHR9O1xuXHRcblx0VmFyT3JBY2Nlc3MucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fdmFyaWFibGUgPyAodGhpcykgOiAodGhpcy52YWx1ZSgpKTtcblx0fTtcblx0XG5cdFZhck9yQWNjZXNzLnByb3RvdHlwZS5zeW1ib2wgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5faWRlbnRpZmllci5zeW1ib2woKTtcblx0XHQvLyB2YWx1ZSBhbmQgdmFsdWUuc3ltYm9sXG5cdH07XG5cdFxuXHRWYXJPckFjY2Vzcy5wcm90b3R5cGUuY2FjaGUgPSBmdW5jdGlvbiAobyl7XG5cdFx0aWYobyA9PT0gdW5kZWZpbmVkKSBvID0ge307XG5cdFx0cmV0dXJuIHRoaXMuX3ZhcmlhYmxlID8gKChvLmZvcmNlICYmIFZhck9yQWNjZXNzLl9fc3VwZXJfXy5jYWNoZS5jYWxsKHRoaXMsbykpKSA6ICh0aGlzLnZhbHVlKCkuY2FjaGUobykpO1xuXHRcdC8vIHNob3VsZCB3ZSByZWFsbHkgY2FjaGUgdGhpcz9cblx0XHQvLyB2YWx1ZS5jYWNoZShvKVxuXHR9O1xuXHRcblx0VmFyT3JBY2Nlc3MucHJvdG90eXBlLmRlY2FjaGUgPSBmdW5jdGlvbiAoKXtcblx0XHR0aGlzLl92YXJpYWJsZSA/IChWYXJPckFjY2Vzcy5fX3N1cGVyX18uZGVjYWNoZS5jYWxsKHRoaXMpKSA6ICh0aGlzLnZhbHVlKCkuZGVjYWNoZSgpKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFZhck9yQWNjZXNzLnByb3RvdHlwZS5kb20gPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy52YWx1ZSgpLmRvbSgpO1xuXHR9O1xuXHRcblx0VmFyT3JBY2Nlc3MucHJvdG90eXBlLnNhZmVjaGFpbiA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9pZGVudGlmaWVyLnNhZmVjaGFpbigpO1xuXHR9O1xuXHRcblx0VmFyT3JBY2Nlc3MucHJvdG90eXBlLmR1bXAgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4ge2xvYzogdGhpcy5sb2MoKX07XG5cdH07XG5cdFxuXHRWYXJPckFjY2Vzcy5wcm90b3R5cGUubG9jID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIGxvYyA9IHRoaXMuX2lkZW50aWZpZXIucmVnaW9uKCk7XG5cdFx0cmV0dXJuIGxvYyB8fCBbMCwwXTtcblx0fTtcblx0XG5cdFZhck9yQWNjZXNzLnByb3RvdHlwZS5yZWdpb24gPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5faWRlbnRpZmllci5yZWdpb24oKTtcblx0fTtcblx0XG5cdFZhck9yQWNjZXNzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiAoXCJWYXJPckFjY2VzcyhcIiArIHRoaXMudmFsdWUoKSArIFwiKVwiKTtcblx0fTtcblx0XG5cdFZhck9yQWNjZXNzLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4ge3R5cGU6IHRoaXMudHlwZU5hbWUoKSx2YWx1ZTogdGhpcy5faWRlbnRpZmllci50b1N0cmluZygpfTtcblx0fTtcblx0XG5cdC8vXHRkZWYganNcblx0Ly9cdFx0aWYgcmlnaHQgaXNhIFZhcmlhYmxlIGFuZCByaWdodC50eXBlID09ICdtZXRoJ1xuXHQvL1x0XHRcdHJldHVybiBcIntyaWdodC5jfSgpXCIgdW5sZXNzIHVwIGlzYSBDYWxsXG5cdC8vXG5cdC8vXHRcdHJpZ2h0LmNcblx0Ly9cblx0Ly9cdGRlZiB2YXJpYWJsZVxuXHQvL1x0XHRyaWdodFxuXHQvL1xuXHQvL1x0ZGVmIGNhY2hlIG8gPSB7fVxuXHQvL1x0XHRzdXBlciBpZiBvOmZvcmNlXG5cdC8vXHRcdHNlbGZcblx0Ly9cblx0Ly9cdGRlZiBhbGlhc1xuXHQvL1x0XHR2YXJpYWJsZS5AYWxpYXMgb3Igc3VwZXIgIyBpZiByZXNvbHZlZD9cblx0Ly9cblx0XG5cdGZ1bmN0aW9uIFZhclJlZmVyZW5jZSh2YWx1ZSx0eXBlKXtcblx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBWYXJPckFjY2Vzcykge1xuXHRcdFx0dmFsdWUgPSB2YWx1ZS52YWx1ZSgpO1xuXHRcdH07XG5cdFx0Ly8gZm9yIG5vdyAtIHRoaXMgY2FuIGhhcHBlblxuXHRcdFZhclJlZmVyZW5jZS5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzLHZhbHVlKTtcblx0XHR0aGlzLl9leHBvcnQgPSBmYWxzZTtcblx0XHR0aGlzLl90eXBlID0gdHlwZSAmJiBTdHJpbmcodHlwZSk7XG5cdFx0dGhpcy5fdmFyaWFibGUgPSBudWxsO1xuXHRcdHRoaXMuX2RlY2xhcmVkID0gdHJ1ZTsgLy8ganVzdCB0ZXN0aW5nIG5vd1xuXHR9O1xuXHRcblx0XG5cdHN1YmNsYXNzJChWYXJSZWZlcmVuY2UsVmFsdWVOb2RlKTtcblx0ZXhwb3J0cy5WYXJSZWZlcmVuY2UgPSBWYXJSZWZlcmVuY2U7IC8vIGV4cG9ydCBjbGFzcyBcblx0VmFyUmVmZXJlbmNlLnByb3RvdHlwZS52YXJpYWJsZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fdmFyaWFibGU7IH1cblx0VmFyUmVmZXJlbmNlLnByb3RvdHlwZS5zZXRWYXJpYWJsZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl92YXJpYWJsZSA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRWYXJSZWZlcmVuY2UucHJvdG90eXBlLmRlY2xhcmVkID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9kZWNsYXJlZDsgfVxuXHRWYXJSZWZlcmVuY2UucHJvdG90eXBlLnNldERlY2xhcmVkID0gZnVuY3Rpb24odil7IHRoaXMuX2RlY2xhcmVkID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFZhclJlZmVyZW5jZS5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fdHlwZTsgfVxuXHRWYXJSZWZlcmVuY2UucHJvdG90eXBlLnNldFR5cGUgPSBmdW5jdGlvbih2KXsgdGhpcy5fdHlwZSA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0VmFyUmVmZXJlbmNlLnByb3RvdHlwZS5sb2MgPSBmdW5jdGlvbiAoKXtcblx0XHQvLyBwIFwibG9jIGZvciBWYXJSZWZlcmVuY2Uge0B2YWx1ZTpjb25zdHJ1Y3Rvcn0ge0B2YWx1ZS5AdmFsdWU6Y29uc3RydWN0b3J9IHtAdmFsdWUucmVnaW9ufVwiXG5cdFx0cmV0dXJuIHRoaXMuX3ZhbHVlLnJlZ2lvbigpO1xuXHR9O1xuXHRcblx0VmFyUmVmZXJlbmNlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAobyl7XG5cdFx0Ly8gaGFjayAtIHdvcmthcm91bmQgZm9yIGhpZGRlbiBjbGFzc2VzIHBlcmZcblx0XHRpZiAoby5leHBvcnQpIHsgdGhpcy5fZXhwb3J0ID0gdHJ1ZSB9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0VmFyUmVmZXJlbmNlLnByb3RvdHlwZS5qcyA9IGZ1bmN0aW9uIChvKXtcblx0XHQvLyBleHBlcmltZW50YWwgZml4XG5cdFx0XG5cdFx0Ly8gd2hhdCBhYm91dCByZXNvbHZpbmc/XG5cdFx0dmFyIHJlZiA9IHRoaXMuX3ZhcmlhYmxlO1xuXHRcdHZhciBvdXQgPSAoXCJcIiArIG1hcmtfXyh0aGlzLl92YWx1ZSkgKyAocmVmLmMoKSkpO1xuXHRcdFxuXHRcdC8vIHAgXCJWYXJSZWZlcmVuY2Uge291dH0gLSB7by51cH0ge28udXAgPT0gc2VsZn1cXG57b31cIlxuXHRcdFxuXHRcdGlmIChyZWYgJiYgIXJlZi5fZGVjbGFyZWQpIHsgLy8gLm9wdGlvbig6ZGVjbGFyZWQpXG5cdFx0XHRpZiAoby51cChWYXJCbG9jaykpIHsgLy8gdXAgdmFyYmxvY2s/P1xuXHRcdFx0XHRyZWYuX2RlY2xhcmVkID0gdHJ1ZTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIHJlZi5zZXQoZGVjbGFyZWQ6IHllcylcblx0XHRcdH0gZWxzZSBpZiAoby5pc0V4cHJlc3Npb24oKSB8fCB0aGlzLl9leHBvcnQpIHsgLy8gd2h5P1xuXHRcdFx0XHQvLyBwIFwiYXV0b2RlY2xhcmVcIlxuXHRcdFx0XHRyZWYuYXV0b2RlY2xhcmUoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dCA9IChcInZhciBcIiArIG91dCk7XG5cdFx0XHRcdHJlZi5fZGVjbGFyZWQgPSB0cnVlO1xuXHRcdFx0XHQvLyByZWYuc2V0KGRlY2xhcmVkOiB5ZXMpXG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gbmVlZCB0byB0aGluayB0aGUgZXhwb3J0IHRocm91Z2ggLS0gbGlrZSByZWdpc3RlcmluZyBzb21laG93XG5cdFx0Ly8gc2hvdWxkIHJlZ2lzdGVyIGluIHNjb3BlIC0gZXhwb3J0IG9uIGFuYWx5c2lzKytcblx0XHRpZiAodGhpcy5fZXhwb3J0KSB7XG5cdFx0XHRvdXQgPSAoXCJtb2R1bGUuZXhwb3J0cy5cIiArIChyZWYuYygpKSArIFwiID0gXCIgKyAocmVmLmMoKSkpO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIG91dDtcblx0fTtcblx0XG5cdFZhclJlZmVyZW5jZS5wcm90b3R5cGUuZGVjbGFyZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0VmFyUmVmZXJlbmNlLnByb3RvdHlwZS5jb25zdW1lID0gZnVuY3Rpb24gKG5vZGUpe1xuXHRcdC8vIHJlYWxseT8gdGhlIGNvbnN1bWVkIG5vZGUgZGlzc2FwcGVhcj9cblx0XHR0aGlzLl92YXJpYWJsZSAmJiB0aGlzLl92YXJpYWJsZS5hdXRvZGVjbGFyZSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0VmFyUmVmZXJlbmNlLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICgpe1xuXHRcdFxuXHRcdC8vIGNvbnNvbGUubG9nIFwidmFsdWUgdHlwZSBmb3IgVmFyUmVmZXJlbmNlIHtAdmFsdWV9IHtAdmFsdWUuQGxvY30ge0B2YWx1ZTpjb25zdHJ1Y3Rvcn1cIlxuXHRcdFxuXHRcdC8vIHNob3VsZCBiZSBwb3NzaWJsZSB0byBoYXZlIGEgVmFyUmVmZXJlbmNlIHdpdGhvdXQgYSBuYW1lIGFzIHdlbGw/IGZvciBhIHN5c3RlbS12YXJpYWJsZVxuXHRcdC8vIG5hbWUgc2hvdWxkIG5vdCBzZXQgdGhpcyB3YXkuXG5cdFx0Ly8gcCBcInZhcm5hbWUge3ZhbHVlfSB7dmFsdWU6Y29uc3RydWN0b3J9XCJcblx0XHR2YXIgbmFtZSA9IHRoaXMudmFsdWUoKS5jKCk7XG5cdFx0Ly8gcCBcInZpc2l0IHZhcmRlY2wge25hbWV9IHt2YWx1ZX1cIlxuXHRcdFxuXHRcdC8vIHdoYXQgYWJvdXQgbG9va2luZyB1cD8gLSBvbiByZWdpc3RlciB3ZSB3YW50IHRvIG1hcmtcblx0XHR2YXIgdiA9IHRoaXMuX3ZhcmlhYmxlIHx8ICh0aGlzLl92YXJpYWJsZSA9IHRoaXMuc2NvcGVfXygpLnJlZ2lzdGVyKG5hbWUsdGhpcyx7dHlwZTogdGhpcy5fdHlwZX0pKTtcblx0XHQvLyBGSVhNRSAtLSBzaG91bGQgbm90IHNpbXBseSBvdmVycmlkZSB0aGUgZGVjbGFyYXRvciBoZXJlKCEpXG5cdFx0XG5cdFx0aWYgKCF2LmRlY2xhcmF0b3IoKSkge1xuXHRcdFx0di5zZXREZWNsYXJhdG9yKHRoaXMpO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKHRoaXMuX3ZhbHVlKSB7IHYuYWRkUmVmZXJlbmNlKHRoaXMuX3ZhbHVlKSB9OyAvLyBpcyB0aGlzIHRoZSBmaXJzdCByZWZlcmVuY2U/XG5cdFx0XG5cdFx0Ly8gb25seSBuZWVkZWQgd2hlbiBhbmFseXppbmc/XG5cdFx0dGhpcy5fdmFsdWUuX3ZhbHVlLl92YXJpYWJsZSA9IHY7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRWYXJSZWZlcmVuY2UucHJvdG90eXBlLnJlZm5yID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMudmFyaWFibGUoKS5yZWZlcmVuY2VzKCkuaW5kZXhPZih0aGlzLnZhbHVlKCkpO1xuXHR9O1xuXHRcblx0Ly8gY29udmVydCB0aGlzIGludG8gYSBsaXN0IG9mIHJlZmVyZW5jZXNcblx0VmFyUmVmZXJlbmNlLnByb3RvdHlwZS5hZGRFeHByZXNzaW9uID0gZnVuY3Rpb24gKGV4cHIpe1xuXHRcdFxuXHRcdHJldHVybiBuZXcgVmFyQmxvY2soW3RoaXNdKS5hZGRFeHByZXNzaW9uKGV4cHIpO1xuXHR9O1xuXHRcblx0XG5cdC8vIEFTU0lHTlxuXHRcblx0ZnVuY3Rpb24gQXNzaWduKG8sbCxyKXtcblx0XHRcblx0XHQvLyB3b3JrYXJvdW5kIHVudGlsIHdlIGNvbXBsZXRlIHRyYW5zaXRpb24gZnJvbSBsdWEtc3R5bGUgYXNzaWdubWVudHNcblx0XHQvLyB0byBhbHdheXMgdXNlIGV4cGxpY2l0IHR1cGxlcyAtIHRoZW4gd2UgY2FuIG1vdmUgYXNzaWdubWVudHMgb3V0IGV0Y1xuXHRcdC8vIHRoaXMgd2lsbCBub3QgYmUgbmVlZGVkIGFmdGVyIHdlIHJlbW92ZSBzdXBwb3J0IGZvciB2YXIgYSxiLGMgPSAxLDIsM1xuXHRcdGlmICgobCBpbnN0YW5jZW9mIFZhclJlZmVyZW5jZSkgJiYgKGwudmFsdWUoKSBpbnN0YW5jZW9mIEFycikpIHtcblx0XHRcdC8vIGNvbnZlcnRpbmcgYWxsIG5vZGVzIHRvIHZhci1yZWZlcmVuY2VzID9cblx0XHRcdC8vIGRvIHdlIG5lZWQgdG8ga2VlcCBpdCBpbiBhIHZhcmJsb2NrIGF0IGFsbD9cblx0XHRcdHZhciB2YXJzID0gbC52YWx1ZSgpLm5vZGVzKCkubWFwKGZ1bmN0aW9uKHYpIHtcblx0XHRcdFx0Ly8gd2hhdCBhYm91dCBpbm5lciB0dXBsZXMgZXRjP1xuXHRcdFx0XHQvLyBrZWVwIHRoZSBzcGxhdHMgLS0gY2x1bXN5IGJ1dCB0cnVlXG5cdFx0XHRcdHZhciB2Xztcblx0XHRcdFx0aWYgKHYgaW5zdGFuY2VvZiBTcGxhdCkge1xuXHRcdFx0XHRcdC8vIHAgXCJ2YWx1ZSBpcyBhIHNwbGF0ISFcIlxuXHRcdFx0XHRcdGlmICghKCh2LnZhbHVlKCkgaW5zdGFuY2VvZiBWYXJSZWZlcmVuY2UpKSkgeyAodi5zZXRWYWx1ZSh2XyA9IG5ldyBWYXJSZWZlcmVuY2Uodi52YWx1ZSgpLGwudHlwZSgpKSksdl8pIH07XG5cdFx0XHRcdH0gZWxzZSBpZiAodiBpbnN0YW5jZW9mIFZhclJlZmVyZW5jZSkge1xuXHRcdFx0XHRcdHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gd2hhdCBhYm91dCByZXRhaW5pbmcgbG9jYXRpb24/XG5cdFx0XHRcdFx0Ly8gdiA9IHYudmFsdWUgaWYgdiBpc2EgVmFyT3JBY2Nlc3Ncblx0XHRcdFx0XHR2ID0gbmV3IFZhclJlZmVyZW5jZSh2LGwudHlwZSgpKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiB2O1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gdiBpc2EgVmFyUmVmZXJlbmNlID8gdiA6IFZhclJlZmVyZW5jZS5uZXcodilcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIG5ldyBUdXBsZUFzc2lnbihvLG5ldyBUdXBsZSh2YXJzKSxyKTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmIChsIGluc3RhbmNlb2YgQXJyKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFR1cGxlQXNzaWduKG8sbmV3IFR1cGxlKGwubm9kZXMoKSkscik7XG5cdFx0XHQvLyBwIFwibGVmdCBpcyBhcnJheSBpbiBhc3NpZ24gLSBpbiBpbml0XCJcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8vIHNldCBleHByZXNzaW9uIHllcywgbm8/XG5cdFx0dGhpcy5fZXhwcmVzc2lvbiA9IGZhbHNlO1xuXHRcdHRoaXMuX3RyYXZlcnNlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX3BhcmVucyA9IGZhbHNlO1xuXHRcdHRoaXMuX2NhY2hlID0gbnVsbDtcblx0XHR0aGlzLl9pbnZlcnQgPSBmYWxzZTtcblx0XHR0aGlzLl9vcFRva2VuID0gbztcblx0XHR0aGlzLl9vcCA9IG8gJiYgby5fdmFsdWUgfHwgbztcblx0XHR0aGlzLl9sZWZ0ID0gbDtcblx0XHR0aGlzLl9yaWdodCA9IHI7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRzdWJjbGFzcyQoQXNzaWduLE9wKTtcblx0ZXhwb3J0cy5Bc3NpZ24gPSBBc3NpZ247IC8vIGV4cG9ydCBjbGFzcyBcblx0QXNzaWduLnByb3RvdHlwZS5pc0V4cHJlc3NhYmxlID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuICEodGhpcy5yaWdodCgpKSB8fCB0aGlzLnJpZ2h0KCkuaXNFeHByZXNzYWJsZSgpO1xuXHR9O1xuXHRcblx0QXNzaWduLnByb3RvdHlwZS5pc1VzZWQgPSBmdW5jdGlvbiAoKXtcblx0XHQvLyByZWFsbHk/XG5cdFx0Ly8gaWYgdXAgaXMgYSBibG9jayBpbiBnZW5lcmFsIHRoaXMgc2hvdWxkIG5vdCBiZSB1c2VkIC0tIHNpbmNlIGl0IHNob3VsZCBhbHJlYWR5IGhhdmUgcmVjZWl2ZWQgaW1wbGljaXQgc2VsZj9cblx0XHRpZiAodGhpcy51cCgpIGluc3RhbmNlb2YgQmxvY2spIHsgLy8gJiYgdXAubGFzdCAhPSBzZWxmXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblx0XG5cdC8vIEZJWE1FIG9wdGltaXplXG5cdEFzc2lnbi5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgbCA9IHRoaXMuX2xlZnQ7XG5cdFx0dmFyIHIgPSB0aGlzLl9yaWdodDtcblx0XHRcblx0XHQvLyBXQVJOSU5HIC0gc2xpZ2h0bHkgdW5kZWZpbmVkXG5cdFx0Ly8gTUFSSyBUSEUgU1RBQ0tcblx0XHRpZiAobCkgeyBsLnRyYXZlcnNlKCkgfTtcblx0XHRcblx0XHR2YXIgbHZhciA9IChsIGluc3RhbmNlb2YgVmFyUmVmZXJlbmNlKSAmJiBsLnZhcmlhYmxlKCk7XG5cdFx0XG5cdFx0Ly8gaG93IGRvZXMgdGhpcyB3b3JrIHdpdGggY29uc3RhbnRzIHRoYXQgYXJlIHJlYWxseSB2YXIgcmVmZXJlbmNlcz9cblx0XHQvLyBzaG91bGQgd29yayB3aGVuIHRoaW5ncyBhcmUgbm90IGRlc2NyaWJlZCBhcyB3ZWxsIC0gYnV0IHRoaXMgaXMgZm9yIHRlc3Rpbmdcblx0XHQvLyBidXQgaWYgaXQgcmVmZXJzIHRvIHNvbWV0aGluZyBlbHNlIFxuXHRcdGlmICghbHZhciAmJiB0aGlzLl9kZXNjKSB7XG5cdFx0XHQvLyBlbnRpdGllcyBzaG91bGQgYmUgYWJsZSB0byBleHRyYWN0IHRoZSBuZWVkZWQgaW5mbyBpbnN0ZWFkXG5cdFx0XHRST09ULmVudGl0aWVzKCkuYWRkKGwubmFtZXBhdGgoKSx7bmFtZXBhdGg6IGwubmFtZXBhdGgoKSx0eXBlOiByLnR5cGVOYW1lKCksZGVzYzogdGhpcy5fZGVzY30pO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gdGhpcyBzaG91bGQgcHJvYmFibHkgYmUgZG9uZSBpbiBhIGRpZmZlcmVudCBtYW5uZXJcblx0XHRpZiAobHZhciAmJiBsdmFyLmRlY2xhcmF0b3IoKSA9PSBsKSB7XG5cdFx0XHRsdmFyLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuXHRcdFx0aWYgKHIpIHsgci50cmF2ZXJzZSgpIH07XG5cdFx0XHRsdmFyLl9pbml0aWFsaXplZCA9IHRydWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChyKSB7IHIudHJhdmVyc2UoKSB9O1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKChsIGluc3RhbmNlb2YgVmFyUmVmZXJlbmNlKSB8fCBsLl92YXJpYWJsZSkge1xuXHRcdFx0bC5fdmFyaWFibGUuYXNzaWduZWQocix0aGlzKTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0QXNzaWduLnByb3RvdHlwZS5jID0gZnVuY3Rpb24gKG8pe1xuXHRcdGlmICghdGhpcy5yaWdodCgpLmlzRXhwcmVzc2FibGUoKSkge1xuXHRcdFx0Ly8gcCBcIkFzc2lnbiNjIHJpZ2h0IGlzIG5vdCBleHByZXNzYWJsZSBcIlxuXHRcdFx0cmV0dXJuIHRoaXMucmlnaHQoKS5jb25zdW1lKHRoaXMpLmMobyk7XG5cdFx0fTtcblx0XHQvLyB0ZXN0aW5nIHRoaXNcblx0XHRyZXR1cm4gQXNzaWduLl9fc3VwZXJfXy5jLmNhbGwodGhpcyxvKTtcblx0fTtcblx0XG5cdEFzc2lnbi5wcm90b3R5cGUuanMgPSBmdW5jdGlvbiAobyl7XG5cdFx0aWYgKCF0aGlzLnJpZ2h0KCkuaXNFeHByZXNzYWJsZSgpKSB7XG5cdFx0XHR0aGlzLnAoXCJBc3NpZ24janMgcmlnaHQgaXMgbm90IGV4cHJlc3NhYmxlIFwiKTtcblx0XHRcdC8vIGhlcmUgdGhpcyBzaG91bGQgYmUgZ28gb3V0IG9mIHRoZSBzdGFjayghKVxuXHRcdFx0Ly8gaXQgc2hvdWxkIGFscmVhZHkgYmUgY29uc3VtZWQ/XG5cdFx0XHRyZXR1cm4gdGhpcy5yaWdodCgpLmNvbnN1bWUodGhpcykuYygpO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gcCBcImFzc2lnbiBsZWZ0IHtsZWZ0OmNvbnRyc3RydX1cIlxuXHRcdHZhciBsID0gdGhpcy5sZWZ0KCkubm9kZSgpO1xuXHRcdHZhciByID0gdGhpcy5yaWdodCgpO1xuXHRcdFxuXHRcdC8vIFdlIGFyZSBzZXR0aW5nIHNlbGYoISlcblx0XHQvLyBUT0RPIGRvY3VtZW50IGZ1bmN0aW9uYWxpdHlcblx0XHRpZiAobCBpbnN0YW5jZW9mIFNlbGYpIHtcblx0XHRcdHZhciBjdHggPSB0aGlzLnNjb3BlX18oKS5jb250ZXh0KCk7XG5cdFx0XHRsID0gY3R4LnJlZmVyZW5jZSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0aWYgKGwgaW5zdGFuY2VvZiBQcm9wZXJ0eUFjY2Vzcykge1xuXHRcdFx0dmFyIGFzdCA9IENBTEwoT1AoJy4nLGwubGVmdCgpLGwucmlnaHQoKS5zZXR0ZXIoKSksW3RoaXMucmlnaHQoKV0pO1xuXHRcdFx0YXN0LnNldFJlY2VpdmVyKGwucmVjZWl2ZXIoKSk7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLmlzVXNlZCgpKSB7XG5cdFx0XHRcdC8vIHAgXCJBc3NpZ24gaXMgdXNlZCB7c3RhY2t9XCJcblx0XHRcdFx0Ly8gZG9udCBjYWNoZSBpdCBhZ2FpbiBpZiBpdCBpcyBhbHJlYWR5IGNhY2hlZCghKVxuXHRcdFx0XHRpZiAoIXRoaXMucmlnaHQoKS5jYWNoZXZhcigpKSB7IHRoaXMucmlnaHQoKS5jYWNoZSh7cG9vbDogJ3ZhbCcsdXNlczogMX0pIH07IC8vIFxuXHRcdFx0XHQvLyB0aGlzIGlzIG9ubHkgd2hlbiB1c2VkLi4gc2hvdWxkIGJlIG1vcmUgY2xldmVyIGFib3V0IGl0XG5cdFx0XHRcdGFzdCA9IG5ldyBQYXJlbnMoYmxrX18oW2FzdCx0aGlzLnJpZ2h0KCldKSk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHQvLyBzaG91bGQgY2hlY2sgdGhlIHVwLXZhbHVlIG5vP1xuXHRcdFx0cmV0dXJuIGFzdC5jKHtleHByZXNzaW9uOiB0cnVlfSk7XG5cdFx0fTtcblx0XHRcblx0XHQvLyBpZiBsIGlzYSBWYXJSZWZlcmVuY2Vcblx0XHQvLyBcdHAgXCJhc3NpZ24gdmFyLXJlZlwiXG5cdFx0Ly8gXHRsLkB2YXJpYWJsZS5hc3NpZ25lZChyKVxuXHRcdFxuXHRcdC8vIEZJWE1FIC0tIGRvZXMgbm90IGFsd2F5cyBuZWVkIHRvIGJlIGFuIGV4cHJlc3Npb24/XG5cdFx0Ly8gcCBcInR5cGVvZiBvcCB7QG9wVG9rZW4gYW5kIEBvcFRva2VuOmNvbnN0cnVjdG9yfVwiXG5cdFx0dmFyIG91dCA9IChcIlwiICsgKGwuYygpKSArIFwiIFwiICsgbWFya19fKHRoaXMuX29wVG9rZW4pICsgdGhpcy5vcCgpICsgXCIgXCIgKyB0aGlzLnJpZ2h0KCkuYyh7ZXhwcmVzc2lvbjogdHJ1ZX0pKTtcblx0XHRcblx0XHRyZXR1cm4gb3V0O1xuXHR9O1xuXHRcblx0Ly8gRklYTUUgb3AgaXMgYSB0b2tlbj8gX0ZJWF9cblx0Ly8gdGhpcyAoYW5kIHNpbWlsYXIgY2FzZXMpIGlzIGJyb2tlbiB3aGVuIGNhbGxlZCBmcm9tXG5cdC8vIGFub3RoZXIgcG9zaXRpb24gaW4gdGhlIHN0YWNrLCBzaW5jZSAndXAnIGlzIGR5bmFtaWNcblx0Ly8gc2hvdWxkIG1heWJlIGZyZWV6ZSB1cD9cblx0QXNzaWduLnByb3RvdHlwZS5zaG91bGRQYXJlbnRoZXNpemUgPSBmdW5jdGlvbiAocGFyKXtcblx0XHRpZihwYXIgPT09IHVuZGVmaW5lZCkgcGFyID0gdGhpcy51cCgpO1xuXHRcdHJldHVybiB0aGlzLl9wYXJlbnMgfHwgKHBhciBpbnN0YW5jZW9mIE9wKSAmJiBwYXIub3AoKSAhPSAnPSc7XG5cdH07XG5cdFxuXHRBc3NpZ24ucHJvdG90eXBlLmNvbnN1bWUgPSBmdW5jdGlvbiAobm9kZSl7XG5cdFx0aWYgKHRoaXMuaXNFeHByZXNzYWJsZSgpKSB7XG5cdFx0XHR0aGlzLmZvcmNlRXhwcmVzc2lvbigpO1xuXHRcdFx0cmV0dXJuIEFzc2lnbi5fX3N1cGVyX18uY29uc3VtZS5jYWxsKHRoaXMsbm9kZSk7XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgYXN0ID0gdGhpcy5yaWdodCgpLmNvbnN1bWUodGhpcyk7XG5cdFx0cmV0dXJuIGFzdC5jb25zdW1lKG5vZGUpO1xuXHR9O1xuXHRcblx0Ly8gbW9yZSB3b3JrYXJvdW5kIGR1cmluZyB0cmFuc2l0aW9uIGF3YXkgZnJvbSBhLGIsYyA9IDEsMiwzIHN0eWxlIGFzc2lnblxuXHRBc3NpZ24ucHJvdG90eXBlLmFkZEV4cHJlc3Npb24gPSBmdW5jdGlvbiAoZXhwcil7XG5cdFx0dmFyIHR5cCA9IEV4cHJlc3Npb25CbG9jaztcblx0XHRpZiAodGhpcy5fbGVmdCAmJiAodGhpcy5fbGVmdCBpbnN0YW5jZW9mIFZhclJlZmVyZW5jZSkpIHtcblx0XHRcdHR5cCA9IFZhckJsb2NrO1xuXHRcdH07XG5cdFx0Ly8gbWlnaHQgYmUgYmV0dGVyIHRvIG5lc3QgdGhpcyB1cCBhZnRlciBwYXJzaW5nIGlzIGRvbmU/XG5cdFx0Ly8gcCBcIkFzc2lnbi5hZGRFeHByZXNzaW9uIHtzZWxmfSA8LSB7ZXhwcn1cIlxuXHRcdHZhciBub2RlID0gbmV3IHR5cChbdGhpc10pO1xuXHRcdHJldHVybiBub2RlLmFkZEV4cHJlc3Npb24oZXhwcik7XG5cdH07XG5cdFxuXHRcblx0ZnVuY3Rpb24gUHVzaEFzc2lnbigpeyByZXR1cm4gQXNzaWduLmFwcGx5KHRoaXMsYXJndW1lbnRzKSB9O1xuXHRcblx0c3ViY2xhc3MkKFB1c2hBc3NpZ24sQXNzaWduKTtcblx0ZXhwb3J0cy5QdXNoQXNzaWduID0gUHVzaEFzc2lnbjsgLy8gZXhwb3J0IGNsYXNzIFxuXHRQdXNoQXNzaWduLnByb3RvdHlwZS5qcyA9IGZ1bmN0aW9uIChvKXtcblx0XHRyZXR1cm4gKFwiXCIgKyAodGhpcy5sZWZ0KCkuYygpKSArIFwiLnB1c2goXCIgKyAodGhpcy5yaWdodCgpLmMoKSkgKyBcIilcIik7XG5cdH07XG5cdFxuXHRQdXNoQXNzaWduLnByb3RvdHlwZS5jb25zdW1lID0gZnVuY3Rpb24gKG5vZGUpe1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0XG5cdGZ1bmN0aW9uIENvbmRpdGlvbmFsQXNzaWduKCl7IHJldHVybiBBc3NpZ24uYXBwbHkodGhpcyxhcmd1bWVudHMpIH07XG5cdFxuXHRzdWJjbGFzcyQoQ29uZGl0aW9uYWxBc3NpZ24sQXNzaWduKTtcblx0ZXhwb3J0cy5Db25kaXRpb25hbEFzc2lnbiA9IENvbmRpdGlvbmFsQXNzaWduOyAvLyBleHBvcnQgY2xhc3MgXG5cdENvbmRpdGlvbmFsQXNzaWduLnByb3RvdHlwZS5jb25zdW1lID0gZnVuY3Rpb24gKG5vZGUpe1xuXHRcdHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpLmNvbnN1bWUobm9kZSk7XG5cdH07XG5cdFxuXHRDb25kaXRpb25hbEFzc2lnbi5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIGwgPSB0aGlzLmxlZnQoKS5ub2RlKCk7XG5cdFx0dmFyIGxzID0gbDtcblx0XHRcblx0XHRpZiAobCBpbnN0YW5jZW9mIEFjY2Vzcykge1xuXHRcdFx0Ly8gcCBcImNvbmRpdGlvbmFsLWFzc2lnbiB7bH0ge2wubGVmdH0ge2wucmlnaHR9XCJcblx0XHRcdGlmIChsLmxlZnQoKSkge1xuXHRcdFx0XHQvLyBwIFwiY2FjaGUgbC5sZWZ0IHtsLmxlZnQ6Y29uc3RydWN0b3J9zItcIlxuXHRcdFx0XHRsLmxlZnQoKS5jYWNoZSgpO1xuXHRcdFx0fTtcblx0XHRcdGxzID0gbC5jbG9uZShsLmxlZnQoKSxsLnJpZ2h0KCkpOyAvLyB0aGlzIHNob3VsZCBzdGlsbCBiZSBjYWNoZWQ/XG5cdFx0XHRpZiAobCBpbnN0YW5jZW9mIFByb3BlcnR5QWNjZXNzKSB7IGwuY2FjaGUoKSB9OyAvLyBjb3JyZWN0IG5vdywgdG8gYSBjZXJ0YWluIGRlZ3JlZVxuXHRcdFx0aWYgKGwgaW5zdGFuY2VvZiBJbmRleEFjY2Vzcykge1xuXHRcdFx0XHQvLyBwIFwiY2FjaGUgdGhlIHJpZ2h0IHNpZGUgb2YgaW5kZXhBY2Nlc3MhISEge2wucmlnaHR9XCJcblx0XHRcdFx0bC5yaWdodCgpLmNhY2hlKCk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHQvLyB3ZSBzaG91bGQgb25seSBjYWNoZSB0aGUgdmFsdWUgaXRzZWxmIGlmIGl0IGlzIGR5bmFtaWM/XG5cdFx0XHQvLyBsLmNhY2hlICMgY2FjaGUgdGhlIHZhbHVlIGFzIHdlbGwgLS0gd2UgY2Fubm90IHVzZSB0aGlzIGluIGFzc2lnbnMgdGhlbVxuXHRcdH07XG5cdFx0XG5cdFx0Ly8gc29tZSBvcHMgYXJlIGxlc3MgbWVzc3lcblx0XHQvLyBuZWVkIG9wIHRvIHN1cHBvcnQgY29uc3VtZSB0aGVuP1xuXHRcdHZhciBleHByID0gdGhpcy5yaWdodCgpLmlzRXhwcmVzc2FibGUoKTtcblx0XHR2YXIgYXN0ID0gbnVsbDtcblx0XHQvLyBoZXJlIHdlIHNob3VsZCB1c2UgYXN0ID0gaWYgLi4uXG5cdFx0aWYgKGV4cHIgJiYgdGhpcy5vcCgpID09ICd8fD0nKSB7XG5cdFx0XHRhc3QgPSBPUCgnfHwnLGwsT1AoJz0nLGxzLHRoaXMucmlnaHQoKSkpO1xuXHRcdH0gZWxzZSBpZiAoZXhwciAmJiB0aGlzLm9wKCkgPT0gJyYmPScpIHtcblx0XHRcdGFzdCA9IE9QKCcmJicsbCxPUCgnPScsbHMsdGhpcy5yaWdodCgpKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFzdCA9IElGKHRoaXMuY29uZGl0aW9uKCksT1AoJz0nLGxzLHRoaXMucmlnaHQoKSksbCk7IC8vIGRvIHdlIG5lZWQgYSBzY29wZSBmb3IgdGhlc2U/XG5cdFx0XHRhc3Quc2V0U2NvcGUobnVsbCk7XG5cdFx0XHQvLyBkcm9wIHRoZSBzY29wZVxuXHRcdFx0Ly8gdG91Y2ggc2NvcGUgLS0gc2hvdWxkIHByb2JhYmx5IHZpc2l0IHRoZSB3aG9sZSB0aGluZz9cblx0XHRcdC8vIGFzdC5zY29wZS52aXNpdFxuXHRcdH07XG5cdFx0aWYgKGFzdC5pc0V4cHJlc3NhYmxlKCkpIHsgYXN0LnRvRXhwcmVzc2lvbigpIH07XG5cdFx0cmV0dXJuIGFzdDtcblx0fTtcblx0XG5cdFxuXHRDb25kaXRpb25hbEFzc2lnbi5wcm90b3R5cGUuYyA9IGZ1bmN0aW9uICgpe1xuXHRcdC8vIFdBUk4gd2hhdCBpZiB3ZSByZXR1cm4gdGhlIHNhbWU/XG5cdFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKCkuYygpO1xuXHR9O1xuXHRcblx0Q29uZGl0aW9uYWxBc3NpZ24ucHJvdG90eXBlLmNvbmRpdGlvbiA9IGZ1bmN0aW9uICgpe1xuXHRcdFxuXHRcdC8vIHVzZSBzd2l0Y2ggaW5zdGVhZCB0byBjYWNoZSBvcCBhY2Nlc3Ncblx0XHRpZiAodGhpcy5vcCgpID09ICc/PScpIHtcblx0XHRcdHJldHVybiBPUCgnPT0nLHRoaXMubGVmdCgpLE5VTEwpO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5vcCgpID09ICd8fD0nKSB7XG5cdFx0XHRyZXR1cm4gT1AoJyEnLHRoaXMubGVmdCgpKTtcblx0XHR9IGVsc2UgaWYgKHRoaXMub3AoKSA9PSAnJiY9Jykge1xuXHRcdFx0cmV0dXJuIHRoaXMubGVmdCgpO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5vcCgpID09ICchPz0nKSB7XG5cdFx0XHRyZXR1cm4gT1AoJyE9Jyx0aGlzLmxlZnQoKSxOVUxMKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHRoaXMubGVmdCgpO1xuXHRcdH07XG5cdH07XG5cdFxuXHRDb25kaXRpb25hbEFzc2lnbi5wcm90b3R5cGUuanMgPSBmdW5jdGlvbiAobyl7XG5cdFx0Ly8gcCBcIkNvbmRpdGlvbmFsQXNzaWduLmpzXCIucmVkXG5cdFx0dmFyIGFzdCA9IElGKHRoaXMuY29uZGl0aW9uKCksT1AoJz0nLHRoaXMubGVmdCgpLHRoaXMucmlnaHQoKSksdGhpcy5sZWZ0KCkpO1xuXHRcdGFzdC5zZXRTY29wZShudWxsKTsgLy8gbm90IHN1cmUgYWJvdXQgdGhpc1xuXHRcdGlmIChhc3QuaXNFeHByZXNzYWJsZSgpKSB7IGFzdC50b0V4cHJlc3Npb24oKSB9OyAvLyBmb3JjZWQgZXhwcmVzc2lvbiBhbHJlYWR5XG5cdFx0cmV0dXJuIGFzdC5jKCk7XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBDb21wb3VuZEFzc2lnbigpeyByZXR1cm4gQXNzaWduLmFwcGx5KHRoaXMsYXJndW1lbnRzKSB9O1xuXHRcblx0c3ViY2xhc3MkKENvbXBvdW5kQXNzaWduLEFzc2lnbik7XG5cdGV4cG9ydHMuQ29tcG91bmRBc3NpZ24gPSBDb21wb3VuZEFzc2lnbjsgLy8gZXhwb3J0IGNsYXNzIFxuXHRDb21wb3VuZEFzc2lnbi5wcm90b3R5cGUuY29uc3VtZSA9IGZ1bmN0aW9uIChub2RlKXtcblx0XHRpZiAodGhpcy5pc0V4cHJlc3NhYmxlKCkpIHsgcmV0dXJuIENvbXBvdW5kQXNzaWduLl9fc3VwZXJfXy5jb25zdW1lLmFwcGx5KHRoaXMsYXJndW1lbnRzKSB9O1xuXHRcdFxuXHRcdHZhciBhc3QgPSB0aGlzLm5vcm1hbGl6ZSgpO1xuXHRcdGlmIChhc3QgIT0gdGhpcykgeyByZXR1cm4gYXN0LmNvbnN1bWUobm9kZSkgfTtcblx0XHRcblx0XHRhc3QgPSB0aGlzLnJpZ2h0KCkuY29uc3VtZSh0aGlzKTtcblx0XHRyZXR1cm4gYXN0LmNvbnN1bWUobm9kZSk7XG5cdH07XG5cdFxuXHRDb21wb3VuZEFzc2lnbi5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIGxuID0gdGhpcy5sZWZ0KCkubm9kZSgpO1xuXHRcdC8vIHdlIGRvbnQgbmVlZCB0byBjaGFuZ2UgdGhpcyBhdCBhbGxcblx0XHRpZiAoISgobG4gaW5zdGFuY2VvZiBQcm9wZXJ0eUFjY2VzcykpKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdGlmIChsbiBpbnN0YW5jZW9mIEFjY2Vzcykge1xuXHRcdFx0Ly8gbGVmdCBtaWdodCBiZSB6ZXJvPyE/IVxuXHRcdFx0aWYgKGxuLmxlZnQoKSkgeyBsbi5sZWZ0KCkuY2FjaGUoKSB9O1xuXHRcdH07XG5cdFx0Ly8gVE9ETyBGSVhNRSB3ZSB3YW50IHRvIGNhY2hlIHRoZSBjb250ZXh0IG9mIHRoZSBhc3NpZ25tZW50XG5cdFx0Ly8gcCBcIm5vcm1hbGl6ZSBjb21wb3VuZCBhc3NpZ24ge2xlZnR9XCJcblx0XHR2YXIgYXN0ID0gT1AoJz0nLHRoaXMubGVmdCgpLE9QKHRoaXMub3AoKVswXSx0aGlzLmxlZnQoKSx0aGlzLnJpZ2h0KCkpKTtcblx0XHRpZiAoYXN0LmlzRXhwcmVzc2FibGUoKSkgeyBhc3QudG9FeHByZXNzaW9uKCkgfTtcblx0XHRcblx0XHRyZXR1cm4gYXN0O1xuXHR9O1xuXHRcblx0Q29tcG91bmRBc3NpZ24ucHJvdG90eXBlLmMgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgYXN0ID0gdGhpcy5ub3JtYWxpemUoKTtcblx0XHRpZiAoYXN0ID09IHRoaXMpIHsgcmV0dXJuIENvbXBvdW5kQXNzaWduLl9fc3VwZXJfXy5jLmFwcGx5KHRoaXMsYXJndW1lbnRzKSB9O1xuXHRcdFxuXHRcdC8vIG90aGVyd2lzZSBpdCBpcyBpbXBvcnRhbnQgdGhhdCB3ZSBhY3R1YWxseSByZXBsYWNlIHRoaXMgbm9kZSBpbiB0aGUgb3V0ZXIgYmxvY2tcblx0XHQvLyB3aGVuZXZlciB3ZSBub3JtYWxpemUgYW5kIG92ZXJyaWRlIGMgaXQgaXMgaW1wb3J0YW50IHRoYXQgd2UgY2FuIHBhc3Mgb24gY2FjaGluZ1xuXHRcdC8vIGV0YyAtLSBvdGhlcndpc2UgdGhlcmUgV0lMTCBiZSBpc3N1ZXMuXG5cdFx0dmFyIHVwID0gU1RBQ0suY3VycmVudCgpO1xuXHRcdGlmICh1cCBpbnN0YW5jZW9mIEJsb2NrKSB7XG5cdFx0XHQvLyBwIFwicGFyZW50IGlzIGJsb2NrLCBzaG91bGQgcmVwbGFjZSFcIlxuXHRcdFx0Ly8gYW4gYWx0ZXJuYXRpdmUgd291bGQgYmUgdG8ganVzdCBwYXNzXG5cdFx0XHR1cC5yZXBsYWNlKHRoaXMsYXN0KTtcblx0XHR9O1xuXHRcdHJldHVybiBhc3QuYygpO1xuXHR9O1xuXHRcblx0XG5cdGZ1bmN0aW9uIEFzeW5jQXNzaWduKCl7IHJldHVybiBBc3NpZ24uYXBwbHkodGhpcyxhcmd1bWVudHMpIH07XG5cdFxuXHRzdWJjbGFzcyQoQXN5bmNBc3NpZ24sQXNzaWduKTtcblx0ZXhwb3J0cy5Bc3luY0Fzc2lnbiA9IEFzeW5jQXNzaWduOyAvLyBleHBvcnQgY2xhc3MgXG5cdFxuXHRcblx0XG5cdGZ1bmN0aW9uIFR1cGxlQXNzaWduKGEsYixjKXtcblx0XHR0aGlzLl90cmF2ZXJzZWQgPSBmYWxzZTtcblx0XHR0aGlzLl9vcCA9IGE7XG5cdFx0dGhpcy5fbGVmdCA9IGI7XG5cdFx0dGhpcy5fcmlnaHQgPSBjO1xuXHRcdHRoaXMuX3RlbXBvcmFyeSA9IFtdO1xuXHR9O1xuXHRcblx0c3ViY2xhc3MkKFR1cGxlQXNzaWduLEFzc2lnbik7XG5cdGV4cG9ydHMuVHVwbGVBc3NpZ24gPSBUdXBsZUFzc2lnbjsgLy8gZXhwb3J0IGNsYXNzIFxuXHRUdXBsZUFzc2lnbi5wcm90b3R5cGUub3AgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX29wOyB9XG5cdFR1cGxlQXNzaWduLnByb3RvdHlwZS5zZXRPcCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9vcCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRUdXBsZUFzc2lnbi5wcm90b3R5cGUubGVmdCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fbGVmdDsgfVxuXHRUdXBsZUFzc2lnbi5wcm90b3R5cGUuc2V0TGVmdCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9sZWZ0ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFR1cGxlQXNzaWduLnByb3RvdHlwZS5yaWdodCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fcmlnaHQ7IH1cblx0VHVwbGVBc3NpZ24ucHJvdG90eXBlLnNldFJpZ2h0ID0gZnVuY3Rpb24odil7IHRoaXMuX3JpZ2h0ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFR1cGxlQXNzaWduLnByb3RvdHlwZS50eXBlID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl90eXBlOyB9XG5cdFR1cGxlQXNzaWduLnByb3RvdHlwZS5zZXRUeXBlID0gZnVuY3Rpb24odil7IHRoaXMuX3R5cGUgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFR1cGxlQXNzaWduLnByb3RvdHlwZS5pc0V4cHJlc3NhYmxlID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMucmlnaHQoKS5pc0V4cHJlc3NhYmxlKCk7XG5cdH07XG5cdFxuXHRUdXBsZUFzc2lnbi5wcm90b3R5cGUuYWRkRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChleHByKXtcblx0XHRpZiAodGhpcy5yaWdodCgpIGluc3RhbmNlb2YgVHVwbGUpIHtcblx0XHRcdHRoaXMucmlnaHQoKS5wdXNoKGV4cHIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBwIFwibWFraW5nIGNoaWxkIGJlY29tZSBhIHR1cGxlP1wiXG5cdFx0XHR0aGlzLnNldFJpZ2h0KG5ldyBUdXBsZShbdGhpcy5yaWdodCgpLGV4cHJdKSk7XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFR1cGxlQXNzaWduLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICgpe1xuXHRcdC8vIGlmIHRoZSBmaXJzdCBsZWZ0LXZhbHVlIGlzIGEgdmFyLXJlZmVyZW5jZSwgdGhlblxuXHRcdC8vIGFsbCB0aGUgdmFyaWFibGVzIHNob3VsZCBiZSBkZWNsYXJlZCBhcyB2YXJpYWJsZXMuXG5cdFx0Ly8gYnV0IGlmIHdlIGhhdmUgY29tcGxleCBpdGVtcyBpbiB0aGUgb3RoZXIgbGlzdCAtIGl0IGRvZXMgYmVjb21lIG11Y2ggaGFyZGVyXG5cdFx0XG5cdFx0Ly8gaWYgdGhlIGZpcnN0IGlzIGEgdmFyLXJlZmVyZW5jZSwgdGhleSBzaG91bGQgYWxsIGJlKCEpIC4uIG9yIHNwbGF0cz9cblx0XHQvLyB0aGlzIGlzIHJlYWxseSBhIGhhY2t5IHdhbyB0byBkbyBpdCB0aG91Z2hcblx0XHRpZiAodGhpcy5sZWZ0KCkuZmlyc3QoKS5ub2RlKCkgaW5zdGFuY2VvZiBWYXJSZWZlcmVuY2UpIHtcblx0XHRcdHRoaXMuc2V0VHlwZSgndmFyJyk7XG5cdFx0XHQvLyBzaG91bGQgcG9zc2libHkgYWxsb3cgcmVhbCB2YXJzIGFzIHdlbGwsIG5vP1xuXHRcdFx0dGhpcy5fdmFycyA9IHRoaXMubGVmdCgpLm5vZGVzKCkuZmlsdGVyKGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gaW5zdGFuY2VvZiBWYXJSZWZlcmVuY2U7IH0pO1xuXHRcdFx0Ly8gY29sbGVjdCB0aGUgdmFycyBmb3IgdHVwbGUgZm9yIGVhc3kgYWNjZXNzXG5cdFx0XHRcblx0XHRcdC8vIE5PVEUgY2FuIGltcHJvdmUuLiBzaG91bGQgcmF0aGVyIG1ha2UgdGhlIHdob2xlIGxlZnQgYmUgYSBWYXJCbG9jayBvciBUdXBsZVZhckJsb2NrXG5cdFx0XHQvLyBwIFwidHlwZSBpcyB2YXIgLS0gc2tpcCB0aGUgcmVzdFwiXG5cdFx0fTtcblx0XHRcblx0XHR0aGlzLnJpZ2h0KCkudHJhdmVyc2UoKTtcblx0XHR0aGlzLmxlZnQoKS50cmF2ZXJzZSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0VHVwbGVBc3NpZ24ucHJvdG90eXBlLmpzID0gZnVuY3Rpb24gKG8pe1xuXHRcdC8vIG9ubHkgZm9yIGFjdHVhbCBpbm5lciBleHByZXNzaW9ucywgb3RoZXJ3aXNlIGNhY2hlIHRoZSB3aG9sZSBhcnJheSwgbm8/XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdGlmICghc2VsZi5yaWdodCgpLmlzRXhwcmVzc2FibGUoKSkge1xuXHRcdFx0Ly8gcCBcIlR1cGxlQXNzaWduLmNvbnN1bWUhIHtyaWdodH1cIi5ibHVlXG5cdFx0XHRcblx0XHRcdHJldHVybiBzZWxmLnJpZ2h0KCkuY29uc3VtZShzZWxmKS5jKCk7XG5cdFx0fTtcblx0XHRcblx0XHQvLyBwIFwiVFVQTEUge3R5cGV9XCJcblx0XHRcblx0XHQvKiBhLGIsYyA9IGFyZ3VtZW50cyAqL1xuXHRcdFxuXHRcdC8vIC0gZGlyZWN0LiBubyBtYXR0ZXIgaWYgbHZhbHVlcyBhcmUgdmFyaWFibGVzIG9yIG5vdC4gTWFrZSBmYWtlIGFyZ3VtZW50cyB1cCB0byB0aGUgc2FtZSBjb3VudCBhcyB0dXBsZVxuXHRcdFxuXHRcdC8qIGEsKmIsYiA9IGFyZ3VtZW50cyAqL1xuXHRcdFxuXHRcdC8vIE5lZWQgdG8gY29udmVydCBhcmd1bWVudHMgdG8gYW4gYXJyYXkuIElGIGFyZ3VtZW50cyBpcyBub3QgcmVmZXJlbmNlZCBhbnl3aGVyZSBlbHNlIGluIHNjb3BlLCBcblx0XHQvLyB3ZSBjYW4gZG8gdGhlIGFzc2lnbm1lbnQgZGlyZWN0bHkgd2hpbGUgcm9sbGluZyB0aHJvdWdoIGFyZ3VtZW50c1xuXHRcdFxuXHRcdC8qIGEsYiA9IGIsYSAqL1xuXHRcdFxuXHRcdC8vIGlkZWFsbHkgd2Ugb25seSBuZWVkIHRvIGNhY2hlIHRoZSBmaXJzdCB2YWx1ZSAob3IgbiAtIDEpLCBhc3NpZ24gZGlyZWN0bHkgd2hlbiBwb3NzaWJsZS5cblx0XHRcblx0XHQvKiBhLGIsYyA9IChtZXRob2QgfCBleHByZXNzaW9uKSAqL1xuXHRcdFxuXHRcdC8vIGNvbnZlcnQgcmVzIGludG8gYXJyYXksIGFzc2lnbiBmcm9tIGFycmF5LiBDYW4gY2FjaGUgdGhlIHZhcmlhYmxlIHdoZW4gYXNzaWduaW5nIGZpcnN0IHZhbHVlXG5cdFx0XG5cdFx0Ly8gRmlyc3Qgd2UgbmVlZCB0byBmaW5kIG91dCB3aGV0aGVyIHdlIGFyZSByZXF1aXJlZCB0byBzdG9yZSB0aGUgcmVzdWx0IGluIGFuIGFycmF5IGJlZm9yZSBhc3NpZ25pbmdcblx0XHQvLyBJZiB0aGlzIG5lZWRzIHRvIGJlIGFuIGV4cHJlc3Npb24gKHJldHVybnM/LCB3ZSBuZWVkIHRvIGZhbGwgYmFjayB0byB0aGUgQ1Mtd2EpXG5cdFx0XG5cdFx0dmFyIGFzdCA9IG5ldyBCbG9jayhbXSk7XG5cdFx0dmFyIGxmdCA9IHNlbGYubGVmdCgpO1xuXHRcdHZhciByZ3QgPSBzZWxmLnJpZ2h0KCk7XG5cdFx0dmFyIHR5cCA9IHNlbGYudHlwZSgpO1xuXHRcdHZhciB2aWEgPSBudWxsO1xuXHRcdFxuXHRcdHZhciBsaSA9IDA7XG5cdFx0dmFyIHJpID0gbGZ0LmNvdW50KCk7XG5cdFx0dmFyIGxsZW4gPSByaTtcblx0XHRcblx0XHRcblx0XHQvLyBpZiBAdmFyc1xuXHRcdC8vIFx0cCBcInR1cGxlIGhhcyB7QHZhcnM6bGVuZ3RofSB2YXJzXCJcblx0XHRcblx0XHQvLyBpZiB3ZSBoYXZlIGEgc3BsYXQgb24gdGhlIGxlZnQgaXQgaXMgbXVjaCBtb3JlIGxpa2VseSB0aGF0IHdlIG5lZWQgdG8gc3RvcmUgcmlnaHRcblx0XHQvLyBpbiBhIHRlbXBvcmFyeSBhcnJheSwgYnV0IGlmIHRoZSByaWdodCBzaWRlIGhhcyBhIGtub3duIGxlbmd0aCwgaXQgc2hvdWxkIHN0aWxsIG5vdCBiZSBuZWVkZWRcblx0XHR2YXIgbHNwbGF0ID0gbGZ0LmZpbHRlcihmdW5jdGlvbih2KSB7IHJldHVybiB2IGluc3RhbmNlb2YgU3BsYXQ7IH0pWzBdO1xuXHRcdFxuXHRcdC8vIGlmIHJpZ2h0IGlzIGFuIGFycmF5IHdpdGhvdXQgYW55IHNwbGF0cyAob3IgaW5uZXIgdHVwbGVzPyksIG5vcm1hbGl6ZSBpdCB0byB0dXBsZVxuXHRcdGlmICgocmd0IGluc3RhbmNlb2YgQXJyKSAmJiAhcmd0LnNwbGF0KCkpIHsgcmd0ID0gbmV3IFR1cGxlKHJndC5ub2RlcygpKSB9O1xuXHRcdHZhciBybGVuID0gcmd0IGluc3RhbmNlb2YgVHVwbGUgPyAocmd0LmNvdW50KCkpIDogKG51bGwpO1xuXHRcdFxuXHRcdC8vIGlmIGFueSB2YWx1ZXMgYXJlIHN0YXRlbWVudHMgd2UgbmVlZCB0byBoYW5kbGUgdGhpcyBiZWZvcmUgY29udGludWluZ1xuXHRcdFxuXHRcdC8qIGEsYixjID0gMTAsMjAsYXJ5ICovXG5cdFx0XG5cdFx0Ly8gaWRlYWxseSB3ZSBvbmx5IG5lZWQgdG8gY2FjaGUgdGhlIGZpcnN0IHZhbHVlIChvciBuIC0gMSksIGFzc2lnbiBkaXJlY3RseSB3aGVuIHBvc3NpYmxlLlxuXHRcdC8vIG9ubHkgaWYgdGhlIHZhcmlhYmxlcyBhcmUgbm90IHByZWRlZmluZWQgb3IgcHJlZGVjbGFyZWQgY2FuIGJlIHdlIGNlcnRhaW4gdGhhdCB3ZSBjYW4gZG8gaXQgd2l0aG91dCBjYWNoaW5nXG5cdFx0Ly8gaWYgcmxlbiAmJiB0eXAgPT0gJ3ZhcicgJiYgIWxzcGxhdFxuXHRcdC8vIFx0IyB0aGlzIGNhbiBiZSBkYW5nZXJvdXMgaW4gZWRnZWNhc2VzIHRoYXQgYXJlIHZlcnkgaGFyZCB0byBkZXRlY3Rcblx0XHQvLyBcdCMgaWYgaXQgYmVjb21lcyBhbiBpc3N1ZSwgZmFsbCBiYWNrIHRvIHNpbXBsZXIgdmVyc2lvbnNcblx0XHQvLyBcdCMgZG9lcyBub3QgZXZlbiBtYXR0ZXIgaWYgdGhlcmUgaXMgYSBzcGxhdD9cblx0XHRcblx0XHQvLyBzcGVjaWFsIGNhc2UgZm9yIGFyZ3VtZW50cyghKVxuXHRcdGlmICghbHNwbGF0ICYmIHJndCA9PSBBUkdVTUVOVFMpIHtcblx0XHRcdFxuXHRcdFx0dmFyIHBhcnMgPSBzZWxmLnNjb3BlX18oKS5wYXJhbXMoKTtcblx0XHRcdC8vIHAgXCJzcGVjaWFsIGNhc2Ugd2l0aCBhcmd1bWVudHMge3BhcnN9XCJcblx0XHRcdC8vIGZvcmNpbmcgdGhlIGFyZ3VtZW50cyB0byBiZSBuYW1lZFxuXHRcdFx0Ly8gcCBcImdvdCBoZXJlPz8/IHtwYXJzfVwiXG5cdFx0XHRsZnQubWFwKGZ1bmN0aW9uKGwsaSkgeyByZXR1cm4gYXN0LnB1c2goT1AoJz0nLGwubm9kZSgpLHBhcnMuYXQoaSx0cnVlKS52aXNpdCgpLnZhcmlhYmxlKCkpKTsgfSk7IC8vIHMucGFyYW1zLmF0KHZhbHVlIC0gMSx5ZXMpXG5cdFx0fSBlbHNlIGlmIChybGVuKSB7XG5cdFx0XHQvLyB3ZSBoYXZlIHNldmVyYWwgaXRlbXMgaW4gdGhlIHJpZ2h0IHBhcnQuIHdoYXQgYWJvdXQgc3BsYXRzIGhlcmU/XG5cdFx0XHRcblx0XHRcdC8vIHByZS1ldmFsdWF0ZSBydmFsdWVzIHRoYXQgbWlnaHQgYmUgcmVmZXJlbmNlIGZyb20gb3RoZXIgYXNzaWdubWVudHNcblx0XHRcdC8vIHdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlIHJpZ2h0c2lkZSB2YWx1ZXMgaGFzIG5vIHNpZGUtZWZmZWN0cy4gQ2F1c2UgaWZcblx0XHRcdC8vIHRoZXkgZG9udCwgd2UgcmVhbGx5IGRvIG5vdCBuZWVkIHRlbXBvcmFyeSB2YXJpYWJsZXMuXG5cdFx0XHRcblx0XHRcdC8vIHNvbWUgb2YgdGhlc2Ugb3B0aW1pemF0aW9ucyBhcmUgcXVpdGUgcGV0dHkgLSBtYWtlcyB0aGluZ3MgbW9yZSBjb21wbGljYXRlZFxuXHRcdFx0Ly8gaW4gdGhlIGNvbXBpbGVyIG9ubHkgdG8gZ2V0IGFyb3VuZCBhZGRpbmcgYSBmZXcgdGVtcC12YXJpYWJsZXMgaGVyZSBhbmQgdGhlcmVcblx0XHRcdFxuXHRcdFx0Ly8gdmFyIGZpcnN0VW5zYWZlID0gMFxuXHRcdFx0Ly8gbGZ0Lm1hcCBkbyB8dixpfFxuXHRcdFx0Ly8gXHRpZiB2IGlzYSBWYXJSZWZlcmVuY2Vcblx0XHRcdC8vIFx0XHRwIFwibGVmdCBzaWRlIHtpfSB7dn0ge3YucmVmbnJ9XCJcblx0XHRcdFxuXHRcdFx0Ly8gcmd0Lm1hcCBkbyB8dixpfFxuXHRcdFx0Ly8gXHRpZiB2Lmhhc1NpZGVFZmZlY3RzXG5cdFx0XHQvLyBcdFx0IyByZXR1cm4gaWYgaSA9PSAwIG9yICF2Lmhhc1NpZGVFZmZlY3RzXG5cdFx0XHQvLyBcdFx0IyByZXR1cm4gaWYgdiBpc2EgTnVtIHx8IHYgaXNhIFN0ciB8fCBpID09IDBcblx0XHRcdC8vIFx0XHQjIHdlIGNvdWxkIGV4cGxpY2l0bHkgY3JlYXRlIGEgdGVtcG9yYXJ5IHZhcmlhYmxlIGFuZCBhZGRpbmcgbm9kZXMgZm9yIGFjY2Vzc2luZyBldGNcblx0XHRcdC8vIFx0XHQjIGJ1dCB0aGUgYnVpbHRpbiBjYWNoaW5nIHNob3VsZCByZWFsbHkgdGFrZSBjYXJlIG9mIHRoaXMgZm9yIHVzXG5cdFx0XHQvLyBcdFx0IyB3ZSBuZWVkIHRvIHJlYWxseSBmb3JjZSB0aGUgY2FjaGluZyB0aG91Z2ggLS0gc2luY2Ugd2UgbmVlZCBhIGNvcHkgb2YgaXQgZXZlbiBpZiBpdCBpcyBhIGxvY2FsXG5cdFx0XHQvLyBcdFx0IyB3ZSBuZWVkIHRvIHByZWRlY2xhcmUgdGhlIHZhcmlhYmxlcyBhdCB0aGUgdG9wIG9mIHNjb3BlIGlmIHRoaXMgZG9lcyBub3QgdGFrZSBjYXJlIG9mIGl0XG5cdFx0XHQvLyBcdFx0XG5cdFx0XHQvLyBcdFx0IyB0aGVzZSBhcmUgdGhlIGRlY2xhcmF0aW9ucyAtLSB3ZSBuZWVkIHRvIGFkZCB0aGVtIHNvbWV3aGVyZSBzbWFydFxuXHRcdFx0Ly8gXHRcdEB0ZW1wb3JhcnkucHVzaCh2KSAjIG5lZWQgYSBnZW5lcmFsaXplZCB3YXkgdG8gZG8gdGhpcyB0eXBlIG9mIHRoaW5nXG5cdFx0XHQvLyBcdFx0YXN0LnB1c2godi5jYWNoZShmb3JjZTogeWVzLCB0eXBlOiAnc3dhcCcsIGRlY2xhcmVkOiB0eXAgPT0gJ3ZhcicpKVxuXHRcdFx0Ly8gXHRcdCMgdGhleSBkbyBuZWVkIHRvIGJlIGRlY2xhcmVkLCBubz9cblx0XHRcdFxuXHRcdFx0Ly8gbm93IHdlIGNhbiBmcmVlIHRoZSBjYWNoZWQgdmFyaWFibGVzXG5cdFx0XHQvLyBhc3QubWFwIGRvIHxufCBuLmRlY2FjaGVcblx0XHRcdFxuXHRcdFx0dmFyIHByZSA9IFtdO1xuXHRcdFx0dmFyIHJlc3QgPSBbXTtcblx0XHRcdFxuXHRcdFx0dmFyIHBhaXJzID0gbGZ0Lm1hcChmdW5jdGlvbihsLGkpIHtcblx0XHRcdFx0dmFyIHYgPSBudWxsO1xuXHRcdFx0XHQvLyBkZXRlcm1pbmUgaWYgdGhpcyBuZWVkcyB0byBiZSBwcmVjYWNoZWQ/XG5cdFx0XHRcdC8vIGlmIGwgaXNhIFZhclJlZmVyZW5jZVxuXHRcdFx0XHQvLyBcdCMgdGhpcyBpcyB0aGUgZmlyc3QgdGltZSB0aGUgdmFyaWFibGUgaXMgcmVmZXJlbmNlZFxuXHRcdFx0XHQvLyBcdCMgc2hvdWxkIGFsc28gY291bnQgZXZlbiBpZiBpdCBpcyBwcmVkZWNsYXJlZCBhdCB0aGUgdG9wXG5cdFx0XHRcdC8vIFx0aWYgbC5yZWZuciA9PSAwXG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAobCA9PSBsc3BsYXQpIHtcblx0XHRcdFx0XHR2ID0gbmV3IEFyZ0xpc3QoW10pO1xuXHRcdFx0XHRcdHZhciB0byA9IChybGVuIC0gKHJpIC0gaSkpO1xuXHRcdFx0XHRcdC8vIHAgXCJhc3Npbmcgc3BsYXQgYXQgaW5kZXgge2l9IHRvIHNsaWNlIHtsaX0gLSB7dG99XCIuY3lhblxuXHRcdFx0XHRcdHdoaWxlIChsaSA8PSB0byl7XG5cdFx0XHRcdFx0XHR2LnB1c2gocmd0LmluZGV4KGxpKyspKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdHYgPSBuZXcgQXJyKHYpO1xuXHRcdFx0XHRcdC8vIGFzdC5wdXNoIE9QKCc9JyxsLm5vZGUsQXJyLm5ldyh2KSlcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2ID0gcmd0LmluZGV4KGxpKyspO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4gW2wubm9kZSgpLHZdO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gaWYgbCBpc2EgVmFyUmVmZXJlbmNlICYmIGwucmVmbnIgXG5cdFx0XHR9KTtcblx0XHRcdHZhciBjbGVhbiA9IHRydWU7XG5cdFx0XHRcblx0XHRcdHBhaXJzLm1hcChmdW5jdGlvbih2LGkpIHtcblx0XHRcdFx0dmFyIGwgPSB2WzBdO1xuXHRcdFx0XHR2YXIgciA9IHZbMV07XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoY2xlYW4pIHtcblx0XHRcdFx0XHRpZiAoKGwgaW5zdGFuY2VvZiBWYXJSZWZlcmVuY2UpICYmIGwucmVmbnIoKSA9PSAwKSB7XG5cdFx0XHRcdFx0XHQvLyBzdGlsbCBjbGVhblxuXHRcdFx0XHRcdFx0Y2xlYW4gPSB0cnVlO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjbGVhbiA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0Ly8gcCBcIm5vdyBjYWNoZVwiXG5cdFx0XHRcdFx0XHRwYWlycy5zbGljZShpKS5tYXAoZnVuY3Rpb24ocGFydCkge1xuXHRcdFx0XHRcdFx0XHRpZiAocGFydFsxXS5oYXNTaWRlRWZmZWN0cygpKSB7XG5cdFx0XHRcdFx0XHRcdFx0c2VsZi5fdGVtcG9yYXJ5LnB1c2gocGFydFsxXSk7IC8vIG5lZWQgYSBnZW5lcmFsaXplZCB3YXkgdG8gZG8gdGhpcyB0eXBlIG9mIHRoaW5nXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGFzdC5wdXNoKHBhcnRbMV0uY2FjaGUoe2ZvcmNlOiB0cnVlLHBvb2w6ICdzd2FwJyxkZWNsYXJlZDogdHlwID09ICd2YXInfSkpO1xuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHQvLyBwIFwiZnJvbSB7aX0gLSBjYWNoZSBhbGwgcmVtYWluaW5nIHdpdGggc2lkZS1lZmZlY3RzXCJcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gaWYgdGhlIHByZXZpb3VzIHZhbHVlIGluIGFzdCBpcyBhIHJlZmVyZW5jZSB0byBvdXIgdmFsdWUgLSB0aGUgY2FjaGluZyB3YXMgbm90IG5lZWRlZFxuXHRcdFx0XHRpZiAoYXN0Lmxhc3QoKSA9PSByKSB7XG5cdFx0XHRcdFx0ci5kZWNhY2hlKCk7XG5cdFx0XHRcdFx0Ly8gcCBcIndhcyBjYWNoZWQgLSBub3QgbmVlZGVkXCJcblx0XHRcdFx0XHQvLyBzaW1wbGUgYXNzaWduXG5cdFx0XHRcdFx0cmV0dXJuIGFzdC5yZXBsYWNlKHIsT1AoJz0nLGwscikpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBhc3QucHVzaChPUCgnPScsbCxyKSk7XG5cdFx0XHRcdH07XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0Ly8gV0FSTiBGSVhNRSBJcyB0aGVyZSBub3QgYW4gaXNzdWUgd2l0aCBWYXJCbG9jayB2cyBub3QgaGVyZT9cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gdGhpcyBpcyB3aGVyZSB3ZSBuZWVkIHRvIGNhY2hlIHRoZSByaWdodCBzaWRlIGJlZm9yZSBhc3NpZ25pbmdcblx0XHRcdC8vIGlmIHRoZSByaWdodCBzaWRlIGlzIGEgZm9yIGxvb3AsIHdlIENPVUxEIHRyeSB0byBiZSBleHRyYSBjbGV2ZXIsIGJ1dFxuXHRcdFx0Ly8gZm9yIG5vdyBpdCBpcyBub3Qgd29ydGggdGhlIGFkZGVkIGNvbXBpbGVyIGNvbXBsZXhpdHlcblx0XHRcdFxuXHRcdFx0Ly8gaXRlci5jYWNoZShmb3JjZTogeWVzLCB0eXBlOiAnaXRlcicpXG5cdFx0XHR2YXIgdG9wID0gbmV3IFZhckJsb2NrKCk7XG5cdFx0XHR2YXIgaXRlciA9IHNlbGYudXRpbCgpLml0ZXJhYmxlKHJndCx0cnVlKTtcblx0XHRcdC8vIGNvdWxkIHNldCB0aGUgdmFycyBpbnNpZGUgLS0gbW9zdCBsaWtlbHlcblx0XHRcdGFzdC5wdXNoKHRvcCk7XG5cdFx0XHR0b3AucHVzaChpdGVyKTtcblx0XHRcdFxuXHRcdFx0aWYgKGxzcGxhdCkge1xuXHRcdFx0XHR2YXIgbGVuID0gc2VsZi51dGlsKCkubGVuKGl0ZXIsdHJ1ZSk7XG5cdFx0XHRcdHZhciBpZHggPSBzZWxmLnV0aWwoKS5jb3VudGVyKDAsdHJ1ZSk7XG5cdFx0XHRcdC8vIGNhY2hlIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5XG5cdFx0XHRcdHRvcC5wdXNoKGxlbik7IC8vIHByZWFzc2lnbiB0aGUgbGVuZ3RoXG5cdFx0XHRcdC8vIGNhY2hlIGNvdW50ZXIgdG8gbG9vcCB0aHJvdWdoXG5cdFx0XHRcdHRvcC5wdXNoKGlkeCk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHQvLyBvbmx5IGlmIHRoZSBibG9jayBpcyB2YXJpYWJsZSBiYXNlZCwgbm8/XG5cdFx0XHQvLyBhc3QucHVzaChibGsgPSBWYXJCbG9jay5uZXcpXG5cdFx0XHQvLyBibGsgPSBudWxsXG5cdFx0XHRcblx0XHRcdHZhciBibGt0eXBlID0gdHlwID09ICd2YXInID8gKFZhckJsb2NrKSA6IChCbG9jayk7XG5cdFx0XHR2YXIgYmxrID0gbmV3IGJsa3R5cGUoW10pO1xuXHRcdFx0Ly8gYmxrID0gdG9wIGlmIHR5cCA9PSAndmFyJ1xuXHRcdFx0YXN0LnB1c2goYmxrKTtcblx0XHRcdFxuXHRcdFx0Ly8gaWYgdGhlIGx2YWxzIGFyZSBub3QgdmFyaWFibGVzIC0gd2UgbmVlZCB0byBwcmVhc3NpZ25cblx0XHRcdC8vIGNhbiBhbHNvIHVzZSBzbGljZSBoZXJlIGZvciBzaW1wbGljaXR5LCBidXQgdHJ5IHdpdGggd2hpbGUgbm93XHRcdFx0XG5cdFx0XHRsZnQubWFwKGZ1bmN0aW9uKGwsaSkge1xuXHRcdFx0XHRpZiAobCA9PSBsc3BsYXQpIHtcblx0XHRcdFx0XHR2YXIgbHZhciA9IGwubm9kZSgpO1xuXHRcdFx0XHRcdHZhciByZW0gPSBsbGVuIC0gaSAtIDE7IC8vIHJlbWFpbmluZyBhZnRlciBzcGxhdFxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmICh0eXAgIT0gJ3ZhcicpIHtcblx0XHRcdFx0XHRcdHZhciBhcnIgPSBzZWxmLnV0aWwoKS5hcnJheShPUCgnLScsbGVuLG51bV9fKGkgKyByZW0pKSx0cnVlKTtcblx0XHRcdFx0XHRcdHRvcC5wdXNoKGFycik7XG5cdFx0XHRcdFx0XHRsdmFyID0gYXJyLmNhY2hldmFyKCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmICghYmxrKSB7IGFzdC5wdXNoKGJsayA9IG5ldyBibGt0eXBlKCkpIH07XG5cdFx0XHRcdFx0XHRhcnIgPSBzZWxmLnV0aWwoKS5hcnJheShPUCgnLScsbGVuLG51bV9fKGkgKyByZW0pKSk7XG5cdFx0XHRcdFx0XHRibGsucHVzaChPUCgnPScsbHZhcixhcnIpKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIGlmICFsdmFyOnZhcmlhYmxlIHx8ICFsdmFyLnZhcmlhYmxlICMgbHZhciA9IFxuXHRcdFx0XHRcdC8vIFx0dG9wLnB1c2goKVxuXHRcdFx0XHRcdC8vXHRwIFwiaGFzIHZhcmlhYmxlIC0gbm8gbmVlZCB0byBjcmVhdGUgYSB0ZW1wXCJcblx0XHRcdFx0XHQvLyBibGsucHVzaChPUCgnPScsbHZhcixBcnIubmV3KFtdKSkpICMgZG9udCBwcmVjYWxjdWxhdGUgc2l6ZSBub3dcblx0XHRcdFx0XHQvLyBtYXggPSB0byA9IChybGVuIC0gKGxsZW4gLSBpKSlcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRcblx0XHRcdFx0XHR2YXIgdGVzdCA9IHJlbSA/IChPUCgnLScsbGVuLHJlbSkpIDogKGxlbik7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0dmFyIHNldCA9IE9QKCc9JyxPUCgnLicsbHZhcixPUCgnLScsaWR4LG51bV9fKGkpKSksXG5cdFx0XHRcdFx0T1AoJy4nLGl0ZXIsT1AoJysrJyxpZHgpKSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0YXN0LnB1c2goV0hJTEUoT1AoJzwnLGlkeCx0ZXN0KSxzZXQpKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAodHlwICE9ICd2YXInKSB7XG5cdFx0XHRcdFx0XHRhc3QucHVzaChibGsgPSBuZXcgQmxvY2soKSk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gYmxrLnB1c2goT1AoJz0nLGwubm9kZSgpLGx2YXIpKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGJsayA9IG51bGw7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBub3QgaWYgc3BsYXQgd2FzIGxhc3Q/XG5cdFx0XHRcdFx0Ly8gYXN0LnB1c2goYmxrID0gVmFyQmxvY2submV3KVxuXHRcdFx0XHR9IGVsc2UgaWYgKGxzcGxhdCkge1xuXHRcdFx0XHRcdGlmICghYmxrKSB7IGFzdC5wdXNoKGJsayA9IG5ldyBibGt0eXBlKCkpIH07XG5cdFx0XHRcdFx0Ly8gd2UgY291bGQgY2FjaGUgdGhlIHJhdyBjb2RlIG9mIHRoaXMgbm9kZSBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlXG5cdFx0XHRcdFx0cmV0dXJuIGJsay5wdXNoKE9QKCc9JyxsLE9QKCcuJyxpdGVyLE9QKCcrKycsaWR4KSkpKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoIWJsaykgeyBhc3QucHVzaChibGsgPSBuZXcgYmxrdHlwZSgpKSB9O1xuXHRcdFx0XHRcdHJldHVybiBibGsucHVzaChPUCgnPScsbCxPUCgnLicsaXRlcixudW1fXyhpKSkpKTtcblx0XHRcdFx0fTtcblx0XHRcdH0pO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gaWYgd2UgYXJlIGluIGFuIGV4cHJlc3Npb24gd2UgcmVhbGx5IG5lZWQgdG8gXG5cdFx0aWYgKG8uaXNFeHByZXNzaW9uKCkgJiYgc2VsZi5fdmFycykge1xuXHRcdFx0Ly8gcCBcInR1cGxlIGlzIGV4cHJlc3Npb25cIiAjIHZhcmlhYmxlcyBNVVNUIGJlIGF1dG9kZWNsYXJlZCBvdXRzaWRlIG9mIHRoZSBleHByZXNzaW9uXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQoc2VsZi5fdmFycyksIGxlbl8gPSBhcnkubGVuZ3RoOyBpIDwgbGVuXzsgaSsrKSB7XG5cdFx0XHRcdGFyeVtpXS52YXJpYWJsZSgpLmF1dG9kZWNsYXJlKCk7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSBpZiAoc2VsZi5fdmFycykge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHNlbGYuX3ZhcnMpLCBsZW5fID0gYXJ5Lmxlbmd0aDsgaSA8IGxlbl87IGkrKykge1xuXHRcdFx0XHQvLyBwIFwicHJlZGVjbGFyZSB2YXJpYWJsZSBiZWZvcmUgY29tcGlsYXRpb25cIlxuXHRcdFx0XHRhcnlbaV0udmFyaWFibGUoKS5wcmVkZWNsYXJlZCgpO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIGlzIHRoZXJlIGFueSByZWFzb24gdG8gbWFrZSBpdCBpbnRvIGFuIGV4cHJlc3Npb24/XG5cdFx0aWYgKGFzdC5pc0V4cHJlc3NhYmxlKCkpIHsgLy8gTk8hXG5cdFx0XHQvLyBwIFwiZXhwcmVzc1wiXG5cdFx0XHQvLyBpZiB0aGlzIGlzIGFuIGV4cHJlc3Npb25cblx0XHRcdHZhciBvdXQgPSBhc3QuYyh7ZXhwcmVzc2lvbjogdHJ1ZX0pO1xuXHRcdFx0aWYgKHR5cCAmJiAhby5pc0V4cHJlc3Npb24oKSkgeyBvdXQgPSAoXCJcIiArIHR5cCArIFwiIFwiICsgb3V0KSB9OyAvLyBub3QgaW4gZXhwcmVzc2lvblxuXHRcdFx0cmV0dXJuIG91dDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0b3V0ID0gYXN0LmMoKTtcblx0XHRcdC8vIGlmIHRoaXMgaXMgYSB2YXJibG9jayBcblx0XHRcdHJldHVybiBvdXQ7XG5cdFx0fTtcblx0fTtcblx0XG5cdFxuXHRUdXBsZUFzc2lnbi5wcm90b3R5cGUuYyA9IGZ1bmN0aW9uIChvKXtcblx0XHR2YXIgb3V0ID0gVHVwbGVBc3NpZ24uX19zdXBlcl9fLmMuY2FsbCh0aGlzLG8pO1xuXHRcdC8vIHRoaXMgaXMgb25seSB1c2VkIGluIHR1cGxlIC0tIGJldHRlciB0byBsZXQgdGhlIHR1cGxlIGhhdiBhIHNlcGFyYXRlICNjXG5cdFx0aWYgKHRoaXMuX3RlbXBvcmFyeSAmJiB0aGlzLl90ZW1wb3JhcnkubGVuZ3RoKSB7XG5cdFx0XHR0aGlzLl90ZW1wb3JhcnkubWFwKGZ1bmN0aW9uKHRlbXApIHsgcmV0dXJuIHRlbXAuZGVjYWNoZSgpOyB9KTtcblx0XHR9O1xuXHRcdHJldHVybiBvdXQ7XG5cdH07XG5cdFxuXHRcblx0XG5cdC8vIElERU5USUZJRVJTXG5cdFxuXHQvLyByZWFsbHkgbmVlZCB0byBjbGVhbiB0aGlzIHVwXG5cdC8vIERyb3AgdGhlIHRva2VuP1xuXHRmdW5jdGlvbiBJZGVudGlmaWVyKHZhbHVlKXtcblx0XHR0aGlzLl92YWx1ZSA9IHRoaXMubG9hZCh2YWx1ZSk7XG5cdFx0dGhpcy5fc3ltYm9sID0gbnVsbDtcblx0XHR0aGlzLl9zZXR0ZXIgPSBudWxsO1xuXHRcdFxuXHRcdGlmICgoXCJcIiArIHZhbHVlKS5pbmRleE9mKFwiP1wiKSA+PSAwKSB7XG5cdFx0XHR0aGlzLl9zYWZlY2hhaW4gPSB0cnVlO1xuXHRcdH07XG5cdFx0Ly8gQHNhZmVjaGFpbiA9IChcIlwiICsgdmFsdWUpLmluZGV4T2YoXCI/XCIpID49IDBcblx0XHR0aGlzO1xuXHR9O1xuXHRcblx0c3ViY2xhc3MkKElkZW50aWZpZXIsTm9kZSk7XG5cdGV4cG9ydHMuSWRlbnRpZmllciA9IElkZW50aWZpZXI7IC8vIGV4cG9ydCBjbGFzcyBcblx0SWRlbnRpZmllci5wcm90b3R5cGUuc2FmZWNoYWluID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9zYWZlY2hhaW47IH1cblx0SWRlbnRpZmllci5wcm90b3R5cGUuc2V0U2FmZWNoYWluID0gZnVuY3Rpb24odil7IHRoaXMuX3NhZmVjaGFpbiA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRJZGVudGlmaWVyLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fdmFsdWU7IH1cblx0SWRlbnRpZmllci5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbih2KXsgdGhpcy5fdmFsdWUgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdElkZW50aWZpZXIucHJvdG90eXBlLnJlZmVyZW5jZXMgPSBmdW5jdGlvbiAodmFyaWFibGUpe1xuXHRcdGlmICh0aGlzLl92YWx1ZSkgeyB0aGlzLl92YWx1ZS5fdmFyaWFibGUgPSB2YXJpYWJsZSB9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SWRlbnRpZmllci5wcm90b3R5cGUuc291cmNlTWFwTWFya2VyID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3ZhbHVlLnNvdXJjZU1hcE1hcmtlcigpO1xuXHR9O1xuXHRcblx0SWRlbnRpZmllci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICh2KXtcblx0XHRyZXR1cm4gKHYgaW5zdGFuY2VvZiBJZGVudGlmaWVyID8gKHYudmFsdWUoKSkgOiAodikpO1xuXHR9O1xuXHRcblx0SWRlbnRpZmllci5wcm90b3R5cGUudHJhdmVyc2UgPSBmdW5jdGlvbiAoKXtcblx0XHQvLyBOT0RFUy5wdXNoKHNlbGYpXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJZGVudGlmaWVyLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICgpe1xuXHRcdFxuXHRcdGlmICh0aGlzLl92YWx1ZSBpbnN0YW5jZW9mIE5vZGUpIHtcblx0XHRcdC8vIGNvbnNvbGUubG9nIFwiSURFTlRJRklFUiBWQUxVRSBJUyBOT0RFXCJcblx0XHRcdHRoaXMuX3ZhbHVlLnRyYXZlcnNlKCk7XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdElkZW50aWZpZXIucHJvdG90eXBlLnJlZ2lvbiA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiBbdGhpcy5fdmFsdWUuX2xvYyx0aGlzLl92YWx1ZS5fbG9jICsgdGhpcy5fdmFsdWUuX2xlbl07XG5cdH07XG5cdFxuXHRJZGVudGlmaWVyLnByb3RvdHlwZS5pc1ZhbGlkSWRlbnRpZmllciA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXHRcblx0SWRlbnRpZmllci5wcm90b3R5cGUuaXNSZXNlcnZlZCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl92YWx1ZS5yZXNlcnZlZCB8fCBSRVNFUlZFRF9URVNULnRlc3QoU3RyaW5nKHRoaXMuX3ZhbHVlKSk7XG5cdH07XG5cdFxuXHRJZGVudGlmaWVyLnByb3RvdHlwZS5zeW1ib2wgPSBmdW5jdGlvbiAoKXtcblx0XHQvLyBjb25zb2xlLmxvZyBcIklkZW50aWZpZXIjc3ltYm9sIHt2YWx1ZX1cIlxuXHRcdHJldHVybiB0aGlzLl9zeW1ib2wgfHwgKHRoaXMuX3N5bWJvbCA9IHN5bV9fKHRoaXMudmFsdWUoKSkpO1xuXHR9O1xuXHRcblx0SWRlbnRpZmllci5wcm90b3R5cGUuc2V0dGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0Ly8gY29uc29sZS5sb2cgXCJJZGVudGlmaWVyI3NldHRlclwiXG5cdFx0dmFyIHRvaztcblx0XHRyZXR1cm4gdGhpcy5fc2V0dGVyIHx8ICh0aGlzLl9zZXR0ZXIgPSAodHJ1ZSkgJiYgKFxuXHRcdFx0dG9rID0gbmV3IFRva2VuKCdJREVOVElGSUVSJyxzeW1fXygnc2V0LScgKyB0aGlzLl92YWx1ZSksdGhpcy5fdmFsdWUuX2xvYyB8fCAtMSksXG5cdFx0XHRuZXcgSWRlbnRpZmllcih0b2spXG5cdFx0XHQvLyBJZGVudGlmaWVyLm5ldyhcInNldC17c3ltYm9sfVwiKVxuXHRcdCkpO1xuXHR9O1xuXHRcblx0SWRlbnRpZmllci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gU3RyaW5nKHRoaXMuX3ZhbHVlKTtcblx0fTtcblx0XG5cdElkZW50aWZpZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG5cdH07XG5cdFxuXHRJZGVudGlmaWVyLnByb3RvdHlwZS5hbGlhcyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiBzeW1fXyh0aGlzLl92YWx1ZSk7XG5cdH07XG5cdFxuXHRJZGVudGlmaWVyLnByb3RvdHlwZS5qcyA9IGZ1bmN0aW9uIChvKXtcblx0XHRyZXR1cm4gdGhpcy5zeW1ib2woKTtcblx0fTtcblx0XG5cdElkZW50aWZpZXIucHJvdG90eXBlLmMgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gJycgKyB0aGlzLnN5bWJvbCgpOyAvLyBtYXJrX18oQHZhbHVlKSArIFxuXHR9O1xuXHRcblx0SWRlbnRpZmllci5wcm90b3R5cGUuZHVtcCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB7bG9jOiB0aGlzLnJlZ2lvbigpfTtcblx0fTtcblx0XG5cdElkZW50aWZpZXIucHJvdG90eXBlLm5hbWVwYXRoID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcblx0fTtcblx0XG5cdGZ1bmN0aW9uIFRhZ0lkKHYpe1xuXHRcdHRoaXMuX3ZhbHVlID0gdiBpbnN0YW5jZW9mIElkZW50aWZpZXIgPyAodi52YWx1ZSgpKSA6ICh2KTtcblx0XHR0aGlzO1xuXHR9O1xuXHRcblx0c3ViY2xhc3MkKFRhZ0lkLElkZW50aWZpZXIpO1xuXHRleHBvcnRzLlRhZ0lkID0gVGFnSWQ7IC8vIGV4cG9ydCBjbGFzcyBcblx0VGFnSWQucHJvdG90eXBlLmMgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gKFwiaWQkKCdcIiArICh0aGlzLnZhbHVlKCkuYygpKSArIFwiJylcIik7XG5cdH07XG5cdFxuXHQvLyBUaGlzIGlzIG5vdCBhbiBpZGVudGlmaWVyIC0gaXQgaXMgcmVhbGx5IGEgc3RyaW5nXG5cdC8vIElzIHRoaXMgbm90IGEgbGl0ZXJhbD9cblx0XG5cdC8vIEZJWE1FIFJlbmFtZSB0byBJdmFyTGl0ZXJhbD8gb3Igc2ltcGx5IExpdGVyYWwgd2l0aCB0eXBlIEl2YXJcblx0ZnVuY3Rpb24gSXZhcih2KXtcblx0XHR0aGlzLl92YWx1ZSA9IHYgaW5zdGFuY2VvZiBJZGVudGlmaWVyID8gKHYudmFsdWUoKSkgOiAodik7XG5cdFx0dGhpcztcblx0fTtcblx0XG5cdHN1YmNsYXNzJChJdmFyLElkZW50aWZpZXIpO1xuXHRleHBvcnRzLkl2YXIgPSBJdmFyOyAvLyBleHBvcnQgY2xhc3MgXG5cdEl2YXIucHJvdG90eXBlLm5hbWUgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gaGVscGVycy5jYW1lbENhc2UodGhpcy5fdmFsdWUpLnJlcGxhY2UoL15ALywnJyk7XG5cdFx0Ly8gdmFsdWUuYy5jYW1lbENhc2UucmVwbGFjZSgvXkAvLCcnKVxuXHR9O1xuXHRcblx0SXZhci5wcm90b3R5cGUuYWxpYXMgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gJ18nICsgdGhpcy5uYW1lKCk7XG5cdH07XG5cdFxuXHQvLyB0aGUgQCBzaG91bGQgcG9zc2libHkgYmUgZ29uZSBmcm9tIHRoZSBzdGFydD9cblx0SXZhci5wcm90b3R5cGUuanMgPSBmdW5jdGlvbiAobyl7XG5cdFx0cmV0dXJuICdfJyArIHRoaXMubmFtZSgpO1xuXHR9O1xuXHRcblx0SXZhci5wcm90b3R5cGUuYyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiAnXycgKyBoZWxwZXJzLmNhbWVsQ2FzZSh0aGlzLl92YWx1ZSkuc2xpY2UoMSk7IC8vIC5yZXBsYWNlKC9eQC8sJycpICMgbWFya19fKEB2YWx1ZSkgKyBcblx0fTtcblx0XG5cdFxuXHRcblx0Ly8gQW1iaWd1b3VzIC0gV2UgbmVlZCB0byBiZSBjb25zaXN0ZW50IGFib3V0IENvbnN0IHZzIENvbnN0QWNjZXNzXG5cdC8vIEJlY29tZXMgbW9yZSBpbXBvcnRhbnQgd2hlbiB3ZSBpbXBsZW1lbnQgdHlwZWluZmVyZW5jZSBhbmQgY29kZS1hbmFseXNpc1xuXHRmdW5jdGlvbiBDb25zdCgpeyByZXR1cm4gSWRlbnRpZmllci5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XG5cdHN1YmNsYXNzJChDb25zdCxJZGVudGlmaWVyKTtcblx0ZXhwb3J0cy5Db25zdCA9IENvbnN0OyAvLyBleHBvcnQgY2xhc3MgXG5cdENvbnN0LnByb3RvdHlwZS5zeW1ib2wgPSBmdW5jdGlvbiAoKXtcblx0XHQvLyBjb25zb2xlLmxvZyBcIklkZW50aWZpZXIjc3ltYm9sIHt2YWx1ZX1cIlxuXHRcdHJldHVybiB0aGlzLl9zeW1ib2wgfHwgKHRoaXMuX3N5bWJvbCA9IHN5bV9fKHRoaXMudmFsdWUoKSkpO1xuXHR9O1xuXHRcblx0Q29uc3QucHJvdG90eXBlLmpzID0gZnVuY3Rpb24gKG8pe1xuXHRcdHJldHVybiB0aGlzLnN5bWJvbCgpO1xuXHR9O1xuXHRcblx0Q29uc3QucHJvdG90eXBlLmMgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gbWFya19fKHRoaXMuX3ZhbHVlKSArIHRoaXMuc3ltYm9sKCk7XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBUYWdUeXBlSWRlbnRpZmllcih2YWx1ZSl7XG5cdFx0dGhpcy5fdmFsdWUgPSB0aGlzLmxvYWQodmFsdWUpO1xuXHRcdHRoaXM7XG5cdH07XG5cdFxuXHRzdWJjbGFzcyQoVGFnVHlwZUlkZW50aWZpZXIsSWRlbnRpZmllcik7XG5cdGV4cG9ydHMuVGFnVHlwZUlkZW50aWZpZXIgPSBUYWdUeXBlSWRlbnRpZmllcjsgLy8gZXhwb3J0IGNsYXNzIFxuXHRUYWdUeXBlSWRlbnRpZmllci5wcm90b3R5cGUubmFtZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fbmFtZTsgfVxuXHRUYWdUeXBlSWRlbnRpZmllci5wcm90b3R5cGUuc2V0TmFtZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9uYW1lID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFRhZ1R5cGVJZGVudGlmaWVyLnByb3RvdHlwZS5ucyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fbnM7IH1cblx0VGFnVHlwZUlkZW50aWZpZXIucHJvdG90eXBlLnNldE5zID0gZnVuY3Rpb24odil7IHRoaXMuX25zID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRUYWdUeXBlSWRlbnRpZmllci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICh2YWwpe1xuXHRcdHRoaXMuX3N0ciA9IChcIlwiICsgdmFsKTtcblx0XHR2YXIgcGFydHMgPSB0aGlzLl9zdHIuc3BsaXQoXCI6XCIpO1xuXHRcdHRoaXMuX3JhdyA9IHZhbDtcblx0XHR0aGlzLl9uYW1lID0gcGFydHMucG9wKCk7XG5cdFx0dGhpcy5fbnMgPSBwYXJ0cy5zaGlmdCgpOyAvLyBpZiBhbnk/XG5cdFx0cmV0dXJuIHRoaXMuX3N0cjtcblx0fTtcblx0XG5cdFRhZ1R5cGVJZGVudGlmaWVyLnByb3RvdHlwZS5qcyA9IGZ1bmN0aW9uIChvKXtcblx0XHRyZXR1cm4gKFwiSW1iYS5UQUdTLlwiICsgdGhpcy5fc3RyLnJlcGxhY2UoXCI6XCIsXCIkXCIpKTtcblx0fTtcblx0XG5cdFRhZ1R5cGVJZGVudGlmaWVyLnByb3RvdHlwZS5jID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuanMoKTtcblx0fTtcblx0XG5cdFRhZ1R5cGVJZGVudGlmaWVyLnByb3RvdHlwZS5mdW5jID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIG5hbWUgPSB0aGlzLl9uYW1lLnJlcGxhY2UoLy0vZywnXycpLnJlcGxhY2UoL1xcIy8sJycpO1xuXHRcdGlmICh0aGlzLl9ucykgeyBuYW1lICs9IChcIiRcIiArICh0aGlzLl9ucy50b0xvd2VyQ2FzZSgpKSkgfTtcblx0XHRyZXR1cm4gbmFtZTtcblx0fTtcblx0XG5cdFRhZ1R5cGVJZGVudGlmaWVyLnByb3RvdHlwZS5zcGF3bmVyID0gZnVuY3Rpb24gKCl7XG5cdFx0aWYgKHRoaXMuX25zKSB7XG5cdFx0XHRyZXR1cm4gKFwiXCIgKyAodGhpcy5fbnMudG9VcHBlckNhc2UoKSkgKyBcIi4kXCIgKyB0aGlzLl9uYW1lLnJlcGxhY2UoLy0vZywnXycpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIChcIiRcIiArIHRoaXMuX25hbWUucmVwbGFjZSgvLS9nLCdfJykpO1xuXHRcdH07XG5cdH07XG5cdFxuXHRUYWdUeXBlSWRlbnRpZmllci5wcm90b3R5cGUuaWQgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgbSA9IHRoaXMuX3N0ci5tYXRjaCgvXFwjKFtcXHdcXC1cXGRcXF9dKylcXGIvKTtcblx0XHRyZXR1cm4gbSA/IChtWzFdKSA6IChudWxsKTtcblx0fTtcblx0XG5cdFxuXHRUYWdUeXBlSWRlbnRpZmllci5wcm90b3R5cGUuZmxhZyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiBcIl9cIiArIHRoaXMubmFtZSgpLnJlcGxhY2UoLy0tL2csJ18nKS50b0xvd2VyQ2FzZSgpO1xuXHR9O1xuXHRcblx0VGFnVHlwZUlkZW50aWZpZXIucHJvdG90eXBlLnNlbCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiAoXCIuXCIgKyB0aGlzLmZsYWcoKSk7IC8vICsgbmFtZS5yZXBsYWNlKC8tL2csJ18nKS50b0xvd2VyQ2FzZVxuXHR9O1xuXHRcblx0VGFnVHlwZUlkZW50aWZpZXIucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLnZhbHVlKCk7XG5cdH07XG5cdFxuXHRcblx0ZnVuY3Rpb24gQXJndmFyKCl7IHJldHVybiBWYWx1ZU5vZGUuYXBwbHkodGhpcyxhcmd1bWVudHMpIH07XG5cdFxuXHRzdWJjbGFzcyQoQXJndmFyLFZhbHVlTm9kZSk7XG5cdGV4cG9ydHMuQXJndmFyID0gQXJndmFyOyAvLyBleHBvcnQgY2xhc3MgXG5cdEFyZ3Zhci5wcm90b3R5cGUuYyA9IGZ1bmN0aW9uICgpe1xuXHRcdC8vIE5FWFQgLS0gZ2xvYmFsLnBhcnNlSW50IG9yIE51bWJlci5wYXJzZUludCAoYmV0dGVyKVxuXHRcdHZhciB2ID0gcGFyc2VJbnQoU3RyaW5nKHRoaXMudmFsdWUoKSkpO1xuXHRcdC8vIEZJWE1FIE5vdCBuZWVkZWQgYW55bW9yZT8gSSB0aGluayB0aGUgbGV4ZXIgaGFuZGxlcyB0aGlzXG5cdFx0aWYgKHYgPT0gMCkgeyByZXR1cm4gXCJhcmd1bWVudHNcIiB9O1xuXHRcdFxuXHRcdHZhciBzID0gdGhpcy5zY29wZV9fKCk7XG5cdFx0Ly8gcGFyYW1zIG5lZWQgdG8gZ28gdXAgdG8gdGhlIGNsb3Nlc3RlIG1ldGhvZC1zY29wZVxuXHRcdHZhciBwYXIgPSBzLnBhcmFtcygpLmF0KHYgLSAxLHRydWUpO1xuXHRcdHJldHVybiAoXCJcIiArIGNfXyhwYXIubmFtZSgpKSk7IC8vIGNcblx0fTtcblx0XG5cdFxuXHQvLyBDQUxMXG5cdFxuXHRmdW5jdGlvbiBDYWxsKGNhbGxlZSxhcmdzLG9wZXhpc3RzKXtcblx0XHR0aGlzLl90cmF2ZXJzZWQgPSBmYWxzZTtcblx0XHR0aGlzLl9leHByZXNzaW9uID0gZmFsc2U7XG5cdFx0dGhpcy5fcGFyZW5zID0gZmFsc2U7XG5cdFx0dGhpcy5fY2FjaGUgPSBudWxsO1xuXHRcdHRoaXMuX3JlY2VpdmVyID0gbnVsbDtcblx0XHR0aGlzLl9vcGV4aXN0cyA9IG9wZXhpc3RzO1xuXHRcdC8vIHNvbWUgYXhpb21zIHRoYXQgc2hhcmUgdGhlIHNhbWUgc3ludGF4IGFzIGNhbGxzIHdpbGwgYmUgcmVkaXJlY3RlZCBmcm9tIGhlcmVcblx0XHRcblx0XHRpZiAoY2FsbGVlIGluc3RhbmNlb2YgVmFyT3JBY2Nlc3MpIHtcblx0XHRcdHZhciBzdHIgPSBjYWxsZWUudmFsdWUoKS5zeW1ib2woKTtcblx0XHRcdC8vIHAgXCJDYWxsIGNhbGxlZSB7Y2FsbGVlfSAtIHtzdHJ9XCJcblx0XHRcdGlmIChzdHIgPT0gJ2V4dGVybicpIHtcblx0XHRcdFx0Ly8gcCBcInJldHVybmluZyBleHRlcm4gaW5zdGVhZCFcIlxuXHRcdFx0XHRjYWxsZWUudmFsdWUoKS52YWx1ZSgpLl90eXBlID0gJ0VYVEVSTic7XG5cdFx0XHRcdHJldHVybiBuZXcgRXh0ZXJuRGVjbGFyYXRpb24oYXJncyk7XG5cdFx0XHR9O1xuXHRcdFx0aWYgKHN0ciA9PSAndGFnJykge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyBcIkVSUk9SIC0gYWNjZXNzIGFyZ3MgYnkgc29tZSBtZXRob2RcIlxuXHRcdFx0XHRyZXR1cm4gbmV3IFRhZ1dyYXBwZXIoYXJncyAmJiBhcmdzLmluZGV4ID8gKGFyZ3MuaW5kZXgoMCkpIDogKGFyZ3NbMF0pKTtcblx0XHRcdH07XG5cdFx0XHRpZiAoc3RyID09ICdleHBvcnQnKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgRXhwb3J0U3RhdGVtZW50KGFyZ3MpO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdHRoaXMuX2NhbGxlZSA9IGNhbGxlZTtcblx0XHR0aGlzLl9hcmdzID0gYXJncyB8fCBuZXcgQXJnTGlzdChbXSk7XG5cdFx0XG5cdFx0aWYgKGFyZ3MgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0dGhpcy5fYXJncyA9IG5ldyBBcmdMaXN0KGFyZ3MpO1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgXCJBUkdVTUVOVFMgSVMgQVJSQVkgLSBlcnJvciB7YXJnc31cIlxuXHRcdH07XG5cdFx0Ly8gcCBcImNhbGwgb3BleGlzdHMge29wZXhpc3RzfVwiXG5cdFx0dGhpcztcblx0fTtcblx0XG5cdHN1YmNsYXNzJChDYWxsLE5vZGUpO1xuXHRleHBvcnRzLkNhbGwgPSBDYWxsOyAvLyBleHBvcnQgY2xhc3MgXG5cdENhbGwucHJvdG90eXBlLmNhbGxlZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fY2FsbGVlOyB9XG5cdENhbGwucHJvdG90eXBlLnNldENhbGxlZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9jYWxsZWUgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0Q2FsbC5wcm90b3R5cGUucmVjZWl2ZXIgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3JlY2VpdmVyOyB9XG5cdENhbGwucHJvdG90eXBlLnNldFJlY2VpdmVyID0gZnVuY3Rpb24odil7IHRoaXMuX3JlY2VpdmVyID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdENhbGwucHJvdG90eXBlLmFyZ3MgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2FyZ3M7IH1cblx0Q2FsbC5wcm90b3R5cGUuc2V0QXJncyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9hcmdzID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdENhbGwucHJvdG90eXBlLmJsb2NrID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9ibG9jazsgfVxuXHRDYWxsLnByb3RvdHlwZS5zZXRCbG9jayA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9ibG9jayA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0Q2FsbC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAoKXtcblx0XHQvLyBjb25zb2xlLmxvZyBcInZpc2l0IGFyZ3Mge2FyZ3N9XCJcblx0XHR0aGlzLmFyZ3MoKS50cmF2ZXJzZSgpO1xuXHRcdHRoaXMuY2FsbGVlKCkudHJhdmVyc2UoKTtcblx0XHRcblx0XHQvLyBpZiB0aGUgY2FsbGVlIGlzIGEgUHJvcGVydHlBY2Nlc3MgLSBiZXR0ZXIgdG8gaW1tZWRpYXRlbHkgY2hhbmdlIGl0XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXMuX2Jsb2NrICYmIHRoaXMuX2Jsb2NrLnRyYXZlcnNlKCk7XG5cdH07XG5cdFxuXHRDYWxsLnByb3RvdHlwZS5hZGRCbG9jayA9IGZ1bmN0aW9uIChibG9jayl7XG5cdFx0dmFyIHBvcyA9IHRoaXMuX2FyZ3MuZmlsdGVyKGZ1bmN0aW9uKG4saSkgeyByZXR1cm4gbiA9PSAnJic7IH0pWzBdOyAvLyBXT1VMRCBCRSBUT0tFTiAtIENBUkVGVUxcblx0XHRwb3MgPyAodGhpcy5hcmdzKCkucmVwbGFjZShwb3MsYmxvY2spKSA6ICh0aGlzLmFyZ3MoKS5wdXNoKGJsb2NrKSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRDYWxsLnByb3RvdHlwZS5yZWNlaXZlciA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9yZWNlaXZlciB8fCAodGhpcy5fcmVjZWl2ZXIgPSAoKHRoaXMuY2FsbGVlKCkgaW5zdGFuY2VvZiBBY2Nlc3MpICYmIHRoaXMuY2FsbGVlKCkubGVmdCgpIHx8IE5VTEwpKTtcblx0fTtcblx0XG5cdC8vIGNoZWNrIGlmIGFsbCBhcmd1bWVudHMgYXJlIGV4cHJlc3Npb25zIC0gb3RoZXJ3aXNlIHdlIGhhdmUgYW4gaXNzdWVcblx0XG5cdENhbGwucHJvdG90eXBlLnNhZmVjaGFpbiA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLmNhbGxlZSgpLnNhZmVjaGFpbigpOyAvLyByZWFsbHk/XG5cdH07XG5cdFxuXHRDYWxsLnByb3RvdHlwZS5qcyA9IGZ1bmN0aW9uIChvKXtcblx0XHR2YXIgb3B0ID0ge2V4cHJlc3Npb246IHRydWV9O1xuXHRcdHZhciByZWMgPSBudWxsO1xuXHRcdC8vIHZhciBhcmdzID0gY29tcGFjdF9fKGFyZ3MpICMgcmVhbGx5P1xuXHRcdHZhciBhcmdzID0gdGhpcy5hcmdzKCk7XG5cdFx0XG5cdFx0Ly8gZHJvcCB0aGlzP1xuXHRcdFxuXHRcdHZhciBzcGxhdCA9IGFyZ3Muc29tZShmdW5jdGlvbih2KSB7IHJldHVybiB2IGluc3RhbmNlb2YgU3BsYXQ7IH0pO1xuXHRcdFxuXHRcdHZhciBvdXQgPSBudWxsO1xuXHRcdHZhciBsZnQgPSBudWxsO1xuXHRcdHZhciByZ3QgPSBudWxsO1xuXHRcdHZhciB3cmFwID0gbnVsbDtcblx0XHRcblx0XHR2YXIgY2FsbGVlID0gdGhpcy5fY2FsbGVlID0gdGhpcy5fY2FsbGVlLm5vZGUoKTsgLy8gZHJvcCB0aGUgdmFyIG9yIGFjY2Vzcz9cblx0XHRcblx0XHQvLyBpZiBjYWxsZWUgaXNhIENhbGwgJiYgY2FsbGVlLnNhZmVjaGFpblxuXHRcdC8vXHR5ZXNcblx0XHRcblx0XHRpZiAoY2FsbGVlIGluc3RhbmNlb2YgQWNjZXNzKSB7XG5cdFx0XHRsZnQgPSBjYWxsZWUubGVmdCgpO1xuXHRcdFx0cmd0ID0gY2FsbGVlLnJpZ2h0KCk7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoKGNhbGxlZSBpbnN0YW5jZW9mIFN1cGVyKSB8fCAoY2FsbGVlIGluc3RhbmNlb2YgU3VwZXJBY2Nlc3MpKSB7XG5cdFx0XHR0aGlzLl9yZWNlaXZlciA9IHRoaXMuc2NvcGVfXygpLmNvbnRleHQoKTtcblx0XHRcdC8vIHJldHVybiBcInN1cGVyY2FsbFwiXG5cdFx0fTtcblx0XHRcblx0XHQvLyBuZXZlciBjYWxsIHRoZSBwcm9wZXJ0eS1hY2Nlc3MgZGlyZWN0bHk/XG5cdFx0aWYgKGNhbGxlZSBpbnN0YW5jZW9mIFByb3BlcnR5QWNjZXNzKSB7IC8vICYmIHJlYyA9IGNhbGxlZS5yZWNlaXZlclxuXHRcdFx0Ly8gcCBcInVud3JhcHBpbmcgcHJvcGVydHktYWNjZXNzIGluIGNhbGxcIlxuXHRcdFx0dGhpcy5fcmVjZWl2ZXIgPSBjYWxsZWUucmVjZWl2ZXIoKTtcblx0XHRcdGNhbGxlZSA9IHRoaXMuX2NhbGxlZSA9IG5ldyBBY2Nlc3MoY2FsbGVlLm9wKCksY2FsbGVlLmxlZnQoKSxjYWxsZWUucmlnaHQoKSk7XG5cdFx0XHQvLyBwIFwiZ290IGhlcmU/IHtjYWxsZWV9XCJcblx0XHRcdC8vIGNvbnNvbGUubG9nIFwidW53cmFwcGluZyB0aGUgcHJvcGVydHlBY2Nlc3NcIlxuXHRcdH07XG5cdFx0XG5cdFx0aWYgKGNhbGxlZS5zYWZlY2hhaW4oKSkge1xuXHRcdFx0Ly8gcCBcImNhbGxlZSBpcyBzYWZlY2hhaW5lZD8hP1wiXG5cdFx0XHQvLyBpZiBsZnQgaXNhIENhbGxcblx0XHRcdC8vIGlmIGxmdCBpc2EgQ2FsbCAjIGNvdWxkIGJlIGEgcHJvcGVydHkgYWNjZXNzIGFzIHdlbGwgLSBpdCBpcyB0aGUgc2FtZT9cblx0XHRcdC8vIGlmIGl0IGlzIGEgbG9jYWwgdmFyIGFjY2VzcyB3ZSBzaW1wbHkgY2hlY2sgaWYgaXQgaXMgYSBmdW5jdGlvbiwgdGhlbiBjYWxsXG5cdFx0XHQvLyBidXQgaXQgc2hvdWxkIGJlIHNhZmVjaGFpbmVkIG91dHNpZGUgYXMgd2VsbD9cblx0XHRcdC8vIGxmdC5jYWNoZSBpZiBsZnRcblx0XHRcdC8vIHRoZSBvdXRlciBzYWZlY2hhaW4gc2hvdWxkIG5vdCBjYWNoZSB0aGUgd2hvbGUgY2FsbCAtIG9ubHkgYXNrIHRvIGNhY2hlXG5cdFx0XHQvLyB0aGUgcmVzdWx0PyAtLSBjaGFpbiBvbnRvXG5cdFx0XHQvLyBwIFwiQ2FsbCBzYWZlY2hhaW4ge2NhbGxlZX0ge2xmdH0ue3JndH1cIlxuXHRcdFx0dmFyIGlzZm4gPSBuZXcgVXRpbC5Jc0Z1bmN0aW9uKFtjYWxsZWVdKTtcblx0XHRcdHdyYXAgPSBbKFwiXCIgKyAoaXNmbi5jKCkpICsgXCIgICYmICBcIiksXCJcIl07XG5cdFx0XHRjYWxsZWUgPSBPUCgnLicsY2FsbGVlLmxlZnQoKSxjYWxsZWUucmlnaHQoKSk7XG5cdFx0XHQvLyBjYWxsZWUgc2hvdWxkIGFscmVhZHkgYmUgY2FjaGVkIG5vdyAtIFxuXHRcdH07XG5cdFx0XG5cdFx0Ly8gc2hvdWxkIGp1c3QgZm9yY2UgZXhwcmVzc2lvbiBmcm9tIHRoZSBzdGFydCwgbm8/XG5cdFx0aWYgKHNwbGF0KSB7XG5cdFx0XHQvLyBpbXBvcnRhbnQgdG8gd3JhcCB0aGUgc2luZ2xlIHZhbHVlIGluIGEgdmFsdWUsIHRvIGtlZXAgaW1wbGljaXQgY2FsbFxuXHRcdFx0Ly8gdGhpcyBpcyBkdWUgdG8gdGhlIHdheSB3ZSBjaGVjayBmb3IgYW4gb3V0ZXIgQ2FsbCB3aXRob3V0IGNoZWNraW5nIGlmXG5cdFx0XHQvLyB3ZSBhcmUgdGhlIHJlY2VpdmVyIChpbiBQcm9wZXJ0eUFjY2VzcykuIFNob3VsZCByYXRoZXIgd3JhcCBpbiBDYWxsQXJndW1lbnRzXG5cdFx0XHR2YXIgcmVjMSA9IHRoaXMucmVjZWl2ZXIoKTtcblx0XHRcdHZhciBhcnkgPSAoYXJncy5jb3VudCgpID09IDEgPyAobmV3IFZhbHVlTm9kZShhcmdzLmZpcnN0KCkudmFsdWUoKSkpIDogKG5ldyBBcnIoYXJncy5saXN0KCkpKSk7XG5cdFx0XHRcblx0XHRcdHJlYzEuY2FjaGUoKTsgLy8gbmVlZCB0byBjYWNoZSB0aGUgY29udGV4dCBhcyBpdCB3aWxsIGJlIHJlZmVyZW5jZWQgaW4gYXBwbHlcblx0XHRcdG91dCA9IChcIlwiICsgY2FsbGVlLmMoe2V4cHJlc3Npb246IHRydWV9KSArIFwiLmFwcGx5KFwiICsgKHJlYzEuYygpKSArIFwiLFwiICsgYXJ5LmMoe2V4cHJlc3Npb246IHRydWV9KSArIFwiKVwiKTtcblx0XHR9IGVsc2UgaWYgKHRoaXMuX3JlY2VpdmVyKSB7XG5cdFx0XHQvLyBxdWljayB3b3JrYXJvdW5kXG5cdFx0XHRpZiAoISgodGhpcy5fcmVjZWl2ZXIgaW5zdGFuY2VvZiBTY29wZUNvbnRleHQpKSkgeyB0aGlzLl9yZWNlaXZlci5jYWNoZSgpIH07XG5cdFx0XHRhcmdzLnVuc2hpZnQodGhpcy5yZWNlaXZlcigpKTtcblx0XHRcdC8vIHNob3VsZCByYXRoZXIgcmV3cml0ZSB0byBhIG5ldyBjYWxsP1xuXHRcdFx0b3V0ID0gKFwiXCIgKyBjYWxsZWUuYyh7ZXhwcmVzc2lvbjogdHJ1ZX0pICsgXCIuY2FsbChcIiArIGFyZ3MuYyh7ZXhwcmVzc2lvbjogdHJ1ZX0pICsgXCIpXCIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRvdXQgPSAoXCJcIiArIGNhbGxlZS5jKHtleHByZXNzaW9uOiB0cnVlfSkgKyBcIihcIiArIGFyZ3MuYyh7ZXhwcmVzc2lvbjogdHJ1ZX0pICsgXCIpXCIpO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKHdyYXApIHtcblx0XHRcdC8vIHdlIHNldCB0aGUgY2FjaGV2YXIgaW5zaWRlXG5cdFx0XHQvLyBwIFwic3BlY2lhbCBjYWNoaW5nIGZvciBjYWxsXCJcblx0XHRcdGlmICh0aGlzLl9jYWNoZSkge1xuXHRcdFx0XHR0aGlzLl9jYWNoZS5tYW51YWwgPSB0cnVlO1xuXHRcdFx0XHRvdXQgPSAoXCIoXCIgKyAodGhpcy5jYWNoZXZhcigpLmMoKSkgKyBcIj1cIiArIG91dCArIFwiKVwiKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdG91dCA9IFt3cmFwWzBdLG91dCx3cmFwWzFdXS5qb2luKFwiXCIpO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIG91dDtcblx0fTtcblx0XG5cdFxuXHRcblx0XG5cdGZ1bmN0aW9uIEltcGxpY2l0Q2FsbCgpeyByZXR1cm4gQ2FsbC5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XG5cdHN1YmNsYXNzJChJbXBsaWNpdENhbGwsQ2FsbCk7XG5cdGV4cG9ydHMuSW1wbGljaXRDYWxsID0gSW1wbGljaXRDYWxsOyAvLyBleHBvcnQgY2xhc3MgXG5cdEltcGxpY2l0Q2FsbC5wcm90b3R5cGUuanMgPSBmdW5jdGlvbiAobyl7XG5cdFx0cmV0dXJuIChcIlwiICsgKHRoaXMuY2FsbGVlKCkuYygpKSArIFwiKClcIik7XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBOZXcoKXsgcmV0dXJuIENhbGwuYXBwbHkodGhpcyxhcmd1bWVudHMpIH07XG5cdFxuXHRzdWJjbGFzcyQoTmV3LENhbGwpO1xuXHRleHBvcnRzLk5ldyA9IE5ldzsgLy8gZXhwb3J0IGNsYXNzIFxuXHROZXcucHJvdG90eXBlLmpzID0gZnVuY3Rpb24gKG8pe1xuXHRcdHZhciB0YXJnZXQgPSB0aGlzLmNhbGxlZSgpO1xuXHRcdFxuXHRcdHdoaWxlICh0YXJnZXQgaW5zdGFuY2VvZiBBY2Nlc3Mpe1xuXHRcdFx0dmFyIGxlZnQgPSB0YXJnZXQubGVmdCgpO1xuXHRcdFx0XG5cdFx0XHRpZiAoKGxlZnQgaW5zdGFuY2VvZiBQcm9wZXJ0eUFjY2VzcykgfHwgKGxlZnQgaW5zdGFuY2VvZiBWYXJPckFjY2VzcykpIHtcblx0XHRcdFx0dGhpcy5jYWxsZWUoKS5fcGFyZW5zID0gdHJ1ZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR0YXJnZXQgPSBsZWZ0O1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIG91dCA9IChcIm5ldyBcIiArICh0aGlzLmNhbGxlZSgpLmMoKSkpO1xuXHRcdGlmICghKChvLnBhcmVudCgpIGluc3RhbmNlb2YgQ2FsbCkpKSB7IG91dCArPSAnKCknIH07XG5cdFx0cmV0dXJuIG91dDtcblx0fTtcblx0XG5cdGZ1bmN0aW9uIFN1cGVyQ2FsbCgpeyByZXR1cm4gQ2FsbC5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XG5cdHN1YmNsYXNzJChTdXBlckNhbGwsQ2FsbCk7XG5cdGV4cG9ydHMuU3VwZXJDYWxsID0gU3VwZXJDYWxsOyAvLyBleHBvcnQgY2xhc3MgXG5cdFN1cGVyQ2FsbC5wcm90b3R5cGUuanMgPSBmdW5jdGlvbiAobyl7XG5cdFx0dmFyIG0gPSBvLm1ldGhvZCgpO1xuXHRcdHRoaXMuc2V0UmVjZWl2ZXIoU0VMRik7XG5cdFx0dGhpcy5zZXRDYWxsZWUoKFwiXCIgKyAobS50YXJnZXQoKS5jKCkpICsgXCIuc3VwZXIkLnByb3RvdHlwZS5cIiArIChtLm5hbWUoKS5jKCkpKSk7XG5cdFx0cmV0dXJuIFN1cGVyQ2FsbC5fX3N1cGVyX18uanMuYXBwbHkodGhpcyxhcmd1bWVudHMpO1xuXHR9O1xuXHRcblx0XG5cdFxuXHRmdW5jdGlvbiBFeHRlcm5EZWNsYXJhdGlvbigpeyByZXR1cm4gTGlzdE5vZGUuYXBwbHkodGhpcyxhcmd1bWVudHMpIH07XG5cdFxuXHRzdWJjbGFzcyQoRXh0ZXJuRGVjbGFyYXRpb24sTGlzdE5vZGUpO1xuXHRleHBvcnRzLkV4dGVybkRlY2xhcmF0aW9uID0gRXh0ZXJuRGVjbGFyYXRpb247IC8vIGV4cG9ydCBjbGFzcyBcblx0RXh0ZXJuRGVjbGFyYXRpb24ucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKCl7XG5cdFx0XG5cdFx0Ly8gcCBcInZpc2l0aW5nIGV4dGVybmRlY2xhcmF0aW9uXCJcblx0XHR0aGlzLnNldE5vZGVzKHRoaXMubWFwKGZ1bmN0aW9uKGl0ZW0pIHsgcmV0dXJuIGl0ZW0ubm9kZSgpOyB9KSk7IC8vIGRyb3AgdmFyIG9yIGFjY2VzcyByZWFsbHlcblx0XHQvLyBvbmx5IGluIGdsb2JhbCBzY29wZT9cblx0XHR2YXIgcm9vdCA9IHRoaXMuc2NvcGVfXygpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJCh0aGlzLm5vZGVzKCkpLCBsZW4gPSBhcnkubGVuZ3RoLCBpdGVtOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGl0ZW0gPSBhcnlbaV07XG5cdFx0XHR2YXIgdmFyaWFibGUgPSByb290LnJlZ2lzdGVyKGl0ZW0uc3ltYm9sKCksaXRlbSx7dHlwZTogJ2dsb2JhbCd9KTtcblx0XHRcdHZhcmlhYmxlLmFkZFJlZmVyZW5jZShpdGVtKTtcblx0XHR9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0RXh0ZXJuRGVjbGFyYXRpb24ucHJvdG90eXBlLmMgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gXCIvLyBleHRlcm5zXCI7XG5cdH07XG5cdFxuXHRcblx0Ly8gRkxPV1xuXHRcblx0ZnVuY3Rpb24gQ29udHJvbEZsb3coKXsgcmV0dXJuIE5vZGUuYXBwbHkodGhpcyxhcmd1bWVudHMpIH07XG5cdFxuXHRzdWJjbGFzcyQoQ29udHJvbEZsb3csTm9kZSk7XG5cdGV4cG9ydHMuQ29udHJvbEZsb3cgPSBDb250cm9sRmxvdzsgLy8gZXhwb3J0IGNsYXNzIFxuXHRcblx0XG5cdFxuXHRcblx0ZnVuY3Rpb24gQ29udHJvbEZsb3dTdGF0ZW1lbnQoKXsgcmV0dXJuIENvbnRyb2xGbG93LmFwcGx5KHRoaXMsYXJndW1lbnRzKSB9O1xuXHRcblx0c3ViY2xhc3MkKENvbnRyb2xGbG93U3RhdGVtZW50LENvbnRyb2xGbG93KTtcblx0ZXhwb3J0cy5Db250cm9sRmxvd1N0YXRlbWVudCA9IENvbnRyb2xGbG93U3RhdGVtZW50OyAvLyBleHBvcnQgY2xhc3MgXG5cdENvbnRyb2xGbG93U3RhdGVtZW50LnByb3RvdHlwZS5pc0V4cHJlc3NhYmxlID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXHRcblx0XG5cdFxuXHRmdW5jdGlvbiBJZihjb25kLGJvZHksbyl7XG5cdFx0aWYobyA9PT0gdW5kZWZpbmVkKSBvID0ge307XG5cdFx0dGhpcy5zZXR1cCgpO1xuXHRcdHRoaXMuX3Rlc3QgPSBjb25kOyAvLyAobzp0eXBlID09ICd1bmxlc3MnID8gVW5hcnlPcC5uZXcoJyEnLGNvbmQsbnVsbCkgOiBjb25kKVxuXHRcdHRoaXMuX2JvZHkgPSBib2R5O1xuXHRcdHRoaXMuX2FsdCA9IG51bGw7XG5cdFx0dGhpcy5fdHlwZSA9IG8udHlwZTtcblx0XHRpZiAodGhpcy5fdHlwZSA9PSAndW5sZXNzJykgdGhpcy5pbnZlcnQoKTtcblx0XHR0aGlzLl9zY29wZSA9IG5ldyBJZlNjb3BlKHRoaXMpO1xuXHRcdHRoaXM7XG5cdH07XG5cdFxuXHRzdWJjbGFzcyQoSWYsQ29udHJvbEZsb3cpO1xuXHRleHBvcnRzLklmID0gSWY7IC8vIGV4cG9ydCBjbGFzcyBcblx0SWYucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3Rlc3Q7IH1cblx0SWYucHJvdG90eXBlLnNldFRlc3QgPSBmdW5jdGlvbih2KXsgdGhpcy5fdGVzdCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRJZi5wcm90b3R5cGUuYm9keSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fYm9keTsgfVxuXHRJZi5wcm90b3R5cGUuc2V0Qm9keSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9ib2R5ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdElmLnByb3RvdHlwZS5hbHQgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2FsdDsgfVxuXHRJZi5wcm90b3R5cGUuc2V0QWx0ID0gZnVuY3Rpb24odil7IHRoaXMuX2FsdCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRJZi5wcm90b3R5cGUuc2NvcGUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3Njb3BlOyB9XG5cdElmLnByb3RvdHlwZS5zZXRTY29wZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9zY29wZSA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0SWYudGVybmFyeSA9IGZ1bmN0aW9uIChjb25kLGJvZHksYWx0KXtcblx0XHQvLyBwcmVmZXIgdG8gY29tcGlsZSBpdCB0aGlzIHdheSBhcyB3ZWxsXG5cdFx0dmFyIG9iaiA9IG5ldyBJZihjb25kLG5ldyBCbG9jayhbYm9keV0pLHt0eXBlOiAnPyd9KTtcblx0XHRvYmouYWRkRWxzZShuZXcgQmxvY2soW2FsdF0pKTtcblx0XHRyZXR1cm4gb2JqO1xuXHR9O1xuXHRcblx0SWYucHJvdG90eXBlLmFkZEVsc2UgPSBmdW5jdGlvbiAoYWRkKXtcblx0XHQvLyBwIFwiYWRkIGVsc2UhXCIsYWRkXG5cdFx0aWYgKHRoaXMuYWx0KCkgJiYgKHRoaXMuYWx0KCkgaW5zdGFuY2VvZiBJZikpIHtcblx0XHRcdC8vIHAgJ2FkZCB0byB0aGUgaW5uZXIgZWxzZSghKScsYWRkXG5cdFx0XHR0aGlzLmFsdCgpLmFkZEVsc2UoYWRkKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5zZXRBbHQoYWRkKTtcblx0XHR9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0XG5cdElmLnByb3RvdHlwZS5pbnZlcnQgPSBmdW5jdGlvbiAoKXtcblx0XHRpZiAodGhpcy5fdGVzdCBpbnN0YW5jZW9mIENvbXBhcmlzb25PcCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3Rlc3QgPSB0aGlzLl90ZXN0LmludmVydCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdGVzdCA9IG5ldyBVbmFyeU9wKCchJyx0aGlzLl90ZXN0LG51bGwpO1xuXHRcdH07XG5cdH07XG5cdFxuXHRJZi5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgYWx0ID0gdGhpcy5hbHQoKTtcblx0XHRcblx0XHRpZiAodGhpcy5fc2NvcGUpIHsgdGhpcy5fc2NvcGUudmlzaXQoKSB9O1xuXHRcdGlmICh0aGlzLnRlc3QoKSkgeyB0aGlzLnRlc3QoKS50cmF2ZXJzZSgpIH07XG5cdFx0aWYgKHRoaXMuYm9keSgpKSB7IHRoaXMuYm9keSgpLnRyYXZlcnNlKCkgfTtcblx0XHRcblx0XHQvLyBzaG91bGQgc2tpcCB0aGUgc2NvcGUgaW4gYWx0LlxuXHRcdGlmIChhbHQpIHtcblx0XHRcdC8vIHAgXCJzY29waW5nIHtTVEFDSy5zY29wZXM6bGVuZ3RofVwiXG5cdFx0XHRTVEFDSy5wb3AodGhpcyk7XG5cdFx0XHRhbHQuX3Njb3BlIHx8IChhbHQuX3Njb3BlID0gbmV3IEJsb2NrU2NvcGUoYWx0KSk7XG5cdFx0XHRhbHQudHJhdmVyc2UoKTtcblx0XHRcdFNUQUNLLnB1c2godGhpcyk7XG5cdFx0fTtcblx0XHRcblx0XHQvLyBmb3JjZSBpdCBhcyBleHByZXNzaW9uP1xuXHRcdGlmICh0aGlzLl90eXBlID09ICc/JyAmJiB0aGlzLmlzRXhwcmVzc2FibGUoKSkgdGhpcy50b0V4cHJlc3Npb24oKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFxuXHRJZi5wcm90b3R5cGUuanMgPSBmdW5jdGlvbiAobyl7XG5cdFx0dmFyIGJvZHkgPSB0aGlzLmJvZHkoKTtcblx0XHQvLyB3b3VsZCBwb3NzaWJseSB3YW50IHRvIGxvb2sgdXAgLyBvdXQgXG5cdFx0dmFyIGJyYWNlID0ge2JyYWNlczogdHJ1ZSxpbmRlbnQ6IHRydWV9O1xuXHRcdFxuXHRcdHZhciBjb25kID0gdGhpcy50ZXN0KCkuYyh7ZXhwcmVzc2lvbjogdHJ1ZX0pOyAvLyB0aGUgY29uZGl0aW9uIGlzIGFsd2F5cyBhbiBleHByZXNzaW9uXG5cdFx0XG5cdFx0aWYgKG8uaXNFeHByZXNzaW9uKCkpIHtcblx0XHRcdHZhciBjb2RlID0gYm9keS5jKCk7IC8vIChicmFjZXM6IHllcylcblx0XHRcdGNvZGUgPSAnKCcgKyBjb2RlICsgJyknOyAvLyBpZiBjb2RlLmluZGV4T2YoJywnKSA+PSAwXG5cdFx0XHQvLyBpcyBleHByZXNzaW9uIVxuXHRcdFx0aWYgKHRoaXMuYWx0KCkpIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgXCJ0eXBlIG9mIHRlcm5hcnkge3Rlc3R9XCJcblx0XHRcdFx0Ly8gYmUgc2FmZSAtIHdyYXAgY29uZGl0aW9uIGFzIHdlbGxcblx0XHRcdFx0Ly8gYXNrIGZvciBwYXJlbnNcblx0XHRcdFx0cmV0dXJuIChcIlwiICsgY29uZCArIFwiID8gXCIgKyBjb2RlICsgXCIgOiAoXCIgKyAodGhpcy5hbHQoKS5jKCkpICsgXCIpXCIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gYWdhaW4gLSB3ZSBuZWVkIGEgYmV0dGVyIHdheSB0byBkZWNpZGUgd2hhdCBuZWVkcyBwYXJlbnNcblx0XHRcdFx0Ly8gbWF5YmUgYmV0dGVyIGlmIHdlIHJld3JpdGUgdGhpcyB0byBhbiBPUCgnJiYnKSwgYW5kIHB1dFxuXHRcdFx0XHQvLyB0aGUgcGFyZW5zIGxvZ2ljIHRoZXJlXG5cdFx0XHRcdC8vIGNvbmQgc2hvdWxkIHBvc3NpYmx5IGhhdmUgcGFyZW5zIC0gYnV0IHdoZXJlIGRvIHdlIGRlY2lkZT9cblx0XHRcdFx0aWYgKHRoaXMuX3RhZ3RyZWUpIHtcblx0XHRcdFx0XHRyZXR1cm4gKFwiKFwiICsgY29uZCArIFwiKSA/IFwiICsgY29kZSArIFwiIDogdm9pZCgwKVwiKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gKFwiKFwiICsgY29uZCArIFwiKSAmJiBcIiArIGNvZGUpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaWYgdGhlcmUgaXMgb25seSBhIHNpbmdsZSBpdGVtIC0gYW5kIGl0IGlzIGFuIGV4cHJlc3Npb24/XG5cdFx0XHRjb2RlID0gbnVsbDtcblx0XHRcdC8vIGlmIGJvZHkuY291bnQgPT0gMSAjIGRvbnQgaW5kZW50IGJ5IG91cnNlbHZlcz9cblx0XHRcdFxuXHRcdFx0aWYgKChib2R5IGluc3RhbmNlb2YgQmxvY2spICYmIGJvZHkuY291bnQoKSA9PSAxICYmICEoYm9keS5maXJzdCgpIGluc3RhbmNlb2YgTG9vcEZsb3dTdGF0ZW1lbnQpKSB7XG5cdFx0XHRcdC8vIHAgXCJib2R5IHRvIGJvZHkgZmlyc3Qge2JvZHkuZmlyc3R9XCJcblx0XHRcdFx0Ym9keSA9IGJvZHkuZmlyc3QoKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8vIGlmIGJvZHkuY291bnQgPT0gMVxuXHRcdFx0Ly9cdHAgXCJvbmUgaXRlbSBvbmx5IVwiXG5cdFx0XHQvL1x0Ym9keSA9IGJvZHkuZmlyc3Rcblx0XHRcdFxuXHRcdFx0Y29kZSA9IGJvZHkuYyh7YnJhY2VzOiB0cnVlfSk7IC8vIChicmFjZXM6IHllcylcblx0XHRcdFxuXHRcdFx0Ly8gZG9uJ3Qgd3JhcCBpZiBpdCBpcyBvbmx5IGEgc2luZ2xlIGV4cHJlc3Npb24/XG5cdFx0XHR2YXIgb3V0ID0gKFwiXCIgKyBtYXJrX18odGhpcy5fdHlwZSkgKyBcImlmIChcIiArIGNvbmQgKyBcIikgXCIpICsgY29kZTsgLy8gJyB7JyArIGNvZGUgKyAnfScgIyAneycgKyBjb2RlICsgJ30nXG5cdFx0XHRpZiAodGhpcy5hbHQoKSkgeyBvdXQgKz0gKFwiIGVsc2UgXCIgKyB0aGlzLmFsdCgpLmModGhpcy5hbHQoKSBpbnN0YW5jZW9mIElmID8gKHt9KSA6IChicmFjZSkpKSB9O1xuXHRcdFx0cmV0dXJuIG91dDtcblx0XHR9O1xuXHR9O1xuXHRcblx0SWYucHJvdG90eXBlLnNvdXJjZU1hcE1hcmtlciA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SWYucHJvdG90eXBlLmNvbnN1bWUgPSBmdW5jdGlvbiAobm9kZSl7XG5cdFx0Ly8gcCAnYXNzaWduaWZ5IGlmPyEnXG5cdFx0Ly8gaWYgaXQgaXMgcG9zc2libGUsIGNvbnZlcnQgaW50byBleHByZXNzaW9uXG5cdFx0aWYgKG5vZGUgaW5zdGFuY2VvZiBUYWdUcmVlKSB7XG5cdFx0XHR0aGlzLl9ib2R5ID0gdGhpcy5fYm9keS5jb25zdW1lKG5vZGUpO1xuXHRcdFx0aWYgKHRoaXMuX2FsdCkgeyB0aGlzLl9hbHQgPSB0aGlzLl9hbHQuY29uc3VtZShub2RlKSB9O1xuXHRcdFx0dGhpcy5fdGFndHJlZSA9IG5vZGU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdC8vIHNwZWNpYWwgY2FzZSBmb3IgSWYgY3JlYXRlZCBmcm9tIGNvbmRpdGlvbmFsIGFzc2lnbiBhcyB3ZWxsP1xuXHRcdC8vIEB0eXBlID09ICc/JyBhbmQgXG5cdFx0Ly8gaWRlYWxseSB3ZSBkb250IHJlYWxseSB3YW50IHRvIG1ha2UgYW55IGV4cHJlc3Npb24gbGlrZSB0aGlzIGJ5IGRlZmF1bHRcblx0XHR2YXIgaXNSZXQgPSAobm9kZSBpbnN0YW5jZW9mIFJldHVybik7XG5cdFx0XG5cdFx0Ly8gbWlnaHQgaGF2ZSBiZWVuIGZvcmNlZCB0byBleHByZXNzaW9uIGFscmVhZHlcblx0XHQvLyBpZiBpdCB3YXMgb3JpZ2luYWxseSBhIHRlcm5hcnkgLSB3aHkgbm90XG5cdFx0aWYgKHRoaXMuX2V4cHJlc3Npb24gfHwgKCghaXNSZXQgfHwgdGhpcy5fdHlwZSA9PSAnPycpICYmIHRoaXMuaXNFeHByZXNzYWJsZSgpKSkge1xuXHRcdFx0dGhpcy50b0V4cHJlc3Npb24oKTsgLy8gbWFyayBhcyBleHByZXNzaW9uKCEpIC0gaXMgdGhpcyBuZWVkZWQ/XG5cdFx0XHRyZXR1cm4gSWYuX19zdXBlcl9fLmNvbnN1bWUuY2FsbCh0aGlzLG5vZGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9ib2R5ID0gdGhpcy5fYm9keS5jb25zdW1lKG5vZGUpO1xuXHRcdFx0aWYgKHRoaXMuX2FsdCkgeyB0aGlzLl9hbHQgPSB0aGlzLl9hbHQuY29uc3VtZShub2RlKSB9O1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRcblx0SWYucHJvdG90eXBlLmlzRXhwcmVzc2FibGUgPSBmdW5jdGlvbiAoKXtcblx0XHQvLyBwcm9jZXNzOnN0ZG91dC53cml0ZSAneCdcblx0XHR2YXIgZXhwID0gdGhpcy5ib2R5KCkuaXNFeHByZXNzYWJsZSgpICYmICghKHRoaXMuYWx0KCkpIHx8IHRoaXMuYWx0KCkuaXNFeHByZXNzYWJsZSgpKTtcblx0XHRyZXR1cm4gZXhwO1xuXHR9O1xuXHRcblx0XG5cdFxuXHRmdW5jdGlvbiBMb29wKG9wdGlvbnMpe1xuXHRcdGlmKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkgb3B0aW9ucyA9IHt9O1xuXHRcdHRoaXMuX3RyYXZlcnNlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHRoaXMuX2JvZHkgPSBudWxsO1xuXHRcdHRoaXM7XG5cdH07XG5cdFxuXHRcblx0c3ViY2xhc3MkKExvb3AsU3RhdGVtZW50KTtcblx0ZXhwb3J0cy5Mb29wID0gTG9vcDsgLy8gZXhwb3J0IGNsYXNzIFxuXHRMb29wLnByb3RvdHlwZS5zY29wZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fc2NvcGU7IH1cblx0TG9vcC5wcm90b3R5cGUuc2V0U2NvcGUgPSBmdW5jdGlvbih2KXsgdGhpcy5fc2NvcGUgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0TG9vcC5wcm90b3R5cGUub3B0aW9ucyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fb3B0aW9uczsgfVxuXHRMb29wLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24odil7IHRoaXMuX29wdGlvbnMgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0TG9vcC5wcm90b3R5cGUuYm9keSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fYm9keTsgfVxuXHRMb29wLnByb3RvdHlwZS5zZXRCb2R5ID0gZnVuY3Rpb24odil7IHRoaXMuX2JvZHkgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0TG9vcC5wcm90b3R5cGUuY2F0Y2hlciA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fY2F0Y2hlcjsgfVxuXHRMb29wLnByb3RvdHlwZS5zZXRDYXRjaGVyID0gZnVuY3Rpb24odil7IHRoaXMuX2NhdGNoZXIgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRMb29wLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAob2JqKXtcblx0XHQvLyBwIFwiY29uZmlndXJlIGZvciFcIlxuXHRcdHRoaXMuX29wdGlvbnMgfHwgKHRoaXMuX29wdGlvbnMgPSB7fSk7XG5cdFx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuXHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChrZXlzKSwgbGVuID0gYXJ5Lmxlbmd0aCwgazsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrID0gYXJ5W2ldO1xuXHRcdFx0dGhpcy5fb3B0aW9uc1trXSA9IG9ialtrXTtcblx0XHR9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0XG5cdExvb3AucHJvdG90eXBlLmFkZEJvZHkgPSBmdW5jdGlvbiAoYm9keSl7XG5cdFx0dGhpcy5zZXRCb2R5KGJsa19fKGJvZHkpKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFxuXHRMb29wLnByb3RvdHlwZS5jID0gZnVuY3Rpb24gKG8pe1xuXHRcdFxuXHRcdHZhciBzID0gdGhpcy5zdGFjaygpO1xuXHRcdHZhciBjdXJyID0gcy5jdXJyZW50KCk7XG5cdFx0Ly8gcCBcIkxvb3AuYyAtIHtpc0V4cHJlc3NhYmxlfSB7c3RhY2t9IHtzdGFjay5pc0V4cHJlc3Npb259XCJcblx0XHQvLyBwIFwic3RhY2sgaXMgZXhwcmVzc2lvbj8ge299IHtpc0V4cHJlc3Npb259XCJcblx0XHRcblx0XHRcblx0XHRcblx0XHRpZiAodGhpcy5zdGFjaygpLmlzRXhwcmVzc2lvbigpIHx8IHRoaXMuaXNFeHByZXNzaW9uKCkpIHtcblx0XHRcdC8vIHAgXCJ0aGUgc3RhY2sgaXMgYW4gZXhwcmVzc2lvbiBmb3IgbG9vcCBub3coISlcIlxuXHRcdFx0Ly8gd2hhdCB0aGUgaW5uZXIgb25lIHNob3VsZCBub3QgYmUgYW4gZXhwcmVzc2lvbiB0aG91Z2g/XG5cdFx0XHQvLyB0aGlzIHdpbGwgcmVzdXQgaW4gYW4gaW5maW5pdGUgbG9vcCwgbm8/IT9cblx0XHRcdHZhciBhc3QgPSBDQUxMKEZOKFtdLFt0aGlzXSksW10pO1xuXHRcdFx0cmV0dXJuIGFzdC5jKG8pO1xuXHRcdH0gZWxzZSBpZiAoKHRoaXMuc3RhY2soKS5jdXJyZW50KCkgaW5zdGFuY2VvZiBCbG9jaykgfHwgKChzLnVwKCkgaW5zdGFuY2VvZiBCbG9jaykgJiYgcy5jdXJyZW50KCkuX2NvbnN1bWVyID09IHRoaXMpKSB7XG5cdFx0XHRcblx0XHRcdC8vIHAgXCJ3aGF0IGlzIHRoZSBjdXJyZW50IHN0YWNrIG9mIGxvb3A/IHtzdGFjay5jdXJyZW50fVwiXG5cdFx0XHRyZXR1cm4gTG9vcC5fX3N1cGVyX18uYy5jYWxsKHRoaXMsbyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHAgXCJTaG91bGQgbmV2ZXIgZ2V0IGhlcmU/IT9cIlxuXHRcdFx0YXN0ID0gQ0FMTChGTihbXSxbdGhpc10pLFtdKTtcblx0XHRcdHJldHVybiBhc3QuYyhvKTtcblx0XHRcdC8vIG5lZWQgdG8gd3JhcCBpbiBmdW5jdGlvblxuXHRcdH07XG5cdH07XG5cdFxuXHRcblx0XG5cdGZ1bmN0aW9uIFdoaWxlKHRlc3Qsb3B0cyl7XG5cdFx0dGhpcy5fdHJhdmVyc2VkID0gZmFsc2U7XG5cdFx0dGhpcy5fdGVzdCA9IHRlc3Q7XG5cdFx0dGhpcy5fb3B0aW9ucyA9IG9wdHMgfHwge307XG5cdFx0dGhpcy5fc2NvcGUgPSBuZXcgV2hpbGVTY29wZSh0aGlzKTtcblx0XHQvLyBzZXQob3B0cykgaWYgb3B0c1xuXHRcdC8vIHAgXCJpbnZlcnQgdGVzdCBmb3Igd2hpbGU/IHtAdGVzdH1cIlxuXHRcdGlmICh0aGlzLm9wdGlvbignaW52ZXJ0JykpIHtcblx0XHRcdC8vIFwiaW52ZXJ0IHRlc3QgZm9yIHdoaWxlIHtAdGVzdH1cIlxuXHRcdFx0dGhpcy5fdGVzdCA9IHRlc3QuaW52ZXJ0KCk7XG5cdFx0fTtcblx0XHQvLyBpbnZlcnQgdGhlIHRlc3Rcblx0fTtcblx0XG5cdFxuXHRzdWJjbGFzcyQoV2hpbGUsTG9vcCk7XG5cdGV4cG9ydHMuV2hpbGUgPSBXaGlsZTsgLy8gZXhwb3J0IGNsYXNzIFxuXHRXaGlsZS5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fdGVzdDsgfVxuXHRXaGlsZS5wcm90b3R5cGUuc2V0VGVzdCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl90ZXN0ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0V2hpbGUucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKCl7XG5cdFx0dGhpcy5zY29wZSgpLnZpc2l0KCk7XG5cdFx0aWYgKHRoaXMudGVzdCgpKSB7IHRoaXMudGVzdCgpLnRyYXZlcnNlKCkgfTtcblx0XHRpZiAodGhpcy5ib2R5KCkpIHsgcmV0dXJuIHRoaXMuYm9keSgpLnRyYXZlcnNlKCkgfTtcblx0fTtcblx0XG5cdFxuXHQvLyBUT0RPIEJVRyAtLSB3aGVuIHdlIGRlY2xhcmUgYSB2YXIgbGlrZTogd2hpbGUgdmFyIHkgPSAuLi5cblx0Ly8gdGhlIHZhcmlhYmxlIHdpbGwgYmUgZGVjbGFyZWQgaW4gdGhlIFdoaWxlU2NvcGUgd2hpY2ggbmV2ZXJcblx0Ly8gZm9yY2UtZGVjbGFyZXMgdGhlIGlubmVyIHZhcmlhYmxlcyBpbiB0aGUgc2NvcGVcblx0XG5cdFdoaWxlLnByb3RvdHlwZS5jb25zdW1lID0gZnVuY3Rpb24gKG5vZGUpe1xuXHRcdC8vIHAgXCJXaGlsZS5jb25zdW1lIHtub2RlfVwiLmN5YW5cblx0XHQvLyBUaGlzIGlzIG5ldmVyIGV4cHJlc3NhYmxlLCBidXQgYXQgc29tZSBwb2ludFxuXHRcdC8vIHdlIG1pZ2h0IHdhbnQgdG8gd3JhcCBpdCBpbiBhIGZ1bmN0aW9uIChsaWtlIENTKVxuXHRcdGlmICh0aGlzLmlzRXhwcmVzc2FibGUoKSkgeyByZXR1cm4gV2hpbGUuX19zdXBlcl9fLmNvbnN1bWUuYXBwbHkodGhpcyxhcmd1bWVudHMpIH07XG5cdFx0XG5cdFx0aWYgKG5vZGUgaW5zdGFuY2VvZiBUYWdUcmVlKSB7XG5cdFx0XHQvLyBXQVJOIHRoaXMgaXMgYSBoYWNrIHRvIGFsbG93IHJlZmVyZW5jZXMgY29taW5nIHRocm91Z2ggdGhlIHdyYXBwaW5nIHNjb3BlIFxuXHRcdFx0Ly8gd2lsbCByZXN1bHQgaW4gdW5uZWVkZWQgc2VsZi1kZWNsYXJhdGlvbnMgYW5kIG90aGVyIG9kZGl0aWVzXG5cdFx0XHR0aGlzLnNjb3BlKCkuY29udGV4dCgpLnJlZmVyZW5jZSgpO1xuXHRcdFx0cmV0dXJuIENBTEwoRk4oW10sW3RoaXNdKSxbXSk7XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgcmV1c2UgPSBmYWxzZTtcblx0XHQvLyBXQVJOIE9wdGltaXphdGlvbiAtIG1pZ2h0IGhhdmUgdW50ZW5kZWQgc2lkZS1lZmZlY3RzXG5cdFx0Ly8gaWYgd2UgYXJlIGFzc2lnbmluZyBkaXJlY3RseSB0byBhIGxvY2FsIHZhcmlhYmxlLCB3ZSBzaW1wbHlcblx0XHQvLyB1c2Ugc2FpZCB2YXJpYWJsZSBmb3IgdGhlIGlubmVyIHJlc1xuXHRcdC8vIGlmIHJldXNlXG5cdFx0Ly8gXHRyZXN2YXIgPSBzY29wZS5kZWNsYXJlKG5vZGUubGVmdC5ub2RlLnZhcmlhYmxlLEFyci5uZXcoW10pLHByb3h5OiB5ZXMpXG5cdFx0Ly8gXHRub2RlID0gbnVsbFxuXHRcdC8vIFx0cCBcImNvbnN1bWUgdmFyaWFibGUgZGVjbGFyYXRvciE/XCIuY3lhblxuXHRcdC8vIGVsc2Vcblx0XHQvLyBkZWNsYXJlIHRoZSB2YXJpYWJsZSB3ZSB3aWxsIHVzZSB0byBzb2FrIHVwIHJlc3VsdHNcblx0XHQvLyBwIFwiQ3JlYXRpbmcgdmFsdWUgdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiBsb29wXCIuY3lhblxuXHRcdC8vIFRPRE8gVXNlIGEgc3BlY2lhbCB2YXJ0eXBlIGZvciB0aGlzP1xuXHRcdHZhciByZXN2YXIgPSB0aGlzLnNjb3BlKCkuZGVjbGFyZSgncmVzJyxuZXcgQXJyKFtdKSx7c3lzdGVtOiB0cnVlfSk7XG5cdFx0Ly8gV0hBVCAtLSBmaXggdGhpcyAtLVxuXHRcdHRoaXMuX2NhdGNoZXIgPSBuZXcgUHVzaEFzc2lnbihcInB1c2hcIixyZXN2YXIsbnVsbCk7IC8vIHRoZSB2YWx1ZSBpcyBub3QgcHJlc2V0ICMgd2hhdFxuXHRcdHRoaXMuYm9keSgpLmNvbnN1bWUodGhpcy5fY2F0Y2hlcik7IC8vIHNob3VsZCBzdGlsbCByZXR1cm4gdGhlIHNhbWUgYm9keVxuXHRcdFxuXHRcdC8vIHNjb3BlIHZhcnMgbXVzdCBub3QgYmUgY29tcGlsZWQgYmVmb3JlIHRoaXMgLS0gdGhpcyBpcyBpbXBvcnRhbnRcblx0XHR2YXIgYXN0ID0gbmV3IEJsb2NrKFt0aGlzLHJlc3Zhci5hY2Nlc3NvcigpXSk7IC8vIHNob3VsZCBiZSB2YXJhY2Nlc3MgaW5zdGVhZD9cblx0XHRyZXR1cm4gYXN0LmNvbnN1bWUobm9kZSk7XG5cdFx0Ly8gTk9URSBIZXJlIHdlIGNhbiBmaW5kIGEgd2F5IHRvIGtub3cgd2hldGVyIG9yIG5vdCB3ZSBldmVuIG5lZWQgdG8gXG5cdFx0Ly8gcmV0dXJuIHRoZSByZXN2YXIuIE9mdGVuIGl0IHdpbGwgbm90IGJlIG5lZWRlZFxuXHRcdC8vIEZJWE1FIHdoYXQgaGFwcGVucyBpZiB0aGVyZSBpcyBubyBub2RlPyE/XG5cdH07XG5cdFxuXHRcblx0V2hpbGUucHJvdG90eXBlLmpzID0gZnVuY3Rpb24gKG8pe1xuXHRcdHZhciBvdXQgPSAoXCJ3aGlsZSAoXCIgKyB0aGlzLnRlc3QoKS5jKHtleHByZXNzaW9uOiB0cnVlfSkgKyBcIilcIikgKyB0aGlzLmJvZHkoKS5jKHticmFjZXM6IHRydWUsaW5kZW50OiB0cnVlfSk7IC8vIC53cmFwXG5cdFx0XG5cdFx0aWYgKHRoaXMuc2NvcGUoKS52YXJzKCkuY291bnQoKSA+IDApIHtcblx0XHRcdC8vIHAgXCJ3aGlsZS1ibG9jayBoYXMgZGVjbGFyZWQgdmFyaWFibGVzKCEpXCJcblx0XHRcdHJldHVybiBbdGhpcy5zY29wZSgpLnZhcnMoKS5jKCksb3V0XTtcblx0XHR9O1xuXHRcdHJldHVybiBvdXQ7XG5cdH07XG5cdFxuXHRcblx0XG5cdC8vIFRoaXMgc2hvdWxkIGRlZmluZSBhbiBvcGVuIHNjb3BlXG5cdC8vIHNob3VsZCByYXRoZXIgXG5cdGZ1bmN0aW9uIEZvcihvKXtcblx0XHRpZihvID09PSB1bmRlZmluZWQpIG8gPSB7fTtcblx0XHR0aGlzLl90cmF2ZXJzZWQgPSBmYWxzZTtcblx0XHR0aGlzLl9vcHRpb25zID0gbztcblx0XHR0aGlzLl9zY29wZSA9IG5ldyBGb3JTY29wZSh0aGlzKTtcblx0XHR0aGlzLl9jYXRjaGVyID0gbnVsbDtcblx0fTtcblx0XG5cdHN1YmNsYXNzJChGb3IsTG9vcCk7XG5cdGV4cG9ydHMuRm9yID0gRm9yOyAvLyBleHBvcnQgY2xhc3MgXG5cdEZvci5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAoKXtcblx0XHR0aGlzLnNjb3BlKCkudmlzaXQoKTtcblx0XHR0aGlzLm9wdGlvbnMoKS5zb3VyY2UudHJhdmVyc2UoKTsgLy8gd2hhdCBhYm91dCBhd2FrZW5pbmcgdGhlIHZhcnMgaGVyZT9cblx0XHR0aGlzLmRlY2xhcmUoKTtcblx0XHQvLyBzaG91bGQgYmUgYWJsZSB0byB0b2dnbGUgd2hldGhlciB0byBrZWVwIHRoZSByZXN1bHRzIGhlcmUgYWxyZWFkeSghKVxuXHRcdFxuXHRcdC8vIGFkZCBndWFyZCB0byBib2R5XG5cdFx0aWYgKHRoaXMub3B0aW9ucygpLmd1YXJkKSB7XG5cdFx0XHR2YXIgb3AgPSBJRih0aGlzLm9wdGlvbnMoKS5ndWFyZC5pbnZlcnQoKSxCbG9jay53cmFwKFtuZXcgQ29udGludWVTdGF0ZW1lbnQoXCJjb250aW51ZVwiKV0pKTtcblx0XHRcdHRoaXMuYm9keSgpLnVuc2hpZnQob3AsQlIpO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXMuYm9keSgpLnRyYXZlcnNlKCk7XG5cdH07XG5cdFxuXHRGb3IucHJvdG90eXBlLmlzQmFyZSA9IGZ1bmN0aW9uIChzcmMpe1xuXHRcdHJldHVybiBzcmMgJiYgc3JjLl92YXJpYWJsZSAmJiBzcmMuX3ZhcmlhYmxlLl9pc0FycmF5O1xuXHR9O1xuXHRcblx0Rm9yLnByb3RvdHlwZS5kZWNsYXJlID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIG8gPSB0aGlzLm9wdGlvbnMoKTtcblx0XHR2YXIgc2NvcGUgPSB0aGlzLnNjb3BlKCk7XG5cdFx0dmFyIHNyYyA9IG8uc291cmNlO1xuXHRcdHZhciB2YXJzID0gby52YXJzID0ge307XG5cdFx0dmFyIG9pID0gby5pbmRleDtcblx0XHRcblx0XHR2YXIgYmFyZSA9IHRoaXMuaXNCYXJlKHNyYyk7XG5cdFx0Ly8gcCBcInNvdXJjZSBpcyBhIHtzcmN9IC0ge2JhcmV9XCJcblx0XHQvLyB2YXIgaSA9IHZhcnM6aW5kZXggPSBvaSA/IHNjb3BlLmRlY2xhcmUob2ksMCkgOiB1dGlsLmNvdW50ZXIoMCx5ZXMpLnByZWRlY2xhcmVcblx0XHRcblx0XHQvLyB3aGF0IGFib3V0IGEgcmFuZ2Ugd2hlcmUgd2UgYWxzbyBpbmNsdWRlIGFuIGluZGV4P1xuXHRcdGlmIChzcmMgaW5zdGFuY2VvZiBSYW5nZSkge1xuXHRcdFx0Ly8gcCBcInJhbmdlIGZvci1sb29wXCJcblx0XHRcdFxuXHRcdFx0Ly8gcmVhbGx5PyBkZWNsYXJlPyBcblx0XHRcdC8vIGFyZSB3ZSBzdXJlPyBfcmVhbGx5Xz9cblx0XHRcdHZhcnMubGVuID0gc2NvcGUuZGVjbGFyZSgnbGVuJyxzcmMucmlnaHQoKSk7IC8vIHV0aWwubGVuKG8seWVzKS5wcmVkZWNsYXJlXG5cdFx0XHQvLyBtYWtlIHRoZSBzY29wZSBiZSB0aGUgZGVjbGFyYXRvclxuXHRcdFx0Ly8gVE9ETyB3b3VsZCBsaWtlIHRvIGJlIGFibGUgdG8gaGF2ZSBjb3VudGVyIGluIHJhbmdlIGFzIHdlbGxcblx0XHRcdHZhcnMuaW5kZXggPSBzY29wZS5yZWdpc3RlcihvLm5hbWUsc2NvcGUse3R5cGU6ICdsZXQnLGRlY2xhcmVkOiB0cnVlfSk7XG5cdFx0XHQvLyBwIFwicmVnaXN0ZXJlZCB7dmFyczppbmRleDpjb25zdHJ1Y3Rvcn1cIlxuXHRcdFx0Ly8gcCBcImluZGV4LXZhciBpcyBkZWNsYXJlb2Q/IT8hIHt2YXJzOmluZGV4LkBkZWNsYXJlZH1cIlxuXHRcdFx0c2NvcGUudmFycygpLnB1c2godmFycy5pbmRleC5hc3NpZ25tZW50KHNyYy5sZWZ0KCkpKTtcblx0XHRcdC8vIHNjb3BlLmRlY2xhcmUob3B0aW9uczpuYW1lLHNyYy5sZWZ0KVxuXHRcdFx0dmFycy52YWx1ZSA9IHZhcnMuaW5kZXg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHZhcnM6dmFsdWUgPSBzY29wZS5kZWNsYXJlKG9wdGlvbnM6bmFtZSxudWxsLGxldDogeWVzKVxuXHRcdFx0Ly8gd2UgYXJlIHVzaW5nIGF1dG9tYXRpYyBjYWNoaW5nIGZhciB0b28gbXVjaCBoZXJlXG5cdFx0XHRcblx0XHRcdC8vIHdlIHNob3VsZCBzaW1wbHkgY2hhbmdlIGhvdyBkZWNsYXJlIHdvcmtzXG5cdFx0XHR2YXIgaSA9IHZhcnMuaW5kZXggPSBvaSA/IChzY29wZS5kZWNsYXJlKG9pLDAse3R5cGU6ICdsZXQnfSkpIDogKHRoaXMudXRpbCgpLmNvdW50ZXIoMCx0cnVlLHNjb3BlKS5wcmVkZWNsYXJlKCkpO1xuXHRcdFx0XG5cdFx0XHR2YXJzLnNvdXJjZSA9IGJhcmUgPyAoc3JjKSA6ICh0aGlzLnV0aWwoKS5pdGVyYWJsZShzcmMsdHJ1ZSkucHJlZGVjbGFyZSgpKTtcblx0XHRcdHZhcnMubGVuID0gdGhpcy51dGlsKCkubGVuKHZhcnMuc291cmNlLHRydWUpLnByZWRlY2xhcmUoKTtcblx0XHRcdFxuXHRcdFx0dmFycy52YWx1ZSA9IHNjb3BlLmRlY2xhcmUoby5uYW1lLG51bGwse3R5cGU6ICdsZXQnfSk7XG5cdFx0XHR2YXJzLnZhbHVlLmFkZFJlZmVyZW5jZShvLm5hbWUpOyAvLyBhZGRpbmcgcmVmZXJlbmNlIVxuXHRcdFx0aWYgKG9pKSB7IGkuYWRkUmVmZXJlbmNlKG9pKSB9O1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRcblx0Rm9yLnByb3RvdHlwZS5jb25zdW1lID0gZnVuY3Rpb24gKG5vZGUpe1xuXHRcdFxuXHRcdHZhciByZWNlaXZlcjtcblx0XHRpZiAodGhpcy5pc0V4cHJlc3NhYmxlKCkpIHtcblx0XHRcdHJldHVybiBGb3IuX19zdXBlcl9fLmNvbnN1bWUuYXBwbHkodGhpcyxhcmd1bWVudHMpO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gb3RoZXIgY2FzZXMgYXMgd2VsbCwgbm8/XG5cdFx0aWYgKG5vZGUgaW5zdGFuY2VvZiBUYWdUcmVlKSB7XG5cdFx0XHR0aGlzLnNjb3BlKCkuY29udGV4dCgpLnJlZmVyZW5jZSgpO1xuXHRcdFx0dmFyIHJlZiA9IG5vZGUucm9vdCgpLnJlZmVyZW5jZSgpO1xuXHRcdFx0bm9kZS5fbG9vcCA9IHRoaXM7XG5cdFx0XHRcblx0XHRcdC8vIFNob3VsZCBub3QgYmUgY29uc3VtZWQgdGhlIHNhbWUgd2F5XG5cdFx0XHR0aGlzLmJvZHkoKS5jb25zdW1lKG5vZGUpO1xuXHRcdFx0bm9kZS5fbG9vcCA9IG51bGw7XG5cdFx0XHR2YXIgZm4gPSBuZXcgTGFtYmRhKFtuZXcgUGFyYW0ocmVmKV0sW3RoaXNdKTtcblx0XHRcdGZuLnNjb3BlKCkud3JhcCh0aGlzLnNjb3BlKCkpO1xuXHRcdFx0Ly8gVE9ETyBTY29wZSBvZiBnZW5lcmF0ZWQgbGFtYmRhIHNob3VsZCBiZSBhZGRlZCBpbnRvIHN0YWNrIGZvclxuXHRcdFx0Ly8gdmFyaWFibGUgbmFtaW5nIC8gcmVzb2x1dGlvblxuXHRcdFx0cmV0dXJuIENBTEwoZm4sW3JlZl0pO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0aWYgKHRoaXMuX3Jlc3Zhcikge1xuXHRcdFx0Ly8gcCBcImFscmVhZHkgaGF2ZSBhIHJlc3ZhciAtLSBjaGFuZ2UgY29uc3VtZT8ge25vZGV9XCJcblx0XHRcdHZhciBhc3QgPSBuZXcgQmxvY2soW3RoaXMsQlIsdGhpcy5fcmVzdmFyLmFjY2Vzc29yKCldKTtcblx0XHRcdGFzdC5jb25zdW1lKG5vZGUpO1xuXHRcdFx0cmV0dXJuIGFzdDtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIGlmIG5vZGUgaXNhIHJldHVybiAtLSBkbyBzb21ldGhpbmcgZWxzZVxuXHRcdFxuXHRcdHZhciByZXN2YXIgPSBudWxsO1xuXHRcdHZhciByZXVzZWFibGUgPSBmYWxzZTsgLy8gbm9kZSBpc2EgQXNzaWduICYmIG5vZGUubGVmdC5ub2RlIGlzYSBMb2NhbFZhckFjY2Vzc1xuXHRcdHZhciBhc3NpZ25lZSA9IG51bGw7XG5cdFx0Ly8gbWlnaHQgb25seSB3b3JrIGZvciBsb2NhbHM/XG5cdFx0aWYgKG5vZGUgaW5zdGFuY2VvZiBBc3NpZ24pIHtcblx0XHRcdC8vIHAgXCJub2RlIGlzYSBhc3NpZ24ge25vZGV9IHtub2RlLmxlZnR9XCJcblx0XHRcdGlmIChyZWNlaXZlciA9IG5vZGUubGVmdCgpKSB7XG5cdFx0XHRcdGlmIChhc3NpZ25lZSA9IHJlY2VpdmVyLl92YXJpYWJsZSkge1xuXHRcdFx0XHRcdC8vIHdlIGNhbiBvbmx5IHB1bGwgdGhlIHZhciByZWZlcmVuY2UgaW50byB0aGUgc2NvcGVcblx0XHRcdFx0XHQvLyBpZiB3ZSBrbm93IHRoYXQgdGhlIHZhcmlhYmxlIGlzIGRlY2xhcmVkIGluIHRoaXMgc2NvcGVcblx0XHRcdFx0XHRyZXVzZWFibGUgPSAocmVjZWl2ZXIgaW5zdGFuY2VvZiBWYXJSZWZlcmVuY2UpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIHAgXCJyZXVzYWJsZT8hPyEge25vZGV9IHtub2RlfVwiXG5cdFx0XG5cdFx0Ly8gV0FSTiBPcHRpbWl6YXRpb24gLSBtaWdodCBoYXZlIHVudGVuZGVkIHNpZGUtZWZmZWN0c1xuXHRcdC8vIGlmIHdlIGFyZSBhc3NpZ25pbmcgZGlyZWN0bHkgdG8gYSBsb2NhbCB2YXJpYWJsZSwgd2Ugc2ltcGx5XG5cdFx0Ly8gdXNlIHNhaWQgdmFyaWFibGUgZm9yIHRoZSBpbm5lciByZXNcblx0XHRpZiAocmV1c2VhYmxlICYmIGFzc2lnbmVlKSB7XG5cdFx0XHQvLyBpbnN0ZWFkIG9mIGRlY2xhcmluZyBpdCBpbiB0aGUgc2NvcGUgLSB3aHkgbm90IGRlY2xhcmUgaXQgb3V0c2lkZT9cblx0XHRcdC8vIGl0IG1pZ2h0IGFscmVhZHkgZXhpc3QgaW4gdGhlIG91dGVyIHNjb3BlIG5vP1xuXHRcdFx0Ly8gcCBcInJldXNlYWJsZSB7YXNzaWduZWV9IHtzY29wZX0ge3Njb3BlLnBhcmVudC5sb29rdXAoYXNzaWduZWUpfVwiXG5cdFx0XHQvLyBhc3NpZ25lZS5yZXNvbHZlXG5cdFx0XHQvLyBzaG91bGQgcHJvYmFibHkgaW5zdGVhZCBhbHRlciB0aGUgYXNzaWduLW5vZGUgdG8gc2V0IHZhbHVlIHRvIGEgYmxhbmsgYXJyYXlcblx0XHRcdC8vIHJlc3ZhciA9IHNjb3BlLnBhcmVudC5kZWNsYXJlKGFzc2lnbmVlLEFyci5uZXcoW10pLHByb3h5OiB5ZXMscG9zOiAwKVxuXHRcdFx0XG5cdFx0XHQvLyB0aGlzIHZhcmlhYmxlIHNob3VsZCByZWFsbHkgbm90IGJlIHJlZGVjbGFyZWQgaW5zaWRlIGhlcmUgYXQgYWxsXG5cdFx0XHRhc3NpZ25lZS5yZXNvbHZlKCk7XG5cdFx0XHQvLyByZXN2YXIgPSBAcmVzdmFyID0gc2NvcGUuZGVjbGFyZShhc3NpZ25lZSxBcnIubmV3KFtdKSxwcm94eTogeWVzKVxuXHRcdFx0XG5cdFx0XHQvLyBkb250IGRlY2xhcmUgaXQgLSBzaW1wbHkgcHVzaCBhbiBhc3NpZ24gaW50byB0aGUgdmFyZGVjbCBvZiBzY29wZVxuXHRcdFx0dGhpcy5zY29wZSgpLnZhcnMoKS51bnNoaWZ0KE9QKCc9Jyxhc3NpZ25lZSxuZXcgQXJyKFtdKSkpO1xuXHRcdFx0cmVzdmFyID0gdGhpcy5fcmVzdmFyID0gYXNzaWduZWU7XG5cdFx0XHRcblx0XHRcdG5vZGUuX2NvbnN1bWVyID0gdGhpcztcblx0XHRcdG5vZGUgPSBudWxsO1xuXHRcdFx0XG5cdFx0XHQvLyBwIFwiY29uc3VtZSB2YXJpYWJsZSBkZWNsYXJhdG9yIT9cIi5jeWFuXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGRlY2xhcmUgdGhlIHZhcmlhYmxlIHdlIHdpbGwgdXNlIHRvIHNvYWsgdXAgcmVzdWx0c1xuXHRcdFx0Ly8gcCBcIkNyZWF0aW5nIHZhbHVlIHRvIHN0b3JlIHRoZSByZXN1bHQgb2YgbG9vcFwiLmN5YW5cblx0XHRcdC8vIHdoYXQgYWJvdXQgYSBwb29sIGhlcmU/XG5cdFx0XHRyZXN2YXIgPSB0aGlzLl9yZXN2YXIgPSB0aGlzLnNjb3BlKCkuZGVjbGFyZSgncmVzJyxuZXcgQXJyKFtdKSx7c3lzdGVtOiB0cnVlfSk7XG5cdFx0fTtcblx0XHRcblx0XHR0aGlzLl9jYXRjaGVyID0gbmV3IFB1c2hBc3NpZ24oXCJwdXNoXCIscmVzdmFyLG51bGwpOyAvLyB0aGUgdmFsdWUgaXMgbm90IHByZXNldFxuXHRcdHRoaXMuYm9keSgpLmNvbnN1bWUodGhpcy5fY2F0Y2hlcik7IC8vIHNob3VsZCBzdGlsbCByZXR1cm4gdGhlIHNhbWUgYm9keVxuXHRcdFxuXHRcdFxuXHRcdFxuXHRcdGlmIChub2RlKSB7XG5cdFx0XHQvLyBwIFwicmV0dXJuaW5nIG5ldyBhc3Qgd2hlcmUgTG9vcCBpcyBmaXJzdFwiXG5cdFx0XHRhc3QgPSBuZXcgQmxvY2soW3RoaXMsQlIscmVzdmFyLmFjY2Vzc29yKCkuY29uc3VtZShub2RlKV0pO1xuXHRcdFx0cmV0dXJuIGFzdDtcblx0XHR9O1xuXHRcdC8vIHZhciBhc3QgPSBCbG9jay5uZXcoW3NlbGYsQlIscmVzdmFyLmFjY2Vzc29yXSlcblx0XHQvLyBhc3QuY29uc3VtZShub2RlKSBpZiBub2RlXG5cdFx0Ly8gcmV0dXJuIGFzdFxuXHRcdC8vIHAgXCJMb29wIGRpZCBjb25zdW1lIHN1Y2Nlc3NmdWxseVwiXG5cdFx0cmV0dXJuIHRoaXM7XG5cdFx0XG5cdFx0Ly8gdGhpcyBpcyBuZXZlciBhbiBleHByZXNzaW9uIChmb3Igbm93IC0tIGJ1dCBzdGlsbClcblx0XHQvLyByZXR1cm4gYXN0XG5cdH07XG5cdFxuXHRcblx0Rm9yLnByb3RvdHlwZS5qcyA9IGZ1bmN0aW9uIChvKXtcblx0XHR2YXIgdl87XG5cdFx0dmFyIHZhcnMgPSB0aGlzLm9wdGlvbnMoKS52YXJzO1xuXHRcdHZhciBpID0gdmFycy5pbmRleDtcblx0XHR2YXIgdmFsID0gdmFycy52YWx1ZTtcblx0XHR2YXIgY29uZCA9IE9QKCc8JyxpLHZhcnMubGVuKTtcblx0XHR2YXIgc3JjID0gdGhpcy5vcHRpb25zKCkuc291cmNlO1xuXHRcdFxuXHRcdC8vIHAgXCJyZWZlcmVuY2VzIGZvciB2YWx1ZVwiLHZhbC5yZWZlcmVuY2VzOmxlbmd0aFxuXHRcdFxuXHRcdHZhciBmaW5hbCA9IHRoaXMub3B0aW9ucygpLnN0ZXAgPyAoXG5cdFx0XHRPUCgnPScsaSxPUCgnKycsaSx0aGlzLm9wdGlvbnMoKS5zdGVwKSlcblx0XHQpIDogKFxuXHRcdFx0T1AoJysrJyxpKVxuXHRcdCk7XG5cdFx0XG5cdFx0Ly8gaWYgdGhlcmUgYXJlIGZldyByZWZlcmVuY2VzIHRvIHRoZSB2YWx1ZSAtIHdlIGNhbiBkcm9wXG5cdFx0Ly8gdGhlIGFjdHVhbCB2YXJpYWJsZSBhbmQgaW5zdGVhZCBtYWtlIGl0IHByb3h5IHRocm91Z2ggdGhlIGluZGV4XG5cdFx0aWYgKHNyYyBpbnN0YW5jZW9mIFJhbmdlKSB7XG5cdFx0XHRpZiAoc3JjLmluY2x1c2l2ZSgpKSB7IChjb25kLnNldE9wKHZfID0gJzw9Jyksdl8pIH07XG5cdFx0fSBlbHNlIGlmICh2YWwucmVmY291bnQoKSA8IDMgJiYgdmFsLmFzc2lnbm1lbnRzKCkubGVuZ3RoID09IDApIHtcblx0XHRcdC8vIHAgXCJwcm94eSB0aGUgdmFsdWUge3ZhbC5hc3NpZ25tZW50czpsZW5ndGh9XCJcblx0XHRcdC8vIHAgXCJzaG91bGQgcHJveHkgdmFsdWUtdmFyaWFibGUgaW5zdGVhZFwiXG5cdFx0XHR2YWwucHJveHkodmFycy5zb3VyY2UsaSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuYm9keSgpLnVuc2hpZnQoT1AoJz0nLHZhbCxPUCgnLicsdmFycy5zb3VyY2UsaSkpLEJSKTtcblx0XHRcdC8vIGJvZHkudW5zaGlmdChoZWFkKVxuXHRcdFx0Ly8gVE9ETyBjaGVjayBsZW5ndGhzIC0gaW50ZWxsaWdlbnRseSBkZWNpZGUgd2hldGhlciB0byBicmFjZSBhbmQgaW5kZW50XG5cdFx0fTtcblx0XHR2YXIgaGVhZCA9IChcIlwiICsgbWFya19fKHRoaXMub3B0aW9ucygpLmtleXdvcmQpICsgXCJmb3IgKFwiICsgKHRoaXMuc2NvcGUoKS52YXJzKCkuYygpKSArIFwiOyBcIiArIChjb25kLmMoKSkgKyBcIjsgXCIgKyAoZmluYWwuYygpKSArIFwiKSBcIik7XG5cdFx0cmV0dXJuIGhlYWQgKyB0aGlzLmJvZHkoKS5jKHticmFjZXM6IHRydWUsaW5kZW50OiB0cnVlfSk7IC8vIC53cmFwXG5cdH07XG5cdFxuXHRcblx0Rm9yLnByb3RvdHlwZS5oZWFkID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHZhcnMgPSB0aGlzLm9wdGlvbnMoKS52YXJzO1xuXHRcdHJldHVybiBPUCgnPScsdmFycy52YWx1ZSxPUCgnLicsdmFycy5zb3VyY2UsdmFycy5pbmRleCkpO1xuXHR9O1xuXHRcblx0XG5cdFxuXHRmdW5jdGlvbiBGb3JJbigpeyByZXR1cm4gRm9yLmFwcGx5KHRoaXMsYXJndW1lbnRzKSB9O1xuXHRcblx0c3ViY2xhc3MkKEZvckluLEZvcik7XG5cdGV4cG9ydHMuRm9ySW4gPSBGb3JJbjsgLy8gZXhwb3J0IGNsYXNzIFxuXHRcblx0XG5cdFxuXHRcblx0ZnVuY3Rpb24gRm9yT2YoKXsgcmV0dXJuIEZvci5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XG5cdHN1YmNsYXNzJChGb3JPZixGb3IpO1xuXHRleHBvcnRzLkZvck9mID0gRm9yT2Y7IC8vIGV4cG9ydCBjbGFzcyBcblx0Rm9yT2YucHJvdG90eXBlLmRlY2xhcmUgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgbyA9IHRoaXMub3B0aW9ucygpO1xuXHRcdHZhciB2YXJzID0gby52YXJzID0ge307XG5cdFx0XG5cdFx0Ly8gc2VlIGlmIFxuXHRcdFxuXHRcdC8vIHAgXCJGb3JPZiBzb3VyY2UgaXNhIHtvOnNvdXJjZX1cIlxuXHRcdFxuXHRcdC8vIGlmIG86c291cmNlIGlzIGEgdmFyaWFibGUgLS0gcmVmZXIgZGlyZWN0bHkgIyB2YXJpYWJsZT8gaXMgdGhpcyB0aGUgaXNzdWU/XG5cdFx0Ly8gcCBzY29wZS5AdmFybWFwWydvJ10sIHNjb3BlLnBhcmVudC5AdmFybWFwWydvJ11cblx0XHRcblx0XHR2YXIgc3JjID0gdmFycy5zb3VyY2UgPSBvLnNvdXJjZS5fdmFyaWFibGUgfHwgdGhpcy5zY29wZSgpLmRlY2xhcmUoJ28nLG8uc291cmNlLHtzeXN0ZW06IHRydWUsdHlwZTogJ2xldCd9KTtcblx0XHRpZiAoby5pbmRleCkgeyB2YXIgdiA9IHZhcnMudmFsdWUgPSB0aGlzLnNjb3BlKCkuZGVjbGFyZShvLmluZGV4LG51bGwse2xldDogdHJ1ZX0pIH07XG5cdFx0XG5cdFx0Ly8gcCBcIkZvck9mIG86aW5kZXgge286aW5kZXh9IG86bmFtZSB7bzpuYW1lfVwiXG5cdFx0Ly8gaWYgbzppbmRleFxuXHRcdFxuXHRcdC8vIHBvc3NpYmx5IHByb3h5IHRoZSBpbmRleC12YXJpYWJsZT9cblx0XHRcblx0XHRpZiAoby5vd24pIHtcblx0XHRcdC8vIHZhciBpID0gdmFyczppbmRleCA9IHNjb3BlLmRlY2xhcmUoJ2knLDAsc3lzdGVtOiB0cnVlLCB0eXBlOiAnbGV0JykgIyBtYXJrIGFzIGEgY291bnRlcj9cblx0XHRcdHZhciBpID0gdmFycy5pbmRleCA9IHRoaXMudXRpbCgpLmNvdW50ZXIoMCx0cnVlLHRoaXMuc2NvcGUoKSkucHJlZGVjbGFyZSgpO1xuXHRcdFx0Ly8gc3lzdGVtdmFyaWFibGUgLS0gc2hvdWxkIG5vdCByZWFsbHkgYmUgYWRkZWQgdG8gdGhlIG1hcFxuXHRcdFx0dmFyIGtleXMgPSB2YXJzLmtleXMgPSB0aGlzLnNjb3BlKCkuZGVjbGFyZSgna2V5cycsVXRpbC5rZXlzKHNyYy5hY2Nlc3NvcigpKSx7c3lzdGVtOiB0cnVlLHR5cGU6ICdsZXQnfSk7IC8vIHRoZSBvdXRlciBvbmUgc2hvdWxkIHJlc29sdmUgZmlyc3Rcblx0XHRcdHZhciBsID0gdmFycy5sZW4gPSB0aGlzLnNjb3BlKCkuZGVjbGFyZSgnbCcsVXRpbC5sZW4oa2V5cy5hY2Nlc3NvcigpKSx7c3lzdGVtOiB0cnVlLHR5cGU6ICdsZXQnfSk7XG5cdFx0XHR2YXIgayA9IHZhcnMua2V5ID0gdGhpcy5zY29wZSgpLnJlZ2lzdGVyKG8ubmFtZSxvLm5hbWUse3R5cGU6ICdsZXQnfSk7IC8vIHNjb3BlLmRlY2xhcmUobzpuYW1lLG51bGwsc3lzdGVtOiB5ZXMpXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHdlIHNldCB0aGUgdmFyIC0tIHdoeSBldmVuIGRlY2xhcmUgaXRcblx0XHRcdC8vIG5vIG5lZWQgdG8gZGVjbGFyZSAtLSBpdCB3aWxsIGRlY2xhcmUgaXRzZWxmIGluIHRoZSBsb29wIC0gbm8/XG5cdFx0XHRrID0gdmFycy5rZXkgPSB0aGlzLnNjb3BlKCkucmVnaXN0ZXIoby5uYW1lLG8ubmFtZSx7dHlwZTogJ2xldCd9KTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIFRPRE8gdXNlIHV0aWwgLSB3aHkgYWRkIHJlZmVyZW5jZXMgYWxyZWFkeT8gQWggLS0gdGhpcyBpcyBmb3IgdGhlIGhpZ2hsaWdodGluZ1xuXHRcdGlmICh2ICYmIG8uaW5kZXgpIHsgdi5hZGRSZWZlcmVuY2Uoby5pbmRleCkgfTtcblx0XHRpZiAoayAmJiBvLm5hbWUpIHsgay5hZGRSZWZlcmVuY2Uoby5uYW1lKSB9O1xuXHRcdFxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Rm9yT2YucHJvdG90eXBlLmpzID0gZnVuY3Rpb24gKG8pe1xuXHRcdHZhciB2YXJzID0gdGhpcy5vcHRpb25zKCkudmFycztcblx0XHRcblx0XHR2YXIgbyA9IHZhcnMuc291cmNlO1xuXHRcdHZhciBrID0gdmFycy5rZXk7XG5cdFx0dmFyIHYgPSB2YXJzLnZhbHVlO1xuXHRcdHZhciBpID0gdmFycy5pbmRleDtcblx0XHRcblx0XHRcblx0XHRpZiAodikge1xuXHRcdFx0Ly8gc2V0IHZhbHVlIGFzIHByb3h5IG9mIG9iamVjdFtrZXldXG5cdFx0XHQvLyBwb3NzaWJseSBtYWtlIGl0IGEgcmVmPyB3aGF0IGlzIGhhcHBlbmluZz9cblx0XHRcdHYucmVmY291bnQoKSA8IDMgPyAodi5wcm94eShvLGspKSA6ICh0aGlzLmJvZHkoKS51bnNoaWZ0KE9QKCc9Jyx2LE9QKCcuJyxvLGspKSkpO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKHRoaXMub3B0aW9ucygpLm93bikge1xuXHRcdFx0XG5cdFx0XHRpZiAoay5yZWZjb3VudCgpIDwgMykgeyAvLyBzaG91bGQgcHJvYmFibHkgYWRqdXN0IHRoZXNlXG5cdFx0XHRcdGsucHJveHkodmFycy5rZXlzLGkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5ib2R5KCkudW5zaGlmdChPUCgnPScsayxPUCgnLicsdmFycy5rZXlzLGkpKSk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR2YXIgaGVhZCA9IChcIlwiICsgbWFya19fKHRoaXMub3B0aW9ucygpLmtleXdvcmQpICsgXCJmb3IgKFwiICsgKHRoaXMuc2NvcGUoKS52YXJzKCkuYygpKSArIFwiOyBcIiArIChPUCgnPCcsaSx2YXJzLmxlbikuYygpKSArIFwiOyBcIiArIChPUCgnKysnLGkpLmMoKSkgKyBcIilcIik7XG5cdFx0XHRyZXR1cm4gaGVhZCArIHRoaXMuYm9keSgpLmMoe2luZGVudDogdHJ1ZSxicmFjZXM6IHRydWV9KTsgLy8gLndyYXBcblx0XHR9O1xuXHRcdFxuXHRcdHZhciBjb2RlID0gdGhpcy5ib2R5KCkuYyh7YnJhY2VzOiB0cnVlLGluZGVudDogdHJ1ZX0pO1xuXHRcdC8vIGl0IGlzIHJlYWxseSBpbXBvcnRhbnQgdGhhdCB0aGlzIGlzIGEgdHJlYXRlZCBhcyBhIHN0YXRlbWVudFxuXHRcdHJldHVybiB0aGlzLnNjb3BlKCkudmFycygpLmMoKSArIChcIjtcXG5cIiArIG1hcmtfXyh0aGlzLm9wdGlvbnMoKS5rZXl3b3JkKSArIFwiZm9yICh2YXIgXCIgKyAoay5jKCkpICsgXCIgaW4gXCIgKyAoby5jKCkpICsgXCIpXCIpICsgY29kZTtcblx0fTtcblx0XG5cdEZvck9mLnByb3RvdHlwZS5oZWFkID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHYgPSB0aGlzLm9wdGlvbnMoKS52YXJzO1xuXHRcdFxuXHRcdHJldHVybiBbXG5cdFx0XHRPUCgnPScsdi5rZXksT1AoJy4nLHYua2V5cyx2LmluZGV4KSksXG5cdFx0XHQodi52YWx1ZSkgJiYgKE9QKCc9Jyx2LnZhbHVlLE9QKCcuJyx2LnNvdXJjZSx2LmtleSkpKVxuXHRcdF07XG5cdH07XG5cdFxuXHQvLyBOTyBORUVEP1xuXHRmdW5jdGlvbiBCZWdpbihib2R5KXtcblx0XHR0aGlzLl9ub2RlcyA9IGJsa19fKGJvZHkpLm5vZGVzKCk7XG5cdH07XG5cdFxuXHRcblx0c3ViY2xhc3MkKEJlZ2luLEJsb2NrKTtcblx0ZXhwb3J0cy5CZWdpbiA9IEJlZ2luOyAvLyBleHBvcnQgY2xhc3MgXG5cdEJlZ2luLnByb3RvdHlwZS5zaG91bGRQYXJlbnRoZXNpemUgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5pc0V4cHJlc3Npb24oKTtcblx0fTtcblx0XG5cdFxuXHRcblx0ZnVuY3Rpb24gU3dpdGNoKGEsYixjKXtcblx0XHR0aGlzLl90cmF2ZXJzZWQgPSBmYWxzZTtcblx0XHR0aGlzLl9zb3VyY2UgPSBhO1xuXHRcdHRoaXMuX2Nhc2VzID0gYjtcblx0XHR0aGlzLl9mYWxsYmFjayA9IGM7XG5cdH07XG5cdFxuXHRcblx0c3ViY2xhc3MkKFN3aXRjaCxDb250cm9sRmxvd1N0YXRlbWVudCk7XG5cdGV4cG9ydHMuU3dpdGNoID0gU3dpdGNoOyAvLyBleHBvcnQgY2xhc3MgXG5cdFN3aXRjaC5wcm90b3R5cGUuc291cmNlID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9zb3VyY2U7IH1cblx0U3dpdGNoLnByb3RvdHlwZS5zZXRTb3VyY2UgPSBmdW5jdGlvbih2KXsgdGhpcy5fc291cmNlID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFN3aXRjaC5wcm90b3R5cGUuY2FzZXMgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2Nhc2VzOyB9XG5cdFN3aXRjaC5wcm90b3R5cGUuc2V0Q2FzZXMgPSBmdW5jdGlvbih2KXsgdGhpcy5fY2FzZXMgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0U3dpdGNoLnByb3RvdHlwZS5mYWxsYmFjayA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fZmFsbGJhY2s7IH1cblx0U3dpdGNoLnByb3RvdHlwZS5zZXRGYWxsYmFjayA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9mYWxsYmFjayA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdFN3aXRjaC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAoKXtcblx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQodGhpcy5jYXNlcygpKSwgbGVuID0gYXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRhcnlbaV0udHJhdmVyc2UoKTtcblx0XHR9O1xuXHRcdGlmICh0aGlzLmZhbGxiYWNrKCkpIHsgdGhpcy5mYWxsYmFjaygpLnZpc2l0KCkgfTtcblx0XHRpZiAodGhpcy5zb3VyY2UoKSkgeyB0aGlzLnNvdXJjZSgpLnZpc2l0KCkgfTtcblx0XHRyZXR1cm47XG5cdH07XG5cdFxuXHRcblx0U3dpdGNoLnByb3RvdHlwZS5jb25zdW1lID0gZnVuY3Rpb24gKG5vZGUpe1xuXHRcdC8vIFRPRE8gd29yayBpbnNpZGUgdGFncyAobGlrZSBsb29wcylcblx0XHR0aGlzLl9jYXNlcyA9IHRoaXMuX2Nhc2VzLm1hcChmdW5jdGlvbihpdGVtKSB7IHJldHVybiBpdGVtLmNvbnN1bWUobm9kZSk7IH0pO1xuXHRcdGlmICh0aGlzLl9mYWxsYmFjaykgeyB0aGlzLl9mYWxsYmFjayA9IHRoaXMuX2ZhbGxiYWNrLmNvbnN1bWUobm9kZSkgfTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFN3aXRjaC5wcm90b3R5cGUuYyA9IGZ1bmN0aW9uIChvKXtcblx0XHRpZiAodGhpcy5zdGFjaygpLmlzRXhwcmVzc2lvbigpIHx8IHRoaXMuaXNFeHByZXNzaW9uKCkpIHtcblx0XHRcdHZhciBhc3QgPSBDQUxMKEZOKFtdLFt0aGlzXSksW10pO1xuXHRcdFx0cmV0dXJuIGFzdC5jKG8pO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIFN3aXRjaC5fX3N1cGVyX18uYy5jYWxsKHRoaXMsbyk7XG5cdH07XG5cdFxuXHRcblx0U3dpdGNoLnByb3RvdHlwZS5qcyA9IGZ1bmN0aW9uIChvKXtcblx0XHR2YXIgYm9keSA9IFtdO1xuXHRcdFxuXHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJCh0aGlzLmNhc2VzKCkpLCBsZW4gPSBhcnkubGVuZ3RoLCBwYXJ0OyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHBhcnQgPSBhcnlbaV07XG5cdFx0XHRwYXJ0LmF1dG9icmVhaygpO1xuXHRcdFx0Ym9keS5wdXNoKHBhcnQpO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKHRoaXMuZmFsbGJhY2soKSkge1xuXHRcdFx0Ym9keS5wdXNoKFwiZGVmYXVsdDpcXG5cIiArIHRoaXMuZmFsbGJhY2soKS5jKHtpbmRlbnQ6IHRydWV9KSk7XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gKFwic3dpdGNoIChcIiArICh0aGlzLnNvdXJjZSgpLmMoKSkgKyBcIikgXCIpICsgaGVscGVycy5icmFja2V0aXplKGNhcnlfXyhib2R5KS5qb2luKFwiXFxuXCIpLHRydWUpO1xuXHR9O1xuXHRcblx0XG5cdFxuXHRmdW5jdGlvbiBTd2l0Y2hDYXNlKHRlc3QsYm9keSl7XG5cdFx0dGhpcy5fdHJhdmVyc2VkID0gZmFsc2U7XG5cdFx0dGhpcy5fdGVzdCA9IHRlc3Q7XG5cdFx0dGhpcy5fYm9keSA9IGJsa19fKGJvZHkpO1xuXHR9O1xuXHRcblx0c3ViY2xhc3MkKFN3aXRjaENhc2UsQ29udHJvbEZsb3dTdGF0ZW1lbnQpO1xuXHRleHBvcnRzLlN3aXRjaENhc2UgPSBTd2l0Y2hDYXNlOyAvLyBleHBvcnQgY2xhc3MgXG5cdFN3aXRjaENhc2UucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3Rlc3Q7IH1cblx0U3dpdGNoQ2FzZS5wcm90b3R5cGUuc2V0VGVzdCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl90ZXN0ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFN3aXRjaENhc2UucHJvdG90eXBlLmJvZHkgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2JvZHk7IH1cblx0U3dpdGNoQ2FzZS5wcm90b3R5cGUuc2V0Qm9keSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9ib2R5ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0U3dpdGNoQ2FzZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5ib2R5KCkudHJhdmVyc2UoKTtcblx0fTtcblx0XG5cdFxuXHRTd2l0Y2hDYXNlLnByb3RvdHlwZS5jb25zdW1lID0gZnVuY3Rpb24gKG5vZGUpe1xuXHRcdHRoaXMuYm9keSgpLmNvbnN1bWUobm9kZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRcblx0U3dpdGNoQ2FzZS5wcm90b3R5cGUuYXV0b2JyZWFrID0gZnVuY3Rpb24gKCl7XG5cdFx0aWYgKCEoKHRoaXMuYm9keSgpLmxhc3QoKSBpbnN0YW5jZW9mIEJyZWFrU3RhdGVtZW50KSkpIHsgdGhpcy5ib2R5KCkucHVzaChuZXcgQnJlYWtTdGF0ZW1lbnQoKSkgfTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFxuXHRTd2l0Y2hDYXNlLnByb3RvdHlwZS5qcyA9IGZ1bmN0aW9uIChvKXtcblx0XHRpZiAoISgodGhpcy5fdGVzdCBpbnN0YW5jZW9mIEFycmF5KSkpIHsgdGhpcy5fdGVzdCA9IFt0aGlzLl90ZXN0XSB9O1xuXHRcdHZhciBjYXNlcyA9IHRoaXMuX3Rlc3QubWFwKGZ1bmN0aW9uKGl0ZW0pIHsgcmV0dXJuIChcImNhc2UgXCIgKyAoaXRlbS5jKCkpICsgXCI6XCIpOyB9KTtcblx0XHRyZXR1cm4gY2FzZXMuam9pbihcIlxcblwiKSArIHRoaXMuYm9keSgpLmMoe2luZGVudDogdHJ1ZX0pOyAvLyAuaW5kZW50XG5cdH07XG5cdFxuXHRcblx0XG5cdGZ1bmN0aW9uIFRyeShib2R5LGMsZil7XG5cdFx0dGhpcy5fdHJhdmVyc2VkID0gZmFsc2U7XG5cdFx0dGhpcy5fYm9keSA9IGJsa19fKGJvZHkpO1xuXHRcdHRoaXMuX2NhdGNoID0gYztcblx0XHR0aGlzLl9maW5hbGx5ID0gZjtcblx0fTtcblx0XG5cdFxuXHRzdWJjbGFzcyQoVHJ5LENvbnRyb2xGbG93U3RhdGVtZW50KTtcblx0ZXhwb3J0cy5UcnkgPSBUcnk7IC8vIGV4cG9ydCBjbGFzcyBcblx0VHJ5LnByb3RvdHlwZS5ib2R5ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9ib2R5OyB9XG5cdFRyeS5wcm90b3R5cGUuc2V0Qm9keSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9ib2R5ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdC8vIHByb3AgbmNhdGNoXG5cdC8vIHByb3AgbmZpbmFsbHlcblx0XG5cdFRyeS5wcm90b3R5cGUuY29uc3VtZSA9IGZ1bmN0aW9uIChub2RlKXtcblx0XHR0aGlzLl9ib2R5ID0gdGhpcy5fYm9keS5jb25zdW1lKG5vZGUpO1xuXHRcdGlmICh0aGlzLl9jYXRjaCkgeyB0aGlzLl9jYXRjaCA9IHRoaXMuX2NhdGNoLmNvbnN1bWUobm9kZSkgfTtcblx0XHRpZiAodGhpcy5fZmluYWxseSkgeyB0aGlzLl9maW5hbGx5ID0gdGhpcy5fZmluYWxseS5jb25zdW1lKG5vZGUpIH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRcblx0VHJ5LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICgpe1xuXHRcdHRoaXMuX2JvZHkudHJhdmVyc2UoKTtcblx0XHRpZiAodGhpcy5fY2F0Y2gpIHsgdGhpcy5fY2F0Y2gudHJhdmVyc2UoKSB9O1xuXHRcdGlmICh0aGlzLl9maW5hbGx5KSB7IHJldHVybiB0aGlzLl9maW5hbGx5LnRyYXZlcnNlKCkgfTtcblx0XHQvLyBubyBibG9ja3MgLSBhZGQgYW4gZW1wdHkgY2F0Y2hcblx0fTtcblx0XG5cdFxuXHRUcnkucHJvdG90eXBlLmpzID0gZnVuY3Rpb24gKG8pe1xuXHRcdHZhciBvdXQgPSBcInRyeSBcIiArIHRoaXMuYm9keSgpLmMoe2JyYWNlczogdHJ1ZSxpbmRlbnQ6IHRydWV9KTtcblx0XHRpZiAodGhpcy5fY2F0Y2gpIHsgb3V0ICs9IFwiIFwiICsgdGhpcy5fY2F0Y2guYygpIH07XG5cdFx0aWYgKHRoaXMuX2ZpbmFsbHkpIHsgb3V0ICs9IFwiIFwiICsgdGhpcy5fZmluYWxseS5jKCkgfTtcblx0XHRcblx0XHRpZiAoISh0aGlzLl9jYXRjaCB8fCB0aGlzLl9maW5hbGx5KSkge1xuXHRcdFx0b3V0ICs9IChcIiBjYXRjaCAoZSkgXFx7IFxcfVwiKTtcblx0XHR9O1xuXHRcdG91dCArPSBcIjtcIjtcblx0XHRyZXR1cm4gb3V0O1xuXHR9O1xuXHRcblx0XG5cdFxuXHRmdW5jdGlvbiBDYXRjaChib2R5LHZhcm5hbWUpe1xuXHRcdHRoaXMuX3RyYXZlcnNlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX2JvZHkgPSBibGtfXyhib2R5IHx8IFtdKTtcblx0XHR0aGlzLl9zY29wZSA9IG5ldyBDYXRjaFNjb3BlKHRoaXMpO1xuXHRcdHRoaXMuX3Zhcm5hbWUgPSB2YXJuYW1lO1xuXHRcdHRoaXM7XG5cdH07XG5cdFxuXHRzdWJjbGFzcyQoQ2F0Y2gsQ29udHJvbEZsb3dTdGF0ZW1lbnQpO1xuXHRleHBvcnRzLkNhdGNoID0gQ2F0Y2g7IC8vIGV4cG9ydCBjbGFzcyBcblx0Q2F0Y2gucHJvdG90eXBlLmJvZHkgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2JvZHk7IH1cblx0Q2F0Y2gucHJvdG90eXBlLnNldEJvZHkgPSBmdW5jdGlvbih2KXsgdGhpcy5fYm9keSA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0Q2F0Y2gucHJvdG90eXBlLmNvbnN1bWUgPSBmdW5jdGlvbiAobm9kZSl7XG5cdFx0dGhpcy5fYm9keSA9IHRoaXMuX2JvZHkuY29uc3VtZShub2RlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFxuXHRDYXRjaC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAoKXtcblx0XHR0aGlzLl9zY29wZS52aXNpdCgpO1xuXHRcdHRoaXMuX3ZhcmlhYmxlID0gdGhpcy5fc2NvcGUucmVnaXN0ZXIodGhpcy5fdmFybmFtZSx0aGlzLHtwb29sOiAnY2F0Y2h2YXInfSk7XG5cdFx0cmV0dXJuIHRoaXMuX2JvZHkudHJhdmVyc2UoKTtcblx0fTtcblx0XG5cdFxuXHRDYXRjaC5wcm90b3R5cGUuanMgPSBmdW5jdGlvbiAobyl7XG5cdFx0Ly8gb25seSBpbmRlbnQgaWYgaW5kZW50ZWQgYnkgZGVmYXVsdD9cblx0XHRyZXR1cm4gKFwiY2F0Y2ggKFwiICsgKHRoaXMuX3ZhcmlhYmxlLmMoKSkgKyBcIikgXCIpICsgdGhpcy5fYm9keS5jKHticmFjZXM6IHRydWUsaW5kZW50OiB0cnVlfSk7XG5cdH07XG5cdFxuXHRcblx0Ly8gcmVwZWF0aW5nIG15c2VsZi4uIGRvbid0IGRlYWwgd2l0aCBpdCB1bnRpbCB3ZSBtb3ZlIHRvIGNvbXBhY3QgdHVwbGUtYXJnc1xuXHQvLyBmb3IgYWxsIGFzdG5vZGVzXG5cdFxuXHRcblx0ZnVuY3Rpb24gRmluYWxseShib2R5KXtcblx0XHR0aGlzLl90cmF2ZXJzZWQgPSBmYWxzZTtcblx0XHR0aGlzLl9ib2R5ID0gYmxrX18oYm9keSB8fCBbXSk7XG5cdH07XG5cdFxuXHRcblx0c3ViY2xhc3MkKEZpbmFsbHksQ29udHJvbEZsb3dTdGF0ZW1lbnQpO1xuXHRleHBvcnRzLkZpbmFsbHkgPSBGaW5hbGx5OyAvLyBleHBvcnQgY2xhc3MgXG5cdEZpbmFsbHkucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX2JvZHkudHJhdmVyc2UoKTtcblx0fTtcblx0XG5cdFxuXHRGaW5hbGx5LnByb3RvdHlwZS5jb25zdW1lID0gZnVuY3Rpb24gKG5vZGUpe1xuXHRcdC8vIHN3YWxsb3cgc2lsZW50bHlcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFxuXHRGaW5hbGx5LnByb3RvdHlwZS5qcyA9IGZ1bmN0aW9uIChvKXtcblx0XHRyZXR1cm4gXCJmaW5hbGx5IFwiICsgdGhpcy5fYm9keS5jKHticmFjZXM6IHRydWUsaW5kZW50OiB0cnVlfSk7XG5cdH07XG5cdFxuXHRcblx0Ly8gUkFOR0Vcblx0XG5cdGZ1bmN0aW9uIFJhbmdlKCl7IHJldHVybiBPcC5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XG5cdHN1YmNsYXNzJChSYW5nZSxPcCk7XG5cdGV4cG9ydHMuUmFuZ2UgPSBSYW5nZTsgLy8gZXhwb3J0IGNsYXNzIFxuXHRSYW5nZS5wcm90b3R5cGUuaW5jbHVzaXZlID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMub3AoKSA9PSAnLi4nO1xuXHR9O1xuXHRcblx0UmFuZ2UucHJvdG90eXBlLmMgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gXCJyYW5nZVwiO1xuXHR9O1xuXHRcblx0XG5cdGZ1bmN0aW9uIFNwbGF0KCl7IHJldHVybiBWYWx1ZU5vZGUuYXBwbHkodGhpcyxhcmd1bWVudHMpIH07XG5cdFxuXHRzdWJjbGFzcyQoU3BsYXQsVmFsdWVOb2RlKTtcblx0ZXhwb3J0cy5TcGxhdCA9IFNwbGF0OyAvLyBleHBvcnQgY2xhc3MgXG5cdFNwbGF0LnByb3RvdHlwZS5qcyA9IGZ1bmN0aW9uIChvKXtcblx0XHR2YXIgcGFyID0gdGhpcy5zdGFjaygpLnBhcmVudCgpO1xuXHRcdGlmICgocGFyIGluc3RhbmNlb2YgQXJnTGlzdCkgfHwgKHBhciBpbnN0YW5jZW9mIEFycikpIHtcblx0XHRcdHJldHVybiAoXCJbXS5zbGljZS5jYWxsKFwiICsgKHRoaXMudmFsdWUoKS5jKCkpICsgXCIpXCIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnAoKFwid2hhdCBpcyB0aGUgcGFyZW50PyBcIiArIHBhcikpO1xuXHRcdFx0cmV0dXJuIFwiU1BMQVRcIjtcblx0XHR9O1xuXHR9O1xuXHRcblx0U3BsYXQucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy52YWx1ZSgpO1xuXHR9O1xuXHRcblx0XG5cdFxuXHRcblx0XG5cdC8vIFRBR1Ncblx0XG5cdFxuXHRUQUdfVFlQRVMgPSB7fTtcblx0VEFHX0FUVFJTID0ge307XG5cdFxuXHRcblx0VEFHX1RZUEVTLkhUTUwgPSBcImEgYWJiciBhZGRyZXNzIGFyZWEgYXJ0aWNsZSBhc2lkZSBhdWRpbyBiIGJhc2UgYmRpIGJkbyBiaWcgYmxvY2txdW90ZSBib2R5IGJyIGJ1dHRvbiBjYW52YXMgY2FwdGlvbiBjaXRlIGNvZGUgY29sIGNvbGdyb3VwIGRhdGEgZGF0YWxpc3QgZGQgZGVsIGRldGFpbHMgZGZuIGRpdiBkbCBkdCBlbSBlbWJlZCBmaWVsZHNldCBmaWdjYXB0aW9uIGZpZ3VyZSBmb290ZXIgZm9ybSBoMSBoMiBoMyBoNCBoNSBoNiBoZWFkIGhlYWRlciBociBodG1sIGkgaWZyYW1lIGltZyBpbnB1dCBpbnMga2JkIGtleWdlbiBsYWJlbCBsZWdlbmQgbGkgbGluayBtYWluIG1hcCBtYXJrIG1lbnUgbWVudWl0ZW0gbWV0YSBtZXRlciBuYXYgbm9zY3JpcHQgb2JqZWN0IG9sIG9wdGdyb3VwIG9wdGlvbiBvdXRwdXQgcCBwYXJhbSBwcmUgcHJvZ3Jlc3MgcSBycCBydCBydWJ5IHMgc2FtcCBzY3JpcHQgc2VjdGlvbiBzZWxlY3Qgc21hbGwgc291cmNlIHNwYW4gc3Ryb25nIHN0eWxlIHN1YiBzdW1tYXJ5IHN1cCB0YWJsZSB0Ym9keSB0ZCB0ZXh0YXJlYSB0Zm9vdCB0aCB0aGVhZCB0aW1lIHRpdGxlIHRyIHRyYWNrIHUgdWwgdmFyIHZpZGVvIHdiclwiLnNwbGl0KFwiIFwiKTtcblx0XG5cdFRBR19UWVBFUy5TVkcgPSBcImNpcmNsZSBkZWZzIGVsbGlwc2UgZyBsaW5lIGxpbmVhckdyYWRpZW50IG1hc2sgcGF0aCBwYXR0ZXJuIHBvbHlnb24gcG9seWxpbmUgcmFkaWFsR3JhZGllbnQgcmVjdCBzdG9wIHN2ZyB0ZXh0IHRzcGFuXCIuc3BsaXQoXCIgXCIpO1xuXHRcblx0VEFHX0FUVFJTLkhUTUwgPSBcImFjY2VwdCBhY2Nlc3NLZXkgYWN0aW9uIGFsbG93RnVsbFNjcmVlbiBhbGxvd1RyYW5zcGFyZW5jeSBhbHQgYXN5bmMgYXV0b0NvbXBsZXRlIGF1dG9Gb2N1cyBhdXRvUGxheSBjZWxsUGFkZGluZyBjZWxsU3BhY2luZyBjaGFyU2V0IGNoZWNrZWQgY2xhc3NOYW1lIGNvbHMgY29sU3BhbiBjb250ZW50IGNvbnRlbnRFZGl0YWJsZSBjb250ZXh0TWVudSBjb250cm9scyBjb29yZHMgY3Jvc3NPcmlnaW4gZGF0YSBkYXRlVGltZSBkZWZlciBkaXIgZGlzYWJsZWQgZG93bmxvYWQgZHJhZ2dhYmxlIGVuY1R5cGUgZm9ybSBmb3JtTm9WYWxpZGF0ZSBmcmFtZUJvcmRlciBoZWlnaHQgaGlkZGVuIGhyZWYgaHJlZkxhbmcgaHRtbEZvciBodHRwRXF1aXYgaWNvbiBpZCBsYWJlbCBsYW5nIGxpc3QgbG9vcCBtYXggbWF4TGVuZ3RoIG1lZGlhR3JvdXAgbWV0aG9kIG1pbiBtdWx0aXBsZSBtdXRlZCBuYW1lIG5vVmFsaWRhdGUgcGF0dGVybiBwbGFjZWhvbGRlciBwb3N0ZXIgcHJlbG9hZCByYWRpb0dyb3VwIHJlYWRPbmx5IHJlbCByZXF1aXJlZCByb2xlIHJvd3Mgcm93U3BhbiBzYW5kYm94IHNjb3BlIHNjcm9sbExlZnQgc2Nyb2xsaW5nIHNjcm9sbFRvcCBzZWFtbGVzcyBzZWxlY3RlZCBzaGFwZSBzaXplIHNwYW4gc3BlbGxDaGVjayBzcmMgc3JjRG9jIHNyY1NldCBzdGFydCBzdGVwIHN0eWxlIHRhYkluZGV4IHRhcmdldCB0aXRsZSB0eXBlIHVzZU1hcCB2YWx1ZSB3aWR0aCB3bW9kZVwiO1xuXHRcblx0VEFHX0FUVFJTLlNWRyA9IFwiY3ggY3kgZCBkeCBkeSBmaWxsIGZpbGxPcGFjaXR5IGZvbnRGYW1pbHkgZm9udFNpemUgZnggZnkgZ3JhZGllbnRUcmFuc2Zvcm0gZ3JhZGllbnRVbml0cyBtYXJrZXJFbmQgbWFya2VyTWlkIG1hcmtlclN0YXJ0IG9mZnNldCBvcGFjaXR5IHBhdHRlcm5Db250ZW50VW5pdHMgcGF0dGVyblVuaXRzIHBvaW50cyBwcmVzZXJ2ZUFzcGVjdFJhdGlvIHIgcnggcnkgc3ByZWFkTWV0aG9kIHN0b3BDb2xvciBzdG9wT3BhY2l0eSBzdHJva2Ugc3Ryb2tlRGFzaGFycmF5IHN0cm9rZUxpbmVjYXAgc3Ryb2tlT3BhY2l0eSBzdHJva2VXaWR0aCB0ZXh0QW5jaG9yIHRyYW5zZm9ybSB2ZXJzaW9uIHZpZXdCb3ggeDEgeDIgeCB5MSB5MiB5XCI7XG5cdFxuXHRcblx0ZnVuY3Rpb24gVGFnRGVzYygpe1xuXHRcdHRoaXMucCgnVGFnRGVzYyEhIScsYXJndW1lbnRzKTtcblx0XHR0aGlzO1xuXHR9O1xuXHRcblx0c3ViY2xhc3MkKFRhZ0Rlc2MsTm9kZSk7XG5cdGV4cG9ydHMuVGFnRGVzYyA9IFRhZ0Rlc2M7IC8vIGV4cG9ydCBjbGFzcyBcblx0VGFnRGVzYy5wcm90b3R5cGUuY2xhc3NlcyA9IGZ1bmN0aW9uICgpe1xuXHRcdHRoaXMucCgnVGFnRGVzY0NsYXNzZXMnLGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBUYWcobyl7XG5cdFx0aWYobyA9PT0gdW5kZWZpbmVkKSBvID0ge307XG5cdFx0dGhpcy5fdHJhdmVyc2VkID0gZmFsc2U7XG5cdFx0dGhpcy5fcGFydHMgPSBbXTtcblx0XHRvLmNsYXNzZXMgfHwgKG8uY2xhc3NlcyA9IFtdKTtcblx0XHRvLmF0dHJpYnV0ZXMgfHwgKG8uYXR0cmlidXRlcyA9IFtdKTtcblx0XHRvLmNsYXNzZXMgfHwgKG8uY2xhc3NlcyA9IFtdKTtcblx0XHR0aGlzLl9vcHRpb25zID0gbztcblx0XHR0aGlzLl9yZWZlcmVuY2UgPSBudWxsO1xuXHRcdHRoaXMuX29iamVjdCA9IG51bGw7XG5cdFx0dGhpcy5fdHJlZSA9IG51bGw7XG5cdFx0dGhpcztcblx0fTtcblx0XG5cdHN1YmNsYXNzJChUYWcsTm9kZSk7XG5cdGV4cG9ydHMuVGFnID0gVGFnOyAvLyBleHBvcnQgY2xhc3MgXG5cdFRhZy5wcm90b3R5cGUucGFydHMgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3BhcnRzOyB9XG5cdFRhZy5wcm90b3R5cGUuc2V0UGFydHMgPSBmdW5jdGlvbih2KXsgdGhpcy5fcGFydHMgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0VGFnLnByb3RvdHlwZS5vYmplY3QgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX29iamVjdDsgfVxuXHRUYWcucHJvdG90eXBlLnNldE9iamVjdCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9vYmplY3QgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0VGFnLnByb3RvdHlwZS5yZWFjdGl2ZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fcmVhY3RpdmU7IH1cblx0VGFnLnByb3RvdHlwZS5zZXRSZWFjdGl2ZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9yZWFjdGl2ZSA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRUYWcucHJvdG90eXBlLnBhcmVudCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fcGFyZW50OyB9XG5cdFRhZy5wcm90b3R5cGUuc2V0UGFyZW50ID0gZnVuY3Rpb24odil7IHRoaXMuX3BhcmVudCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRUYWcucHJvdG90eXBlLnRyZWUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3RyZWU7IH1cblx0VGFnLnByb3RvdHlwZS5zZXRUcmVlID0gZnVuY3Rpb24odil7IHRoaXMuX3RyZWUgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFRhZy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG9iail7XG5cdFx0Zm9yICh2YXIgdiwgaSA9IDAsIGtleXMgPSBPYmplY3Qua2V5cyhvYmopLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspe1xuXHRcdFx0ayA9IGtleXNbaV07diA9IG9ialtrXTtpZiAoayA9PSAnYXR0cmlidXRlcycpIHtcblx0XHRcdFx0Ly8gcCBcImF0dHJpYnV0cyFcIlxuXHRcdFx0XHRmb3IgKHZhciBqID0gMCwgYXJ5ID0gaXRlciQodiksIGxlbiA9IGFyeS5sZW5ndGg7IGogPCBsZW47IGorKykge1xuXHRcdFx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKGFyeVtqXSk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dGhpcy5fb3B0aW9uc1trXSA9IHY7XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFRhZy5wcm90b3R5cGUuYWRkQ2xhc3MgPSBmdW5jdGlvbiAobm9kZSl7XG5cdFx0aWYgKCEoKG5vZGUgaW5zdGFuY2VvZiBUYWdGbGFnKSkpIHtcblx0XHRcdG5vZGUgPSBuZXcgVGFnRmxhZyhub2RlKTtcblx0XHR9O1xuXHRcdHRoaXMuX29wdGlvbnMuY2xhc3Nlcy5wdXNoKG5vZGUpO1xuXHRcdHRoaXMuX3BhcnRzLnB1c2gobm9kZSk7XG5cdFx0XG5cdFx0Ly8gcCBcImFkZCBjbGFzcyEhIVwiXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRUYWcucHJvdG90eXBlLmFkZEluZGV4ID0gZnVuY3Rpb24gKG5vZGUpe1xuXHRcdHRoaXMuX3BhcnRzLnB1c2gobm9kZSk7XG5cdFx0dGhpcy5fb2JqZWN0ID0gbm9kZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFRhZy5wcm90b3R5cGUuYWRkU3ltYm9sID0gZnVuY3Rpb24gKG5vZGUpe1xuXHRcdC8vIHAgXCJhZGRTeW1ib2wgdG8gdGhlIHRhZ1wiLG5vZGVcblx0XHRpZiAodGhpcy5fcGFydHMubGVuZ3RoID09IDApIHtcblx0XHRcdHRoaXMuX3BhcnRzLnB1c2gobm9kZSk7XG5cdFx0XHR0aGlzLl9vcHRpb25zLm5zID0gbm9kZTtcblx0XHR9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0XG5cdFRhZy5wcm90b3R5cGUuYWRkQXR0cmlidXRlID0gZnVuY3Rpb24gKGF0cil7XG5cdFx0Ly8gcCBcImFkZCBhdHRyaWJ1dGUhISFcIiwga2V5LCB2YWx1ZVxuXHRcdHRoaXMuX3BhcnRzLnB1c2goYXRyKTsgLy8gd2hhdD9cblx0XHR0aGlzLl9vcHRpb25zLmF0dHJpYnV0ZXMucHVzaChhdHIpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0VGFnLnByb3RvdHlwZS5lbmNsb3NpbmcgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fb3B0aW9ucy5jbG9zZSAmJiB0aGlzLl9vcHRpb25zLmNsb3NlLnZhbHVlKCk7XG5cdH07XG5cdFxuXHRUYWcucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fb3B0aW9ucy50eXBlIHx8ICdkaXYnO1xuXHR9O1xuXHRcblx0VGFnLnByb3RvdHlwZS5jb25zdW1lID0gZnVuY3Rpb24gKG5vZGUpe1xuXHRcdHZhciBvID0gdGhpcy5fb3B0aW9ucztcblx0XHRcblx0XHRcblx0XHRpZiAobm9kZSBpbnN0YW5jZW9mIFRhZ1RyZWUpIHtcblx0XHRcdC8vIHAgXCJ0YWcgY29uc3VtZSB0YWd0cmVlPyB7bm9kZS5yZWFjdGl2ZX1cIlxuXHRcdFx0dGhpcy5zZXRQYXJlbnQobm9kZS5yb290KCkpO1xuXHRcdFx0Ly8gbzp0cmVlUmVmID0gbm9kZS5uZXh0Q2FjaGVLZXlcblx0XHRcdFxuXHRcdFx0aWYgKG5vZGUuX2xvb3ApIHtcblx0XHRcdFx0Ly8gYWx3YXR5cyBtYWtlIGl0ZW1zIGluIGxvb3AgcmVhY3RpdmVcblx0XHRcdFx0dGhpcy5zZXRSZWFjdGl2ZShub2RlLnJlYWN0aXZlKCkgfHwgdGhpcy5vcHRpb24oJ2tleScpKTtcblx0XHRcdFx0dGhpcy5vcHRpb24oJ2xvb3AnLG5vZGUuX2xvb3ApO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHRoaXMub3B0aW9uKCdpdmFyJykpIHtcblx0XHRcdFx0XHR0aGlzLndhcm4oKFwiVGFnIGluc2lkZSBsb29wIGNhbiBub3QgaGF2ZSBhIHN0YXRpYyByZWZlcmVuY2UgXCIgKyB0aGlzLm9wdGlvbignaXZhcicpKSx7dHlwZTogJ2Vycm9yJyx0b2tlbjogdGhpcy5vcHRpb24oJ2l2YXInKS52YWx1ZSgpfSk7XG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnNldFJlYWN0aXZlKG5vZGUucmVhY3RpdmUoKSB8fCAhKCF0aGlzLm9wdGlvbignaXZhcicpKSk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiBUYWcuX19zdXBlcl9fLmNvbnN1bWUuYXBwbHkodGhpcyxhcmd1bWVudHMpO1xuXHR9O1xuXHRcblx0XG5cdFRhZy5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAoKXtcblx0XHRcblx0XHR2YXIgbyA9IHRoaXMuX29wdGlvbnM7XG5cdFx0XG5cdFx0aWYgKG8uaXZhciB8fCBvLmtleSkge1xuXHRcdFx0dGhpcy5zZXRSZWFjdGl2ZSh0cnVlKTtcblx0XHR9O1xuXHRcdFxuXHRcdHZhciB0eXAgPSB0aGlzLmVuY2xvc2luZygpO1xuXHRcdFxuXHRcdC8vIGxvb2sgZm9yIG91dGVyIHRhZyBoZXJlP1xuXHRcdFxuXHRcdGlmICh0eXAgPT0gJy0+JyB8fCB0eXAgPT0gJz0+Jykge1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgXCJ0YWcgaXMgdGVtcGxhdGU/IT8ge3R5cH1cIlxuXHRcdFx0dGhpcy5fdHJlZSA9IG5ldyBUYWdUcmVlKHRoaXMsby5ib2R5LHtyb290OiB0aGlzLHJlYWN0aXZlOiB0aGlzLnJlYWN0aXZlKCl9KTtcblx0XHRcdG8uYm9keSA9IG5ldyBUYWdGcmFnbWVudEZ1bmMoW10sQmxvY2sud3JhcChbdGhpcy5fdHJlZV0pKTtcblx0XHRcdC8vIGNvbnNvbGUubG9nIFwibWFkZSBvIGJvZHkgYSBmdW5jdGlvbj9cIlxuXHRcdH07XG5cdFx0XG5cdFx0aWYgKG8ua2V5KSB7IG8ua2V5LnRyYXZlcnNlKCkgfTtcblx0XHRcblx0XHRpZiAoby5ib2R5KSB7XG5cdFx0XHRvLmJvZHkudHJhdmVyc2UoKTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIGlkIHNob3VsZCBhbHNvIGJlIGEgcmVndWxhciBwYXJ0XG5cdFx0XG5cdFx0aWYgKG8uaWQpIHsgby5pZC50cmF2ZXJzZSgpIH07XG5cdFx0XG5cdFx0XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHRoaXMuX3BhcnRzKSwgbGVuID0gYXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRhcnlbaV0udHJhdmVyc2UoKTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIGZvciBhdHIgaW4gQG9wdGlvbnM6YXR0cmlidXRlc1xuXHRcdC8vIFx0YXRyLnRyYXZlcnNlXG5cdFx0XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRUYWcucHJvdG90eXBlLnJlZmVyZW5jZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9yZWZlcmVuY2UgfHwgKHRoaXMuX3JlZmVyZW5jZSA9IHRoaXMuc2NvcGVfXygpLmNsb3N1cmUoKS50ZW1wb3JhcnkodGhpcyx7cG9vbDogJ3RhZyd9KS5yZXNvbHZlKCkpO1xuXHR9O1xuXHRcblx0Ly8gc2hvdWxkIHRoaXMgbm90IGhhcHBlbiBpbiBqcz9cblx0Ly8gc2hvdWxkIHRoaXMgbm90IGhhcHBlbiBpbiBqcz9cblx0VGFnLnByb3RvdHlwZS5qcyA9IGZ1bmN0aW9uIChvKXtcblx0XHQvLyBwIEpTT04uc3RyaW5naWZ5KEBvcHRpb25zKVxuXHRcdC8vIHZhciBhdHRycyA9IFRhZ0F0dHJpYnV0ZXMubmV3KG86YXR0cmlidXRlcylcblx0XHQvLyBwIFwiZ290IGhlcmU/XCJcblx0XHR2YXIgYm9keTtcblx0XHR2YXIgbyA9IHRoaXMuX29wdGlvbnM7XG5cdFx0dmFyIGEgPSB7fTtcblx0XHR2YXIgZW5jID0gdGhpcy5lbmNsb3NpbmcoKTtcblx0XHRcblx0XHR2YXIgc2V0dXAgPSBbXTtcblx0XHR2YXIgY2FsbHMgPSBbXTtcblx0XHR2YXIgc3RhdGljcyA9IFtdO1xuXHRcdFxuXHRcdHZhciBzY29wZSA9IHRoaXMuc2NvcGVfXygpO1xuXHRcdHZhciBjb21taXQgPSBcImVuZFwiO1xuXHRcdHZhciBjb250ZW50ID0gby5ib2R5O1xuXHRcdFxuXHRcdHZhciBpc1NlbGYgPSAodGhpcy50eXBlKCkgaW5zdGFuY2VvZiBTZWxmKTtcblx0XHR2YXIgYm9keVNldHRlciA9IGlzU2VsZiA/IChcInNldENoaWxkcmVuXCIpIDogKFwic2V0Q29udGVudFwiKTtcblx0XHRcblx0XHQvLyBzaG91bGQgbm90IGNhY2hlIHN0YXRpY3MgaWYgdGhlIG5vZGUgaXRzZWxmIGlzIG5vdCBjYWNoZWRcblx0XHQvLyB0aGF0IHdvdWxkIG9ubHkgbWFuZ2xlIHRoZSBvcmRlciBpbiB3aGljaCB3ZSBzZXQgdGhlIHByb3BlcnRpZXNcblx0XHR2YXIgY2FjaGVTdGF0aWNzID0gdHJ1ZTtcblx0XHRcblx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQoby5hdHRyaWJ1dGVzKSwgbGVuID0gYXJ5Lmxlbmd0aCwgYXRyOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGF0ciA9IGFyeVtpXTtcblx0XHRcdGFbYXRyLmtleSgpXSA9IGF0ci52YWx1ZSgpOyAvLyAucG9wdWxhdGUob2JqKVxuXHRcdH07XG5cdFx0XG5cdFx0dmFyIHF1b3RlID0gZnVuY3Rpb24oc3RyKSB7IHJldHVybiBoZWxwZXJzLnNpbmdsZXF1b3RlKHN0cik7IH07XG5cdFx0dmFyIGlkID0gby5pZCBpbnN0YW5jZW9mIE5vZGUgPyAoby5pZC5jKCkpIDogKChvLmlkICYmIHF1b3RlKG8uaWQuYygpKSkpO1xuXHRcdHZhciB0cmVlID0gdGhpcy5fdHJlZSB8fCBudWxsO1xuXHRcdHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudCgpO1xuXHRcdC8vIHZhciBwYXJUcmVlID0gcGFyZW50IGFuZCBwYXJlbnQudHJlZVxuXHRcdFxuXHRcdFxuXHRcdC8vICBcInNjb3BlIGlzXCIsICEhc2NvcGVcblx0XHQvLyBwIFwidHlwZSBpcyB7dHlwZX1cIlxuXHRcdHZhciBvdXQgPSBpc1NlbGYgPyAoXG5cdFx0XHRjb21taXQgPSBcInN5bmNlZFwiLFxuXHRcdFx0Ly8gcCBcImdvdCBoZXJlXCJcblx0XHRcdC8vIHNldHRpbmcgY29ycmVjdCBjb250ZXh0IGRpcmVjdGx5XG5cdFx0XHR0aGlzLnNldFJlYWN0aXZlKHRydWUpLFxuXHRcdFx0dGhpcy5fcmVmZXJlbmNlID0gc2NvcGUuY29udGV4dCgpLFxuXHRcdFx0c2NvcGUuY29udGV4dCgpLmMoKVxuXHRcdCkgOiAoXG5cdFx0XHQoXCJcIiArIG1hcmtfXyhvLm9wZW4pICsgKHNjb3BlLnRhZ0NvbnRleHRQYXRoKCkpICsgXCIuXCIgKyAodGhpcy50eXBlKCkuc3Bhd25lcigpKSArIFwiKClcIilcblx0XHQpO1xuXHRcdFxuXHRcdGlmIChvLmlkKSB7XG5cdFx0XHRzdGF0aWNzLnB1c2goKFwiLnNldElkKFwiICsgcXVvdGUoby5pZCkgKyBcIilcIikpO1xuXHRcdH07XG5cdFx0Ly8gdGhpcyBpcyByZWFjdGl2ZSBpZiBpdCBoYXMgYW4gaXZhclxuXHRcdGlmIChvLml2YXIpIHtcblx0XHRcdHRoaXMuc2V0UmVhY3RpdmUodHJ1ZSk7XG5cdFx0XHRzdGF0aWNzLnB1c2goKFwiLnNldFJlZihcIiArIHF1b3RlKG8uaXZhci5uYW1lKCkpICsgXCIsXCIgKyAoc2NvcGUuY29udGV4dCgpLmMoKSkgKyBcIilcIikpO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKG8uYm9keSBpbnN0YW5jZW9mIEZ1bmMpIHtcblx0XHRcdC8vIGNvbnNvbGUubG9nIFwibzpib2R5IGlzYSBmdW5jdGlvbiFcIlxuXHRcdFx0Ym9keVNldHRlciA9IFwic2V0VGVtcGxhdGVcIjtcblx0XHR9IGVsc2UgaWYgKG8uYm9keSkge1xuXHRcdFx0aWYgKChvLmJvZHkgaW5zdGFuY2VvZiBBcmdMaXN0KSAmJiBvLmJvZHkuY291bnQoKSA9PSAxICYmIG8uYm9keS5maXJzdCgpLmlzU3RyaW5nKCkpIHtcblx0XHRcdFx0Ym9keVNldHRlciA9IFwic2V0VGV4dFwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gd291bGQgcHJvYmFibHkgYmUgYmV0dGVyIHRvIGNvbnZlcnQgdG8gYSB0YWd0cmVlIGR1cmluZyB0aGUgaW5pdGlhbCB2aXNpdFxuXHRcdFx0XHR0cmVlID0gbmV3IFRhZ1RyZWUodGhpcyxvLmJvZHkse3Jvb3Q6IHRoaXMscmVhY3RpdmU6IHRoaXMucmVhY3RpdmUoKX0pO1xuXHRcdFx0XHRjb250ZW50ID0gdHJlZTtcblx0XHRcdFx0dGhpcy5zZXRUcmVlKHRyZWUpO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmICh0cmVlKSB7XG5cdFx0XHQvLyB0aGlzIGlzIHRoZSBwb2ludCB3aGVyZSB3ZSB0cmF2ZXJzZSB0aGUgaW5uZXIgbm9kZXMgd2l0aCBvdXIgdHJlZVxuXHRcdFx0Ly8gc2hvdWxkIHJhdGhlciBoYXBwZW4gaW4gdmlzaXQgLSBsb25nIGJlZm9yZS5cblx0XHRcdHRyZWUucmVzb2x2ZSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHRoaXMuX3BhcnRzKSwgbGVuID0gYXJ5Lmxlbmd0aCwgcGFydDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRwYXJ0ID0gYXJ5W2ldO1xuXHRcdFx0dmFyIHBqcztcblx0XHRcdHZhciBwY2FjaGUgPSBmYWxzZTtcblx0XHRcdFxuXHRcdFx0aWYgKHBhcnQgaW5zdGFuY2VvZiBUYWdBdHRyKSB7XG5cdFx0XHRcdHZhciBha2V5ID0gU3RyaW5nKHBhcnQua2V5KCkpO1xuXHRcdFx0XHR2YXIgYXZhbCA9IHBhcnQudmFsdWUoKTtcblx0XHRcdFx0Ly8gcCBcInBhcnQgdmFsdWUge2F2YWx9IHthdmFsLmlzUHJpbWl0aXZlKHllcyl9XCJcblx0XHRcdFx0XG5cdFx0XHRcdC8vIHRoZSBhdHRyIHNob3VsZCBjb21waWxlIGl0c2VsZiBpbnN0ZWFkIC0tIHJlYWxseVxuXHRcdFx0XHRwY2FjaGUgPSBhdmFsLmlzUHJpbWl0aXZlKCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoYWtleVswXSA9PSAnLicpIHsgLy8gc2hvdWxkIGNoZWNrIGluIGEgYmV0dGVyIHdheVxuXHRcdFx0XHRcdHBjYWNoZSA9IGZhbHNlO1xuXHRcdFx0XHRcdHBqcyA9IChcIi5mbGFnKFwiICsgcXVvdGUoYWtleS5zdWJzdHIoMSkpICsgXCIsXCIgKyAoYXZhbC5jKCkpICsgXCIpXCIpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGFrZXlbMF0gPT0gJzonKSB7XG5cdFx0XHRcdFx0Ly8gbmVlZCB0byBhbmFseXplIHdoZXRoZXIgdGhpcyBpcyBzdGF0aWMgb3Igbm90XG5cdFx0XHRcdFx0cGpzID0gKFwiLnNldEhhbmRsZXIoXCIgKyBxdW90ZShha2V5LnN1YnN0cigxKSkgKyBcIixcIiArIChhdmFsLmMoKSkgKyBcIixcIiArIChzY29wZS5jb250ZXh0KCkuYygpKSArIFwiKVwiKTtcblx0XHRcdFx0fSBlbHNlIGlmIChha2V5LnN1YnN0cigwLDUpID09ICdkYXRhLScpIHtcblx0XHRcdFx0XHRwanMgPSAoXCIuZGF0YXNldCgnXCIgKyBha2V5LnNsaWNlKDUpICsgXCInLFwiICsgKGF2YWwuYygpKSArIFwiKVwiKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwanMgPSAoXCIuXCIgKyBtYXJrX18ocGFydC5rZXkoKSkgKyBoZWxwZXJzLnNldHRlclN5bShha2V5KSArIFwiKFwiICsgKGF2YWwuYygpKSArIFwiKVwiKTtcblx0XHRcdFx0fTtcblx0XHRcdH0gZWxzZSBpZiAocGFydCBpbnN0YW5jZW9mIFRhZ0ZsYWcpIHtcblx0XHRcdFx0cGpzID0gcGFydC5jKCk7XG5cdFx0XHRcdHBjYWNoZSA9IHRydWU7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAocGpzKSB7XG5cdFx0XHRcdGNhY2hlU3RhdGljcyAmJiBwY2FjaGUgPyAoc3RhdGljcy5wdXNoKHBqcykpIDogKGNhbGxzLnB1c2gocGpzKSk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0XG5cdFx0aWYgKHRoaXMub2JqZWN0KCkpIHtcblx0XHRcdGNhbGxzLnB1c2goKFwiLnNldE9iamVjdChcIiArICh0aGlzLm9iamVjdCgpLmMoKSkgKyBcIilcIikpO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gcCBcInRhZ3RyZWUgaXMgc3RhdGljPyB7dHJlZS5zdGF0aWN9XCJcblx0XHRcblx0XHQvLyB3ZSBuZWVkIHRvIHRyaWdnZXIgb3VyIG93biByZWZlcmVuY2UgYmVmb3JlIHRoZSBib2R5IGRvZXNcblx0XHQvLyBidXQgd2UgZG8gbm90IG5lZWQgYSByZWZlcmVuY2UgaWYgd2UgaGF2ZSBubyBib2R5IChubyBub2RlcyB3aWxsIHJlZmVyIGl0KVxuXHRcdGlmICh0aGlzLnJlYWN0aXZlKCkgJiYgdHJlZSkgeyAvLyBhbmQgdHJlZS5oYXNUYWdzXG5cdFx0XHR0aGlzLnJlZmVyZW5jZSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKHRoaXMucmVhY3RpdmUoKSAmJiBwYXJlbnQgJiYgcGFyZW50LnRyZWUoKSkge1xuXHRcdFx0by50cmVlUmVmID0gcGFyZW50LnRyZWUoKS5uZXh0Q2FjaGVLZXkodGhpcyk7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoYm9keSA9IGNvbnRlbnQgJiYgY29udGVudC5jKHtleHByZXNzaW9uOiB0cnVlfSkpIHsgLy8gZm9yY2UgaXQgdG8gYmUgYW4gZXhwcmVzc2lvbiwgbm8/XG5cdFx0XHR2YXIgdHlwID0gMDtcblx0XHRcdFxuXHRcdFx0aWYgKHRyZWUpIHtcblx0XHRcdFx0aWYgKHRyZWUuc3RhdGljKCkpIHtcblx0XHRcdFx0XHR0eXAgPSAyO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMucmVhY3RpdmUoKSB8fCB0cmVlLnJlYWN0aXZlKCkpIHtcblx0XHRcdFx0XHRpZiAoIXRyZWUuc2luZ2xlKCkgfHwgKHRyZWUuc2luZ2xlKCkgaW5zdGFuY2VvZiBJZikpIHtcblx0XHRcdFx0XHRcdHR5cCA9IDE7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHR5cCA9IDM7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0aWYgKGJvZHlTZXR0ZXIgPT0gJ3NldENoaWxkcmVuJyB8fCBib2R5U2V0dGVyID09ICdzZXRDb250ZW50Jykge1xuXHRcdFx0XHRjYWxscy5wdXNoKChcIi5cIiArIGJvZHlTZXR0ZXIgKyBcIihcIiArIGJvZHkgKyBcIixcIiArIHR5cCArIFwiKVwiKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjYWxscy5wdXNoKChcIi5cIiArIGJvZHlTZXR0ZXIgKyBcIihcIiArIGJvZHkgKyBcIilcIikpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Ly8gb3V0ICs9IFwiLmJvZHkoe2JvZHl9KVwiXG5cdFx0fTtcblx0XHRcblx0XHQvLyBpZiBvOmF0dHJpYnV0ZXM6bGVuZ3RoICMgb3IgLS0gYWx3YXlzP1xuXHRcdC8vIGFkZHMgbG90cyBvZiBleHRyYSBjYWxscyAtIGJ1dCBva2F5IGZvciBub3dcblx0XHRjYWxscy5wdXNoKChcIi5cIiArIGNvbW1pdCArIFwiKClcIikpO1xuXHRcdFxuXHRcdGlmIChzdGF0aWNzLmxlbmd0aCkge1xuXHRcdFx0b3V0ID0gb3V0ICsgc3RhdGljcy5qb2luKFwiXCIpO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0aWYgKChvLml2YXIgfHwgby5rZXkgfHwgdGhpcy5yZWFjdGl2ZSgpKSAmJiAhKHRoaXMudHlwZSgpIGluc3RhbmNlb2YgU2VsZikpIHtcblx0XHRcdC8vIGlmIHRoaXMgaXMgYW4gaXZhciwgd2Ugc2hvdWxkIHNldCB0aGUgcmVmZXJlbmNlIHJlbGF0aXZlXG5cdFx0XHQvLyB0byB0aGUgb3V0ZXIgcmVmZXJlbmNlLCBvciBwb3NzaWJseSByaWdodCBvbiBjb250ZXh0P1xuXHRcdFx0dmFyIGN0eCxrZXk7XG5cdFx0XHR2YXIgcGFydHJlZSA9IHBhcmVudCAmJiBwYXJlbnQudHJlZSgpO1xuXHRcdFx0Ly8gY3R4ID0gIW86aXZhciBhbmQgcGFyIGFuZCBwYXIucmVmZXJlbmNlIG9yIHNjb3BlLmNvbnRleHRcblx0XHRcdC8vIGtleSA9IG86aXZhciBvciB0cmVlIGFuZCB0cmVlLm5leHRDYWNoZUtleVxuXHRcdFx0XG5cdFx0XHRpZiAoby5rZXkpIHtcblx0XHRcdFx0Ly8gY2xvc2VzdCB0YWdcblx0XHRcdFx0Ly8gVE9ETyBpZiB0aGUgZHluYW1pYyBrZXkgc3RhcnRzIHdpdGggYSBzdGF0aWMgc3RyaW5nIHdlIHNob3VsZFxuXHRcdFx0XHQvLyBqdXN0IHByZXBlbmQgXyB0byB0aGUgc3RyaW5nIGluc3RlYWQgb2Ygd3JhcHBpbmcgaW4gT1Bcblx0XHRcdFx0Y3R4ID0gcGFyZW50ICYmIHBhcmVudC5yZWZlcmVuY2UoKTtcblx0XHRcdFx0a2V5ID0gT1AoJysnLG5ldyBTdHIoXCInXydcIiksby5rZXkpO1xuXHRcdFx0fSBlbHNlIGlmIChvLml2YXIpIHtcblx0XHRcdFx0Y3R4ID0gc2NvcGUuY29udGV4dCgpO1xuXHRcdFx0XHRrZXkgPSBvLml2YXI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjdHggPSBwYXJlbnQgJiYgcGFyZW50LnJlZmVyZW5jZSgpO1xuXHRcdFx0XHQvLyBjdHggPSBwYXJ0cmVlLmNhY2hlclxuXHRcdFx0XHRrZXkgPSBvLnRyZWVSZWYgfHwgcGFydHJlZSAmJiBwYXJ0cmVlLm5leHRDYWNoZUtleSgpO1xuXHRcdFx0XHQvLyBrZXkgPSB0cmVlIGFuZCB0cmVlLm5leHRDYWNoZUtleVxuXHRcdFx0XHRpZiAoby5sb29wKSB7XG5cdFx0XHRcdFx0dmFyIGlkeCA9IG8ubG9vcC5vcHRpb24oJ3ZhcnMnKS5pbmRleDtcblx0XHRcdFx0XHRrZXkgPSBPUCgnKycsXCInXCIgKyBrZXkgKyBcIidcIixpZHgpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0XG5cdFx0XHRcblx0XHRcdC8vIG5lZWQgdGhlIGNvbnRleHQgLS0gbWlnaHQgYmUgYmV0dGVyIHRvIHJld3JpdGUgaXQgZm9yIHJlYWw/XG5cdFx0XHQvLyBwYXJzZSB0aGUgd2hvbGUgdGhpbmcgaW50byBjYWxscyBldGNcblx0XHRcdHZhciBhY2MgPSBPUCgnLicsY3R4LGtleSkuYygpO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5fcmVmZXJlbmNlKSB7XG5cdFx0XHRcdG91dCA9IChcIihcIiArICh0aGlzLnJlZmVyZW5jZSgpLmMoKSkgKyBcIiA9IFwiICsgYWNjICsgXCI9XCIgKyBhY2MgKyBcIiB8fCBcIiArIG91dCArIFwiKVwiKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dCA9IChcIihcIiArIGFjYyArIFwiID0gXCIgKyBhY2MgKyBcIiB8fCBcIiArIG91dCArIFwiKVwiKTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gb3V0ICsgY2FsbHMuam9pbihcIlwiKTtcblx0fTtcblx0XG5cdC8vIFRoaXMgaXMgYSBoZWxwZXItbm9kZVxuXHQvLyBTaG91bGQgcHJvYmFibHkgdXNlIHRoZSBzYW1lIHR5cGUgb2YgbGlzdG5vZGUgZXZlcnl3aGVyZSAtIGFuZCBzaW1wbHkgZmxhZyB0aGUgdHlwZSBhcyBUYWdUcmVlIGluc3RlYWRcblx0ZnVuY3Rpb24gVGFnVHJlZShvd25lcixsaXN0LG9wdGlvbnMpe1xuXHRcdGlmKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkgb3B0aW9ucyA9IHt9O1xuXHRcdHRoaXMuX293bmVyID0gb3duZXI7XG5cdFx0dGhpcy5fbm9kZXMgPSB0aGlzLmxvYWQobGlzdCk7XG5cdFx0dGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dGhpcy5fY29uZGl0aW9ucyA9IFtdO1xuXHRcdHRoaXMuX2Jsb2NrcyA9IFt0aGlzXTtcblx0XHR0aGlzLl9jb3VudGVyID0gMDtcblx0XHR0aGlzO1xuXHR9O1xuXHRcblx0c3ViY2xhc3MkKFRhZ1RyZWUsTGlzdE5vZGUpO1xuXHRleHBvcnRzLlRhZ1RyZWUgPSBUYWdUcmVlOyAvLyBleHBvcnQgY2xhc3MgXG5cdFRhZ1RyZWUucHJvdG90eXBlLmNvdW50ZXIgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2NvdW50ZXI7IH1cblx0VGFnVHJlZS5wcm90b3R5cGUuc2V0Q291bnRlciA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9jb3VudGVyID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFRhZ1RyZWUucHJvdG90eXBlLmNvbmRpdGlvbnMgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2NvbmRpdGlvbnM7IH1cblx0VGFnVHJlZS5wcm90b3R5cGUuc2V0Q29uZGl0aW9ucyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9jb25kaXRpb25zID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFRhZ1RyZWUucHJvdG90eXBlLmJsb2NrcyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fYmxvY2tzOyB9XG5cdFRhZ1RyZWUucHJvdG90eXBlLnNldEJsb2NrcyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9ibG9ja3MgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0VGFnVHJlZS5wcm90b3R5cGUuY2FjaGVyID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9jYWNoZXI7IH1cblx0VGFnVHJlZS5wcm90b3R5cGUuc2V0Q2FjaGVyID0gZnVuY3Rpb24odil7IHRoaXMuX2NhY2hlciA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0VGFnVHJlZS5wcm90b3R5cGUucGFyZW50ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmVudCB8fCAodGhpcy5fcGFyZW50ID0gdGhpcy5fb3duZXIucGFyZW50KCkpO1xuXHR9O1xuXHRcblx0VGFnVHJlZS5wcm90b3R5cGUubmV4dENhY2hlS2V5ID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHJvb3QgPSB0aGlzLl9vd25lcjtcblx0XHRcblx0XHQvLyBpZiB3ZSB3YW50IHRvIGNhY2hlIGV2ZXJ5dGhpbmcgb24gcm9vdFxuXHRcdHZhciBudW0gPSArK3RoaXMuX2NvdW50ZXI7XG5cdFx0dmFyIGJhc2UgPSBcIkFcIi5jaGFyQ29kZUF0KDApO1xuXHRcdHZhciBzdHIgPSBcIlwiO1xuXHRcdFxuXHRcdHdoaWxlICh0cnVlKXtcblx0XHRcdG51bSAtPSAxO1xuXHRcdFx0c3RyID0gU3RyaW5nLmZyb21DaGFyQ29kZShiYXNlICsgKG51bSAlIDI2KSkgKyBzdHI7XG5cdFx0XHRudW0gPSBNYXRoLmZsb29yKG51bSAvIDI2KTtcblx0XHRcdGlmIChudW0gPD0gMCkgeyBicmVhazsgfTtcblx0XHR9O1xuXHRcdFxuXHRcdHN0ciA9ICh0aGlzLl9vd25lci50eXBlKCkgaW5zdGFuY2VvZiBTZWxmID8gKFwiJFwiKSA6IChcIiQkXCIpKSArIHN0ci50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiBzdHI7XG5cdFx0cmV0dXJuIG51bTtcblx0fTtcblx0XG5cdFRhZ1RyZWUucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAobGlzdCl7XG5cdFx0aWYgKGxpc3QgaW5zdGFuY2VvZiBMaXN0Tm9kZSkge1xuXHRcdFx0Ly8gcCBcImlzIGEgbGlzdCBub2RlISEge2xpc3QuY291bnR9XCJcblx0XHRcdC8vIHdlIHN0aWxsIHdhbnQgdGhlIGluZGVudGF0aW9uIGlmIHdlIGFyZSBub3QgaW4gYSB0ZW1wbGF0ZVxuXHRcdFx0Ly8gb3IsIHJhdGhlciAtIHdlIHdhbnQgdGhlIGJsb2NrIHRvIGdldCB0aGUgaW5kZW50YXRpb24gLSBub3QgdGhlIHRyZWVcblx0XHRcdHRoaXMuX2luZGVudGF0aW9uIHx8ICh0aGlzLl9pbmRlbnRhdGlvbiA9IGxpc3QuX2luZGVudGF0aW9uKTsgLy8gaWYgbGlzdC5jb3VudCA+IDFcblx0XHRcdHJldHVybiBsaXN0Lm5vZGVzKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBjb21wYWN0X18obGlzdCBpbnN0YW5jZW9mIEFycmF5ID8gKGxpc3QpIDogKFtsaXN0XSkpO1xuXHRcdH07XG5cdH07XG5cdFxuXHRUYWdUcmVlLnByb3RvdHlwZS5yb290ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMub3B0aW9uKCdyb290Jyk7XG5cdH07XG5cdFxuXHRUYWdUcmVlLnByb3RvdHlwZS5yZWFjdGl2ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLm9wdGlvbigncmVhY3RpdmUnKTtcblx0fTtcblx0XG5cdFRhZ1RyZWUucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0dGhpcy5yZW1hcChmdW5jdGlvbihjKSB7IHJldHVybiBjLmNvbnN1bWUoc2VsZik7IH0pO1xuXHRcdHJldHVybiBzZWxmO1xuXHR9O1xuXHRcblx0VGFnVHJlZS5wcm90b3R5cGUuc3RhdGljID0gZnVuY3Rpb24gKCl7XG5cdFx0Ly8gZXZlcnkgcmVhbCBub2RlXG5cdFx0cmV0dXJuIHRoaXMuX3N0YXRpYyA9PSBudWxsID8gKHRoaXMuX3N0YXRpYyA9IHRoaXMuZXZlcnkoZnVuY3Rpb24oYykgeyByZXR1cm4gKGMgaW5zdGFuY2VvZiBUYWcpIHx8IChjIGluc3RhbmNlb2YgU3RyKSB8fCAoYyBpbnN0YW5jZW9mIE1ldGEpOyB9KSkgOiAodGhpcy5fc3RhdGljKTtcblx0fTtcblx0XG5cdFRhZ1RyZWUucHJvdG90eXBlLnNpbmdsZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9zaW5nbGUgPT0gbnVsbCA/ICh0aGlzLl9zaW5nbGUgPSAodGhpcy5yZWFsQ291bnQoKSA9PSAxID8gKHRoaXMubGFzdCgpKSA6IChmYWxzZSkpKSA6ICh0aGlzLl9zaW5nbGUpO1xuXHR9O1xuXHRcblx0VGFnVHJlZS5wcm90b3R5cGUuaGFzVGFncyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLnNvbWUoZnVuY3Rpb24oYykgeyByZXR1cm4gYyBpbnN0YW5jZW9mIFRhZzsgfSk7XG5cdH07XG5cdFxuXHRUYWdUcmVlLnByb3RvdHlwZS5jID0gZnVuY3Rpb24gKG8pe1xuXHRcdC8vIEZJWE1FIFRFU1Qgd2hhdCBhYm91dCBjb21tZW50cz8/P1xuXHRcdHZhciBzaW5nbGUgPSB0aGlzLnNpbmdsZSgpO1xuXHRcdFxuXHRcdC8vIG5vIGluZGVudGF0aW9uIGlmIHRoaXMgc2hvdWxkIHJldHVyblxuXHRcdGlmIChzaW5nbGUgJiYgKFNUQUNLLmN1cnJlbnQoKSBpbnN0YW5jZW9mIFJldHVybikpIHtcblx0XHRcdHRoaXMuX2luZGVudGF0aW9uID0gbnVsbDtcblx0XHR9O1xuXHRcdFxuXHRcdHZhciBvdXQgPSBUYWdUcmVlLl9fc3VwZXJfXy5jLmNhbGwodGhpcyxvKTtcblx0XHRcblx0XHRpZiAoIXNpbmdsZSB8fCAoc2luZ2xlIGluc3RhbmNlb2YgSWYpKSB7XG5cdFx0XHRyZXR1cm4gKFwiW1wiICsgb3V0ICsgXCJdXCIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gb3V0O1xuXHRcdH07XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBUYWdXcmFwcGVyKCl7IHJldHVybiBWYWx1ZU5vZGUuYXBwbHkodGhpcyxhcmd1bWVudHMpIH07XG5cdFxuXHRzdWJjbGFzcyQoVGFnV3JhcHBlcixWYWx1ZU5vZGUpO1xuXHRleHBvcnRzLlRhZ1dyYXBwZXIgPSBUYWdXcmFwcGVyOyAvLyBleHBvcnQgY2xhc3MgXG5cdFRhZ1dyYXBwZXIucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKCl7XG5cdFx0aWYgKHRoaXMudmFsdWUoKSBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHR0aGlzLnZhbHVlKCkubWFwKGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHYudHJhdmVyc2UoKTsgfSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMudmFsdWUoKS50cmF2ZXJzZSgpO1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRUYWdXcmFwcGVyLnByb3RvdHlwZS5jID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIChcInRhZyR3cmFwKFwiICsgdGhpcy52YWx1ZSgpLmMoe2V4cHJlc3Npb246IHRydWV9KSArIFwiKVwiKTtcblx0fTtcblx0XG5cdFxuXHRmdW5jdGlvbiBUYWdBdHRyaWJ1dGVzKCl7IHJldHVybiBMaXN0Tm9kZS5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XG5cdHN1YmNsYXNzJChUYWdBdHRyaWJ1dGVzLExpc3ROb2RlKTtcblx0ZXhwb3J0cy5UYWdBdHRyaWJ1dGVzID0gVGFnQXR0cmlidXRlczsgLy8gZXhwb3J0IGNsYXNzIFxuXHRUYWdBdHRyaWJ1dGVzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobmFtZSl7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHRoaXMubm9kZXMoKSksIGxlbiA9IGFyeS5sZW5ndGgsIG5vZGUsIHJlcyA9IFtdOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdG5vZGUgPSBhcnlbaV07XG5cdFx0XHRpZiAobm9kZS5rZXkoKSA9PSBuYW1lKSB7IHJldHVybiBub2RlIH07XG5cdFx0fTtcblx0XHRyZXR1cm4gcmVzO1xuXHR9O1xuXHRcblx0XG5cdGZ1bmN0aW9uIFRhZ0F0dHIoayx2KXtcblx0XHQvLyBwIFwiaW5pdCBUYWdBdHRyaWJ1dGVcIiwgJDBcblx0XHR0aGlzLl90cmF2ZXJzZWQgPSBmYWxzZTtcblx0XHR0aGlzLl9rZXkgPSBrO1xuXHRcdHRoaXMuX3ZhbHVlID0gdjtcblx0fTtcblx0XG5cdHN1YmNsYXNzJChUYWdBdHRyLE5vZGUpO1xuXHRleHBvcnRzLlRhZ0F0dHIgPSBUYWdBdHRyOyAvLyBleHBvcnQgY2xhc3MgXG5cdFRhZ0F0dHIucHJvdG90eXBlLmtleSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fa2V5OyB9XG5cdFRhZ0F0dHIucHJvdG90eXBlLnNldEtleSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9rZXkgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0VGFnQXR0ci5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3ZhbHVlOyB9XG5cdFRhZ0F0dHIucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24odil7IHRoaXMuX3ZhbHVlID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRUYWdBdHRyLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmICh0aGlzLnZhbHVlKCkpIHsgdGhpcy52YWx1ZSgpLnRyYXZlcnNlKCkgfTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFRhZ0F0dHIucHJvdG90eXBlLnBvcHVsYXRlID0gZnVuY3Rpb24gKG9iail7XG5cdFx0b2JqLmFkZCh0aGlzLmtleSgpLHRoaXMudmFsdWUoKSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRUYWdBdHRyLnByb3RvdHlwZS5jID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIFwiYXR0cmlidXRlXCI7XG5cdH07XG5cdFxuXHRcblx0ZnVuY3Rpb24gVGFnRmxhZyh2YWx1ZSl7XG5cdFx0dGhpcy5fdHJhdmVyc2VkID0gZmFsc2U7XG5cdFx0dGhpcy5fdmFsdWUgPSB2YWx1ZTtcblx0XHR0aGlzO1xuXHR9O1xuXHRcblx0c3ViY2xhc3MkKFRhZ0ZsYWcsTm9kZSk7XG5cdGV4cG9ydHMuVGFnRmxhZyA9IFRhZ0ZsYWc7IC8vIGV4cG9ydCBjbGFzcyBcblx0VGFnRmxhZy5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3ZhbHVlOyB9XG5cdFRhZ0ZsYWcucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24odil7IHRoaXMuX3ZhbHVlID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFRhZ0ZsYWcucHJvdG90eXBlLnRvZ2dsZXIgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3RvZ2dsZXI7IH1cblx0VGFnRmxhZy5wcm90b3R5cGUuc2V0VG9nZ2xlciA9IGZ1bmN0aW9uKHYpeyB0aGlzLl90b2dnbGVyID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRUYWdGbGFnLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmICghKCh0eXBlb2YgdGhpcy5fdmFsdWU9PSdzdHJpbmcnfHx0aGlzLl92YWx1ZSBpbnN0YW5jZW9mIFN0cmluZykpKSB7XG5cdFx0XHR0aGlzLl92YWx1ZS50cmF2ZXJzZSgpO1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRUYWdGbGFnLnByb3RvdHlwZS5jID0gZnVuY3Rpb24gKCl7XG5cdFx0aWYgKHRoaXMudmFsdWUoKSBpbnN0YW5jZW9mIE5vZGUpIHtcblx0XHRcdHJldHVybiAoXCIuZmxhZyhcIiArICh0aGlzLnZhbHVlKCkuYygpKSArIFwiKVwiKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIChcIi5mbGFnKFwiICsgaGVscGVycy5zaW5nbGVxdW90ZSh0aGlzLnZhbHVlKCkpICsgXCIpXCIpO1xuXHRcdH07XG5cdH07XG5cdFxuXHRcblx0XG5cdFxuXHRcblx0XG5cdC8vIFNFTEVDVE9SU1xuXHRcblx0XG5cdGZ1bmN0aW9uIFNlbGVjdG9yKGxpc3Qsb3B0aW9ucyl7XG5cdFx0dGhpcy5fbm9kZXMgPSBsaXN0IHx8IFtdO1xuXHRcdHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuXHR9O1xuXHRcblx0c3ViY2xhc3MkKFNlbGVjdG9yLExpc3ROb2RlKTtcblx0ZXhwb3J0cy5TZWxlY3RvciA9IFNlbGVjdG9yOyAvLyBleHBvcnQgY2xhc3MgXG5cdFNlbGVjdG9yLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAocGFydCx0eXApe1xuXHRcdC8vIHAgXCJzZWxlY3QgYWRkIVwiLHBhcnQsdHlwXG5cdFx0Ly8gbWFyayBpZiBzcGVjaWFsP1xuXHRcdHRoaXMucHVzaChwYXJ0KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFNlbGVjdG9yLnByb3RvdHlwZS5ncm91cCA9IGZ1bmN0aW9uICgpe1xuXHRcdC8vIGNvbnNvbGUubG9nIFwiZ3JvdXBlZCFcIlxuXHRcdC8vIGZvciBub3cgd2Ugc2ltcGx5IGFkZCBhIGNvbW1hXG5cdFx0Ly8gaG93IHdvdWxkIHRoaXMgd29yayBmb3IgZHN0P1xuXHRcdHRoaXMuX25vZGVzLnB1c2gobmV3IFNlbGVjdG9yR3JvdXAoXCIsXCIpKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFNlbGVjdG9yLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBzdHIgPSBcIlwiO1xuXHRcdHZhciBhcnkgPSBbXTtcblx0XHRcblx0XHRmb3IgKHZhciBpID0gMCwgaXRlbXMgPSBpdGVyJCh0aGlzLm5vZGVzKCkpLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0dmFyIHZhbCA9IGl0ZW1zW2ldLmMoKTtcblx0XHRcdGlmICgodHlwZW9mIHZhbD09J3N0cmluZyd8fHZhbCBpbnN0YW5jZW9mIFN0cmluZykpIHtcblx0XHRcdFx0c3RyID0gKFwiXCIgKyBzdHIgKyB2YWwpO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiAoXCInXCIgKyBzdHIgKyBcIidcIik7XG5cdH07XG5cdFxuXHRcblx0U2VsZWN0b3IucHJvdG90eXBlLmpzID0gZnVuY3Rpb24gKG8pe1xuXHRcdHZhciB0eXAgPSB0aGlzLm9wdGlvbigndHlwZScpO1xuXHRcdHZhciBxID0gY19fKHRoaXMucXVlcnkoKSk7XG5cdFx0XG5cdFx0aWYgKHR5cCA9PSAnJScpIHtcblx0XHRcdHJldHVybiAoXCJxJChcIiArIHEgKyBcIixcIiArIG8uc2NvcGUoKS5jb250ZXh0KCkuYyh7ZXhwbGljaXQ6IHRydWV9KSArIFwiKVwiKTsgLy8gZXhwbGljaXQgY29udGV4dFxuXHRcdH0gZWxzZSBpZiAodHlwID09ICclJScpIHtcblx0XHRcdHJldHVybiAoXCJxJCQoXCIgKyBxICsgXCIsXCIgKyBvLnNjb3BlKCkuY29udGV4dCgpLmMoe2V4cGxpY2l0OiB0cnVlfSkgKyBcIilcIik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiAoXCJxXCIgKyB0eXAgKyBcIihcIiArIHEgKyBcIilcIik7XG5cdFx0fTtcblx0XHRcblx0XHQvLyByZXR1cm4gXCJ7dHlwfSB7c2NvcGVkfSAtIHthbGx9XCJcblx0fTtcblx0XG5cdFxuXHRmdW5jdGlvbiBTZWxlY3RvclBhcnQoKXsgcmV0dXJuIFZhbHVlTm9kZS5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XG5cdHN1YmNsYXNzJChTZWxlY3RvclBhcnQsVmFsdWVOb2RlKTtcblx0ZXhwb3J0cy5TZWxlY3RvclBhcnQgPSBTZWxlY3RvclBhcnQ7IC8vIGV4cG9ydCBjbGFzcyBcblx0U2VsZWN0b3JQYXJ0LnByb3RvdHlwZS5jID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIGNfXyh0aGlzLl92YWx1ZSk7XG5cdFx0Ly8gXCJ7dmFsdWUuY31cIlxuXHR9O1xuXHRcblx0ZnVuY3Rpb24gU2VsZWN0b3JHcm91cCgpeyByZXR1cm4gU2VsZWN0b3JQYXJ0LmFwcGx5KHRoaXMsYXJndW1lbnRzKSB9O1xuXHRcblx0c3ViY2xhc3MkKFNlbGVjdG9yR3JvdXAsU2VsZWN0b3JQYXJ0KTtcblx0ZXhwb3J0cy5TZWxlY3Rvckdyb3VwID0gU2VsZWN0b3JHcm91cDsgLy8gZXhwb3J0IGNsYXNzIFxuXHRTZWxlY3Rvckdyb3VwLnByb3RvdHlwZS5jID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIFwiLFwiO1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gU2VsZWN0b3JUeXBlKCl7IHJldHVybiBTZWxlY3RvclBhcnQuYXBwbHkodGhpcyxhcmd1bWVudHMpIH07XG5cdFxuXHRzdWJjbGFzcyQoU2VsZWN0b3JUeXBlLFNlbGVjdG9yUGFydCk7XG5cdGV4cG9ydHMuU2VsZWN0b3JUeXBlID0gU2VsZWN0b3JUeXBlOyAvLyBleHBvcnQgY2xhc3MgXG5cdFNlbGVjdG9yVHlwZS5wcm90b3R5cGUuYyA9IGZ1bmN0aW9uICgpe1xuXHRcdC8vIHN1cHBvcnRcblx0XHQvLyBwIFwic2VsZWN0b3J0eXBlIHt2YWx1ZX1cIlxuXHRcdC8vIHZhciBvdXQgPSB2YWx1ZS5jXG5cdFx0dmFyIG5hbWUgPSB0aGlzLnZhbHVlKCkubmFtZSgpO1xuXHRcdFxuXHRcdC8vIGF0IGxlYXN0IGJlIHZlcnkgY29uc2VydmF0aXZlIGFib3V0IHdoaWNoIHRhZ3Mgd2Vcblx0XHQvLyBjYW4gZHJvcCB0aGUgdGFnIGZvcj9cblx0XHQvLyBvdXQgaW4gVEFHX1RZUEVTLkhUTUwgPyBcblx0XHRyZXR1cm4gaWR4JChuYW1lLFRBR19UWVBFUy5IVE1MKSA+PSAwID8gKG5hbWUpIDogKHRoaXMudmFsdWUoKS5zZWwoKSk7XG5cdH07XG5cdFxuXHRcblx0ZnVuY3Rpb24gU2VsZWN0b3JVbml2ZXJzYWwoKXsgcmV0dXJuIFNlbGVjdG9yUGFydC5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XG5cdHN1YmNsYXNzJChTZWxlY3RvclVuaXZlcnNhbCxTZWxlY3RvclBhcnQpO1xuXHRleHBvcnRzLlNlbGVjdG9yVW5pdmVyc2FsID0gU2VsZWN0b3JVbml2ZXJzYWw7IC8vIGV4cG9ydCBjbGFzcyBcblx0XG5cdFxuXHRmdW5jdGlvbiBTZWxlY3Rvck5hbWVzcGFjZSgpeyByZXR1cm4gU2VsZWN0b3JQYXJ0LmFwcGx5KHRoaXMsYXJndW1lbnRzKSB9O1xuXHRcblx0c3ViY2xhc3MkKFNlbGVjdG9yTmFtZXNwYWNlLFNlbGVjdG9yUGFydCk7XG5cdGV4cG9ydHMuU2VsZWN0b3JOYW1lc3BhY2UgPSBTZWxlY3Rvck5hbWVzcGFjZTsgLy8gZXhwb3J0IGNsYXNzIFxuXHRcblx0XG5cdGZ1bmN0aW9uIFNlbGVjdG9yQ2xhc3MoKXsgcmV0dXJuIFNlbGVjdG9yUGFydC5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XG5cdHN1YmNsYXNzJChTZWxlY3RvckNsYXNzLFNlbGVjdG9yUGFydCk7XG5cdGV4cG9ydHMuU2VsZWN0b3JDbGFzcyA9IFNlbGVjdG9yQ2xhc3M7IC8vIGV4cG9ydCBjbGFzcyBcblx0U2VsZWN0b3JDbGFzcy5wcm90b3R5cGUuYyA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmICh0aGlzLl92YWx1ZSBpbnN0YW5jZW9mIE5vZGUpIHtcblx0XHRcdHJldHVybiAoXCIuJytcIiArICh0aGlzLl92YWx1ZS5jKCkpICsgXCIrJ1wiKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIChcIi5cIiArIGNfXyh0aGlzLl92YWx1ZSkpO1xuXHRcdH07XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBTZWxlY3RvcklkKCl7IHJldHVybiBTZWxlY3RvclBhcnQuYXBwbHkodGhpcyxhcmd1bWVudHMpIH07XG5cdFxuXHRzdWJjbGFzcyQoU2VsZWN0b3JJZCxTZWxlY3RvclBhcnQpO1xuXHRleHBvcnRzLlNlbGVjdG9ySWQgPSBTZWxlY3RvcklkOyAvLyBleHBvcnQgY2xhc3MgXG5cdFNlbGVjdG9ySWQucHJvdG90eXBlLmMgPSBmdW5jdGlvbiAoKXtcblx0XHRpZiAodGhpcy5fdmFsdWUgaW5zdGFuY2VvZiBOb2RlKSB7XG5cdFx0XHRyZXR1cm4gKFwiIycrXCIgKyAodGhpcy5fdmFsdWUuYygpKSArIFwiKydcIik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiAoXCIjXCIgKyBjX18odGhpcy5fdmFsdWUpKTtcblx0XHR9O1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gU2VsZWN0b3JDb21iaW5hdG9yKCl7IHJldHVybiBTZWxlY3RvclBhcnQuYXBwbHkodGhpcyxhcmd1bWVudHMpIH07XG5cdFxuXHRzdWJjbGFzcyQoU2VsZWN0b3JDb21iaW5hdG9yLFNlbGVjdG9yUGFydCk7XG5cdGV4cG9ydHMuU2VsZWN0b3JDb21iaW5hdG9yID0gU2VsZWN0b3JDb21iaW5hdG9yOyAvLyBleHBvcnQgY2xhc3MgXG5cdFNlbGVjdG9yQ29tYmluYXRvci5wcm90b3R5cGUuYyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiAoXCJcIiArIGNfXyh0aGlzLl92YWx1ZSkpO1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gU2VsZWN0b3JQc2V1ZG9DbGFzcygpeyByZXR1cm4gU2VsZWN0b3JQYXJ0LmFwcGx5KHRoaXMsYXJndW1lbnRzKSB9O1xuXHRcblx0c3ViY2xhc3MkKFNlbGVjdG9yUHNldWRvQ2xhc3MsU2VsZWN0b3JQYXJ0KTtcblx0ZXhwb3J0cy5TZWxlY3RvclBzZXVkb0NsYXNzID0gU2VsZWN0b3JQc2V1ZG9DbGFzczsgLy8gZXhwb3J0IGNsYXNzIFxuXHRcblx0XG5cdGZ1bmN0aW9uIFNlbGVjdG9yQXR0cmlidXRlKGxlZnQsb3AscmlnaHQpe1xuXHRcdHRoaXMuX2xlZnQgPSBsZWZ0O1xuXHRcdHRoaXMuX29wID0gb3A7XG5cdFx0dGhpcy5fcmlnaHQgPSB0aGlzLl92YWx1ZSA9IHJpZ2h0O1xuXHR9O1xuXHRcblx0c3ViY2xhc3MkKFNlbGVjdG9yQXR0cmlidXRlLFNlbGVjdG9yUGFydCk7XG5cdGV4cG9ydHMuU2VsZWN0b3JBdHRyaWJ1dGUgPSBTZWxlY3RvckF0dHJpYnV0ZTsgLy8gZXhwb3J0IGNsYXNzIFxuXHRTZWxlY3RvckF0dHJpYnV0ZS5wcm90b3R5cGUuYyA9IGZ1bmN0aW9uICgpe1xuXHRcdC8vIFRPRE8gcG9zc2libHkgc3VwcG9ydCAudG9TZWwgb3Igc2VsJCh2KSBmb3IgaXRlbXMgaW5zaWRlIHF1ZXJ5XG5cdFx0Ly8gY291bGQgZWFzaWx5IGRvIGl0IHdpdGggYSBoZWxwZXItZnVuY3Rpb24gdGhhdCBpcyBhZGRlZCB0byB0aGUgdG9wIG9mIHRoZSBmaWxlc2NvcGVcblx0XHRpZiAodGhpcy5fcmlnaHQgaW5zdGFuY2VvZiBTdHIpIHtcblx0XHRcdHJldHVybiAoXCJbXCIgKyAodGhpcy5fbGVmdC5jKCkpICsgKHRoaXMuX29wKSArICh0aGlzLl9yaWdodC5jKCkpICsgXCJdXCIpO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5fcmlnaHQpIHtcblx0XHRcdC8vIHRoaXMgaXMgbm90IGF0IGFsbCBnb29kXG5cdFx0XHRyZXR1cm4gKFwiW1wiICsgKHRoaXMuX2xlZnQuYygpKSArICh0aGlzLl9vcCkgKyBcIlxcXCInK1wiICsgY19fKHRoaXMuX3JpZ2h0KSArIFwiKydcXFwiXVwiKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIChcIltcIiArICh0aGlzLl9sZWZ0LmMoKSkgKyBcIl1cIik7XG5cdFx0XHRcblx0XHRcdC8vIC4uLlxuXHRcdH07XG5cdH07XG5cdFxuXHRcblx0XG5cdFxuXHQvLyBERUZFUlxuXHRcblx0ZnVuY3Rpb24gQXdhaXQoKXsgcmV0dXJuIFZhbHVlTm9kZS5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XG5cdHN1YmNsYXNzJChBd2FpdCxWYWx1ZU5vZGUpO1xuXHRleHBvcnRzLkF3YWl0ID0gQXdhaXQ7IC8vIGV4cG9ydCBjbGFzcyBcblx0QXdhaXQucHJvdG90eXBlLmZ1bmMgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2Z1bmM7IH1cblx0QXdhaXQucHJvdG90eXBlLnNldEZ1bmMgPSBmdW5jdGlvbih2KXsgdGhpcy5fZnVuYyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0QXdhaXQucHJvdG90eXBlLmpzID0gZnVuY3Rpb24gKG8pe1xuXHRcdC8vIGludHJvZHVjZSBhIHV0aWwgaGVyZSwgbm8/XG5cdFx0cmV0dXJuIENBTEwoT1AoJy4nLG5ldyBVdGlsLlByb21pc2lmeShbdGhpcy52YWx1ZSgpXSksJ3RoZW4nKSxbdGhpcy5mdW5jKCldKS5jKCk7XG5cdFx0Ly8gdmFsdWUuY1xuXHR9O1xuXHRcblx0QXdhaXQucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKG8pe1xuXHRcdC8vIHRoaW5ncyBhcmUgbm93IHRyYXZlcnNlZCBpbiBhIHNvbWV3aGF0IGNoYW90aWMgb3JkZXIuIE5lZWQgdG8gdGlnaHRlblxuXHRcdC8vIENyZWF0ZSBhd2FpdCBmdW5jdGlvbiAtIHB1c2ggdGhpcyB2YWx1ZSB1cCB0byBibG9jaywgdGFrZSB0aGUgb3V0ZXJcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0c2VsZi52YWx1ZSgpLnRyYXZlcnNlKCk7XG5cdFx0XG5cdFx0dmFyIGJsb2NrID0gby51cChCbG9jayk7IC8vIG9yIHVwIHRvIHRoZSBjbG9zZXN0IEZVTkNUSU9OP1xuXHRcdHZhciBvdXRlciA9IG8ucmVsYXRpdmUoYmxvY2ssMSk7XG5cdFx0dmFyIHBhciA9IG8ucmVsYXRpdmUoc2VsZiwtMSk7XG5cdFx0XG5cdFx0Ly8gcCBcIkJsb2NrIHtibG9ja30ge291dGVyfSB7cGFyfVwiXG5cdFx0XG5cdFx0c2VsZi5zZXRGdW5jKG5ldyBBc3luY0Z1bmMoW10sW10pKTtcblx0XHQvLyBub3cgd2UgbW92ZSB0aGlzIG5vZGUgdXAgdG8gdGhlIGJsb2NrXG5cdFx0c2VsZi5mdW5jKCkuYm9keSgpLnNldE5vZGVzKGJsb2NrLmRlZmVycyhvdXRlcixzZWxmKSk7XG5cdFx0XG5cdFx0Ly8gaWYgdGhlIG91dGVyIGlzIGEgdmFyLWFzc2lnbm1lbnQsIHdlIGNhbiBzaW1wbHkgc2V0IHRoZSBwYXJhbXNcblx0XHRpZiAocGFyIGluc3RhbmNlb2YgQXNzaWduKSB7XG5cdFx0XHRwYXIubGVmdCgpLnRyYXZlcnNlKCk7XG5cdFx0XHR2YXIgbGZ0ID0gcGFyLmxlZnQoKS5ub2RlKCk7XG5cdFx0XHQvLyBwIFwiQXN5bmMgYXNzaWdubWVudCB7cGFyfSB7bGZ0fVwiXG5cdFx0XHQvLyBDYW4gYmUgYSB0dXBsZSBhcyB3ZWxsLCBubz9cblx0XHRcdGlmIChsZnQgaW5zdGFuY2VvZiBWYXJSZWZlcmVuY2UpIHtcblx0XHRcdFx0Ly8gdGhlIHBhcmFtIGlzIGFscmVhZHkgcmVnaXN0ZXJlZD9cblx0XHRcdFx0Ly8gc2hvdWxkIG5vdCBmb3JjZSB0aGUgbmFtZSBhbHJlYWR5Pz9cblx0XHRcdFx0Ly8gYmV3YXJlIG9mIGJ1Z3Ncblx0XHRcdFx0c2VsZi5mdW5jKCkucGFyYW1zKCkuYXQoMCx0cnVlLGxmdC52YXJpYWJsZSgpLm5hbWUoKSk7XG5cdFx0XHR9IGVsc2UgaWYgKGxmdCBpbnN0YW5jZW9mIFR1cGxlKSB7XG5cdFx0XHRcdC8vIGlmIHRoaXMgYW4gdW5mYW5jeSB0dXBsZSwgd2l0aCBvbmx5IHZhcnNcblx0XHRcdFx0Ly8gd2UgY2FuIGp1c3QgdXNlIGFyZ3VtZW50c1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHBhci50eXBlKCkgPT0gJ3ZhcicgJiYgIWxmdC5oYXNTcGxhdCgpKSB7XG5cdFx0XHRcdFx0Ly8gcCBcIlNJTVBMSUZZISB7bGZ0Lm5vZGVzWzBdfVwiXG5cdFx0XHRcdFx0bGZ0Lm1hcChmdW5jdGlvbihlbCxpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gc2VsZi5mdW5jKCkucGFyYW1zKCkuYXQoaSx0cnVlLGVsLnZhbHVlKCkpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSwgZG8gdGhlIHdob2xlIHR1cGxlXG5cdFx0XHRcdFx0Ly8gbWFrZSBzdXJlIGl0IGlzIGEgdmFyIGFzc2lnbm1lbnQ/XG5cdFx0XHRcdFx0cGFyLnNldFJpZ2h0KEFSR1VNRU5UUyk7XG5cdFx0XHRcdFx0c2VsZi5mdW5jKCkuYm9keSgpLnVuc2hpZnQocGFyKTtcblx0XHRcdFx0fTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHJlZ3VsYXIgc2V0dGVyc1xuXHRcdFx0XHRwYXIuc2V0UmlnaHQoc2VsZi5mdW5jKCkucGFyYW1zKCkuYXQoMCx0cnVlKSk7XG5cdFx0XHRcdHNlbGYuZnVuYygpLmJvZHkoKS51bnNoaWZ0KHBhcik7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0XG5cdFx0Ly8gSWYgaXQgaXMgYW4gYWR2YW5jZSB0dXBsZSBvciBzb21ldGhpbmcsIGl0IHNob3VsZCBiZSBwb3NzaWJsZSB0b1xuXHRcdC8vIGZlZWQgaW4gdGhlIHBhcmFtbGlzdCwgYW5kIGxldCB0aGUgdHVwbGUgaGFuZGxlIGl0IGFzIGlmIGl0IHdhcyBhbnlcblx0XHQvLyBvdGhlciB2YWx1ZVxuXHRcdFxuXHRcdC8vIENBU0UgSWYgdGhpcyBpcyBhIHR1cGxlIC8gbXVsdGlzZXQgd2l0aCBtb3JlIHRoYW4gb25lIGFzeW5jIHZhbHVlXG5cdFx0Ly8gd2UgbmVlZCB0byB0aGluayBkaWZmZXJlbnRseS5cblx0XHRcblx0XHQvLyBub3cgd2UgbmVlZCB0byB2aXNpdCB0aGUgZnVuY3Rpb24gYXMgd2VsbFxuXHRcdHNlbGYuZnVuYygpLnRyYXZlcnNlKCk7XG5cdFx0Ly8gcHVsbCB0aGUgb3V0ZXIgaW5cblx0XHRyZXR1cm4gc2VsZjtcblx0fTtcblx0XG5cdGZ1bmN0aW9uIEFzeW5jRnVuYyhwYXJhbXMsYm9keSxuYW1lLHRhcmdldCxvcHRpb25zKXtcblx0XHRBc3luY0Z1bmMuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcyxwYXJhbXMsYm9keSxuYW1lLHRhcmdldCxvcHRpb25zKTtcblx0fTtcblx0XG5cdHN1YmNsYXNzJChBc3luY0Z1bmMsRnVuYyk7XG5cdGV4cG9ydHMuQXN5bmNGdW5jID0gQXN5bmNGdW5jOyAvLyBleHBvcnQgY2xhc3MgXG5cdEFzeW5jRnVuYy5wcm90b3R5cGUuc2NvcGV0eXBlID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIExhbWJkYVNjb3BlO1xuXHR9O1xuXHRcblx0Ly8gbmVlZCB0byBvdmVycmlkZSwgc2luY2Ugd2Ugd29udCBkbyBpbXBsaWNpdCByZXR1cm5zXG5cdC8vIGRlZiBqc1xuXHQvLyBcdHZhciBjb2RlID0gc2NvcGUuY1xuXHQvLyBcdHJldHVybiBcImZ1bmN0aW9uICh7cGFyYW1zLmN9KVwiICsgY29kZS53cmFwXG5cdDtcblx0XG5cdFxuXHRcblx0Ly8gSU1QT1JUU1xuXHRcblx0ZnVuY3Rpb24gSW1wb3J0U3RhdGVtZW50KGltcG9ydHMsc291cmNlLG5zKXtcblx0XHR0aGlzLl90cmF2ZXJzZWQgPSBmYWxzZTtcblx0XHR0aGlzLl9pbXBvcnRzID0gaW1wb3J0cztcblx0XHR0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XG5cdFx0dGhpcy5fbnMgPSBucztcblx0XHR0aGlzO1xuXHR9O1xuXHRcblx0c3ViY2xhc3MkKEltcG9ydFN0YXRlbWVudCxTdGF0ZW1lbnQpO1xuXHRleHBvcnRzLkltcG9ydFN0YXRlbWVudCA9IEltcG9ydFN0YXRlbWVudDsgLy8gZXhwb3J0IGNsYXNzIFxuXHRJbXBvcnRTdGF0ZW1lbnQucHJvdG90eXBlLm5zID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9uczsgfVxuXHRJbXBvcnRTdGF0ZW1lbnQucHJvdG90eXBlLnNldE5zID0gZnVuY3Rpb24odil7IHRoaXMuX25zID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdEltcG9ydFN0YXRlbWVudC5wcm90b3R5cGUuaW1wb3J0cyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5faW1wb3J0czsgfVxuXHRJbXBvcnRTdGF0ZW1lbnQucHJvdG90eXBlLnNldEltcG9ydHMgPSBmdW5jdGlvbih2KXsgdGhpcy5faW1wb3J0cyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRJbXBvcnRTdGF0ZW1lbnQucHJvdG90eXBlLnNvdXJjZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fc291cmNlOyB9XG5cdEltcG9ydFN0YXRlbWVudC5wcm90b3R5cGUuc2V0U291cmNlID0gZnVuY3Rpb24odil7IHRoaXMuX3NvdXJjZSA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdEltcG9ydFN0YXRlbWVudC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAoKXtcblx0XHRpZiAodGhpcy5fbnMpIHtcblx0XHRcdHRoaXMuX25zdmFyIHx8ICh0aGlzLl9uc3ZhciA9IHRoaXMuc2NvcGVfXygpLnJlZ2lzdGVyKHRoaXMuX25zLHRoaXMpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHNyYyA9IHRoaXMuc291cmNlKCkuYygpO1xuXHRcdFx0dmFyIG0gPSBzcmMubWF0Y2goLyhcXHcrKShcXC5qc3xpbWJhKT9bXFxcIlxcJ10kLyk7XG5cdFx0XHR0aGlzLl9hbGlhcyA9IG0gPyAobVsxXSArICckJykgOiAoJ21vZCQnKTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIHNob3VsZCBhbHNvIHJlZ2lzdGVyIHRoZSBpbXBvcnRlZCBpdGVtcywgbm8/XG5cdFx0aWYgKHRoaXMuX2ltcG9ydHMpIHtcblx0XHRcdHZhciBkZWMgPSB0aGlzLl9kZWNsYXJhdGlvbnMgPSBuZXcgVmFyaWFibGVEZWNsYXJhdGlvbihbXSk7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLl9pbXBvcnRzLmxlbmd0aCA9PSAxKSB7XG5cdFx0XHRcdHRoaXMuX2FsaWFzID0gdGhpcy5faW1wb3J0c1swXTtcblx0XHRcdFx0ZGVjLmFkZCh0aGlzLl9hbGlhcyxPUCgnLicsQ0FMTChuZXcgSWRlbnRpZmllcihcInJlcXVpcmVcIiksW3RoaXMuc291cmNlKCldKSx0aGlzLl9hbGlhcykpO1xuXHRcdFx0XHRkZWMudHJhdmVyc2UoKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBkZWMuYWRkKEBhbGlhcyxDQUxMKElkZW50aWZpZXIubmV3KFwicmVxdWlyZVwiKSxbc291cmNlXSkpXG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHQvLyBwIFwiSW1wb3J0U3RhdGVtZW50IGhhcyBpbXBvcnRzIHtAaW1wb3J0czpsZW5ndGh9XCJcblx0XHRcdC8vIEBkZWNsYXJhdGlvbnMgPSBWYXJpYWJsZURlY2xhcmF0aW9uLm5ldyhbXSlcblx0XHRcdHRoaXMuX21vZHVsZWRlY2wgPSBkZWMuYWRkKHRoaXMuX2FsaWFzLENBTEwobmV3IElkZW50aWZpZXIoXCJyZXF1aXJlXCIpLFt0aGlzLnNvdXJjZSgpXSkpO1xuXHRcdFx0dGhpcy5fbW9kdWxlZGVjbC50cmF2ZXJzZSgpO1xuXHRcdFx0XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLl9pbXBvcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHRoaXMuX2ltcG9ydHMpLCBsZW4gPSBhcnkubGVuZ3RoLCBpbXA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdGltcCA9IGFyeVtpXTtcblx0XHRcdFx0XHR0aGlzLl9kZWNsYXJhdGlvbnMuYWRkKGltcCxPUCgnLicsdGhpcy5fbW9kdWxlZGVjbC52YXJpYWJsZSgpLGltcCkpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0ZGVjLnRyYXZlcnNlKCk7XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFxuXHRJbXBvcnRTdGF0ZW1lbnQucHJvdG90eXBlLmpzID0gZnVuY3Rpb24gKG8pe1xuXHRcdFxuXHRcdHZhciBmbmFtZTtcblx0XHRpZiAodGhpcy5fZGVjbGFyYXRpb25zKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZGVjbGFyYXRpb25zLmMoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHZhciByZXEgPSBDQUxMKG5ldyBJZGVudGlmaWVyKFwicmVxdWlyZVwiKSxbdGhpcy5zb3VyY2UoKV0pO1xuXHRcdFxuXHRcdGlmICh0aGlzLl9ucykge1xuXHRcdFx0Ly8gbXVzdCByZWdpc3RlciBucyBhcyBhIHJlYWwgdmFyaWFibGVcblx0XHRcdHJldHVybiAoXCJ2YXIgXCIgKyAodGhpcy5fbnN2YXIuYygpKSArIFwiID0gXCIgKyAocmVxLmMoKSkpO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKHRoaXMuX2ltcG9ydHMpIHtcblx0XHRcdFxuXHRcdFx0dmFyIHNyYyA9IHRoaXMuc291cmNlKCkuYygpO1xuXHRcdFx0dmFyIGFsaWFzID0gW107XG5cdFx0XHR2YXIgdmFycyA9IG5ldyBWYXJCbG9jayhbXSk7XG5cdFx0XHRcblx0XHRcdGlmIChmbmFtZSA9IHNyYy5tYXRjaCgvKFxcdyspKFxcLmpzfGltYmEpP1tcXFwiXFwnXSQvKSkge1xuXHRcdFx0XHRhbGlhcy5wdXNoKGZuYW1lWzFdKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8vIHZhciBhbGlhcyA9IHNyYy5tYXRjaCgvKFxcdyspKFxcLmpzfGltYmEpP1tcXFwiXFwnXSQvKVxuXHRcdFx0Ly8gcCBcInNvdXJjZSB0eXBlIHtzb3VyY2V9XCJcblx0XHRcdC8vIGNyZWF0ZSBhIHJlcXVpcmUgZm9yIHRoZSBzb3VyY2UsIHdpdGggYSB0ZW1wb3JhcnkgbmFtZT9cblx0XHRcdHZhciBvdXQgPSBbcmVxLmNhY2hlKHtuYW1lczogYWxpYXN9KS5jKCldO1xuXHRcdFx0XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQodGhpcy5faW1wb3J0cyksIGxlbiA9IGFyeS5sZW5ndGgsIGltcDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdC8vIHdlIGFsc28gbmVlZCB0byByZWdpc3RlciB0aGVzZSBpbXBvcnRzIGFzIHZhcmlhYmxlcywgbm8/XG5cdFx0XHRcdGltcCA9IGFyeVtpXTtcblx0XHRcdFx0dmFyIG8gPSBPUCgnPScsaW1wLE9QKCcuJyxyZXEsaW1wKSk7XG5cdFx0XHRcdG91dC5wdXNoKChcInZhciBcIiArIChvLmMoKSkpKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiBvdXQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiByZXEuYygpO1xuXHRcdH07XG5cdH07XG5cdFxuXHRJbXBvcnRTdGF0ZW1lbnQucHJvdG90eXBlLmNvbnN1bWUgPSBmdW5jdGlvbiAobm9kZSl7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRcblx0Ly8gRVhQT1JUIFxuXHRcblx0ZnVuY3Rpb24gRXhwb3J0U3RhdGVtZW50KCl7IHJldHVybiBWYWx1ZU5vZGUuYXBwbHkodGhpcyxhcmd1bWVudHMpIH07XG5cdFxuXHRzdWJjbGFzcyQoRXhwb3J0U3RhdGVtZW50LFZhbHVlTm9kZSk7XG5cdGV4cG9ydHMuRXhwb3J0U3RhdGVtZW50ID0gRXhwb3J0U3RhdGVtZW50OyAvLyBleHBvcnQgY2xhc3MgXG5cdEV4cG9ydFN0YXRlbWVudC5wcm90b3R5cGUuanMgPSBmdW5jdGlvbiAobyl7XG5cdFx0dmFyIG5vZGVzID0gdGhpcy5fdmFsdWUubWFwKGZ1bmN0aW9uKGFyZykgeyByZXR1cm4gKFwibW9kdWxlLmV4cG9ydHMuXCIgKyAoYXJnLmMoKSkgKyBcIiA9IFwiICsgKGFyZy5jKCkpKTsgfSk7XG5cdFx0XG5cdFx0aWYgKG5vZGVzLmxlbmd0aCA+IDEgJiYgKHRoaXMudXAoKSBpbnN0YW5jZW9mIFJldHVybikpIHtcblx0XHRcdHJldHVybiAnWycgKyBub2Rlcy5qb2luKCcsJykgKyAnXSc7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBub2Rlcy5qb2luKCc7XFxuJykgKyAnOyc7XG5cdFx0fTtcblx0fTtcblx0XG5cdFxuXHQvLyBVVElMU1xuXHRcblx0ZnVuY3Rpb24gVXRpbChhcmdzKXtcblx0XHR0aGlzLl9hcmdzID0gYXJncztcblx0fTtcblx0XG5cdC8vIHRoaXMgaXMgaG93IHdlIGRlYWwgd2l0aCBpdCBub3dcblx0c3ViY2xhc3MkKFV0aWwsTm9kZSk7XG5cdGV4cG9ydHMuVXRpbCA9IFV0aWw7IC8vIGV4cG9ydCBjbGFzcyBcblx0VXRpbC5wcm90b3R5cGUuYXJncyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fYXJnczsgfVxuXHRVdGlsLnByb3RvdHlwZS5zZXRBcmdzID0gZnVuY3Rpb24odil7IHRoaXMuX2FyZ3MgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFV0aWwuZXh0ZW5kID0gZnVuY3Rpb24gKGEsYil7XG5cdFx0cmV0dXJuIG5ldyBVdGlsLkV4dGVuZChbYSxiXSk7XG5cdH07XG5cdFxuXHRVdGlsLmNhbGxJbWJhID0gZnVuY3Rpb24gKG1ldGgsYXJncyl7XG5cdFx0cmV0dXJuIENBTEwoT1AoJy4nLG5ldyBDb25zdChcIkltYmFcIiksbmV3IElkZW50aWZpZXIobWV0aCkpLGFyZ3MpO1xuXHR9O1xuXHRcblx0VXRpbC5yZXBlYXQgPSBmdW5jdGlvbiAoc3RyLHRpbWVzKXtcblx0XHR2YXIgcmVzID0gJyc7XG5cdFx0d2hpbGUgKHRpbWVzID4gMCl7XG5cdFx0XHRpZiAodGltZXMgJSAyID09IDEpIHtcblx0XHRcdFx0cmVzICs9IHN0cjtcblx0XHRcdH07XG5cdFx0XHRzdHIgKz0gc3RyO1xuXHRcdFx0dGltZXMgPj49IDE7XG5cdFx0fTtcblx0XHRyZXR1cm4gcmVzO1xuXHR9O1xuXHRcblx0XG5cdFxuXHRVdGlsLmtleXMgPSBmdW5jdGlvbiAob2JqKXtcblx0XHR2YXIgbCA9IG5ldyBDb25zdChcIk9iamVjdFwiKTtcblx0XHR2YXIgciA9IG5ldyBJZGVudGlmaWVyKFwia2V5c1wiKTtcblx0XHRyZXR1cm4gQ0FMTChPUCgnLicsbCxyKSxbb2JqXSk7XG5cdH07XG5cdFxuXHRVdGlsLmxlbiA9IGZ1bmN0aW9uIChvYmosY2FjaGUpe1xuXHRcdC8vIHAgXCJMRU4gSEVMUEVSXCIuZ3JlZW5cblx0XHR2YXIgciA9IG5ldyBJZGVudGlmaWVyKFwibGVuZ3RoXCIpO1xuXHRcdHZhciBub2RlID0gT1AoJy4nLG9iaixyKTtcblx0XHRpZiAoY2FjaGUpIHsgbm9kZS5jYWNoZSh7Zm9yY2U6IHRydWUscG9vbDogJ2xlbid9KSB9O1xuXHRcdHJldHVybiBub2RlO1xuXHR9O1xuXHRcblx0VXRpbC5pbmRleE9mID0gZnVuY3Rpb24gKGxmdCxyZ3Qpe1xuXHRcdHZhciBub2RlID0gbmV3IFV0aWwuSW5kZXhPZihbbGZ0LHJndF0pO1xuXHRcdC8vIG5vZGUuY2FjaGUoZm9yY2U6IHllcywgdHlwZTogJ2l0ZXInKSBpZiBjYWNoZVxuXHRcdHJldHVybiBub2RlO1xuXHR9O1xuXHRcblx0VXRpbC5zbGljZSA9IGZ1bmN0aW9uIChvYmosYSxiKXtcblx0XHR2YXIgc2xpY2UgPSBuZXcgSWRlbnRpZmllcihcInNsaWNlXCIpO1xuXHRcdGNvbnNvbGUubG9nKChcInNsaWNlIFwiICsgYSArIFwiIFwiICsgYikpO1xuXHRcdHJldHVybiBDQUxMKE9QKCcuJyxvYmosc2xpY2UpLGNvbXBhY3RfXyhbYSxiXSkpO1xuXHR9O1xuXHRcblx0VXRpbC5pdGVyYWJsZSA9IGZ1bmN0aW9uIChvYmosY2FjaGUpe1xuXHRcdHZhciBub2RlID0gbmV3IFV0aWwuSXRlcmFibGUoW29ial0pO1xuXHRcdGlmIChjYWNoZSkgeyBub2RlLmNhY2hlKHtmb3JjZTogdHJ1ZSxwb29sOiAnaXRlcid9KSB9O1xuXHRcdHJldHVybiBub2RlO1xuXHR9O1xuXHRcblx0XG5cdFxuXHRVdGlsLnVuaW9uID0gZnVuY3Rpb24gKGEsYil7XG5cdFx0cmV0dXJuIG5ldyBVdGlsLlVuaW9uKFthLGJdKTtcblx0XHQvLyBDQUxMKFVOSU9OLFthLGJdKVxuXHR9O1xuXHRcblx0VXRpbC5pbnRlcnNlY3QgPSBmdW5jdGlvbiAoYSxiKXtcblx0XHRyZXR1cm4gbmV3IFV0aWwuSW50ZXJzZWN0KFthLGJdKTtcblx0XHQvLyBDQUxMKElOVEVSU0VDVCxbYSxiXSlcblx0fTtcblx0XG5cdFV0aWwuY291bnRlciA9IGZ1bmN0aW9uIChzdGFydCxjYWNoZSl7XG5cdFx0Ly8gc2hvdWxkIGl0IG5vdCByYXRoZXIgYmUgYSB2YXJpYWJsZT8hP1xuXHRcdHZhciBub2RlID0gbmV3IE51bShzdGFydCk7IC8vIG1ha2Ugc3VyZSBpdCByZWFsbHkgaXMgYSBudW1iZXJcblx0XHRpZiAoY2FjaGUpIHsgbm9kZS5jYWNoZSh7Zm9yY2U6IHRydWUscG9vbDogJ2NvdW50ZXInfSkgfTtcblx0XHRyZXR1cm4gbm9kZTtcblx0fTtcblx0XG5cdFV0aWwuYXJyYXkgPSBmdW5jdGlvbiAoc2l6ZSxjYWNoZSl7XG5cdFx0dmFyIG5vZGUgPSBuZXcgVXRpbC5BcnJheShbc2l6ZV0pO1xuXHRcdGlmIChjYWNoZSkgeyBub2RlLmNhY2hlKHtmb3JjZTogdHJ1ZSxwb29sOiAnbGlzdCd9KSB9O1xuXHRcdHJldHVybiBub2RlO1xuXHR9O1xuXHRcblx0VXRpbC5kZWZpbmVUYWcgPSBmdW5jdGlvbiAodHlwZSxjdG9yLHN1cHIpe1xuXHRcdHJldHVybiBDQUxMKFRBR0RFRixbdHlwZSxjdG9yLHN1cHJdKTtcblx0fTtcblx0XG5cdFxuXHRVdGlsLmRlZmluZUNsYXNzID0gZnVuY3Rpb24gKG5hbWUsc3Vwcixpbml0b3Ipe1xuXHRcdHJldHVybiBDQUxMKENMQVNTREVGLFtuYW1lIHx8IGluaXRvcix0aGlzLnN1cCgpXSk7XG5cdH07XG5cdFxuXHRVdGlsLnByb3RvdHlwZS5pc1N0YW5kYWxvbmUgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gT1BUUy5zdGFuZGFsb25lICE9PSBmYWxzZTtcblx0fTtcblx0XG5cdFV0aWwucHJvdG90eXBlLmpzID0gZnVuY3Rpb24gKG8pe1xuXHRcdHJldHVybiBcImhlbHBlclwiO1xuXHR9O1xuXHRcblx0Ly8gVE9ETyBEZXByZWNhdGUgYW5kIHJlbW92ZVxuXHRVdGlsLlVuaW9uID0gZnVuY3Rpb24gVW5pb24oKXsgcmV0dXJuIFV0aWwuYXBwbHkodGhpcyxhcmd1bWVudHMpIH07XG5cdFxuXHRzdWJjbGFzcyQoVXRpbC5VbmlvbixVdGlsKTtcblx0VXRpbC5Vbmlvbi5wcm90b3R5cGUuaGVscGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuICdmdW5jdGlvbiB1bmlvbiQoYSxiKXtcXG5cdGlmKGEgJiYgYS5fX3VuaW9uKSByZXR1cm4gYS5fX3VuaW9uKGIpO1xcblxcblx0dmFyIHUgPSBhLnNsaWNlKDApO1xcblx0Zm9yKHZhciBpPTAsbD1iLmxlbmd0aDtpPGw7aSsrKSBpZih1LmluZGV4T2YoYltpXSkgPT0gLTEpIHUucHVzaChiW2ldKTtcXG5cdHJldHVybiB1O1xcbn07XFxuJztcblx0fTtcblx0XG5cdFV0aWwuVW5pb24ucHJvdG90eXBlLmpzID0gZnVuY3Rpb24gKG8pe1xuXHRcdHRoaXMuc2NvcGVfXygpLnJvb3QoKS5oZWxwZXIodGhpcyx0aGlzLmhlbHBlcigpKTtcblx0XHQvLyBXaGVuIHRoaXMgaXMgdHJpZ2dlcmVkLCB3ZSBuZWVkIHRvIGFkZCBpdCB0byB0aGUgdG9wIG9mIGZpbGU/XG5cdFx0cmV0dXJuIChcInVuaW9uJChcIiArIHRoaXMuYXJncygpLm1hcChmdW5jdGlvbih2KSB7IHJldHVybiB2LmMoKTsgfSkuam9pbignLCcpICsgXCIpXCIpO1xuXHR9O1xuXHRcblx0Ly8gVE9ETyBEZXByZWNhdGUgYW5kIHJlbW92ZVxuXHRVdGlsLkludGVyc2VjdCA9IGZ1bmN0aW9uIEludGVyc2VjdCgpeyByZXR1cm4gVXRpbC5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XG5cdHN1YmNsYXNzJChVdGlsLkludGVyc2VjdCxVdGlsKTtcblx0VXRpbC5JbnRlcnNlY3QucHJvdG90eXBlLmhlbHBlciA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiAnZnVuY3Rpb24gaW50ZXJzZWN0JChhLGIpe1xcblx0aWYoYSAmJiBhLl9faW50ZXJzZWN0KSByZXR1cm4gYS5fX2ludGVyc2VjdChiKTtcXG5cdHZhciByZXMgPSBbXTtcXG5cdGZvcih2YXIgaT0wLCBsPWEubGVuZ3RoOyBpPGw7IGkrKykge1xcblx0XHR2YXIgdiA9IGFbaV07XFxuXHRcdGlmKGIuaW5kZXhPZih2KSAhPSAtMSkgcmVzLnB1c2godik7XFxuXHR9XFxuXHRyZXR1cm4gcmVzO1xcbn07XFxuJztcblx0fTtcblx0XG5cdFV0aWwuSW50ZXJzZWN0LnByb3RvdHlwZS5qcyA9IGZ1bmN0aW9uIChvKXtcblx0XHQvLyBXaGVuIHRoaXMgaXMgdHJpZ2dlcmVkLCB3ZSBuZWVkIHRvIGFkZCBpdCB0byB0aGUgdG9wIG9mIGZpbGU/XG5cdFx0dGhpcy5zY29wZV9fKCkucm9vdCgpLmhlbHBlcih0aGlzLHRoaXMuaGVscGVyKCkpO1xuXHRcdHJldHVybiAoXCJpbnRlcnNlY3QkKFwiICsgdGhpcy5hcmdzKCkubWFwKGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHYuYygpOyB9KS5qb2luKCcsJykgKyBcIilcIik7XG5cdH07XG5cdFxuXHRVdGlsLkV4dGVuZCA9IGZ1bmN0aW9uIEV4dGVuZCgpeyByZXR1cm4gVXRpbC5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XG5cdHN1YmNsYXNzJChVdGlsLkV4dGVuZCxVdGlsKTtcblx0VXRpbC5FeHRlbmQucHJvdG90eXBlLmpzID0gZnVuY3Rpb24gKG8pe1xuXHRcdC8vIFdoZW4gdGhpcyBpcyB0cmlnZ2VyZWQsIHdlIG5lZWQgdG8gYWRkIGl0IHRvIHRoZSB0b3Agb2YgZmlsZT9cblx0XHRyZXR1cm4gKFwiZXh0ZW5kJChcIiArIGNvbXBhY3RfXyhjYXJ5X18odGhpcy5hcmdzKCkpKS5qb2luKCcsJykgKyBcIilcIik7XG5cdH07XG5cdFxuXHRVdGlsLkluZGV4T2YgPSBmdW5jdGlvbiBJbmRleE9mKCl7IHJldHVybiBVdGlsLmFwcGx5KHRoaXMsYXJndW1lbnRzKSB9O1xuXHRcblx0c3ViY2xhc3MkKFV0aWwuSW5kZXhPZixVdGlsKTtcblx0VXRpbC5JbmRleE9mLnByb3RvdHlwZS5oZWxwZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gJ2Z1bmN0aW9uIGlkeCQoYSxiKXtcXG5cdHJldHVybiAoYiAmJiBiLmluZGV4T2YpID8gYi5pbmRleE9mKGEpIDogW10uaW5kZXhPZi5jYWxsKGEsYik7XFxufTtcXG4nO1xuXHR9O1xuXHRcblx0VXRpbC5JbmRleE9mLnByb3RvdHlwZS5qcyA9IGZ1bmN0aW9uIChvKXtcblx0XHRpZiAodGhpcy5pc1N0YW5kYWxvbmUoKSkge1xuXHRcdFx0dGhpcy5zY29wZV9fKCkucm9vdCgpLmhlbHBlcih0aGlzLHRoaXMuaGVscGVyKCkpO1xuXHRcdFx0Ly8gV2hlbiB0aGlzIGlzIHRyaWdnZXJlZCwgd2UgbmVlZCB0byBhZGQgaXQgdG8gdGhlIHRvcCBvZiBmaWxlP1xuXHRcdFx0cmV0dXJuIChcImlkeCQoXCIgKyB0aGlzLmFyZ3MoKS5tYXAoZnVuY3Rpb24odikgeyByZXR1cm4gdi5jKCk7IH0pLmpvaW4oJywnKSArIFwiKVwiKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIChcIkltYmEuaW5kZXhPZihcIiArIHRoaXMuYXJncygpLm1hcChmdW5jdGlvbih2KSB7IHJldHVybiB2LmMoKTsgfSkuam9pbignLCcpICsgXCIpXCIpO1xuXHRcdH07XG5cdH07XG5cdFxuXHRcblx0VXRpbC5TdWJjbGFzcyA9IGZ1bmN0aW9uIFN1YmNsYXNzKCl7IHJldHVybiBVdGlsLmFwcGx5KHRoaXMsYXJndW1lbnRzKSB9O1xuXHRcblx0c3ViY2xhc3MkKFV0aWwuU3ViY2xhc3MsVXRpbCk7XG5cdFV0aWwuU3ViY2xhc3MucHJvdG90eXBlLmhlbHBlciA9IGZ1bmN0aW9uICgpe1xuXHRcdC8vIHNob3VsZCBhbHNvIGNoZWNrIGlmIGl0IGlzIGEgcmVhbCBwcm9taXNlXG5cdFx0cmV0dXJuICcvLyBoZWxwZXIgZm9yIHN1YmNsYXNzaW5nXFxuZnVuY3Rpb24gc3ViY2xhc3MkKG9iaixzdXApIHtcXG5cdGZvciAodmFyIGsgaW4gc3VwKSB7XFxuXHRcdGlmIChzdXAuaGFzT3duUHJvcGVydHkoaykpIG9ialtrXSA9IHN1cFtrXTtcXG5cdH07XFxuXHQvLyBvYmouX19zdXBlcl9fID0gc3VwO1xcblx0b2JqLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwLnByb3RvdHlwZSk7XFxuXHRvYmouX19zdXBlcl9fID0gb2JqLnByb3RvdHlwZS5fX3N1cGVyX18gPSBzdXAucHJvdG90eXBlO1xcblx0b2JqLnByb3RvdHlwZS5pbml0aWFsaXplID0gb2JqLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG9iajtcXG59O1xcbic7XG5cdH07XG5cdFxuXHRVdGlsLlN1YmNsYXNzLnByb3RvdHlwZS5qcyA9IGZ1bmN0aW9uIChvKXtcblx0XHRpZiAodGhpcy5pc1N0YW5kYWxvbmUoKSkge1xuXHRcdFx0Ly8gV2hlbiB0aGlzIGlzIHRyaWdnZXJlZCwgd2UgbmVlZCB0byBhZGQgaXQgdG8gdGhlIHRvcCBvZiBmaWxlP1xuXHRcdFx0dGhpcy5zY29wZV9fKCkucm9vdCgpLmhlbHBlcih0aGlzLHRoaXMuaGVscGVyKCkpO1xuXHRcdFx0cmV0dXJuIChcInN1YmNsYXNzJChcIiArIHRoaXMuYXJncygpLm1hcChmdW5jdGlvbih2KSB7IHJldHVybiB2LmMoKTsgfSkuam9pbignLCcpICsgXCIpO1xcblwiKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIChcIkltYmEuc3ViY2xhc3MoXCIgKyB0aGlzLmFyZ3MoKS5tYXAoZnVuY3Rpb24odikgeyByZXR1cm4gdi5jKCk7IH0pLmpvaW4oJywnKSArIFwiKTtcXG5cIik7XG5cdFx0fTtcblx0fTtcblx0XG5cdFV0aWwuUHJvbWlzaWZ5ID0gZnVuY3Rpb24gUHJvbWlzaWZ5KCl7IHJldHVybiBVdGlsLmFwcGx5KHRoaXMsYXJndW1lbnRzKSB9O1xuXHRcblx0c3ViY2xhc3MkKFV0aWwuUHJvbWlzaWZ5LFV0aWwpO1xuXHRVdGlsLlByb21pc2lmeS5wcm90b3R5cGUuaGVscGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0Ly8gc2hvdWxkIGFsc28gY2hlY2sgaWYgaXQgaXMgYSByZWFsIHByb21pc2Vcblx0XHRyZXR1cm4gKFwiZnVuY3Rpb24gcHJvbWlzZSQoYSlcXHsgcmV0dXJuIGEgaW5zdGFuY2VvZiBBcnJheSA/IFByb21pc2UuYWxsKGEpIDogKGEgJiYgYS50aGVuID8gYSA6IFByb21pc2UucmVzb2x2ZShhKSk7IFxcfVwiKTtcblx0fTtcblx0XG5cdFV0aWwuUHJvbWlzaWZ5LnByb3RvdHlwZS5qcyA9IGZ1bmN0aW9uIChvKXtcblx0XHRpZiAodGhpcy5pc1N0YW5kYWxvbmUoKSkge1xuXHRcdFx0Ly8gV2hlbiB0aGlzIGlzIHRyaWdnZXJlZCwgd2UgbmVlZCB0byBhZGQgaXQgdG8gdGhlIHRvcCBvZiBmaWxlP1xuXHRcdFx0dGhpcy5zY29wZV9fKCkucm9vdCgpLmhlbHBlcih0aGlzLHRoaXMuaGVscGVyKCkpO1xuXHRcdFx0cmV0dXJuIChcInByb21pc2UkKFwiICsgdGhpcy5hcmdzKCkubWFwKGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHYuYygpOyB9KS5qb2luKCcsJykgKyBcIilcIik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiAoXCJJbWJhLmF3YWl0KFwiICsgdGhpcy5hcmdzKCkubWFwKGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHYuYygpOyB9KS5qb2luKCcsJykgKyBcIilcIik7XG5cdFx0fTtcblx0fTtcblx0XG5cdC8vIFRPRE8gZGVwcmVjYXRlZDogY2FuIHJlbW92ZVxuXHRVdGlsLkNsYXNzID0gZnVuY3Rpb24gQ2xhc3MoKXsgcmV0dXJuIFV0aWwuYXBwbHkodGhpcyxhcmd1bWVudHMpIH07XG5cdFxuXHRzdWJjbGFzcyQoVXRpbC5DbGFzcyxVdGlsKTtcblx0VXRpbC5DbGFzcy5wcm90b3R5cGUuanMgPSBmdW5jdGlvbiAobyl7XG5cdFx0Ly8gV2hlbiB0aGlzIGlzIHRyaWdnZXJlZCwgd2UgbmVlZCB0byBhZGQgaXQgdG8gdGhlIHRvcCBvZiBmaWxlP1xuXHRcdHJldHVybiAoXCJjbGFzcyQoXCIgKyB0aGlzLmFyZ3MoKS5tYXAoZnVuY3Rpb24odikgeyByZXR1cm4gdi5jKCk7IH0pLmpvaW4oJywnKSArIFwiKVwiKTtcblx0fTtcblx0XG5cdFV0aWwuSXRlcmFibGUgPSBmdW5jdGlvbiBJdGVyYWJsZSgpeyByZXR1cm4gVXRpbC5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XG5cdHN1YmNsYXNzJChVdGlsLkl0ZXJhYmxlLFV0aWwpO1xuXHRVdGlsLkl0ZXJhYmxlLnByb3RvdHlwZS5oZWxwZXIgPSBmdW5jdGlvbiAoKXtcblx0XHQvLyBub3cgd2Ugd2FudCB0byBhbGxvdyBudWxsIHZhbHVlcyBhcyB3ZWxsIC0ganVzdCByZXR1cm4gYXMgZW1wdHkgY29sbGVjdGlvblxuXHRcdC8vIHNob3VsZCBiZSB0aGUgc2FtZSBmb3IgZm9yIG93biBvZiBJIGd1ZXNzXG5cdFx0cmV0dXJuIChcImZ1bmN0aW9uIGl0ZXIkKGEpXFx7IHJldHVybiBhID8gKGEudG9BcnJheSA/IGEudG9BcnJheSgpIDogYSkgOiBbXTsgXFx9O1wiKTtcblx0fTtcblx0XG5cdFV0aWwuSXRlcmFibGUucHJvdG90eXBlLmpzID0gZnVuY3Rpb24gKG8pe1xuXHRcdGlmICh0aGlzLmFyZ3MoKVswXSBpbnN0YW5jZW9mIEFycikgeyByZXR1cm4gdGhpcy5hcmdzKClbMF0uYygpIH07IC8vIG9yIGlmIHdlIGtub3cgZm9yIHN1cmUgdGhhdCBpdCBpcyBhbiBhcnJheVxuXHRcdFxuXHRcdGlmICh0aGlzLmlzU3RhbmRhbG9uZSgpKSB7XG5cdFx0XHR0aGlzLnNjb3BlX18oKS5yb290KCkuaGVscGVyKHRoaXMsdGhpcy5oZWxwZXIoKSk7XG5cdFx0XHRyZXR1cm4gKFwiaXRlciQoXCIgKyAodGhpcy5hcmdzKClbMF0uYygpKSArIFwiKVwiKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIChcIkltYmEuaXRlcmFibGUoXCIgKyAodGhpcy5hcmdzKClbMF0uYygpKSArIFwiKVwiKTtcblx0XHR9O1xuXHR9O1xuXHRcblx0VXRpbC5Jc0Z1bmN0aW9uID0gZnVuY3Rpb24gSXNGdW5jdGlvbigpeyByZXR1cm4gVXRpbC5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XG5cdHN1YmNsYXNzJChVdGlsLklzRnVuY3Rpb24sVXRpbCk7XG5cdFV0aWwuSXNGdW5jdGlvbi5wcm90b3R5cGUuanMgPSBmdW5jdGlvbiAobyl7XG5cdFx0cmV0dXJuIChcIlwiICsgKHRoaXMuYXJncygpWzBdLmMoKSkpO1xuXHR9O1xuXHRcblx0VXRpbC5BcnJheSA9IGZ1bmN0aW9uIEFycmF5KCl7IHJldHVybiBVdGlsLmFwcGx5KHRoaXMsYXJndW1lbnRzKSB9O1xuXHRcblx0c3ViY2xhc3MkKFV0aWwuQXJyYXksVXRpbCk7XG5cdFV0aWwuQXJyYXkucHJvdG90eXBlLmpzID0gZnVuY3Rpb24gKG8pe1xuXHRcdC8vIFdoZW4gdGhpcyBpcyB0cmlnZ2VyZWQsIHdlIG5lZWQgdG8gYWRkIGl0IHRvIHRoZSB0b3Agb2YgZmlsZT9cblx0XHRyZXR1cm4gKFwibmV3IEFycmF5KFwiICsgdGhpcy5hcmdzKCkubWFwKGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHYuYygpOyB9KSArIFwiKVwiKTtcblx0fTtcblx0XG5cdFxuXHRcblx0XG5cdGZ1bmN0aW9uIEVudGl0aWVzKHJvb3Qpe1xuXHRcdHRoaXMuX3Jvb3QgPSByb290O1xuXHRcdHRoaXMuX21hcCA9IHt9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0RW50aXRpZXMucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChwYXRoLG9iamVjdCl7XG5cdFx0dGhpcy5fbWFwW3BhdGhdID0gb2JqZWN0O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0RW50aXRpZXMucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGVudGl0eSl7XG5cdFx0dmFyICQxO1xuXHRcdHZhciBwYXRoID0gZW50aXR5Lm5hbWVwYXRoKCk7XG5cdFx0dGhpcy5fbWFwWygkMSA9IHBhdGgpXSB8fCAodGhpcy5fbWFwWyQxXSA9IGVudGl0eSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRFbnRpdGllcy5wcm90b3R5cGUucGxhaW4gPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLl9tYXApKTtcblx0fTtcblx0XG5cdEVudGl0aWVzLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fbWFwO1xuXHR9O1xuXHRcblx0Ly8gU0NPUEVTXG5cdFxuXHQvLyBoYW5kbGVzIGxvY2FsIHZhcmlhYmxlcywgc2VsZiBldGMuIFNob3VsZCBjcmVhdGUgcmVmZXJlbmNlcyB0byBvdXRlciBzY29wZXNcblx0Ly8gd2hlbiBuZWVkZWQgZXRjLlxuXHRcblx0Ly8gYWRkIGNsYXNzIGZvciBhbm5vdGF0aW9ucyAvIHJlZ2lzdGVyaW5nIG1ldGhvZHMsIGV0Yz9cblx0Ly8gY2xhc3MgSW50ZXJmYWNlXG5cdFxuXHQvLyBzaG91bGQgbW92ZSB0aGUgd2hvbGUgY29udGV4dC10aGluZ2llIHJpZ2h0IGludG8gc2NvcGVcblx0ZnVuY3Rpb24gU2NvcGUobm9kZSxwYXJlbnQpe1xuXHRcdHRoaXMuX25yID0gU1RBQ0suaW5jcignc2NvcGVzJyk7XG5cdFx0dGhpcy5faGVhZCA9IFtdO1xuXHRcdHRoaXMuX25vZGUgPSBub2RlO1xuXHRcdHRoaXMuX3BhcmVudCA9IHBhcmVudDtcblx0XHR0aGlzLl92YXJzID0gbmV3IFZhcmlhYmxlRGVjbGFyYXRpb24oW10pO1xuXHRcdHRoaXMuX21ldGEgPSB7fTtcblx0XHR0aGlzLl9hbm5vdGF0aW9ucyA9IFtdO1xuXHRcdHRoaXMuX2Nsb3N1cmUgPSB0aGlzO1xuXHRcdHRoaXMuX3ZpcnR1YWwgPSBmYWxzZTtcblx0XHR0aGlzLl9jb3VudGVyID0gMDtcblx0XHR0aGlzLl92YXJtYXAgPSB7fTtcblx0XHR0aGlzLl92YXJwb29sID0gW107XG5cdH07XG5cdFxuXHRleHBvcnRzLlNjb3BlID0gU2NvcGU7IC8vIGV4cG9ydCBjbGFzcyBcblx0U2NvcGUucHJvdG90eXBlLmxldmVsID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9sZXZlbDsgfVxuXHRTY29wZS5wcm90b3R5cGUuc2V0TGV2ZWwgPSBmdW5jdGlvbih2KXsgdGhpcy5fbGV2ZWwgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0U2NvcGUucHJvdG90eXBlLmNvbnRleHQgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2NvbnRleHQ7IH1cblx0U2NvcGUucHJvdG90eXBlLnNldENvbnRleHQgPSBmdW5jdGlvbih2KXsgdGhpcy5fY29udGV4dCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRTY29wZS5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fbm9kZTsgfVxuXHRTY29wZS5wcm90b3R5cGUuc2V0Tm9kZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9ub2RlID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFNjb3BlLnByb3RvdHlwZS5wYXJlbnQgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3BhcmVudDsgfVxuXHRTY29wZS5wcm90b3R5cGUuc2V0UGFyZW50ID0gZnVuY3Rpb24odil7IHRoaXMuX3BhcmVudCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRTY29wZS5wcm90b3R5cGUudmFybWFwID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl92YXJtYXA7IH1cblx0U2NvcGUucHJvdG90eXBlLnNldFZhcm1hcCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl92YXJtYXAgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0U2NvcGUucHJvdG90eXBlLnZhcnBvb2wgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3ZhcnBvb2w7IH1cblx0U2NvcGUucHJvdG90eXBlLnNldFZhcnBvb2wgPSBmdW5jdGlvbih2KXsgdGhpcy5fdmFycG9vbCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRTY29wZS5wcm90b3R5cGUucGFyYW1zID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9wYXJhbXM7IH1cblx0U2NvcGUucHJvdG90eXBlLnNldFBhcmFtcyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9wYXJhbXMgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0U2NvcGUucHJvdG90eXBlLmhlYWQgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2hlYWQ7IH1cblx0U2NvcGUucHJvdG90eXBlLnNldEhlYWQgPSBmdW5jdGlvbih2KXsgdGhpcy5faGVhZCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRTY29wZS5wcm90b3R5cGUudmFycyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fdmFyczsgfVxuXHRTY29wZS5wcm90b3R5cGUuc2V0VmFycyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl92YXJzID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFNjb3BlLnByb3RvdHlwZS5jb3VudGVyID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9jb3VudGVyOyB9XG5cdFNjb3BlLnByb3RvdHlwZS5zZXRDb3VudGVyID0gZnVuY3Rpb24odil7IHRoaXMuX2NvdW50ZXIgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFNjb3BlLnByb3RvdHlwZS5wID0gZnVuY3Rpb24gKCl7XG5cdFx0aWYgKFNUQUNLLmxvZ2xldmVsKCkgPiAwKSB7XG5cdFx0XHRjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFNjb3BlLnByb3RvdHlwZS5zdGFjayA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiBTVEFDSztcblx0fTtcblx0XG5cdFNjb3BlLnByb3RvdHlwZS5tZXRhID0gZnVuY3Rpb24gKGtleSx2YWx1ZSl7XG5cdFx0aWYgKHZhbHVlICE9IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5fbWV0YVtrZXldID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdHJldHVybiB0aGlzLl9tZXRhW2tleV07XG5cdH07XG5cdFxuXHRTY29wZS5wcm90b3R5cGUubmFtZXBhdGggPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gJz8nO1xuXHR9O1xuXHRcblx0U2NvcGUucHJvdG90eXBlLnRhZ0NvbnRleHRQYXRoID0gZnVuY3Rpb24gKCl7XG5cdFx0Ly8gYnlwYXNzaW5nIGZvciBub3dcblx0XHRyZXR1cm4gdGhpcy5fdGFnQ29udGV4dFBhdGggfHwgKHRoaXMuX3RhZ0NvbnRleHRQYXRoID0gXCJ0YWckXCIpOyAvLyBwYXJlbnQudGFnQ29udGV4dFBhdGhcblx0fTtcblx0XG5cdFNjb3BlLnByb3RvdHlwZS5jb250ZXh0ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRleHQgfHwgKHRoaXMuX2NvbnRleHQgPSBuZXcgU2NvcGVDb250ZXh0KHRoaXMpKTtcblx0fTtcblx0XG5cdFNjb3BlLnByb3RvdHlwZS50cmF2ZXJzZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0U2NvcGUucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKCl7XG5cdFx0aWYgKHRoaXMuX3BhcmVudCkgeyByZXR1cm4gdGhpcyB9O1xuXHRcdC8vIHAgXCJ2aXNpdGVkIHNjb3BlIVwiXG5cdFx0dGhpcy5fcGFyZW50ID0gU1RBQ0suc2NvcGUoMSk7IC8vIHRoZSBwYXJlbnQgc2NvcGVcblx0XHR0aGlzLl9sZXZlbCA9IFNUQUNLLnNjb3BlcygpLmxlbmd0aCAtIDE7XG5cdFx0XG5cdFx0Ly8gcCBcInBhcmVudCBpc1wiLEBwYXJlbnRcblx0XHRTVEFDSy5hZGRTY29wZSh0aGlzKTtcblx0XHR0aGlzLnJvb3QoKS5zY29wZXMoKS5wdXNoKHRoaXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0U2NvcGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc2NvcGUpe1xuXHRcdHRoaXMuX3BhcmVudCA9IHNjb3BlLl9wYXJlbnQ7XG5cdFx0c2NvcGUuX3BhcmVudCA9IHRoaXM7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvLyBjYWxsZWQgZm9yIHNjb3BlcyB0aGF0IGFyZSBub3QgcmVhbCBzY29wZXMgaW4ganNcblx0Ly8gbXVzdCBlbnN1cmUgdGhhdCB0aGUgbG9jYWwgdmFyaWFibGVzIGluc2lkZSBvZiB0aGUgc2NvcGVzIGRvIG5vdFxuXHQvLyBjb2xsaWRlIHdpdGggdmFyaWFibGVzIGluIG91dGVyIHNjb3BlcyAtLSByZW5hbWUgaWYgbmVlZGVkXG5cdFNjb3BlLnByb3RvdHlwZS52aXJ0dWFsaXplID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRTY29wZS5wcm90b3R5cGUucm9vdCA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBzY29wZSA9IHRoaXM7XG5cdFx0d2hpbGUgKHNjb3BlKXtcblx0XHRcdGlmIChzY29wZSBpbnN0YW5jZW9mIFJvb3RTY29wZSkgeyByZXR1cm4gc2NvcGUgfTtcblx0XHRcdHNjb3BlID0gc2NvcGUucGFyZW50KCk7XG5cdFx0fTtcblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblx0XG5cdFNjb3BlLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChuYW1lLGRlY2wsbyl7XG5cdFx0Ly8gRklYTUUgcmUtcmVnaXN0ZXJpbmcgYSB2YXJpYWJsZSBzaG91bGQgcmVhbGx5IHJldHVybiB0aGUgZXhpc3Rpbmcgb25lXG5cdFx0Ly8gQWdhaW4sIGhlcmUgd2Ugc2hvdWxkIG5vdCByZWFsbHkgaGF2ZSB0byBkZWFsIHdpdGggc3lzdGVtLWdlbmVyYXRlZCB2YXJzXG5cdFx0Ly8gQnV0IGFnYWluLCBpdCBpcyBpbXBvcnRhbnRcblx0XHRcblx0XHQvLyBwIFwicmVnaXN0ZXJpbmcge25hbWV9XCJcblx0XHRpZihkZWNsID09PSB1bmRlZmluZWQpIGRlY2wgPSBudWxsO1xuXHRcdGlmKG8gPT09IHVuZGVmaW5lZCkgbyA9IHt9O1xuXHRcdG5hbWUgPSBoZWxwZXJzLnN5bWJvbGl6ZShuYW1lKTtcblx0XHRcblx0XHQvLyBhbHNvIGxvb2sgYXQgb3V0ZXIgc2NvcGVzIGlmIHRoaXMgaXMgbm90IGNsb3NlZD9cblx0XHR2YXIgZXhpc3RpbmcgPSB0aGlzLl92YXJtYXAuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgdGhpcy5fdmFybWFwW25hbWVdO1xuXHRcdGlmIChleGlzdGluZykgeyByZXR1cm4gZXhpc3RpbmcgfTtcblx0XHRcblx0XHR2YXIgaXRlbSA9IG5ldyBWYXJpYWJsZSh0aGlzLG5hbWUsZGVjbCxvKTtcblx0XHQvLyBuZWVkIHRvIGNoZWNrIGZvciBkdXBsaWNhdGVzLCBhbmQgaGFuZGxlIHRoaXMgZ3JhY2VmdWxseSAtXG5cdFx0Ly8gZ29pbmcgdG8gcmVmYWN0b3IgbGF0ZXJcblx0XHRpZiAoIW8uc3lzdGVtKSB7IHRoaXMuX3Zhcm1hcFtuYW1lXSA9IGl0ZW0gfTsgLy8gZG9udCBldmVuIGFkZCB0byB0aGUgdmFybWFwIGlmIGl0IGlzIGEgc3lzdmFyXG5cdFx0cmV0dXJuIGl0ZW07XG5cdH07XG5cdFxuXHRTY29wZS5wcm90b3R5cGUuYW5ub3RhdGUgPSBmdW5jdGlvbiAob2JqKXtcblx0XHR0aGlzLl9hbm5vdGF0aW9ucy5wdXNoKG9iaik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvLyBqdXN0IGxpa2UgcmVnaXN0ZXIsIGJ1dCB3ZSBhdXRvbWF0aWNhbGx5IFxuXHRTY29wZS5wcm90b3R5cGUuZGVjbGFyZSA9IGZ1bmN0aW9uIChuYW1lLGluaXQsbyl7XG5cdFx0dmFyIGRlY2xhcmF0b3JfO1xuXHRcdGlmKGluaXQgPT09IHVuZGVmaW5lZCkgaW5pdCA9IG51bGw7XG5cdFx0aWYobyA9PT0gdW5kZWZpbmVkKSBvID0ge307XG5cdFx0dmFyIHZhcmlhYmxlID0gdGhpcy5yZWdpc3RlcihuYW1lLG51bGwsbyk7XG5cdFx0Ly8gVE9ETyBjcmVhdGUgdGhlIHZhcmlhYmxlZGVjbGFyYXRpb24gaGVyZSBpbnN0ZWFkP1xuXHRcdC8vIGlmIHRoaXMgaXMgYSBzeXN2YXIgd2UgbmVlZCBpdCB0byBiZSByZW5hbWVhYmxlXG5cdFx0dmFyIGRlYyA9IHRoaXMuX3ZhcnMuYWRkKHZhcmlhYmxlLGluaXQpO1xuXHRcdChkZWNsYXJhdG9yXyA9IHZhcmlhYmxlLmRlY2xhcmF0b3IoKSkgfHwgKCh2YXJpYWJsZS5zZXREZWNsYXJhdG9yKGRlYyksZGVjKSk7XG5cdFx0cmV0dXJuIHZhcmlhYmxlO1xuXHRcdFxuXHRcdC8vIHAgXCJkZWNsYXJlIHZhcmlhYmxlIHtuYW1lfSB7b31cIlxuXHRcdC8vIGlmIG5hbWUgaXNhIFZhcmlhYmxlXG5cdFx0Ly8gcCBcIlNDT1BFIGRlY2xhcmUgdmFyXCIuZ3JlZW5cblx0XHRuYW1lID0gaGVscGVycy5zeW1ib2xpemUobmFtZSk7XG5cdFx0Ly8gd2Ugd2lsbCBzZWUgaGVyZVxuXHRcdHRoaXMuX3ZhcnMuYWRkKG5hbWUsaW5pdCk7IC8vIC5sYXN0IC0tIFxuXHRcdHZhciBkZWNsID0gdGhpcy5fdmFycy5sYXN0KCk7IC8vIGJ1ZyghKVxuXHRcdHZhciBpdGVtO1xuXHRcdC8vIGl0ZW0gPSBWYXJpYWJsZS5uZXcoc2VsZixuYW1lLGRlY2wpXG5cdFx0XG5cdFx0Ly8gaWYgbzpzeXN0ZW1cblx0XHQvLyBcdGl0ZW0gPSBTeXN0ZW1WYXJpYWJsZS5uZXcoc2VsZixuYW1lLGRlY2wsbylcblx0XHQvLyBcdGRlY2wudmFyaWFibGUgPSBpdGVtXG5cdFx0Ly8gZWxzZVxuXHRcdGl0ZW0gPSBuZXcgVmFyaWFibGUodGhpcyxuYW1lLGRlY2wsbyk7XG5cdFx0ZGVjbC5zZXRWYXJpYWJsZShpdGVtKTtcblx0XHRpdGVtLnJlc29sdmUoKTsgLy8gd2h5IG9uIGVhcnRoIHNob3VsZCBpdCByZXNvbHZlIGltbWVkaWF0ZWx5P1xuXHRcdFxuXHRcdC8vIGRlY2wudmFyaWFibGUgPSBpdGVtXG5cdFx0Ly8gaXRlbS5yZXNvbHZlICMgd2h5IG9uIGVhcnRoIHNob3VsZCBpdCByZXNvbHZlIGltbWVkaWF0ZWx5P1xuXHRcdHJldHVybiBpdGVtO1xuXHRcdFxuXHRcdC8vIHNob3VsZCBiZSBwb3NzaWJsZSB0byBmb3JjZS1kZWNsYXJlIGZvciB0aGlzIHNjb3BlLCBubz9cblx0XHQvLyBpZiB0aGlzIGlzIGEgc3lzdGVtLXZhcmlhYmxlIFxuXHR9O1xuXHRcblx0Ly8gZGVjbGFyZXMgYSB2YXJpYWJsZSAoaGFzIG5vIHJlYWwgZGVjbGFyYXRpb24gYmVmb3JlaGFuZClcblx0XG5cdFxuXHQvLyB3aGF0IGFyZSB0aGUgZGlmZmVyZW5jZXMgaGVyZT8gb21qXG5cdC8vIHdlIG9ubHkgbmVlZCBhIHRlbXBvcmFyeSB0aGluZyB3aXRoIGRlZmF1bHRzIC0tIHRoYXQgaXMgYWxsXG5cdC8vIGNoYW5nZSB0aGVzZSB2YWx1ZXMsIG5vP1xuXHRTY29wZS5wcm90b3R5cGUudGVtcG9yYXJ5ID0gZnVuY3Rpb24gKHJlZm5vZGUsbyxuYW1lKXtcblx0XHRcblx0XHQvLyBwIFwicmVnaXN0ZXJpbmcgdGVtcG9yYXJ5IHtyZWZub2RlfSB7bmFtZX1cIlxuXHRcdC8vIHJldXNlIHZhcmlhYmxlcyAtLSBobW1cblx0XHRpZihvID09PSB1bmRlZmluZWQpIG8gPSB7fTtcblx0XHRpZihuYW1lID09PSB1bmRlZmluZWQpIG5hbWUgPSBudWxsO1xuXHRcdGlmIChvLnBvb2wpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJCh0aGlzLl92YXJwb29sKSwgbGVuID0gYXJ5Lmxlbmd0aCwgdjsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHYgPSBhcnlbaV07XG5cdFx0XHRcdGlmICh2LnBvb2woKSA9PSBvLnBvb2wgJiYgdi5kZWNsYXJhdG9yKCkgPT0gbnVsbCkge1xuXHRcdFx0XHRcdHJldHVybiB2LnJldXNlKHJlZm5vZGUpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIHNob3VsZCBvbmx5ICdyZWdpc3RlcicgYXMgYWhpZGRlbiB2YXJpYWJsZSwgbm8/XG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHJlYWwgbm9kZXMgaW5zaWRlIHRoYXQgdHJpZXMgdG8gcmVmZXIgdG8gdmFyc1xuXHRcdC8vIGRlZmluZWQgaW4gb3V0ZXIgc2NvcGVzLCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGV5IGFyZSBub3QgbmFtZWQgYWZ0ZXIgdGhpc1xuXHRcdHZhciBpdGVtID0gbmV3IFN5c3RlbVZhcmlhYmxlKHRoaXMsbmFtZSxyZWZub2RlLG8pO1xuXHRcdHRoaXMuX3ZhcnBvb2wucHVzaChpdGVtKTsgLy8gV0hBVD8gSXQgc2hvdWxkIG5vdCBiZSBpbiB0aGUgcG9vbCB1bmxlc3MgZXhwbGljaXRseSBwdXQgdGhlcmU/XG5cdFx0dGhpcy5fdmFycy5wdXNoKGl0ZW0pOyAvLyBXQVJOIHZhcmlhYmxlcyBzaG91bGQgbm90IGdvIGRpcmVjdGx5IGludG8gYSBkZWNsYXJhdGlvbi1saXN0XG5cdFx0cmV0dXJuIGl0ZW07XG5cdFx0Ly8gcmV0dXJuIHJlZ2lzdGVyKG5hbWUgfHwgXCJfX1wiLG51bGwsc3lzdGVtOiB5ZXMsIHRlbXBvcmFyeTogeWVzKVxuXHR9O1xuXHRcblx0XG5cdFxuXHRTY29wZS5wcm90b3R5cGUubG9va3VwID0gZnVuY3Rpb24gKG5hbWUpe1xuXHRcdHZhciByZXQgPSBudWxsO1xuXHRcdG5hbWUgPSBoZWxwZXJzLnN5bWJvbGl6ZShuYW1lKTtcblx0XHRpZiAodGhpcy5fdmFybWFwLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG5cdFx0XHRyZXQgPSB0aGlzLl92YXJtYXBbbmFtZV07XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGxvb2sgdXAgYW55IHBhcmVudCBzY29wZSA/PyBzZWVtcyBva2F5XG5cdFx0XHQvLyAhaXNDbG9zZWQgJiYgXG5cdFx0XHRyZXQgPSB0aGlzLnBhcmVudCgpICYmIHRoaXMucGFyZW50KCkubG9va3VwKG5hbWUpO1xuXHRcdFx0Ly8gb3IgLS0gbm90IGFsbCBzY29wZXMgaGF2ZSBhIHBhcmVudD9cblx0XHR9O1xuXHRcdFxuXHRcdC8vIHNob3VsZCB0aGlzIG5vdCBoYXBwZW4gYnkgaXRzZWxmP1xuXHRcdC8vIGlmICFyZXQgYW5kIFxuXHRcdC8vXHRyZXQgPSBcblx0XHQvLyByZXQgfHw9IChnLmxvb2t1cChuYW1lKSBpZiB2YXIgZyA9IHJvb3QpXG5cdFx0Ly8gZyA9IHJvb3Rcblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xuXHRcblx0U2NvcGUucHJvdG90eXBlLmF1dG9kZWNsYXJlID0gZnVuY3Rpb24gKHZhcmlhYmxlKXtcblx0XHRyZXR1cm4gdGhpcy52YXJzKCkucHVzaCh2YXJpYWJsZSk7IC8vIG9ubHkgaWYgaXQgZG9lcyBub3QgZXhpc3QgaGVyZSEhIVxuXHR9O1xuXHRcblx0U2NvcGUucHJvdG90eXBlLmZyZWUgPSBmdW5jdGlvbiAodmFyaWFibGUpe1xuXHRcdC8vIHAgXCJmcmVlIHZhcmlhYmxlXCJcblx0XHR2YXJpYWJsZS5mcmVlKCk7IC8vIDpvd25lciA9IG51bGxcblx0XHQvLyBAdmFycG9vbC5wdXNoKHZhcmlhYmxlKVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0U2NvcGUucHJvdG90eXBlLmlzQ2xvc2VkID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXHRcblx0U2NvcGUucHJvdG90eXBlLmNsb3N1cmUgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fY2xvc3VyZTtcblx0fTtcblx0XG5cdFNjb3BlLnByb3RvdHlwZS5maW5hbGl6ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0U2NvcGUucHJvdG90eXBlLmtsYXNzID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHNjb3BlID0gdGhpcztcblx0XHR3aGlsZSAoc2NvcGUpe1xuXHRcdFx0c2NvcGUgPSBzY29wZS5wYXJlbnQoKTtcblx0XHRcdGlmIChzY29wZSBpbnN0YW5jZW9mIENsYXNzU2NvcGUpIHsgcmV0dXJuIHNjb3BlIH07XG5cdFx0fTtcblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblx0XG5cdFNjb3BlLnByb3RvdHlwZS5oZWFkID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIFt0aGlzLl92YXJzLHRoaXMuX3BhcmFtc107XG5cdH07XG5cdFxuXHRTY29wZS5wcm90b3R5cGUuYyA9IGZ1bmN0aW9uIChvKXtcblx0XHR2YXIgYm9keTtcblx0XHRpZihvID09PSB1bmRlZmluZWQpIG8gPSB7fTtcblx0XHRvLmV4cHJlc3Npb24gPSBmYWxzZTtcblx0XHQvLyBuZWVkIHRvIGZpeCB0aGlzXG5cdFx0dGhpcy5ub2RlKCkuYm9keSgpLnNldEhlYWQodGhpcy5oZWFkKCkpO1xuXHRcdHJldHVybiBib2R5ID0gdGhpcy5ub2RlKCkuYm9keSgpLmMobyk7XG5cdFx0XG5cdFx0Ly8gdmFyIGhlYWQgPSBbQHZhcnMsQHBhcmFtc10uYmxvY2suYyhleHByZXNzaW9uOiBubylcblx0XHQvLyBwIFwiaGVhZCBmcm9tIHNjb3BlIGlzICh7aGVhZH0pXCJcblx0XHQvLyB2YXIgb3V0ID0gW2hlYWQgb3IgbnVsbCxib2R5XS5mbGF0dGVuX18uY29tcGFjdC5qb2luKFwiXFxuXCIpXG5cdFx0Ly8gb3V0XG5cdFx0Ly8gb3V0ID0gJ3snICsgb3V0ICsgXG5cdH07XG5cdFxuXHRTY29wZS5wcm90b3R5cGUucmVnaW9uID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMubm9kZSgpLmJvZHkoKS5yZWdpb24oKTtcblx0fTtcblx0XG5cdFNjb3BlLnByb3RvdHlwZS5sb2MgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5ub2RlKCkubG9jKCk7XG5cdH07XG5cdFxuXHRTY29wZS5wcm90b3R5cGUuZHVtcCA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR2YXIgdmFycyA9IE9iamVjdC5rZXlzKHRoaXMuX3Zhcm1hcCkubWFwKGZ1bmN0aW9uKGspIHtcblx0XHRcdHZhciB2ID0gc2VsZi5fdmFybWFwW2tdO1xuXHRcdFx0cmV0dXJuIHYucmVmZXJlbmNlcygpLmxlbmd0aCA/IChkdW1wX18odikpIDogKG51bGwpO1xuXHRcdH0pO1xuXHRcdFxuXHRcdHZhciBkZXNjID0ge1xuXHRcdFx0bnI6IHNlbGYuX25yLFxuXHRcdFx0dHlwZTogc2VsZi5jb25zdHJ1Y3Rvci5uYW1lLFxuXHRcdFx0bGV2ZWw6IChzZWxmLmxldmVsKCkgfHwgMCksXG5cdFx0XHR2YXJzOiBjb21wYWN0X18odmFycyksXG5cdFx0XHRsb2M6IHNlbGYubG9jKClcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiBkZXNjO1xuXHR9O1xuXHRcblx0U2NvcGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLmR1bXAoKTtcblx0fTtcblx0XG5cdFNjb3BlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiAoXCJcIiArICh0aGlzLmNvbnN0cnVjdG9yLm5hbWUpKTtcblx0fTtcblx0XG5cdFxuXHQvLyBSb290U2NvcGUgaXMgd3Jvbmc/IFJhdGhlciBUb3BTY29wZSBvciBQcm9ncmFtU2NvcGVcblx0ZnVuY3Rpb24gUm9vdFNjb3BlKCl7XG5cdFx0Um9vdFNjb3BlLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLGFyZ3VtZW50cyk7XG5cdFx0XG5cdFx0dGhpcy5yZWdpc3RlcignZ2xvYmFsJyx0aGlzLHt0eXBlOiAnZ2xvYmFsJ30pO1xuXHRcdHRoaXMucmVnaXN0ZXIoJ21vZHVsZScsdGhpcyx7dHlwZTogJ2dsb2JhbCd9KTtcblx0XHR0aGlzLnJlZ2lzdGVyKCd3aW5kb3cnLHRoaXMse3R5cGU6ICdnbG9iYWwnfSk7XG5cdFx0dGhpcy5yZWdpc3RlcignZG9jdW1lbnQnLHRoaXMse3R5cGU6ICdnbG9iYWwnfSk7XG5cdFx0dGhpcy5yZWdpc3RlcignZXhwb3J0cycsdGhpcyx7dHlwZTogJ2dsb2JhbCd9KTtcblx0XHR0aGlzLnJlZ2lzdGVyKCdjb25zb2xlJyx0aGlzLHt0eXBlOiAnZ2xvYmFsJ30pO1xuXHRcdHRoaXMucmVnaXN0ZXIoJ3Byb2Nlc3MnLHRoaXMse3R5cGU6ICdnbG9iYWwnfSk7XG5cdFx0dGhpcy5yZWdpc3RlcigncGFyc2VJbnQnLHRoaXMse3R5cGU6ICdnbG9iYWwnfSk7XG5cdFx0dGhpcy5yZWdpc3RlcigncGFyc2VGbG9hdCcsdGhpcyx7dHlwZTogJ2dsb2JhbCd9KTtcblx0XHR0aGlzLnJlZ2lzdGVyKCdzZXRUaW1lb3V0Jyx0aGlzLHt0eXBlOiAnZ2xvYmFsJ30pO1xuXHRcdHRoaXMucmVnaXN0ZXIoJ3NldEludGVydmFsJyx0aGlzLHt0eXBlOiAnZ2xvYmFsJ30pO1xuXHRcdHRoaXMucmVnaXN0ZXIoJ2NsZWFyVGltZW91dCcsdGhpcyx7dHlwZTogJ2dsb2JhbCd9KTtcblx0XHR0aGlzLnJlZ2lzdGVyKCdjbGVhckludGVydmFsJyx0aGlzLHt0eXBlOiAnZ2xvYmFsJ30pO1xuXHRcdHRoaXMucmVnaXN0ZXIoJ19fZGlybmFtZScsdGhpcyx7dHlwZTogJ2dsb2JhbCd9KTtcblx0XHRcblx0XHQvLyBwcmVyZWdpc3RlciBnbG9iYWwgc3BlY2lhbCB2YXJpYWJsZXMgaGVyZVxuXHRcdHRoaXMuX3dhcm5pbmdzID0gW107XG5cdFx0dGhpcy5fc2NvcGVzID0gW107XG5cdFx0dGhpcy5faGVscGVycyA9IFtdO1xuXHRcdHRoaXMuX2VudGl0aWVzID0gbmV3IEVudGl0aWVzKHRoaXMpO1xuXHRcdHRoaXMuX2hlYWQgPSBbdGhpcy5fdmFyc107XG5cdH07XG5cdFxuXHRzdWJjbGFzcyQoUm9vdFNjb3BlLFNjb3BlKTtcblx0ZXhwb3J0cy5Sb290U2NvcGUgPSBSb290U2NvcGU7IC8vIGV4cG9ydCBjbGFzcyBcblx0Um9vdFNjb3BlLnByb3RvdHlwZS53YXJuaW5ncyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fd2FybmluZ3M7IH1cblx0Um9vdFNjb3BlLnByb3RvdHlwZS5zZXRXYXJuaW5ncyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl93YXJuaW5ncyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRSb290U2NvcGUucHJvdG90eXBlLnNjb3BlcyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fc2NvcGVzOyB9XG5cdFJvb3RTY29wZS5wcm90b3R5cGUuc2V0U2NvcGVzID0gZnVuY3Rpb24odil7IHRoaXMuX3Njb3BlcyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRSb290U2NvcGUucHJvdG90eXBlLmVudGl0aWVzID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9lbnRpdGllczsgfVxuXHRSb290U2NvcGUucHJvdG90eXBlLnNldEVudGl0aWVzID0gZnVuY3Rpb24odil7IHRoaXMuX2VudGl0aWVzID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRSb290U2NvcGUucHJvdG90eXBlLmNvbnRleHQgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fY29udGV4dCB8fCAodGhpcy5fY29udGV4dCA9IG5ldyBSb290U2NvcGVDb250ZXh0KHRoaXMpKTtcblx0fTtcblx0XG5cdFJvb3RTY29wZS5wcm90b3R5cGUudGFnQ29udGV4dFBhdGggPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fdGFnQ29udGV4dFBhdGggfHwgKHRoaXMuX3RhZ0NvbnRleHRQYXRoID0gXCJ0YWckXCIpO1xuXHR9O1xuXHRcblx0Um9vdFNjb3BlLnByb3RvdHlwZS5sb29rdXAgPSBmdW5jdGlvbiAobmFtZSl7XG5cdFx0Ly8gcCBcImxvb2t1cCBmaWxlc2NvcGVcIlxuXHRcdG5hbWUgPSBoZWxwZXJzLnN5bWJvbGl6ZShuYW1lKTtcblx0XHRpZiAodGhpcy5fdmFybWFwLmhhc093blByb3BlcnR5KG5hbWUpKSB7IHJldHVybiB0aGlzLl92YXJtYXBbbmFtZV0gfTtcblx0fTtcblx0XG5cdFJvb3RTY29wZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAoKXtcblx0XHRTVEFDSy5hZGRTY29wZSh0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFJvb3RTY29wZS5wcm90b3R5cGUuaGVscGVyID0gZnVuY3Rpb24gKHR5cCx2YWx1ZSl7XG5cdFx0Ly8gbG9nIFwiYWRkIGhlbHBlclwiLHR5cCx2YWx1ZVxuXHRcdGlmICh0aGlzLl9oZWxwZXJzLmluZGV4T2YodmFsdWUpID09IC0xKSB7XG5cdFx0XHR0aGlzLl9oZWxwZXJzLnB1c2godmFsdWUpO1xuXHRcdFx0dGhpcy5faGVhZC51bnNoaWZ0KHZhbHVlKTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Um9vdFNjb3BlLnByb3RvdHlwZS5oZWFkID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX2hlYWQ7XG5cdH07XG5cdFxuXHRSb290U2NvcGUucHJvdG90eXBlLndhcm4gPSBmdW5jdGlvbiAoZGF0YSl7XG5cdFx0Ly8gaGFja3lcblx0XHRkYXRhLm5vZGUgPSBudWxsO1xuXHRcdC8vIHAgXCJ3YXJuaW5nXCIsSlNPTi5zdHJpbmdpZnkoZGF0YSlcblx0XHR0aGlzLl93YXJuaW5ncy5wdXNoKGRhdGEpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Um9vdFNjb3BlLnByb3RvdHlwZS5kdW1wID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIG9iaiA9IHt3YXJuaW5nczogZHVtcF9fKHRoaXMuX3dhcm5pbmdzKX07XG5cdFx0XG5cdFx0aWYgKE9QVFMuYW5hbHlzaXMuc2NvcGVzKSB7XG5cdFx0XHR2YXIgc2NvcGVzID0gdGhpcy5fc2NvcGVzLm1hcChmdW5jdGlvbihzKSB7IHJldHVybiBzLmR1bXAoKTsgfSk7XG5cdFx0XHRzY29wZXMudW5zaGlmdChSb290U2NvcGUuX19zdXBlcl9fLmR1bXAuY2FsbCh0aGlzKSk7XG5cdFx0XHRvYmouc2NvcGVzID0gc2NvcGVzO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKE9QVFMuYW5hbHlzaXMuZW50aXRpZXMpIHtcblx0XHRcdG9iai5lbnRpdGllcyA9IHRoaXMuX2VudGl0aWVzO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIG9iajtcblx0fTtcblx0XG5cdFxuXHRmdW5jdGlvbiBDbGFzc1Njb3BlKCl7IHJldHVybiBTY29wZS5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XG5cdHN1YmNsYXNzJChDbGFzc1Njb3BlLFNjb3BlKTtcblx0ZXhwb3J0cy5DbGFzc1Njb3BlID0gQ2xhc3NTY29wZTsgLy8gZXhwb3J0IGNsYXNzIFxuXHRDbGFzc1Njb3BlLnByb3RvdHlwZS5uYW1lcGF0aCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9ub2RlLm5hbWVwYXRoKCk7XG5cdH07XG5cdFxuXHRcblx0Ly8gY2FsbGVkIGZvciBzY29wZXMgdGhhdCBhcmUgbm90IHJlYWwgc2NvcGVzIGluIGpzXG5cdC8vIG11c3QgZW5zdXJlIHRoYXQgdGhlIGxvY2FsIHZhcmlhYmxlcyBpbnNpZGUgb2YgdGhlIHNjb3BlcyBkbyBub3Rcblx0Ly8gY29sbGlkZSB3aXRoIHZhcmlhYmxlcyBpbiBvdXRlciBzY29wZXMgLS0gcmVuYW1lIGlmIG5lZWRlZFxuXHRDbGFzc1Njb3BlLnByb3RvdHlwZS52aXJ0dWFsaXplID0gZnVuY3Rpb24gKCl7XG5cdFx0Ly8gY29uc29sZS5sb2cgXCJ2aXJ0dWFsaXppbmcgQ2xhc3NTY29wZVwiXG5cdFx0dmFyIHVwID0gdGhpcy5wYXJlbnQoKTtcblx0XHRmb3IgKHZhciBvID0gdGhpcy5fdmFybWFwLCBpID0gMCwga2V5cyA9IE9iamVjdC5rZXlzKG8pLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspe1xuXHRcdFx0dHJ1ZTtcblx0XHRcdG9ba2V5c1tpXV0ucmVzb2x2ZSh1cCx0cnVlKTsgLy8gZm9yY2UgbmV3IHJlc29sdmVcblx0XHR9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Q2xhc3NTY29wZS5wcm90b3R5cGUuaXNDbG9zZWQgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblx0XG5cdGZ1bmN0aW9uIFRhZ1Njb3BlKCl7IHJldHVybiBDbGFzc1Njb3BlLmFwcGx5KHRoaXMsYXJndW1lbnRzKSB9O1xuXHRcblx0c3ViY2xhc3MkKFRhZ1Njb3BlLENsYXNzU2NvcGUpO1xuXHRleHBvcnRzLlRhZ1Njb3BlID0gVGFnU2NvcGU7IC8vIGV4cG9ydCBjbGFzcyBcblx0XG5cdFxuXHRmdW5jdGlvbiBDbG9zdXJlU2NvcGUoKXsgcmV0dXJuIFNjb3BlLmFwcGx5KHRoaXMsYXJndW1lbnRzKSB9O1xuXHRcblx0c3ViY2xhc3MkKENsb3N1cmVTY29wZSxTY29wZSk7XG5cdGV4cG9ydHMuQ2xvc3VyZVNjb3BlID0gQ2xvc3VyZVNjb3BlOyAvLyBleHBvcnQgY2xhc3MgXG5cdFxuXHRcblx0ZnVuY3Rpb24gRnVuY3Rpb25TY29wZSgpeyByZXR1cm4gU2NvcGUuYXBwbHkodGhpcyxhcmd1bWVudHMpIH07XG5cdFxuXHRzdWJjbGFzcyQoRnVuY3Rpb25TY29wZSxTY29wZSk7XG5cdGV4cG9ydHMuRnVuY3Rpb25TY29wZSA9IEZ1bmN0aW9uU2NvcGU7IC8vIGV4cG9ydCBjbGFzcyBcblx0XG5cdFxuXHRmdW5jdGlvbiBNZXRob2RTY29wZSgpeyByZXR1cm4gU2NvcGUuYXBwbHkodGhpcyxhcmd1bWVudHMpIH07XG5cdFxuXHRzdWJjbGFzcyQoTWV0aG9kU2NvcGUsU2NvcGUpO1xuXHRleHBvcnRzLk1ldGhvZFNjb3BlID0gTWV0aG9kU2NvcGU7IC8vIGV4cG9ydCBjbGFzcyBcblx0TWV0aG9kU2NvcGUucHJvdG90eXBlLmlzQ2xvc2VkID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBMYW1iZGFTY29wZSgpeyByZXR1cm4gU2NvcGUuYXBwbHkodGhpcyxhcmd1bWVudHMpIH07XG5cdFxuXHRzdWJjbGFzcyQoTGFtYmRhU2NvcGUsU2NvcGUpO1xuXHRleHBvcnRzLkxhbWJkYVNjb3BlID0gTGFtYmRhU2NvcGU7IC8vIGV4cG9ydCBjbGFzcyBcblx0TGFtYmRhU2NvcGUucHJvdG90eXBlLmNvbnRleHQgPSBmdW5jdGlvbiAoKXtcblx0XHRcblx0XHQvLyB3aGVuIGFjY2Vzc2luZyB0aGUgb3V0ZXIgY29udGV4dCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGl0IGlzIGNhY2hlZFxuXHRcdC8vIHNvIHRoaXMgaXMgd3JvbmcgLSBidXQgdGVtcCBva2F5XG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRleHQgfHwgKHRoaXMuX2NvbnRleHQgPSB0aGlzLnBhcmVudCgpLmNvbnRleHQoKS5yZWZlcmVuY2UodGhpcykpO1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gRmxvd1Njb3BlKCl7IHJldHVybiBTY29wZS5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XG5cdHN1YmNsYXNzJChGbG93U2NvcGUsU2NvcGUpO1xuXHRleHBvcnRzLkZsb3dTY29wZSA9IEZsb3dTY29wZTsgLy8gZXhwb3J0IGNsYXNzIFxuXHRGbG93U2NvcGUucHJvdG90eXBlLnBhcmFtcyA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmICh0aGlzLl9wYXJlbnQpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5wYXJhbXMoKSB9O1xuXHR9O1xuXHRcblx0Rmxvd1Njb3BlLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChuYW1lLGRlY2wsbyl7XG5cdFx0dmFyIGZvdW5kO1xuXHRcdGlmKGRlY2wgPT09IHVuZGVmaW5lZCkgZGVjbCA9IG51bGw7XG5cdFx0aWYobyA9PT0gdW5kZWZpbmVkKSBvID0ge307XG5cdFx0aWYgKG8udHlwZSAhPSAnbGV0JyAmJiAodGhpcy5jbG9zdXJlKCkgIT0gdGhpcykpIHtcblx0XHRcdGlmIChmb3VuZCA9IHRoaXMubG9va3VwKG5hbWUpKSB7XG5cdFx0XHRcdC8vIHAgXCJhbHJlYWR5IGZvdW5kIHZhcmlhYmxlIHtmb3VuZC50eXBlfVwiXG5cdFx0XHRcdGlmIChmb3VuZC50eXBlKCkgPT0gJ2xldCcpIHtcblx0XHRcdFx0XHR0aGlzLnAoKFwiXCIgKyBuYW1lICsgXCIgYWxyZWFkeSBleGlzdHMgYXMgYSBibG9jay12YXJpYWJsZSBcIiArIGRlY2wpKTtcblx0XHRcdFx0XHQvLyBUT0RPIHNob3VsZCB0aHJvdyBlcnJvciBpbnN0ZWFkXG5cdFx0XHRcdFx0aWYgKGRlY2wpIHsgZGVjbC53YXJuKFwiVmFyaWFibGUgYWxyZWFkeSBleGlzdHMgaW4gYmxvY2tcIikgfTtcblx0XHRcdFx0XHQvLyByb290Lndhcm4gbWVzc2FnZTogXCJIb2x5IHNoaXRcIlxuXHRcdFx0XHR9O1xuXHRcdFx0XHQvLyBpZiBmb3VuZC5cblx0XHRcdH07XG5cdFx0XHQvLyBwIFwiRmxvd1Njb3BlIHJlZ2lzdGVyIHZhciAtLSBkbyBpdCByaWdodCBpbiB0aGUgb3V0ZXIgc2NvcGVcIlxuXHRcdFx0cmV0dXJuIHRoaXMuY2xvc3VyZSgpLnJlZ2lzdGVyKG5hbWUsZGVjbCxvKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gcCBcIlJlZ2lzdGVyIGxvY2FsIHZhcmlhYmxlIGZvciBGbG93U2NvcGUge25hbWV9XCJcblx0XHRcdC8vIG86Y2xvc3VyZSA9IHBhcmVudFxuXHRcdFx0Ly8gcCBcIkZsb3dTY29wZSByZWdpc3RlclwiLCBhcmd1bWVudHNcblx0XHRcdHJldHVybiBGbG93U2NvcGUuX19zdXBlcl9fLnJlZ2lzdGVyLmNhbGwodGhpcyxuYW1lLGRlY2wsbyk7XG5cdFx0fTtcblx0fTtcblx0XG5cdC8vIEZJWE1FIHNob3VsZCBvdmVycmlkZSB0ZW1wb3JhcnkgYXMgd2VsbFxuXHRcblx0Rmxvd1Njb3BlLnByb3RvdHlwZS5hdXRvZGVjbGFyZSA9IGZ1bmN0aW9uICh2YXJpYWJsZSl7XG5cdFx0cmV0dXJuIHRoaXMucGFyZW50KCkuYXV0b2RlY2xhcmUodmFyaWFibGUpO1xuXHR9O1xuXHRcblx0Rmxvd1Njb3BlLnByb3RvdHlwZS5jbG9zdXJlID0gZnVuY3Rpb24gKCl7XG5cdFx0Ly8gcmF0aGVyIGFsbCB0aGUgd2F5P1xuXHRcdHJldHVybiB0aGlzLl9wYXJlbnQuY2xvc3VyZSgpOyAvLyB0aGlzIGlzIGltcG9ydGFudD9cblx0fTtcblx0XG5cdEZsb3dTY29wZS5wcm90b3R5cGUuY29udGV4dCA9IGZ1bmN0aW9uICgpe1xuXHRcdC8vIGlmIHdlIGFyZSB3cmFwcGluZyBpbiBhbiBleHByZXNzaW9uIC0gd2UgZG8gbmVlZCB0byBhZGQgYSByZWZlcmVuY2Vcblx0XHQvLyBAcmVmZXJlbmNlZCA9IHllc1xuXHRcdHJldHVybiB0aGlzLnBhcmVudCgpLmNvbnRleHQoKTtcblx0XHQvLyB1c3VhbGx5IC0gaWYgdGhlIHBhcmVudCBzY29wZSBpcyBhIGNsb3NlZCBzY29wZSB3ZSBkb250IHJlYWxseSBuZWVkXG5cdFx0Ly8gdG8gZm9yY2UgYSByZWZlcmVuY2Vcblx0XHQvLyBAY29udGV4dCB8fD0gcGFyZW50LmNvbnRleHQucmVmZXJlbmNlKHNlbGYpXG5cdH07XG5cdFxuXHRmdW5jdGlvbiBDYXRjaFNjb3BlKCl7IHJldHVybiBGbG93U2NvcGUuYXBwbHkodGhpcyxhcmd1bWVudHMpIH07XG5cdFxuXHRzdWJjbGFzcyQoQ2F0Y2hTY29wZSxGbG93U2NvcGUpO1xuXHRleHBvcnRzLkNhdGNoU2NvcGUgPSBDYXRjaFNjb3BlOyAvLyBleHBvcnQgY2xhc3MgXG5cdFxuXHRcblx0ZnVuY3Rpb24gV2hpbGVTY29wZSgpeyByZXR1cm4gRmxvd1Njb3BlLmFwcGx5KHRoaXMsYXJndW1lbnRzKSB9O1xuXHRcblx0c3ViY2xhc3MkKFdoaWxlU2NvcGUsRmxvd1Njb3BlKTtcblx0ZXhwb3J0cy5XaGlsZVNjb3BlID0gV2hpbGVTY29wZTsgLy8gZXhwb3J0IGNsYXNzIFxuXHRXaGlsZVNjb3BlLnByb3RvdHlwZS5hdXRvZGVjbGFyZSA9IGZ1bmN0aW9uICh2YXJpYWJsZSl7XG5cdFx0cmV0dXJuIHRoaXMudmFycygpLnB1c2godmFyaWFibGUpO1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gRm9yU2NvcGUoKXsgcmV0dXJuIEZsb3dTY29wZS5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XG5cdHN1YmNsYXNzJChGb3JTY29wZSxGbG93U2NvcGUpO1xuXHRleHBvcnRzLkZvclNjb3BlID0gRm9yU2NvcGU7IC8vIGV4cG9ydCBjbGFzcyBcblx0Rm9yU2NvcGUucHJvdG90eXBlLmF1dG9kZWNsYXJlID0gZnVuY3Rpb24gKHZhcmlhYmxlKXtcblx0XHRyZXR1cm4gdGhpcy52YXJzKCkucHVzaCh2YXJpYWJsZSk7XG5cdFx0Ly8gcGFyZW50LmF1dG9kZWNsYXJlKHZhcmlhYmxlKVxuXHR9O1xuXHRcblx0Ly8gZGVmIGNsb3N1cmVcblx0Ly8gXHRzZWxmXG5cdDtcblx0XG5cdGZ1bmN0aW9uIElmU2NvcGUoKXsgcmV0dXJuIEZsb3dTY29wZS5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XG5cdHN1YmNsYXNzJChJZlNjb3BlLEZsb3dTY29wZSk7XG5cdGV4cG9ydHMuSWZTY29wZSA9IElmU2NvcGU7IC8vIGV4cG9ydCBjbGFzcyBcblx0SWZTY29wZS5wcm90b3R5cGUudGVtcG9yYXJ5ID0gZnVuY3Rpb24gKHJlZm5vZGUsbyxuYW1lKXtcblx0XHRpZihvID09PSB1bmRlZmluZWQpIG8gPSB7fTtcblx0XHRpZihuYW1lID09PSB1bmRlZmluZWQpIG5hbWUgPSBudWxsO1xuXHRcdHJldHVybiB0aGlzLnBhcmVudCgpLnRlbXBvcmFyeShyZWZub2RlLG8sbmFtZSk7XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBCbG9ja1Njb3BlKCl7IHJldHVybiBGbG93U2NvcGUuYXBwbHkodGhpcyxhcmd1bWVudHMpIH07XG5cdFxuXHRzdWJjbGFzcyQoQmxvY2tTY29wZSxGbG93U2NvcGUpO1xuXHRleHBvcnRzLkJsb2NrU2NvcGUgPSBCbG9ja1Njb3BlOyAvLyBleHBvcnQgY2xhc3MgXG5cdEJsb2NrU2NvcGUucHJvdG90eXBlLnRlbXBvcmFyeSA9IGZ1bmN0aW9uIChyZWZub2RlLG8sbmFtZSl7XG5cdFx0aWYobyA9PT0gdW5kZWZpbmVkKSBvID0ge307XG5cdFx0aWYobmFtZSA9PT0gdW5kZWZpbmVkKSBuYW1lID0gbnVsbDtcblx0XHRyZXR1cm4gdGhpcy5wYXJlbnQoKS50ZW1wb3JhcnkocmVmbm9kZSxvLG5hbWUpO1xuXHR9O1xuXHRcblx0QmxvY2tTY29wZS5wcm90b3R5cGUucmVnaW9uID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMubm9kZSgpLnJlZ2lvbigpO1xuXHR9O1xuXHRcblx0Ly8gbGl2ZXMgaW4gc2NvcGUgLS0gcmVhbGx5IGEgbm9kZT8/P1xuXHRmdW5jdGlvbiBWYXJpYWJsZShzY29wZSxuYW1lLGRlY2wsbyl7XG5cdFx0dGhpcy5fcmVmID0gU1RBQ0suX2NvdW50ZXIrKztcblx0XHR0aGlzLl9jID0gbnVsbDtcblx0XHR0aGlzLl9zY29wZSA9IHNjb3BlO1xuXHRcdHRoaXMuX25hbWUgPSBuYW1lO1xuXHRcdHRoaXMuX2FsaWFzID0gbnVsbDtcblx0XHR0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG5cdFx0dGhpcy5fZGVjbGFyYXRvciA9IGRlY2w7XG5cdFx0dGhpcy5fYXV0b2RlY2xhcmUgPSBmYWxzZTtcblx0XHR0aGlzLl9kZWNsYXJlZCA9IG8gJiYgby5kZWNsYXJlZCB8fCBmYWxzZTtcblx0XHR0aGlzLl9yZXNvbHZlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX29wdGlvbnMgPSBvIHx8IHt9O1xuXHRcdHRoaXMuX3R5cGUgPSBvICYmIG8udHlwZSB8fCAndmFyJzsgLy8gd2hhdCBhYm91dCBsZXQgaGVyZT1cblx0XHR0aGlzLl9leHBvcnQgPSBmYWxzZTtcblx0XHR0aGlzLl9yZWZlcmVuY2VzID0gW107IC8vIG9ubHkgbmVlZGVkIHdoZW4gcHJvZmlsaW5nXG5cdFx0dGhpcy5fYXNzaWdubWVudHMgPSBbXTtcblx0XHR0aGlzO1xuXHR9O1xuXHRcblx0c3ViY2xhc3MkKFZhcmlhYmxlLE5vZGUpO1xuXHRleHBvcnRzLlZhcmlhYmxlID0gVmFyaWFibGU7IC8vIGV4cG9ydCBjbGFzcyBcblx0VmFyaWFibGUucHJvdG90eXBlLnNjb3BlID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9zY29wZTsgfVxuXHRWYXJpYWJsZS5wcm90b3R5cGUuc2V0U2NvcGUgPSBmdW5jdGlvbih2KXsgdGhpcy5fc2NvcGUgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0VmFyaWFibGUucHJvdG90eXBlLm5hbWUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX25hbWU7IH1cblx0VmFyaWFibGUucHJvdG90eXBlLnNldE5hbWUgPSBmdW5jdGlvbih2KXsgdGhpcy5fbmFtZSA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRWYXJpYWJsZS5wcm90b3R5cGUuYWxpYXMgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2FsaWFzOyB9XG5cdFZhcmlhYmxlLnByb3RvdHlwZS5zZXRBbGlhcyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9hbGlhcyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRWYXJpYWJsZS5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fdHlwZTsgfVxuXHRWYXJpYWJsZS5wcm90b3R5cGUuc2V0VHlwZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl90eXBlID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFZhcmlhYmxlLnByb3RvdHlwZS5vcHRpb25zID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9vcHRpb25zOyB9XG5cdFZhcmlhYmxlLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24odil7IHRoaXMuX29wdGlvbnMgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0VmFyaWFibGUucHJvdG90eXBlLmluaXRpYWxpemVkID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9pbml0aWFsaXplZDsgfVxuXHRWYXJpYWJsZS5wcm90b3R5cGUuc2V0SW5pdGlhbGl6ZWQgPSBmdW5jdGlvbih2KXsgdGhpcy5faW5pdGlhbGl6ZWQgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0VmFyaWFibGUucHJvdG90eXBlLmRlY2xhcmVkID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9kZWNsYXJlZDsgfVxuXHRWYXJpYWJsZS5wcm90b3R5cGUuc2V0RGVjbGFyZWQgPSBmdW5jdGlvbih2KXsgdGhpcy5fZGVjbGFyZWQgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0VmFyaWFibGUucHJvdG90eXBlLmRlY2xhcmF0b3IgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2RlY2xhcmF0b3I7IH1cblx0VmFyaWFibGUucHJvdG90eXBlLnNldERlY2xhcmF0b3IgPSBmdW5jdGlvbih2KXsgdGhpcy5fZGVjbGFyYXRvciA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRWYXJpYWJsZS5wcm90b3R5cGUuYXV0b2RlY2xhcmUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2F1dG9kZWNsYXJlOyB9XG5cdFZhcmlhYmxlLnByb3RvdHlwZS5zZXRBdXRvZGVjbGFyZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9hdXRvZGVjbGFyZSA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRWYXJpYWJsZS5wcm90b3R5cGUucmVmZXJlbmNlcyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fcmVmZXJlbmNlczsgfVxuXHRWYXJpYWJsZS5wcm90b3R5cGUuc2V0UmVmZXJlbmNlcyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9yZWZlcmVuY2VzID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFZhcmlhYmxlLnByb3RvdHlwZS5leHBvcnQgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2V4cG9ydDsgfVxuXHRWYXJpYWJsZS5wcm90b3R5cGUuc2V0RXhwb3J0ID0gZnVuY3Rpb24odil7IHRoaXMuX2V4cG9ydCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0VmFyaWFibGUucHJvdG90eXBlLnBvb2wgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblx0XG5cdFZhcmlhYmxlLnByb3RvdHlwZS5jbG9zdXJlID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3Njb3BlLmNsb3N1cmUoKTtcblx0fTtcblx0XG5cdFZhcmlhYmxlLnByb3RvdHlwZS5hc3NpZ25tZW50cyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9hc3NpZ25tZW50cztcblx0fTtcblx0XG5cdC8vIEhlcmUgd2UgY2FuIGNvbGxlY3QgbG90cyBvZiB0eXBlLWluZm8gYWJvdXQgdmFyaWFibGVzXG5cdC8vIGFuZCBzaG93IHdhcm5pbmdzIC8gZ2l2ZSBhZHZpY2UgaWYgdmFyaWFibGVzIGFyZSBhbWJpZ3VvdXMgZXRjXG5cdFZhcmlhYmxlLnByb3RvdHlwZS5hc3NpZ25lZCA9IGZ1bmN0aW9uICh2YWwsc291cmNlKXtcblx0XHR0aGlzLl9hc3NpZ25tZW50cy5wdXNoKHZhbCk7XG5cdFx0Ly8gcCBcIlZhcmlhYmxlIHdhcyBhc3NpZ25lZCB7dmFsfVwiXG5cdFx0aWYgKHZhbCBpbnN0YW5jZW9mIEFycikge1xuXHRcdFx0Ly8ganVzdCBmb3IgdGVzdGluZyByZWFsbHlcblx0XHRcdHRoaXMuX2lzQXJyYXkgPSB0cnVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9pc0FycmF5ID0gZmFsc2U7XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFZhcmlhYmxlLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gKHNjb3BlLGZvcmNlKXtcblx0XHRpZihzY29wZSA9PT0gdW5kZWZpbmVkKSBzY29wZSA9IHRoaXMuc2NvcGUoKTtcblx0XHRpZihmb3JjZSA9PT0gdW5kZWZpbmVkKSBmb3JjZSA9IGZhbHNlO1xuXHRcdGlmICh0aGlzLl9yZXNvbHZlZCAmJiAhZm9yY2UpIHsgcmV0dXJuIHRoaXMgfTtcblx0XHRcblx0XHR0aGlzLl9yZXNvbHZlZCA9IHRydWU7XG5cdFx0dmFyIGNsb3N1cmUgPSB0aGlzLl9zY29wZS5jbG9zdXJlKCk7XG5cdFx0dmFyIGl0ZW0gPSBzY29wZS5sb29rdXAodGhpcy5fbmFtZSk7XG5cdFx0XG5cdFx0Ly8gaWYgdGhpcyBpcyBhIGxldC1kZWZpbml0aW9uIGluc2lkZSBhIHZpcnR1YWwgc2NvcGUgd2UgZG8gbmVlZFxuXHRcdC8vIFxuXHRcdGlmICh0aGlzLl9zY29wZSAhPSBjbG9zdXJlICYmIHRoaXMuX3R5cGUgPT0gJ2xldCcpIHsgLy8gb3IgaWYgaXQgaXMgYSBzeXN0ZW0tdmFyaWFibGVcblx0XHRcdC8vIHAgXCJzY29wZSBpcyBub3QgdGhlIGNsb3N1cmUgLS0gbmVlZCB0byByZXNvbHZlIHtAbmFtZX1cIlxuXHRcdFx0aXRlbSA9IGNsb3N1cmUubG9va3VwKHRoaXMuX25hbWUpO1xuXHRcdFx0XG5cdFx0XHQvLyB3ZSBub3cgbmVlZCB0byBlbnN1cmUgdGhhdCB0aGlzIHZhcmlhYmxlIGlzIHVuaXF1ZSBpbnNpZGVcblx0XHRcdC8vIHRoZSB3aG9sZSBjbG9zdXJlLlxuXHRcdFx0c2NvcGUgPSBjbG9zdXJlO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gcCBcInNjb3BlIGlzIG5vdCB0aGUgY2xvc3VyZSAtLSBuZWVkIHRvIHJlc29sdmUge0BuYW1lfSB7QHR5cGV9XCJcblx0XHRcblx0XHRpZiAoaXRlbSA9PSB0aGlzKSB7XG5cdFx0XHRzY29wZS52YXJtYXAoKVt0aGlzLl9uYW1lXSA9IHRoaXM7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9IGVsc2UgaWYgKGl0ZW0pIHtcblx0XHRcdC8vIHAgXCJ2YXJpYWJsZSBhbHJlYWR5IGV4aXN0cyB7QG5hbWV9XCJcblx0XHRcdFxuXHRcdFx0Ly8gcG9zc2libHkgcmVkZWZpbmUgdGhpcyBpbnNpZGUsIHVzZSBpdCBvbmx5IGluIHRoaXMgc2NvcGVcblx0XHRcdC8vIGlmIHRoZSBpdGVtIGlzIGRlZmluZWQgaW4gYW4gb3V0ZXIgc2NvcGUgLSB3ZSByZXNlcnZlIHRoZVxuXHRcdFx0aWYgKGl0ZW0uc2NvcGUoKSAhPSBzY29wZSAmJiAodGhpcy5vcHRpb25zKCkubGV0IHx8IHRoaXMuX3R5cGUgPT0gJ2xldCcpKSB7XG5cdFx0XHRcdC8vIHAgXCJvdmVycmlkZSB2YXJpYWJsZSBpbnNpZGUgdGhpcyBzY29wZSB7QG5hbWV9XCJcblx0XHRcdFx0c2NvcGUudmFybWFwKClbdGhpcy5fbmFtZV0gPSB0aGlzO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Ly8gZGlmZmVyZW50IHJ1bGVzIGZvciBkaWZmZXJlbnQgdmFyaWFibGVzP1xuXHRcdFx0aWYgKHRoaXMuX29wdGlvbnMucHJveHkpIHtcblx0XHRcdFx0Ly8gcCBcImlzIHByb3h5IC0tIG5vIG5lZWQgdG8gY2hhbmdlIG5hbWUhISEge25hbWV9XCIuY3lhblxuXHRcdFx0XHR0cnVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0XHR2YXIgb3JpZyA9IHRoaXMuX25hbWU7XG5cdFx0XHRcdC8vIGl0IGlzIHRoZSBjbG9zdXJlIHRoYXQgd2Ugc2hvdWxkIHVzZVxuXHRcdFx0XHR3aGlsZSAoc2NvcGUubG9va3VwKHRoaXMuX25hbWUpKXtcblx0XHRcdFx0XHR0aGlzLl9uYW1lID0gKFwiXCIgKyBvcmlnICsgKGkgKz0gMSkpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIGluZWZmaWNpZW50IGRvdWJsZSBzZXR0aW5nXG5cdFx0c2NvcGUudmFybWFwKClbdGhpcy5fbmFtZV0gPSB0aGlzO1xuXHRcdGNsb3N1cmUudmFybWFwKClbdGhpcy5fbmFtZV0gPSB0aGlzO1xuXHRcdHJldHVybiB0aGlzO1xuXHRcdC8vIHAgXCJyZXNvbHZlIHZhcmlhYmxlXCIuY3lhblxuXHR9O1xuXHRcblx0VmFyaWFibGUucHJvdG90eXBlLnJlZmVyZW5jZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0VmFyaWFibGUucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFZhcmlhYmxlLnByb3RvdHlwZS50cmF2ZXJzZSA9IGZ1bmN0aW9uICgpe1xuXHRcdC8vIE5PREVTLnB1c2goc2VsZilcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFZhcmlhYmxlLnByb3RvdHlwZS5mcmVlID0gZnVuY3Rpb24gKHJlZil7XG5cdFx0Ly8gcCBcImZyZWUgdmFyaWFibGUhXCJcblx0XHR0aGlzLl9kZWNsYXJhdG9yID0gbnVsbDtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFZhcmlhYmxlLnByb3RvdHlwZS5yZXVzZSA9IGZ1bmN0aW9uIChyZWYpe1xuXHRcdHRoaXMuX2RlY2xhcmF0b3IgPSByZWY7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRWYXJpYWJsZS5wcm90b3R5cGUucHJveHkgPSBmdW5jdGlvbiAocGFyLGluZGV4KXtcblx0XHR0aGlzLl9wcm94eSA9IFtwYXIsaW5kZXhdO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0VmFyaWFibGUucHJvdG90eXBlLnJlZmNvdW50ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3JlZmVyZW5jZXMubGVuZ3RoO1xuXHR9O1xuXHRcblx0VmFyaWFibGUucHJvdG90eXBlLmMgPSBmdW5jdGlvbiAoKXtcblx0XHRpZiAodGhpcy5fYykgeyByZXR1cm4gdGhpcy5fYyB9O1xuXHRcdC8vIG9wdGlvbnMgLSBwcm94eT8/XG5cdFx0aWYgKHRoaXMuX3Byb3h5KSB7XG5cdFx0XHQvLyBwIFwidmFyIGlzIHByb3hpZWQhXCIsQHByb3h5XG5cdFx0XHR0aGlzLl9jID0gdGhpcy5fcHJveHlbMF0uYygpICsgJ1snICsgdGhpcy5fcHJveHlbMV0uYygpICsgJ10nO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIXRoaXMuX3Jlc29sdmVkKSB0aGlzLnJlc29sdmUoKTtcblx0XHRcdHZhciB2ID0gKHRoaXMuYWxpYXMoKSB8fCB0aGlzLm5hbWUoKSk7XG5cdFx0XHR0aGlzLl9jID0gdHlwZW9mIHYgPT0gJ3N0cmluZycgPyAodikgOiAodi5jKCkpO1xuXHRcdFx0Ly8gYWxsb3cgY2VydGFpbiByZXNlcnZlZCB3b3Jkc1xuXHRcdFx0Ly8gc2hvdWxkIHdhcm4gb24gb3RoZXJzIHRob3VnaCAoISEhKVxuXHRcdFx0Ly8gaWYgQGMgPT0gJ25ldydcblx0XHRcdC8vIFx0QGMgPSAnX25ldydcblx0XHRcdC8vIFx0IyBzaG91bGQgaGFwcGVuIGF0IGVhcmxpZXIgc3RhZ2UgdG9cblx0XHRcdC8vIFx0IyBnZXQgYXJvdW5kIG5hbWluZyBjb252ZW50aW9uc1xuXHRcdFx0aWYgKFJFU0VSVkVEX1JFR0VYLnRlc3QodGhpcy5fYykpIHsgdGhpcy5fYyA9IChcIlwiICsgdGhpcy5jKCkgKyBcIiRcIikgfTsgLy8gQGMubWF0Y2goL14oZGVmYXVsdCkkLylcblx0XHR9O1xuXHRcdHJldHVybiB0aGlzLl9jO1xuXHR9O1xuXHRcblx0Ly8gdmFyaWFibGVzIHNob3VsZCBwcm9iYWJseSBpbmhlcml0IGZyb20gbm9kZSghKVxuXHRWYXJpYWJsZS5wcm90b3R5cGUuY29uc3VtZSA9IGZ1bmN0aW9uIChub2RlKXtcblx0XHQvLyBwIFwidmFyaWFibGUgYXNzaWduaWZ5ISEhXCJcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8vIHRoaXMgc2hvdWxkIG9ubHkgZ2VuZXJhdGUgdGhlIGFjY2Vzc29ycyAtIG5vdCBkYWVsIHdpdGggcmVmZXJlbmNlc1xuXHRWYXJpYWJsZS5wcm90b3R5cGUuYWNjZXNzb3IgPSBmdW5jdGlvbiAocmVmKXtcblx0XHR2YXIgbm9kZSA9IG5ldyBMb2NhbFZhckFjY2VzcyhcIi5cIixudWxsLHRoaXMpOyAvLyB0aGlzIGlzIGp1c3Qgd3JvbmcgLi4gc2hvdWxkIG5vdCBiZSBhIHJlZ3VsYXIgYWNjZXNzb3Jcblx0XHQvLyBAcmVmZXJlbmNlcy5wdXNoKFtyZWYsZWxdKSBpZiByZWYgIyB3ZWlyZCB0ZW1wIGZvcm1hdFxuXHRcdHJldHVybiBub2RlO1xuXHR9O1xuXHRcblx0VmFyaWFibGUucHJvdG90eXBlLmFzc2lnbm1lbnQgPSBmdW5jdGlvbiAodmFsKXtcblx0XHRyZXR1cm4gbmV3IEFzc2lnbignPScsdGhpcyx2YWwpO1xuXHR9O1xuXHRcblx0VmFyaWFibGUucHJvdG90eXBlLmFkZFJlZmVyZW5jZSA9IGZ1bmN0aW9uIChyZWYpe1xuXHRcdGlmIChyZWYgaW5zdGFuY2VvZiBJZGVudGlmaWVyKSB7XG5cdFx0XHRyZWYucmVmZXJlbmNlcyh0aGlzKTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmIChyZWYucmVnaW9uICYmIHJlZi5yZWdpb24oKSkge1xuXHRcdFx0dGhpcy5fcmVmZXJlbmNlcy5wdXNoKHJlZik7XG5cdFx0fTtcblx0XHRcblx0XHQvLyBwIFwicmVmZXJlbmNlIGlzIHtyZWY6cmVnaW9uIGFuZCByZWYucmVnaW9ufVwiXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRWYXJpYWJsZS5wcm90b3R5cGUuYXV0b2RlY2xhcmUgPSBmdW5jdGlvbiAoKXtcblx0XHRpZiAodGhpcy5fZGVjbGFyZWQpIHsgcmV0dXJuIHRoaXMgfTtcblx0XHQvLyBwIFwidmFyaWFibGUgc2hvdWxkIGF1dG9kZWNsYXJlKCEpIHtuYW1lfVwiXG5cdFx0dGhpcy5fYXV0b2RlY2xhcmUgPSB0cnVlO1xuXHRcdHRoaXMuc2NvcGUoKS5hdXRvZGVjbGFyZSh0aGlzKTtcblx0XHR0aGlzLl9kZWNsYXJlZCA9IHRydWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRWYXJpYWJsZS5wcm90b3R5cGUucHJlZGVjbGFyZWQgPSBmdW5jdGlvbiAoKXtcblx0XHR0aGlzLl9kZWNsYXJlZCA9IHRydWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRcblx0VmFyaWFibGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIFN0cmluZyh0aGlzLm5hbWUoKSk7XG5cdH07XG5cdFxuXHRWYXJpYWJsZS5wcm90b3R5cGUuZHVtcCA9IGZ1bmN0aW9uICh0eXApe1xuXHRcdHZhciBuYW1lID0gdGhpcy5uYW1lKCk7XG5cdFx0aWYgKG5hbWVbMF0ubWF0Y2goL1tBLVpdLykpIHsgcmV0dXJuIG51bGwgfTtcblx0XHQvLyBjb25zb2xlLmxvZyBcImR1bXAgdmFyaWFibGUgb2YgdHlwZSB7dHlwZX0gLSB7bmFtZX1cIlxuXHRcdHJldHVybiB7XG5cdFx0XHR0eXBlOiB0aGlzLnR5cGUoKSxcblx0XHRcdG5hbWU6IG5hbWUsXG5cdFx0XHRyZWZzOiBkdW1wX18odGhpcy5fcmVmZXJlbmNlcyx0eXApXG5cdFx0fTtcblx0fTtcblx0XG5cdFxuXHRmdW5jdGlvbiBTeXN0ZW1WYXJpYWJsZSgpeyByZXR1cm4gVmFyaWFibGUuYXBwbHkodGhpcyxhcmd1bWVudHMpIH07XG5cdFxuXHRzdWJjbGFzcyQoU3lzdGVtVmFyaWFibGUsVmFyaWFibGUpO1xuXHRleHBvcnRzLlN5c3RlbVZhcmlhYmxlID0gU3lzdGVtVmFyaWFibGU7IC8vIGV4cG9ydCBjbGFzcyBcblx0U3lzdGVtVmFyaWFibGUucHJvdG90eXBlLnBvb2wgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fb3B0aW9ucy5wb29sO1xuXHR9O1xuXHRcblx0Ly8gd2VpcmQgbmFtZSBmb3IgdGhpc1xuXHRTeXN0ZW1WYXJpYWJsZS5wcm90b3R5cGUucHJlZGVjbGFyZWQgPSBmdW5jdGlvbiAoKXtcblx0XHQvLyBwIFwicmVtb3ZlIHZhciBmcm9tIHNjb3BlKCEpXCJcblx0XHR0aGlzLnNjb3BlKCkudmFycygpLnJlbW92ZSh0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFN5c3RlbVZhcmlhYmxlLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIGFsaWFzLCB2Xztcblx0XHRpZiAodGhpcy5fcmVzb2x2ZWQgfHwgdGhpcy5fbmFtZSkgeyByZXR1cm4gdGhpcyB9O1xuXHRcdC8vIHAgXCJSRVNPTFZFIFNZU1RFTSBWQVJJQUJMRVwiLnJlZFxuXHRcdHRoaXMuX3Jlc29sdmVkID0gdHJ1ZTtcblx0XHQvLyB1bmxlc3MgQG5hbWVcblx0XHQvLyBhZGRzIGEgdmVyeSByYW5kb20gaW5pdGlhbCBuYW1lXG5cdFx0Ly8gdGhlIGF1dG8tbWFnaWNhbCBnb2VzIGxhc3QsIG9yIGF0IGxlYXN0LCBwb3NzaWJseSByZXVzZSBvdGhlciBuYW1lc1xuXHRcdC8vIFwiJHtNYXRoLmZsb29yKE1hdGgucmFuZG9tICogMTAwMCl9XCJcblx0XHRcblx0XHR2YXIgdHlwID0gdGhpcy5fb3B0aW9ucy5wb29sO1xuXHRcdHZhciBuYW1lcyA9IFtdLmNvbmNhdCh0aGlzLl9vcHRpb25zLm5hbWVzKTtcblx0XHR2YXIgYWx0ID0gbnVsbDtcblx0XHR2YXIgbm9kZSA9IG51bGw7XG5cdFx0XG5cdFx0dmFyIHNjb3BlID0gdGhpcy5zY29wZSgpO1xuXHRcdFxuXHRcdGlmICh0eXAgPT0gJ3RhZycpIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdHdoaWxlICghdGhpcy5fbmFtZSl7XG5cdFx0XHRcdGFsdCA9IChcInRcIiArIChpKyspKTtcblx0XHRcdFx0aWYgKCFzY29wZS5sb29rdXAoYWx0KSkgeyB0aGlzLl9uYW1lID0gYWx0IH07XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSBpZiAodHlwID09ICdpdGVyJykge1xuXHRcdFx0bmFtZXMgPSBbJ2FyeV9fJywnYXJ5XycsJ2NvbGwnLCdhcnJheScsJ2l0ZW1zJywnYXJ5J107XG5cdFx0fSBlbHNlIGlmICh0eXAgPT0gJ3ZhbCcpIHtcblx0XHRcdG5hbWVzID0gWyd2XyddO1xuXHRcdH0gZWxzZSBpZiAodHlwID09ICdhcmd1bWVudHMnKSB7XG5cdFx0XHRuYW1lcyA9IFsnJF8nLCckMCddO1xuXHRcdH0gZWxzZSBpZiAodHlwID09ICdrZXlwYXJzJykge1xuXHRcdFx0bmFtZXMgPSBbJ29wdHMnLCdvcHRpb25zJywncGFycyddO1xuXHRcdH0gZWxzZSBpZiAodHlwID09ICdjb3VudGVyJykge1xuXHRcdFx0bmFtZXMgPSBbJ2lfXycsJ2lfJywnaycsJ2onLCdpJ107XG5cdFx0fSBlbHNlIGlmICh0eXAgPT0gJ2xlbicpIHtcblx0XHRcdG5hbWVzID0gWydsZW5fXycsJ2xlbl8nLCdsZW4nXTtcblx0XHR9IGVsc2UgaWYgKHR5cCA9PSAnbGlzdCcpIHtcblx0XHRcdG5hbWVzID0gWyd0bXBsaXN0XycsJ3RtcGxpc3QnLCd0bXAnXTtcblx0XHR9O1xuXHRcdC8vIG9yIGlmIHR5cGUgcGxhY2Vob2xkZXIgLyBjYWNoZXIgKGFkZCAwKVxuXHRcdFxuXHRcdHdoaWxlICghdGhpcy5fbmFtZSAmJiAoYWx0ID0gbmFtZXMucG9wKCkpKXtcblx0XHRcdGlmICghc2NvcGUubG9va3VwKGFsdCkpIHsgdGhpcy5fbmFtZSA9IGFsdCB9O1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKCF0aGlzLl9uYW1lICYmIHRoaXMuX2RlY2xhcmF0b3IpIHtcblx0XHRcdGlmIChub2RlID0gdGhpcy5kZWNsYXJhdG9yKCkubm9kZSgpKSB7XG5cdFx0XHRcdGlmIChhbGlhcyA9IG5vZGUuYWxpYXMoKSkgeyBuYW1lcy5wdXNoKGFsaWFzICsgXCJfXCIpIH07XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0d2hpbGUgKCF0aGlzLl9uYW1lICYmIChhbHQgPSBuYW1lcy5wb3AoKSkpe1xuXHRcdFx0aWYgKCFzY29wZS5sb29rdXAoYWx0KSkgeyB0aGlzLl9uYW1lID0gYWx0IH07XG5cdFx0fTtcblx0XHRcblx0XHQvLyBwIFwic3VnZ2VzdGVkIG5hbWVzIHtuYW1lcy5qb2luKFwiICwgXCIpfSB7bm9kZX1cIi5jeWFuXG5cdFx0Ly8gIE1hdGguZmxvb3IoTWF0aC5yYW5kb20gKiAxMDAwKVxuXHRcdHRoaXMuX25hbWUgfHwgKHRoaXMuX25hbWUgPSAoXCIkXCIgKyAoc2NvcGUuc2V0Q291bnRlcih2XyA9IHNjb3BlLmNvdW50ZXIoKSArIDEpLHZfKSkpO1xuXHRcdC8vIHAgXCJuYW1lIGZvciB2YXJpYWJsZSBpcyB7QG5hbWV9XCJcblx0XHRzY29wZS52YXJtYXAoKVt0aGlzLl9uYW1lXSA9IHRoaXM7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRTeXN0ZW1WYXJpYWJsZS5wcm90b3R5cGUubmFtZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHRoaXMucmVzb2x2ZSgpO1xuXHRcdHJldHVybiB0aGlzLl9uYW1lO1xuXHR9O1xuXHRcblx0XG5cdGZ1bmN0aW9uIFNjb3BlQ29udGV4dChzY29wZSx2YWx1ZSl7XG5cdFx0dGhpcy5fc2NvcGUgPSBzY29wZTtcblx0XHR0aGlzLl92YWx1ZSA9IHZhbHVlO1xuXHRcdHRoaXMuX3JlZmVyZW5jZSA9IG51bGw7XG5cdFx0dGhpcztcblx0fTtcblx0XG5cdHN1YmNsYXNzJChTY29wZUNvbnRleHQsTm9kZSk7XG5cdGV4cG9ydHMuU2NvcGVDb250ZXh0ID0gU2NvcGVDb250ZXh0OyAvLyBleHBvcnQgY2xhc3MgXG5cdFNjb3BlQ29udGV4dC5wcm90b3R5cGUuc2NvcGUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3Njb3BlOyB9XG5cdFNjb3BlQ29udGV4dC5wcm90b3R5cGUuc2V0U2NvcGUgPSBmdW5jdGlvbih2KXsgdGhpcy5fc2NvcGUgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0U2NvcGVDb250ZXh0LnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fdmFsdWU7IH1cblx0U2NvcGVDb250ZXh0LnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl92YWx1ZSA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0U2NvcGVDb250ZXh0LnByb3RvdHlwZS5uYW1lcGF0aCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9zY29wZS5uYW1lcGF0aCgpO1xuXHR9O1xuXHRcblx0Ly8gaW5zdGVhZCBvZiBhbGwgdGhlc2UgcmVmZXJlbmNlcyB3ZSBzaG91bGQgcHJvYmFibHlcblx0Ly8ganVzdCByZWdpc3RlciB3aGVuIGl0IGlzIGFjY2Vzc2VkIC8gbG9va2VkIHVwIGZyb21cblx0Ly8gYSBkZWVwZXIgZnVuY3Rpb24tc2NvcGUsIGFuZCB3aGVuIGl0IGlzLCB3ZSBzaG91bGRcblx0Ly8gcmVnaXN0ZXIgdGhlIHZhcmlhYmxlIGluIHNjb3BlLCBhbmQgdGhlbiBzdGFydCB0b1xuXHQvLyB1c2UgdGhhdCBmb3IgZnVydGhlciByZWZlcmVuY2VzLiBNaWdodCBjbGVhbiB0aGluZ3Ncblx0Ly8gdXAgZm9yIHRoZSBjYXNlcyB3aGVyZSB3ZSBoYXZlIHlldCB0byBkZWNpZGUgdGhlXG5cdC8vIG5hbWUgb2YgdGhlIHZhcmlhYmxlIGV0Yz9cblx0XG5cdFNjb3BlQ29udGV4dC5wcm90b3R5cGUucmVmZXJlbmNlID0gZnVuY3Rpb24gKCl7XG5cdFx0Ly8gcCBcInAgcmVmZXJlbmNlIHtTVEFDSy5zY29waW5nfVwiXG5cdFx0Ly8gc2hvdWxkIGJlIGEgc3BlY2lhbCBjb250ZXh0LXZhcmlhYmxlISEhXG5cdFx0cmV0dXJuIHRoaXMuX3JlZmVyZW5jZSB8fCAodGhpcy5fcmVmZXJlbmNlID0gdGhpcy5zY29wZSgpLmRlY2xhcmUoXCJzZWxmXCIsbmV3IFRoaXMoKSkpO1xuXHR9O1xuXHRcblx0U2NvcGVDb250ZXh0LnByb3RvdHlwZS5jID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHZhbCA9IHRoaXMuX3ZhbHVlIHx8IHRoaXMuX3JlZmVyZW5jZTtcblx0XHRyZXR1cm4gdmFsID8gKHZhbC5jKCkpIDogKFwidGhpc1wiKTtcblx0fTtcblx0XG5cdFNjb3BlQ29udGV4dC5wcm90b3R5cGUuY2FjaGUgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdGZ1bmN0aW9uIFJvb3RTY29wZUNvbnRleHQoKXsgcmV0dXJuIFNjb3BlQ29udGV4dC5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XG5cdHN1YmNsYXNzJChSb290U2NvcGVDb250ZXh0LFNjb3BlQ29udGV4dCk7XG5cdGV4cG9ydHMuUm9vdFNjb3BlQ29udGV4dCA9IFJvb3RTY29wZUNvbnRleHQ7IC8vIGV4cG9ydCBjbGFzcyBcblx0Um9vdFNjb3BlQ29udGV4dC5wcm90b3R5cGUuYyA9IGZ1bmN0aW9uIChvKXtcblx0XHQvLyByZXR1cm4gXCJcIiBpZiBvIGFuZCBvOmV4cGxpY2l0XG5cdFx0dmFyIHZhbCA9IHRoaXMuX3ZhbHVlIHx8IHRoaXMuX3JlZmVyZW5jZTtcblx0XHRyZXR1cm4gKHZhbCAmJiB2YWwgIT0gdGhpcykgPyAodmFsLmMoKSkgOiAoXCJ0aGlzXCIpO1xuXHRcdC8vIHNob3VsZCBiZSB0aGUgb3RoZXIgd2F5IGFyb3VuZCwgbm8/XG5cdFx0Ly8gbyBhbmQgbzpleHBsaWNpdCA/IHN1cGVyIDogXCJcIlxuXHR9O1xuXHRcblx0ZnVuY3Rpb24gU3VwZXIoKXsgcmV0dXJuIE5vZGUuYXBwbHkodGhpcyxhcmd1bWVudHMpIH07XG5cdFxuXHRzdWJjbGFzcyQoU3VwZXIsTm9kZSk7XG5cdGV4cG9ydHMuU3VwZXIgPSBTdXBlcjsgLy8gZXhwb3J0IGNsYXNzIFxuXHRTdXBlci5wcm90b3R5cGUuYyA9IGZ1bmN0aW9uICgpe1xuXHRcdC8vIG5lZWQgdG8gZmluZCB0aGUgc3R1ZmYgaGVyZVxuXHRcdC8vIHRoaXMgaXMgcmVhbGx5IG5vdCB0aGF0IGdvb2Q4XG5cdFx0dmFyIG0gPSBTVEFDSy5tZXRob2QoKTtcblx0XHR2YXIgb3V0ID0gbnVsbDtcblx0XHR2YXIgdXAgPSBTVEFDSy5jdXJyZW50KCk7XG5cdFx0dmFyIGRlZXAgPSAodXAgaW5zdGFuY2VvZiBBY2Nlc3MpO1xuXHRcdFxuXHRcdC8vIFRPRE8gb3B0aW1pemF0aW9uIGZvciBsYXRlciAtIHByb2JsZW1hdGljIGlmIHRoZXJlIGlzIGEgZGlmZmVyZW50IHJlZmVyZW5jZSBpbiB0aGUgZW5kXG5cdFx0aWYgKGZhbHNlICYmIG0gJiYgbS50eXBlKCkgPT0gJ2NvbnN0cnVjdG9yJykge1xuXHRcdFx0b3V0ID0gKFwiXCIgKyAobS50YXJnZXQoKS5jKCkpICsgXCIuc3VwZXJjbGFzc1wiKTtcblx0XHRcdGlmICghZGVlcCkgeyBvdXQgKz0gKFwiLmFwcGx5KFwiICsgKG0uc2NvcGUoKS5jb250ZXh0KCkuYygpKSArIFwiLGFyZ3VtZW50cylcIikgfTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0b3V0ID0gKFwiXCIgKyAobS50YXJnZXQoKS5jKCkpICsgXCIuX19zdXBlcl9fXCIpO1xuXHRcdFx0aWYgKCEoKHVwIGluc3RhbmNlb2YgQWNjZXNzKSkpIHtcblx0XHRcdFx0b3V0ICs9IChcIi5cIiArIGNfXyhtLnN1cGVybmFtZSgpKSk7XG5cdFx0XHRcdGlmICghKCh1cCBpbnN0YW5jZW9mIENhbGwpKSkgeyAvLyBhdXRvY2FsbD9cblx0XHRcdFx0XHRvdXQgKz0gKFwiLmFwcGx5KFwiICsgKG0uc2NvcGUoKS5jb250ZXh0KCkuYygpKSArIFwiLGFyZ3VtZW50cylcIik7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0cmV0dXJuIG91dDtcblx0fTtcblx0XG5cdC8vIGNvbnN0YW50c1xuXHRcblx0bW9kdWxlLmV4cG9ydHMuQlIgPSBCUiA9IG5ldyBOZXdsaW5lKCdcXG4nKTtcblx0bW9kdWxlLmV4cG9ydHMuQlIyID0gQlIyID0gbmV3IE5ld2xpbmUoJ1xcblxcbicpO1xuXHRtb2R1bGUuZXhwb3J0cy5TRUxGID0gU0VMRiA9IG5ldyBTZWxmKCk7XG5cdG1vZHVsZS5leHBvcnRzLlNVUEVSID0gU1VQRVIgPSBuZXcgU3VwZXIoKTtcblx0XG5cdG1vZHVsZS5leHBvcnRzLlRSVUUgPSBUUlVFID0gbmV3IFRydWUoJ3RydWUnKTtcblx0bW9kdWxlLmV4cG9ydHMuRkFMU0UgPSBGQUxTRSA9IG5ldyBGYWxzZSgnZmFsc2UnKTtcblx0bW9kdWxlLmV4cG9ydHMuVU5ERUZJTkVEID0gVU5ERUZJTkVEID0gbmV3IFVuZGVmaW5lZCgpO1xuXHRtb2R1bGUuZXhwb3J0cy5OSUwgPSBOSUwgPSBuZXcgTmlsKCk7XG5cdFxuXHRtb2R1bGUuZXhwb3J0cy5BUkdVTUVOVFMgPSBBUkdVTUVOVFMgPSBuZXcgQXJnc1JlZmVyZW5jZSgnYXJndW1lbnRzJyk7XG5cdG1vZHVsZS5leHBvcnRzLkVNUFRZID0gRU1QVFkgPSAnJztcblx0bW9kdWxlLmV4cG9ydHMuTlVMTCA9IE5VTEwgPSAnbnVsbCc7XG5cdFxuXHRtb2R1bGUuZXhwb3J0cy5SRVNFUlZFRCA9IFJFU0VSVkVEID0gWydkZWZhdWx0JywnbmF0aXZlJywnZW51bScsJ3dpdGgnXTtcblx0bW9kdWxlLmV4cG9ydHMuUkVTRVJWRURfUkVHRVggPSBSRVNFUlZFRF9SRUdFWCA9IC9eKGRlZmF1bHR8bmF0aXZlfGVudW18d2l0aHxuZXd8Y2hhcikkLztcblx0XG5cdG1vZHVsZS5leHBvcnRzLlVOSU9OID0gVU5JT04gPSBuZXcgQ29uc3QoJ3VuaW9uJCcpO1xuXHRtb2R1bGUuZXhwb3J0cy5JTlRFUlNFQ1QgPSBJTlRFUlNFQ1QgPSBuZXcgQ29uc3QoJ2ludGVyc2VjdCQnKTtcblx0bW9kdWxlLmV4cG9ydHMuQ0xBU1NERUYgPSBDTEFTU0RFRiA9IG5ldyBDb25zdCgnaW1iYSRjbGFzcycpO1xuXHRtb2R1bGUuZXhwb3J0cy5UQUdERUYgPSBUQUdERUYgPSBuZXcgQ29uc3QoJ0ltYmEuVEFHUy5kZWZpbmUnKTtcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzLk5FV1RBRyA9IE5FV1RBRyA9IG5ldyBJZGVudGlmaWVyKFwidGFnJFwiKTtcblx0XG5cdFxuXHRcblx0XG5cdFxuXHRcblx0XG5cdFxuXHRcblx0XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2NvbXBpbGVyL25vZGVzLmltYmFcbiAqKiBtb2R1bGUgaWQgPSA4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0XG5cdGZ1bmN0aW9uIGJyYWNlKHN0cil7XG5cdFx0dmFyIGxpbmVzID0gc3RyLm1hdGNoKC9cXG4vKTtcblx0XHQvLyB3aGF0IGFib3V0IGluZGVudGF0aW9uP1xuXHRcdFxuXHRcdGlmIChsaW5lcykge1xuXHRcdFx0cmV0dXJuICd7JyArIHN0ciArICdcXG59Jztcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuICd7XFxuJyArIHN0ciArICdcXG59Jztcblx0XHR9O1xuXHR9OyBleHBvcnRzLmJyYWNlID0gYnJhY2U7XG5cdFxuXHRmdW5jdGlvbiBub3JtYWxpemVJbmRlbnRhdGlvbihzdHIpe1xuXHRcdHZhciBtO1xuXHRcdHZhciByZWcgPSAvXFxuKyhbXlxcblxcU10qKS9nO1xuXHRcdHZhciBpbmQgPSBudWxsO1xuXHRcdFxuXHRcdHZhciBsZW5ndGhfO3doaWxlIChtID0gcmVnLmV4ZWMoc3RyKSl7XG5cdFx0XHR2YXIgYXR0ZW1wdCA9IG1bMV07XG5cdFx0XHRpZiAoaW5kID09IG51bGwgfHwgMCA8IChsZW5ndGhfID0gYXR0ZW1wdC5sZW5ndGgpICYmIGxlbmd0aF8gPCBpbmQubGVuZ3RoKSB7XG5cdFx0XHRcdGluZCA9IGF0dGVtcHQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKGluZCkgeyBzdHIgPSBzdHIucmVwbGFjZShSZWdFeHAoKFwiXFxcXG5cIiArIGluZCksXCJnXCIpLCdcXG4nKSB9O1xuXHRcdHJldHVybiBzdHI7XG5cdH07IGV4cG9ydHMubm9ybWFsaXplSW5kZW50YXRpb24gPSBub3JtYWxpemVJbmRlbnRhdGlvbjtcblx0XG5cdFxuXHRmdW5jdGlvbiBmbGF0dGVuKGFycil7XG5cdFx0dmFyIG91dCA9IFtdO1xuXHRcdGFyci5mb3JFYWNoKGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHYgaW5zdGFuY2VvZiBBcnJheSA/IChvdXQucHVzaC5hcHBseShvdXQsZmxhdHRlbih2KSkpIDogKG91dC5wdXNoKHYpKTsgfSk7XG5cdFx0cmV0dXJuIG91dDtcblx0fTsgZXhwb3J0cy5mbGF0dGVuID0gZmxhdHRlbjtcblx0XG5cdFxuXHRmdW5jdGlvbiBwYXNjYWxDYXNlKHN0cil7XG5cdFx0cmV0dXJuIHN0ci5yZXBsYWNlKC8oXnxbXFwtXFxfXFxzXSkoXFx3KS9nLGZ1bmN0aW9uKG0sdixsKSB7IHJldHVybiBsLnRvVXBwZXJDYXNlKCk7IH0pO1xuXHR9OyBleHBvcnRzLnBhc2NhbENhc2UgPSBwYXNjYWxDYXNlO1xuXHRcblx0ZnVuY3Rpb24gY2FtZWxDYXNlKHN0cil7XG5cdFx0c3RyID0gU3RyaW5nKHN0cik7XG5cdFx0Ly8gc2hvdWxkIGFkZCBzaG9ydGN1dCBvdXRcblx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoLyhbXFwtXFxfXFxzXSkoXFx3KS9nLGZ1bmN0aW9uKG0sdixsKSB7IHJldHVybiBsLnRvVXBwZXJDYXNlKCk7IH0pO1xuXHR9OyBleHBvcnRzLmNhbWVsQ2FzZSA9IGNhbWVsQ2FzZTtcblx0XG5cdGZ1bmN0aW9uIHNuYWtlQ2FzZShzdHIpe1xuXHRcdHZhciBzdHIgPSBzdHIucmVwbGFjZSgvKFtcXC1cXHNdKShcXHcpL2csJ18nKTtcblx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoLygpKFtBLVpdKS9nLFwiXyQxXCIsZnVuY3Rpb24obSx2LGwpIHsgcmV0dXJuIGwudG9VcHBlckNhc2UoKTsgfSk7XG5cdH07IGV4cG9ydHMuc25ha2VDYXNlID0gc25ha2VDYXNlO1xuXHRcblx0ZnVuY3Rpb24gc2V0dGVyU3ltKHN5bSl7XG5cdFx0cmV0dXJuIGNhbWVsQ2FzZSgoXCJzZXQtXCIgKyBzeW0pKTtcblx0fTsgZXhwb3J0cy5zZXR0ZXJTeW0gPSBzZXR0ZXJTeW07XG5cdFxuXHRmdW5jdGlvbiBxdW90ZShzdHIpe1xuXHRcdHJldHVybiAnXCInICsgc3RyICsgJ1wiJztcblx0fTsgZXhwb3J0cy5xdW90ZSA9IHF1b3RlO1xuXHRcblx0ZnVuY3Rpb24gc2luZ2xlcXVvdGUoc3RyKXtcblx0XHRyZXR1cm4gXCInXCIgKyBzdHIgKyBcIidcIjtcblx0fTsgZXhwb3J0cy5zaW5nbGVxdW90ZSA9IHNpbmdsZXF1b3RlO1xuXHRcblx0ZnVuY3Rpb24gc3ltYm9saXplKHN0cil7XG5cdFx0c3RyID0gU3RyaW5nKHN0cik7XG5cdFx0dmFyIGVuZCA9IHN0ci5jaGFyQXQoc3RyLmxlbmd0aCAtIDEpO1xuXHRcdFxuXHRcdGlmIChlbmQgPT0gJz0nKSB7XG5cdFx0XHRzdHIgPSAnc2V0JyArIHN0clswXS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEsLTEpO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKHN0ci5pbmRleE9mKFwiLVwiKSA+PSAwKSB7XG5cdFx0XHRzdHIgPSBzdHIucmVwbGFjZSgvKFtcXC1cXHNdKShcXHcpL2csZnVuY3Rpb24obSx2LGwpIHsgcmV0dXJuIGwudG9VcHBlckNhc2UoKTsgfSk7XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gc3RyO1xuXHR9OyBleHBvcnRzLnN5bWJvbGl6ZSA9IHN5bWJvbGl6ZTtcblx0XG5cdFxuXHRmdW5jdGlvbiBpbmRlbnQoc3RyKXtcblx0XHRyZXR1cm4gU3RyaW5nKHN0cikucmVwbGFjZSgvXi9nLFwiXFx0XCIpLnJlcGxhY2UoL1xcbi9nLFwiXFxuXFx0XCIpLnJlcGxhY2UoL1xcblxcdCQvZyxcIlxcblwiKTtcblx0fTsgZXhwb3J0cy5pbmRlbnQgPSBpbmRlbnQ7XG5cdFxuXHRmdW5jdGlvbiBicmFja2V0aXplKHN0cixpbmQpe1xuXHRcdGlmKGluZCA9PT0gdW5kZWZpbmVkKSBpbmQgPSB0cnVlO1xuXHRcdGlmIChpbmQpIHsgc3RyID0gXCJcXG5cIiArIGluZGVudChzdHIpICsgXCJcXG5cIiB9O1xuXHRcdHJldHVybiAneycgKyBzdHIgKyAnfSc7XG5cdH07IGV4cG9ydHMuYnJhY2tldGl6ZSA9IGJyYWNrZXRpemU7XG5cdFxuXHRmdW5jdGlvbiBwYXJlbnRoZXNpemUoc3RyKXtcblx0XHRyZXR1cm4gJygnICsgU3RyaW5nKHN0cikgKyAnKSc7XG5cdH07IGV4cG9ydHMucGFyZW50aGVzaXplID0gcGFyZW50aGVzaXplO1xuXHRcblx0ZnVuY3Rpb24gbG9jYXRpb25Ub0xpbmVDb2xNYXAoY29kZSl7XG5cdFx0dmFyIGxpbmVzID0gY29kZS5zcGxpdCgvXFxuL2cpO1xuXHRcdHZhciBtYXAgPSBbXTtcblx0XHRcblx0XHR2YXIgY2hyO1xuXHRcdHZhciBsb2MgPSAwO1xuXHRcdHZhciBjb2wgPSAwO1xuXHRcdHZhciBsaW5lID0gMDtcblx0XHRcblx0XHR3aGlsZSAoY2hyID0gY29kZVtsb2NdKXtcblx0XHRcdG1hcFtsb2NdID0gW2xpbmUsY29sXTtcblx0XHRcdFxuXHRcdFx0aWYgKGNociA9PSAnXFxuJykge1xuXHRcdFx0XHRsaW5lKys7XG5cdFx0XHRcdGNvbCA9IDA7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb2wrKztcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGxvYysrO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIG1hcDtcblx0fTsgZXhwb3J0cy5sb2NhdGlvblRvTGluZUNvbE1hcCA9IGxvY2F0aW9uVG9MaW5lQ29sTWFwO1xuXHRcblx0ZnVuY3Rpb24gbWFya0xpbmVDb2xGb3JUb2tlbnModG9rZW5zLGNvZGUpe1xuXHRcdHJldHVybiB0aGlzO1xuXHR9OyBleHBvcnRzLm1hcmtMaW5lQ29sRm9yVG9rZW5zID0gbWFya0xpbmVDb2xGb3JUb2tlbnM7OyByZXR1cm4gbWFya0xpbmVDb2xGb3JUb2tlbnM7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2NvbXBpbGVyL2hlbHBlcnMuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRmdW5jdGlvbiBpdGVyJChhKXsgcmV0dXJuIGEgPyAoYS50b0FycmF5ID8gYS50b0FycmF5KCkgOiBhKSA6IFtdOyB9O1xuXHRcblx0dmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5cdHZhciB1dGlsID0gcmVxdWlyZSgnLi9oZWxwZXJzJyk7XG5cdFxuXHRmdW5jdGlvbiBTb3VyY2VNYXAoc291cmNlKXtcblx0XHR0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XG5cdFx0dGhpcy5fbWFwcyA9IFtdO1xuXHRcdHRoaXMuX21hcCA9IFwiXCI7XG5cdFx0dGhpcy5fanMgPSBcIlwiO1xuXHR9O1xuXHRcblx0ZXhwb3J0cy5Tb3VyY2VNYXAgPSBTb3VyY2VNYXA7IC8vIGV4cG9ydCBjbGFzcyBcblx0U291cmNlTWFwLnByb3RvdHlwZS5zb3VyY2UgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fc291cmNlO1xuXHR9O1xuXHRcblx0U291cmNlTWFwLnByb3RvdHlwZS5vcHRpb25zID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3NvdXJjZTtcblx0fTtcblx0XG5cdFNvdXJjZU1hcC5wcm90b3R5cGUuZmlsZW5hbWUgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zKCkub3B0aW9ucy5maWxlbmFtZTtcblx0fTtcblx0XG5cdFNvdXJjZU1hcC5wcm90b3R5cGUuc291cmNlQ29kZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMoKS5vcHRpb25zLl9zb3VyY2U7XG5cdH07XG5cdFxuXHRTb3VyY2VNYXAucHJvdG90eXBlLnRhcmdldFBhdGggPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zKCkub3B0aW9ucy50YXJnZXRQYXRoO1xuXHR9O1xuXHRcblx0U291cmNlTWFwLnByb3RvdHlwZS5zb3VyY2VQYXRoID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucygpLm9wdGlvbnMuc291cmNlUGF0aDtcblx0fTtcblx0XG5cdFNvdXJjZU1hcC5wcm90b3R5cGUuc291cmNlTmFtZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiBwYXRoLmJhc2VuYW1lKHRoaXMuc291cmNlUGF0aCgpKTtcblx0fTtcblx0XG5cdFNvdXJjZU1hcC5wcm90b3R5cGUudGFyZ2V0TmFtZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiBwYXRoLmJhc2VuYW1lKHRoaXMudGFyZ2V0UGF0aCgpKTtcblx0fTtcblx0XG5cdFxuXHRTb3VyY2VNYXAucHJvdG90eXBlLnNvdXJjZUZpbGVzID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIFt0aGlzLnNvdXJjZU5hbWUoKV07XG5cdH07XG5cdFxuXHRTb3VyY2VNYXAucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHZhciBtYXRjaGVyID0gL1xcJVxcJChcXGQqKVxcJFxcJS87XG5cdFx0dmFyIHJlcGxhY2VyID0gL14oLio/KVxcJVxcJChcXGQqKVxcJFxcJS87XG5cdFx0dmFyIGxpbmVzID0gdGhpcy5vcHRpb25zKCkuanMuc3BsaXQoL1xcbi9nKTsgLy8gd2hhdCBhYm91dCBqcz9cblx0XHQvLyByZXR1cm4gc2VsZlxuXHRcdHZhciBsb2NtYXAgPSB1dGlsLmxvY2F0aW9uVG9MaW5lQ29sTWFwKHRoaXMuc291cmNlQ29kZSgpKTtcblx0XHR0aGlzLl9tYXBzID0gW107XG5cdFx0XG5cdFx0Ly8gY29uc29sZS5sb2cgb3B0aW9uczpqc1xuXHRcdFxuXHRcdHZhciBtYXRjaDtcblx0XHQvLyBzcGxpdCB0aGUgY29kZSBpbiBsaW5lcy4gZ28gdGhyb3VnaCBlYWNoIGxpbmUgXG5cdFx0Ly8gZ28gdGhyb3VnaCB0aGUgY29kZSBsb29raW5nIGZvciBMT0MgbWFya2Vyc1xuXHRcdC8vIHJlbW92ZSBtYXJrZXJzIGFsb25nIHRoZSB3YXkgYW5kIGtlZXAgdHJhY2sgb2Zcblx0XHQvLyBjb25zb2xlLmxvZyBzb3VyY2U6anNcblx0XHRcblx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQobGluZXMpLCBsZW4gPSBhcnkubGVuZ3RoLCBsaW5lOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdC8vIGNvdWxkIHNwbGl0IG9uIHRoZXNlP1xuXHRcdFx0bGluZSA9IGFyeVtpXTtcblx0XHRcdHZhciBjb2wgPSAwO1xuXHRcdFx0dmFyIGNhcmV0ID0gMDtcblx0XHRcdFxuXHRcdFx0dGhpcy5fbWFwc1tpXSA9IFtdO1xuXHRcdFx0d2hpbGUgKGxpbmUubWF0Y2gobWF0Y2hlcikpe1xuXHRcdFx0XHRsaW5lID0gbGluZS5yZXBsYWNlKHJlcGxhY2VyLGZ1bmN0aW9uKG0scHJlLGxvYykge1xuXHRcdFx0XHRcdHZhciBsYyA9IGxvY21hcFtwYXJzZUludChsb2MpXTtcblx0XHRcdFx0XHRjYXJldCA9IHByZS5sZW5ndGg7XG5cdFx0XHRcdFx0dmFyIG1hcHBpbmcgPSBbW2xjWzBdLGxjWzFdXSxbaSxjYXJldF1dOyAvLyBzb3VyY2UgYW5kIG91dHB1dFxuXHRcdFx0XHRcdHNlbGYuX21hcHNbaV0ucHVzaChtYXBwaW5nKTtcblx0XHRcdFx0XHRyZXR1cm4gcHJlO1xuXHRcdFx0XHR9KTtcblx0XHRcdH07XG5cdFx0XHRsaW5lc1tpXSA9IGxpbmU7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHRzZWxmLnNvdXJjZSgpLmpzID0gbGluZXMuam9pbignXFxuJyk7XG5cdFx0cmV0dXJuIHNlbGY7XG5cdH07XG5cdFxuXHRTb3VyY2VNYXAucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gKCl7XG5cdFx0dGhpcy5wYXJzZSgpO1xuXHRcdFxuXHRcdHZhciBsYXN0Q29sdW1uID0gMDtcblx0XHR2YXIgbGFzdFNvdXJjZUxpbmUgPSAwO1xuXHRcdHZhciBsYXN0U291cmNlQ29sdW1uID0gMDtcblx0XHR2YXIgYnVmZmVyID0gXCJcIjtcblx0XHRcblx0XHRmb3IgKHZhciBsaW5lTnVtYmVyID0gMCwgYXJ5ID0gaXRlciQodGhpcy5fbWFwcyksIGxlbiA9IGFyeS5sZW5ndGg7IGxpbmVOdW1iZXIgPCBsZW47IGxpbmVOdW1iZXIrKykge1xuXHRcdFx0bGFzdENvbHVtbiA9IDA7XG5cdFx0XHRcblx0XHRcdGZvciAodmFyIG5yID0gMCwgaXRlbXMgPSBpdGVyJChhcnlbbGluZU51bWJlcl0pLCBsZW5fID0gaXRlbXMubGVuZ3RoLCBtYXAxOyBuciA8IGxlbl87IG5yKyspIHtcblx0XHRcdFx0bWFwMSA9IGl0ZW1zW25yXTtcblx0XHRcdFx0aWYgKG5yICE9IDApIHsgYnVmZmVyICs9ICcsJyB9O1xuXHRcdFx0XHR2YXIgc3JjID0gbWFwMVswXTtcblx0XHRcdFx0dmFyIGRlc3QgPSBtYXAxWzFdO1xuXHRcdFx0XHRcblx0XHRcdFx0YnVmZmVyICs9IHRoaXMuZW5jb2RlVmxxKGRlc3RbMV0gLSBsYXN0Q29sdW1uKTtcblx0XHRcdFx0bGFzdENvbHVtbiA9IGRlc3RbMV07XG5cdFx0XHRcdC8vIGFkZCBpbmRleFxuXHRcdFx0XHRidWZmZXIgKz0gdGhpcy5lbmNvZGVWbHEoMCk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBUaGUgc3RhcnRpbmcgbGluZSBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCByZWxhdGl2ZSB0byB0aGUgcHJldmlvdXMgc291cmNlIGxpbmUuXG5cdFx0XHRcdGJ1ZmZlciArPSB0aGlzLmVuY29kZVZscShzcmNbMF0gLSBsYXN0U291cmNlTGluZSk7XG5cdFx0XHRcdGxhc3RTb3VyY2VMaW5lID0gc3JjWzBdO1xuXHRcdFx0XHQvLyBUaGUgc3RhcnRpbmcgY29sdW1uIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIHJlbGF0aXZlIHRvIHRoZSBwcmV2aW91cyBjb2x1bW4uXG5cdFx0XHRcdGJ1ZmZlciArPSB0aGlzLmVuY29kZVZscShzcmNbMV0gLSBsYXN0U291cmNlQ29sdW1uKTtcblx0XHRcdFx0bGFzdFNvdXJjZUNvbHVtbiA9IHNyY1sxXTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGJ1ZmZlciArPSBcIjtcIjtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdHZhciByZWwgPSBwYXRoLnJlbGF0aXZlKHBhdGguZGlybmFtZSh0aGlzLnRhcmdldFBhdGgoKSksdGhpcy5zb3VyY2VQYXRoKCkpO1xuXHRcdFxuXHRcdHZhciBtYXAgPSB7XG5cdFx0XHR2ZXJzaW9uOiAzLFxuXHRcdFx0ZmlsZTogdGhpcy5zb3VyY2VOYW1lKCkucmVwbGFjZSgvXFwuaW1iYS8sJy5qcycpIHx8ICcnLFxuXHRcdFx0c291cmNlUm9vdDogdGhpcy5vcHRpb25zKCkuc291cmNlUm9vdCB8fCAnJyxcblx0XHRcdHNvdXJjZXM6IFtyZWxdLFxuXHRcdFx0c291cmNlc0NvbnRlbnQ6IFt0aGlzLnNvdXJjZUNvZGUoKV0sXG5cdFx0XHRuYW1lczogW10sXG5cdFx0XHRtYXBwaW5nczogYnVmZmVyXG5cdFx0fTtcblx0XHRcblx0XHQvLyBzb3VyY2U6c291cmNlbWFwID0gc291cmNlbWFwXG5cdFx0Ly8gdmFyIGJhc2U2NCA9IEJ1ZmZlci5uZXcoSlNPTi5zdHJpbmdpZnkobWFwKSkudG9TdHJpbmcoXCJiYXNlNjRcIilcblx0XHQvLyBzb3VyY2U6anMgKz0gXCJcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LHtiYXNlNjR9XCJcblx0XHRyZXR1cm4gbWFwO1xuXHR9O1xuXHRcblx0VkxRX1NISUZUID0gNTtcblx0VkxRX0NPTlRJTlVBVElPTl9CSVQgPSAxIDw8IFZMUV9TSElGVDtcblx0VkxRX1ZBTFVFX01BU0sgPSBWTFFfQ09OVElOVUFUSU9OX0JJVCAtIDE7XG5cdEJBU0U2NF9DSEFSUyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcblx0XG5cdC8vIGJvcnJvd2VkIGZyb20gQ29mZmVlU2NyaXB0XG5cdFNvdXJjZU1hcC5wcm90b3R5cGUuZW5jb2RlVmxxID0gZnVuY3Rpb24gKHZhbHVlKXtcblx0XHR2YXIgYW5zd2VyID0gJyc7XG5cdFx0Ly8gTGVhc3Qgc2lnbmlmaWNhbnQgYml0IHJlcHJlc2VudHMgdGhlIHNpZ24uXG5cdFx0dmFyIHNpZ25CaXQgPSB2YWx1ZSA8IDAgPyAoMSkgOiAoMCk7XG5cdFx0dmFyIG5leHRDaHVuaztcblx0XHQvLyBUaGUgbmV4dCBiaXRzIGFyZSB0aGUgYWN0dWFsIHZhbHVlLlxuXHRcdHZhciB2YWx1ZVRvRW5jb2RlID0gKE1hdGguYWJzKHZhbHVlKSA8PCAxKSArIHNpZ25CaXQ7XG5cdFx0Ly8gTWFrZSBzdXJlIHdlIGVuY29kZSBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyLCBldmVuIGlmIHZhbHVlVG9FbmNvZGUgaXMgMC5cblx0XHR3aGlsZSAodmFsdWVUb0VuY29kZSB8fCAhYW5zd2VyKXtcblx0XHRcdG5leHRDaHVuayA9IHZhbHVlVG9FbmNvZGUgJiBWTFFfVkFMVUVfTUFTSztcblx0XHRcdHZhbHVlVG9FbmNvZGUgPSB2YWx1ZVRvRW5jb2RlID4+IFZMUV9TSElGVDtcblx0XHRcdGlmICh2YWx1ZVRvRW5jb2RlKSB7XG5cdFx0XHRcdG5leHRDaHVuayB8PSBWTFFfQ09OVElOVUFUSU9OX0JJVDtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGFuc3dlciArPSB0aGlzLmVuY29kZUJhc2U2NChuZXh0Q2h1bmspO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIGFuc3dlcjtcblx0fTtcblx0XG5cdFNvdXJjZU1hcC5wcm90b3R5cGUuZW5jb2RlQmFzZTY0ID0gZnVuY3Rpb24gKHZhbHVlKXtcblx0XHRyZXR1cm4gQkFTRTY0X0NIQVJTW3ZhbHVlXTsgLy8gb3IgdGhyb3cgRXJyb3IubmV3KFwiQ2Fubm90IEJhc2U2NCBlbmNvZGUgdmFsdWU6IHt2YWx1ZX1cIilcblx0fTtcblx0cmV0dXJuIFNvdXJjZU1hcDtcblx0XG5cdFxuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21waWxlci9zb3VyY2VtYXAuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gcmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIGFycmF5IHdpdGggZGlyZWN0b3J5IG5hbWVzIHRoZXJlXG4vLyBtdXN0IGJlIG5vIHNsYXNoZXMsIGVtcHR5IGVsZW1lbnRzLCBvciBkZXZpY2UgbmFtZXMgKGM6XFwpIGluIHRoZSBhcnJheVxuLy8gKHNvIGFsc28gbm8gbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcyAtIGl0IGRvZXMgbm90IGRpc3Rpbmd1aXNoXG4vLyByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgcGF0aHMpXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheShwYXJ0cywgYWxsb3dBYm92ZVJvb3QpIHtcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGxhc3QgPSBwYXJ0c1tpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG4vLyBTcGxpdCBhIGZpbGVuYW1lIGludG8gW3Jvb3QsIGRpciwgYmFzZW5hbWUsIGV4dF0sIHVuaXggdmVyc2lvblxuLy8gJ3Jvb3QnIGlzIGp1c3QgYSBzbGFzaCwgb3Igbm90aGluZy5cbnZhciBzcGxpdFBhdGhSZSA9XG4gICAgL14oXFwvP3wpKFtcXHNcXFNdKj8pKCg/OlxcLnsxLDJ9fFteXFwvXSs/fCkoXFwuW14uXFwvXSp8KSkoPzpbXFwvXSopJC87XG52YXIgc3BsaXRQYXRoID0gZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aFJlLmV4ZWMoZmlsZW5hbWUpLnNsaWNlKDEpO1xufTtcblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKSxcbiAgICAgIHRyYWlsaW5nU2xhc2ggPSBzdWJzdHIocGF0aCwgLTEpID09PSAnLyc7XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9KS5qb2luKCcvJykpO1xufTtcblxuXG4vLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICB0byA9IGV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuXG4gIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICB9XG5cbiAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICB9XG5cbiAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcblxuICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xufTtcblxuZXhwb3J0cy5zZXAgPSAnLyc7XG5leHBvcnRzLmRlbGltaXRlciA9ICc6JztcblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgcmVzdWx0ID0gc3BsaXRQYXRoKHBhdGgpLFxuICAgICAgcm9vdCA9IHJlc3VsdFswXSxcbiAgICAgIGRpciA9IHJlc3VsdFsxXTtcblxuICBpZiAoIXJvb3QgJiYgIWRpcikge1xuICAgIC8vIE5vIGRpcm5hbWUgd2hhdHNvZXZlclxuICAgIHJldHVybiAnLic7XG4gIH1cblxuICBpZiAoZGlyKSB7XG4gICAgLy8gSXQgaGFzIGEgZGlybmFtZSwgc3RyaXAgdHJhaWxpbmcgc2xhc2hcbiAgICBkaXIgPSBkaXIuc3Vic3RyKDAsIGRpci5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIHJldHVybiByb290ICsgZGlyO1xufTtcblxuXG5leHBvcnRzLmJhc2VuYW1lID0gZnVuY3Rpb24ocGF0aCwgZXh0KSB7XG4gIHZhciBmID0gc3BsaXRQYXRoKHBhdGgpWzJdO1xuICAvLyBUT0RPOiBtYWtlIHRoaXMgY29tcGFyaXNvbiBjYXNlLWluc2Vuc2l0aXZlIG9uIHdpbmRvd3M/XG4gIGlmIChleHQgJiYgZi5zdWJzdHIoLTEgKiBleHQubGVuZ3RoKSA9PT0gZXh0KSB7XG4gICAgZiA9IGYuc3Vic3RyKDAsIGYubGVuZ3RoIC0gZXh0Lmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGY7XG59O1xuXG5cbmV4cG9ydHMuZXh0bmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aChwYXRoKVszXTtcbn07XG5cbmZ1bmN0aW9uIGZpbHRlciAoeHMsIGYpIHtcbiAgICBpZiAoeHMuZmlsdGVyKSByZXR1cm4geHMuZmlsdGVyKGYpO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmKHhzW2ldLCBpLCB4cykpIHJlcy5wdXNoKHhzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gU3RyaW5nLnByb3RvdHlwZS5zdWJzdHIgLSBuZWdhdGl2ZSBpbmRleCBkb24ndCB3b3JrIGluIElFOFxudmFyIHN1YnN0ciA9ICdhYicuc3Vic3RyKC0xKSA9PT0gJ2InXG4gICAgPyBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7IHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pIH1cbiAgICA6IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHtcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBzdHIubGVuZ3RoICsgc3RhcnQ7XG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pO1xuICAgIH1cbjtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogKHdlYnBhY2spL34vbm9kZS1saWJzLWJyb3dzZXIvfi9wYXRoLWJyb3dzZXJpZnkvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==